focal_method,test_prefix,docstring
"public static float max(final float a, final float b) {
    return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);
}","public void test0000() throws Throwable {
    float float0 = FastMath.max((float) 1610087935, (float) 1610087935);
    assertEquals(1.61008794E9F, float0, 0.01F);
}","/**
 * Compute the maximum of two values
 * @param a first value
 * @param b second value
 * @return b if a is lesser or equal to b, a otherwise
 */"
"public static long max(final long a, final long b) {
    return (a <= b) ? b : a;
}","public void test0011() throws Throwable {
    long long0 = FastMath.max((-1L), 767L);
    assertEquals(767L, long0);
}","/**
 * Compute the maximum of two values
 * @param a first value
 * @param b second value
 * @return b if a is lesser or equal to b, a otherwise
 */"
"public static double min(final double a, final double b) {
    return (a <= b) ? a : (Double.isNaN(a + b) ? Double.NaN : b);
}","public void test0022() throws Throwable {
    double double0 = FastMath.min(1.2958646899018938E-9, 1.2958646899018938E-9);
    assertEquals(1.2958646899018938E-9, double0, 0.01);
}","/**
 * Compute the minimum of two values
 * @param a first value
 * @param b second value
 * @return a if a is lesser or equal to b, b otherwise
 */"
"public static float min(final float a, final float b) {
    return (a <= b) ? a : (Float.isNaN(a + b) ? Float.NaN : b);
}","public void test0033() throws Throwable {
    float float0 = FastMath.min((-1.0F), 0.0F);
    assertEquals((-1.0F), float0, 0.01F);
}","/**
 * Compute the minimum of two values
 * @param a first value
 * @param b second value
 * @return a if a is lesser or equal to b, b otherwise
 */"
"public static long min(final long a, final long b) {
    return (a <= b) ? a : b;
}","public void test0044() throws Throwable {
    long long0 = FastMath.min(0L, 0L);
    assertEquals(0L, long0);
}","/**
 * Compute the minimum of two values
 * @param a first value
 * @param b second value
 * @return a if a is lesser or equal to b, b otherwise
 */"
"public static double floor(double x) {
    long y;
    if (x != x) {
        // NaN
        return x;
    }
    if (x >= 4503599627370496.0 || x <= -4503599627370496.0) {
        return x;
    }
    y = (long) x;
    if (x < 0 && y != x) {
        y--;
    }
    if (y == 0) {
        return x * y;
    }
    return (double) y;
}","public void test0055() throws Throwable {
    double double0 = FastMath.floor((-4.503599627370496E15));
    assertEquals((-4.503599627370496E15), double0, 0.01);
}","/**
 * Get the largest whole number smaller than x.
 * @param x number from which floor is requested
 * @return a double number f such that f is an integer f <= x < f + 1.0
 */"
"public static double nextAfter(double d, double direction) {
    // handling of some important special cases
    if (Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    } else if (d == 0) {
        return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
    }
    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
    // are handled just as normal numbers
    // split the double in raw components
    long bits = Double.doubleToLongBits(d);
    long sign = bits & 0x8000000000000000L;
    long exponent = bits & 0x7ff0000000000000L;
    long mantissa = bits & 0x000fffffffffffffL;
    if (d * (direction - d) >= 0) {
        // we should increase the mantissa
        if (mantissa == 0x000fffffffffffffL) {
            return Double.longBitsToDouble(sign | (exponent + 0x0010000000000000L));
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa + 1));
        }
    } else {
        // we should decrease the mantissa
        if (mantissa == 0L) {
            return Double.longBitsToDouble(sign | (exponent - 0x0010000000000000L) | 0x000fffffffffffffL);
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa - 1));
        }
    }
}","public void test0066() throws Throwable {
    double double0 = FastMath.nextAfter((-0.8813735870195429), (-0.8813735870195429));
    assertEquals((-0.881373587019543), double0, 0.01);
}","/**
 * Get the next machine representable number after a number, moving
 * in the direction of another number.
 * <p>
 * If <code>direction</code> is greater than or equal to<code>d</code>,
 * the smallest machine representable number strictly greater than
 * <code>d</code> is returned; otherwise the largest representable number
 * strictly less than <code>d</code> is returned.</p>
 * <p>
 * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param direction (the only important thing is whether
 * direction is greater or smaller than d)
 * @return the next machine representable number in the specified direction
 */"
"public static double atan2(double y, double x) {
    if (x != x || y != y) {
        return Double.NaN;
    }
    if (y == 0.0) {
        double result = x * y;
        double invx = 1.0 / x;
        double invy = 1.0 / y;
        if (invx == 0.0) {
            // X is infinite
            if (x > 0) {
                return 0.0;
            } else {
                return Math.PI;
            }
        }
        if (result != result) {
            // y must be infinite
            return x / y;
        }
        if (x < 0.0 || invx < 0.0) {
            if (y < 0.0 || invy < 0.0) {
                return -Math.PI;
            } else {
                return Math.PI;
            }
        } else {
            return result;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return Math.PI * 3.0 / 4.0;
        }
        return Math.PI / 2.0;
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return -Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return -Math.PI * 3.0 / 4.0;
        }
        return -Math.PI / 2.0;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return 0.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI;
        }
    }
    if (x == 0) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI / 2.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI / 2.0;
        }
    }
    if (x > 8e298 || x < -8e298) {
        // This would cause split of x to fail
        x *= 9.31322574615478515625E-10;
        y *= 9.31322574615478515625E-10;
    }
    // Split y
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    // Compute ratio r = x/y
    final double r = y / x;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    // Call atan
    double result = atan(ra, rb, x < 0);
    return result;
}","public void test0077() throws Throwable {
    double double0 = FastMath.atan2(0.0F, 3.4620039155736807E-7);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Two arguments arctangent function
 * @param y ordinate
 * @param x abscissa
 * @return phase angle of point (x,y) between -&pi; and &pi;
 */"
"public static double tan(double x) {
    boolean negative = false;
    int quadrant = 0;
    /* Take absolute value of the input */
    double xa = x;
    if (x < 0) {
        negative = true;
        xa = -xa;
    }
    /* Check for zero and negative zero */
    if (xa == 0.0) {
        long bits = Double.doubleToLongBits(x);
        if (bits < 0) {
            return -0.0;
        }
        return 0.0;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    double xb = 0;
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    if (xa > 1.5) {
        // Accurracy suffers between 1.5 and PI/2
        final double pi2a = 1.5707963267948966;
        final double pi2b = 6.123233995736766E-17;
        final double a = pi2a - xa;
        double b = -(a - pi2a + xa);
        b += pi2b - xb;
        xa = a + b;
        xb = -(xa - a - b);
        quadrant ^= 1;
        negative ^= true;
    }
    double result;
    if ((quadrant & 1) == 0) {
        result = tanQ(xa, xb, false);
    } else {
        result = -tanQ(xa, xb, true);
    }
    if (negative) {
        result = -result;
    }
    return result;
}","public void test0088() throws Throwable {
    double double0 = FastMath.tan(1.5707963267948966);
    assertEquals(1.633123935319537E16, double0, 0.01);
}","/**
 *   Tangent function
 *  @param x a number
 *  @return tan(x)
 */"
"public static double tan(double x) {
    boolean negative = false;
    int quadrant = 0;
    /* Take absolute value of the input */
    double xa = x;
    if (x < 0) {
        negative = true;
        xa = -xa;
    }
    /* Check for zero and negative zero */
    if (xa == 0.0) {
        long bits = Double.doubleToLongBits(x);
        if (bits < 0) {
            return -0.0;
        }
        return 0.0;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    double xb = 0;
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    if (xa > 1.5) {
        // Accurracy suffers between 1.5 and PI/2
        final double pi2a = 1.5707963267948966;
        final double pi2b = 6.123233995736766E-17;
        final double a = pi2a - xa;
        double b = -(a - pi2a + xa);
        b += pi2b - xb;
        xa = a + b;
        xb = -(xa - a - b);
        quadrant ^= 1;
        negative ^= true;
    }
    double result;
    if ((quadrant & 1) == 0) {
        result = tanQ(xa, xb, false);
    } else {
        result = -tanQ(xa, xb, true);
    }
    if (negative) {
        result = -result;
    }
    return result;
}","public void test0099() throws Throwable {
    double double0 = FastMath.tan(3294198.0);
    assertEquals((-0.7734333808731876), double0, 0.01);
}","/**
 *   Tangent function
 *  @param x a number
 *  @return tan(x)
 */"
"public static double cos(double x) {
    int quadrant = 0;
    /* Take absolute value of the input */
    double xa = x;
    if (x < 0) {
        xa = -xa;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    double xb = 0;
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    //if (negative)
    //  quadrant = (quadrant + 2) % 4;
    switch(quadrant) {
        case 0:
            return cosQ(xa, xb);
        case 1:
            return -sinQ(xa, xb);
        case 2:
            return -cosQ(xa, xb);
        case 3:
            return sinQ(xa, xb);
        default:
            return Double.NaN;
    }
}","public void test01010() throws Throwable {
    double double0 = FastMath.cos(3294198.0);
    assertEquals(0.7910146852024715, double0, 0.01);
}","/**
 *  Cosine function
 *  @param x a number
 *  @return cos(x)
 */"
"public static double cos(double x) {
    int quadrant = 0;
    /* Take absolute value of the input */
    double xa = x;
    if (x < 0) {
        xa = -xa;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    double xb = 0;
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    //if (negative)
    //  quadrant = (quadrant + 2) % 4;
    switch(quadrant) {
        case 0:
            return cosQ(xa, xb);
        case 1:
            return -sinQ(xa, xb);
        case 2:
            return -cosQ(xa, xb);
        case 3:
            return sinQ(xa, xb);
        default:
            return Double.NaN;
    }
}","public void test01111() throws Throwable {
    double double0 = FastMath.cos(0.0);
    assertEquals(1.0, double0, 0.01);
}","/**
 *  Cosine function
 *  @param x a number
 *  @return cos(x)
 */"
"public static double sin(double x) {
    boolean negative = false;
    int quadrant = 0;
    double xa;
    double xb = 0.0;
    /* Take absolute value of the input */
    xa = x;
    if (x < 0) {
        negative = true;
        xa = -xa;
    }
    /* Check for zero and negative zero */
    if (xa == 0.0) {
        long bits = Double.doubleToLongBits(x);
        if (bits < 0) {
            return -0.0;
        }
        return 0.0;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    if (negative) {
        // Flip bit 1
        quadrant ^= 2;
    }
    switch(quadrant) {
        case 0:
            return sinQ(xa, xb);
        case 1:
            return cosQ(xa, xb);
        case 2:
            return -sinQ(xa, xb);
        case 3:
            return -cosQ(xa, xb);
        default:
            return Double.NaN;
    }
}","public void test01212() throws Throwable {
    double double0 = FastMath.sin(3294198.0);
    assertEquals((-0.6117971622964877), double0, 0.01);
}","/**
 *  Sine function.
 *  @param x a number
 *  @return sin(x)
 */"
"public static double sin(double x) {
    boolean negative = false;
    int quadrant = 0;
    double xa;
    double xb = 0.0;
    /* Take absolute value of the input */
    xa = x;
    if (x < 0) {
        negative = true;
        xa = -xa;
    }
    /* Check for zero and negative zero */
    if (xa == 0.0) {
        long bits = Double.doubleToLongBits(x);
        if (bits < 0) {
            return -0.0;
        }
        return 0.0;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    if (negative) {
        // Flip bit 1
        quadrant ^= 2;
    }
    switch(quadrant) {
        case 0:
            return sinQ(xa, xb);
        case 1:
            return cosQ(xa, xb);
        case 2:
            return -sinQ(xa, xb);
        case 3:
            return -cosQ(xa, xb);
        default:
            return Double.NaN;
    }
}","public void test01313() throws Throwable {
    double double0 = FastMath.sin(3.2485117458075736E278);
    assertEquals(0.9674687945516579, double0, 0.01);
}","/**
 *  Sine function.
 *  @param x a number
 *  @return sin(x)
 */"
"public static double expm1(double x) {
    return expm1(x, null);
}","public void test01414() throws Throwable {
    double double0 = FastMath.expm1(1.0);
    assertEquals(1.7182818284590453, double0, 0.01);
}","/**
 * Compute exp(x) - 1
 * @param x number to compute shifted exponential
 * @return exp(x) - 1
 */"
"public static double expm1(double x) {
    return expm1(x, null);
}","public void test01515() throws Throwable {
    double double0 = FastMath.expm1((-1.0));
    assertEquals((-0.6321205588285577), double0, 0.01);
}","/**
 * Compute exp(x) - 1
 * @param x number to compute shifted exponential
 * @return exp(x) - 1
 */"
"public static double tanh(double x) {
    boolean negate = false;
    if (x != x) {
        return x;
    }
    if (x > 20.0) {
        return 1.0;
    }
    if (x < -20) {
        return -1.0;
    }
    if (x == 0) {
        return x;
    }
    if (x < 0.0) {
        x = -x;
        negate = true;
    }
    double result;
    if (x >= 0.5) {
        double[] hiPrec = new double[2];
        // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)
        exp(x * 2.0, 0.0, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        /* Numerator */
        double na = -1.0 + ya;
        double nb = -(na + 1.0 - ya);
        double temp = na + yb;
        nb += -(temp - na - yb);
        na = temp;
        /* Denominator */
        double da = 1.0 + ya;
        double db = -(da - 1.0 - ya);
        temp = da + yb;
        db += -(temp - da - yb);
        da = temp;
        temp = da * 1073741824.0;
        double daa = da + temp - temp;
        double dab = da - daa;
        // ratio = na/da
        double ratio = na / da;
        temp = ratio * 1073741824.0;
        double ratioa = ratio + temp - temp;
        double ratiob = ratio - ratioa;
        // Correct for rounding in division
        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;
        // Account for nb
        ratiob += nb / da;
        // Account for db
        ratiob += -db * na / da / da;
        result = ratioa + ratiob;
    } else {
        double[] hiPrec = new double[2];
        // tanh(x) = expm1(2x) / (expm1(2x) + 2)
        expm1(x * 2.0, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        /* Numerator */
        double na = ya;
        double nb = yb;
        /* Denominator */
        double da = 2.0 + ya;
        double db = -(da - 2.0 - ya);
        double temp = da + yb;
        db += -(temp - da - yb);
        da = temp;
        temp = da * 1073741824.0;
        double daa = da + temp - temp;
        double dab = da - daa;
        // ratio = na/da
        double ratio = na / da;
        temp = ratio * 1073741824.0;
        double ratioa = ratio + temp - temp;
        double ratiob = ratio - ratioa;
        // Correct for rounding in division
        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;
        // Account for nb
        ratiob += nb / da;
        // Account for db
        ratiob += -db * na / da / da;
        result = ratioa + ratiob;
    }
    if (negate) {
        result = -result;
    }
    return result;
}","public void test01616() throws Throwable {
    double double0 = FastMath.tanh((-20.0));
    assertEquals((-1.0), double0, 0.01);
}","/**
 * Compute the hyperbolic tangent of a number.
 * @param x number on which evaluation is done
 * @return hyperbolic tangent of x
 */"
"public static double sinh(double x) {
    boolean negate = false;
    if (x != x) {
        return x;
    }
    if (x > 20.0) {
        return exp(x) / 2.0;
    }
    if (x < -20) {
        return -exp(-x) / 2.0;
    }
    if (x == 0) {
        return x;
    }
    if (x < 0.0) {
        x = -x;
        negate = true;
    }
    double result;
    if (x > 0.25) {
        double[] hiPrec = new double[2];
        exp(x, 0.0, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        double temp = ya * 1073741824.0;
        double yaa = ya + temp - temp;
        double yab = ya - yaa;
        // recip = 1/y
        double recip = 1.0 / ya;
        temp = recip * 1073741824.0;
        double recipa = recip + temp - temp;
        double recipb = recip - recipa;
        // Correct for rounding in division
        recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;
        // Account for yb
        recipb += -yb * recip * recip;
        recipa = -recipa;
        recipb = -recipb;
        // y = y + 1/y
        temp = ya + recipa;
        yb += -(temp - ya - recipa);
        ya = temp;
        temp = ya + recipb;
        yb += -(temp - ya - recipb);
        ya = temp;
        result = ya + yb;
        result *= 0.5;
    } else {
        double[] hiPrec = new double[2];
        expm1(x, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */
        double denom = 1.0 + ya;
        double denomr = 1.0 / denom;
        double denomb = -(denom - 1.0 - ya) + yb;
        double ratio = ya * denomr;
        double temp = ratio * 1073741824.0;
        double ra = ratio + temp - temp;
        double rb = ratio - ra;
        temp = denom * 1073741824.0;
        double za = denom + temp - temp;
        double zb = denom - za;
        rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;
        // Adjust for yb
        // numerator
        rb += yb * denomr;
        // denominator
        rb += -ya * denomb * denomr * denomr;
        // y = y - 1/y
        temp = ya + ra;
        yb += -(temp - ya - ra);
        ya = temp;
        temp = ya + rb;
        yb += -(temp - ya - rb);
        ya = temp;
        result = ya + yb;
        result *= 0.5;
    }
    if (negate) {
        result = -result;
    }
    return result;
}","public void test01717() throws Throwable {
    double double0 = FastMath.sinh((-20.0));
    assertEquals((-2.4258259770489514E8), double0, 0.01);
}","/**
 * Compute the hyperbolic sine of a number.
 * @param x number on which evaluation is done
 * @return hyperbolic sine of x
 */"
"public static double cosh(double x) {
    if (x != x) {
        return x;
    }
    if (x > 20.0) {
        return exp(x) / 2.0;
    }
    if (x < -20) {
        return exp(-x) / 2.0;
    }
    double[] hiPrec = new double[2];
    if (x < 0.0) {
        x = -x;
    }
    exp(x, 0.0, hiPrec);
    double ya = hiPrec[0] + hiPrec[1];
    double yb = -(ya - hiPrec[0] - hiPrec[1]);
    double temp = ya * 1073741824.0;
    double yaa = ya + temp - temp;
    double yab = ya - yaa;
    // recip = 1/y
    double recip = 1.0 / ya;
    temp = recip * 1073741824.0;
    double recipa = recip + temp - temp;
    double recipb = recip - recipa;
    // Correct for rounding in division
    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;
    // Account for yb
    recipb += -yb * recip * recip;
    // y = y + 1/y
    temp = ya + recipa;
    yb += -(temp - ya - recipa);
    ya = temp;
    temp = ya + recipb;
    yb += -(temp - ya - recipb);
    ya = temp;
    double result = ya + yb;
    result *= 0.5;
    return result;
}","public void test01818() throws Throwable {
    double double0 = FastMath.cosh(0.0);
    assertEquals(1.0, double0, 0.01);
}","/**
 * Compute the hyperbolic cosine of a number.
 * @param x number on which evaluation is done
 * @return hyperbolic cosine of x
 */"
"public static double toRadians(double x) {
    final double facta = 0.01745329052209854;
    final double factb = 1.997844754509471E-9;
    double temp = x * 1073741824.0;
    double xa = x + temp - temp;
    double xb = x - xa;
    return xb * factb + xb * facta + xa * factb + xa * facta;
}","public void test01919() throws Throwable {
    double double0 = FastMath.toRadians(0.0);
    assertEquals(0.0, double0, 0.01);
}","/**
 *  Convert degrees to radians, with error of less than 0.5 ULP
 *  @param x angle in degrees
 *  @return x converted into radians
 */"
"public static double toRadians(double x) {
    final double facta = 0.01745329052209854;
    final double factb = 1.997844754509471E-9;
    double temp = x * 1073741824.0;
    double xa = x + temp - temp;
    double xb = x - xa;
    return xb * factb + xb * facta + xa * factb + xa * facta;
}","public void test02020() throws Throwable {
    double double0 = FastMath.toRadians((-4460.20706341));
    assertEquals((-77.845298577212), double0, 0.01);
}","/**
 *  Convert degrees to radians, with error of less than 0.5 ULP
 *  @param x angle in degrees
 *  @return x converted into radians
 */"
"public static double toDegrees(double x) {
    final double facta = 57.2957763671875;
    final double factb = 3.145894820876798E-6;
    double temp = x * 1073741824.0;
    double xa = x + temp - temp;
    double xb = x - xa;
    return xb * factb + xb * facta + xa * factb + xa * facta;
}","public void test02121() throws Throwable {
    double double0 = FastMath.toDegrees(0.0);
    assertEquals(0.0, double0, 0.01);
}","/**
 *  Convert radians to degrees, with error of less than 0.5 ULP
 *  @param x angle in radians
 *  @return x converted into degrees
 */"
"public static double toDegrees(double x) {
    final double facta = 57.2957763671875;
    final double factb = 3.145894820876798E-6;
    double temp = x * 1073741824.0;
    double xa = x + temp - temp;
    double xb = x - xa;
    return xb * factb + xb * facta + xa * factb + xa * facta;
}","public void test02222() throws Throwable {
    double double0 = FastMath.toDegrees((-417.574158));
    assertEquals((-23925.236887129002), double0, 0.01);
}","/**
 *  Convert radians to degrees, with error of less than 0.5 ULP
 *  @param x angle in radians
 *  @return x converted into degrees
 */"
"public static double sqrt(final double a) {
    return Math.sqrt(a);
}","public void test02323() throws Throwable {
    double double0 = FastMath.sqrt(0.0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Compute the square root of a number.
 * @param a number on which evaluation is done
 * @return square root of a
 */"
"public static double sqrt(final double a) {
    return Math.sqrt(a);
}","public void test02424() throws Throwable {
    double double0 = FastMath.sqrt(3.001117512531765E-7);
    assertEquals(5.478245624770548E-4, double0, 0.01);
}","/**
 * Compute the square root of a number.
 * @param a number on which evaluation is done
 * @return square root of a
 */"
"public static int round(final float x) {
    return Math.round(x);
}","public void test02525() throws Throwable {
    int int0 = FastMath.round((float) 0L);
    assertEquals(0, int0);
}","/**
 * Get the closest int to x.
 * @param x number from which closest int is requested
 * @return closest int to x
 */"
"public static int round(final float x) {
    return Math.round(x);
}","public void test02626() throws Throwable {
    int int0 = FastMath.round((float) (-1884L));
    assertEquals((-1884), int0);
}","/**
 * Get the closest int to x.
 * @param x number from which closest int is requested
 * @return closest int to x
 */"
"public static long round(double x) {
    return (long) floor(x + 0.5);
}","public void test02727() throws Throwable {
    long long0 = FastMath.round(1.2246467991473532E-16);
    assertEquals(0L, long0);
}","/**
 * Get the closest long to x.
 * @param x number from which closest long is requested
 * @return closest long to x
 */"
"public static long round(double x) {
    return (long) floor(x + 0.5);
}","public void test02828() throws Throwable {
    long long0 = FastMath.round(539.3857692181872);
    assertEquals(539L, long0);
}","/**
 * Get the closest long to x.
 * @param x number from which closest long is requested
 * @return closest long to x
 */"
"public static double rint(double x) {
    double y = floor(x);
    double d = x - y;
    if (d > 0.5) {
        return y + 1.0;
    }
    if (d < 0.5) {
        return y;
    }
    /* half way, round to even */
    long z = (long) y;
    return (z & 1) == 0 ? y : y + 1.0;
}","public void test02929() throws Throwable {
    double double0 = FastMath.rint((-0.05417713522911072));
    assertEquals(0.0, double0, 0.01);
}","/**
 * Get the whole number that is the nearest to x, or the even one if x is exactly half way between two integers.
 * @param x number from which nearest whole number is requested
 * @return a double number r such that r is an integer r - 0.5 <= x <= r + 0.5
 */"
"public static double nextAfter(double d, double direction) {
    // handling of some important special cases
    if (Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    } else if (d == 0) {
        return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
    }
    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
    // are handled just as normal numbers
    // split the double in raw components
    long bits = Double.doubleToLongBits(d);
    long sign = bits & 0x8000000000000000L;
    long exponent = bits & 0x7ff0000000000000L;
    long mantissa = bits & 0x000fffffffffffffL;
    if (d * (direction - d) >= 0) {
        // we should increase the mantissa
        if (mantissa == 0x000fffffffffffffL) {
            return Double.longBitsToDouble(sign | (exponent + 0x0010000000000000L));
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa + 1));
        }
    } else {
        // we should decrease the mantissa
        if (mantissa == 0L) {
            return Double.longBitsToDouble(sign | (exponent - 0x0010000000000000L) | 0x000fffffffffffffL);
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa - 1));
        }
    }
}","public void test03030() throws Throwable {
    double double0 = FastMath.nextAfter((-4.9E-324), 187.384791016);
    assertEquals(-0.0, double0, 0.01);
}","/**
 * Get the next machine representable number after a number, moving
 * in the direction of another number.
 * <p>
 * If <code>direction</code> is greater than or equal to<code>d</code>,
 * the smallest machine representable number strictly greater than
 * <code>d</code> is returned; otherwise the largest representable number
 * strictly less than <code>d</code> is returned.</p>
 * <p>
 * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param direction (the only important thing is whether
 * direction is greater or smaller than d)
 * @return the next machine representable number in the specified direction
 */"
"public static long min(final long a, final long b) {
    return (a <= b) ? a : b;
}","public void test03131() throws Throwable {
    long long0 = FastMath.min((long) 4035, 1L);
    assertEquals(1L, long0);
}","/**
 * Compute the minimum of two values
 * @param a first value
 * @param b second value
 * @return a if a is lesser or equal to b, b otherwise
 */"
"public static long min(final long a, final long b) {
    return (a <= b) ? a : b;
}","public void test03232() throws Throwable {
    long long0 = FastMath.min((-2572L), 0L);
    assertEquals((-2572L), long0);
}","/**
 * Compute the minimum of two values
 * @param a first value
 * @param b second value
 * @return a if a is lesser or equal to b, b otherwise
 */"
"public static int min(final int a, final int b) {
    return (a <= b) ? a : b;
}","public void test03333() throws Throwable {
    int int0 = FastMath.min(2147477730, 2147477730);
    assertEquals(2147477730, int0);
}","/**
 * Compute the minimum of two values
 * @param a first value
 * @param b second value
 * @return a if a is lesser or equal to b, b otherwise
 */"
"public static float min(final float a, final float b) {
    return (a <= b) ? a : (Float.isNaN(a + b) ? Float.NaN : b);
}","public void test03434() throws Throwable {
    float float0 = FastMath.min(0.0F, (float) 0L);
    assertEquals(0.0F, float0, 0.01F);
}","/**
 * Compute the minimum of two values
 * @param a first value
 * @param b second value
 * @return a if a is lesser or equal to b, b otherwise
 */"
"public static float min(final float a, final float b) {
    return (a <= b) ? a : (Float.isNaN(a + b) ? Float.NaN : b);
}","public void test03535() throws Throwable {
    float float0 = FastMath.min(1974.7F, 1974.7F);
    assertEquals(1974.7F, float0, 0.01F);
}","/**
 * Compute the minimum of two values
 * @param a first value
 * @param b second value
 * @return a if a is lesser or equal to b, b otherwise
 */"
"public static double min(final double a, final double b) {
    return (a <= b) ? a : (Double.isNaN(a + b) ? Double.NaN : b);
}","public void test03636() throws Throwable {
    double double0 = FastMath.min(729.439563, (-550.19612));
    assertEquals((-550.19612), double0, 0.01);
}","/**
 * Compute the minimum of two values
 * @param a first value
 * @param b second value
 * @return a if a is lesser or equal to b, b otherwise
 */"
"public static long max(final long a, final long b) {
    return (a <= b) ? b : a;
}","public void test03737() throws Throwable {
    long long0 = FastMath.max((-3133L), (-3133L));
    assertEquals((-3133L), long0);
}","/**
 * Compute the maximum of two values
 * @param a first value
 * @param b second value
 * @return b if a is lesser or equal to b, a otherwise
 */"
"public static int max(final int a, final int b) {
    return (a <= b) ? b : a;
}","public void test03838() throws Throwable {
    int int0 = FastMath.max(0, 0);
    assertEquals(0, int0);
}","/**
 * Compute the maximum of two values
 * @param a first value
 * @param b second value
 * @return b if a is lesser or equal to b, a otherwise
 */"
"public static int max(final int a, final int b) {
    return (a <= b) ? b : a;
}","public void test03939() throws Throwable {
    int int0 = FastMath.max((-3649), (-3649));
    assertEquals((-3649), int0);
}","/**
 * Compute the maximum of two values
 * @param a first value
 * @param b second value
 * @return b if a is lesser or equal to b, a otherwise
 */"
"public static float max(final float a, final float b) {
    return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);
}","public void test04040() throws Throwable {
    float float0 = FastMath.max(0.0F, 55.96F);
    assertEquals(55.96F, float0, 0.01F);
}","/**
 * Compute the maximum of two values
 * @param a first value
 * @param b second value
 * @return b if a is lesser or equal to b, a otherwise
 */"
"public static double max(final double a, final double b) {
    return (a <= b) ? b : (Double.isNaN(a + b) ? Double.NaN : a);
}","public void test04141() throws Throwable {
    double double0 = FastMath.max((double) 0L, (double) 0L);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Compute the maximum of two values
 * @param a first value
 * @param b second value
 * @return b if a is lesser or equal to b, a otherwise
 */"
"public static double log1p(final double x) {
    double xpa = 1.0 + x;
    double xpb = -(xpa - 1.0 - x);
    if (x == -1) {
        // -Infinity
        return x / 0.0;
    }
    if (x > 0 && 1 / x == 0) {
        // x = Infinity
        return x;
    }
    if (x > 1e-6 || x < -1e-6) {
        double[] hiPrec = new double[2];
        log(xpa, hiPrec);
        /* Do a taylor series expansion around xpa */
        /* f(x+y) = f(x) + f'(x)*y + f''(x)/2 y^2 */
        double fx1 = xpb / xpa;
        double epsilon = 0.5 * fx1 + 1.0;
        epsilon = epsilon * fx1;
        return epsilon + hiPrec[1] + hiPrec[0];
    }
    /* Value is small |x| < 1e6, do a Taylor series centered on 1.0 */
    double y = x * 0.333333333333333 - 0.5;
    y = y * x + 1.0;
    y = y * x;
    return y;
}","public void test04242() throws Throwable {
    double double0 = FastMath.log1p(0.0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Compute log(1 + x).
 * @param x a number
 * @return log(1 + x)
 */"
"public static double log10(final double x) {
    final double[] hiPrec = new double[2];
    log(x, hiPrec);
    final double tmp = hiPrec[0] * 1073741824.0;
    final double lna = hiPrec[0] + tmp - tmp;
    final double lnb = hiPrec[0] - lna + hiPrec[1];
    final double rln10a = 0.4342944622039795;
    final double rln10b = 1.9699272335463627E-8;
    return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna;
}","public void test04343() throws Throwable {
    double double0 = FastMath.log10(2345.4687312242845);
    assertEquals(3.370229647495384, double0, 0.01);
}","/**
 * Compute the base 10 logarithm.
 * @param x a number
 * @return log10(x)
 */"
"public static double log10(final double x) {
    final double[] hiPrec = new double[2];
    log(x, hiPrec);
    final double tmp = hiPrec[0] * 1073741824.0;
    final double lna = hiPrec[0] + tmp - tmp;
    final double lnb = hiPrec[0] - lna + hiPrec[1];
    final double rln10a = 0.4342944622039795;
    final double rln10b = 1.9699272335463627E-8;
    return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna;
}","public void test04444() throws Throwable {
    double double0 = FastMath.log10(2.404307984052299E-9);
    assertEquals((-8.619009901391752), double0, 0.01);
}","/**
 * Compute the base 10 logarithm.
 * @param x a number
 * @return log10(x)
 */"
"public static double log(final double x) {
    return log(x, null);
}","public void test04545() throws Throwable {
    double double0 = FastMath.log(1.0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Natural logarithm.
 *
 * @param x   a double
 * @return log(x)
 */"
"public static double exp(double x) {
    return exp(x, 0.0, null);
}","public void test04646() throws Throwable {
    double double0 = FastMath.exp((-4234));
    assertEquals(0.0, double0, 0.01);
}","/**
 * Exponential function.
 *
 * Computes exp(x), function result is nearly rounded.   It will be correctly
 * rounded to the theoretical value for 99.9% of input values, otherwise it will
 * have a 1 UPL error.
 *
 * Method:
 *    Lookup intVal = exp(int(x))
 *    Lookup fracVal = exp(int(x-int(x) / 1024.0) * 1024.0 );
 *    Compute z as the exponential of the remaining bits by a polynomial minus one
 *    exp(x) = intVal * fracVal * (1 + z)
 *
 * Accuracy:
 *    Calculation is done with 63 bits of precision, so result should be correctly
 *    rounded for 99.9% of input values, with less than 1 ULP error otherwise.
 *
 * @param x   a double
 * @return double e<sup>x</sup>
 */"
"public static double ceil(double x) {
    double y;
    if (x != x) {
        // NaN
        return x;
    }
    y = floor(x);
    if (y == x) {
        return y;
    }
    y += 1.0;
    if (y == 0) {
        return x * y;
    }
    return y;
}","public void test04747() throws Throwable {
    double double0 = FastMath.ceil((-3334.19046999));
    assertEquals((-3334.0), double0, 0.01);
}","/**
 * Get the smallest whole number larger than x.
 * @param x number from which ceil is requested
 * @return a double number c such that c is an integer c - 1.0 < x <= c
 */"
"public static double cbrt(double x) {
    /* Convert input double to bits */
    long inbits = Double.doubleToLongBits(x);
    int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;
    boolean subnormal = false;
    if (exponent == -1023) {
        if (x == 0) {
            return x;
        }
        /* Subnormal, so normalize */
        subnormal = true;
        // 2^54
        x *= 1.8014398509481984E16;
        inbits = Double.doubleToLongBits(x);
        exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;
    }
    if (exponent == 1024) {
        // Nan or infinity.  Don't care which.
        return x;
    }
    /* Divide the exponent by 3 */
    int exp3 = exponent / 3;
    /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */
    double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) | (long) (((exp3 + 1023) & 0x7ff)) << 52);
    /* This will be a number between 1 and 2 */
    final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);
    /* Estimate the cube root of mant by polynomial */
    double est = -0.010714690733195933;
    est = est * mant + 0.0875862700108075;
    est = est * mant + -0.3058015757857271;
    est = est * mant + 0.7249995199969751;
    est = est * mant + 0.5039018405998233;
    est *= CBRTTWO[exponent % 3 + 2];
    // est should now be good to about 15 bits of precision.   Do 2 rounds of
    // Newton's method to get closer,  this should get us full double precision
    // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.
    final double xs = x / (p2 * p2 * p2);
    est += (xs - est * est * est) / (3 * est * est);
    est += (xs - est * est * est) / (3 * est * est);
    // Do one round of Newton's method in extended precision to get the last bit right.
    double temp = est * 1073741824.0;
    double ya = est + temp - temp;
    double yb = est - ya;
    double za = ya * ya;
    double zb = ya * yb * 2.0 + yb * yb;
    temp = za * 1073741824.0;
    double temp2 = za + temp - temp;
    zb += za - temp2;
    za = temp2;
    zb = za * yb + ya * zb + zb * yb;
    za = za * ya;
    double na = xs - za;
    double nb = -(na - xs + za);
    nb -= zb;
    est += (na + nb) / (3 * est * est);
    /* Scale by a power of two, so this is exact. */
    est *= p2;
    if (subnormal) {
        // 2^-18
        est *= 3.814697265625E-6;
    }
    return est;
}","public void test04848() throws Throwable {
    double double0 = FastMath.cbrt((-3291.630575171235));
    assertEquals((-14.87545856484684), double0, 0.01);
}","/**
 * Compute the cubic root of a number.
 * @param x number on which evaluation is done
 * @return cubic root of x
 */"
"public static double atan(double x) {
    return atan(x, 0.0, false);
}","public void test04949() throws Throwable {
    double double0 = FastMath.atan(0L);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Arctangent function
 *  @param x a number
 *  @return atan(x)
 */"
"public static double atan(double x) {
    return atan(x, 0.0, false);
}","public void test05050() throws Throwable {
    double double0 = FastMath.atan(1.8508157176809257);
    assertEquals(1.0754290375762232, double0, 0.01);
}","/**
 * Arctangent function
 *  @param x a number
 *  @return atan(x)
 */"
"public static double acosh(final double a) {
    return FastMath.log(a + FastMath.sqrt(a * a - 1));
}","public void test05151() throws Throwable {
    double double0 = FastMath.acosh(1.0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Compute the inverse hyperbolic cosine of a number.
 * @param a number on which evaluation is done
 * @return inverse hyperbolic cosine of a
 */"
"public static double acosh(final double a) {
    return FastMath.log(a + FastMath.sqrt(a * a - 1));
}","public void test05252() throws Throwable {
    double double0 = FastMath.acosh(2163.669);
    assertEquals(8.372707797938883, double0, 0.01);
}","/**
 * Compute the inverse hyperbolic cosine of a number.
 * @param a number on which evaluation is done
 * @return inverse hyperbolic cosine of a
 */"
"public static long abs(final long x) {
    return (x < 0l) ? -x : x;
}","public void test05353() throws Throwable {
    long long0 = FastMath.abs(0L);
    assertEquals(0L, long0);
}","/**
 * Absolute value.
 * @param x number from which absolute value is requested
 * @return abs(x)
 */"
"public static long abs(final long x) {
    return (x < 0l) ? -x : x;
}","public void test05454() throws Throwable {
    long long0 = FastMath.abs((-9223372036854775808L));
    assertEquals((-9223372036854775808L), long0);
}","/**
 * Absolute value.
 * @param x number from which absolute value is requested
 * @return abs(x)
 */"
"public static int abs(final int x) {
    return (x < 0) ? -x : x;
}","public void test05555() throws Throwable {
    int int0 = FastMath.abs(0);
    assertEquals(0, int0);
}","/**
 * Absolute value.
 * @param x number from which absolute value is requested
 * @return abs(x)
 */"
"public static float abs(final float x) {
    return (x < 0.0f) ? -x : x;
}","public void test05656() throws Throwable {
    float float0 = FastMath.abs((float) 0L);
    assertEquals(0.0F, float0, 0.01F);
}","/**
 * Absolute value.
 * @param x number from which absolute value is requested
 * @return abs(x)
 */"
"public static double abs(double x) {
    return (x < 0.0) ? -x : x;
}","public void test05757() throws Throwable {
    double double0 = FastMath.abs((double) 0L);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Absolute value.
 * @param x number from which absolute value is requested
 * @return abs(x)
 */"
"public static double floor(double x) {
    long y;
    if (x != x) {
        // NaN
        return x;
    }
    if (x >= 4503599627370496.0 || x <= -4503599627370496.0) {
        return x;
    }
    y = (long) x;
    if (x < 0 && y != x) {
        y--;
    }
    if (y == 0) {
        return x * y;
    }
    return (double) y;
}","public void test05858() throws Throwable {
    double double0 = FastMath.floor(0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Get the largest whole number smaller than x.
 * @param x number from which floor is requested
 * @return a double number f such that f is an integer f <= x < f + 1.0
 */"
"public static double floor(double x) {
    long y;
    if (x != x) {
        // NaN
        return x;
    }
    if (x >= 4503599627370496.0 || x <= -4503599627370496.0) {
        return x;
    }
    y = (long) x;
    if (x < 0 && y != x) {
        y--;
    }
    if (y == 0) {
        return x * y;
    }
    return (double) y;
}","public void test05959() throws Throwable {
    double double0 = FastMath.floor((-1.0));
    assertEquals((-1.0), double0, 0.01);
}","/**
 * Get the largest whole number smaller than x.
 * @param x number from which floor is requested
 * @return a double number f such that f is an integer f <= x < f + 1.0
 */"
"public static double floor(double x) {
    long y;
    if (x != x) {
        // NaN
        return x;
    }
    if (x >= 4503599627370496.0 || x <= -4503599627370496.0) {
        return x;
    }
    y = (long) x;
    if (x < 0 && y != x) {
        y--;
    }
    if (y == 0) {
        return x * y;
    }
    return (double) y;
}","public void test06060() throws Throwable {
    double double0 = FastMath.floor((-3540.46208));
    assertEquals((-3541.0), double0, 0.01);
}","/**
 * Get the largest whole number smaller than x.
 * @param x number from which floor is requested
 * @return a double number f such that f is an integer f <= x < f + 1.0
 */"
"public static double floor(double x) {
    long y;
    if (x != x) {
        // NaN
        return x;
    }
    if (x >= 4503599627370496.0 || x <= -4503599627370496.0) {
        return x;
    }
    y = (long) x;
    if (x < 0 && y != x) {
        y--;
    }
    if (y == 0) {
        return x * y;
    }
    return (double) y;
}","public void test06161() throws Throwable {
    double double0 = FastMath.floor((-9223372036854775808L));
    assertEquals((-9.223372036854776E18), double0, 0.01);
}","/**
 * Get the largest whole number smaller than x.
 * @param x number from which floor is requested
 * @return a double number f such that f is an integer f <= x < f + 1.0
 */"
"public static double floor(double x) {
    long y;
    if (x != x) {
        // NaN
        return x;
    }
    if (x >= 4503599627370496.0 || x <= -4503599627370496.0) {
        return x;
    }
    y = (long) x;
    if (x < 0 && y != x) {
        y--;
    }
    if (y == 0) {
        return x * y;
    }
    return (double) y;
}","public void test06262() throws Throwable {
    double double0 = FastMath.floor(1.0);
    assertEquals(1.0, double0, 0.01);
}","/**
 * Get the largest whole number smaller than x.
 * @param x number from which floor is requested
 * @return a double number f such that f is an integer f <= x < f + 1.0
 */"
"public static double floor(double x) {
    long y;
    if (x != x) {
        // NaN
        return x;
    }
    if (x >= 4503599627370496.0 || x <= -4503599627370496.0) {
        return x;
    }
    y = (long) x;
    if (x < 0 && y != x) {
        y--;
    }
    if (y == 0) {
        return x * y;
    }
    return (double) y;
}","public void test06363() throws Throwable {
    double double0 = FastMath.floor(Double.NaN);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Get the largest whole number smaller than x.
 * @param x number from which floor is requested
 * @return a double number f such that f is an integer f <= x < f + 1.0
 */"
"public static double nextAfter(double d, double direction) {
    // handling of some important special cases
    if (Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    } else if (d == 0) {
        return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
    }
    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
    // are handled just as normal numbers
    // split the double in raw components
    long bits = Double.doubleToLongBits(d);
    long sign = bits & 0x8000000000000000L;
    long exponent = bits & 0x7ff0000000000000L;
    long mantissa = bits & 0x000fffffffffffffL;
    if (d * (direction - d) >= 0) {
        // we should increase the mantissa
        if (mantissa == 0x000fffffffffffffL) {
            return Double.longBitsToDouble(sign | (exponent + 0x0010000000000000L));
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa + 1));
        }
    } else {
        // we should decrease the mantissa
        if (mantissa == 0L) {
            return Double.longBitsToDouble(sign | (exponent - 0x0010000000000000L) | 0x000fffffffffffffL);
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa - 1));
        }
    }
}","public void test06464() throws Throwable {
    double double0 = FastMath.nextAfter(14.136832902969902, 1.570796251296997);
    assertEquals(14.1368329029699, double0, 0.01);
}","/**
 * Get the next machine representable number after a number, moving
 * in the direction of another number.
 * <p>
 * If <code>direction</code> is greater than or equal to<code>d</code>,
 * the smallest machine representable number strictly greater than
 * <code>d</code> is returned; otherwise the largest representable number
 * strictly less than <code>d</code> is returned.</p>
 * <p>
 * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param direction (the only important thing is whether
 * direction is greater or smaller than d)
 * @return the next machine representable number in the specified direction
 */"
"public static double nextAfter(double d, double direction) {
    // handling of some important special cases
    if (Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    } else if (d == 0) {
        return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
    }
    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
    // are handled just as normal numbers
    // split the double in raw components
    long bits = Double.doubleToLongBits(d);
    long sign = bits & 0x8000000000000000L;
    long exponent = bits & 0x7ff0000000000000L;
    long mantissa = bits & 0x000fffffffffffffL;
    if (d * (direction - d) >= 0) {
        // we should increase the mantissa
        if (mantissa == 0x000fffffffffffffL) {
            return Double.longBitsToDouble(sign | (exponent + 0x0010000000000000L));
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa + 1));
        }
    } else {
        // we should decrease the mantissa
        if (mantissa == 0L) {
            return Double.longBitsToDouble(sign | (exponent - 0x0010000000000000L) | 0x000fffffffffffffL);
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa - 1));
        }
    }
}","public void test06565() throws Throwable {
    double double0 = FastMath.nextAfter(5.551115123125783E-17, 2.85040095144011776E17);
    assertEquals(5.551115123125784E-17, double0, 0.01);
}","/**
 * Get the next machine representable number after a number, moving
 * in the direction of another number.
 * <p>
 * If <code>direction</code> is greater than or equal to<code>d</code>,
 * the smallest machine representable number strictly greater than
 * <code>d</code> is returned; otherwise the largest representable number
 * strictly less than <code>d</code> is returned.</p>
 * <p>
 * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param direction (the only important thing is whether
 * direction is greater or smaller than d)
 * @return the next machine representable number in the specified direction
 */"
"public static double nextAfter(double d, double direction) {
    // handling of some important special cases
    if (Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    } else if (d == 0) {
        return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
    }
    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
    // are handled just as normal numbers
    // split the double in raw components
    long bits = Double.doubleToLongBits(d);
    long sign = bits & 0x8000000000000000L;
    long exponent = bits & 0x7ff0000000000000L;
    long mantissa = bits & 0x000fffffffffffffL;
    if (d * (direction - d) >= 0) {
        // we should increase the mantissa
        if (mantissa == 0x000fffffffffffffL) {
            return Double.longBitsToDouble(sign | (exponent + 0x0010000000000000L));
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa + 1));
        }
    } else {
        // we should decrease the mantissa
        if (mantissa == 0L) {
            return Double.longBitsToDouble(sign | (exponent - 0x0010000000000000L) | 0x000fffffffffffffL);
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa - 1));
        }
    }
}","public void test06666() throws Throwable {
    double double0 = FastMath.nextAfter(0.0F, 0.0);
    assertEquals(4.9E-324, double0, 0.01);
}","/**
 * Get the next machine representable number after a number, moving
 * in the direction of another number.
 * <p>
 * If <code>direction</code> is greater than or equal to<code>d</code>,
 * the smallest machine representable number strictly greater than
 * <code>d</code> is returned; otherwise the largest representable number
 * strictly less than <code>d</code> is returned.</p>
 * <p>
 * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param direction (the only important thing is whether
 * direction is greater or smaller than d)
 * @return the next machine representable number in the specified direction
 */"
"public static double abs(double x) {
    return (x < 0.0) ? -x : x;
}","public void test06767() throws Throwable {
    double double0 = FastMath.abs(0.08713622391223907);
    assertEquals(0.08713622391223907, double0, 0.01);
}","/**
 * Absolute value.
 * @param x number from which absolute value is requested
 * @return abs(x)
 */"
"public static double max(final double a, final double b) {
    return (a <= b) ? b : (Double.isNaN(a + b) ? Double.NaN : a);
}","public void test06868() throws Throwable {
    double double0 = FastMath.max(Double.NaN, (double) 0L);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Compute the maximum of two values
 * @param a first value
 * @param b second value
 * @return b if a is lesser or equal to b, a otherwise
 */"
"public static double max(final double a, final double b) {
    return (a <= b) ? b : (Double.isNaN(a + b) ? Double.NaN : a);
}","public void test06969() throws Throwable {
    double double0 = FastMath.max((-2294.24779888286), (-1537.2113330561938));
    assertEquals((-1537.2113330561938), double0, 0.01);
}","/**
 * Compute the maximum of two values
 * @param a first value
 * @param b second value
 * @return b if a is lesser or equal to b, a otherwise
 */"
"public static double max(final double a, final double b) {
    return (a <= b) ? b : (Double.isNaN(a + b) ? Double.NaN : a);
}","public void test07070() throws Throwable {
    double double0 = FastMath.max(0.39362657592563277, (double) 0.0F);
    assertEquals(0.39362657592563277, double0, 0.01);
}","/**
 * Compute the maximum of two values
 * @param a first value
 * @param b second value
 * @return b if a is lesser or equal to b, a otherwise
 */"
"public static float max(final float a, final float b) {
    return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);
}","public void test07171() throws Throwable {
    float float0 = FastMath.max(Float.NaN, Float.NaN);
    assertEquals(Float.NaN, float0, 0.01F);
}","/**
 * Compute the maximum of two values
 * @param a first value
 * @param b second value
 * @return b if a is lesser or equal to b, a otherwise
 */"
"public static float max(final float a, final float b) {
    return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);
}","public void test07272() throws Throwable {
    float float0 = FastMath.max((-982.0F), 0.0F);
    assertEquals(0.0F, float0, 0.01F);
}","/**
 * Compute the maximum of two values
 * @param a first value
 * @param b second value
 * @return b if a is lesser or equal to b, a otherwise
 */"
"public static float max(final float a, final float b) {
    return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);
}","public void test07373() throws Throwable {
    float float0 = FastMath.max(1003.90845F, (-1.0F));
    assertEquals((-1.0F), float0, 0.01F);
}","/**
 * Compute the maximum of two values
 * @param a first value
 * @param b second value
 * @return b if a is lesser or equal to b, a otherwise
 */"
"public static long max(final long a, final long b) {
    return (a <= b) ? b : a;
}","public void test07474() throws Throwable {
    long long0 = FastMath.max(0L, (-3133L));
    assertEquals(0L, long0);
}","/**
 * Compute the maximum of two values
 * @param a first value
 * @param b second value
 * @return b if a is lesser or equal to b, a otherwise
 */"
"public static int max(final int a, final int b) {
    return (a <= b) ? b : a;
}","public void test07575() throws Throwable {
    int int0 = FastMath.max((-1), 1820);
    assertEquals(1820, int0);
}","/**
 * Compute the maximum of two values
 * @param a first value
 * @param b second value
 * @return b if a is lesser or equal to b, a otherwise
 */"
"public static int max(final int a, final int b) {
    return (a <= b) ? b : a;
}","public void test07676() throws Throwable {
    int int0 = FastMath.max(575, (-46));
    assertEquals(575, int0);
}","/**
 * Compute the maximum of two values
 * @param a first value
 * @param b second value
 * @return b if a is lesser or equal to b, a otherwise
 */"
"public static double min(final double a, final double b) {
    return (a <= b) ? a : (Double.isNaN(a + b) ? Double.NaN : b);
}","public void test07777() throws Throwable {
    double double0 = FastMath.min(Double.NaN, (-820.0391));
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Compute the minimum of two values
 * @param a first value
 * @param b second value
 * @return a if a is lesser or equal to b, b otherwise
 */"
"public static double min(final double a, final double b) {
    return (a <= b) ? a : (Double.isNaN(a + b) ? Double.NaN : b);
}","public void test07878() throws Throwable {
    double double0 = FastMath.min(488.22003, 2734.21557215);
    assertEquals(488.22003, double0, 0.01);
}","/**
 * Compute the minimum of two values
 * @param a first value
 * @param b second value
 * @return a if a is lesser or equal to b, b otherwise
 */"
"public static double min(final double a, final double b) {
    return (a <= b) ? a : (Double.isNaN(a + b) ? Double.NaN : b);
}","public void test07979() throws Throwable {
    double double0 = FastMath.min(3415.645784369997, 0.0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Compute the minimum of two values
 * @param a first value
 * @param b second value
 * @return a if a is lesser or equal to b, b otherwise
 */"
"public static float min(final float a, final float b) {
    return (a <= b) ? a : (Float.isNaN(a + b) ? Float.NaN : b);
}","public void test08080() throws Throwable {
    float float0 = FastMath.min(0.0F, (-1439.5981F));
    assertEquals((-1439.5981F), float0, 0.01F);
}","/**
 * Compute the minimum of two values
 * @param a first value
 * @param b second value
 * @return a if a is lesser or equal to b, b otherwise
 */"
"public static float min(final float a, final float b) {
    return (a <= b) ? a : (Float.isNaN(a + b) ? Float.NaN : b);
}","public void test08181() throws Throwable {
    float float0 = FastMath.min(1.0F, Float.NaN);
    assertEquals(Float.NaN, float0, 0.01F);
}","/**
 * Compute the minimum of two values
 * @param a first value
 * @param b second value
 * @return a if a is lesser or equal to b, b otherwise
 */"
"public static int min(final int a, final int b) {
    return (a <= b) ? a : b;
}","public void test08282() throws Throwable {
    int int0 = FastMath.min((-4234), (-1831));
    assertEquals((-4234), int0);
}","/**
 * Compute the minimum of two values
 * @param a first value
 * @param b second value
 * @return a if a is lesser or equal to b, b otherwise
 */"
"public static int min(final int a, final int b) {
    return (a <= b) ? a : b;
}","public void test08383() throws Throwable {
    int int0 = FastMath.min(5, 0);
    assertEquals(0, int0);
}","/**
 * Compute the minimum of two values
 * @param a first value
 * @param b second value
 * @return a if a is lesser or equal to b, b otherwise
 */"
"public static double rint(double x) {
    double y = floor(x);
    double d = x - y;
    if (d > 0.5) {
        return y + 1.0;
    }
    if (d < 0.5) {
        return y;
    }
    /* half way, round to even */
    long z = (long) y;
    return (z & 1) == 0 ? y : y + 1.0;
}","public void test08484() throws Throwable {
    double double0 = FastMath.rint((-872.5));
    assertEquals((-872.0), double0, 0.01);
}","/**
 * Get the whole number that is the nearest to x, or the even one if x is exactly half way between two integers.
 * @param x number from which nearest whole number is requested
 * @return a double number r such that r is an integer r - 0.5 <= x <= r + 0.5
 */"
"public static double rint(double x) {
    double y = floor(x);
    double d = x - y;
    if (d > 0.5) {
        return y + 1.0;
    }
    if (d < 0.5) {
        return y;
    }
    /* half way, round to even */
    long z = (long) y;
    return (z & 1) == 0 ? y : y + 1.0;
}","public void test08585() throws Throwable {
    double double0 = FastMath.rint(0.9124657557600824);
    assertEquals(1.0, double0, 0.01);
}","/**
 * Get the whole number that is the nearest to x, or the even one if x is exactly half way between two integers.
 * @param x number from which nearest whole number is requested
 * @return a double number r such that r is an integer r - 0.5 <= x <= r + 0.5
 */"
"public static double ceil(double x) {
    double y;
    if (x != x) {
        // NaN
        return x;
    }
    y = floor(x);
    if (y == x) {
        return y;
    }
    y += 1.0;
    if (y == 0) {
        return x * y;
    }
    return y;
}","public void test08686() throws Throwable {
    double double0 = FastMath.ceil((-0.33333333333333287));
    assertEquals(-0.0, double0, 0.01);
}","/**
 * Get the smallest whole number larger than x.
 * @param x number from which ceil is requested
 * @return a double number c such that c is an integer c - 1.0 < x <= c
 */"
"public static double ceil(double x) {
    double y;
    if (x != x) {
        // NaN
        return x;
    }
    y = floor(x);
    if (y == x) {
        return y;
    }
    y += 1.0;
    if (y == 0) {
        return x * y;
    }
    return y;
}","public void test08787() throws Throwable {
    double double0 = FastMath.ceil(18.0);
    assertEquals(18.0, double0, 0.01);
}","/**
 * Get the smallest whole number larger than x.
 * @param x number from which ceil is requested
 * @return a double number c such that c is an integer c - 1.0 < x <= c
 */"
"public static double ceil(double x) {
    double y;
    if (x != x) {
        // NaN
        return x;
    }
    y = floor(x);
    if (y == x) {
        return y;
    }
    y += 1.0;
    if (y == 0) {
        return x * y;
    }
    return y;
}","public void test08888() throws Throwable {
    double double0 = FastMath.ceil(Double.NaN);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Get the smallest whole number larger than x.
 * @param x number from which ceil is requested
 * @return a double number c such that c is an integer c - 1.0 < x <= c
 */"
"public static double rint(double x) {
    double y = floor(x);
    double d = x - y;
    if (d > 0.5) {
        return y + 1.0;
    }
    if (d < 0.5) {
        return y;
    }
    /* half way, round to even */
    long z = (long) y;
    return (z & 1) == 0 ? y : y + 1.0;
}","public void test08989() throws Throwable {
    double double0 = FastMath.rint((-4234));
    assertEquals((-4234.0), double0, 0.01);
}","/**
 * Get the whole number that is the nearest to x, or the even one if x is exactly half way between two integers.
 * @param x number from which nearest whole number is requested
 * @return a double number r such that r is an integer r - 0.5 <= x <= r + 0.5
 */"
"public static double ceil(double x) {
    double y;
    if (x != x) {
        // NaN
        return x;
    }
    y = floor(x);
    if (y == x) {
        return y;
    }
    y += 1.0;
    if (y == 0) {
        return x * y;
    }
    return y;
}","public void test09090() throws Throwable {
    double double0 = FastMath.ceil(0.5463024898437905);
    assertEquals(1.0, double0, 0.01);
}","/**
 * Get the smallest whole number larger than x.
 * @param x number from which ceil is requested
 * @return a double number c such that c is an integer c - 1.0 < x <= c
 */"
"public static double rint(double x) {
    double y = floor(x);
    double d = x - y;
    if (d > 0.5) {
        return y + 1.0;
    }
    if (d < 0.5) {
        return y;
    }
    /* half way, round to even */
    long z = (long) y;
    return (z & 1) == 0 ? y : y + 1.0;
}","public void test09191() throws Throwable {
    double double0 = FastMath.rint(Double.NEGATIVE_INFINITY);
    assertEquals(Double.NEGATIVE_INFINITY, double0, 0.01);
}","/**
 * Get the whole number that is the nearest to x, or the even one if x is exactly half way between two integers.
 * @param x number from which nearest whole number is requested
 * @return a double number r such that r is an integer r - 0.5 <= x <= r + 0.5
 */"
"public static double floor(double x) {
    long y;
    if (x != x) {
        // NaN
        return x;
    }
    if (x >= 4503599627370496.0 || x <= -4503599627370496.0) {
        return x;
    }
    y = (long) x;
    if (x < 0 && y != x) {
        y--;
    }
    if (y == 0) {
        return x * y;
    }
    return (double) y;
}","public void test09292() throws Throwable {
    double double0 = FastMath.floor(Double.POSITIVE_INFINITY);
    assertEquals(Double.POSITIVE_INFINITY, double0, 0.01);
}","/**
 * Get the largest whole number smaller than x.
 * @param x number from which floor is requested
 * @return a double number f such that f is an integer f <= x < f + 1.0
 */"
"public static double nextAfter(double d, double direction) {
    // handling of some important special cases
    if (Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    } else if (d == 0) {
        return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
    }
    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
    // are handled just as normal numbers
    // split the double in raw components
    long bits = Double.doubleToLongBits(d);
    long sign = bits & 0x8000000000000000L;
    long exponent = bits & 0x7ff0000000000000L;
    long mantissa = bits & 0x000fffffffffffffL;
    if (d * (direction - d) >= 0) {
        // we should increase the mantissa
        if (mantissa == 0x000fffffffffffffL) {
            return Double.longBitsToDouble(sign | (exponent + 0x0010000000000000L));
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa + 1));
        }
    } else {
        // we should decrease the mantissa
        if (mantissa == 0L) {
            return Double.longBitsToDouble(sign | (exponent - 0x0010000000000000L) | 0x000fffffffffffffL);
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa - 1));
        }
    }
}","public void test09393() throws Throwable {
    double double0 = FastMath.nextAfter(1.0, 0.19454771280288696);
    assertEquals(0.9999999999999999, double0, 0.01);
}","/**
 * Get the next machine representable number after a number, moving
 * in the direction of another number.
 * <p>
 * If <code>direction</code> is greater than or equal to<code>d</code>,
 * the smallest machine representable number strictly greater than
 * <code>d</code> is returned; otherwise the largest representable number
 * strictly less than <code>d</code> is returned.</p>
 * <p>
 * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param direction (the only important thing is whether
 * direction is greater or smaller than d)
 * @return the next machine representable number in the specified direction
 */"
"public static double nextUp(final double a) {
    return nextAfter(a, Double.POSITIVE_INFINITY);
}","public void test09494() throws Throwable {
    double double0 = FastMath.nextUp(3398.0);
    assertEquals(3398.0000000000005, double0, 0.01);
}","/**
 * Compute next number towards positive infinity.
 * @param a number to which neighbor should be computed
 * @return neighbor of a towards positive infinity
 */"
"public static double nextAfter(double d, double direction) {
    // handling of some important special cases
    if (Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    } else if (d == 0) {
        return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
    }
    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
    // are handled just as normal numbers
    // split the double in raw components
    long bits = Double.doubleToLongBits(d);
    long sign = bits & 0x8000000000000000L;
    long exponent = bits & 0x7ff0000000000000L;
    long mantissa = bits & 0x000fffffffffffffL;
    if (d * (direction - d) >= 0) {
        // we should increase the mantissa
        if (mantissa == 0x000fffffffffffffL) {
            return Double.longBitsToDouble(sign | (exponent + 0x0010000000000000L));
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa + 1));
        }
    } else {
        // we should decrease the mantissa
        if (mantissa == 0L) {
            return Double.longBitsToDouble(sign | (exponent - 0x0010000000000000L) | 0x000fffffffffffffL);
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa - 1));
        }
    }
}","public void test09595() throws Throwable {
    double double0 = FastMath.nextAfter(0.0, (-1.570078214189996));
    assertEquals((-4.9E-324), double0, 0.01);
}","/**
 * Get the next machine representable number after a number, moving
 * in the direction of another number.
 * <p>
 * If <code>direction</code> is greater than or equal to<code>d</code>,
 * the smallest machine representable number strictly greater than
 * <code>d</code> is returned; otherwise the largest representable number
 * strictly less than <code>d</code> is returned.</p>
 * <p>
 * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param direction (the only important thing is whether
 * direction is greater or smaller than d)
 * @return the next machine representable number in the specified direction
 */"
"public static double nextUp(final double a) {
    return nextAfter(a, Double.POSITIVE_INFINITY);
}","public void test09696() throws Throwable {
    double double0 = FastMath.nextUp(0.0);
    assertEquals(4.9E-324, double0, 0.01);
}","/**
 * Compute next number towards positive infinity.
 * @param a number to which neighbor should be computed
 * @return neighbor of a towards positive infinity
 */"
"public static double nextAfter(double d, double direction) {
    // handling of some important special cases
    if (Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    } else if (d == 0) {
        return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
    }
    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
    // are handled just as normal numbers
    // split the double in raw components
    long bits = Double.doubleToLongBits(d);
    long sign = bits & 0x8000000000000000L;
    long exponent = bits & 0x7ff0000000000000L;
    long mantissa = bits & 0x000fffffffffffffL;
    if (d * (direction - d) >= 0) {
        // we should increase the mantissa
        if (mantissa == 0x000fffffffffffffL) {
            return Double.longBitsToDouble(sign | (exponent + 0x0010000000000000L));
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa + 1));
        }
    } else {
        // we should decrease the mantissa
        if (mantissa == 0L) {
            return Double.longBitsToDouble(sign | (exponent - 0x0010000000000000L) | 0x000fffffffffffffL);
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa - 1));
        }
    }
}","public void test09797() throws Throwable {
    double double0 = FastMath.nextAfter(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
    assertEquals(Double.POSITIVE_INFINITY, double0, 0.01);
}","/**
 * Get the next machine representable number after a number, moving
 * in the direction of another number.
 * <p>
 * If <code>direction</code> is greater than or equal to<code>d</code>,
 * the smallest machine representable number strictly greater than
 * <code>d</code> is returned; otherwise the largest representable number
 * strictly less than <code>d</code> is returned.</p>
 * <p>
 * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param direction (the only important thing is whether
 * direction is greater or smaller than d)
 * @return the next machine representable number in the specified direction
 */"
"public static double nextAfter(double d, double direction) {
    // handling of some important special cases
    if (Double.isNaN(d) || Double.isInfinite(d)) {
        return d;
    } else if (d == 0) {
        return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
    }
    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
    // are handled just as normal numbers
    // split the double in raw components
    long bits = Double.doubleToLongBits(d);
    long sign = bits & 0x8000000000000000L;
    long exponent = bits & 0x7ff0000000000000L;
    long mantissa = bits & 0x000fffffffffffffL;
    if (d * (direction - d) >= 0) {
        // we should increase the mantissa
        if (mantissa == 0x000fffffffffffffL) {
            return Double.longBitsToDouble(sign | (exponent + 0x0010000000000000L));
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa + 1));
        }
    } else {
        // we should decrease the mantissa
        if (mantissa == 0L) {
            return Double.longBitsToDouble(sign | (exponent - 0x0010000000000000L) | 0x000fffffffffffffL);
        } else {
            return Double.longBitsToDouble(sign | exponent | (mantissa - 1));
        }
    }
}","public void test09898() throws Throwable {
    double double0 = FastMath.nextAfter(Double.NaN, 1.0);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Get the next machine representable number after a number, moving
 * in the direction of another number.
 * <p>
 * If <code>direction</code> is greater than or equal to<code>d</code>,
 * the smallest machine representable number strictly greater than
 * <code>d</code> is returned; otherwise the largest representable number
 * strictly less than <code>d</code> is returned.</p>
 * <p>
 * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>
 *
 * @param d base number
 * @param direction (the only important thing is whether
 * direction is greater or smaller than d)
 * @return the next machine representable number in the specified direction
 */"
"public static double abs(double x) {
    return (x < 0.0) ? -x : x;
}","public void test09999() throws Throwable {
    double double0 = FastMath.abs((-1537.2113330561938));
    assertEquals(1537.2113330561938, double0, 0.01);
}","/**
 * Absolute value.
 * @param x number from which absolute value is requested
 * @return abs(x)
 */"
"public static float abs(final float x) {
    return (x < 0.0f) ? -x : x;
}","public void test100100() throws Throwable {
    float float0 = FastMath.abs((-982.0F));
    assertEquals(982.0F, float0, 0.01F);
}","/**
 * Absolute value.
 * @param x number from which absolute value is requested
 * @return abs(x)
 */"
"public static float abs(final float x) {
    return (x < 0.0f) ? -x : x;
}","public void test101101() throws Throwable {
    float float0 = FastMath.abs(2316.0F);
    assertEquals(2316.0F, float0, 0.01F);
}","/**
 * Absolute value.
 * @param x number from which absolute value is requested
 * @return abs(x)
 */"
"public static long abs(final long x) {
    return (x < 0l) ? -x : x;
}","public void test102102() throws Throwable {
    long long0 = FastMath.abs((-1386L));
    assertEquals(1386L, long0);
}","/**
 * Absolute value.
 * @param x number from which absolute value is requested
 * @return abs(x)
 */"
"public static long abs(final long x) {
    return (x < 0l) ? -x : x;
}","public void test103103() throws Throwable {
    long long0 = FastMath.abs(784L);
    assertEquals(784L, long0);
}","/**
 * Absolute value.
 * @param x number from which absolute value is requested
 * @return abs(x)
 */"
"public static int abs(final int x) {
    return (x < 0) ? -x : x;
}","public void test104104() throws Throwable {
    int int0 = FastMath.abs((-1));
    assertEquals(1, int0);
}","/**
 * Absolute value.
 * @param x number from which absolute value is requested
 * @return abs(x)
 */"
"public static int abs(final int x) {
    return (x < 0) ? -x : x;
}","public void test105105() throws Throwable {
    int int0 = FastMath.abs(1610);
    assertEquals(1610, int0);
}","/**
 * Absolute value.
 * @param x number from which absolute value is requested
 * @return abs(x)
 */"
"public static double cbrt(double x) {
    /* Convert input double to bits */
    long inbits = Double.doubleToLongBits(x);
    int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;
    boolean subnormal = false;
    if (exponent == -1023) {
        if (x == 0) {
            return x;
        }
        /* Subnormal, so normalize */
        subnormal = true;
        // 2^54
        x *= 1.8014398509481984E16;
        inbits = Double.doubleToLongBits(x);
        exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;
    }
    if (exponent == 1024) {
        // Nan or infinity.  Don't care which.
        return x;
    }
    /* Divide the exponent by 3 */
    int exp3 = exponent / 3;
    /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */
    double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) | (long) (((exp3 + 1023) & 0x7ff)) << 52);
    /* This will be a number between 1 and 2 */
    final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);
    /* Estimate the cube root of mant by polynomial */
    double est = -0.010714690733195933;
    est = est * mant + 0.0875862700108075;
    est = est * mant + -0.3058015757857271;
    est = est * mant + 0.7249995199969751;
    est = est * mant + 0.5039018405998233;
    est *= CBRTTWO[exponent % 3 + 2];
    // est should now be good to about 15 bits of precision.   Do 2 rounds of
    // Newton's method to get closer,  this should get us full double precision
    // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.
    final double xs = x / (p2 * p2 * p2);
    est += (xs - est * est * est) / (3 * est * est);
    est += (xs - est * est * est) / (3 * est * est);
    // Do one round of Newton's method in extended precision to get the last bit right.
    double temp = est * 1073741824.0;
    double ya = est + temp - temp;
    double yb = est - ya;
    double za = ya * ya;
    double zb = ya * yb * 2.0 + yb * yb;
    temp = za * 1073741824.0;
    double temp2 = za + temp - temp;
    zb += za - temp2;
    za = temp2;
    zb = za * yb + ya * zb + zb * yb;
    za = za * ya;
    double na = xs - za;
    double nb = -(na - xs + za);
    nb -= zb;
    est += (na + nb) / (3 * est * est);
    /* Scale by a power of two, so this is exact. */
    est *= p2;
    if (subnormal) {
        // 2^-18
        est *= 3.814697265625E-6;
    }
    return est;
}","public void test106106() throws Throwable {
    double double0 = FastMath.cbrt(Float.NaN);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Compute the cubic root of a number.
 * @param x number on which evaluation is done
 * @return cubic root of x
 */"
"public static double cbrt(double x) {
    /* Convert input double to bits */
    long inbits = Double.doubleToLongBits(x);
    int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;
    boolean subnormal = false;
    if (exponent == -1023) {
        if (x == 0) {
            return x;
        }
        /* Subnormal, so normalize */
        subnormal = true;
        // 2^54
        x *= 1.8014398509481984E16;
        inbits = Double.doubleToLongBits(x);
        exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;
    }
    if (exponent == 1024) {
        // Nan or infinity.  Don't care which.
        return x;
    }
    /* Divide the exponent by 3 */
    int exp3 = exponent / 3;
    /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */
    double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) | (long) (((exp3 + 1023) & 0x7ff)) << 52);
    /* This will be a number between 1 and 2 */
    final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);
    /* Estimate the cube root of mant by polynomial */
    double est = -0.010714690733195933;
    est = est * mant + 0.0875862700108075;
    est = est * mant + -0.3058015757857271;
    est = est * mant + 0.7249995199969751;
    est = est * mant + 0.5039018405998233;
    est *= CBRTTWO[exponent % 3 + 2];
    // est should now be good to about 15 bits of precision.   Do 2 rounds of
    // Newton's method to get closer,  this should get us full double precision
    // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.
    final double xs = x / (p2 * p2 * p2);
    est += (xs - est * est * est) / (3 * est * est);
    est += (xs - est * est * est) / (3 * est * est);
    // Do one round of Newton's method in extended precision to get the last bit right.
    double temp = est * 1073741824.0;
    double ya = est + temp - temp;
    double yb = est - ya;
    double za = ya * ya;
    double zb = ya * yb * 2.0 + yb * yb;
    temp = za * 1073741824.0;
    double temp2 = za + temp - temp;
    zb += za - temp2;
    za = temp2;
    zb = za * yb + ya * zb + zb * yb;
    za = za * ya;
    double na = xs - za;
    double nb = -(na - xs + za);
    nb -= zb;
    est += (na + nb) / (3 * est * est);
    /* Scale by a power of two, so this is exact. */
    est *= p2;
    if (subnormal) {
        // 2^-18
        est *= 3.814697265625E-6;
    }
    return est;
}","public void test107107() throws Throwable {
    double double0 = FastMath.cbrt(0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Compute the cubic root of a number.
 * @param x number on which evaluation is done
 * @return cubic root of x
 */"
"public static double cbrt(double x) {
    /* Convert input double to bits */
    long inbits = Double.doubleToLongBits(x);
    int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;
    boolean subnormal = false;
    if (exponent == -1023) {
        if (x == 0) {
            return x;
        }
        /* Subnormal, so normalize */
        subnormal = true;
        // 2^54
        x *= 1.8014398509481984E16;
        inbits = Double.doubleToLongBits(x);
        exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;
    }
    if (exponent == 1024) {
        // Nan or infinity.  Don't care which.
        return x;
    }
    /* Divide the exponent by 3 */
    int exp3 = exponent / 3;
    /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */
    double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) | (long) (((exp3 + 1023) & 0x7ff)) << 52);
    /* This will be a number between 1 and 2 */
    final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);
    /* Estimate the cube root of mant by polynomial */
    double est = -0.010714690733195933;
    est = est * mant + 0.0875862700108075;
    est = est * mant + -0.3058015757857271;
    est = est * mant + 0.7249995199969751;
    est = est * mant + 0.5039018405998233;
    est *= CBRTTWO[exponent % 3 + 2];
    // est should now be good to about 15 bits of precision.   Do 2 rounds of
    // Newton's method to get closer,  this should get us full double precision
    // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.
    final double xs = x / (p2 * p2 * p2);
    est += (xs - est * est * est) / (3 * est * est);
    est += (xs - est * est * est) / (3 * est * est);
    // Do one round of Newton's method in extended precision to get the last bit right.
    double temp = est * 1073741824.0;
    double ya = est + temp - temp;
    double yb = est - ya;
    double za = ya * ya;
    double zb = ya * yb * 2.0 + yb * yb;
    temp = za * 1073741824.0;
    double temp2 = za + temp - temp;
    zb += za - temp2;
    za = temp2;
    zb = za * yb + ya * zb + zb * yb;
    za = za * ya;
    double na = xs - za;
    double nb = -(na - xs + za);
    nb -= zb;
    est += (na + nb) / (3 * est * est);
    /* Scale by a power of two, so this is exact. */
    est *= p2;
    if (subnormal) {
        // 2^-18
        est *= 3.814697265625E-6;
    }
    return est;
}","public void test108108() throws Throwable {
    double double0 = FastMath.cbrt(1537.2113330561938);
    assertEquals(11.5410288289951, double0, 0.01);
}","/**
 * Compute the cubic root of a number.
 * @param x number on which evaluation is done
 * @return cubic root of x
 */"
"public static double acos(double x) {
    if (x != x) {
        return Double.NaN;
    }
    if (x > 1.0 || x < -1.0) {
        return Double.NaN;
    }
    if (x == -1.0) {
        return Math.PI;
    }
    if (x == 1.0) {
        return 0.0;
    }
    if (x == 0) {
        return Math.PI / 2.0;
    }
    /* Compute acos(x) = atan(sqrt(1-x*x)/x) */
    /* Split x */
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    /* Square it */
    double ya = xa * xa;
    double yb = xa * xb * 2.0 + xb * xb;
    /* Subtract from 1 */
    ya = -ya;
    yb = -yb;
    double za = 1.0 + ya;
    double zb = -(za - 1.0 - ya);
    temp = za + yb;
    zb += -(temp - za - yb);
    za = temp;
    /* Square root */
    double y = sqrt(za);
    temp = y * 1073741824.0;
    ya = y + temp - temp;
    yb = y - ya;
    /* Extend precision of sqrt */
    yb += (za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y);
    /* Contribution of zb to sqrt */
    yb += zb / (2.0 * y);
    y = ya + yb;
    yb = -(y - ya - yb);
    // Compute ratio r = y/x
    double r = y / x;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    // Correct for rounding in division
    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
    // Add in effect additional bits of sqrt.
    rb += yb / x;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    return atan(ra, rb, x < 0);
}","public void test109109() throws Throwable {
    double double0 = FastMath.acos((-0.00918780066381382));
    assertEquals(1.5799842567293627, double0, 0.01);
}","/**
 * Compute the arc cosine of a number.
 * @param x number on which evaluation is done
 * @return arc cosine of x
 */"
"public static double acos(double x) {
    if (x != x) {
        return Double.NaN;
    }
    if (x > 1.0 || x < -1.0) {
        return Double.NaN;
    }
    if (x == -1.0) {
        return Math.PI;
    }
    if (x == 1.0) {
        return 0.0;
    }
    if (x == 0) {
        return Math.PI / 2.0;
    }
    /* Compute acos(x) = atan(sqrt(1-x*x)/x) */
    /* Split x */
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    /* Square it */
    double ya = xa * xa;
    double yb = xa * xb * 2.0 + xb * xb;
    /* Subtract from 1 */
    ya = -ya;
    yb = -yb;
    double za = 1.0 + ya;
    double zb = -(za - 1.0 - ya);
    temp = za + yb;
    zb += -(temp - za - yb);
    za = temp;
    /* Square root */
    double y = sqrt(za);
    temp = y * 1073741824.0;
    ya = y + temp - temp;
    yb = y - ya;
    /* Extend precision of sqrt */
    yb += (za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y);
    /* Contribution of zb to sqrt */
    yb += zb / (2.0 * y);
    y = ya + yb;
    yb = -(y - ya - yb);
    // Compute ratio r = y/x
    double r = y / x;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    // Correct for rounding in division
    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
    // Add in effect additional bits of sqrt.
    rb += yb / x;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    return atan(ra, rb, x < 0);
}","public void test110110() throws Throwable {
    double double0 = FastMath.acos(0L);
    assertEquals(1.5707963267948966, double0, 0.01);
}","/**
 * Compute the arc cosine of a number.
 * @param x number on which evaluation is done
 * @return arc cosine of x
 */"
"public static double acos(double x) {
    if (x != x) {
        return Double.NaN;
    }
    if (x > 1.0 || x < -1.0) {
        return Double.NaN;
    }
    if (x == -1.0) {
        return Math.PI;
    }
    if (x == 1.0) {
        return 0.0;
    }
    if (x == 0) {
        return Math.PI / 2.0;
    }
    /* Compute acos(x) = atan(sqrt(1-x*x)/x) */
    /* Split x */
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    /* Square it */
    double ya = xa * xa;
    double yb = xa * xb * 2.0 + xb * xb;
    /* Subtract from 1 */
    ya = -ya;
    yb = -yb;
    double za = 1.0 + ya;
    double zb = -(za - 1.0 - ya);
    temp = za + yb;
    zb += -(temp - za - yb);
    za = temp;
    /* Square root */
    double y = sqrt(za);
    temp = y * 1073741824.0;
    ya = y + temp - temp;
    yb = y - ya;
    /* Extend precision of sqrt */
    yb += (za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y);
    /* Contribution of zb to sqrt */
    yb += zb / (2.0 * y);
    y = ya + yb;
    yb = -(y - ya - yb);
    // Compute ratio r = y/x
    double r = y / x;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    // Correct for rounding in division
    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
    // Add in effect additional bits of sqrt.
    rb += yb / x;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    return atan(ra, rb, x < 0);
}","public void test111111() throws Throwable {
    double double0 = FastMath.acos(1.0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Compute the arc cosine of a number.
 * @param x number on which evaluation is done
 * @return arc cosine of x
 */"
"public static double acos(double x) {
    if (x != x) {
        return Double.NaN;
    }
    if (x > 1.0 || x < -1.0) {
        return Double.NaN;
    }
    if (x == -1.0) {
        return Math.PI;
    }
    if (x == 1.0) {
        return 0.0;
    }
    if (x == 0) {
        return Math.PI / 2.0;
    }
    /* Compute acos(x) = atan(sqrt(1-x*x)/x) */
    /* Split x */
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    /* Square it */
    double ya = xa * xa;
    double yb = xa * xb * 2.0 + xb * xb;
    /* Subtract from 1 */
    ya = -ya;
    yb = -yb;
    double za = 1.0 + ya;
    double zb = -(za - 1.0 - ya);
    temp = za + yb;
    zb += -(temp - za - yb);
    za = temp;
    /* Square root */
    double y = sqrt(za);
    temp = y * 1073741824.0;
    ya = y + temp - temp;
    yb = y - ya;
    /* Extend precision of sqrt */
    yb += (za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y);
    /* Contribution of zb to sqrt */
    yb += zb / (2.0 * y);
    y = ya + yb;
    yb = -(y - ya - yb);
    // Compute ratio r = y/x
    double r = y / x;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    // Correct for rounding in division
    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
    // Add in effect additional bits of sqrt.
    rb += yb / x;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    return atan(ra, rb, x < 0);
}","public void test112112() throws Throwable {
    double double0 = FastMath.acos((-1.0));
    assertEquals(3.141592653589793, double0, 0.01);
}","/**
 * Compute the arc cosine of a number.
 * @param x number on which evaluation is done
 * @return arc cosine of x
 */"
"public static double acos(double x) {
    if (x != x) {
        return Double.NaN;
    }
    if (x > 1.0 || x < -1.0) {
        return Double.NaN;
    }
    if (x == -1.0) {
        return Math.PI;
    }
    if (x == 1.0) {
        return 0.0;
    }
    if (x == 0) {
        return Math.PI / 2.0;
    }
    /* Compute acos(x) = atan(sqrt(1-x*x)/x) */
    /* Split x */
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    /* Square it */
    double ya = xa * xa;
    double yb = xa * xb * 2.0 + xb * xb;
    /* Subtract from 1 */
    ya = -ya;
    yb = -yb;
    double za = 1.0 + ya;
    double zb = -(za - 1.0 - ya);
    temp = za + yb;
    zb += -(temp - za - yb);
    za = temp;
    /* Square root */
    double y = sqrt(za);
    temp = y * 1073741824.0;
    ya = y + temp - temp;
    yb = y - ya;
    /* Extend precision of sqrt */
    yb += (za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y);
    /* Contribution of zb to sqrt */
    yb += zb / (2.0 * y);
    y = ya + yb;
    yb = -(y - ya - yb);
    // Compute ratio r = y/x
    double r = y / x;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    // Correct for rounding in division
    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
    // Add in effect additional bits of sqrt.
    rb += yb / x;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    return atan(ra, rb, x < 0);
}","public void test113113() throws Throwable {
    double double0 = FastMath.acos((-99.7024));
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Compute the arc cosine of a number.
 * @param x number on which evaluation is done
 * @return arc cosine of x
 */"
"public static double acos(double x) {
    if (x != x) {
        return Double.NaN;
    }
    if (x > 1.0 || x < -1.0) {
        return Double.NaN;
    }
    if (x == -1.0) {
        return Math.PI;
    }
    if (x == 1.0) {
        return 0.0;
    }
    if (x == 0) {
        return Math.PI / 2.0;
    }
    /* Compute acos(x) = atan(sqrt(1-x*x)/x) */
    /* Split x */
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    /* Square it */
    double ya = xa * xa;
    double yb = xa * xb * 2.0 + xb * xb;
    /* Subtract from 1 */
    ya = -ya;
    yb = -yb;
    double za = 1.0 + ya;
    double zb = -(za - 1.0 - ya);
    temp = za + yb;
    zb += -(temp - za - yb);
    za = temp;
    /* Square root */
    double y = sqrt(za);
    temp = y * 1073741824.0;
    ya = y + temp - temp;
    yb = y - ya;
    /* Extend precision of sqrt */
    yb += (za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y);
    /* Contribution of zb to sqrt */
    yb += zb / (2.0 * y);
    y = ya + yb;
    yb = -(y - ya - yb);
    // Compute ratio r = y/x
    double r = y / x;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    // Correct for rounding in division
    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
    // Add in effect additional bits of sqrt.
    rb += yb / x;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    return atan(ra, rb, x < 0);
}","public void test114114() throws Throwable {
    double double0 = FastMath.acos(20.0);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Compute the arc cosine of a number.
 * @param x number on which evaluation is done
 * @return arc cosine of x
 */"
"public static double acos(double x) {
    if (x != x) {
        return Double.NaN;
    }
    if (x > 1.0 || x < -1.0) {
        return Double.NaN;
    }
    if (x == -1.0) {
        return Math.PI;
    }
    if (x == 1.0) {
        return 0.0;
    }
    if (x == 0) {
        return Math.PI / 2.0;
    }
    /* Compute acos(x) = atan(sqrt(1-x*x)/x) */
    /* Split x */
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    /* Square it */
    double ya = xa * xa;
    double yb = xa * xb * 2.0 + xb * xb;
    /* Subtract from 1 */
    ya = -ya;
    yb = -yb;
    double za = 1.0 + ya;
    double zb = -(za - 1.0 - ya);
    temp = za + yb;
    zb += -(temp - za - yb);
    za = temp;
    /* Square root */
    double y = sqrt(za);
    temp = y * 1073741824.0;
    ya = y + temp - temp;
    yb = y - ya;
    /* Extend precision of sqrt */
    yb += (za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y);
    /* Contribution of zb to sqrt */
    yb += zb / (2.0 * y);
    y = ya + yb;
    yb = -(y - ya - yb);
    // Compute ratio r = y/x
    double r = y / x;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    // Correct for rounding in division
    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
    // Add in effect additional bits of sqrt.
    rb += yb / x;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    return atan(ra, rb, x < 0);
}","public void test115115() throws Throwable {
    double double0 = FastMath.acos(Double.NaN);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Compute the arc cosine of a number.
 * @param x number on which evaluation is done
 * @return arc cosine of x
 */"
"public static double asin(double x) {
    if (x != x) {
        return Double.NaN;
    }
    if (x > 1.0 || x < -1.0) {
        return Double.NaN;
    }
    if (x == 1.0) {
        return Math.PI / 2.0;
    }
    if (x == -1.0) {
        return -Math.PI / 2.0;
    }
    /* Compute asin(x) = atan(x/sqrt(1-x*x)) */
    /* Split x */
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    /* Square it */
    double ya = xa * xa;
    double yb = xa * xb * 2.0 + xb * xb;
    /* Subtract from 1 */
    ya = -ya;
    yb = -yb;
    double za = 1.0 + ya;
    double zb = -(za - 1.0 - ya);
    temp = za + yb;
    zb += -(temp - za - yb);
    za = temp;
    /* Square root */
    double y;
    y = sqrt(za);
    temp = y * 1073741824.0;
    ya = y + temp - temp;
    yb = y - ya;
    /* Extend precision of sqrt */
    yb += (za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y);
    /* Contribution of zb to sqrt */
    double dx = zb / (2.0 * y);
    // Compute ratio r = x/y
    double r = x / y;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    // Correct for rounding in division
    rb += (x - ra * ya - ra * yb - rb * ya - rb * yb) / y;
    // Add in effect additional bits of sqrt.
    rb += -x * dx / y / y;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    return atan(ra, rb, false);
}","public void test116116() throws Throwable {
    double double0 = FastMath.asin((-1.0));
    assertEquals((-1.5707963267948966), double0, 0.01);
}","/**
 * Compute the arc sine of a number.
 * @param x number on which evaluation is done
 * @return arc sine of x
 */"
"public static double asin(double x) {
    if (x != x) {
        return Double.NaN;
    }
    if (x > 1.0 || x < -1.0) {
        return Double.NaN;
    }
    if (x == 1.0) {
        return Math.PI / 2.0;
    }
    if (x == -1.0) {
        return -Math.PI / 2.0;
    }
    /* Compute asin(x) = atan(x/sqrt(1-x*x)) */
    /* Split x */
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    /* Square it */
    double ya = xa * xa;
    double yb = xa * xb * 2.0 + xb * xb;
    /* Subtract from 1 */
    ya = -ya;
    yb = -yb;
    double za = 1.0 + ya;
    double zb = -(za - 1.0 - ya);
    temp = za + yb;
    zb += -(temp - za - yb);
    za = temp;
    /* Square root */
    double y;
    y = sqrt(za);
    temp = y * 1073741824.0;
    ya = y + temp - temp;
    yb = y - ya;
    /* Extend precision of sqrt */
    yb += (za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y);
    /* Contribution of zb to sqrt */
    double dx = zb / (2.0 * y);
    // Compute ratio r = x/y
    double r = x / y;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    // Correct for rounding in division
    rb += (x - ra * ya - ra * yb - rb * ya - rb * yb) / y;
    // Add in effect additional bits of sqrt.
    rb += -x * dx / y / y;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    return atan(ra, rb, false);
}","public void test117117() throws Throwable {
    double double0 = FastMath.asin(1.0);
    assertEquals(1.5707963267948966, double0, 0.01);
}","/**
 * Compute the arc sine of a number.
 * @param x number on which evaluation is done
 * @return arc sine of x
 */"
"public static double asin(double x) {
    if (x != x) {
        return Double.NaN;
    }
    if (x > 1.0 || x < -1.0) {
        return Double.NaN;
    }
    if (x == 1.0) {
        return Math.PI / 2.0;
    }
    if (x == -1.0) {
        return -Math.PI / 2.0;
    }
    /* Compute asin(x) = atan(x/sqrt(1-x*x)) */
    /* Split x */
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    /* Square it */
    double ya = xa * xa;
    double yb = xa * xb * 2.0 + xb * xb;
    /* Subtract from 1 */
    ya = -ya;
    yb = -yb;
    double za = 1.0 + ya;
    double zb = -(za - 1.0 - ya);
    temp = za + yb;
    zb += -(temp - za - yb);
    za = temp;
    /* Square root */
    double y;
    y = sqrt(za);
    temp = y * 1073741824.0;
    ya = y + temp - temp;
    yb = y - ya;
    /* Extend precision of sqrt */
    yb += (za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y);
    /* Contribution of zb to sqrt */
    double dx = zb / (2.0 * y);
    // Compute ratio r = x/y
    double r = x / y;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    // Correct for rounding in division
    rb += (x - ra * ya - ra * yb - rb * ya - rb * yb) / y;
    // Add in effect additional bits of sqrt.
    rb += -x * dx / y / y;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    return atan(ra, rb, false);
}","public void test118118() throws Throwable {
    double double0 = FastMath.asin((-1.5701457982452864));
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Compute the arc sine of a number.
 * @param x number on which evaluation is done
 * @return arc sine of x
 */"
"public static double asin(double x) {
    if (x != x) {
        return Double.NaN;
    }
    if (x > 1.0 || x < -1.0) {
        return Double.NaN;
    }
    if (x == 1.0) {
        return Math.PI / 2.0;
    }
    if (x == -1.0) {
        return -Math.PI / 2.0;
    }
    /* Compute asin(x) = atan(x/sqrt(1-x*x)) */
    /* Split x */
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    /* Square it */
    double ya = xa * xa;
    double yb = xa * xb * 2.0 + xb * xb;
    /* Subtract from 1 */
    ya = -ya;
    yb = -yb;
    double za = 1.0 + ya;
    double zb = -(za - 1.0 - ya);
    temp = za + yb;
    zb += -(temp - za - yb);
    za = temp;
    /* Square root */
    double y;
    y = sqrt(za);
    temp = y * 1073741824.0;
    ya = y + temp - temp;
    yb = y - ya;
    /* Extend precision of sqrt */
    yb += (za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y);
    /* Contribution of zb to sqrt */
    double dx = zb / (2.0 * y);
    // Compute ratio r = x/y
    double r = x / y;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    // Correct for rounding in division
    rb += (x - ra * ya - ra * yb - rb * ya - rb * yb) / y;
    // Add in effect additional bits of sqrt.
    rb += -x * dx / y / y;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    return atan(ra, rb, false);
}","public void test119119() throws Throwable {
    double double0 = FastMath.asin(3398.0);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Compute the arc sine of a number.
 * @param x number on which evaluation is done
 * @return arc sine of x
 */"
"public static double asin(double x) {
    if (x != x) {
        return Double.NaN;
    }
    if (x > 1.0 || x < -1.0) {
        return Double.NaN;
    }
    if (x == 1.0) {
        return Math.PI / 2.0;
    }
    if (x == -1.0) {
        return -Math.PI / 2.0;
    }
    /* Compute asin(x) = atan(x/sqrt(1-x*x)) */
    /* Split x */
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    /* Square it */
    double ya = xa * xa;
    double yb = xa * xb * 2.0 + xb * xb;
    /* Subtract from 1 */
    ya = -ya;
    yb = -yb;
    double za = 1.0 + ya;
    double zb = -(za - 1.0 - ya);
    temp = za + yb;
    zb += -(temp - za - yb);
    za = temp;
    /* Square root */
    double y;
    y = sqrt(za);
    temp = y * 1073741824.0;
    ya = y + temp - temp;
    yb = y - ya;
    /* Extend precision of sqrt */
    yb += (za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y);
    /* Contribution of zb to sqrt */
    double dx = zb / (2.0 * y);
    // Compute ratio r = x/y
    double r = x / y;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    // Correct for rounding in division
    rb += (x - ra * ya - ra * yb - rb * ya - rb * yb) / y;
    // Add in effect additional bits of sqrt.
    rb += -x * dx / y / y;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    return atan(ra, rb, false);
}","public void test120120() throws Throwable {
    double double0 = FastMath.asin(Double.NaN);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Compute the arc sine of a number.
 * @param x number on which evaluation is done
 * @return arc sine of x
 */"
"public static double atan2(double y, double x) {
    if (x != x || y != y) {
        return Double.NaN;
    }
    if (y == 0.0) {
        double result = x * y;
        double invx = 1.0 / x;
        double invy = 1.0 / y;
        if (invx == 0.0) {
            // X is infinite
            if (x > 0) {
                return 0.0;
            } else {
                return Math.PI;
            }
        }
        if (result != result) {
            // y must be infinite
            return x / y;
        }
        if (x < 0.0 || invx < 0.0) {
            if (y < 0.0 || invy < 0.0) {
                return -Math.PI;
            } else {
                return Math.PI;
            }
        } else {
            return result;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return Math.PI * 3.0 / 4.0;
        }
        return Math.PI / 2.0;
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return -Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return -Math.PI * 3.0 / 4.0;
        }
        return -Math.PI / 2.0;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return 0.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI;
        }
    }
    if (x == 0) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI / 2.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI / 2.0;
        }
    }
    if (x > 8e298 || x < -8e298) {
        // This would cause split of x to fail
        x *= 9.31322574615478515625E-10;
        y *= 9.31322574615478515625E-10;
    }
    // Split y
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    // Compute ratio r = x/y
    final double r = y / x;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    // Call atan
    double result = atan(ra, rb, x < 0);
    return result;
}","public void test121121() throws Throwable {
    double double0 = FastMath.atan2(835.6992, 835.6992);
    assertEquals(0.7853981633974483, double0, 0.01);
}","/**
 * Two arguments arctangent function
 * @param y ordinate
 * @param x abscissa
 * @return phase angle of point (x,y) between -&pi; and &pi;
 */"
"public static double atan2(double y, double x) {
    if (x != x || y != y) {
        return Double.NaN;
    }
    if (y == 0.0) {
        double result = x * y;
        double invx = 1.0 / x;
        double invy = 1.0 / y;
        if (invx == 0.0) {
            // X is infinite
            if (x > 0) {
                return 0.0;
            } else {
                return Math.PI;
            }
        }
        if (result != result) {
            // y must be infinite
            return x / y;
        }
        if (x < 0.0 || invx < 0.0) {
            if (y < 0.0 || invy < 0.0) {
                return -Math.PI;
            } else {
                return Math.PI;
            }
        } else {
            return result;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return Math.PI * 3.0 / 4.0;
        }
        return Math.PI / 2.0;
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return -Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return -Math.PI * 3.0 / 4.0;
        }
        return -Math.PI / 2.0;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return 0.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI;
        }
    }
    if (x == 0) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI / 2.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI / 2.0;
        }
    }
    if (x > 8e298 || x < -8e298) {
        // This would cause split of x to fail
        x *= 9.31322574615478515625E-10;
        y *= 9.31322574615478515625E-10;
    }
    // Split y
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    // Compute ratio r = x/y
    final double r = y / x;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    // Call atan
    double result = atan(ra, rb, x < 0);
    return result;
}","public void test122122() throws Throwable {
    double double0 = FastMath.atan2((-4.469603409122654E-6), 0.0);
    assertEquals((-1.5707963267948966), double0, 0.01);
}","/**
 * Two arguments arctangent function
 * @param y ordinate
 * @param x abscissa
 * @return phase angle of point (x,y) between -&pi; and &pi;
 */"
"public static double atan2(double y, double x) {
    if (x != x || y != y) {
        return Double.NaN;
    }
    if (y == 0.0) {
        double result = x * y;
        double invx = 1.0 / x;
        double invy = 1.0 / y;
        if (invx == 0.0) {
            // X is infinite
            if (x > 0) {
                return 0.0;
            } else {
                return Math.PI;
            }
        }
        if (result != result) {
            // y must be infinite
            return x / y;
        }
        if (x < 0.0 || invx < 0.0) {
            if (y < 0.0 || invy < 0.0) {
                return -Math.PI;
            } else {
                return Math.PI;
            }
        } else {
            return result;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return Math.PI * 3.0 / 4.0;
        }
        return Math.PI / 2.0;
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return -Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return -Math.PI * 3.0 / 4.0;
        }
        return -Math.PI / 2.0;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return 0.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI;
        }
    }
    if (x == 0) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI / 2.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI / 2.0;
        }
    }
    if (x > 8e298 || x < -8e298) {
        // This would cause split of x to fail
        x *= 9.31322574615478515625E-10;
        y *= 9.31322574615478515625E-10;
    }
    // Split y
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    // Compute ratio r = x/y
    final double r = y / x;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    // Call atan
    double result = atan(ra, rb, x < 0);
    return result;
}","public void test123123() throws Throwable {
    double double0 = FastMath.atan2(8.0E298, -0.0);
    assertEquals(1.5707963267948966, double0, 0.01);
}","/**
 * Two arguments arctangent function
 * @param y ordinate
 * @param x abscissa
 * @return phase angle of point (x,y) between -&pi; and &pi;
 */"
"public static double atan2(double y, double x) {
    if (x != x || y != y) {
        return Double.NaN;
    }
    if (y == 0.0) {
        double result = x * y;
        double invx = 1.0 / x;
        double invy = 1.0 / y;
        if (invx == 0.0) {
            // X is infinite
            if (x > 0) {
                return 0.0;
            } else {
                return Math.PI;
            }
        }
        if (result != result) {
            // y must be infinite
            return x / y;
        }
        if (x < 0.0 || invx < 0.0) {
            if (y < 0.0 || invy < 0.0) {
                return -Math.PI;
            } else {
                return Math.PI;
            }
        } else {
            return result;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return Math.PI * 3.0 / 4.0;
        }
        return Math.PI / 2.0;
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return -Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return -Math.PI * 3.0 / 4.0;
        }
        return -Math.PI / 2.0;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return 0.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI;
        }
    }
    if (x == 0) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI / 2.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI / 2.0;
        }
    }
    if (x > 8e298 || x < -8e298) {
        // This would cause split of x to fail
        x *= 9.31322574615478515625E-10;
        y *= 9.31322574615478515625E-10;
    }
    // Split y
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    // Compute ratio r = x/y
    final double r = y / x;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    // Call atan
    double result = atan(ra, rb, x < 0);
    return result;
}","public void test124124() throws Throwable {
    double double0 = FastMath.atan2((-1.0), Double.NEGATIVE_INFINITY);
    assertEquals((-3.141592653589793), double0, 0.01);
}","/**
 * Two arguments arctangent function
 * @param y ordinate
 * @param x abscissa
 * @return phase angle of point (x,y) between -&pi; and &pi;
 */"
"public static double atan2(double y, double x) {
    if (x != x || y != y) {
        return Double.NaN;
    }
    if (y == 0.0) {
        double result = x * y;
        double invx = 1.0 / x;
        double invy = 1.0 / y;
        if (invx == 0.0) {
            // X is infinite
            if (x > 0) {
                return 0.0;
            } else {
                return Math.PI;
            }
        }
        if (result != result) {
            // y must be infinite
            return x / y;
        }
        if (x < 0.0 || invx < 0.0) {
            if (y < 0.0 || invy < 0.0) {
                return -Math.PI;
            } else {
                return Math.PI;
            }
        } else {
            return result;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return Math.PI * 3.0 / 4.0;
        }
        return Math.PI / 2.0;
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return -Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return -Math.PI * 3.0 / 4.0;
        }
        return -Math.PI / 2.0;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return 0.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI;
        }
    }
    if (x == 0) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI / 2.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI / 2.0;
        }
    }
    if (x > 8e298 || x < -8e298) {
        // This would cause split of x to fail
        x *= 9.31322574615478515625E-10;
        y *= 9.31322574615478515625E-10;
    }
    // Split y
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    // Compute ratio r = x/y
    final double r = y / x;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    // Call atan
    double result = atan(ra, rb, x < 0);
    return result;
}","public void test125125() throws Throwable {
    double double0 = FastMath.atan2((-1710.4285759692), Double.POSITIVE_INFINITY);
    assertEquals(-0.0, double0, 0.01);
}","/**
 * Two arguments arctangent function
 * @param y ordinate
 * @param x abscissa
 * @return phase angle of point (x,y) between -&pi; and &pi;
 */"
"public static double atan2(double y, double x) {
    if (x != x || y != y) {
        return Double.NaN;
    }
    if (y == 0.0) {
        double result = x * y;
        double invx = 1.0 / x;
        double invy = 1.0 / y;
        if (invx == 0.0) {
            // X is infinite
            if (x > 0) {
                return 0.0;
            } else {
                return Math.PI;
            }
        }
        if (result != result) {
            // y must be infinite
            return x / y;
        }
        if (x < 0.0 || invx < 0.0) {
            if (y < 0.0 || invy < 0.0) {
                return -Math.PI;
            } else {
                return Math.PI;
            }
        } else {
            return result;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return Math.PI * 3.0 / 4.0;
        }
        return Math.PI / 2.0;
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return -Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return -Math.PI * 3.0 / 4.0;
        }
        return -Math.PI / 2.0;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return 0.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI;
        }
    }
    if (x == 0) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI / 2.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI / 2.0;
        }
    }
    if (x > 8e298 || x < -8e298) {
        // This would cause split of x to fail
        x *= 9.31322574615478515625E-10;
        y *= 9.31322574615478515625E-10;
    }
    // Split y
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    // Compute ratio r = x/y
    final double r = y / x;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    // Call atan
    double result = atan(ra, rb, x < 0);
    return result;
}","public void test126126() throws Throwable {
    double double0 = FastMath.atan2(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);
    assertEquals((-0.7853981633974483), double0, 0.01);
}","/**
 * Two arguments arctangent function
 * @param y ordinate
 * @param x abscissa
 * @return phase angle of point (x,y) between -&pi; and &pi;
 */"
"public static double atan2(double y, double x) {
    if (x != x || y != y) {
        return Double.NaN;
    }
    if (y == 0.0) {
        double result = x * y;
        double invx = 1.0 / x;
        double invy = 1.0 / y;
        if (invx == 0.0) {
            // X is infinite
            if (x > 0) {
                return 0.0;
            } else {
                return Math.PI;
            }
        }
        if (result != result) {
            // y must be infinite
            return x / y;
        }
        if (x < 0.0 || invx < 0.0) {
            if (y < 0.0 || invy < 0.0) {
                return -Math.PI;
            } else {
                return Math.PI;
            }
        } else {
            return result;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return Math.PI * 3.0 / 4.0;
        }
        return Math.PI / 2.0;
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return -Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return -Math.PI * 3.0 / 4.0;
        }
        return -Math.PI / 2.0;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return 0.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI;
        }
    }
    if (x == 0) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI / 2.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI / 2.0;
        }
    }
    if (x > 8e298 || x < -8e298) {
        // This would cause split of x to fail
        x *= 9.31322574615478515625E-10;
        y *= 9.31322574615478515625E-10;
    }
    // Split y
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    // Compute ratio r = x/y
    final double r = y / x;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    // Call atan
    double result = atan(ra, rb, x < 0);
    return result;
}","public void test127127() throws Throwable {
    double double0 = FastMath.atan2(Double.POSITIVE_INFINITY, 5.1661063655873455E169);
    assertEquals(1.5707963267948966, double0, 0.01);
}","/**
 * Two arguments arctangent function
 * @param y ordinate
 * @param x abscissa
 * @return phase angle of point (x,y) between -&pi; and &pi;
 */"
"public static double atan2(double y, double x) {
    if (x != x || y != y) {
        return Double.NaN;
    }
    if (y == 0.0) {
        double result = x * y;
        double invx = 1.0 / x;
        double invy = 1.0 / y;
        if (invx == 0.0) {
            // X is infinite
            if (x > 0) {
                return 0.0;
            } else {
                return Math.PI;
            }
        }
        if (result != result) {
            // y must be infinite
            return x / y;
        }
        if (x < 0.0 || invx < 0.0) {
            if (y < 0.0 || invy < 0.0) {
                return -Math.PI;
            } else {
                return Math.PI;
            }
        } else {
            return result;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return Math.PI * 3.0 / 4.0;
        }
        return Math.PI / 2.0;
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return -Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return -Math.PI * 3.0 / 4.0;
        }
        return -Math.PI / 2.0;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return 0.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI;
        }
    }
    if (x == 0) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI / 2.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI / 2.0;
        }
    }
    if (x > 8e298 || x < -8e298) {
        // This would cause split of x to fail
        x *= 9.31322574615478515625E-10;
        y *= 9.31322574615478515625E-10;
    }
    // Split y
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    // Compute ratio r = x/y
    final double r = y / x;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    // Call atan
    double result = atan(ra, rb, x < 0);
    return result;
}","public void test128128() throws Throwable {
    double double0 = FastMath.atan2(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
    assertEquals(0.7853981633974483, double0, 0.01);
}","/**
 * Two arguments arctangent function
 * @param y ordinate
 * @param x abscissa
 * @return phase angle of point (x,y) between -&pi; and &pi;
 */"
"public static double atan2(double y, double x) {
    if (x != x || y != y) {
        return Double.NaN;
    }
    if (y == 0.0) {
        double result = x * y;
        double invx = 1.0 / x;
        double invy = 1.0 / y;
        if (invx == 0.0) {
            // X is infinite
            if (x > 0) {
                return 0.0;
            } else {
                return Math.PI;
            }
        }
        if (result != result) {
            // y must be infinite
            return x / y;
        }
        if (x < 0.0 || invx < 0.0) {
            if (y < 0.0 || invy < 0.0) {
                return -Math.PI;
            } else {
                return Math.PI;
            }
        } else {
            return result;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return Math.PI * 3.0 / 4.0;
        }
        return Math.PI / 2.0;
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return -Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return -Math.PI * 3.0 / 4.0;
        }
        return -Math.PI / 2.0;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return 0.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI;
        }
    }
    if (x == 0) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI / 2.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI / 2.0;
        }
    }
    if (x > 8e298 || x < -8e298) {
        // This would cause split of x to fail
        x *= 9.31322574615478515625E-10;
        y *= 9.31322574615478515625E-10;
    }
    // Split y
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    // Compute ratio r = x/y
    final double r = y / x;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    // Call atan
    double result = atan(ra, rb, x < 0);
    return result;
}","public void test129129() throws Throwable {
    double double0 = FastMath.atan2(-0.0, (-1.157542012003743E-14));
    assertEquals((-3.141592653589793), double0, 0.01);
}","/**
 * Two arguments arctangent function
 * @param y ordinate
 * @param x abscissa
 * @return phase angle of point (x,y) between -&pi; and &pi;
 */"
"public static double atan2(double y, double x) {
    if (x != x || y != y) {
        return Double.NaN;
    }
    if (y == 0.0) {
        double result = x * y;
        double invx = 1.0 / x;
        double invy = 1.0 / y;
        if (invx == 0.0) {
            // X is infinite
            if (x > 0) {
                return 0.0;
            } else {
                return Math.PI;
            }
        }
        if (result != result) {
            // y must be infinite
            return x / y;
        }
        if (x < 0.0 || invx < 0.0) {
            if (y < 0.0 || invy < 0.0) {
                return -Math.PI;
            } else {
                return Math.PI;
            }
        } else {
            return result;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return Math.PI * 3.0 / 4.0;
        }
        return Math.PI / 2.0;
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return -Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return -Math.PI * 3.0 / 4.0;
        }
        return -Math.PI / 2.0;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return 0.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI;
        }
    }
    if (x == 0) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI / 2.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI / 2.0;
        }
    }
    if (x > 8e298 || x < -8e298) {
        // This would cause split of x to fail
        x *= 9.31322574615478515625E-10;
        y *= 9.31322574615478515625E-10;
    }
    // Split y
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    // Compute ratio r = x/y
    final double r = y / x;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    // Call atan
    double result = atan(ra, rb, x < 0);
    return result;
}","public void test130130() throws Throwable {
    double double0 = FastMath.atan2(0.0, 0.0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Two arguments arctangent function
 * @param y ordinate
 * @param x abscissa
 * @return phase angle of point (x,y) between -&pi; and &pi;
 */"
"public static double atan2(double y, double x) {
    if (x != x || y != y) {
        return Double.NaN;
    }
    if (y == 0.0) {
        double result = x * y;
        double invx = 1.0 / x;
        double invy = 1.0 / y;
        if (invx == 0.0) {
            // X is infinite
            if (x > 0) {
                return 0.0;
            } else {
                return Math.PI;
            }
        }
        if (result != result) {
            // y must be infinite
            return x / y;
        }
        if (x < 0.0 || invx < 0.0) {
            if (y < 0.0 || invy < 0.0) {
                return -Math.PI;
            } else {
                return Math.PI;
            }
        } else {
            return result;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return Math.PI * 3.0 / 4.0;
        }
        return Math.PI / 2.0;
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return -Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return -Math.PI * 3.0 / 4.0;
        }
        return -Math.PI / 2.0;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return 0.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI;
        }
    }
    if (x == 0) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI / 2.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI / 2.0;
        }
    }
    if (x > 8e298 || x < -8e298) {
        // This would cause split of x to fail
        x *= 9.31322574615478515625E-10;
        y *= 9.31322574615478515625E-10;
    }
    // Split y
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    // Compute ratio r = x/y
    final double r = y / x;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    // Call atan
    double result = atan(ra, rb, x < 0);
    return result;
}","public void test131131() throws Throwable {
    double double0 = FastMath.atan2(0.0, (-1710.4285759692));
    assertEquals(3.141592653589793, double0, 0.01);
}","/**
 * Two arguments arctangent function
 * @param y ordinate
 * @param x abscissa
 * @return phase angle of point (x,y) between -&pi; and &pi;
 */"
"public static double atan2(double y, double x) {
    if (x != x || y != y) {
        return Double.NaN;
    }
    if (y == 0.0) {
        double result = x * y;
        double invx = 1.0 / x;
        double invy = 1.0 / y;
        if (invx == 0.0) {
            // X is infinite
            if (x > 0) {
                return 0.0;
            } else {
                return Math.PI;
            }
        }
        if (result != result) {
            // y must be infinite
            return x / y;
        }
        if (x < 0.0 || invx < 0.0) {
            if (y < 0.0 || invy < 0.0) {
                return -Math.PI;
            } else {
                return Math.PI;
            }
        } else {
            return result;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return Math.PI * 3.0 / 4.0;
        }
        return Math.PI / 2.0;
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return -Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return -Math.PI * 3.0 / 4.0;
        }
        return -Math.PI / 2.0;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return 0.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI;
        }
    }
    if (x == 0) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI / 2.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI / 2.0;
        }
    }
    if (x > 8e298 || x < -8e298) {
        // This would cause split of x to fail
        x *= 9.31322574615478515625E-10;
        y *= 9.31322574615478515625E-10;
    }
    // Split y
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    // Compute ratio r = x/y
    final double r = y / x;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    // Call atan
    double result = atan(ra, rb, x < 0);
    return result;
}","public void test132132() throws Throwable {
    double double0 = FastMath.atan2(Double.NaN, (-3496.80156));
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Two arguments arctangent function
 * @param y ordinate
 * @param x abscissa
 * @return phase angle of point (x,y) between -&pi; and &pi;
 */"
"public static double atan2(double y, double x) {
    if (x != x || y != y) {
        return Double.NaN;
    }
    if (y == 0.0) {
        double result = x * y;
        double invx = 1.0 / x;
        double invy = 1.0 / y;
        if (invx == 0.0) {
            // X is infinite
            if (x > 0) {
                return 0.0;
            } else {
                return Math.PI;
            }
        }
        if (result != result) {
            // y must be infinite
            return x / y;
        }
        if (x < 0.0 || invx < 0.0) {
            if (y < 0.0 || invy < 0.0) {
                return -Math.PI;
            } else {
                return Math.PI;
            }
        } else {
            return result;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return Math.PI * 3.0 / 4.0;
        }
        return Math.PI / 2.0;
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return -Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return -Math.PI * 3.0 / 4.0;
        }
        return -Math.PI / 2.0;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return 0.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI;
        }
    }
    if (x == 0) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI / 2.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI / 2.0;
        }
    }
    if (x > 8e298 || x < -8e298) {
        // This would cause split of x to fail
        x *= 9.31322574615478515625E-10;
        y *= 9.31322574615478515625E-10;
    }
    // Split y
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    // Compute ratio r = x/y
    final double r = y / x;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    // Call atan
    double result = atan(ra, rb, x < 0);
    return result;
}","public void test133133() throws Throwable {
    double double0 = FastMath.atan2(2212.41026543, Double.NaN);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Two arguments arctangent function
 * @param y ordinate
 * @param x abscissa
 * @return phase angle of point (x,y) between -&pi; and &pi;
 */"
"public static double asin(double x) {
    if (x != x) {
        return Double.NaN;
    }
    if (x > 1.0 || x < -1.0) {
        return Double.NaN;
    }
    if (x == 1.0) {
        return Math.PI / 2.0;
    }
    if (x == -1.0) {
        return -Math.PI / 2.0;
    }
    /* Compute asin(x) = atan(x/sqrt(1-x*x)) */
    /* Split x */
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    /* Square it */
    double ya = xa * xa;
    double yb = xa * xb * 2.0 + xb * xb;
    /* Subtract from 1 */
    ya = -ya;
    yb = -yb;
    double za = 1.0 + ya;
    double zb = -(za - 1.0 - ya);
    temp = za + yb;
    zb += -(temp - za - yb);
    za = temp;
    /* Square root */
    double y;
    y = sqrt(za);
    temp = y * 1073741824.0;
    ya = y + temp - temp;
    yb = y - ya;
    /* Extend precision of sqrt */
    yb += (za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y);
    /* Contribution of zb to sqrt */
    double dx = zb / (2.0 * y);
    // Compute ratio r = x/y
    double r = x / y;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    // Correct for rounding in division
    rb += (x - ra * ya - ra * yb - rb * ya - rb * yb) / y;
    // Add in effect additional bits of sqrt.
    rb += -x * dx / y / y;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    return atan(ra, rb, false);
}","public void test134134() throws Throwable {
    double double0 = FastMath.asin(0L);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Compute the arc sine of a number.
 * @param x number on which evaluation is done
 * @return arc sine of x
 */"
"public static double atan2(double y, double x) {
    if (x != x || y != y) {
        return Double.NaN;
    }
    if (y == 0.0) {
        double result = x * y;
        double invx = 1.0 / x;
        double invy = 1.0 / y;
        if (invx == 0.0) {
            // X is infinite
            if (x > 0) {
                return 0.0;
            } else {
                return Math.PI;
            }
        }
        if (result != result) {
            // y must be infinite
            return x / y;
        }
        if (x < 0.0 || invx < 0.0) {
            if (y < 0.0 || invy < 0.0) {
                return -Math.PI;
            } else {
                return Math.PI;
            }
        } else {
            return result;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return Math.PI * 3.0 / 4.0;
        }
        return Math.PI / 2.0;
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return -Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return -Math.PI * 3.0 / 4.0;
        }
        return -Math.PI / 2.0;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return 0.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI;
        }
    }
    if (x == 0) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI / 2.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI / 2.0;
        }
    }
    if (x > 8e298 || x < -8e298) {
        // This would cause split of x to fail
        x *= 9.31322574615478515625E-10;
        y *= 9.31322574615478515625E-10;
    }
    // Split y
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    // Compute ratio r = x/y
    final double r = y / x;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    // Call atan
    double result = atan(ra, rb, x < 0);
    return result;
}","public void test135135() throws Throwable {
    double double0 = FastMath.atan2(3076.8323247, (-4234.0));
    assertEquals(2.5131734557100405, double0, 0.01);
}","/**
 * Two arguments arctangent function
 * @param y ordinate
 * @param x abscissa
 * @return phase angle of point (x,y) between -&pi; and &pi;
 */"
"public static double atan2(double y, double x) {
    if (x != x || y != y) {
        return Double.NaN;
    }
    if (y == 0.0) {
        double result = x * y;
        double invx = 1.0 / x;
        double invy = 1.0 / y;
        if (invx == 0.0) {
            // X is infinite
            if (x > 0) {
                return 0.0;
            } else {
                return Math.PI;
            }
        }
        if (result != result) {
            // y must be infinite
            return x / y;
        }
        if (x < 0.0 || invx < 0.0) {
            if (y < 0.0 || invy < 0.0) {
                return -Math.PI;
            } else {
                return Math.PI;
            }
        } else {
            return result;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return Math.PI * 3.0 / 4.0;
        }
        return Math.PI / 2.0;
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x == Double.POSITIVE_INFINITY) {
            return -Math.PI / 4.0;
        }
        if (x == Double.NEGATIVE_INFINITY) {
            return -Math.PI * 3.0 / 4.0;
        }
        return -Math.PI / 2.0;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return 0.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI;
        }
    }
    if (x == 0) {
        if (y > 0.0 || 1 / y > 0.0) {
            return Math.PI / 2.0;
        }
        if (y < 0.0 || 1 / y < 0.0) {
            return -Math.PI / 2.0;
        }
    }
    if (x > 8e298 || x < -8e298) {
        // This would cause split of x to fail
        x *= 9.31322574615478515625E-10;
        y *= 9.31322574615478515625E-10;
    }
    // Split y
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    // Compute ratio r = x/y
    final double r = y / x;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    // Call atan
    double result = atan(ra, rb, x < 0);
    return result;
}","public void test136136() throws Throwable {
    double double0 = FastMath.atan2(6.849723859521112E287, (-785));
    assertEquals(1.5707963267948966, double0, 0.01);
}","/**
 * Two arguments arctangent function
 * @param y ordinate
 * @param x abscissa
 * @return phase angle of point (x,y) between -&pi; and &pi;
 */"
"public static double atan(double x) {
    return atan(x, 0.0, false);
}","public void test137137() throws Throwable {
    double double0 = FastMath.atan(Double.NEGATIVE_INFINITY);
    assertEquals((-1.5707963267948966), double0, 0.01);
}","/**
 * Arctangent function
 *  @param x a number
 *  @return atan(x)
 */"
"public static double tan(double x) {
    boolean negative = false;
    int quadrant = 0;
    /* Take absolute value of the input */
    double xa = x;
    if (x < 0) {
        negative = true;
        xa = -xa;
    }
    /* Check for zero and negative zero */
    if (xa == 0.0) {
        long bits = Double.doubleToLongBits(x);
        if (bits < 0) {
            return -0.0;
        }
        return 0.0;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    double xb = 0;
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    if (xa > 1.5) {
        // Accurracy suffers between 1.5 and PI/2
        final double pi2a = 1.5707963267948966;
        final double pi2b = 6.123233995736766E-17;
        final double a = pi2a - xa;
        double b = -(a - pi2a + xa);
        b += pi2b - xb;
        xa = a + b;
        xb = -(xa - a - b);
        quadrant ^= 1;
        negative ^= true;
    }
    double result;
    if ((quadrant & 1) == 0) {
        result = tanQ(xa, xb, false);
    } else {
        result = -tanQ(xa, xb, true);
    }
    if (negative) {
        result = -result;
    }
    return result;
}","public void test138138() throws Throwable {
    double double0 = FastMath.tan(Double.POSITIVE_INFINITY);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 *   Tangent function
 *  @param x a number
 *  @return tan(x)
 */"
"public static double tan(double x) {
    boolean negative = false;
    int quadrant = 0;
    /* Take absolute value of the input */
    double xa = x;
    if (x < 0) {
        negative = true;
        xa = -xa;
    }
    /* Check for zero and negative zero */
    if (xa == 0.0) {
        long bits = Double.doubleToLongBits(x);
        if (bits < 0) {
            return -0.0;
        }
        return 0.0;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    double xb = 0;
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    if (xa > 1.5) {
        // Accurracy suffers between 1.5 and PI/2
        final double pi2a = 1.5707963267948966;
        final double pi2b = 6.123233995736766E-17;
        final double a = pi2a - xa;
        double b = -(a - pi2a + xa);
        b += pi2b - xb;
        xa = a + b;
        xb = -(xa - a - b);
        quadrant ^= 1;
        negative ^= true;
    }
    double result;
    if ((quadrant & 1) == 0) {
        result = tanQ(xa, xb, false);
    } else {
        result = -tanQ(xa, xb, true);
    }
    if (negative) {
        result = -result;
    }
    return result;
}","public void test139139() throws Throwable {
    double double0 = FastMath.tan(Double.NaN);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 *   Tangent function
 *  @param x a number
 *  @return tan(x)
 */"
"public static double tan(double x) {
    boolean negative = false;
    int quadrant = 0;
    /* Take absolute value of the input */
    double xa = x;
    if (x < 0) {
        negative = true;
        xa = -xa;
    }
    /* Check for zero and negative zero */
    if (xa == 0.0) {
        long bits = Double.doubleToLongBits(x);
        if (bits < 0) {
            return -0.0;
        }
        return 0.0;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    double xb = 0;
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    if (xa > 1.5) {
        // Accurracy suffers between 1.5 and PI/2
        final double pi2a = 1.5707963267948966;
        final double pi2b = 6.123233995736766E-17;
        final double a = pi2a - xa;
        double b = -(a - pi2a + xa);
        b += pi2b - xb;
        xa = a + b;
        xb = -(xa - a - b);
        quadrant ^= 1;
        negative ^= true;
    }
    double result;
    if ((quadrant & 1) == 0) {
        result = tanQ(xa, xb, false);
    } else {
        result = -tanQ(xa, xb, true);
    }
    if (negative) {
        result = -result;
    }
    return result;
}","public void test140140() throws Throwable {
    double double0 = FastMath.tan(-0.0);
    assertEquals(-0.0, double0, 0.01);
}","/**
 *   Tangent function
 *  @param x a number
 *  @return tan(x)
 */"
"public static double tan(double x) {
    boolean negative = false;
    int quadrant = 0;
    /* Take absolute value of the input */
    double xa = x;
    if (x < 0) {
        negative = true;
        xa = -xa;
    }
    /* Check for zero and negative zero */
    if (xa == 0.0) {
        long bits = Double.doubleToLongBits(x);
        if (bits < 0) {
            return -0.0;
        }
        return 0.0;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    double xb = 0;
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    if (xa > 1.5) {
        // Accurracy suffers between 1.5 and PI/2
        final double pi2a = 1.5707963267948966;
        final double pi2b = 6.123233995736766E-17;
        final double a = pi2a - xa;
        double b = -(a - pi2a + xa);
        b += pi2b - xb;
        xa = a + b;
        xb = -(xa - a - b);
        quadrant ^= 1;
        negative ^= true;
    }
    double result;
    if ((quadrant & 1) == 0) {
        result = tanQ(xa, xb, false);
    } else {
        result = -tanQ(xa, xb, true);
    }
    if (negative) {
        result = -result;
    }
    return result;
}","public void test141141() throws Throwable {
    double double0 = FastMath.tan(0.0);
    assertEquals(0.0, double0, 0.01);
}","/**
 *   Tangent function
 *  @param x a number
 *  @return tan(x)
 */"
"public static double cos(double x) {
    int quadrant = 0;
    /* Take absolute value of the input */
    double xa = x;
    if (x < 0) {
        xa = -xa;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    double xb = 0;
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    //if (negative)
    //  quadrant = (quadrant + 2) % 4;
    switch(quadrant) {
        case 0:
            return cosQ(xa, xb);
        case 1:
            return -sinQ(xa, xb);
        case 2:
            return -cosQ(xa, xb);
        case 3:
            return sinQ(xa, xb);
        default:
            return Double.NaN;
    }
}","public void test142142() throws Throwable {
    double double0 = FastMath.cos(1537.2113330561938);
    assertEquals((-0.5632145223911247), double0, 0.01);
}","/**
 *  Cosine function
 *  @param x a number
 *  @return cos(x)
 */"
"public static double cos(double x) {
    int quadrant = 0;
    /* Take absolute value of the input */
    double xa = x;
    if (x < 0) {
        xa = -xa;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    double xb = 0;
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    //if (negative)
    //  quadrant = (quadrant + 2) % 4;
    switch(quadrant) {
        case 0:
            return cosQ(xa, xb);
        case 1:
            return -sinQ(xa, xb);
        case 2:
            return -cosQ(xa, xb);
        case 3:
            return sinQ(xa, xb);
        default:
            return Double.NaN;
    }
}","public void test143143() throws Throwable {
    double double0 = FastMath.cos((-3.141592653589793));
    assertEquals((-1.0), double0, 0.01);
}","/**
 *  Cosine function
 *  @param x a number
 *  @return cos(x)
 */"
"public static double cos(double x) {
    int quadrant = 0;
    /* Take absolute value of the input */
    double xa = x;
    if (x < 0) {
        xa = -xa;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    double xb = 0;
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    //if (negative)
    //  quadrant = (quadrant + 2) % 4;
    switch(quadrant) {
        case 0:
            return cosQ(xa, xb);
        case 1:
            return -sinQ(xa, xb);
        case 2:
            return -cosQ(xa, xb);
        case 3:
            return sinQ(xa, xb);
        default:
            return Double.NaN;
    }
}","public void test144144() throws Throwable {
    double double0 = FastMath.cos(Double.POSITIVE_INFINITY);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 *  Cosine function
 *  @param x a number
 *  @return cos(x)
 */"
"public static double cos(double x) {
    int quadrant = 0;
    /* Take absolute value of the input */
    double xa = x;
    if (x < 0) {
        xa = -xa;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    double xb = 0;
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    //if (negative)
    //  quadrant = (quadrant + 2) % 4;
    switch(quadrant) {
        case 0:
            return cosQ(xa, xb);
        case 1:
            return -sinQ(xa, xb);
        case 2:
            return -cosQ(xa, xb);
        case 3:
            return sinQ(xa, xb);
        default:
            return Double.NaN;
    }
}","public void test145145() throws Throwable {
    double double0 = FastMath.cos(Double.NaN);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 *  Cosine function
 *  @param x a number
 *  @return cos(x)
 */"
"public static double sin(double x) {
    boolean negative = false;
    int quadrant = 0;
    double xa;
    double xb = 0.0;
    /* Take absolute value of the input */
    xa = x;
    if (x < 0) {
        negative = true;
        xa = -xa;
    }
    /* Check for zero and negative zero */
    if (xa == 0.0) {
        long bits = Double.doubleToLongBits(x);
        if (bits < 0) {
            return -0.0;
        }
        return 0.0;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    if (negative) {
        // Flip bit 1
        quadrant ^= 2;
    }
    switch(quadrant) {
        case 0:
            return sinQ(xa, xb);
        case 1:
            return cosQ(xa, xb);
        case 2:
            return -sinQ(xa, xb);
        case 3:
            return -cosQ(xa, xb);
        default:
            return Double.NaN;
    }
}","public void test146146() throws Throwable {
    double double0 = FastMath.sin((-26289.35832616549));
    assertEquals((-0.4890505549521145), double0, 0.01);
}","/**
 *  Sine function.
 *  @param x a number
 *  @return sin(x)
 */"
"public static double sin(double x) {
    boolean negative = false;
    int quadrant = 0;
    double xa;
    double xb = 0.0;
    /* Take absolute value of the input */
    xa = x;
    if (x < 0) {
        negative = true;
        xa = -xa;
    }
    /* Check for zero and negative zero */
    if (xa == 0.0) {
        long bits = Double.doubleToLongBits(x);
        if (bits < 0) {
            return -0.0;
        }
        return 0.0;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    if (negative) {
        // Flip bit 1
        quadrant ^= 2;
    }
    switch(quadrant) {
        case 0:
            return sinQ(xa, xb);
        case 1:
            return cosQ(xa, xb);
        case 2:
            return -sinQ(xa, xb);
        case 3:
            return -cosQ(xa, xb);
        default:
            return Double.NaN;
    }
}","public void test147147() throws Throwable {
    double double0 = FastMath.sin(3.141592653589793);
    assertEquals(1.2246467991473532E-16, double0, 0.01);
}","/**
 *  Sine function.
 *  @param x a number
 *  @return sin(x)
 */"
"public static double sin(double x) {
    boolean negative = false;
    int quadrant = 0;
    double xa;
    double xb = 0.0;
    /* Take absolute value of the input */
    xa = x;
    if (x < 0) {
        negative = true;
        xa = -xa;
    }
    /* Check for zero and negative zero */
    if (xa == 0.0) {
        long bits = Double.doubleToLongBits(x);
        if (bits < 0) {
            return -0.0;
        }
        return 0.0;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    if (negative) {
        // Flip bit 1
        quadrant ^= 2;
    }
    switch(quadrant) {
        case 0:
            return sinQ(xa, xb);
        case 1:
            return cosQ(xa, xb);
        case 2:
            return -sinQ(xa, xb);
        case 3:
            return -cosQ(xa, xb);
        default:
            return Double.NaN;
    }
}","public void test148148() throws Throwable {
    double double0 = FastMath.sin(Double.NEGATIVE_INFINITY);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 *  Sine function.
 *  @param x a number
 *  @return sin(x)
 */"
"public static double sin(double x) {
    boolean negative = false;
    int quadrant = 0;
    double xa;
    double xb = 0.0;
    /* Take absolute value of the input */
    xa = x;
    if (x < 0) {
        negative = true;
        xa = -xa;
    }
    /* Check for zero and negative zero */
    if (xa == 0.0) {
        long bits = Double.doubleToLongBits(x);
        if (bits < 0) {
            return -0.0;
        }
        return 0.0;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    if (negative) {
        // Flip bit 1
        quadrant ^= 2;
    }
    switch(quadrant) {
        case 0:
            return sinQ(xa, xb);
        case 1:
            return cosQ(xa, xb);
        case 2:
            return -sinQ(xa, xb);
        case 3:
            return -cosQ(xa, xb);
        default:
            return Double.NaN;
    }
}","public void test149149() throws Throwable {
    double double0 = FastMath.sin(Double.NaN);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 *  Sine function.
 *  @param x a number
 *  @return sin(x)
 */"
"public static double sin(double x) {
    boolean negative = false;
    int quadrant = 0;
    double xa;
    double xb = 0.0;
    /* Take absolute value of the input */
    xa = x;
    if (x < 0) {
        negative = true;
        xa = -xa;
    }
    /* Check for zero and negative zero */
    if (xa == 0.0) {
        long bits = Double.doubleToLongBits(x);
        if (bits < 0) {
            return -0.0;
        }
        return 0.0;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    if (negative) {
        // Flip bit 1
        quadrant ^= 2;
    }
    switch(quadrant) {
        case 0:
            return sinQ(xa, xb);
        case 1:
            return cosQ(xa, xb);
        case 2:
            return -sinQ(xa, xb);
        case 3:
            return -cosQ(xa, xb);
        default:
            return Double.NaN;
    }
}","public void test150150() throws Throwable {
    double double0 = FastMath.sin(0.0);
    assertEquals(0.0, double0, 0.01);
}","/**
 *  Sine function.
 *  @param x a number
 *  @return sin(x)
 */"
"public static double sin(double x) {
    boolean negative = false;
    int quadrant = 0;
    double xa;
    double xb = 0.0;
    /* Take absolute value of the input */
    xa = x;
    if (x < 0) {
        negative = true;
        xa = -xa;
    }
    /* Check for zero and negative zero */
    if (xa == 0.0) {
        long bits = Double.doubleToLongBits(x);
        if (bits < 0) {
            return -0.0;
        }
        return 0.0;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    if (negative) {
        // Flip bit 1
        quadrant ^= 2;
    }
    switch(quadrant) {
        case 0:
            return sinQ(xa, xb);
        case 1:
            return cosQ(xa, xb);
        case 2:
            return -sinQ(xa, xb);
        case 3:
            return -cosQ(xa, xb);
        default:
            return Double.NaN;
    }
}","public void test151151() throws Throwable {
    double double0 = FastMath.sin(2147483594);
    assertEquals(0.9384061647119671, double0, 0.01);
}","/**
 *  Sine function.
 *  @param x a number
 *  @return sin(x)
 */"
"public static double tan(double x) {
    boolean negative = false;
    int quadrant = 0;
    /* Take absolute value of the input */
    double xa = x;
    if (x < 0) {
        negative = true;
        xa = -xa;
    }
    /* Check for zero and negative zero */
    if (xa == 0.0) {
        long bits = Double.doubleToLongBits(x);
        if (bits < 0) {
            return -0.0;
        }
        return 0.0;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    double xb = 0;
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    if (xa > 1.5) {
        // Accurracy suffers between 1.5 and PI/2
        final double pi2a = 1.5707963267948966;
        final double pi2b = 6.123233995736766E-17;
        final double a = pi2a - xa;
        double b = -(a - pi2a + xa);
        b += pi2b - xb;
        xa = a + b;
        xb = -(xa - a - b);
        quadrant ^= 1;
        negative ^= true;
    }
    double result;
    if ((quadrant & 1) == 0) {
        result = tanQ(xa, xb, false);
    } else {
        result = -tanQ(xa, xb, true);
    }
    if (negative) {
        result = -result;
    }
    return result;
}","public void test152152() throws Throwable {
    double double0 = FastMath.tan(1003734390);
    assertEquals(5.211627199720771, double0, 0.01);
}","/**
 *   Tangent function
 *  @param x a number
 *  @return tan(x)
 */"
"public static double sin(double x) {
    boolean negative = false;
    int quadrant = 0;
    double xa;
    double xb = 0.0;
    /* Take absolute value of the input */
    xa = x;
    if (x < 0) {
        negative = true;
        xa = -xa;
    }
    /* Check for zero and negative zero */
    if (xa == 0.0) {
        long bits = Double.doubleToLongBits(x);
        if (bits < 0) {
            return -0.0;
        }
        return 0.0;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    if (negative) {
        // Flip bit 1
        quadrant ^= 2;
    }
    switch(quadrant) {
        case 0:
            return sinQ(xa, xb);
        case 1:
            return cosQ(xa, xb);
        case 2:
            return -sinQ(xa, xb);
        case 3:
            return -cosQ(xa, xb);
        default:
            return Double.NaN;
    }
}","public void test153153() throws Throwable {
    double double0 = FastMath.sin(2061584302);
    assertEquals(0.9961585365086896, double0, 0.01);
}","/**
 *  Sine function.
 *  @param x a number
 *  @return sin(x)
 */"
"public static double cos(double x) {
    int quadrant = 0;
    /* Take absolute value of the input */
    double xa = x;
    if (x < 0) {
        xa = -xa;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    double xb = 0;
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    //if (negative)
    //  quadrant = (quadrant + 2) % 4;
    switch(quadrant) {
        case 0:
            return cosQ(xa, xb);
        case 1:
            return -sinQ(xa, xb);
        case 2:
            return -cosQ(xa, xb);
        case 3:
            return sinQ(xa, xb);
        default:
            return Double.NaN;
    }
}","public void test154154() throws Throwable {
    double double0 = FastMath.cos(2.85040095144011776E17);
    assertEquals((-0.00918780066381382), double0, 0.01);
}","/**
 *  Cosine function
 *  @param x a number
 *  @return cos(x)
 */"
"public static double tan(double x) {
    boolean negative = false;
    int quadrant = 0;
    /* Take absolute value of the input */
    double xa = x;
    if (x < 0) {
        negative = true;
        xa = -xa;
    }
    /* Check for zero and negative zero */
    if (xa == 0.0) {
        long bits = Double.doubleToLongBits(x);
        if (bits < 0) {
            return -0.0;
        }
        return 0.0;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    double xb = 0;
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    if (xa > 1.5) {
        // Accurracy suffers between 1.5 and PI/2
        final double pi2a = 1.5707963267948966;
        final double pi2b = 6.123233995736766E-17;
        final double a = pi2a - xa;
        double b = -(a - pi2a + xa);
        b += pi2b - xb;
        xa = a + b;
        xb = -(xa - a - b);
        quadrant ^= 1;
        negative ^= true;
    }
    double result;
    if ((quadrant & 1) == 0) {
        result = tanQ(xa, xb, false);
    } else {
        result = -tanQ(xa, xb, true);
    }
    if (negative) {
        result = -result;
    }
    return result;
}","public void test155155() throws Throwable {
    double double0 = FastMath.tan((-6705138.972558685));
    assertEquals((-0.07301950858910497), double0, 0.01);
}","/**
 *   Tangent function
 *  @param x a number
 *  @return tan(x)
 */"
"public static double tan(double x) {
    boolean negative = false;
    int quadrant = 0;
    /* Take absolute value of the input */
    double xa = x;
    if (x < 0) {
        negative = true;
        xa = -xa;
    }
    /* Check for zero and negative zero */
    if (xa == 0.0) {
        long bits = Double.doubleToLongBits(x);
        if (bits < 0) {
            return -0.0;
        }
        return 0.0;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    double xb = 0;
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    if (xa > 1.5) {
        // Accurracy suffers between 1.5 and PI/2
        final double pi2a = 1.5707963267948966;
        final double pi2b = 6.123233995736766E-17;
        final double a = pi2a - xa;
        double b = -(a - pi2a + xa);
        b += pi2b - xb;
        xa = a + b;
        xb = -(xa - a - b);
        quadrant ^= 1;
        negative ^= true;
    }
    double result;
    if ((quadrant & 1) == 0) {
        result = tanQ(xa, xb, false);
    } else {
        result = -tanQ(xa, xb, true);
    }
    if (negative) {
        result = -result;
    }
    return result;
}","public void test156156() throws Throwable {
    double double0 = FastMath.tan(8.0E298);
    assertEquals((-0.04237639320697582), double0, 0.01);
}","/**
 *   Tangent function
 *  @param x a number
 *  @return tan(x)
 */"
"public static double tan(double x) {
    boolean negative = false;
    int quadrant = 0;
    /* Take absolute value of the input */
    double xa = x;
    if (x < 0) {
        negative = true;
        xa = -xa;
    }
    /* Check for zero and negative zero */
    if (xa == 0.0) {
        long bits = Double.doubleToLongBits(x);
        if (bits < 0) {
            return -0.0;
        }
        return 0.0;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    double xb = 0;
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    if (xa > 1.5) {
        // Accurracy suffers between 1.5 and PI/2
        final double pi2a = 1.5707963267948966;
        final double pi2b = 6.123233995736766E-17;
        final double a = pi2a - xa;
        double b = -(a - pi2a + xa);
        b += pi2b - xb;
        xa = a + b;
        xb = -(xa - a - b);
        quadrant ^= 1;
        negative ^= true;
    }
    double result;
    if ((quadrant & 1) == 0) {
        result = tanQ(xa, xb, false);
    } else {
        result = -tanQ(xa, xb, true);
    }
    if (negative) {
        result = -result;
    }
    return result;
}","public void test157157() throws Throwable {
    double double0 = FastMath.tan((-6705139.388311141));
    assertEquals((-0.5316458258475749), double0, 0.01);
}","/**
 *   Tangent function
 *  @param x a number
 *  @return tan(x)
 */"
"public static double tan(double x) {
    boolean negative = false;
    int quadrant = 0;
    /* Take absolute value of the input */
    double xa = x;
    if (x < 0) {
        negative = true;
        xa = -xa;
    }
    /* Check for zero and negative zero */
    if (xa == 0.0) {
        long bits = Double.doubleToLongBits(x);
        if (bits < 0) {
            return -0.0;
        }
        return 0.0;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    double xb = 0;
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    if (xa > 1.5) {
        // Accurracy suffers between 1.5 and PI/2
        final double pi2a = 1.5707963267948966;
        final double pi2b = 6.123233995736766E-17;
        final double a = pi2a - xa;
        double b = -(a - pi2a + xa);
        b += pi2b - xb;
        xa = a + b;
        xb = -(xa - a - b);
        quadrant ^= 1;
        negative ^= true;
    }
    double result;
    if ((quadrant & 1) == 0) {
        result = tanQ(xa, xb, false);
    } else {
        result = -tanQ(xa, xb, true);
    }
    if (negative) {
        result = -result;
    }
    return result;
}","public void test158158() throws Throwable {
    double double0 = FastMath.tan(0.6409968137741089);
    assertEquals(0.7460943665116851, double0, 0.01);
}","/**
 *   Tangent function
 *  @param x a number
 *  @return tan(x)
 */"
"public static double sin(double x) {
    boolean negative = false;
    int quadrant = 0;
    double xa;
    double xb = 0.0;
    /* Take absolute value of the input */
    xa = x;
    if (x < 0) {
        negative = true;
        xa = -xa;
    }
    /* Check for zero and negative zero */
    if (xa == 0.0) {
        long bits = Double.doubleToLongBits(x);
        if (bits < 0) {
            return -0.0;
        }
        return 0.0;
    }
    if (xa != xa || xa == Double.POSITIVE_INFINITY) {
        return Double.NaN;
    }
    /* Perform any argument reduction */
    if (xa > 3294198.0) {
        // PI * (2**20)
        // Argument too big for CodyWaite reduction.  Must use
        // PayneHanek.
        double[] reduceResults = new double[3];
        reducePayneHanek(xa, reduceResults);
        quadrant = ((int) reduceResults[0]) & 3;
        xa = reduceResults[1];
        xb = reduceResults[2];
    } else if (xa > 1.5707963267948966) {
        /* Inline the Cody/Waite reduction for performance */
        // Estimate k
        //k = (int)(xa / 1.5707963267948966);
        int k = (int) (xa * 0.6366197723675814);
        // Compute remainder
        double remA;
        double remB;
        while (true) {
            double a = -k * 1.570796251296997;
            remA = xa + a;
            remB = -(remA - xa - a);
            a = -k * 7.549789948768648E-8;
            double b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            a = -k * 6.123233995736766E-17;
            b = remA;
            remA = a + b;
            remB += -(remA - b - a);
            if (remA > 0.0)
                break;
            // Remainder is negative, so decrement k and try again.
            // This should only happen if the input is very close
            // to an even multiple of pi/2
            k--;
        }
        quadrant = k & 3;
        xa = remA;
        xb = remB;
    }
    if (negative) {
        // Flip bit 1
        quadrant ^= 2;
    }
    switch(quadrant) {
        case 0:
            return sinQ(xa, xb);
        case 1:
            return cosQ(xa, xb);
        case 2:
            return -sinQ(xa, xb);
        case 3:
            return -cosQ(xa, xb);
        default:
            return Double.NaN;
    }
}","public void test159159() throws Throwable {
    double double0 = FastMath.sin(0.1538461446762085);
    assertEquals(0.1532399744099201, double0, 0.01);
}","/**
 *  Sine function.
 *  @param x a number
 *  @return sin(x)
 */"
"public static double pow(double x, double y) {
    final double[] lns = new double[2];
    if (y == 0.0) {
        return 1.0;
    }
    if (x != x) {
        // X is NaN
        return x;
    }
    if (x == 0) {
        long bits = Double.doubleToLongBits(x);
        if ((bits & 0x8000000000000000L) != 0) {
            // -zero
            long yi = (long) y;
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            if (y > 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
        }
        if (y < 0) {
            return Double.POSITIVE_INFINITY;
        }
        if (y > 0) {
            return 0.0;
        }
        return Double.NaN;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0.0) {
            return 0.0;
        } else {
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x * x == 1.0)
            return Double.NaN;
        if (x * x > 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            return 0.0;
        }
        if (y > 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x * x == 1.0) {
            return Double.NaN;
        }
        if (x * x < 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    /* Handle special case x<0 */
    if (x < 0) {
        // y is an even integer in this case
        if (y >= 4503599627370496.0 || y <= -4503599627370496.0) {
            return pow(-x, y);
        }
        if (y == (long) y) {
            // If y is an integer
            return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y);
        } else {
            return Double.NaN;
        }
    }
    /* Split y into ya and yb such that y = ya+yb */
    double ya;
    double yb;
    if (y < 8e298 && y > -8e298) {
        double tmp1 = y * 1073741824.0;
        ya = y + tmp1 - tmp1;
        yb = y - ya;
    } else {
        double tmp1 = y * 9.31322574615478515625E-10;
        double tmp2 = tmp1 * 9.31322574615478515625E-10;
        ya = (tmp1 + tmp2 - tmp1) * 1073741824.0 * 1073741824.0;
        yb = y - ya;
    }
    /* Compute ln(x) */
    log(x, lns);
    double lna = lns[0];
    double lnb = lns[1];
    /* resplit lns */
    double tmp1 = lna * 1073741824.0;
    double tmp2 = lna + tmp1 - tmp1;
    lnb += lna - tmp2;
    lna = tmp2;
    // y*ln(x) = (aa+ab)
    final double aa = lna * ya;
    final double ab = lna * yb + lnb * ya + lnb * yb;
    lna = aa + ab;
    lnb = -(lna - aa - ab);
    double z = 1.0 / 120.0;
    z = z * lnb + (1.0 / 24.0);
    z = z * lnb + (1.0 / 6.0);
    z = z * lnb + 0.5;
    z = z * lnb + 1.0;
    z = z * lnb;
    final double result = exp(lna, z, null);
    //result = result + result * z;
    return result;
}","public void test160160() throws Throwable {
    double double0 = FastMath.pow(3197.206125659861, Double.NaN);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Power function.  Compute x^y.
 *
 * @param x   a double
 * @param y   a double
 * @return double
 */"
"public static double pow(double x, double y) {
    final double[] lns = new double[2];
    if (y == 0.0) {
        return 1.0;
    }
    if (x != x) {
        // X is NaN
        return x;
    }
    if (x == 0) {
        long bits = Double.doubleToLongBits(x);
        if ((bits & 0x8000000000000000L) != 0) {
            // -zero
            long yi = (long) y;
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            if (y > 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
        }
        if (y < 0) {
            return Double.POSITIVE_INFINITY;
        }
        if (y > 0) {
            return 0.0;
        }
        return Double.NaN;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0.0) {
            return 0.0;
        } else {
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x * x == 1.0)
            return Double.NaN;
        if (x * x > 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            return 0.0;
        }
        if (y > 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x * x == 1.0) {
            return Double.NaN;
        }
        if (x * x < 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    /* Handle special case x<0 */
    if (x < 0) {
        // y is an even integer in this case
        if (y >= 4503599627370496.0 || y <= -4503599627370496.0) {
            return pow(-x, y);
        }
        if (y == (long) y) {
            // If y is an integer
            return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y);
        } else {
            return Double.NaN;
        }
    }
    /* Split y into ya and yb such that y = ya+yb */
    double ya;
    double yb;
    if (y < 8e298 && y > -8e298) {
        double tmp1 = y * 1073741824.0;
        ya = y + tmp1 - tmp1;
        yb = y - ya;
    } else {
        double tmp1 = y * 9.31322574615478515625E-10;
        double tmp2 = tmp1 * 9.31322574615478515625E-10;
        ya = (tmp1 + tmp2 - tmp1) * 1073741824.0 * 1073741824.0;
        yb = y - ya;
    }
    /* Compute ln(x) */
    log(x, lns);
    double lna = lns[0];
    double lnb = lns[1];
    /* resplit lns */
    double tmp1 = lna * 1073741824.0;
    double tmp2 = lna + tmp1 - tmp1;
    lnb += lna - tmp2;
    lna = tmp2;
    // y*ln(x) = (aa+ab)
    final double aa = lna * ya;
    final double ab = lna * yb + lnb * ya + lnb * yb;
    lna = aa + ab;
    lnb = -(lna - aa - ab);
    double z = 1.0 / 120.0;
    z = z * lnb + (1.0 / 24.0);
    z = z * lnb + (1.0 / 6.0);
    z = z * lnb + 0.5;
    z = z * lnb + 1.0;
    z = z * lnb;
    final double result = exp(lna, z, null);
    //result = result + result * z;
    return result;
}","public void test161161() throws Throwable {
    double double0 = FastMath.pow((-1.0), (-1.0));
    assertEquals((-1.0), double0, 0.01);
}","/**
 * Power function.  Compute x^y.
 *
 * @param x   a double
 * @param y   a double
 * @return double
 */"
"public static double pow(double x, double y) {
    final double[] lns = new double[2];
    if (y == 0.0) {
        return 1.0;
    }
    if (x != x) {
        // X is NaN
        return x;
    }
    if (x == 0) {
        long bits = Double.doubleToLongBits(x);
        if ((bits & 0x8000000000000000L) != 0) {
            // -zero
            long yi = (long) y;
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            if (y > 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
        }
        if (y < 0) {
            return Double.POSITIVE_INFINITY;
        }
        if (y > 0) {
            return 0.0;
        }
        return Double.NaN;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0.0) {
            return 0.0;
        } else {
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x * x == 1.0)
            return Double.NaN;
        if (x * x > 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            return 0.0;
        }
        if (y > 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x * x == 1.0) {
            return Double.NaN;
        }
        if (x * x < 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    /* Handle special case x<0 */
    if (x < 0) {
        // y is an even integer in this case
        if (y >= 4503599627370496.0 || y <= -4503599627370496.0) {
            return pow(-x, y);
        }
        if (y == (long) y) {
            // If y is an integer
            return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y);
        } else {
            return Double.NaN;
        }
    }
    /* Split y into ya and yb such that y = ya+yb */
    double ya;
    double yb;
    if (y < 8e298 && y > -8e298) {
        double tmp1 = y * 1073741824.0;
        ya = y + tmp1 - tmp1;
        yb = y - ya;
    } else {
        double tmp1 = y * 9.31322574615478515625E-10;
        double tmp2 = tmp1 * 9.31322574615478515625E-10;
        ya = (tmp1 + tmp2 - tmp1) * 1073741824.0 * 1073741824.0;
        yb = y - ya;
    }
    /* Compute ln(x) */
    log(x, lns);
    double lna = lns[0];
    double lnb = lns[1];
    /* resplit lns */
    double tmp1 = lna * 1073741824.0;
    double tmp2 = lna + tmp1 - tmp1;
    lnb += lna - tmp2;
    lna = tmp2;
    // y*ln(x) = (aa+ab)
    final double aa = lna * ya;
    final double ab = lna * yb + lnb * ya + lnb * yb;
    lna = aa + ab;
    lnb = -(lna - aa - ab);
    double z = 1.0 / 120.0;
    z = z * lnb + (1.0 / 24.0);
    z = z * lnb + (1.0 / 6.0);
    z = z * lnb + 0.5;
    z = z * lnb + 1.0;
    z = z * lnb;
    final double result = exp(lna, z, null);
    //result = result + result * z;
    return result;
}","public void test162162() throws Throwable {
    double double0 = FastMath.pow((-1.8918886108479045), 3.001117512531765E-7);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Power function.  Compute x^y.
 *
 * @param x   a double
 * @param y   a double
 * @return double
 */"
"public static double pow(double x, double y) {
    final double[] lns = new double[2];
    if (y == 0.0) {
        return 1.0;
    }
    if (x != x) {
        // X is NaN
        return x;
    }
    if (x == 0) {
        long bits = Double.doubleToLongBits(x);
        if ((bits & 0x8000000000000000L) != 0) {
            // -zero
            long yi = (long) y;
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            if (y > 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
        }
        if (y < 0) {
            return Double.POSITIVE_INFINITY;
        }
        if (y > 0) {
            return 0.0;
        }
        return Double.NaN;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0.0) {
            return 0.0;
        } else {
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x * x == 1.0)
            return Double.NaN;
        if (x * x > 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            return 0.0;
        }
        if (y > 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x * x == 1.0) {
            return Double.NaN;
        }
        if (x * x < 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    /* Handle special case x<0 */
    if (x < 0) {
        // y is an even integer in this case
        if (y >= 4503599627370496.0 || y <= -4503599627370496.0) {
            return pow(-x, y);
        }
        if (y == (long) y) {
            // If y is an integer
            return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y);
        } else {
            return Double.NaN;
        }
    }
    /* Split y into ya and yb such that y = ya+yb */
    double ya;
    double yb;
    if (y < 8e298 && y > -8e298) {
        double tmp1 = y * 1073741824.0;
        ya = y + tmp1 - tmp1;
        yb = y - ya;
    } else {
        double tmp1 = y * 9.31322574615478515625E-10;
        double tmp2 = tmp1 * 9.31322574615478515625E-10;
        ya = (tmp1 + tmp2 - tmp1) * 1073741824.0 * 1073741824.0;
        yb = y - ya;
    }
    /* Compute ln(x) */
    log(x, lns);
    double lna = lns[0];
    double lnb = lns[1];
    /* resplit lns */
    double tmp1 = lna * 1073741824.0;
    double tmp2 = lna + tmp1 - tmp1;
    lnb += lna - tmp2;
    lna = tmp2;
    // y*ln(x) = (aa+ab)
    final double aa = lna * ya;
    final double ab = lna * yb + lnb * ya + lnb * yb;
    lna = aa + ab;
    lnb = -(lna - aa - ab);
    double z = 1.0 / 120.0;
    z = z * lnb + (1.0 / 24.0);
    z = z * lnb + (1.0 / 6.0);
    z = z * lnb + 0.5;
    z = z * lnb + 1.0;
    z = z * lnb;
    final double result = exp(lna, z, null);
    //result = result + result * z;
    return result;
}","public void test163163() throws Throwable {
    double double0 = FastMath.pow((-4.503599627370496E15), (-4.503599627370496E15));
    assertEquals(0.0, double0, 0.01);
}","/**
 * Power function.  Compute x^y.
 *
 * @param x   a double
 * @param y   a double
 * @return double
 */"
"public static double pow(double x, double y) {
    final double[] lns = new double[2];
    if (y == 0.0) {
        return 1.0;
    }
    if (x != x) {
        // X is NaN
        return x;
    }
    if (x == 0) {
        long bits = Double.doubleToLongBits(x);
        if ((bits & 0x8000000000000000L) != 0) {
            // -zero
            long yi = (long) y;
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            if (y > 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
        }
        if (y < 0) {
            return Double.POSITIVE_INFINITY;
        }
        if (y > 0) {
            return 0.0;
        }
        return Double.NaN;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0.0) {
            return 0.0;
        } else {
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x * x == 1.0)
            return Double.NaN;
        if (x * x > 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            return 0.0;
        }
        if (y > 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x * x == 1.0) {
            return Double.NaN;
        }
        if (x * x < 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    /* Handle special case x<0 */
    if (x < 0) {
        // y is an even integer in this case
        if (y >= 4503599627370496.0 || y <= -4503599627370496.0) {
            return pow(-x, y);
        }
        if (y == (long) y) {
            // If y is an integer
            return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y);
        } else {
            return Double.NaN;
        }
    }
    /* Split y into ya and yb such that y = ya+yb */
    double ya;
    double yb;
    if (y < 8e298 && y > -8e298) {
        double tmp1 = y * 1073741824.0;
        ya = y + tmp1 - tmp1;
        yb = y - ya;
    } else {
        double tmp1 = y * 9.31322574615478515625E-10;
        double tmp2 = tmp1 * 9.31322574615478515625E-10;
        ya = (tmp1 + tmp2 - tmp1) * 1073741824.0 * 1073741824.0;
        yb = y - ya;
    }
    /* Compute ln(x) */
    log(x, lns);
    double lna = lns[0];
    double lnb = lns[1];
    /* resplit lns */
    double tmp1 = lna * 1073741824.0;
    double tmp2 = lna + tmp1 - tmp1;
    lnb += lna - tmp2;
    lna = tmp2;
    // y*ln(x) = (aa+ab)
    final double aa = lna * ya;
    final double ab = lna * yb + lnb * ya + lnb * yb;
    lna = aa + ab;
    lnb = -(lna - aa - ab);
    double z = 1.0 / 120.0;
    z = z * lnb + (1.0 / 24.0);
    z = z * lnb + (1.0 / 6.0);
    z = z * lnb + 0.5;
    z = z * lnb + 1.0;
    z = z * lnb;
    final double result = exp(lna, z, null);
    //result = result + result * z;
    return result;
}","public void test164164() throws Throwable {
    double double0 = FastMath.pow((-4016.29948), 20.0);
    assertEquals(1.1926740780371286E72, double0, 0.01);
}","/**
 * Power function.  Compute x^y.
 *
 * @param x   a double
 * @param y   a double
 * @return double
 */"
"public static double pow(double x, double y) {
    final double[] lns = new double[2];
    if (y == 0.0) {
        return 1.0;
    }
    if (x != x) {
        // X is NaN
        return x;
    }
    if (x == 0) {
        long bits = Double.doubleToLongBits(x);
        if ((bits & 0x8000000000000000L) != 0) {
            // -zero
            long yi = (long) y;
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            if (y > 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
        }
        if (y < 0) {
            return Double.POSITIVE_INFINITY;
        }
        if (y > 0) {
            return 0.0;
        }
        return Double.NaN;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0.0) {
            return 0.0;
        } else {
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x * x == 1.0)
            return Double.NaN;
        if (x * x > 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            return 0.0;
        }
        if (y > 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x * x == 1.0) {
            return Double.NaN;
        }
        if (x * x < 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    /* Handle special case x<0 */
    if (x < 0) {
        // y is an even integer in this case
        if (y >= 4503599627370496.0 || y <= -4503599627370496.0) {
            return pow(-x, y);
        }
        if (y == (long) y) {
            // If y is an integer
            return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y);
        } else {
            return Double.NaN;
        }
    }
    /* Split y into ya and yb such that y = ya+yb */
    double ya;
    double yb;
    if (y < 8e298 && y > -8e298) {
        double tmp1 = y * 1073741824.0;
        ya = y + tmp1 - tmp1;
        yb = y - ya;
    } else {
        double tmp1 = y * 9.31322574615478515625E-10;
        double tmp2 = tmp1 * 9.31322574615478515625E-10;
        ya = (tmp1 + tmp2 - tmp1) * 1073741824.0 * 1073741824.0;
        yb = y - ya;
    }
    /* Compute ln(x) */
    log(x, lns);
    double lna = lns[0];
    double lnb = lns[1];
    /* resplit lns */
    double tmp1 = lna * 1073741824.0;
    double tmp2 = lna + tmp1 - tmp1;
    lnb += lna - tmp2;
    lna = tmp2;
    // y*ln(x) = (aa+ab)
    final double aa = lna * ya;
    final double ab = lna * yb + lnb * ya + lnb * yb;
    lna = aa + ab;
    lnb = -(lna - aa - ab);
    double z = 1.0 / 120.0;
    z = z * lnb + (1.0 / 24.0);
    z = z * lnb + (1.0 / 6.0);
    z = z * lnb + 0.5;
    z = z * lnb + 1.0;
    z = z * lnb;
    final double result = exp(lna, z, null);
    //result = result + result * z;
    return result;
}","public void test165165() throws Throwable {
    double double0 = FastMath.pow(Double.NEGATIVE_INFINITY, 1.197421629234348);
    assertEquals(Double.POSITIVE_INFINITY, double0, 0.01);
}","/**
 * Power function.  Compute x^y.
 *
 * @param x   a double
 * @param y   a double
 * @return double
 */"
"public static double pow(double x, double y) {
    final double[] lns = new double[2];
    if (y == 0.0) {
        return 1.0;
    }
    if (x != x) {
        // X is NaN
        return x;
    }
    if (x == 0) {
        long bits = Double.doubleToLongBits(x);
        if ((bits & 0x8000000000000000L) != 0) {
            // -zero
            long yi = (long) y;
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            if (y > 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
        }
        if (y < 0) {
            return Double.POSITIVE_INFINITY;
        }
        if (y > 0) {
            return 0.0;
        }
        return Double.NaN;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0.0) {
            return 0.0;
        } else {
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x * x == 1.0)
            return Double.NaN;
        if (x * x > 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            return 0.0;
        }
        if (y > 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x * x == 1.0) {
            return Double.NaN;
        }
        if (x * x < 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    /* Handle special case x<0 */
    if (x < 0) {
        // y is an even integer in this case
        if (y >= 4503599627370496.0 || y <= -4503599627370496.0) {
            return pow(-x, y);
        }
        if (y == (long) y) {
            // If y is an integer
            return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y);
        } else {
            return Double.NaN;
        }
    }
    /* Split y into ya and yb such that y = ya+yb */
    double ya;
    double yb;
    if (y < 8e298 && y > -8e298) {
        double tmp1 = y * 1073741824.0;
        ya = y + tmp1 - tmp1;
        yb = y - ya;
    } else {
        double tmp1 = y * 9.31322574615478515625E-10;
        double tmp2 = tmp1 * 9.31322574615478515625E-10;
        ya = (tmp1 + tmp2 - tmp1) * 1073741824.0 * 1073741824.0;
        yb = y - ya;
    }
    /* Compute ln(x) */
    log(x, lns);
    double lna = lns[0];
    double lnb = lns[1];
    /* resplit lns */
    double tmp1 = lna * 1073741824.0;
    double tmp2 = lna + tmp1 - tmp1;
    lnb += lna - tmp2;
    lna = tmp2;
    // y*ln(x) = (aa+ab)
    final double aa = lna * ya;
    final double ab = lna * yb + lnb * ya + lnb * yb;
    lna = aa + ab;
    lnb = -(lna - aa - ab);
    double z = 1.0 / 120.0;
    z = z * lnb + (1.0 / 24.0);
    z = z * lnb + (1.0 / 6.0);
    z = z * lnb + 0.5;
    z = z * lnb + 1.0;
    z = z * lnb;
    final double result = exp(lna, z, null);
    //result = result + result * z;
    return result;
}","public void test166166() throws Throwable {
    double double0 = FastMath.pow(207.2730473156495, Double.POSITIVE_INFINITY);
    assertEquals(Double.POSITIVE_INFINITY, double0, 0.01);
}","/**
 * Power function.  Compute x^y.
 *
 * @param x   a double
 * @param y   a double
 * @return double
 */"
"public static double pow(double x, double y) {
    final double[] lns = new double[2];
    if (y == 0.0) {
        return 1.0;
    }
    if (x != x) {
        // X is NaN
        return x;
    }
    if (x == 0) {
        long bits = Double.doubleToLongBits(x);
        if ((bits & 0x8000000000000000L) != 0) {
            // -zero
            long yi = (long) y;
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            if (y > 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
        }
        if (y < 0) {
            return Double.POSITIVE_INFINITY;
        }
        if (y > 0) {
            return 0.0;
        }
        return Double.NaN;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0.0) {
            return 0.0;
        } else {
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x * x == 1.0)
            return Double.NaN;
        if (x * x > 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            return 0.0;
        }
        if (y > 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x * x == 1.0) {
            return Double.NaN;
        }
        if (x * x < 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    /* Handle special case x<0 */
    if (x < 0) {
        // y is an even integer in this case
        if (y >= 4503599627370496.0 || y <= -4503599627370496.0) {
            return pow(-x, y);
        }
        if (y == (long) y) {
            // If y is an integer
            return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y);
        } else {
            return Double.NaN;
        }
    }
    /* Split y into ya and yb such that y = ya+yb */
    double ya;
    double yb;
    if (y < 8e298 && y > -8e298) {
        double tmp1 = y * 1073741824.0;
        ya = y + tmp1 - tmp1;
        yb = y - ya;
    } else {
        double tmp1 = y * 9.31322574615478515625E-10;
        double tmp2 = tmp1 * 9.31322574615478515625E-10;
        ya = (tmp1 + tmp2 - tmp1) * 1073741824.0 * 1073741824.0;
        yb = y - ya;
    }
    /* Compute ln(x) */
    log(x, lns);
    double lna = lns[0];
    double lnb = lns[1];
    /* resplit lns */
    double tmp1 = lna * 1073741824.0;
    double tmp2 = lna + tmp1 - tmp1;
    lnb += lna - tmp2;
    lna = tmp2;
    // y*ln(x) = (aa+ab)
    final double aa = lna * ya;
    final double ab = lna * yb + lnb * ya + lnb * yb;
    lna = aa + ab;
    lnb = -(lna - aa - ab);
    double z = 1.0 / 120.0;
    z = z * lnb + (1.0 / 24.0);
    z = z * lnb + (1.0 / 6.0);
    z = z * lnb + 0.5;
    z = z * lnb + 1.0;
    z = z * lnb;
    final double result = exp(lna, z, null);
    //result = result + result * z;
    return result;
}","public void test167167() throws Throwable {
    double double0 = FastMath.pow(Double.POSITIVE_INFINITY, 534.0361263716215);
    assertEquals(Double.POSITIVE_INFINITY, double0, 0.01);
}","/**
 * Power function.  Compute x^y.
 *
 * @param x   a double
 * @param y   a double
 * @return double
 */"
"public static double pow(double x, double y) {
    final double[] lns = new double[2];
    if (y == 0.0) {
        return 1.0;
    }
    if (x != x) {
        // X is NaN
        return x;
    }
    if (x == 0) {
        long bits = Double.doubleToLongBits(x);
        if ((bits & 0x8000000000000000L) != 0) {
            // -zero
            long yi = (long) y;
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            if (y > 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
        }
        if (y < 0) {
            return Double.POSITIVE_INFINITY;
        }
        if (y > 0) {
            return 0.0;
        }
        return Double.NaN;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0.0) {
            return 0.0;
        } else {
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x * x == 1.0)
            return Double.NaN;
        if (x * x > 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            return 0.0;
        }
        if (y > 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x * x == 1.0) {
            return Double.NaN;
        }
        if (x * x < 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    /* Handle special case x<0 */
    if (x < 0) {
        // y is an even integer in this case
        if (y >= 4503599627370496.0 || y <= -4503599627370496.0) {
            return pow(-x, y);
        }
        if (y == (long) y) {
            // If y is an integer
            return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y);
        } else {
            return Double.NaN;
        }
    }
    /* Split y into ya and yb such that y = ya+yb */
    double ya;
    double yb;
    if (y < 8e298 && y > -8e298) {
        double tmp1 = y * 1073741824.0;
        ya = y + tmp1 - tmp1;
        yb = y - ya;
    } else {
        double tmp1 = y * 9.31322574615478515625E-10;
        double tmp2 = tmp1 * 9.31322574615478515625E-10;
        ya = (tmp1 + tmp2 - tmp1) * 1073741824.0 * 1073741824.0;
        yb = y - ya;
    }
    /* Compute ln(x) */
    log(x, lns);
    double lna = lns[0];
    double lnb = lns[1];
    /* resplit lns */
    double tmp1 = lna * 1073741824.0;
    double tmp2 = lna + tmp1 - tmp1;
    lnb += lna - tmp2;
    lna = tmp2;
    // y*ln(x) = (aa+ab)
    final double aa = lna * ya;
    final double ab = lna * yb + lnb * ya + lnb * yb;
    lna = aa + ab;
    lnb = -(lna - aa - ab);
    double z = 1.0 / 120.0;
    z = z * lnb + (1.0 / 24.0);
    z = z * lnb + (1.0 / 6.0);
    z = z * lnb + 0.5;
    z = z * lnb + 1.0;
    z = z * lnb;
    final double result = exp(lna, z, null);
    //result = result + result * z;
    return result;
}","public void test168168() throws Throwable {
    double double0 = FastMath.pow(Double.POSITIVE_INFINITY, Double.NaN);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Power function.  Compute x^y.
 *
 * @param x   a double
 * @param y   a double
 * @return double
 */"
"public static double pow(double x, double y) {
    final double[] lns = new double[2];
    if (y == 0.0) {
        return 1.0;
    }
    if (x != x) {
        // X is NaN
        return x;
    }
    if (x == 0) {
        long bits = Double.doubleToLongBits(x);
        if ((bits & 0x8000000000000000L) != 0) {
            // -zero
            long yi = (long) y;
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            if (y > 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
        }
        if (y < 0) {
            return Double.POSITIVE_INFINITY;
        }
        if (y > 0) {
            return 0.0;
        }
        return Double.NaN;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0.0) {
            return 0.0;
        } else {
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x * x == 1.0)
            return Double.NaN;
        if (x * x > 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            return 0.0;
        }
        if (y > 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x * x == 1.0) {
            return Double.NaN;
        }
        if (x * x < 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    /* Handle special case x<0 */
    if (x < 0) {
        // y is an even integer in this case
        if (y >= 4503599627370496.0 || y <= -4503599627370496.0) {
            return pow(-x, y);
        }
        if (y == (long) y) {
            // If y is an integer
            return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y);
        } else {
            return Double.NaN;
        }
    }
    /* Split y into ya and yb such that y = ya+yb */
    double ya;
    double yb;
    if (y < 8e298 && y > -8e298) {
        double tmp1 = y * 1073741824.0;
        ya = y + tmp1 - tmp1;
        yb = y - ya;
    } else {
        double tmp1 = y * 9.31322574615478515625E-10;
        double tmp2 = tmp1 * 9.31322574615478515625E-10;
        ya = (tmp1 + tmp2 - tmp1) * 1073741824.0 * 1073741824.0;
        yb = y - ya;
    }
    /* Compute ln(x) */
    log(x, lns);
    double lna = lns[0];
    double lnb = lns[1];
    /* resplit lns */
    double tmp1 = lna * 1073741824.0;
    double tmp2 = lna + tmp1 - tmp1;
    lnb += lna - tmp2;
    lna = tmp2;
    // y*ln(x) = (aa+ab)
    final double aa = lna * ya;
    final double ab = lna * yb + lnb * ya + lnb * yb;
    lna = aa + ab;
    lnb = -(lna - aa - ab);
    double z = 1.0 / 120.0;
    z = z * lnb + (1.0 / 24.0);
    z = z * lnb + (1.0 / 6.0);
    z = z * lnb + 0.5;
    z = z * lnb + 1.0;
    z = z * lnb;
    final double result = exp(lna, z, null);
    //result = result + result * z;
    return result;
}","public void test169169() throws Throwable {
    double double0 = FastMath.pow(0.0, Double.NaN);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Power function.  Compute x^y.
 *
 * @param x   a double
 * @param y   a double
 * @return double
 */"
"public static double pow(double x, double y) {
    final double[] lns = new double[2];
    if (y == 0.0) {
        return 1.0;
    }
    if (x != x) {
        // X is NaN
        return x;
    }
    if (x == 0) {
        long bits = Double.doubleToLongBits(x);
        if ((bits & 0x8000000000000000L) != 0) {
            // -zero
            long yi = (long) y;
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            if (y > 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
        }
        if (y < 0) {
            return Double.POSITIVE_INFINITY;
        }
        if (y > 0) {
            return 0.0;
        }
        return Double.NaN;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0.0) {
            return 0.0;
        } else {
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x * x == 1.0)
            return Double.NaN;
        if (x * x > 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            return 0.0;
        }
        if (y > 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x * x == 1.0) {
            return Double.NaN;
        }
        if (x * x < 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    /* Handle special case x<0 */
    if (x < 0) {
        // y is an even integer in this case
        if (y >= 4503599627370496.0 || y <= -4503599627370496.0) {
            return pow(-x, y);
        }
        if (y == (long) y) {
            // If y is an integer
            return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y);
        } else {
            return Double.NaN;
        }
    }
    /* Split y into ya and yb such that y = ya+yb */
    double ya;
    double yb;
    if (y < 8e298 && y > -8e298) {
        double tmp1 = y * 1073741824.0;
        ya = y + tmp1 - tmp1;
        yb = y - ya;
    } else {
        double tmp1 = y * 9.31322574615478515625E-10;
        double tmp2 = tmp1 * 9.31322574615478515625E-10;
        ya = (tmp1 + tmp2 - tmp1) * 1073741824.0 * 1073741824.0;
        yb = y - ya;
    }
    /* Compute ln(x) */
    log(x, lns);
    double lna = lns[0];
    double lnb = lns[1];
    /* resplit lns */
    double tmp1 = lna * 1073741824.0;
    double tmp2 = lna + tmp1 - tmp1;
    lnb += lna - tmp2;
    lna = tmp2;
    // y*ln(x) = (aa+ab)
    final double aa = lna * ya;
    final double ab = lna * yb + lnb * ya + lnb * yb;
    lna = aa + ab;
    lnb = -(lna - aa - ab);
    double z = 1.0 / 120.0;
    z = z * lnb + (1.0 / 24.0);
    z = z * lnb + (1.0 / 6.0);
    z = z * lnb + 0.5;
    z = z * lnb + 1.0;
    z = z * lnb;
    final double result = exp(lna, z, null);
    //result = result + result * z;
    return result;
}","public void test170170() throws Throwable {
    double double0 = FastMath.pow(0L, (-1.0));
    assertEquals(Double.POSITIVE_INFINITY, double0, 0.01);
}","/**
 * Power function.  Compute x^y.
 *
 * @param x   a double
 * @param y   a double
 * @return double
 */"
"public static double pow(double x, double y) {
    final double[] lns = new double[2];
    if (y == 0.0) {
        return 1.0;
    }
    if (x != x) {
        // X is NaN
        return x;
    }
    if (x == 0) {
        long bits = Double.doubleToLongBits(x);
        if ((bits & 0x8000000000000000L) != 0) {
            // -zero
            long yi = (long) y;
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            if (y > 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
        }
        if (y < 0) {
            return Double.POSITIVE_INFINITY;
        }
        if (y > 0) {
            return 0.0;
        }
        return Double.NaN;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0.0) {
            return 0.0;
        } else {
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x * x == 1.0)
            return Double.NaN;
        if (x * x > 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            return 0.0;
        }
        if (y > 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x * x == 1.0) {
            return Double.NaN;
        }
        if (x * x < 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    /* Handle special case x<0 */
    if (x < 0) {
        // y is an even integer in this case
        if (y >= 4503599627370496.0 || y <= -4503599627370496.0) {
            return pow(-x, y);
        }
        if (y == (long) y) {
            // If y is an integer
            return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y);
        } else {
            return Double.NaN;
        }
    }
    /* Split y into ya and yb such that y = ya+yb */
    double ya;
    double yb;
    if (y < 8e298 && y > -8e298) {
        double tmp1 = y * 1073741824.0;
        ya = y + tmp1 - tmp1;
        yb = y - ya;
    } else {
        double tmp1 = y * 9.31322574615478515625E-10;
        double tmp2 = tmp1 * 9.31322574615478515625E-10;
        ya = (tmp1 + tmp2 - tmp1) * 1073741824.0 * 1073741824.0;
        yb = y - ya;
    }
    /* Compute ln(x) */
    log(x, lns);
    double lna = lns[0];
    double lnb = lns[1];
    /* resplit lns */
    double tmp1 = lna * 1073741824.0;
    double tmp2 = lna + tmp1 - tmp1;
    lnb += lna - tmp2;
    lna = tmp2;
    // y*ln(x) = (aa+ab)
    final double aa = lna * ya;
    final double ab = lna * yb + lnb * ya + lnb * yb;
    lna = aa + ab;
    lnb = -(lna - aa - ab);
    double z = 1.0 / 120.0;
    z = z * lnb + (1.0 / 24.0);
    z = z * lnb + (1.0 / 6.0);
    z = z * lnb + 0.5;
    z = z * lnb + 1.0;
    z = z * lnb;
    final double result = exp(lna, z, null);
    //result = result + result * z;
    return result;
}","public void test171171() throws Throwable {
    double double0 = FastMath.pow(0.0, Double.POSITIVE_INFINITY);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Power function.  Compute x^y.
 *
 * @param x   a double
 * @param y   a double
 * @return double
 */"
"public static double pow(double x, double y) {
    final double[] lns = new double[2];
    if (y == 0.0) {
        return 1.0;
    }
    if (x != x) {
        // X is NaN
        return x;
    }
    if (x == 0) {
        long bits = Double.doubleToLongBits(x);
        if ((bits & 0x8000000000000000L) != 0) {
            // -zero
            long yi = (long) y;
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            if (y > 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
        }
        if (y < 0) {
            return Double.POSITIVE_INFINITY;
        }
        if (y > 0) {
            return 0.0;
        }
        return Double.NaN;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0.0) {
            return 0.0;
        } else {
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x * x == 1.0)
            return Double.NaN;
        if (x * x > 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            return 0.0;
        }
        if (y > 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x * x == 1.0) {
            return Double.NaN;
        }
        if (x * x < 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    /* Handle special case x<0 */
    if (x < 0) {
        // y is an even integer in this case
        if (y >= 4503599627370496.0 || y <= -4503599627370496.0) {
            return pow(-x, y);
        }
        if (y == (long) y) {
            // If y is an integer
            return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y);
        } else {
            return Double.NaN;
        }
    }
    /* Split y into ya and yb such that y = ya+yb */
    double ya;
    double yb;
    if (y < 8e298 && y > -8e298) {
        double tmp1 = y * 1073741824.0;
        ya = y + tmp1 - tmp1;
        yb = y - ya;
    } else {
        double tmp1 = y * 9.31322574615478515625E-10;
        double tmp2 = tmp1 * 9.31322574615478515625E-10;
        ya = (tmp1 + tmp2 - tmp1) * 1073741824.0 * 1073741824.0;
        yb = y - ya;
    }
    /* Compute ln(x) */
    log(x, lns);
    double lna = lns[0];
    double lnb = lns[1];
    /* resplit lns */
    double tmp1 = lna * 1073741824.0;
    double tmp2 = lna + tmp1 - tmp1;
    lnb += lna - tmp2;
    lna = tmp2;
    // y*ln(x) = (aa+ab)
    final double aa = lna * ya;
    final double ab = lna * yb + lnb * ya + lnb * yb;
    lna = aa + ab;
    lnb = -(lna - aa - ab);
    double z = 1.0 / 120.0;
    z = z * lnb + (1.0 / 24.0);
    z = z * lnb + (1.0 / 6.0);
    z = z * lnb + 0.5;
    z = z * lnb + 1.0;
    z = z * lnb;
    final double result = exp(lna, z, null);
    //result = result + result * z;
    return result;
}","public void test172172() throws Throwable {
    double double0 = FastMath.pow(-0.0, 5.551115123125783E-17);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Power function.  Compute x^y.
 *
 * @param x   a double
 * @param y   a double
 * @return double
 */"
"public static double pow(double x, double y) {
    final double[] lns = new double[2];
    if (y == 0.0) {
        return 1.0;
    }
    if (x != x) {
        // X is NaN
        return x;
    }
    if (x == 0) {
        long bits = Double.doubleToLongBits(x);
        if ((bits & 0x8000000000000000L) != 0) {
            // -zero
            long yi = (long) y;
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            if (y > 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
        }
        if (y < 0) {
            return Double.POSITIVE_INFINITY;
        }
        if (y > 0) {
            return 0.0;
        }
        return Double.NaN;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0.0) {
            return 0.0;
        } else {
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x * x == 1.0)
            return Double.NaN;
        if (x * x > 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            return 0.0;
        }
        if (y > 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x * x == 1.0) {
            return Double.NaN;
        }
        if (x * x < 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    /* Handle special case x<0 */
    if (x < 0) {
        // y is an even integer in this case
        if (y >= 4503599627370496.0 || y <= -4503599627370496.0) {
            return pow(-x, y);
        }
        if (y == (long) y) {
            // If y is an integer
            return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y);
        } else {
            return Double.NaN;
        }
    }
    /* Split y into ya and yb such that y = ya+yb */
    double ya;
    double yb;
    if (y < 8e298 && y > -8e298) {
        double tmp1 = y * 1073741824.0;
        ya = y + tmp1 - tmp1;
        yb = y - ya;
    } else {
        double tmp1 = y * 9.31322574615478515625E-10;
        double tmp2 = tmp1 * 9.31322574615478515625E-10;
        ya = (tmp1 + tmp2 - tmp1) * 1073741824.0 * 1073741824.0;
        yb = y - ya;
    }
    /* Compute ln(x) */
    log(x, lns);
    double lna = lns[0];
    double lnb = lns[1];
    /* resplit lns */
    double tmp1 = lna * 1073741824.0;
    double tmp2 = lna + tmp1 - tmp1;
    lnb += lna - tmp2;
    lna = tmp2;
    // y*ln(x) = (aa+ab)
    final double aa = lna * ya;
    final double ab = lna * yb + lnb * ya + lnb * yb;
    lna = aa + ab;
    lnb = -(lna - aa - ab);
    double z = 1.0 / 120.0;
    z = z * lnb + (1.0 / 24.0);
    z = z * lnb + (1.0 / 6.0);
    z = z * lnb + 0.5;
    z = z * lnb + 1.0;
    z = z * lnb;
    final double result = exp(lna, z, null);
    //result = result + result * z;
    return result;
}","public void test173173() throws Throwable {
    double double0 = FastMath.pow(Double.NaN, 1);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Power function.  Compute x^y.
 *
 * @param x   a double
 * @param y   a double
 * @return double
 */"
"public static double pow(double x, double y) {
    final double[] lns = new double[2];
    if (y == 0.0) {
        return 1.0;
    }
    if (x != x) {
        // X is NaN
        return x;
    }
    if (x == 0) {
        long bits = Double.doubleToLongBits(x);
        if ((bits & 0x8000000000000000L) != 0) {
            // -zero
            long yi = (long) y;
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            if (y > 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
        }
        if (y < 0) {
            return Double.POSITIVE_INFINITY;
        }
        if (y > 0) {
            return 0.0;
        }
        return Double.NaN;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0.0) {
            return 0.0;
        } else {
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x * x == 1.0)
            return Double.NaN;
        if (x * x > 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            return 0.0;
        }
        if (y > 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x * x == 1.0) {
            return Double.NaN;
        }
        if (x * x < 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    /* Handle special case x<0 */
    if (x < 0) {
        // y is an even integer in this case
        if (y >= 4503599627370496.0 || y <= -4503599627370496.0) {
            return pow(-x, y);
        }
        if (y == (long) y) {
            // If y is an integer
            return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y);
        } else {
            return Double.NaN;
        }
    }
    /* Split y into ya and yb such that y = ya+yb */
    double ya;
    double yb;
    if (y < 8e298 && y > -8e298) {
        double tmp1 = y * 1073741824.0;
        ya = y + tmp1 - tmp1;
        yb = y - ya;
    } else {
        double tmp1 = y * 9.31322574615478515625E-10;
        double tmp2 = tmp1 * 9.31322574615478515625E-10;
        ya = (tmp1 + tmp2 - tmp1) * 1073741824.0 * 1073741824.0;
        yb = y - ya;
    }
    /* Compute ln(x) */
    log(x, lns);
    double lna = lns[0];
    double lnb = lns[1];
    /* resplit lns */
    double tmp1 = lna * 1073741824.0;
    double tmp2 = lna + tmp1 - tmp1;
    lnb += lna - tmp2;
    lna = tmp2;
    // y*ln(x) = (aa+ab)
    final double aa = lna * ya;
    final double ab = lna * yb + lnb * ya + lnb * yb;
    lna = aa + ab;
    lnb = -(lna - aa - ab);
    double z = 1.0 / 120.0;
    z = z * lnb + (1.0 / 24.0);
    z = z * lnb + (1.0 / 6.0);
    z = z * lnb + 0.5;
    z = z * lnb + 1.0;
    z = z * lnb;
    final double result = exp(lna, z, null);
    //result = result + result * z;
    return result;
}","public void test174174() throws Throwable {
    double double0 = FastMath.pow((-354.116861617897), 0.0);
    assertEquals(1.0, double0, 0.01);
}","/**
 * Power function.  Compute x^y.
 *
 * @param x   a double
 * @param y   a double
 * @return double
 */"
"public static double log1p(final double x) {
    double xpa = 1.0 + x;
    double xpb = -(xpa - 1.0 - x);
    if (x == -1) {
        // -Infinity
        return x / 0.0;
    }
    if (x > 0 && 1 / x == 0) {
        // x = Infinity
        return x;
    }
    if (x > 1e-6 || x < -1e-6) {
        double[] hiPrec = new double[2];
        log(xpa, hiPrec);
        /* Do a taylor series expansion around xpa */
        /* f(x+y) = f(x) + f'(x)*y + f''(x)/2 y^2 */
        double fx1 = xpb / xpa;
        double epsilon = 0.5 * fx1 + 1.0;
        epsilon = epsilon * fx1;
        return epsilon + hiPrec[1] + hiPrec[0];
    }
    /* Value is small |x| < 1e6, do a Taylor series centered on 1.0 */
    double y = x * 0.333333333333333 - 0.5;
    y = y * x + 1.0;
    y = y * x;
    return y;
}","public void test175175() throws Throwable {
    double double0 = FastMath.log1p(2.639144044101463E-7);
    assertEquals(2.63914369584746E-7, double0, 0.01);
}","/**
 * Compute log(1 + x).
 * @param x a number
 * @return log(1 + x)
 */"
"public static double log1p(final double x) {
    double xpa = 1.0 + x;
    double xpb = -(xpa - 1.0 - x);
    if (x == -1) {
        // -Infinity
        return x / 0.0;
    }
    if (x > 0 && 1 / x == 0) {
        // x = Infinity
        return x;
    }
    if (x > 1e-6 || x < -1e-6) {
        double[] hiPrec = new double[2];
        log(xpa, hiPrec);
        /* Do a taylor series expansion around xpa */
        /* f(x+y) = f(x) + f'(x)*y + f''(x)/2 y^2 */
        double fx1 = xpb / xpa;
        double epsilon = 0.5 * fx1 + 1.0;
        epsilon = epsilon * fx1;
        return epsilon + hiPrec[1] + hiPrec[0];
    }
    /* Value is small |x| < 1e6, do a Taylor series centered on 1.0 */
    double y = x * 0.333333333333333 - 0.5;
    y = y * x + 1.0;
    y = y * x;
    return y;
}","public void test176176() throws Throwable {
    double double0 = FastMath.log1p(Double.POSITIVE_INFINITY);
    assertEquals(Double.POSITIVE_INFINITY, double0, 0.01);
}","/**
 * Compute log(1 + x).
 * @param x a number
 * @return log(1 + x)
 */"
"public static double log1p(final double x) {
    double xpa = 1.0 + x;
    double xpb = -(xpa - 1.0 - x);
    if (x == -1) {
        // -Infinity
        return x / 0.0;
    }
    if (x > 0 && 1 / x == 0) {
        // x = Infinity
        return x;
    }
    if (x > 1e-6 || x < -1e-6) {
        double[] hiPrec = new double[2];
        log(xpa, hiPrec);
        /* Do a taylor series expansion around xpa */
        /* f(x+y) = f(x) + f'(x)*y + f''(x)/2 y^2 */
        double fx1 = xpb / xpa;
        double epsilon = 0.5 * fx1 + 1.0;
        epsilon = epsilon * fx1;
        return epsilon + hiPrec[1] + hiPrec[0];
    }
    /* Value is small |x| < 1e6, do a Taylor series centered on 1.0 */
    double y = x * 0.333333333333333 - 0.5;
    y = y * x + 1.0;
    y = y * x;
    return y;
}","public void test177177() throws Throwable {
    double double0 = FastMath.log1p(1908.117806007);
    assertEquals(7.554396532668752, double0, 0.01);
}","/**
 * Compute log(1 + x).
 * @param x a number
 * @return log(1 + x)
 */"
"public static double log1p(final double x) {
    double xpa = 1.0 + x;
    double xpb = -(xpa - 1.0 - x);
    if (x == -1) {
        // -Infinity
        return x / 0.0;
    }
    if (x > 0 && 1 / x == 0) {
        // x = Infinity
        return x;
    }
    if (x > 1e-6 || x < -1e-6) {
        double[] hiPrec = new double[2];
        log(xpa, hiPrec);
        /* Do a taylor series expansion around xpa */
        /* f(x+y) = f(x) + f'(x)*y + f''(x)/2 y^2 */
        double fx1 = xpb / xpa;
        double epsilon = 0.5 * fx1 + 1.0;
        epsilon = epsilon * fx1;
        return epsilon + hiPrec[1] + hiPrec[0];
    }
    /* Value is small |x| < 1e6, do a Taylor series centered on 1.0 */
    double y = x * 0.333333333333333 - 0.5;
    y = y * x + 1.0;
    y = y * x;
    return y;
}","public void test178178() throws Throwable {
    double double0 = FastMath.log1p((-1.0));
    assertEquals(Double.NEGATIVE_INFINITY, double0, 0.01);
}","/**
 * Compute log(1 + x).
 * @param x a number
 * @return log(1 + x)
 */"
"public static double log1p(final double x) {
    double xpa = 1.0 + x;
    double xpb = -(xpa - 1.0 - x);
    if (x == -1) {
        // -Infinity
        return x / 0.0;
    }
    if (x > 0 && 1 / x == 0) {
        // x = Infinity
        return x;
    }
    if (x > 1e-6 || x < -1e-6) {
        double[] hiPrec = new double[2];
        log(xpa, hiPrec);
        /* Do a taylor series expansion around xpa */
        /* f(x+y) = f(x) + f'(x)*y + f''(x)/2 y^2 */
        double fx1 = xpb / xpa;
        double epsilon = 0.5 * fx1 + 1.0;
        epsilon = epsilon * fx1;
        return epsilon + hiPrec[1] + hiPrec[0];
    }
    /* Value is small |x| < 1e6, do a Taylor series centered on 1.0 */
    double y = x * 0.333333333333333 - 0.5;
    y = y * x + 1.0;
    y = y * x;
    return y;
}","public void test179179() throws Throwable {
    double double0 = FastMath.log1p((-1493.59867));
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Compute log(1 + x).
 * @param x a number
 * @return log(1 + x)
 */"
"public static double log10(final double x) {
    final double[] hiPrec = new double[2];
    log(x, hiPrec);
    final double tmp = hiPrec[0] * 1073741824.0;
    final double lna = hiPrec[0] + tmp - tmp;
    final double lnb = hiPrec[0] - lna + hiPrec[1];
    final double rln10a = 0.4342944622039795;
    final double rln10b = 1.9699272335463627E-8;
    return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna;
}","public void test180180() throws Throwable {
    double double0 = FastMath.log10(1.0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Compute the base 10 logarithm.
 * @param x a number
 * @return log10(x)
 */"
"public static double log(final double x) {
    return log(x, null);
}","public void test181181() throws Throwable {
    double double0 = FastMath.log(1.006182195365655);
    assertEquals(0.0061631639927189575, double0, 0.01);
}","/**
 * Natural logarithm.
 *
 * @param x   a double
 * @return log(x)
 */"
"public static double log(final double x) {
    return log(x, null);
}","public void test182182() throws Throwable {
    double double0 = FastMath.log(0.0);
    assertEquals(Double.NEGATIVE_INFINITY, double0, 0.01);
}","/**
 * Natural logarithm.
 *
 * @param x   a double
 * @return log(x)
 */"
"public static double log(final double x) {
    return log(x, null);
}","public void test183183() throws Throwable {
    double double0 = FastMath.log(4.9E-324);
    assertEquals((-744.4400719213812), double0, 0.01);
}","/**
 * Natural logarithm.
 *
 * @param x   a double
 * @return log(x)
 */"
"public static double log10(final double x) {
    final double[] hiPrec = new double[2];
    log(x, hiPrec);
    final double tmp = hiPrec[0] * 1073741824.0;
    final double lna = hiPrec[0] + tmp - tmp;
    final double lnb = hiPrec[0] - lna + hiPrec[1];
    final double rln10a = 0.4342944622039795;
    final double rln10b = 1.9699272335463627E-8;
    return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna;
}","public void test184184() throws Throwable {
    double double0 = FastMath.log10(Double.POSITIVE_INFINITY);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Compute the base 10 logarithm.
 * @param x a number
 * @return log10(x)
 */"
"public static double log10(final double x) {
    final double[] hiPrec = new double[2];
    log(x, hiPrec);
    final double tmp = hiPrec[0] * 1073741824.0;
    final double lna = hiPrec[0] + tmp - tmp;
    final double lnb = hiPrec[0] - lna + hiPrec[1];
    final double rln10a = 0.4342944622039795;
    final double rln10b = 1.9699272335463627E-8;
    return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna;
}","public void test185185() throws Throwable {
    double double0 = FastMath.log10(-0.0);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Compute the base 10 logarithm.
 * @param x a number
 * @return log10(x)
 */"
"public static double log(final double x) {
    return log(x, null);
}","public void test186186() throws Throwable {
    double double0 = FastMath.log(Float.NaN);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Natural logarithm.
 *
 * @param x   a double
 * @return log(x)
 */"
"public static double expm1(double x) {
    return expm1(x, null);
}","public void test187187() throws Throwable {
    double double0 = FastMath.expm1((-0.9990852728343232));
    assertEquals((-0.6317838955559781), double0, 0.01);
}","/**
 * Compute exp(x) - 1
 * @param x number to compute shifted exponential
 * @return exp(x) - 1
 */"
"public static double expm1(double x) {
    return expm1(x, null);
}","public void test188188() throws Throwable {
    double double0 = FastMath.expm1(0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Compute exp(x) - 1
 * @param x number to compute shifted exponential
 * @return exp(x) - 1
 */"
"public static double expm1(double x) {
    return expm1(x, null);
}","public void test189189() throws Throwable {
    double double0 = FastMath.expm1(1.8014398509481984E16);
    assertEquals(Double.POSITIVE_INFINITY, double0, 0.01);
}","/**
 * Compute exp(x) - 1
 * @param x number to compute shifted exponential
 * @return exp(x) - 1
 */"
"public static double expm1(double x) {
    return expm1(x, null);
}","public void test190190() throws Throwable {
    double double0 = FastMath.expm1((-1493.9999999999998));
    assertEquals((-1.0), double0, 0.01);
}","/**
 * Compute exp(x) - 1
 * @param x number to compute shifted exponential
 * @return exp(x) - 1
 */"
"public static double pow(double x, double y) {
    final double[] lns = new double[2];
    if (y == 0.0) {
        return 1.0;
    }
    if (x != x) {
        // X is NaN
        return x;
    }
    if (x == 0) {
        long bits = Double.doubleToLongBits(x);
        if ((bits & 0x8000000000000000L) != 0) {
            // -zero
            long yi = (long) y;
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            if (y > 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
        }
        if (y < 0) {
            return Double.POSITIVE_INFINITY;
        }
        if (y > 0) {
            return 0.0;
        }
        return Double.NaN;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0.0) {
            return 0.0;
        } else {
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x * x == 1.0)
            return Double.NaN;
        if (x * x > 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            return 0.0;
        }
        if (y > 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x * x == 1.0) {
            return Double.NaN;
        }
        if (x * x < 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    /* Handle special case x<0 */
    if (x < 0) {
        // y is an even integer in this case
        if (y >= 4503599627370496.0 || y <= -4503599627370496.0) {
            return pow(-x, y);
        }
        if (y == (long) y) {
            // If y is an integer
            return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y);
        } else {
            return Double.NaN;
        }
    }
    /* Split y into ya and yb such that y = ya+yb */
    double ya;
    double yb;
    if (y < 8e298 && y > -8e298) {
        double tmp1 = y * 1073741824.0;
        ya = y + tmp1 - tmp1;
        yb = y - ya;
    } else {
        double tmp1 = y * 9.31322574615478515625E-10;
        double tmp2 = tmp1 * 9.31322574615478515625E-10;
        ya = (tmp1 + tmp2 - tmp1) * 1073741824.0 * 1073741824.0;
        yb = y - ya;
    }
    /* Compute ln(x) */
    log(x, lns);
    double lna = lns[0];
    double lnb = lns[1];
    /* resplit lns */
    double tmp1 = lna * 1073741824.0;
    double tmp2 = lna + tmp1 - tmp1;
    lnb += lna - tmp2;
    lna = tmp2;
    // y*ln(x) = (aa+ab)
    final double aa = lna * ya;
    final double ab = lna * yb + lnb * ya + lnb * yb;
    lna = aa + ab;
    lnb = -(lna - aa - ab);
    double z = 1.0 / 120.0;
    z = z * lnb + (1.0 / 24.0);
    z = z * lnb + (1.0 / 6.0);
    z = z * lnb + 0.5;
    z = z * lnb + 1.0;
    z = z * lnb;
    final double result = exp(lna, z, null);
    //result = result + result * z;
    return result;
}","public void test191191() throws Throwable {
    double double0 = FastMath.pow(1.5574077246549023, (-4523.969811987168));
    assertEquals(0.0, double0, 0.01);
}","/**
 * Power function.  Compute x^y.
 *
 * @param x   a double
 * @param y   a double
 * @return double
 */"
"public static double pow(double x, double y) {
    final double[] lns = new double[2];
    if (y == 0.0) {
        return 1.0;
    }
    if (x != x) {
        // X is NaN
        return x;
    }
    if (x == 0) {
        long bits = Double.doubleToLongBits(x);
        if ((bits & 0x8000000000000000L) != 0) {
            // -zero
            long yi = (long) y;
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            if (y < 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            if (y > 0 && y == yi && (yi & 1) == 1) {
                return -0.0;
            }
        }
        if (y < 0) {
            return Double.POSITIVE_INFINITY;
        }
        if (y > 0) {
            return 0.0;
        }
        return Double.NaN;
    }
    if (x == Double.POSITIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0.0) {
            return 0.0;
        } else {
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.POSITIVE_INFINITY) {
        if (x * x == 1.0)
            return Double.NaN;
        if (x * x > 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    if (x == Double.NEGATIVE_INFINITY) {
        if (y != y) {
            // y is NaN
            return y;
        }
        if (y < 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return -0.0;
            }
            return 0.0;
        }
        if (y > 0) {
            long yi = (long) y;
            if (y == yi && (yi & 1) == 1) {
                return Double.NEGATIVE_INFINITY;
            }
            return Double.POSITIVE_INFINITY;
        }
    }
    if (y == Double.NEGATIVE_INFINITY) {
        if (x * x == 1.0) {
            return Double.NaN;
        }
        if (x * x < 1.0) {
            return Double.POSITIVE_INFINITY;
        } else {
            return 0.0;
        }
    }
    /* Handle special case x<0 */
    if (x < 0) {
        // y is an even integer in this case
        if (y >= 4503599627370496.0 || y <= -4503599627370496.0) {
            return pow(-x, y);
        }
        if (y == (long) y) {
            // If y is an integer
            return ((long) y & 1) == 0 ? pow(-x, y) : -pow(-x, y);
        } else {
            return Double.NaN;
        }
    }
    /* Split y into ya and yb such that y = ya+yb */
    double ya;
    double yb;
    if (y < 8e298 && y > -8e298) {
        double tmp1 = y * 1073741824.0;
        ya = y + tmp1 - tmp1;
        yb = y - ya;
    } else {
        double tmp1 = y * 9.31322574615478515625E-10;
        double tmp2 = tmp1 * 9.31322574615478515625E-10;
        ya = (tmp1 + tmp2 - tmp1) * 1073741824.0 * 1073741824.0;
        yb = y - ya;
    }
    /* Compute ln(x) */
    log(x, lns);
    double lna = lns[0];
    double lnb = lns[1];
    /* resplit lns */
    double tmp1 = lna * 1073741824.0;
    double tmp2 = lna + tmp1 - tmp1;
    lnb += lna - tmp2;
    lna = tmp2;
    // y*ln(x) = (aa+ab)
    final double aa = lna * ya;
    final double ab = lna * yb + lnb * ya + lnb * yb;
    lna = aa + ab;
    lnb = -(lna - aa - ab);
    double z = 1.0 / 120.0;
    z = z * lnb + (1.0 / 24.0);
    z = z * lnb + (1.0 / 6.0);
    z = z * lnb + 0.5;
    z = z * lnb + 1.0;
    z = z * lnb;
    final double result = exp(lna, z, null);
    //result = result + result * z;
    return result;
}","public void test192192() throws Throwable {
    double double0 = FastMath.pow(0.877582550048828, 1.0);
    assertEquals(0.877582550048828, double0, 0.01);
}","/**
 * Power function.  Compute x^y.
 *
 * @param x   a double
 * @param y   a double
 * @return double
 */"
"public static double signum(final double a) {
    return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : (Double.isNaN(a) ? Double.NaN : 0.0));
}","public void test193193() throws Throwable {
    double double0 = FastMath.signum(Double.NaN);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Compute the signum of a number.
 * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise
 * @param a number on which evaluation is done
 * @return -1, 0, +1 or NaN depending on sign of a
 */"
"public static double signum(final double a) {
    return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : (Double.isNaN(a) ? Double.NaN : 0.0));
}","public void test194194() throws Throwable {
    double double0 = FastMath.signum(0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Compute the signum of a number.
 * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise
 * @param a number on which evaluation is done
 * @return -1, 0, +1 or NaN depending on sign of a
 */"
"public static double signum(final double a) {
    return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : (Double.isNaN(a) ? Double.NaN : 0.0));
}","public void test195195() throws Throwable {
    double double0 = FastMath.signum((-3306.614));
    assertEquals((-1.0), double0, 0.01);
}","/**
 * Compute the signum of a number.
 * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise
 * @param a number on which evaluation is done
 * @return -1, 0, +1 or NaN depending on sign of a
 */"
"public static double signum(final double a) {
    return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : (Double.isNaN(a) ? Double.NaN : 0.0));
}","public void test196196() throws Throwable {
    double double0 = FastMath.signum(0.3153223395347595);
    assertEquals(1.0, double0, 0.01);
}","/**
 * Compute the signum of a number.
 * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise
 * @param a number on which evaluation is done
 * @return -1, 0, +1 or NaN depending on sign of a
 */"
"public static double atanh(double a) {
    boolean negative = false;
    if (a < 0) {
        negative = true;
        a = -a;
    }
    double absAtanh;
    if (a > 0.15) {
        absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));
    } else {
        final double a2 = a * a;
        if (a > 0.087) {
            absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0 + a2 * (1.0 / 11.0 + a2 * (1.0 / 13.0 + a2 * (1.0 / 15.0 + a2 * (1.0 / 17.0)))))))));
        } else if (a > 0.031) {
            absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0 + a2 * (1.0 / 11.0 + a2 * (1.0 / 13.0)))))));
        } else if (a > 0.003) {
            absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0)))));
        } else {
            absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0)));
        }
    }
    return negative ? -absAtanh : absAtanh;
}","public void test197197() throws Throwable {
    double double0 = FastMath.atanh(0.01745329052209854);
    assertEquals(0.017455063037776063, double0, 0.01);
}","/**
 * Compute the inverse hyperbolic tangent of a number.
 * @param a number on which evaluation is done
 * @return inverse hyperbolic tangent of a
 */"
"public static double atanh(double a) {
    boolean negative = false;
    if (a < 0) {
        negative = true;
        a = -a;
    }
    double absAtanh;
    if (a > 0.15) {
        absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));
    } else {
        final double a2 = a * a;
        if (a > 0.087) {
            absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0 + a2 * (1.0 / 11.0 + a2 * (1.0 / 13.0 + a2 * (1.0 / 15.0 + a2 * (1.0 / 17.0)))))))));
        } else if (a > 0.031) {
            absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0 + a2 * (1.0 / 11.0 + a2 * (1.0 / 13.0)))))));
        } else if (a > 0.003) {
            absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0)))));
        } else {
            absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0)));
        }
    }
    return negative ? -absAtanh : absAtanh;
}","public void test198198() throws Throwable {
    double double0 = FastMath.atanh(0.036);
    assertEquals(0.03601556410444137, double0, 0.01);
}","/**
 * Compute the inverse hyperbolic tangent of a number.
 * @param a number on which evaluation is done
 * @return inverse hyperbolic tangent of a
 */"
"public static double atanh(double a) {
    boolean negative = false;
    if (a < 0) {
        negative = true;
        a = -a;
    }
    double absAtanh;
    if (a > 0.15) {
        absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));
    } else {
        final double a2 = a * a;
        if (a > 0.087) {
            absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0 + a2 * (1.0 / 11.0 + a2 * (1.0 / 13.0 + a2 * (1.0 / 15.0 + a2 * (1.0 / 17.0)))))))));
        } else if (a > 0.031) {
            absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0 + a2 * (1.0 / 11.0 + a2 * (1.0 / 13.0)))))));
        } else if (a > 0.003) {
            absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0)))));
        } else {
            absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0)));
        }
    }
    return negative ? -absAtanh : absAtanh;
}","public void test199199() throws Throwable {
    double double0 = FastMath.atanh(0.11754920246761832);
    assertEquals(0.11809516041174332, double0, 0.01);
}","/**
 * Compute the inverse hyperbolic tangent of a number.
 * @param a number on which evaluation is done
 * @return inverse hyperbolic tangent of a
 */"
"public static double atanh(double a) {
    boolean negative = false;
    if (a < 0) {
        negative = true;
        a = -a;
    }
    double absAtanh;
    if (a > 0.15) {
        absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));
    } else {
        final double a2 = a * a;
        if (a > 0.087) {
            absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0 + a2 * (1.0 / 11.0 + a2 * (1.0 / 13.0 + a2 * (1.0 / 15.0 + a2 * (1.0 / 17.0)))))))));
        } else if (a > 0.031) {
            absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0 + a2 * (1.0 / 11.0 + a2 * (1.0 / 13.0)))))));
        } else if (a > 0.003) {
            absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0)))));
        } else {
            absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0)));
        }
    }
    return negative ? -absAtanh : absAtanh;
}","public void test200200() throws Throwable {
    double double0 = FastMath.atanh(0.0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Compute the inverse hyperbolic tangent of a number.
 * @param a number on which evaluation is done
 * @return inverse hyperbolic tangent of a
 */"
"public static double atanh(double a) {
    boolean negative = false;
    if (a < 0) {
        negative = true;
        a = -a;
    }
    double absAtanh;
    if (a > 0.15) {
        absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));
    } else {
        final double a2 = a * a;
        if (a > 0.087) {
            absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0 + a2 * (1.0 / 11.0 + a2 * (1.0 / 13.0 + a2 * (1.0 / 15.0 + a2 * (1.0 / 17.0)))))))));
        } else if (a > 0.031) {
            absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0 + a2 * (1.0 / 11.0 + a2 * (1.0 / 13.0)))))));
        } else if (a > 0.003) {
            absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0 + a2 * (1.0 / 7.0 + a2 * (1.0 / 9.0)))));
        } else {
            absAtanh = a * (1 + a2 * (1.0 / 3.0 + a2 * (1.0 / 5.0)));
        }
    }
    return negative ? -absAtanh : absAtanh;
}","public void test201201() throws Throwable {
    double double0 = FastMath.atanh((-1.0));
    assertEquals(Double.NEGATIVE_INFINITY, double0, 0.01);
}","/**
 * Compute the inverse hyperbolic tangent of a number.
 * @param a number on which evaluation is done
 * @return inverse hyperbolic tangent of a
 */"
"public static double asinh(double a) {
    boolean negative = false;
    if (a < 0) {
        negative = true;
        a = -a;
    }
    double absAsinh;
    if (a > 0.167) {
        absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a);
    } else {
        final double a2 = a * a;
        if (a > 0.097) {
            absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0 - a2 * (1.0 / 11.0 - a2 * (1.0 / 13.0 - a2 * (1.0 / 15.0 - a2 * (1.0 / 17.0) * 15.0 / 16.0) * 13.0 / 14.0) * 11.0 / 12.0) * 9.0 / 10.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);
        } else if (a > 0.036) {
            absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0 - a2 * (1.0 / 11.0 - a2 * (1.0 / 13.0) * 11.0 / 12.0) * 9.0 / 10.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);
        } else if (a > 0.0036) {
            absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);
        } else {
            absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0) * 3.0 / 4.0) / 2.0);
        }
    }
    return negative ? -absAsinh : absAsinh;
}","public void test202202() throws Throwable {
    double double0 = FastMath.asinh(0.030589580535888672);
    assertEquals(0.03058481198405819, double0, 0.01);
}","/**
 * Compute the inverse hyperbolic sine of a number.
 * @param a number on which evaluation is done
 * @return inverse hyperbolic sine of a
 */"
"public static double asinh(double a) {
    boolean negative = false;
    if (a < 0) {
        negative = true;
        a = -a;
    }
    double absAsinh;
    if (a > 0.167) {
        absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a);
    } else {
        final double a2 = a * a;
        if (a > 0.097) {
            absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0 - a2 * (1.0 / 11.0 - a2 * (1.0 / 13.0 - a2 * (1.0 / 15.0 - a2 * (1.0 / 17.0) * 15.0 / 16.0) * 13.0 / 14.0) * 11.0 / 12.0) * 9.0 / 10.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);
        } else if (a > 0.036) {
            absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0 - a2 * (1.0 / 11.0 - a2 * (1.0 / 13.0) * 11.0 / 12.0) * 9.0 / 10.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);
        } else if (a > 0.0036) {
            absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);
        } else {
            absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0) * 3.0 / 4.0) / 2.0);
        }
    }
    return negative ? -absAsinh : absAsinh;
}","public void test203203() throws Throwable {
    double double0 = FastMath.asinh((-0.05417713522911072));
    assertEquals((-0.05415066706272276), double0, 0.01);
}","/**
 * Compute the inverse hyperbolic sine of a number.
 * @param a number on which evaluation is done
 * @return inverse hyperbolic sine of a
 */"
"public static double asinh(double a) {
    boolean negative = false;
    if (a < 0) {
        negative = true;
        a = -a;
    }
    double absAsinh;
    if (a > 0.167) {
        absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a);
    } else {
        final double a2 = a * a;
        if (a > 0.097) {
            absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0 - a2 * (1.0 / 11.0 - a2 * (1.0 / 13.0 - a2 * (1.0 / 15.0 - a2 * (1.0 / 17.0) * 15.0 / 16.0) * 13.0 / 14.0) * 11.0 / 12.0) * 9.0 / 10.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);
        } else if (a > 0.036) {
            absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0 - a2 * (1.0 / 11.0 - a2 * (1.0 / 13.0) * 11.0 / 12.0) * 9.0 / 10.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);
        } else if (a > 0.0036) {
            absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);
        } else {
            absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0) * 3.0 / 4.0) / 2.0);
        }
    }
    return negative ? -absAsinh : absAsinh;
}","public void test204204() throws Throwable {
    double double0 = FastMath.asinh(0.1628696876132061);
    assertEquals(0.16215808821463767, double0, 0.01);
}","/**
 * Compute the inverse hyperbolic sine of a number.
 * @param a number on which evaluation is done
 * @return inverse hyperbolic sine of a
 */"
"public static double asinh(double a) {
    boolean negative = false;
    if (a < 0) {
        negative = true;
        a = -a;
    }
    double absAsinh;
    if (a > 0.167) {
        absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a);
    } else {
        final double a2 = a * a;
        if (a > 0.097) {
            absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0 - a2 * (1.0 / 11.0 - a2 * (1.0 / 13.0 - a2 * (1.0 / 15.0 - a2 * (1.0 / 17.0) * 15.0 / 16.0) * 13.0 / 14.0) * 11.0 / 12.0) * 9.0 / 10.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);
        } else if (a > 0.036) {
            absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0 - a2 * (1.0 / 11.0 - a2 * (1.0 / 13.0) * 11.0 / 12.0) * 9.0 / 10.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);
        } else if (a > 0.0036) {
            absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);
        } else {
            absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0) * 3.0 / 4.0) / 2.0);
        }
    }
    return negative ? -absAsinh : absAsinh;
}","public void test205205() throws Throwable {
    double double0 = FastMath.asinh((-1884L));
    assertEquals((-8.234299706129574), double0, 0.01);
}","/**
 * Compute the inverse hyperbolic sine of a number.
 * @param a number on which evaluation is done
 * @return inverse hyperbolic sine of a
 */"
"public static double asinh(double a) {
    boolean negative = false;
    if (a < 0) {
        negative = true;
        a = -a;
    }
    double absAsinh;
    if (a > 0.167) {
        absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a);
    } else {
        final double a2 = a * a;
        if (a > 0.097) {
            absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0 - a2 * (1.0 / 11.0 - a2 * (1.0 / 13.0 - a2 * (1.0 / 15.0 - a2 * (1.0 / 17.0) * 15.0 / 16.0) * 13.0 / 14.0) * 11.0 / 12.0) * 9.0 / 10.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);
        } else if (a > 0.036) {
            absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0 - a2 * (1.0 / 11.0 - a2 * (1.0 / 13.0) * 11.0 / 12.0) * 9.0 / 10.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);
        } else if (a > 0.0036) {
            absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0 - a2 * (1 / 7.0 - a2 * (1 / 9.0) * 7.0 / 8.0) * 5.0 / 6.0) * 3.0 / 4.0) / 2.0);
        } else {
            absAsinh = a * (1 - a2 * (1 / 3.0 - a2 * (1 / 5.0) * 3.0 / 4.0) / 2.0);
        }
    }
    return negative ? -absAsinh : absAsinh;
}","public void test206206() throws Throwable {
    double double0 = FastMath.asinh(0.0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Compute the inverse hyperbolic sine of a number.
 * @param a number on which evaluation is done
 * @return inverse hyperbolic sine of a
 */"
"public static double tanh(double x) {
    boolean negate = false;
    if (x != x) {
        return x;
    }
    if (x > 20.0) {
        return 1.0;
    }
    if (x < -20) {
        return -1.0;
    }
    if (x == 0) {
        return x;
    }
    if (x < 0.0) {
        x = -x;
        negate = true;
    }
    double result;
    if (x >= 0.5) {
        double[] hiPrec = new double[2];
        // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)
        exp(x * 2.0, 0.0, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        /* Numerator */
        double na = -1.0 + ya;
        double nb = -(na + 1.0 - ya);
        double temp = na + yb;
        nb += -(temp - na - yb);
        na = temp;
        /* Denominator */
        double da = 1.0 + ya;
        double db = -(da - 1.0 - ya);
        temp = da + yb;
        db += -(temp - da - yb);
        da = temp;
        temp = da * 1073741824.0;
        double daa = da + temp - temp;
        double dab = da - daa;
        // ratio = na/da
        double ratio = na / da;
        temp = ratio * 1073741824.0;
        double ratioa = ratio + temp - temp;
        double ratiob = ratio - ratioa;
        // Correct for rounding in division
        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;
        // Account for nb
        ratiob += nb / da;
        // Account for db
        ratiob += -db * na / da / da;
        result = ratioa + ratiob;
    } else {
        double[] hiPrec = new double[2];
        // tanh(x) = expm1(2x) / (expm1(2x) + 2)
        expm1(x * 2.0, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        /* Numerator */
        double na = ya;
        double nb = yb;
        /* Denominator */
        double da = 2.0 + ya;
        double db = -(da - 2.0 - ya);
        double temp = da + yb;
        db += -(temp - da - yb);
        da = temp;
        temp = da * 1073741824.0;
        double daa = da + temp - temp;
        double dab = da - daa;
        // ratio = na/da
        double ratio = na / da;
        temp = ratio * 1073741824.0;
        double ratioa = ratio + temp - temp;
        double ratiob = ratio - ratioa;
        // Correct for rounding in division
        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;
        // Account for nb
        ratiob += nb / da;
        // Account for db
        ratiob += -db * na / da / da;
        result = ratioa + ratiob;
    }
    if (negate) {
        result = -result;
    }
    return result;
}","public void test207207() throws Throwable {
    double double0 = FastMath.tanh((-4.469603409122654E-6));
    assertEquals((-4.46960340909289E-6), double0, 0.01);
}","/**
 * Compute the hyperbolic tangent of a number.
 * @param x number on which evaluation is done
 * @return hyperbolic tangent of x
 */"
"public static double tanh(double x) {
    boolean negate = false;
    if (x != x) {
        return x;
    }
    if (x > 20.0) {
        return 1.0;
    }
    if (x < -20) {
        return -1.0;
    }
    if (x == 0) {
        return x;
    }
    if (x < 0.0) {
        x = -x;
        negate = true;
    }
    double result;
    if (x >= 0.5) {
        double[] hiPrec = new double[2];
        // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)
        exp(x * 2.0, 0.0, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        /* Numerator */
        double na = -1.0 + ya;
        double nb = -(na + 1.0 - ya);
        double temp = na + yb;
        nb += -(temp - na - yb);
        na = temp;
        /* Denominator */
        double da = 1.0 + ya;
        double db = -(da - 1.0 - ya);
        temp = da + yb;
        db += -(temp - da - yb);
        da = temp;
        temp = da * 1073741824.0;
        double daa = da + temp - temp;
        double dab = da - daa;
        // ratio = na/da
        double ratio = na / da;
        temp = ratio * 1073741824.0;
        double ratioa = ratio + temp - temp;
        double ratiob = ratio - ratioa;
        // Correct for rounding in division
        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;
        // Account for nb
        ratiob += nb / da;
        // Account for db
        ratiob += -db * na / da / da;
        result = ratioa + ratiob;
    } else {
        double[] hiPrec = new double[2];
        // tanh(x) = expm1(2x) / (expm1(2x) + 2)
        expm1(x * 2.0, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        /* Numerator */
        double na = ya;
        double nb = yb;
        /* Denominator */
        double da = 2.0 + ya;
        double db = -(da - 2.0 - ya);
        double temp = da + yb;
        db += -(temp - da - yb);
        da = temp;
        temp = da * 1073741824.0;
        double daa = da + temp - temp;
        double dab = da - daa;
        // ratio = na/da
        double ratio = na / da;
        temp = ratio * 1073741824.0;
        double ratioa = ratio + temp - temp;
        double ratiob = ratio - ratioa;
        // Correct for rounding in division
        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;
        // Account for nb
        ratiob += nb / da;
        // Account for db
        ratiob += -db * na / da / da;
        result = ratioa + ratiob;
    }
    if (negate) {
        result = -result;
    }
    return result;
}","public void test208208() throws Throwable {
    double double0 = FastMath.tanh(0.9124657557600824);
    assertEquals(0.7223136355571643, double0, 0.01);
}","/**
 * Compute the hyperbolic tangent of a number.
 * @param x number on which evaluation is done
 * @return hyperbolic tangent of x
 */"
"public static double tanh(double x) {
    boolean negate = false;
    if (x != x) {
        return x;
    }
    if (x > 20.0) {
        return 1.0;
    }
    if (x < -20) {
        return -1.0;
    }
    if (x == 0) {
        return x;
    }
    if (x < 0.0) {
        x = -x;
        negate = true;
    }
    double result;
    if (x >= 0.5) {
        double[] hiPrec = new double[2];
        // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)
        exp(x * 2.0, 0.0, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        /* Numerator */
        double na = -1.0 + ya;
        double nb = -(na + 1.0 - ya);
        double temp = na + yb;
        nb += -(temp - na - yb);
        na = temp;
        /* Denominator */
        double da = 1.0 + ya;
        double db = -(da - 1.0 - ya);
        temp = da + yb;
        db += -(temp - da - yb);
        da = temp;
        temp = da * 1073741824.0;
        double daa = da + temp - temp;
        double dab = da - daa;
        // ratio = na/da
        double ratio = na / da;
        temp = ratio * 1073741824.0;
        double ratioa = ratio + temp - temp;
        double ratiob = ratio - ratioa;
        // Correct for rounding in division
        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;
        // Account for nb
        ratiob += nb / da;
        // Account for db
        ratiob += -db * na / da / da;
        result = ratioa + ratiob;
    } else {
        double[] hiPrec = new double[2];
        // tanh(x) = expm1(2x) / (expm1(2x) + 2)
        expm1(x * 2.0, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        /* Numerator */
        double na = ya;
        double nb = yb;
        /* Denominator */
        double da = 2.0 + ya;
        double db = -(da - 2.0 - ya);
        double temp = da + yb;
        db += -(temp - da - yb);
        da = temp;
        temp = da * 1073741824.0;
        double daa = da + temp - temp;
        double dab = da - daa;
        // ratio = na/da
        double ratio = na / da;
        temp = ratio * 1073741824.0;
        double ratioa = ratio + temp - temp;
        double ratiob = ratio - ratioa;
        // Correct for rounding in division
        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;
        // Account for nb
        ratiob += nb / da;
        // Account for db
        ratiob += -db * na / da / da;
        result = ratioa + ratiob;
    }
    if (negate) {
        result = -result;
    }
    return result;
}","public void test209209() throws Throwable {
    double double0 = FastMath.tanh((-1593.0));
    assertEquals((-1.0), double0, 0.01);
}","/**
 * Compute the hyperbolic tangent of a number.
 * @param x number on which evaluation is done
 * @return hyperbolic tangent of x
 */"
"public static double tanh(double x) {
    boolean negate = false;
    if (x != x) {
        return x;
    }
    if (x > 20.0) {
        return 1.0;
    }
    if (x < -20) {
        return -1.0;
    }
    if (x == 0) {
        return x;
    }
    if (x < 0.0) {
        x = -x;
        negate = true;
    }
    double result;
    if (x >= 0.5) {
        double[] hiPrec = new double[2];
        // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)
        exp(x * 2.0, 0.0, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        /* Numerator */
        double na = -1.0 + ya;
        double nb = -(na + 1.0 - ya);
        double temp = na + yb;
        nb += -(temp - na - yb);
        na = temp;
        /* Denominator */
        double da = 1.0 + ya;
        double db = -(da - 1.0 - ya);
        temp = da + yb;
        db += -(temp - da - yb);
        da = temp;
        temp = da * 1073741824.0;
        double daa = da + temp - temp;
        double dab = da - daa;
        // ratio = na/da
        double ratio = na / da;
        temp = ratio * 1073741824.0;
        double ratioa = ratio + temp - temp;
        double ratiob = ratio - ratioa;
        // Correct for rounding in division
        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;
        // Account for nb
        ratiob += nb / da;
        // Account for db
        ratiob += -db * na / da / da;
        result = ratioa + ratiob;
    } else {
        double[] hiPrec = new double[2];
        // tanh(x) = expm1(2x) / (expm1(2x) + 2)
        expm1(x * 2.0, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        /* Numerator */
        double na = ya;
        double nb = yb;
        /* Denominator */
        double da = 2.0 + ya;
        double db = -(da - 2.0 - ya);
        double temp = da + yb;
        db += -(temp - da - yb);
        da = temp;
        temp = da * 1073741824.0;
        double daa = da + temp - temp;
        double dab = da - daa;
        // ratio = na/da
        double ratio = na / da;
        temp = ratio * 1073741824.0;
        double ratioa = ratio + temp - temp;
        double ratiob = ratio - ratioa;
        // Correct for rounding in division
        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;
        // Account for nb
        ratiob += nb / da;
        // Account for db
        ratiob += -db * na / da / da;
        result = ratioa + ratiob;
    }
    if (negate) {
        result = -result;
    }
    return result;
}","public void test210210() throws Throwable {
    double double0 = FastMath.tanh(784L);
    assertEquals(1.0, double0, 0.01);
}","/**
 * Compute the hyperbolic tangent of a number.
 * @param x number on which evaluation is done
 * @return hyperbolic tangent of x
 */"
"public static double tanh(double x) {
    boolean negate = false;
    if (x != x) {
        return x;
    }
    if (x > 20.0) {
        return 1.0;
    }
    if (x < -20) {
        return -1.0;
    }
    if (x == 0) {
        return x;
    }
    if (x < 0.0) {
        x = -x;
        negate = true;
    }
    double result;
    if (x >= 0.5) {
        double[] hiPrec = new double[2];
        // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)
        exp(x * 2.0, 0.0, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        /* Numerator */
        double na = -1.0 + ya;
        double nb = -(na + 1.0 - ya);
        double temp = na + yb;
        nb += -(temp - na - yb);
        na = temp;
        /* Denominator */
        double da = 1.0 + ya;
        double db = -(da - 1.0 - ya);
        temp = da + yb;
        db += -(temp - da - yb);
        da = temp;
        temp = da * 1073741824.0;
        double daa = da + temp - temp;
        double dab = da - daa;
        // ratio = na/da
        double ratio = na / da;
        temp = ratio * 1073741824.0;
        double ratioa = ratio + temp - temp;
        double ratiob = ratio - ratioa;
        // Correct for rounding in division
        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;
        // Account for nb
        ratiob += nb / da;
        // Account for db
        ratiob += -db * na / da / da;
        result = ratioa + ratiob;
    } else {
        double[] hiPrec = new double[2];
        // tanh(x) = expm1(2x) / (expm1(2x) + 2)
        expm1(x * 2.0, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        /* Numerator */
        double na = ya;
        double nb = yb;
        /* Denominator */
        double da = 2.0 + ya;
        double db = -(da - 2.0 - ya);
        double temp = da + yb;
        db += -(temp - da - yb);
        da = temp;
        temp = da * 1073741824.0;
        double daa = da + temp - temp;
        double dab = da - daa;
        // ratio = na/da
        double ratio = na / da;
        temp = ratio * 1073741824.0;
        double ratioa = ratio + temp - temp;
        double ratiob = ratio - ratioa;
        // Correct for rounding in division
        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;
        // Account for nb
        ratiob += nb / da;
        // Account for db
        ratiob += -db * na / da / da;
        result = ratioa + ratiob;
    }
    if (negate) {
        result = -result;
    }
    return result;
}","public void test211211() throws Throwable {
    double double0 = FastMath.tanh(Double.NaN);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Compute the hyperbolic tangent of a number.
 * @param x number on which evaluation is done
 * @return hyperbolic tangent of x
 */"
"public static double tanh(double x) {
    boolean negate = false;
    if (x != x) {
        return x;
    }
    if (x > 20.0) {
        return 1.0;
    }
    if (x < -20) {
        return -1.0;
    }
    if (x == 0) {
        return x;
    }
    if (x < 0.0) {
        x = -x;
        negate = true;
    }
    double result;
    if (x >= 0.5) {
        double[] hiPrec = new double[2];
        // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)
        exp(x * 2.0, 0.0, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        /* Numerator */
        double na = -1.0 + ya;
        double nb = -(na + 1.0 - ya);
        double temp = na + yb;
        nb += -(temp - na - yb);
        na = temp;
        /* Denominator */
        double da = 1.0 + ya;
        double db = -(da - 1.0 - ya);
        temp = da + yb;
        db += -(temp - da - yb);
        da = temp;
        temp = da * 1073741824.0;
        double daa = da + temp - temp;
        double dab = da - daa;
        // ratio = na/da
        double ratio = na / da;
        temp = ratio * 1073741824.0;
        double ratioa = ratio + temp - temp;
        double ratiob = ratio - ratioa;
        // Correct for rounding in division
        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;
        // Account for nb
        ratiob += nb / da;
        // Account for db
        ratiob += -db * na / da / da;
        result = ratioa + ratiob;
    } else {
        double[] hiPrec = new double[2];
        // tanh(x) = expm1(2x) / (expm1(2x) + 2)
        expm1(x * 2.0, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        /* Numerator */
        double na = ya;
        double nb = yb;
        /* Denominator */
        double da = 2.0 + ya;
        double db = -(da - 2.0 - ya);
        double temp = da + yb;
        db += -(temp - da - yb);
        da = temp;
        temp = da * 1073741824.0;
        double daa = da + temp - temp;
        double dab = da - daa;
        // ratio = na/da
        double ratio = na / da;
        temp = ratio * 1073741824.0;
        double ratioa = ratio + temp - temp;
        double ratiob = ratio - ratioa;
        // Correct for rounding in division
        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;
        // Account for nb
        ratiob += nb / da;
        // Account for db
        ratiob += -db * na / da / da;
        result = ratioa + ratiob;
    }
    if (negate) {
        result = -result;
    }
    return result;
}","public void test212212() throws Throwable {
    double double0 = FastMath.tanh(0.0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Compute the hyperbolic tangent of a number.
 * @param x number on which evaluation is done
 * @return hyperbolic tangent of x
 */"
"public static double sinh(double x) {
    boolean negate = false;
    if (x != x) {
        return x;
    }
    if (x > 20.0) {
        return exp(x) / 2.0;
    }
    if (x < -20) {
        return -exp(-x) / 2.0;
    }
    if (x == 0) {
        return x;
    }
    if (x < 0.0) {
        x = -x;
        negate = true;
    }
    double result;
    if (x > 0.25) {
        double[] hiPrec = new double[2];
        exp(x, 0.0, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        double temp = ya * 1073741824.0;
        double yaa = ya + temp - temp;
        double yab = ya - yaa;
        // recip = 1/y
        double recip = 1.0 / ya;
        temp = recip * 1073741824.0;
        double recipa = recip + temp - temp;
        double recipb = recip - recipa;
        // Correct for rounding in division
        recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;
        // Account for yb
        recipb += -yb * recip * recip;
        recipa = -recipa;
        recipb = -recipb;
        // y = y + 1/y
        temp = ya + recipa;
        yb += -(temp - ya - recipa);
        ya = temp;
        temp = ya + recipb;
        yb += -(temp - ya - recipb);
        ya = temp;
        result = ya + yb;
        result *= 0.5;
    } else {
        double[] hiPrec = new double[2];
        expm1(x, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */
        double denom = 1.0 + ya;
        double denomr = 1.0 / denom;
        double denomb = -(denom - 1.0 - ya) + yb;
        double ratio = ya * denomr;
        double temp = ratio * 1073741824.0;
        double ra = ratio + temp - temp;
        double rb = ratio - ra;
        temp = denom * 1073741824.0;
        double za = denom + temp - temp;
        double zb = denom - za;
        rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;
        // Adjust for yb
        // numerator
        rb += yb * denomr;
        // denominator
        rb += -ya * denomb * denomr * denomr;
        // y = y - 1/y
        temp = ya + ra;
        yb += -(temp - ya - ra);
        ya = temp;
        temp = ya + rb;
        yb += -(temp - ya - rb);
        ya = temp;
        result = ya + yb;
        result *= 0.5;
    }
    if (negate) {
        result = -result;
    }
    return result;
}","public void test213213() throws Throwable {
    double double0 = FastMath.sinh((-1.0));
    assertEquals((-1.1752011936438014), double0, 0.01);
}","/**
 * Compute the hyperbolic sine of a number.
 * @param x number on which evaluation is done
 * @return hyperbolic sine of x
 */"
"public static double sinh(double x) {
    boolean negate = false;
    if (x != x) {
        return x;
    }
    if (x > 20.0) {
        return exp(x) / 2.0;
    }
    if (x < -20) {
        return -exp(-x) / 2.0;
    }
    if (x == 0) {
        return x;
    }
    if (x < 0.0) {
        x = -x;
        negate = true;
    }
    double result;
    if (x > 0.25) {
        double[] hiPrec = new double[2];
        exp(x, 0.0, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        double temp = ya * 1073741824.0;
        double yaa = ya + temp - temp;
        double yab = ya - yaa;
        // recip = 1/y
        double recip = 1.0 / ya;
        temp = recip * 1073741824.0;
        double recipa = recip + temp - temp;
        double recipb = recip - recipa;
        // Correct for rounding in division
        recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;
        // Account for yb
        recipb += -yb * recip * recip;
        recipa = -recipa;
        recipb = -recipb;
        // y = y + 1/y
        temp = ya + recipa;
        yb += -(temp - ya - recipa);
        ya = temp;
        temp = ya + recipb;
        yb += -(temp - ya - recipb);
        ya = temp;
        result = ya + yb;
        result *= 0.5;
    } else {
        double[] hiPrec = new double[2];
        expm1(x, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */
        double denom = 1.0 + ya;
        double denomr = 1.0 / denom;
        double denomb = -(denom - 1.0 - ya) + yb;
        double ratio = ya * denomr;
        double temp = ratio * 1073741824.0;
        double ra = ratio + temp - temp;
        double rb = ratio - ra;
        temp = denom * 1073741824.0;
        double za = denom + temp - temp;
        double zb = denom - za;
        rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;
        // Adjust for yb
        // numerator
        rb += yb * denomr;
        // denominator
        rb += -ya * denomb * denomr * denomr;
        // y = y - 1/y
        temp = ya + ra;
        yb += -(temp - ya - ra);
        ya = temp;
        temp = ya + rb;
        yb += -(temp - ya - rb);
        ya = temp;
        result = ya + yb;
        result *= 0.5;
    }
    if (negate) {
        result = -result;
    }
    return result;
}","public void test214214() throws Throwable {
    double double0 = FastMath.sinh(0.0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Compute the hyperbolic sine of a number.
 * @param x number on which evaluation is done
 * @return hyperbolic sine of x
 */"
"public static double sinh(double x) {
    boolean negate = false;
    if (x != x) {
        return x;
    }
    if (x > 20.0) {
        return exp(x) / 2.0;
    }
    if (x < -20) {
        return -exp(-x) / 2.0;
    }
    if (x == 0) {
        return x;
    }
    if (x < 0.0) {
        x = -x;
        negate = true;
    }
    double result;
    if (x > 0.25) {
        double[] hiPrec = new double[2];
        exp(x, 0.0, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        double temp = ya * 1073741824.0;
        double yaa = ya + temp - temp;
        double yab = ya - yaa;
        // recip = 1/y
        double recip = 1.0 / ya;
        temp = recip * 1073741824.0;
        double recipa = recip + temp - temp;
        double recipb = recip - recipa;
        // Correct for rounding in division
        recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;
        // Account for yb
        recipb += -yb * recip * recip;
        recipa = -recipa;
        recipb = -recipb;
        // y = y + 1/y
        temp = ya + recipa;
        yb += -(temp - ya - recipa);
        ya = temp;
        temp = ya + recipb;
        yb += -(temp - ya - recipb);
        ya = temp;
        result = ya + yb;
        result *= 0.5;
    } else {
        double[] hiPrec = new double[2];
        expm1(x, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */
        double denom = 1.0 + ya;
        double denomr = 1.0 / denom;
        double denomb = -(denom - 1.0 - ya) + yb;
        double ratio = ya * denomr;
        double temp = ratio * 1073741824.0;
        double ra = ratio + temp - temp;
        double rb = ratio - ra;
        temp = denom * 1073741824.0;
        double za = denom + temp - temp;
        double zb = denom - za;
        rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;
        // Adjust for yb
        // numerator
        rb += yb * denomr;
        // denominator
        rb += -ya * denomb * denomr * denomr;
        // y = y - 1/y
        temp = ya + ra;
        yb += -(temp - ya - ra);
        ya = temp;
        temp = ya + rb;
        yb += -(temp - ya - rb);
        ya = temp;
        result = ya + yb;
        result *= 0.5;
    }
    if (negate) {
        result = -result;
    }
    return result;
}","public void test215215() throws Throwable {
    double double0 = FastMath.sinh((-1537.2113330561938));
    assertEquals(Double.NEGATIVE_INFINITY, double0, 0.01);
}","/**
 * Compute the hyperbolic sine of a number.
 * @param x number on which evaluation is done
 * @return hyperbolic sine of x
 */"
"public static double sinh(double x) {
    boolean negate = false;
    if (x != x) {
        return x;
    }
    if (x > 20.0) {
        return exp(x) / 2.0;
    }
    if (x < -20) {
        return -exp(-x) / 2.0;
    }
    if (x == 0) {
        return x;
    }
    if (x < 0.0) {
        x = -x;
        negate = true;
    }
    double result;
    if (x > 0.25) {
        double[] hiPrec = new double[2];
        exp(x, 0.0, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        double temp = ya * 1073741824.0;
        double yaa = ya + temp - temp;
        double yab = ya - yaa;
        // recip = 1/y
        double recip = 1.0 / ya;
        temp = recip * 1073741824.0;
        double recipa = recip + temp - temp;
        double recipb = recip - recipa;
        // Correct for rounding in division
        recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;
        // Account for yb
        recipb += -yb * recip * recip;
        recipa = -recipa;
        recipb = -recipb;
        // y = y + 1/y
        temp = ya + recipa;
        yb += -(temp - ya - recipa);
        ya = temp;
        temp = ya + recipb;
        yb += -(temp - ya - recipb);
        ya = temp;
        result = ya + yb;
        result *= 0.5;
    } else {
        double[] hiPrec = new double[2];
        expm1(x, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */
        double denom = 1.0 + ya;
        double denomr = 1.0 / denom;
        double denomb = -(denom - 1.0 - ya) + yb;
        double ratio = ya * denomr;
        double temp = ratio * 1073741824.0;
        double ra = ratio + temp - temp;
        double rb = ratio - ra;
        temp = denom * 1073741824.0;
        double za = denom + temp - temp;
        double zb = denom - za;
        rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;
        // Adjust for yb
        // numerator
        rb += yb * denomr;
        // denominator
        rb += -ya * denomb * denomr * denomr;
        // y = y - 1/y
        temp = ya + ra;
        yb += -(temp - ya - ra);
        ya = temp;
        temp = ya + rb;
        yb += -(temp - ya - rb);
        ya = temp;
        result = ya + yb;
        result *= 0.5;
    }
    if (negate) {
        result = -result;
    }
    return result;
}","public void test216216() throws Throwable {
    double double0 = FastMath.sinh(1.8014398509481984E16);
    assertEquals(Double.POSITIVE_INFINITY, double0, 0.01);
}","/**
 * Compute the hyperbolic sine of a number.
 * @param x number on which evaluation is done
 * @return hyperbolic sine of x
 */"
"public static double sinh(double x) {
    boolean negate = false;
    if (x != x) {
        return x;
    }
    if (x > 20.0) {
        return exp(x) / 2.0;
    }
    if (x < -20) {
        return -exp(-x) / 2.0;
    }
    if (x == 0) {
        return x;
    }
    if (x < 0.0) {
        x = -x;
        negate = true;
    }
    double result;
    if (x > 0.25) {
        double[] hiPrec = new double[2];
        exp(x, 0.0, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        double temp = ya * 1073741824.0;
        double yaa = ya + temp - temp;
        double yab = ya - yaa;
        // recip = 1/y
        double recip = 1.0 / ya;
        temp = recip * 1073741824.0;
        double recipa = recip + temp - temp;
        double recipb = recip - recipa;
        // Correct for rounding in division
        recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;
        // Account for yb
        recipb += -yb * recip * recip;
        recipa = -recipa;
        recipb = -recipb;
        // y = y + 1/y
        temp = ya + recipa;
        yb += -(temp - ya - recipa);
        ya = temp;
        temp = ya + recipb;
        yb += -(temp - ya - recipb);
        ya = temp;
        result = ya + yb;
        result *= 0.5;
    } else {
        double[] hiPrec = new double[2];
        expm1(x, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */
        double denom = 1.0 + ya;
        double denomr = 1.0 / denom;
        double denomb = -(denom - 1.0 - ya) + yb;
        double ratio = ya * denomr;
        double temp = ratio * 1073741824.0;
        double ra = ratio + temp - temp;
        double rb = ratio - ra;
        temp = denom * 1073741824.0;
        double za = denom + temp - temp;
        double zb = denom - za;
        rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;
        // Adjust for yb
        // numerator
        rb += yb * denomr;
        // denominator
        rb += -ya * denomb * denomr * denomr;
        // y = y - 1/y
        temp = ya + ra;
        yb += -(temp - ya - ra);
        ya = temp;
        temp = ya + rb;
        yb += -(temp - ya - rb);
        ya = temp;
        result = ya + yb;
        result *= 0.5;
    }
    if (negate) {
        result = -result;
    }
    return result;
}","public void test217217() throws Throwable {
    double double0 = FastMath.sinh(Double.NaN);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Compute the hyperbolic sine of a number.
 * @param x number on which evaluation is done
 * @return hyperbolic sine of x
 */"
"public static double sinh(double x) {
    boolean negate = false;
    if (x != x) {
        return x;
    }
    if (x > 20.0) {
        return exp(x) / 2.0;
    }
    if (x < -20) {
        return -exp(-x) / 2.0;
    }
    if (x == 0) {
        return x;
    }
    if (x < 0.0) {
        x = -x;
        negate = true;
    }
    double result;
    if (x > 0.25) {
        double[] hiPrec = new double[2];
        exp(x, 0.0, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        double temp = ya * 1073741824.0;
        double yaa = ya + temp - temp;
        double yab = ya - yaa;
        // recip = 1/y
        double recip = 1.0 / ya;
        temp = recip * 1073741824.0;
        double recipa = recip + temp - temp;
        double recipb = recip - recipa;
        // Correct for rounding in division
        recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;
        // Account for yb
        recipb += -yb * recip * recip;
        recipa = -recipa;
        recipb = -recipb;
        // y = y + 1/y
        temp = ya + recipa;
        yb += -(temp - ya - recipa);
        ya = temp;
        temp = ya + recipb;
        yb += -(temp - ya - recipb);
        ya = temp;
        result = ya + yb;
        result *= 0.5;
    } else {
        double[] hiPrec = new double[2];
        expm1(x, hiPrec);
        double ya = hiPrec[0] + hiPrec[1];
        double yb = -(ya - hiPrec[0] - hiPrec[1]);
        /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */
        double denom = 1.0 + ya;
        double denomr = 1.0 / denom;
        double denomb = -(denom - 1.0 - ya) + yb;
        double ratio = ya * denomr;
        double temp = ratio * 1073741824.0;
        double ra = ratio + temp - temp;
        double rb = ratio - ra;
        temp = denom * 1073741824.0;
        double za = denom + temp - temp;
        double zb = denom - za;
        rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;
        // Adjust for yb
        // numerator
        rb += yb * denomr;
        // denominator
        rb += -ya * denomb * denomr * denomr;
        // y = y - 1/y
        temp = ya + ra;
        yb += -(temp - ya - ra);
        ya = temp;
        temp = ya + rb;
        yb += -(temp - ya - rb);
        ya = temp;
        result = ya + yb;
        result *= 0.5;
    }
    if (negate) {
        result = -result;
    }
    return result;
}","public void test218218() throws Throwable {
    double double0 = FastMath.sinh(0.1532399744099201);
    assertEquals(0.1538404216645775, double0, 0.01);
}","/**
 * Compute the hyperbolic sine of a number.
 * @param x number on which evaluation is done
 * @return hyperbolic sine of x
 */"
"public static double cosh(double x) {
    if (x != x) {
        return x;
    }
    if (x > 20.0) {
        return exp(x) / 2.0;
    }
    if (x < -20) {
        return exp(-x) / 2.0;
    }
    double[] hiPrec = new double[2];
    if (x < 0.0) {
        x = -x;
    }
    exp(x, 0.0, hiPrec);
    double ya = hiPrec[0] + hiPrec[1];
    double yb = -(ya - hiPrec[0] - hiPrec[1]);
    double temp = ya * 1073741824.0;
    double yaa = ya + temp - temp;
    double yab = ya - yaa;
    // recip = 1/y
    double recip = 1.0 / ya;
    temp = recip * 1073741824.0;
    double recipa = recip + temp - temp;
    double recipb = recip - recipa;
    // Correct for rounding in division
    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;
    // Account for yb
    recipb += -yb * recip * recip;
    // y = y + 1/y
    temp = ya + recipa;
    yb += -(temp - ya - recipa);
    ya = temp;
    temp = ya + recipb;
    yb += -(temp - ya - recipb);
    ya = temp;
    double result = ya + yb;
    result *= 0.5;
    return result;
}","public void test219219() throws Throwable {
    double double0 = FastMath.cosh((-7.44321345601866E-11));
    assertEquals(1.0, double0, 0.01);
}","/**
 * Compute the hyperbolic cosine of a number.
 * @param x number on which evaluation is done
 * @return hyperbolic cosine of x
 */"
"public static double cosh(double x) {
    if (x != x) {
        return x;
    }
    if (x > 20.0) {
        return exp(x) / 2.0;
    }
    if (x < -20) {
        return exp(-x) / 2.0;
    }
    double[] hiPrec = new double[2];
    if (x < 0.0) {
        x = -x;
    }
    exp(x, 0.0, hiPrec);
    double ya = hiPrec[0] + hiPrec[1];
    double yb = -(ya - hiPrec[0] - hiPrec[1]);
    double temp = ya * 1073741824.0;
    double yaa = ya + temp - temp;
    double yab = ya - yaa;
    // recip = 1/y
    double recip = 1.0 / ya;
    temp = recip * 1073741824.0;
    double recipa = recip + temp - temp;
    double recipb = recip - recipa;
    // Correct for rounding in division
    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;
    // Account for yb
    recipb += -yb * recip * recip;
    // y = y + 1/y
    temp = ya + recipa;
    yb += -(temp - ya - recipa);
    ya = temp;
    temp = ya + recipb;
    yb += -(temp - ya - recipb);
    ya = temp;
    double result = ya + yb;
    result *= 0.5;
    return result;
}","public void test220220() throws Throwable {
    double double0 = FastMath.cosh((-2714.21));
    assertEquals(Double.POSITIVE_INFINITY, double0, 0.01);
}","/**
 * Compute the hyperbolic cosine of a number.
 * @param x number on which evaluation is done
 * @return hyperbolic cosine of x
 */"
"public static double cosh(double x) {
    if (x != x) {
        return x;
    }
    if (x > 20.0) {
        return exp(x) / 2.0;
    }
    if (x < -20) {
        return exp(-x) / 2.0;
    }
    double[] hiPrec = new double[2];
    if (x < 0.0) {
        x = -x;
    }
    exp(x, 0.0, hiPrec);
    double ya = hiPrec[0] + hiPrec[1];
    double yb = -(ya - hiPrec[0] - hiPrec[1]);
    double temp = ya * 1073741824.0;
    double yaa = ya + temp - temp;
    double yab = ya - yaa;
    // recip = 1/y
    double recip = 1.0 / ya;
    temp = recip * 1073741824.0;
    double recipa = recip + temp - temp;
    double recipb = recip - recipa;
    // Correct for rounding in division
    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;
    // Account for yb
    recipb += -yb * recip * recip;
    // y = y + 1/y
    temp = ya + recipa;
    yb += -(temp - ya - recipa);
    ya = temp;
    temp = ya + recipb;
    yb += -(temp - ya - recipb);
    ya = temp;
    double result = ya + yb;
    result *= 0.5;
    return result;
}","public void test221221() throws Throwable {
    double double0 = FastMath.cosh(3398.0000000000005);
    assertEquals(Double.POSITIVE_INFINITY, double0, 0.01);
}","/**
 * Compute the hyperbolic cosine of a number.
 * @param x number on which evaluation is done
 * @return hyperbolic cosine of x
 */"
"public static double cosh(double x) {
    if (x != x) {
        return x;
    }
    if (x > 20.0) {
        return exp(x) / 2.0;
    }
    if (x < -20) {
        return exp(-x) / 2.0;
    }
    double[] hiPrec = new double[2];
    if (x < 0.0) {
        x = -x;
    }
    exp(x, 0.0, hiPrec);
    double ya = hiPrec[0] + hiPrec[1];
    double yb = -(ya - hiPrec[0] - hiPrec[1]);
    double temp = ya * 1073741824.0;
    double yaa = ya + temp - temp;
    double yab = ya - yaa;
    // recip = 1/y
    double recip = 1.0 / ya;
    temp = recip * 1073741824.0;
    double recipa = recip + temp - temp;
    double recipb = recip - recipa;
    // Correct for rounding in division
    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;
    // Account for yb
    recipb += -yb * recip * recip;
    // y = y + 1/y
    temp = ya + recipa;
    yb += -(temp - ya - recipa);
    ya = temp;
    temp = ya + recipb;
    yb += -(temp - ya - recipb);
    ya = temp;
    double result = ya + yb;
    result *= 0.5;
    return result;
}","public void test222222() throws Throwable {
    double double0 = FastMath.cosh(Double.NaN);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Compute the hyperbolic cosine of a number.
 * @param x number on which evaluation is done
 * @return hyperbolic cosine of x
 */"
"public static double cosh(double x) {
    if (x != x) {
        return x;
    }
    if (x > 20.0) {
        return exp(x) / 2.0;
    }
    if (x < -20) {
        return exp(-x) / 2.0;
    }
    double[] hiPrec = new double[2];
    if (x < 0.0) {
        x = -x;
    }
    exp(x, 0.0, hiPrec);
    double ya = hiPrec[0] + hiPrec[1];
    double yb = -(ya - hiPrec[0] - hiPrec[1]);
    double temp = ya * 1073741824.0;
    double yaa = ya + temp - temp;
    double yab = ya - yaa;
    // recip = 1/y
    double recip = 1.0 / ya;
    temp = recip * 1073741824.0;
    double recipa = recip + temp - temp;
    double recipb = recip - recipa;
    // Correct for rounding in division
    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;
    // Account for yb
    recipb += -yb * recip * recip;
    // y = y + 1/y
    temp = ya + recipa;
    yb += -(temp - ya - recipa);
    ya = temp;
    temp = ya + recipb;
    yb += -(temp - ya - recipb);
    ya = temp;
    double result = ya + yb;
    result *= 0.5;
    return result;
}","public void test223223() throws Throwable {
    double double0 = FastMath.cosh(0.08713622391223907);
    assertEquals(1.0037987634260317, double0, 0.01);
}","/**
 * Compute the hyperbolic cosine of a number.
 * @param x number on which evaluation is done
 * @return hyperbolic cosine of x
 */"
"public static double nextUp(final double a) {
    return nextAfter(a, Double.POSITIVE_INFINITY);
}","public void test224224() throws Throwable {
    double double0 = FastMath.nextUp((-707.1667484602));
    assertEquals((-707.1667484601999), double0, 0.01);
}","/**
 * Compute next number towards positive infinity.
 * @param a number to which neighbor should be computed
 * @return neighbor of a towards positive infinity
 */"
"public static double atan(double x) {
    return atan(x, 0.0, false);
}","public void test225225() throws Throwable {
    double double0 = FastMath.atan((-1537.2113330561938));
    assertEquals((-1.5701457982452864), double0, 0.01);
}","/**
 * Arctangent function
 *  @param x a number
 *  @return atan(x)
 */"
"public static double exp(double x) {
    return exp(x, 0.0, null);
}","public void test226226() throws Throwable {
    double double0 = FastMath.exp(1886.48842325);
    assertEquals(Double.POSITIVE_INFINITY, double0, 0.01);
}","/**
 * Exponential function.
 *
 * Computes exp(x), function result is nearly rounded.   It will be correctly
 * rounded to the theoretical value for 99.9% of input values, otherwise it will
 * have a 1 UPL error.
 *
 * Method:
 *    Lookup intVal = exp(int(x))
 *    Lookup fracVal = exp(int(x-int(x) / 1024.0) * 1024.0 );
 *    Compute z as the exponential of the remaining bits by a polynomial minus one
 *    exp(x) = intVal * fracVal * (1 + z)
 *
 * Accuracy:
 *    Calculation is done with 63 bits of precision, so result should be correctly
 *    rounded for 99.9% of input values, with less than 1 ULP error otherwise.
 *
 * @param x   a double
 * @return double e<sup>x</sup>
 */"
"public static double random() {
    return Math.random();
}","public void test227227() throws Throwable {
    FastMath.random();
    double double0 = FastMath.random();
    assertEquals(0.1, double0, 0.01);
}","/**
 * Returns a pseudo-random number between 0.0 and 1.0.
 * @return a random number between 0.0 and 1.0
 */"
"public static int round(final float x) {
    return Math.round(x);
}","public void test228228() throws Throwable {
    int int0 = FastMath.round(1006.5021F);
    assertEquals(1007, int0);
}","/**
 * Get the closest int to x.
 * @param x number from which closest int is requested
 * @return closest int to x
 */"
"public static long round(double x) {
    return (long) floor(x + 0.5);
}","public void test229229() throws Throwable {
    long long0 = FastMath.round((-0.9999999999999999));
    assertEquals((-1L), long0);
}","/**
 * Get the closest long to x.
 * @param x number from which closest long is requested
 * @return closest long to x
 */"
"public static double ulp(double x) {
    return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1));
}","public void test230230() throws Throwable {
    double double0 = FastMath.ulp(4675.204408024046);
    assertEquals(9.094947017729282E-13, double0, 0.01);
}","/**
 * Compute least significant bit (Unit in Last Position) for a number.
 * @param x number from which ulp is requested
 * @return ulp(x)
 */"
"public static double expm1(double x) {
    return expm1(x, null);
}","public void test231231() throws Throwable {
    double double0 = FastMath.expm1(Double.NaN);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Compute exp(x) - 1
 * @param x number to compute shifted exponential
 * @return exp(x) - 1
 */"
"public static double toDegrees(double x) {
    final double facta = 57.2957763671875;
    final double factb = 3.145894820876798E-6;
    double temp = x * 1073741824.0;
    double xa = x + temp - temp;
    double xb = x - xa;
    return xb * factb + xb * facta + xa * factb + xa * facta;
}","public void test232232() throws Throwable {
    double double0 = FastMath.toDegrees(1886.48842325);
    assertEquals(108087.82475251432, double0, 0.01);
}","/**
 *  Convert radians to degrees, with error of less than 0.5 ULP
 *  @param x angle in radians
 *  @return x converted into degrees
 */"
"public static double toRadians(double x) {
    final double facta = 0.01745329052209854;
    final double factb = 1.997844754509471E-9;
    double temp = x * 1073741824.0;
    double xa = x + temp - temp;
    double xb = x - xa;
    return xb * factb + xb * facta + xa * factb + xa * facta;
}","public void test233233() throws Throwable {
    double double0 = FastMath.toRadians(2.639144044101463E-7);
    assertEquals(4.606175300396897E-9, double0, 0.01);
}","/**
 *  Convert degrees to radians, with error of less than 0.5 ULP
 *  @param x angle in degrees
 *  @return x converted into radians
 */"
"public static double acos(double x) {
    if (x != x) {
        return Double.NaN;
    }
    if (x > 1.0 || x < -1.0) {
        return Double.NaN;
    }
    if (x == -1.0) {
        return Math.PI;
    }
    if (x == 1.0) {
        return 0.0;
    }
    if (x == 0) {
        return Math.PI / 2.0;
    }
    /* Compute acos(x) = atan(sqrt(1-x*x)/x) */
    /* Split x */
    double temp = x * 1073741824.0;
    final double xa = x + temp - temp;
    final double xb = x - xa;
    /* Square it */
    double ya = xa * xa;
    double yb = xa * xb * 2.0 + xb * xb;
    /* Subtract from 1 */
    ya = -ya;
    yb = -yb;
    double za = 1.0 + ya;
    double zb = -(za - 1.0 - ya);
    temp = za + yb;
    zb += -(temp - za - yb);
    za = temp;
    /* Square root */
    double y = sqrt(za);
    temp = y * 1073741824.0;
    ya = y + temp - temp;
    yb = y - ya;
    /* Extend precision of sqrt */
    yb += (za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y);
    /* Contribution of zb to sqrt */
    yb += zb / (2.0 * y);
    y = ya + yb;
    yb = -(y - ya - yb);
    // Compute ratio r = y/x
    double r = y / x;
    temp = r * 1073741824.0;
    double ra = r + temp - temp;
    double rb = r - ra;
    // Correct for rounding in division
    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
    // Add in effect additional bits of sqrt.
    rb += yb / x;
    temp = ra + rb;
    rb = -(temp - ra - rb);
    ra = temp;
    return atan(ra, rb, x < 0);
}","public void test234234() throws Throwable {
    double double0 = FastMath.acos(0.19454771280288696);
    assertEquals(1.3749999950923297, double0, 0.01);
}","/**
 * Compute the arc cosine of a number.
 * @param x number on which evaluation is done
 * @return arc cosine of x
 */"
