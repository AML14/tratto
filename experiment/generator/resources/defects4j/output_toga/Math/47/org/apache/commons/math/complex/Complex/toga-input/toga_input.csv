focal_method,test_prefix,docstring
"protected Complex createComplex(double realPart, double imaginaryPart) {
    return new Complex(realPart, imaginaryPart);
}","public void test0000() throws Throwable {
    Complex complex0 = new Complex(3294198.0, 3294198.0);
    Complex complex1 = complex0.I.conjugate();
    Complex complex2 = complex0.ONE.divide(3294198.0);
    complex2.ONE.nthRoot(3814);
    Complex complex3 = Complex.NaN;
    Complex complex4 = complex2.cos();
    complex4.NaN.add(8.0E298);
    Complex complex5 = complex0.subtract(complex3);
    complex3.isNaN();
    complex2.isInfinite();
    complex5.abs();
    complex2.abs();
    Complex complex6 = complex1.negate();
    Complex complex7 = complex0.ONE.sqrt1z();
    complex6.ZERO.toString();
    complex5.nthRoot(3814);
    Complex complex8 = Complex.I;
    complex3.ZERO.add(3294198.0);
    Complex complex9 = new Complex(3814, Double.NaN);
    complex4.subtract(complex8);
    complex8.sqrt();
    complex6.acos();
    complex7.atan();
    complex7.conjugate();
    complex5.atan();
    complex2.atan();
    complex5.createComplex(2.0, 6.283185307179586);
}","/**
 * Create a complex number given the real and imaginary parts.
 *
 * @param realPart Real part.
 * @param imaginaryPart Imaginary part.
 * @return a new complex number instance.
 * @since 1.2
 * @see #valueOf(double, double)
 */"
"public Complex add(Complex addend) throws NullArgumentException {
    MathUtils.checkNotNull(addend);
    if (isNaN || addend.isNaN) {
        return NaN;
    }
    return createComplex(real + addend.getReal(), imaginary + addend.getImaginary());
}","public void test0011() throws Throwable {
    Complex complex0 = new Complex((-2595.188104221), (-2595.188104221));
    Complex complex1 = (Complex) complex0.ZERO.readResolve();
    complex0.readResolve();
    Complex complex2 = Complex.valueOf(0.0, (-2595.188104221));
    Complex complex3 = Complex.valueOf(0.0, 0.0);
    Complex complex4 = complex3.ONE.cosh();
    Complex complex5 = complex3.add(0.0);
    complex5.acos();
    Complex complex6 = complex3.createComplex((-2595.188104221), (-1077.1));
    complex6.divide(complex3);
    complex0.getReal();
    Complex complex7 = complex0.sinh();
    complex7.INF.multiply((-2595.188104221));
    Complex complex8 = complex2.sqrt1z();
    complex2.ONE.pow((-2595.188104221));
    complex4.cos();
    complex3.NaN.abs();
    Complex.valueOf((-2595.188104221));
    Complex complex9 = complex8.subtract(complex3);
    complex4.cos();
    Complex complex10 = complex7.sinh();
    complex10.createComplex(0.041666666666621166, 892.28875252206);
    Complex complex11 = complex9.sinh();
    complex10.subtract(Double.NaN);
    Complex complex12 = new Complex(0.0);
    complex4.divide(complex12);
    Complex complex13 = complex7.divide(0.0);
    complex4.divide(complex13);
    complex12.acos();
    complex4.getField();
    complex11.isInfinite();
    try {
        complex1.add((Complex) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // null is not allowed
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this + addend)}.
 * Uses the definitional formula
 * <pre>
 *  <code>
 *   (a + bi) + (c + di) = (a+c) + (b+d)i
 *  </code>
 * </pre>
 * <br/>
 * If either {@code this} or {@code addend} has a {@code NaN} value in
 * either part, {@link #NaN} is returned; otherwise {@code Infinite}
 * and {@code NaN} values are returned in the parts of the result
 * according to the rules for {@link java.lang.Double} arithmetic.
 *
 * @param  addend Value to be added to this {@code Complex}.
 * @return {@code this + addend}.
 * @throws NullArgumentException if {@code addend} is {@code null}.
 */"
"public Complex divide(Complex divisor) throws NullArgumentException {
    MathUtils.checkNotNull(divisor);
    if (isNaN || divisor.isNaN) {
        return NaN;
    }
    if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) {
        return NaN;
    }
    if (divisor.isInfinite() && !isInfinite()) {
        return ZERO;
    }
    final double c = divisor.getReal();
    final double d = divisor.getImaginary();
    if (FastMath.abs(c) < FastMath.abs(d)) {
        double q = c / d;
        double denominator = c * q + d;
        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);
    } else {
        double q = d / c;
        double denominator = d * q + c;
        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
    }
}","public void test0022() throws Throwable {
    Complex complex0 = new Complex((-12.397928415777582), (-12.397928415777582));
    Complex complex1 = complex0.tanh();
    Complex complex2 = complex1.pow((-12.397928415777582));
    Complex complex3 = complex2.ONE.tan();
    Complex complex4 = complex1.tan();
    complex0.ONE.abs();
    Complex complex5 = complex4.multiply((-12.397928415777582));
    Complex complex6 = complex5.ONE.atan();
    complex6.INF.pow(complex5);
    Complex complex7 = complex6.INF.tan();
    complex7.INF.readResolve();
    complex6.multiply(complex4);
    complex4.multiply((-12.397928415777582));
    complex3.conjugate();
    complex5.sin();
    complex3.isNaN();
    complex0.divide(complex2);
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this / divisor)}.
 * Implements the definitional formula
 * <pre>
 *  <code>
 *    a + bi          ac + bd + (bc - ad)i
 *    ----------- = -------------------------
 *    c + di         c<sup>2</sup> + d<sup>2</sup>
 *  </code>
 * </pre>
 * but uses
 * <a href=""http://doi.acm.org/10.1145/1039813.1039814"">
 * prescaling of operands</a> to limit the effects of overflows and
 * underflows in the computation.
 * <br/>
 * {@code Infinite} and {@code NaN} values are handled according to the
 * following rules, applied in the order presented:
 * <ul>
 *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value
 *   in either part, {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code this} and {@code divisor} are both {@link #ZERO},
 *   {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code divisor} equals {@link #ZERO}, {@link #INF} is returned.
 *  </li>
 *  <li>If {@code this} and {@code divisor} are both infinite,
 *   {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or
 *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts
 *   infinite), {@link #ZERO} is returned.
 *  </li>
 *  <li>If {@code this} is infinite and {@code divisor} is finite,
 *   {@code NaN} values are returned in the parts of the result if the
 *   {@link java.lang.Double} rules applied to the definitional formula
 *   force {@code NaN} results.
 *  </li>
 * </ul>
 *
 * @param divisor Value by which this {@code Complex} is to be divided.
 * @return {@code this / divisor}.
 * @throws NullArgumentException if {@code divisor} is {@code null}.
 */"
"public Complex add(double addend) {
    if (isNaN || Double.isNaN(addend)) {
        return NaN;
    }
    return createComplex(real + addend, imaginary);
}","public void test0033() throws Throwable {
    Complex complex0 = new Complex(Double.NaN);
    Complex complex1 = complex0.NaN.exp();
    Complex complex2 = complex0.multiply(Double.NaN);
    Complex complex3 = complex0.divide(Double.NaN);
    complex0.NaN.getField();
    complex3.NaN.readResolve();
    Complex.valueOf(1533.4099858269, 1888.3755);
    complex3.INF.abs();
    Complex complex4 = complex3.acos();
    Complex complex5 = complex4.I.cosh();
    complex5.NaN.exp();
    Complex complex6 = complex1.subtract(complex2);
    complex6.ZERO.divide(Double.POSITIVE_INFINITY);
    Object object0 = new Object();
    complex2.equals(object0);
    Complex complex7 = complex3.log();
    complex7.add(1533.4099858269);
}","/**
 * Returns a {@code Complex} whose value is {@code (this + addend)},
 * with {@code addend} interpreted as a real number.
 *
 * @param addend Value to be added to this {@code Complex}.
 * @return {@code this + addend}.
 * @see #add(Complex)
 */"
"public Complex divide(Complex divisor) throws NullArgumentException {
    MathUtils.checkNotNull(divisor);
    if (isNaN || divisor.isNaN) {
        return NaN;
    }
    if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) {
        return NaN;
    }
    if (divisor.isInfinite() && !isInfinite()) {
        return ZERO;
    }
    final double c = divisor.getReal();
    final double d = divisor.getImaginary();
    if (FastMath.abs(c) < FastMath.abs(d)) {
        double q = c / d;
        double denominator = c * q + d;
        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);
    } else {
        double q = d / c;
        double denominator = d * q + c;
        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
    }
}","public void test0044() throws Throwable {
    Complex complex0 = Complex.valueOf(3154.786305001714);
    Complex complex1 = complex0.I.log();
    Complex complex2 = complex1.INF.sin();
    complex2.ONE.cosh();
    complex1.ONE.log();
    complex2.INF.cos();
    complex1.ZERO.sqrt1z();
    Complex complex3 = new Complex((-0.9993909506205958));
    complex1.ZERO.add(complex3);
    try {
        complex0.divide((Complex) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // null is not allowed
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this / divisor)}.
 * Implements the definitional formula
 * <pre>
 *  <code>
 *    a + bi          ac + bd + (bc - ad)i
 *    ----------- = -------------------------
 *    c + di         c<sup>2</sup> + d<sup>2</sup>
 *  </code>
 * </pre>
 * but uses
 * <a href=""http://doi.acm.org/10.1145/1039813.1039814"">
 * prescaling of operands</a> to limit the effects of overflows and
 * underflows in the computation.
 * <br/>
 * {@code Infinite} and {@code NaN} values are handled according to the
 * following rules, applied in the order presented:
 * <ul>
 *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value
 *   in either part, {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code this} and {@code divisor} are both {@link #ZERO},
 *   {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code divisor} equals {@link #ZERO}, {@link #INF} is returned.
 *  </li>
 *  <li>If {@code this} and {@code divisor} are both infinite,
 *   {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or
 *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts
 *   infinite), {@link #ZERO} is returned.
 *  </li>
 *  <li>If {@code this} is infinite and {@code divisor} is finite,
 *   {@code NaN} values are returned in the parts of the result if the
 *   {@link java.lang.Double} rules applied to the definitional formula
 *   force {@code NaN} results.
 *  </li>
 * </ul>
 *
 * @param divisor Value by which this {@code Complex} is to be divided.
 * @return {@code this / divisor}.
 * @throws NullArgumentException if {@code divisor} is {@code null}.
 */"
"public Complex multiply(Complex factor) throws NullArgumentException {
    MathUtils.checkNotNull(factor);
    if (isNaN || factor.isNaN) {
        return NaN;
    }
    if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(factor.real) || Double.isInfinite(factor.imaginary)) {
        // we don't use isInfinite() to avoid testing for NaN again
        return INF;
    }
    return createComplex(real * factor.real - imaginary * factor.imaginary, real * factor.imaginary + imaginary * factor.real);
}","public void test0055() throws Throwable {
    Complex complex0 = Complex.valueOf(0.0, 0.0);
    complex0.ONE.pow(0.0);
    complex0.toString();
    Complex complex1 = null;
    try {
        complex0.multiply((Complex) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // null is not allowed
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns a {@code Complex} whose value is {@code this * factor}.
 * Implements preliminary checks for {@code NaN} and infinity followed by
 * the definitional formula:
 * <pre>
 *  <code>
 *   (a + bi)(c + di) = (ac - bd) + (ad + bc)i
 *  </code>
 * </pre>
 * Returns {@link #NaN} if either {@code this} or {@code factor} has one or
 * more {@code NaN} parts.
 * <br/>
 * Returns {@link #INF} if neither {@code this} nor {@code factor} has one
 * or more {@code NaN} parts and if either {@code this} or {@code factor}
 * has one or more infinite parts (same result is returned regardless of
 * the sign of the components).
 * <br/>
 * Returns finite values in components of the result per the definitional
 * formula in all remaining cases.
 *
 * @param  factor value to be multiplied by this {@code Complex}.
 * @return {@code this * factor}.
 * @throws NullArgumentException if {@code factor} is {@code null}.
 */"
"public Complex sqrt() {
    if (isNaN) {
        return NaN;
    }
    if (real == 0.0 && imaginary == 0.0) {
        return createComplex(0.0, 0.0);
    }
    double t = FastMath.sqrt((FastMath.abs(real) + abs()) / 2.0);
    if (real >= 0.0) {
        return createComplex(t, imaginary / (2.0 * t));
    } else {
        return createComplex(FastMath.abs(imaginary) / (2.0 * t), MathUtils.indicator(imaginary) * t);
    }
}","public void test0066() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = complex0.INF.createComplex(0.0, (-2091.90184));
    Complex complex2 = complex0.sqrt();
    Complex complex3 = complex2.sin();
    complex3.I.pow((-2091.90184));
    Complex complex4 = complex2.INF.subtract(complex0);
    complex2.ZERO.exp();
    Complex complex5 = complex4.NaN.acos();
    complex0.NaN.negate();
    complex4.ZERO.getField();
    complex0.abs();
    Complex complex6 = complex4.INF.sin();
    Complex complex7 = complex1.ZERO.conjugate();
    complex5.ONE.getArgument();
    Complex complex8 = complex0.atan();
    complex8.I.subtract(complex7);
    Complex complex9 = complex1.sqrt();
    complex4.INF.log();
    complex9.ZERO.log();
    Complex complex10 = complex7.ONE.pow(complex9);
    complex5.I.sqrt();
    Complex complex11 = complex10.NaN.pow(complex5);
    complex7.ONE.cos();
    Complex complex12 = complex11.exp();
    Complex complex13 = complex7.ZERO.sqrt1z();
    complex1.getField();
    Complex complex14 = complex7.sqrt1z();
    complex14.log();
    Object object0 = new Object();
    complex12.equals(object0);
    complex13.sin();
    complex6.sqrt();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/SquareRoot.html"" TARGET=""_top"">
 * square root</a> of this complex number.
 * Implements the following algorithm to compute {@code sqrt(a + bi)}:
 * <ol><li>Let {@code t = sqrt((|a| + |a + bi|) / 2)}</li>
 * <li><pre>if {@code  a &#8805; 0} return {@code t + (b/2t)i}
 *  else return {@code |b|/2t + sign(b)t i }</pre></li>
 * </ol>
 * where <ul>
 * <li>{@code |a| = }{@link Math#abs}(a)</li>
 * <li>{@code |a + bi| = }{@link Complex#abs}(a + bi)</li>
 * <li>{@code sign(b) =  }{@link MathUtils#indicator}(b)
 * </ul>
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i
 *   sqrt(INFINITY + i) = INFINITY + 0i
 *   sqrt(-INFINITY + i) = 0 + INFINITY i
 *   sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i
 *   sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i
 *  </code>
 * </pre>
 *
 * @return the square root of {@code this}.
 * @since 1.2
 */"
"public Complex subtract(Complex subtrahend) throws NullArgumentException {
    MathUtils.checkNotNull(subtrahend);
    if (isNaN || subtrahend.isNaN) {
        return NaN;
    }
    return createComplex(real - subtrahend.getReal(), imaginary - subtrahend.getImaginary());
}","public void test0077() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.I.asin();
    Complex complex2 = complex0.ONE.multiply(complex1);
    Complex.valueOf(2.7553817452272217E-6);
    double double0 = 12.0;
    Complex complex3 = complex2.ZERO.createComplex(12.0, 12.0);
    complex3.sqrt();
    complex3.I.readResolve();
    Complex complex4 = Complex.valueOf(Double.POSITIVE_INFINITY);
    Complex complex5 = complex4.I.sin();
    Complex complex6 = new Complex(Double.POSITIVE_INFINITY, 12.0);
    complex4.NaN.subtract(complex6);
    complex4.subtract(complex5);
    complex5.NaN.pow(complex6);
    complex6.NaN.log();
    complex0.ONE.readResolve();
    complex0.ONE.readResolve();
    complex4.tan();
    complex0.abs();
    Complex complex7 = complex4.pow(1014.1582587727);
    try {
        complex7.subtract((Complex) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // null is not allowed
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this - subtrahend)}.
 * Uses the definitional formula
 * <pre>
 *  <code>
 *   (a + bi) - (c + di) = (a-c) + (b-d)i
 *  </code>
 * </pre>
 * If either {@code this} or {@code subtrahend} has a {@code NaN]} value in either part,
 * {@link #NaN} is returned; otherwise infinite and {@code NaN} values are
 * returned in the parts of the result according to the rules for
 * {@link java.lang.Double} arithmetic.
 *
 * @param  subtrahend value to be subtracted from this {@code Complex}.
 * @return {@code this - subtrahend}.
 * @throws NullArgumentException if {@code subtrahend} is {@code null}.
 */"
"public Complex log() {
    if (isNaN) {
        return NaN;
    }
    return createComplex(FastMath.log(abs()), FastMath.atan2(imaginary, real));
}","public void test0088() throws Throwable {
    Complex complex0 = Complex.INF;
    complex0.abs();
    Complex complex1 = Complex.valueOf(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
    Complex complex2 = complex0.pow(complex1);
    complex1.ONE.hashCode();
    Complex complex3 = complex2.INF.pow(complex0);
    Complex complex4 = complex2.cosh();
    Complex complex5 = complex4.I.log();
    Complex complex6 = complex2.ZERO.sqrt();
    complex6.ZERO.conjugate();
    complex4.INF.getField();
    Complex.valueOf(Double.POSITIVE_INFINITY);
    Complex complex7 = complex4.I.divide((-3123.98166223953));
    complex2.ONE.log();
    Complex complex8 = complex2.log();
    Complex complex9 = complex3.NaN.atan();
    complex9.ZERO.getArgument();
    Complex complex10 = complex4.subtract(complex3);
    complex10.ZERO.pow(Double.POSITIVE_INFINITY);
    complex10.I.hashCode();
    complex1.negate();
    Complex complex11 = Complex.valueOf(Double.POSITIVE_INFINITY, 1.997844754509471E-9);
    Complex complex12 = complex7.exp();
    complex12.ONE.negate();
    complex4.add(complex5);
    Complex complex13 = complex11.subtract(complex4);
    Complex complex14 = complex13.acos();
    complex14.ONE.cosh();
    complex8.conjugate();
    complex7.log();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/NaturalLogarithm.html"" TARGET=""_top"">
 * natural logarithm</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   log(a + bi) = ln(|a + bi|) + arg(a + bi)i
 *  </code>
 * </pre>
 * where ln on the right hand side is {@link java.lang.Math#log},
 * {@code |a + bi|} is the modulus, {@link Complex#abs},  and
 * {@code arg(a + bi) = }{@link java.lang.Math#atan2}(b, a).
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   log(1 &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/2)i
 *   log(INFINITY + i) = INFINITY + 0i
 *   log(-INFINITY + i) = INFINITY + &pi;i
 *   log(INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/4)i
 *   log(-INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (3&pi;/4)i
 *   log(0 + 0i) = -INFINITY + 0i
 *  </code>
 * </pre>
 *
 * @return the value <code>ln &nbsp; this</code>, the natural logarithm
 * of {@code this}.
 * @since 1.2
 */"
"public Complex tan() {
    if (isNaN) {
        return NaN;
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = FastMath.cos(real2) + MathUtils.cosh(imaginary2);
    return createComplex(FastMath.sin(real2) / d, MathUtils.sinh(imaginary2) / d);
}","public void test0099() throws Throwable {
    Complex complex0 = new Complex(8.251545029714408E-9, 0.8471270883830365);
    Complex complex1 = complex0.INF.sqrt();
    Complex complex2 = complex0.atan();
    complex1.ONE.acos();
    complex1.ONE.pow(8.251545029714408E-9);
    complex0.INF.sqrt();
    complex2.INF.toString();
    Complex complex3 = Complex.valueOf(8.251545029714408E-9);
    complex1.getField();
    complex3.ONE.abs();
    Complex complex4 = complex3.log();
    complex4.getField();
    complex0.readResolve();
    complex4.tan();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Tangent.html"" TARGET=""_top"">
 * tangent</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   tan(1 &plusmn; INFINITY i) = 0 + NaN i
 *   tan(&plusmn;INFINITY + i) = NaN + NaN i
 *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *   tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i
 *  </code>
 * </pre>
 *
 * @return the tangent of {@code this}.
 * @since 1.2
 */"
"public Complex pow(Complex x) throws NullArgumentException {
    MathUtils.checkNotNull(x);
    return this.log().multiply(x).exp();
}","public void test01010() throws Throwable {
    Complex complex0 = Complex.ONE;
    complex0.isInfinite();
    try {
        complex0.pow((Complex) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // null is not allowed
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns of value of this complex number raised to the power of {@code x}.
 * Implements the formula:
 * <pre>
 *  <code>
 *   y<sup>x</sup> = exp(x&middot;log(y))
 *  </code>
 * </pre>
 * where {@code exp} and {@code log} are {@link #exp} and
 * {@link #log}, respectively.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite, or if {@code y}
 * equals {@link Complex#ZERO}.
 *
 * @param  x exponent to which this {@code Complex} is to be raised.
 * @return <code> this<sup>{@code x}</sup></code>.
 * @throws NullArgumentException if x is {@code null}.
 * @since 1.2
 */"
"public double abs() {
    if (isNaN) {
        return Double.NaN;
    }
    if (isInfinite()) {
        return Double.POSITIVE_INFINITY;
    }
    if (FastMath.abs(real) < FastMath.abs(imaginary)) {
        if (imaginary == 0.0) {
            return FastMath.abs(real);
        }
        double q = real / imaginary;
        return FastMath.abs(imaginary) * FastMath.sqrt(1 + q * q);
    } else {
        if (real == 0.0) {
            return FastMath.abs(imaginary);
        }
        double q = imaginary / real;
        return FastMath.abs(real) * FastMath.sqrt(1 + q * q);
    }
}","public void test01111() throws Throwable {
    Complex complex0 = Complex.ONE;
    complex0.ZERO.atan();
    Complex complex1 = Complex.NaN;
    complex1.INF.tanh();
    Complex complex2 = Complex.valueOf(0.19999954120254515, 0.19999954120254515);
    complex1.NaN.pow(complex2);
    complex1.NaN.toString();
    Complex complex3 = complex0.INF.sqrt();
    complex0.ZERO.subtract(complex1);
    Complex complex4 = complex0.subtract((-2490.7));
    Complex complex5 = complex4.INF.tanh();
    Complex complex6 = complex0.pow(Double.POSITIVE_INFINITY);
    complex5.NaN.conjugate();
    complex4.sin();
    Complex.valueOf((-616.3680538715619));
    complex5.add(Double.POSITIVE_INFINITY);
    complex5.I.negate();
    Complex complex7 = complex3.tan();
    Complex complex8 = complex6.exp();
    Complex complex9 = complex5.log();
    complex7.getImaginary();
    complex4.getReal();
    complex8.readResolve();
    Complex complex10 = complex9.cos();
    Complex complex11 = complex10.ONE.multiply(Double.NaN);
    complex2.cos();
    complex11.abs();
}","/**
 * Return the absolute value of this complex number.
 * Returns {@code NaN} if either real or imaginary part is {@code NaN}
 * and {@code Double.POSITIVE_INFINITY} if neither part is {@code NaN},
 * but at least one part is infinite.
 *
 * @return the absolute value.
 */"
"public List<Complex> nthRoot(int n) {
    if (n <= 0) {
        throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N, n);
    }
    final List<Complex> result = new ArrayList<Complex>();
    if (isNaN) {
        result.add(NaN);
        return result;
    }
    if (isInfinite()) {
        result.add(INF);
        return result;
    }
    // nth root of abs -- faster / more accurate to use a solver here?
    final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);
    // Compute nth roots of complex number with k = 0, 1, ... n-1
    final double nthPhi = getArgument() / n;
    final double slice = 2 * FastMath.PI / n;
    double innerPart = nthPhi;
    for (int k = 0; k < n; k++) {
        // inner part
        final double realPart = nthRootOfAbs * FastMath.cos(innerPart);
        final double imaginaryPart = nthRootOfAbs * FastMath.sin(innerPart);
        result.add(createComplex(realPart, imaginaryPart));
        innerPart += slice;
    }
    return result;
}","public void test01212() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = complex0.divide(Double.POSITIVE_INFINITY);
    Complex complex2 = complex1.exp();
    Complex complex3 = complex1.ONE.pow(Double.POSITIVE_INFINITY);
    Complex complex4 = complex3.pow(complex0);
    Complex complex5 = complex2.ZERO.cosh();
    Complex complex6 = complex3.I.tan();
    complex6.I.hashCode();
    Complex complex7 = complex0.ZERO.sin();
    complex2.createComplex(1870.5758085, 0.0);
    complex7.getArgument();
    complex1.toString();
    complex0.sin();
    Complex complex8 = complex0.multiply((-3240.151965));
    complex0.ONE.getField();
    Complex complex9 = complex1.NaN.pow(complex0);
    complex9.NaN.tanh();
    complex4.getField();
    Complex complex10 = complex7.log();
    complex10.INF.atan();
    Complex complex11 = complex8.atan();
    complex11.ZERO.atan();
    complex8.ZERO.getArgument();
    Complex complex12 = complex7.sin();
    complex12.NaN.divide(complex4);
    Complex.valueOf((-2345.9582633378));
    complex8.asin();
    Complex.valueOf((-3240.151965));
    complex12.hashCode();
    // Undeclared exception!
    try {
        complex5.nthRoot((-2148));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot compute nth root for null or negative n: -2,148
        //
        verifyException(""org.apache.commons.math.complex.Complex"", e);
    }
}","/**
 * Computes the n-th roots of this complex number.
 * The nth roots are defined by the formula:
 * <pre>
 *  <code>
 *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))
 *  </code>
 * </pre>
 * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}
 * are respectively the {@link #abs() modulus} and
 * {@link #getArgument() argument} of this complex number.
 * <br/>
 * If one or both parts of this complex number is NaN, a list with just
 * one element, {@link #NaN} is returned.
 * if neither part is NaN, but at least one part is infinite, the result
 * is a one-element list containing {@link #INF}.
 *
 * @param n Degree of root.
 * @return a List<Complex> of all {@code n}-th roots of {@code this}.
 * @throws NotPositiveException if {@code n <= 0}.
 * @since 2.0
 */"
"public Complex divide(double divisor) {
    if (isNaN || Double.isNaN(divisor)) {
        return NaN;
    }
    if (divisor == 0d) {
        return NaN;
    }
    if (Double.isInfinite(divisor)) {
        return !isInfinite() ? ZERO : NaN;
    }
    return createComplex(real / divisor, imaginary / divisor);
}","public void test01313() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.ZERO.negate();
    Complex complex2 = complex0.log();
    Complex complex3 = complex0.ZERO.sinh();
    Complex complex4 = complex3.ZERO.conjugate();
    Complex complex5 = complex2.INF.negate();
    complex5.NaN.getField();
    complex4.I.asin();
    complex4.INF.getArgument();
    Complex complex6 = new Complex(0.0);
    complex6.NaN.getField();
    Complex complex7 = complex2.I.divide(complex6);
    complex6.I.abs();
    Complex complex8 = complex7.ONE.conjugate();
    complex0.readResolve();
    Complex complex9 = complex1.I.sqrt1z();
    complex2.hashCode();
    complex0.atan();
    complex7.ONE.negate();
    Complex complex10 = complex1.multiply(2504.643931016);
    complex4.INF.acos();
    complex6.subtract(complex7);
    complex4.divide(0.0);
    complex9.conjugate();
    complex10.isNaN();
    complex0.atan();
    complex8.divide(Double.NaN);
}","/**
 * Returns a {@code Complex} whose value is {@code (this / divisor)},
 * with {@code divisor} interpreted as a real number.
 *
 * @param  divisor Value by which this {@code Complex} is to be divided.
 * @return {@code this / divisor}.
 * @see #divide(Complex)
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Complex) {
        Complex c = (Complex) other;
        if (c.isNaN) {
            return isNaN;
        } else {
            return (real == c.real) && (imaginary == c.imaginary);
        }
    }
    return false;
}","public void test01414() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.NaN.exp();
    Complex complex2 = complex0.multiply(Double.NaN);
    Complex complex3 = complex0.divide(Double.NaN);
    complex0.NaN.getField();
    complex3.NaN.readResolve();
    Complex.valueOf(1533.4099858269, Double.NaN);
    complex3.INF.abs();
    Complex complex4 = complex3.acos();
    Complex complex5 = complex4.I.cosh();
    complex5.NaN.exp();
    Complex complex6 = complex1.subtract(complex2);
    complex6.ZERO.divide(Double.POSITIVE_INFINITY);
    Object object0 = new Object();
    complex2.equals(object0);
    complex3.log();
    complex6.equals(complex4);
}","/**
 * Test for the equality of two Complex objects.
 * If both the real and imaginary parts of two complex numbers
 * are exactly the same, and neither is {@code Double.NaN}, the two
 * Complex objects are considered to be equal.
 * All {@code NaN} values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to {@code Double.NaN}, the complex number is equal to
 * {@code NaN}.
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if object is
 * {@code null}, not an instance of Complex, or not equal to this Complex
 * instance.
 */"
"@Override
public int hashCode() {
    if (isNaN) {
        return 7;
    }
    return 37 * (17 * MathUtils.hash(imaginary) + MathUtils.hash(real));
}","public void test01515() throws Throwable {
    Complex complex0 = Complex.ZERO;
    complex0.abs();
    complex0.acos();
    Complex complex1 = complex0.tan();
    Complex complex2 = complex1.I.sin();
    Complex complex3 = complex1.add(0.0);
    Complex complex4 = complex3.I.cosh();
    complex3.getReal();
    complex1.log();
    Complex complex5 = Complex.valueOf(0.0, 0.1111111111111111);
    complex1.getArgument();
    Complex complex6 = complex2.cosh();
    Complex complex7 = complex1.divide(0.1111111111111111);
    Complex complex8 = complex6.tan();
    complex7.tanh();
    complex5.getReal();
    complex8.cosh();
    complex2.atan();
    Complex.valueOf(0.0);
    complex4.hashCode();
}","/**
 * Get a hashCode for the complex number.
 * Any {@code Double.NaN} value in real or imaginary part produces
 * the same hash code {@code 7}.
 *
 * @return a hash code value for this object.
 */"
"public List<Complex> nthRoot(int n) {
    if (n <= 0) {
        throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N, n);
    }
    final List<Complex> result = new ArrayList<Complex>();
    if (isNaN) {
        result.add(NaN);
        return result;
    }
    if (isInfinite()) {
        result.add(INF);
        return result;
    }
    // nth root of abs -- faster / more accurate to use a solver here?
    final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);
    // Compute nth roots of complex number with k = 0, 1, ... n-1
    final double nthPhi = getArgument() / n;
    final double slice = 2 * FastMath.PI / n;
    double innerPart = nthPhi;
    for (int k = 0; k < n; k++) {
        // inner part
        final double realPart = nthRootOfAbs * FastMath.cos(innerPart);
        final double imaginaryPart = nthRootOfAbs * FastMath.sin(innerPart);
        result.add(createComplex(realPart, imaginaryPart));
        innerPart += slice;
    }
    return result;
}","public void test01616() throws Throwable {
    Complex complex0 = Complex.I;
    double double0 = 0.0;
    Complex complex1 = complex0.ONE.pow(0.0);
    int int0 = 3265;
    complex1.INF.sqrt();
    complex0.nthRoot(3265);
    Complex complex2 = complex1.NaN.tanh();
    Complex.valueOf(0.0);
    complex2.NaN.pow(complex0);
    Complex complex3 = complex1.I.atan();
    complex3.NaN.subtract(5.650007086920087E-9);
    Complex complex4 = complex0.multiply((-1761.203806667228));
    // Undeclared exception!
    complex4.nthRoot(3265);
}","/**
 * Computes the n-th roots of this complex number.
 * The nth roots are defined by the formula:
 * <pre>
 *  <code>
 *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))
 *  </code>
 * </pre>
 * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}
 * are respectively the {@link #abs() modulus} and
 * {@link #getArgument() argument} of this complex number.
 * <br/>
 * If one or both parts of this complex number is NaN, a list with just
 * one element, {@link #NaN} is returned.
 * if neither part is NaN, but at least one part is infinite, the result
 * is a one-element list containing {@link #INF}.
 *
 * @param n Degree of root.
 * @return a List<Complex> of all {@code n}-th roots of {@code this}.
 * @throws NotPositiveException if {@code n <= 0}.
 * @since 2.0
 */"
"public Complex sqrt() {
    if (isNaN) {
        return NaN;
    }
    if (real == 0.0 && imaginary == 0.0) {
        return createComplex(0.0, 0.0);
    }
    double t = FastMath.sqrt((FastMath.abs(real) + abs()) / 2.0);
    if (real >= 0.0) {
        return createComplex(t, imaginary / (2.0 * t));
    } else {
        return createComplex(FastMath.abs(imaginary) / (2.0 * t), MathUtils.indicator(imaginary) * t);
    }
}","public void test01717() throws Throwable {
    Complex complex0 = new Complex((-940.0), (-940.0));
    Complex complex1 = Complex.valueOf((-1105.325103098376));
    Complex complex2 = complex0.INF.sqrt1z();
    Complex complex3 = complex0.add(complex1);
    Complex complex4 = complex1.ONE.exp();
    complex0.sin();
    complex1.exp();
    Complex complex5 = complex4.tanh();
    complex2.isInfinite();
    complex2.hashCode();
    Complex complex6 = complex4.NaN.conjugate();
    complex0.toString();
    complex5.ZERO.divide((-3545.1566946));
    Complex complex7 = complex0.subtract(complex3);
    complex7.ZERO.divide(complex6);
    complex5.abs();
    Complex complex8 = complex4.atan();
    complex8.ONE.log();
    Complex complex9 = Complex.valueOf((-3545.1566946));
    complex2.divide(complex9);
    complex1.sqrt();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/SquareRoot.html"" TARGET=""_top"">
 * square root</a> of this complex number.
 * Implements the following algorithm to compute {@code sqrt(a + bi)}:
 * <ol><li>Let {@code t = sqrt((|a| + |a + bi|) / 2)}</li>
 * <li><pre>if {@code  a &#8805; 0} return {@code t + (b/2t)i}
 *  else return {@code |b|/2t + sign(b)t i }</pre></li>
 * </ol>
 * where <ul>
 * <li>{@code |a| = }{@link Math#abs}(a)</li>
 * <li>{@code |a + bi| = }{@link Complex#abs}(a + bi)</li>
 * <li>{@code sign(b) =  }{@link MathUtils#indicator}(b)
 * </ul>
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i
 *   sqrt(INFINITY + i) = INFINITY + 0i
 *   sqrt(-INFINITY + i) = 0 + INFINITY i
 *   sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i
 *   sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i
 *  </code>
 * </pre>
 *
 * @return the square root of {@code this}.
 * @since 1.2
 */"
"public double abs() {
    if (isNaN) {
        return Double.NaN;
    }
    if (isInfinite()) {
        return Double.POSITIVE_INFINITY;
    }
    if (FastMath.abs(real) < FastMath.abs(imaginary)) {
        if (imaginary == 0.0) {
            return FastMath.abs(real);
        }
        double q = real / imaginary;
        return FastMath.abs(imaginary) * FastMath.sqrt(1 + q * q);
    } else {
        if (real == 0.0) {
            return FastMath.abs(imaginary);
        }
        double q = imaginary / real;
        return FastMath.abs(real) * FastMath.sqrt(1 + q * q);
    }
}","public void test01818() throws Throwable {
    Complex complex0 = Complex.valueOf(0.07692307692307693, 1.0);
    Complex complex1 = complex0.cos();
    Complex complex2 = complex1.log();
    Complex complex3 = complex0.cosh();
    complex1.NaN.divide((-2569.32327198));
    Complex complex4 = complex0.NaN.pow(complex3);
    complex4.ZERO.cos();
    Complex complex5 = complex1.NaN.multiply(complex0);
    Complex.valueOf(0.0);
    Complex complex6 = complex2.subtract(0.0);
    complex2.ZERO.toString();
    Complex complex7 = complex6.tan();
    Complex complex8 = complex0.divide(complex3);
    complex3.NaN.sqrt1z();
    complex1.tan();
    complex7.toString();
    complex0.asin();
    complex8.subtract(complex3);
    complex1.subtract(0.0);
    complex5.abs();
}","/**
 * Return the absolute value of this complex number.
 * Returns {@code NaN} if either real or imaginary part is {@code NaN}
 * and {@code Double.POSITIVE_INFINITY} if neither part is {@code NaN},
 * but at least one part is infinite.
 *
 * @return the absolute value.
 */"
"public ComplexField getField() {
    return ComplexField.getInstance();
}","public void test01919() throws Throwable {
    Complex complex0 = Complex.valueOf((-1106.4407611427034), (-1830.56497));
    Complex complex1 = complex0.ONE.atan();
    Complex complex2 = complex1.createComplex(1300.335011281131, 0.0);
    complex2.ONE.divide(complex1);
    Complex complex3 = complex0.conjugate();
    Complex complex4 = complex3.INF.conjugate();
    complex4.I.log();
    complex3.INF.sin();
    Complex complex5 = complex0.sin();
    complex5.ONE.pow(complex3);
    Complex complex6 = complex0.multiply((-1830.56497));
    Complex complex7 = complex6.INF.pow(1.176342548272881E-8);
    complex7.sinh();
    complex0.divide((-622.2));
    complex1.isNaN();
    Complex complex8 = complex3.divide((-1830.56497));
    complex4.isInfinite();
    complex8.createComplex((-1106.4407611427034), (-622.2));
    complex6.getField();
}","/**
 * {@inheritDoc}
 */"
"public List<Complex> nthRoot(int n) {
    if (n <= 0) {
        throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N, n);
    }
    final List<Complex> result = new ArrayList<Complex>();
    if (isNaN) {
        result.add(NaN);
        return result;
    }
    if (isInfinite()) {
        result.add(INF);
        return result;
    }
    // nth root of abs -- faster / more accurate to use a solver here?
    final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);
    // Compute nth roots of complex number with k = 0, 1, ... n-1
    final double nthPhi = getArgument() / n;
    final double slice = 2 * FastMath.PI / n;
    double innerPart = nthPhi;
    for (int k = 0; k < n; k++) {
        // inner part
        final double realPart = nthRootOfAbs * FastMath.cos(innerPart);
        final double imaginaryPart = nthRootOfAbs * FastMath.sin(innerPart);
        result.add(createComplex(realPart, imaginaryPart));
        innerPart += slice;
    }
    return result;
}","public void test02020() throws Throwable {
    double double0 = 1015.7;
    double double1 = Double.POSITIVE_INFINITY;
    Complex complex0 = new Complex(1015.7, Double.POSITIVE_INFINITY);
    complex0.NaN.pow(0.16666666666666666);
    // Undeclared exception!
    try {
        complex0.nthRoot((-909));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot compute nth root for null or negative n: -909
        //
        verifyException(""org.apache.commons.math.complex.Complex"", e);
    }
}","/**
 * Computes the n-th roots of this complex number.
 * The nth roots are defined by the formula:
 * <pre>
 *  <code>
 *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))
 *  </code>
 * </pre>
 * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}
 * are respectively the {@link #abs() modulus} and
 * {@link #getArgument() argument} of this complex number.
 * <br/>
 * If one or both parts of this complex number is NaN, a list with just
 * one element, {@link #NaN} is returned.
 * if neither part is NaN, but at least one part is infinite, the result
 * is a one-element list containing {@link #INF}.
 *
 * @param n Degree of root.
 * @return a List<Complex> of all {@code n}-th roots of {@code this}.
 * @throws NotPositiveException if {@code n <= 0}.
 * @since 2.0
 */"
"protected Complex createComplex(double realPart, double imaginaryPart) {
    return new Complex(realPart, imaginaryPart);
}","public void test02121() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = Complex.ZERO;
    Complex complex2 = complex1.ZERO.cos();
    Complex complex3 = complex0.sinh();
    complex3.tan();
    Complex complex4 = complex0.INF.multiply(complex1);
    complex4.NaN.exp();
    Complex complex5 = complex0.pow(722.206499088);
    Complex complex6 = complex5.INF.divide(complex0);
    complex6.NaN.pow(0.0);
    Complex complex7 = complex0.tan();
    Complex complex8 = complex7.NaN.negate();
    complex2.ONE.add(722.206499088);
    Complex complex9 = Complex.INF;
    Complex complex10 = Complex.valueOf(722.206499088, 722.206499088);
    Complex complex11 = complex2.multiply(complex9);
    complex11.divide(12.0);
    Complex complex12 = complex0.sqrt();
    complex12.INF.acos();
    Complex complex13 = Complex.valueOf(12.0);
    complex13.NaN.sqrt1z();
    complex12.ONE.tan();
    complex0.ZERO.getArgument();
    complex10.getImaginary();
    complex9.I.abs();
    complex5.toString();
    complex2.readResolve();
    Complex complex14 = complex11.pow(722.206499088);
    Complex complex15 = complex14.divide(complex12);
    complex15.I.sinh();
    complex1.multiply(0.01745329052209854);
    complex8.createComplex(332.609741714, 0.01745329052209854);
}","/**
 * Create a complex number given the real and imaginary parts.
 *
 * @param realPart Real part.
 * @param imaginaryPart Imaginary part.
 * @return a new complex number instance.
 * @since 1.2
 * @see #valueOf(double, double)
 */"
"public Complex pow(double x) {
    return this.log().multiply(x).exp();
}","public void test02222() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = Complex.valueOf(0.0);
    Complex complex2 = complex0.multiply(complex1);
    Complex complex3 = complex2.ONE.asin();
    Complex complex4 = complex0.ZERO.log();
    complex1.I.subtract(0.0);
    complex2.nthRoot(2302);
    complex0.NaN.negate();
    Complex complex5 = complex2.ONE.tan();
    Complex complex6 = complex2.pow(complex1);
    Complex complex7 = complex6.exp();
    complex7.I.sin();
    complex1.atan();
    complex4.isInfinite();
    complex5.ZERO.nthRoot(2302);
    Complex complex8 = complex0.add(0.333333333333333);
    complex8.abs();
    Complex complex9 = complex3.NaN.divide(complex5);
    Complex complex10 = Complex.valueOf(2459.070788, 2459.070788);
    complex3.pow(complex10);
    Complex.valueOf((-685.2963035897));
    complex0.conjugate();
    complex3.sqrt();
    complex0.equals(complex9);
    complex3.pow((-2372.332706601));
}","/**
 * Returns of value of this complex number raised to the power of {@code x}.
 *
 * @param  x exponent to which this {@code Complex} is to be raised.
 * @return <code>this<sup>x</sup></code>.
 * @see #pow(Complex)
 */"
"public Complex divide(Complex divisor) throws NullArgumentException {
    MathUtils.checkNotNull(divisor);
    if (isNaN || divisor.isNaN) {
        return NaN;
    }
    if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) {
        return NaN;
    }
    if (divisor.isInfinite() && !isInfinite()) {
        return ZERO;
    }
    final double c = divisor.getReal();
    final double d = divisor.getImaginary();
    if (FastMath.abs(c) < FastMath.abs(d)) {
        double q = c / d;
        double denominator = c * q + d;
        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);
    } else {
        double q = d / c;
        double denominator = d * q + c;
        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
    }
}","public void test02323() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = new Complex(71.2586727722403);
    Complex complex2 = complex1.cos();
    Complex complex3 = complex0.subtract(complex1);
    complex1.ZERO.multiply(71.2586727722403);
    Complex complex4 = complex3.NaN.subtract((-2549.782341));
    complex1.isInfinite();
    complex4.ONE.createComplex((-2549.782341), 2.0);
    complex2.log();
    Complex complex5 = complex0.cos();
    complex5.exp();
    complex1.divide(complex4);
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this / divisor)}.
 * Implements the definitional formula
 * <pre>
 *  <code>
 *    a + bi          ac + bd + (bc - ad)i
 *    ----------- = -------------------------
 *    c + di         c<sup>2</sup> + d<sup>2</sup>
 *  </code>
 * </pre>
 * but uses
 * <a href=""http://doi.acm.org/10.1145/1039813.1039814"">
 * prescaling of operands</a> to limit the effects of overflows and
 * underflows in the computation.
 * <br/>
 * {@code Infinite} and {@code NaN} values are handled according to the
 * following rules, applied in the order presented:
 * <ul>
 *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value
 *   in either part, {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code this} and {@code divisor} are both {@link #ZERO},
 *   {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code divisor} equals {@link #ZERO}, {@link #INF} is returned.
 *  </li>
 *  <li>If {@code this} and {@code divisor} are both infinite,
 *   {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or
 *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts
 *   infinite), {@link #ZERO} is returned.
 *  </li>
 *  <li>If {@code this} is infinite and {@code divisor} is finite,
 *   {@code NaN} values are returned in the parts of the result if the
 *   {@link java.lang.Double} rules applied to the definitional formula
 *   force {@code NaN} results.
 *  </li>
 * </ul>
 *
 * @param divisor Value by which this {@code Complex} is to be divided.
 * @return {@code this / divisor}.
 * @throws NullArgumentException if {@code divisor} is {@code null}.
 */"
"public double getReal() {
    return real;
}","public void test02424() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = complex0.ZERO.log();
    Complex complex2 = complex1.INF.conjugate();
    complex0.hashCode();
    Complex complex3 = complex1.add((-2.957007209750105E-8));
    complex3.INF.getArgument();
    Complex complex4 = complex0.tan();
    complex4.ZERO.toString();
    complex4.INF.getArgument();
    Complex complex5 = complex4.acos();
    complex1.sqrt();
    Complex complex6 = Complex.valueOf((-970.8813176722667), (-970.8813176722667));
    complex6.NaN.pow((-2.957007209750105E-8));
    complex6.INF.log();
    Complex complex7 = Complex.valueOf(0.167);
    Complex complex8 = complex7.ZERO.divide(complex5);
    Complex complex9 = complex1.sinh();
    complex2.ONE.abs();
    Complex complex10 = complex9.NaN.log();
    complex1.tanh();
    Complex.valueOf(3757.229241514609);
    Complex complex11 = complex10.ZERO.cosh();
    complex11.INF.subtract(0.7853981633974483);
    Complex complex12 = complex1.sinh();
    complex12.ZERO.conjugate();
    Complex complex13 = complex12.NaN.negate();
    Complex complex14 = complex2.conjugate();
    complex14.divide(complex9);
    Complex complex15 = complex9.tanh();
    complex10.isInfinite();
    complex15.cos();
    complex13.multiply(0.7853981633974483);
    complex12.getArgument();
    complex8.isNaN();
    complex14.getReal();
}","/**
 * Access the real part.
 *
 * @return the real part.
 */"
"public Complex negate() {
    if (isNaN) {
        return NaN;
    }
    return createComplex(-real, -imaginary);
}","public void test02525() throws Throwable {
    Complex complex0 = new Complex(2676.8242);
    Complex complex1 = complex0.pow(908.2);
    complex1.INF.acos();
    Complex complex2 = complex1.tanh();
    complex1.ONE.atan();
    complex0.sqrt1z();
    complex0.toString();
    complex2.sqrt1z();
    complex1.negate();
}","/**
 * Returns a {@code Complex} whose value is {@code (-this)}.
 * Returns {@code NaN} if either real or imaginary
 * part of this Complex number equals {@code Double.NaN}.
 *
 * @return {@code -this}.
 */"
"public Complex exp() {
    if (isNaN) {
        return NaN;
    }
    double expReal = FastMath.exp(real);
    return createComplex(expReal * FastMath.cos(imaginary), expReal * FastMath.sin(imaginary));
}","public void test02626() throws Throwable {
    Complex complex0 = Complex.valueOf(0.0, 0.0);
    complex0.hashCode();
    complex0.ONE.tan();
    Complex complex1 = complex0.sin();
    Complex complex2 = Complex.valueOf((-1637.31273183776), 0.0);
    Complex complex3 = complex2.I.tan();
    Complex.valueOf((-1.0));
    complex3.NaN.log();
    Complex.valueOf(0.0, (-1802.089548400548));
    complex2.atan();
    Complex complex4 = complex0.conjugate();
    complex4.sqrt1z();
    Complex.valueOf(0.0, (-1802.089548400548));
    complex2.sqrt();
    complex1.exp();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/ExponentialFunction.html"" TARGET=""_top"">
 * exponential function</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#exp}, {@link java.lang.Math#cos}, and
 * {@link java.lang.Math#sin}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   exp(1 &plusmn; INFINITY i) = NaN + NaN i
 *   exp(INFINITY + i) = INFINITY + INFINITY i
 *   exp(-INFINITY + i) = 0 + 0i
 *   exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *  </code>
 * </pre>
 *
 * @return <code><i>e</i><sup>this</sup></code>.
 * @since 1.2
 */"
"public Complex subtract(double subtrahend) {
    if (isNaN || Double.isNaN(subtrahend)) {
        return NaN;
    }
    return createComplex(real - subtrahend, imaginary);
}","public void test02727() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = new Complex(451.708049122054, 451.708049122054);
    Complex complex2 = new Complex((-1603.4959993), 451.708049122054);
    complex1.NaN.divide(complex2);
    complex0.pow(complex1);
    complex0.isInfinite();
    Complex complex3 = complex0.cosh();
    complex3.subtract(451.708049122054);
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this - subtrahend)}.
 *
 * @param  subtrahend value to be subtracted from this {@code Complex}.
 * @return {@code this - subtrahend}.
 * @see #subtract(Complex)
 */"
"public double getArgument() {
    return FastMath.atan2(getImaginary(), getReal());
}","public void test02828() throws Throwable {
    Complex complex0 = Complex.valueOf(0.0, (-3735.8220878899638));
    Complex complex1 = complex0.I.multiply((-2389.6805));
    Complex complex2 = Complex.valueOf(2266.42684135932);
    Complex complex3 = complex2.atan();
    Complex complex4 = complex2.conjugate();
    complex1.isNaN();
    complex2.ZERO.divide(complex4);
    Complex complex5 = complex2.exp();
    Complex complex6 = complex3.atan();
    complex5.isNaN();
    complex6.readResolve();
    complex1.exp();
    Complex complex7 = complex4.multiply((-3735.8220878899638));
    complex7.ZERO.nthRoot(1);
    complex5.getArgument();
}","/**
 * Compute the argument of this complex number.
 * The argument is the angle phi between the positive real axis and
 * the point representing this number in the complex plane.
 * The value returned is between -PI (not inclusive)
 * and PI (inclusive), with negative values returned for numbers with
 * negative imaginary parts.
 * <br/>
 * If either real or imaginary part (or both) is NaN, NaN is returned.
 * Infinite parts are handled as {@code Math.atan2} handles them,
 * essentially treating finite parts as zero in the presence of an
 * infinite coordinate and returning a multiple of pi/4 depending on
 * the signs of the infinite parts.
 * See the javadoc for {@code Math.atan2} for full details.
 *
 * @return the argument of {@code this}.
 */"
"public Complex add(Complex addend) throws NullArgumentException {
    MathUtils.checkNotNull(addend);
    if (isNaN || addend.isNaN) {
        return NaN;
    }
    return createComplex(real + addend.getReal(), imaginary + addend.getImaginary());
}","public void test02929() throws Throwable {
    Complex complex0 = new Complex(0.19999998807907104);
    Complex complex1 = complex0.subtract(0.19999998807907104);
    complex1.INF.multiply(complex0);
    complex0.ZERO.tan();
    Complex complex2 = complex0.sqrt1z();
    complex0.readResolve();
    complex1.tan();
    Complex complex3 = complex0.subtract(complex2);
    Complex complex4 = complex0.sqrt();
    complex4.toString();
    complex3.add(complex4);
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this + addend)}.
 * Uses the definitional formula
 * <pre>
 *  <code>
 *   (a + bi) + (c + di) = (a+c) + (b+d)i
 *  </code>
 * </pre>
 * <br/>
 * If either {@code this} or {@code addend} has a {@code NaN} value in
 * either part, {@link #NaN} is returned; otherwise {@code Infinite}
 * and {@code NaN} values are returned in the parts of the result
 * according to the rules for {@link java.lang.Double} arithmetic.
 *
 * @param  addend Value to be added to this {@code Complex}.
 * @return {@code this + addend}.
 * @throws NullArgumentException if {@code addend} is {@code null}.
 */"
"public Complex tan() {
    if (isNaN) {
        return NaN;
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = FastMath.cos(real2) + MathUtils.cosh(imaginary2);
    return createComplex(FastMath.sin(real2) / d, MathUtils.sinh(imaginary2) / d);
}","public void test03030() throws Throwable {
    Complex complex0 = Complex.valueOf(0.0, 0.0);
    Complex complex1 = complex0.NaN.cos();
    complex0.getReal();
    complex0.readResolve();
    complex1.NaN.sinh();
    Complex complex2 = complex1.createComplex((-10.57), (-456.9455001));
    Complex complex3 = Complex.valueOf((-10.57));
    complex0.ONE.multiply(complex3);
    complex3.INF.readResolve();
    Complex complex4 = complex3.ONE.add(complex1);
    complex4.I.toString();
    complex2.equals(complex3);
    complex1.tan();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Tangent.html"" TARGET=""_top"">
 * tangent</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   tan(1 &plusmn; INFINITY i) = 0 + NaN i
 *   tan(&plusmn;INFINITY + i) = NaN + NaN i
 *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *   tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i
 *  </code>
 * </pre>
 *
 * @return the tangent of {@code this}.
 * @since 1.2
 */"
"public double getReal() {
    return real;
}","public void test03131() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = complex0.ONE.sqrt1z();
    complex0.readResolve();
    complex0.I.multiply(complex1);
    complex0.nthRoot(7);
    Complex complex2 = complex0.sqrt1z();
    complex0.multiply((double) 7);
    complex1.pow((-2956.314));
    Complex complex3 = complex2.cos();
    complex3.INF.nthRoot(7);
    complex3.conjugate();
    Complex.valueOf((-2956.314));
    complex2.getReal();
}","/**
 * Access the real part.
 *
 * @return the real part.
 */"
"public Complex add(double addend) {
    if (isNaN || Double.isNaN(addend)) {
        return NaN;
    }
    return createComplex(real + addend, imaginary);
}","public void test03232() throws Throwable {
    Complex complex0 = Complex.NaN;
    complex0.INF.abs();
    Complex complex1 = complex0.sqrt();
    Complex complex2 = complex1.NaN.add((-4935.6723));
    Complex complex3 = complex1.ZERO.subtract(1704.3733911);
    complex2.INF.abs();
    Complex complex4 = complex3.INF.cos();
    complex4.ONE.tan();
    Complex complex5 = complex1.conjugate();
    complex0.ZERO.subtract(complex2);
    complex0.toString();
    complex3.abs();
    complex5.hashCode();
    Complex complex6 = complex5.negate();
    complex6.NaN.negate();
    complex5.hashCode();
    complex6.getReal();
    complex4.add(Double.NaN);
}","/**
 * Returns a {@code Complex} whose value is {@code (this + addend)},
 * with {@code addend} interpreted as a real number.
 *
 * @param addend Value to be added to this {@code Complex}.
 * @return {@code this + addend}.
 * @see #add(Complex)
 */"
"public List<Complex> nthRoot(int n) {
    if (n <= 0) {
        throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N, n);
    }
    final List<Complex> result = new ArrayList<Complex>();
    if (isNaN) {
        result.add(NaN);
        return result;
    }
    if (isInfinite()) {
        result.add(INF);
        return result;
    }
    // nth root of abs -- faster / more accurate to use a solver here?
    final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);
    // Compute nth roots of complex number with k = 0, 1, ... n-1
    final double nthPhi = getArgument() / n;
    final double slice = 2 * FastMath.PI / n;
    double innerPart = nthPhi;
    for (int k = 0; k < n; k++) {
        // inner part
        final double realPart = nthRootOfAbs * FastMath.cos(innerPart);
        final double imaginaryPart = nthRootOfAbs * FastMath.sin(innerPart);
        result.add(createComplex(realPart, imaginaryPart));
        innerPart += slice;
    }
    return result;
}","public void test03333() throws Throwable {
    Complex complex0 = Complex.valueOf((-2098.980137684341));
    Complex.valueOf(0.0, (-1884.806573799));
    Complex complex1 = complex0.createComplex(3160.071260027, (-2098.980137684341));
    complex1.NaN.tanh();
    Complex complex2 = complex1.ZERO.divide(3160.071260027);
    complex2.NaN.tanh();
    Complex complex3 = Complex.ONE;
    complex3.I.readResolve();
    Complex complex4 = complex1.NaN.add(complex3);
    complex4.sin();
    Complex complex5 = complex1.ZERO.acos();
    complex5.ZERO.log();
    complex0.getReal();
    // Undeclared exception!
    try {
        complex2.INF.nthRoot(0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot compute nth root for null or negative n: 0
        //
        verifyException(""org.apache.commons.math.complex.Complex"", e);
    }
}","/**
 * Computes the n-th roots of this complex number.
 * The nth roots are defined by the formula:
 * <pre>
 *  <code>
 *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))
 *  </code>
 * </pre>
 * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}
 * are respectively the {@link #abs() modulus} and
 * {@link #getArgument() argument} of this complex number.
 * <br/>
 * If one or both parts of this complex number is NaN, a list with just
 * one element, {@link #NaN} is returned.
 * if neither part is NaN, but at least one part is infinite, the result
 * is a one-element list containing {@link #INF}.
 *
 * @param n Degree of root.
 * @return a List<Complex> of all {@code n}-th roots of {@code this}.
 * @throws NotPositiveException if {@code n <= 0}.
 * @since 2.0
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Complex) {
        Complex c = (Complex) other;
        if (c.isNaN) {
            return isNaN;
        } else {
            return (real == c.real) && (imaginary == c.imaginary);
        }
    }
    return false;
}","public void test03434() throws Throwable {
    Complex complex0 = Complex.NaN;
    Complex complex1 = complex0.pow((-1580.0526));
    Complex complex2 = complex1.ZERO.sin();
    Complex complex3 = complex2.NaN.sqrt();
    complex1.hashCode();
    Complex complex4 = complex0.exp();
    complex4.NaN.multiply((-1580.0526));
    complex4.INF.abs();
    Complex complex5 = complex0.negate();
    complex0.subtract(2024.5786127379486);
    Complex.valueOf(2.0, 4328.89478421);
    complex3.tan();
    complex2.isNaN();
    complex2.readResolve();
    complex5.equals(complex1);
}","/**
 * Test for the equality of two Complex objects.
 * If both the real and imaginary parts of two complex numbers
 * are exactly the same, and neither is {@code Double.NaN}, the two
 * Complex objects are considered to be equal.
 * All {@code NaN} values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to {@code Double.NaN}, the complex number is equal to
 * {@code NaN}.
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if object is
 * {@code null}, not an instance of Complex, or not equal to this Complex
 * instance.
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Complex) {
        Complex c = (Complex) other;
        if (c.isNaN) {
            return isNaN;
        } else {
            return (real == c.real) && (imaginary == c.imaginary);
        }
    }
    return false;
}","public void test03535() throws Throwable {
    Complex complex0 = Complex.valueOf(6.283185307179586, 0.0);
    Complex complex1 = Complex.valueOf(0.0, 1077.513167137088);
    Complex.valueOf(0.0, 0.0);
    complex1.tan();
    Complex complex2 = complex1.INF.sin();
    complex2.I.divide(0.0);
    complex0.equals(complex1);
}","/**
 * Test for the equality of two Complex objects.
 * If both the real and imaginary parts of two complex numbers
 * are exactly the same, and neither is {@code Double.NaN}, the two
 * Complex objects are considered to be equal.
 * All {@code NaN} values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to {@code Double.NaN}, the complex number is equal to
 * {@code NaN}.
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if object is
 * {@code null}, not an instance of Complex, or not equal to this Complex
 * instance.
 */"
"public double getImaginary() {
    return imaginary;
}","public void test03636() throws Throwable {
    Complex complex0 = Complex.INF;
    complex0.ONE.toString();
    Complex complex1 = new Complex((-2130.345), (-1145.30516837));
    Complex complex2 = complex0.subtract(complex1);
    complex2.ZERO.sinh();
    complex1.getImaginary();
    Complex complex3 = complex1.cosh();
    complex3.tan();
    Complex complex4 = complex3.cos();
    Complex complex5 = complex3.acos();
    complex5.sqrt();
    complex2.exp();
    complex4.getImaginary();
}","/**
 * Access the imaginary part.
 *
 * @return the imaginary part.
 */"
"public Complex divide(Complex divisor) throws NullArgumentException {
    MathUtils.checkNotNull(divisor);
    if (isNaN || divisor.isNaN) {
        return NaN;
    }
    if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) {
        return NaN;
    }
    if (divisor.isInfinite() && !isInfinite()) {
        return ZERO;
    }
    final double c = divisor.getReal();
    final double d = divisor.getImaginary();
    if (FastMath.abs(c) < FastMath.abs(d)) {
        double q = c / d;
        double denominator = c * q + d;
        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);
    } else {
        double q = d / c;
        double denominator = d * q + c;
        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
    }
}","public void test03737() throws Throwable {
    Complex complex0 = Complex.I;
    complex0.NaN.abs();
    Complex complex1 = Complex.valueOf(Double.NaN);
    complex0.ONE.add(0.99);
    Complex complex2 = complex1.multiply(Double.NaN);
    complex2.ZERO.cos();
    Complex complex3 = complex2.NaN.subtract(0.0);
    complex1.I.add(Double.NaN);
    Complex complex4 = complex0.NaN.subtract(complex1);
    complex4.ZERO.negate();
    complex0.nthRoot(577);
    Complex.valueOf(Double.NaN);
    complex3.divide(complex1);
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this / divisor)}.
 * Implements the definitional formula
 * <pre>
 *  <code>
 *    a + bi          ac + bd + (bc - ad)i
 *    ----------- = -------------------------
 *    c + di         c<sup>2</sup> + d<sup>2</sup>
 *  </code>
 * </pre>
 * but uses
 * <a href=""http://doi.acm.org/10.1145/1039813.1039814"">
 * prescaling of operands</a> to limit the effects of overflows and
 * underflows in the computation.
 * <br/>
 * {@code Infinite} and {@code NaN} values are handled according to the
 * following rules, applied in the order presented:
 * <ul>
 *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value
 *   in either part, {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code this} and {@code divisor} are both {@link #ZERO},
 *   {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code divisor} equals {@link #ZERO}, {@link #INF} is returned.
 *  </li>
 *  <li>If {@code this} and {@code divisor} are both infinite,
 *   {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or
 *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts
 *   infinite), {@link #ZERO} is returned.
 *  </li>
 *  <li>If {@code this} is infinite and {@code divisor} is finite,
 *   {@code NaN} values are returned in the parts of the result if the
 *   {@link java.lang.Double} rules applied to the definitional formula
 *   force {@code NaN} results.
 *  </li>
 * </ul>
 *
 * @param divisor Value by which this {@code Complex} is to be divided.
 * @return {@code this / divisor}.
 * @throws NullArgumentException if {@code divisor} is {@code null}.
 */"
"public Complex exp() {
    if (isNaN) {
        return NaN;
    }
    double expReal = FastMath.exp(real);
    return createComplex(expReal * FastMath.cos(imaginary), expReal * FastMath.sin(imaginary));
}","public void test03838() throws Throwable {
    Complex complex0 = new Complex(696.202035286);
    Complex complex1 = complex0.pow(696.202035286);
    Complex complex2 = complex0.ZERO.pow(13.07);
    Complex complex3 = complex1.I.acos();
    complex0.INF.divide(complex3);
    Complex complex4 = complex2.subtract(0.0);
    complex1.NaN.asin();
    Complex complex5 = complex1.ONE.negate();
    Complex complex6 = complex5.INF.log();
    Complex complex7 = complex6.createComplex(696.202035286, 13.07);
    complex7.I.toString();
    Complex complex8 = complex5.I.cos();
    Complex complex9 = complex1.pow(696.202035286);
    Complex complex10 = complex8.divide(0.0);
    Complex complex11 = complex0.multiply(complex9);
    complex10.sqrt1z();
    Complex complex12 = complex4.cosh();
    Complex complex13 = complex12.add(0.0);
    complex4.equals(complex2);
    complex2.log();
    complex11.nthRoot(37);
    complex13.exp();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/ExponentialFunction.html"" TARGET=""_top"">
 * exponential function</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#exp}, {@link java.lang.Math#cos}, and
 * {@link java.lang.Math#sin}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   exp(1 &plusmn; INFINITY i) = NaN + NaN i
 *   exp(INFINITY + i) = INFINITY + INFINITY i
 *   exp(-INFINITY + i) = 0 + 0i
 *   exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *  </code>
 * </pre>
 *
 * @return <code><i>e</i><sup>this</sup></code>.
 * @since 1.2
 */"
"public List<Complex> nthRoot(int n) {
    if (n <= 0) {
        throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N, n);
    }
    final List<Complex> result = new ArrayList<Complex>();
    if (isNaN) {
        result.add(NaN);
        return result;
    }
    if (isInfinite()) {
        result.add(INF);
        return result;
    }
    // nth root of abs -- faster / more accurate to use a solver here?
    final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);
    // Compute nth roots of complex number with k = 0, 1, ... n-1
    final double nthPhi = getArgument() / n;
    final double slice = 2 * FastMath.PI / n;
    double innerPart = nthPhi;
    for (int k = 0; k < n; k++) {
        // inner part
        final double realPart = nthRootOfAbs * FastMath.cos(innerPart);
        final double imaginaryPart = nthRootOfAbs * FastMath.sin(innerPart);
        result.add(createComplex(realPart, imaginaryPart));
        innerPart += slice;
    }
    return result;
}","public void test03939() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = complex0.INF.negate();
    Complex complex2 = new Complex(125.255577);
    Complex complex3 = Complex.ONE;
    Complex.valueOf(125.255577, Double.NaN);
    complex0.INF.pow(complex3);
    Complex complex4 = complex1.pow(complex2);
    complex4.ZERO.add(complex2);
    Complex complex5 = complex0.ONE.subtract(complex1);
    complex5.divide(0.0);
    Complex.valueOf(0.0, 836.3305);
    complex0.ZERO.pow(0.0);
    Complex complex6 = Complex.I;
    complex6.NaN.tanh();
    Complex complex7 = complex0.multiply(complex6);
    complex0.INF.tanh();
    // Undeclared exception!
    try {
        complex7.I.nthRoot((-472));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot compute nth root for null or negative n: -472
        //
        verifyException(""org.apache.commons.math.complex.Complex"", e);
    }
}","/**
 * Computes the n-th roots of this complex number.
 * The nth roots are defined by the formula:
 * <pre>
 *  <code>
 *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))
 *  </code>
 * </pre>
 * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}
 * are respectively the {@link #abs() modulus} and
 * {@link #getArgument() argument} of this complex number.
 * <br/>
 * If one or both parts of this complex number is NaN, a list with just
 * one element, {@link #NaN} is returned.
 * if neither part is NaN, but at least one part is infinite, the result
 * is a one-element list containing {@link #INF}.
 *
 * @param n Degree of root.
 * @return a List<Complex> of all {@code n}-th roots of {@code this}.
 * @throws NotPositiveException if {@code n <= 0}.
 * @since 2.0
 */"
"public double getImaginary() {
    return imaginary;
}","public void test04040() throws Throwable {
    Complex complex0 = Complex.INF;
    complex0.ONE.add(5265.00324922752);
    Complex complex1 = Complex.valueOf(1772.2415, 1772.2415);
    Complex complex2 = Complex.NaN;
    Complex complex3 = complex2.divide(complex0);
    complex1.ZERO.log();
    complex3.INF.negate();
    Complex complex4 = complex3.divide(complex0);
    complex4.ONE.add(complex1);
    complex0.subtract(complex2);
    complex0.conjugate();
    Complex complex5 = complex2.atan();
    complex5.ZERO.getArgument();
    complex5.ONE.sin();
    complex4.getField();
    complex4.tan();
    complex4.getImaginary();
}","/**
 * Access the imaginary part.
 *
 * @return the imaginary part.
 */"
"public List<Complex> nthRoot(int n) {
    if (n <= 0) {
        throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N, n);
    }
    final List<Complex> result = new ArrayList<Complex>();
    if (isNaN) {
        result.add(NaN);
        return result;
    }
    if (isInfinite()) {
        result.add(INF);
        return result;
    }
    // nth root of abs -- faster / more accurate to use a solver here?
    final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);
    // Compute nth roots of complex number with k = 0, 1, ... n-1
    final double nthPhi = getArgument() / n;
    final double slice = 2 * FastMath.PI / n;
    double innerPart = nthPhi;
    for (int k = 0; k < n; k++) {
        // inner part
        final double realPart = nthRootOfAbs * FastMath.cos(innerPart);
        final double imaginaryPart = nthRootOfAbs * FastMath.sin(innerPart);
        result.add(createComplex(realPart, imaginaryPart));
        innerPart += slice;
    }
    return result;
}","public void test04141() throws Throwable {
    Complex complex0 = Complex.I;
    complex0.I.hashCode();
    complex0.getReal();
    Complex complex1 = complex0.negate();
    Complex complex2 = complex1.tanh();
    complex0.INF.pow(complex1);
    Complex complex3 = complex1.createComplex(0.14982303977012634, 0.0);
    complex1.ONE.divide(0.14982303977012634);
    Complex complex4 = complex2.pow(0.0);
    Complex complex5 = complex4.ZERO.sqrt();
    complex2.hashCode();
    Complex complex6 = complex3.sin();
    Complex complex7 = complex6.sqrt();
    complex7.ONE.sinh();
    Complex complex8 = complex5.divide(2315.662);
    complex8.I.sinh();
    // Undeclared exception!
    try {
        complex5.nthRoot(0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot compute nth root for null or negative n: 0
        //
        verifyException(""org.apache.commons.math.complex.Complex"", e);
    }
}","/**
 * Computes the n-th roots of this complex number.
 * The nth roots are defined by the formula:
 * <pre>
 *  <code>
 *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))
 *  </code>
 * </pre>
 * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}
 * are respectively the {@link #abs() modulus} and
 * {@link #getArgument() argument} of this complex number.
 * <br/>
 * If one or both parts of this complex number is NaN, a list with just
 * one element, {@link #NaN} is returned.
 * if neither part is NaN, but at least one part is infinite, the result
 * is a one-element list containing {@link #INF}.
 *
 * @param n Degree of root.
 * @return a List<Complex> of all {@code n}-th roots of {@code this}.
 * @throws NotPositiveException if {@code n <= 0}.
 * @since 2.0
 */"
"public Complex divide(Complex divisor) throws NullArgumentException {
    MathUtils.checkNotNull(divisor);
    if (isNaN || divisor.isNaN) {
        return NaN;
    }
    if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) {
        return NaN;
    }
    if (divisor.isInfinite() && !isInfinite()) {
        return ZERO;
    }
    final double c = divisor.getReal();
    final double d = divisor.getImaginary();
    if (FastMath.abs(c) < FastMath.abs(d)) {
        double q = c / d;
        double denominator = c * q + d;
        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);
    } else {
        double q = d / c;
        double denominator = d * q + c;
        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
    }
}","public void test04242() throws Throwable {
    Complex complex0 = Complex.valueOf((-3939.65017517634));
    Complex complex1 = Complex.I;
    Complex.valueOf(1667.009475630678);
    complex0.I.multiply(complex1);
    Complex complex2 = complex0.sinh();
    complex2.INF.hashCode();
    complex2.divide(complex0);
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this / divisor)}.
 * Implements the definitional formula
 * <pre>
 *  <code>
 *    a + bi          ac + bd + (bc - ad)i
 *    ----------- = -------------------------
 *    c + di         c<sup>2</sup> + d<sup>2</sup>
 *  </code>
 * </pre>
 * but uses
 * <a href=""http://doi.acm.org/10.1145/1039813.1039814"">
 * prescaling of operands</a> to limit the effects of overflows and
 * underflows in the computation.
 * <br/>
 * {@code Infinite} and {@code NaN} values are handled according to the
 * following rules, applied in the order presented:
 * <ul>
 *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value
 *   in either part, {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code this} and {@code divisor} are both {@link #ZERO},
 *   {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code divisor} equals {@link #ZERO}, {@link #INF} is returned.
 *  </li>
 *  <li>If {@code this} and {@code divisor} are both infinite,
 *   {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or
 *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts
 *   infinite), {@link #ZERO} is returned.
 *  </li>
 *  <li>If {@code this} is infinite and {@code divisor} is finite,
 *   {@code NaN} values are returned in the parts of the result if the
 *   {@link java.lang.Double} rules applied to the definitional formula
 *   force {@code NaN} results.
 *  </li>
 * </ul>
 *
 * @param divisor Value by which this {@code Complex} is to be divided.
 * @return {@code this / divisor}.
 * @throws NullArgumentException if {@code divisor} is {@code null}.
 */"
"public Complex tan() {
    if (isNaN) {
        return NaN;
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = FastMath.cos(real2) + MathUtils.cosh(imaginary2);
    return createComplex(FastMath.sin(real2) / d, MathUtils.sinh(imaginary2) / d);
}","public void test04343() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.add(1618.51707594719);
    Complex complex2 = complex1.conjugate();
    Complex complex3 = complex1.tanh();
    complex2.multiply(1.2599210498948732);
    complex3.cos();
    complex3.log();
    complex2.tan();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Tangent.html"" TARGET=""_top"">
 * tangent</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   tan(1 &plusmn; INFINITY i) = 0 + NaN i
 *   tan(&plusmn;INFINITY + i) = NaN + NaN i
 *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *   tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i
 *  </code>
 * </pre>
 *
 * @return the tangent of {@code this}.
 * @since 1.2
 */"
"public Complex asin() {
    if (isNaN) {
        return NaN;
    }
    return sqrt1z().add(this.multiply(I)).log().multiply(I.negate());
}","public void test04444() throws Throwable {
    Complex complex0 = Complex.valueOf(1.0, 1.0);
    Complex complex1 = complex0.exp();
    Complex complex2 = complex1.add(1.0);
    Complex complex3 = complex0.log();
    Complex complex4 = complex3.cos();
    complex4.ZERO.tanh();
    Complex complex5 = complex4.cos();
    Complex complex6 = complex5.ONE.createComplex((-2932.941614), 0.0);
    Complex complex7 = complex6.ONE.subtract((-2932.941614));
    complex7.ZERO.multiply(complex1);
    complex3.NaN.add((-2932.941614));
    complex1.INF.createComplex(0.5000000000042687, 1.0);
    complex3.nthRoot(1);
    Complex complex8 = complex2.tan();
    complex8.NaN.tan();
    Complex complex9 = complex2.asin();
    complex3.asin();
    complex3.sin();
    complex4.sin();
    complex9.asin();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/InverseSine.html"" TARGET=""_top"">
 * inverse sine</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz))
 *  </code>
 * </pre>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite.
 *
 * @return the inverse sine of this complex number.
 * @since 1.2
 */"
"public Complex sqrt() {
    if (isNaN) {
        return NaN;
    }
    if (real == 0.0 && imaginary == 0.0) {
        return createComplex(0.0, 0.0);
    }
    double t = FastMath.sqrt((FastMath.abs(real) + abs()) / 2.0);
    if (real >= 0.0) {
        return createComplex(t, imaginary / (2.0 * t));
    } else {
        return createComplex(FastMath.abs(imaginary) / (2.0 * t), MathUtils.indicator(imaginary) * t);
    }
}","public void test04545() throws Throwable {
    Complex complex0 = new Complex((-1.0E-6), (-1.0E-6));
    Complex complex1 = complex0.ZERO.atan();
    complex0.NaN.hashCode();
    Complex complex2 = complex0.add((-1.0E-6));
    complex2.createComplex(0.0, (-1.0E-6));
    Complex complex3 = complex1.tan();
    Complex complex4 = complex3.INF.tanh();
    complex4.sin();
    complex4.NaN.cos();
    Complex.valueOf(0.0, (-1.0E-6));
    Complex complex5 = complex2.asin();
    Complex complex6 = complex5.divide(complex3);
    complex6.sqrt();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/SquareRoot.html"" TARGET=""_top"">
 * square root</a> of this complex number.
 * Implements the following algorithm to compute {@code sqrt(a + bi)}:
 * <ol><li>Let {@code t = sqrt((|a| + |a + bi|) / 2)}</li>
 * <li><pre>if {@code  a &#8805; 0} return {@code t + (b/2t)i}
 *  else return {@code |b|/2t + sign(b)t i }</pre></li>
 * </ol>
 * where <ul>
 * <li>{@code |a| = }{@link Math#abs}(a)</li>
 * <li>{@code |a + bi| = }{@link Complex#abs}(a + bi)</li>
 * <li>{@code sign(b) =  }{@link MathUtils#indicator}(b)
 * </ul>
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i
 *   sqrt(INFINITY + i) = INFINITY + 0i
 *   sqrt(-INFINITY + i) = 0 + INFINITY i
 *   sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i
 *   sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i
 *  </code>
 * </pre>
 *
 * @return the square root of {@code this}.
 * @since 1.2
 */"
"public Complex cosh() {
    if (isNaN) {
        return NaN;
    }
    return createComplex(MathUtils.cosh(real) * FastMath.cos(imaginary), MathUtils.sinh(real) * FastMath.sin(imaginary));
}","public void test04646() throws Throwable {
    Complex complex0 = Complex.ONE;
    complex0.getImaginary();
    Complex complex1 = complex0.subtract((-1010.64271470606));
    Complex complex2 = complex0.tan();
    complex2.I.readResolve();
    complex1.cosh();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/HyperbolicCosine.html"" TARGET=""_top"">
 * hyperbolic cosine</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i}
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   cosh(1 &plusmn; INFINITY i) = NaN + NaN i
 *   cosh(&plusmn;INFINITY + i) = INFINITY &plusmn; INFINITY i
 *   cosh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *  </code>
 * </pre>
 *
 * @return the hyperbolic cosine of this complex number.
 * @since 1.2
 */"
"public Complex acos() {
    if (isNaN) {
        return NaN;
    }
    return this.add(this.sqrt1z().multiply(I)).log().multiply(I.negate());
}","public void test04747() throws Throwable {
    Complex complex0 = new Complex(2642.074901291758, 2642.074901291758);
    Complex complex1 = new Complex((-4954.60382), (-4954.60382));
    complex0.I.subtract(complex1);
    Complex complex2 = Complex.ONE;
    complex1.INF.divide(0.333333333333333);
    Complex complex3 = complex0.subtract(complex2);
    Complex complex4 = complex3.pow((-4954.60382));
    complex1.abs();
    complex2.divide(complex1);
    complex1.divide((-371.7178401964143));
    complex4.acos();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/InverseCosine.html"" TARGET=""_top"">
 * inverse cosine</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))
 *  </code>
 * </pre>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite.
 *
 * @return the inverse cosine of this complex number.
 * @since 1.2
 */"
"public List<Complex> nthRoot(int n) {
    if (n <= 0) {
        throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N, n);
    }
    final List<Complex> result = new ArrayList<Complex>();
    if (isNaN) {
        result.add(NaN);
        return result;
    }
    if (isInfinite()) {
        result.add(INF);
        return result;
    }
    // nth root of abs -- faster / more accurate to use a solver here?
    final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);
    // Compute nth roots of complex number with k = 0, 1, ... n-1
    final double nthPhi = getArgument() / n;
    final double slice = 2 * FastMath.PI / n;
    double innerPart = nthPhi;
    for (int k = 0; k < n; k++) {
        // inner part
        final double realPart = nthRootOfAbs * FastMath.cos(innerPart);
        final double imaginaryPart = nthRootOfAbs * FastMath.sin(innerPart);
        result.add(createComplex(realPart, imaginaryPart));
        innerPart += slice;
    }
    return result;
}","public void test04848() throws Throwable {
    double double0 = 2.718281828459045;
    Complex complex0 = new Complex(2.718281828459045, 2.718281828459045);
    Complex complex1 = Complex.valueOf(2.718281828459045, 0.0);
    Complex complex2 = complex0.pow(complex1);
    Complex complex3 = Complex.valueOf(2.718281828459045);
    complex3.NaN.nthRoot(1827);
    complex0.toString();
    Complex complex4 = complex1.acos();
    complex2.ZERO.createComplex(0.0, 6.283185307179586);
    Complex.valueOf(2.718281828459045, 0.0);
    complex2.subtract(0.0);
    Complex complex5 = complex4.sinh();
    // Undeclared exception!
    try {
        complex5.ONE.nthRoot((-1));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot compute nth root for null or negative n: -1
        //
        verifyException(""org.apache.commons.math.complex.Complex"", e);
    }
}","/**
 * Computes the n-th roots of this complex number.
 * The nth roots are defined by the formula:
 * <pre>
 *  <code>
 *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))
 *  </code>
 * </pre>
 * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}
 * are respectively the {@link #abs() modulus} and
 * {@link #getArgument() argument} of this complex number.
 * <br/>
 * If one or both parts of this complex number is NaN, a list with just
 * one element, {@link #NaN} is returned.
 * if neither part is NaN, but at least one part is infinite, the result
 * is a one-element list containing {@link #INF}.
 *
 * @param n Degree of root.
 * @return a List<Complex> of all {@code n}-th roots of {@code this}.
 * @throws NotPositiveException if {@code n <= 0}.
 * @since 2.0
 */"
"public Complex subtract(double subtrahend) {
    if (isNaN || Double.isNaN(subtrahend)) {
        return NaN;
    }
    return createComplex(real - subtrahend, imaginary);
}","public void test04949() throws Throwable {
    Complex complex0 = Complex.valueOf(51.49210426066, 51.49210426066);
    complex0.getReal();
    Complex complex1 = Complex.valueOf(51.49210426066);
    complex0.acos();
    Complex.valueOf(51.49210426066);
    Complex complex2 = complex1.add(51.49210426066);
    complex2.pow(complex0);
    complex2.nthRoot(3505);
    complex0.subtract(51.49210426066);
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this - subtrahend)}.
 *
 * @param  subtrahend value to be subtracted from this {@code Complex}.
 * @return {@code this - subtrahend}.
 * @see #subtract(Complex)
 */"
"public Complex subtract(Complex subtrahend) throws NullArgumentException {
    MathUtils.checkNotNull(subtrahend);
    if (isNaN || subtrahend.isNaN) {
        return NaN;
    }
    return createComplex(real - subtrahend.getReal(), imaginary - subtrahend.getImaginary());
}","public void test05050() throws Throwable {
    Complex complex0 = Complex.INF;
    complex0.ZERO.tanh();
    Complex complex1 = complex0.subtract(795.423452);
    Complex complex2 = complex1.ZERO.add(complex0);
    complex1.cos();
    Complex complex3 = complex2.conjugate();
    complex1.NaN.divide(795.423452);
    complex1.log();
    Complex complex4 = complex2.NaN.tan();
    complex1.isNaN();
    Complex complex5 = complex3.tanh();
    complex5.ONE.getField();
    complex0.cosh();
    Complex.valueOf(795.423452);
    Complex.valueOf(0.0, 795.423452);
    complex4.subtract((-668.8104386325));
    complex0.subtract(complex3);
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this - subtrahend)}.
 * Uses the definitional formula
 * <pre>
 *  <code>
 *   (a + bi) - (c + di) = (a-c) + (b-d)i
 *  </code>
 * </pre>
 * If either {@code this} or {@code subtrahend} has a {@code NaN]} value in either part,
 * {@link #NaN} is returned; otherwise infinite and {@code NaN} values are
 * returned in the parts of the result according to the rules for
 * {@link java.lang.Double} arithmetic.
 *
 * @param  subtrahend value to be subtracted from this {@code Complex}.
 * @return {@code this - subtrahend}.
 * @throws NullArgumentException if {@code subtrahend} is {@code null}.
 */"
"public Complex sin() {
    if (isNaN) {
        return NaN;
    }
    return createComplex(FastMath.sin(real) * MathUtils.cosh(imaginary), FastMath.cos(real) * MathUtils.sinh(imaginary));
}","public void test05151() throws Throwable {
    Complex complex0 = Complex.I;
    complex0.ZERO.divide(0.0);
    Complex complex1 = complex0.tan();
    Complex complex2 = complex1.I.cosh();
    complex1.ZERO.getArgument();
    complex2.multiply((-1433.800400190024));
    Complex complex3 = complex1.subtract(complex0);
    complex3.ZERO.acos();
    Complex.valueOf((-1719.8124983792463), (-1719.8124983792463));
    complex1.sinh();
    complex3.atan();
    complex1.sin();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Sine.html"" TARGET=""_top"">
 * sine</a>
 * of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or {@code NaN} values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   sin(1 &plusmn; INFINITY i) = 1 &plusmn; INFINITY i
 *   sin(&plusmn;INFINITY + i) = NaN + NaN i
 *   sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *  </code>
 * </pre>
 *
 * @return the sine of this complex number.
 * @since 1.2
 */"
"public Complex conjugate() {
    if (isNaN) {
        return NaN;
    }
    return createComplex(real, -imaginary);
}","public void test05252() throws Throwable {
    Complex complex0 = new Complex(0.9999997615814209);
    complex0.NaN.exp();
    complex0.ONE.asin();
    complex0.conjugate();
}","/**
 * Return the conjugate of this complex number.
 * The conjugate of {@code a + bi} is {@code a - bi}.
 * <br/>
 * {@link #NaN} is returned if either the real or imaginary
 * part of this Complex number equals {@code Double.NaN}.
 * <br/>
 * If the imaginary part is infinite, and the real part is not
 * {@code NaN}, the returned value has infinite imaginary part
 * of the opposite sign, e.g. the conjugate of
 * {@code 1 + POSITIVE_INFINITY i} is {@code 1 - NEGATIVE_INFINITY i}.
 *
 * @return the conjugate of this Complex object.
 */"
"public Complex sqrt() {
    if (isNaN) {
        return NaN;
    }
    if (real == 0.0 && imaginary == 0.0) {
        return createComplex(0.0, 0.0);
    }
    double t = FastMath.sqrt((FastMath.abs(real) + abs()) / 2.0);
    if (real >= 0.0) {
        return createComplex(t, imaginary / (2.0 * t));
    } else {
        return createComplex(FastMath.abs(imaginary) / (2.0 * t), MathUtils.indicator(imaginary) * t);
    }
}","public void test05353() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = complex0.I.sin();
    Complex complex2 = complex0.tan();
    complex2.log();
    complex0.I.readResolve();
    Complex complex3 = Complex.valueOf(0.0, 0.0);
    Complex complex4 = complex0.ONE.divide(0.0);
    complex4.getField();
    Complex complex5 = complex3.tanh();
    Complex complex6 = complex5.I.pow((-329.233591427587));
    complex3.ZERO.negate();
    Complex complex7 = complex5.createComplex(0.0, 0.0);
    complex6.toString();
    complex7.ZERO.sinh();
    Complex complex8 = complex1.add(complex3);
    complex8.NaN.sin();
    complex6.sqrt();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/SquareRoot.html"" TARGET=""_top"">
 * square root</a> of this complex number.
 * Implements the following algorithm to compute {@code sqrt(a + bi)}:
 * <ol><li>Let {@code t = sqrt((|a| + |a + bi|) / 2)}</li>
 * <li><pre>if {@code  a &#8805; 0} return {@code t + (b/2t)i}
 *  else return {@code |b|/2t + sign(b)t i }</pre></li>
 * </ol>
 * where <ul>
 * <li>{@code |a| = }{@link Math#abs}(a)</li>
 * <li>{@code |a + bi| = }{@link Complex#abs}(a + bi)</li>
 * <li>{@code sign(b) =  }{@link MathUtils#indicator}(b)
 * </ul>
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i
 *   sqrt(INFINITY + i) = INFINITY + 0i
 *   sqrt(-INFINITY + i) = 0 + INFINITY i
 *   sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i
 *   sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i
 *  </code>
 * </pre>
 *
 * @return the square root of {@code this}.
 * @since 1.2
 */"
"public Complex cos() {
    if (isNaN) {
        return NaN;
    }
    return createComplex(FastMath.cos(real) * MathUtils.cosh(imaginary), -FastMath.sin(real) * MathUtils.sinh(imaginary));
}","public void test05454() throws Throwable {
    Complex complex0 = Complex.valueOf(0.0, 0.0);
    complex0.NaN.acos();
    complex0.ONE.sin();
    Complex complex1 = complex0.createComplex(0.0, 8.0E298);
    complex1.tan();
    Complex.valueOf((-744.0));
    Complex.valueOf(0.0, 1.0);
    complex0.cos();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Cosine.html"" TARGET=""_top"">
 * cosine</a>
 * of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   cos(1 &plusmn; INFINITY i) = 1 &#x2213; INFINITY i
 *   cos(&plusmn;INFINITY + i) = NaN + NaN i
 *   cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *  </code>
 * </pre>
 *
 * @return the cosine of this complex number.
 * @since 1.2
 */"
"public Complex log() {
    if (isNaN) {
        return NaN;
    }
    return createComplex(FastMath.log(abs()), FastMath.atan2(imaginary, real));
}","public void test05555() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = Complex.ZERO;
    complex1.abs();
    complex1.ONE.nthRoot(2097);
    complex0.INF.multiply(complex1);
    Complex complex2 = complex0.INF.exp();
    complex2.ZERO.hashCode();
    Complex complex3 = complex0.tanh();
    Complex complex4 = complex3.sqrt();
    Complex complex5 = complex0.sin();
    Complex complex6 = complex0.asin();
    complex6.hashCode();
    complex6.add(complex4);
    Complex complex7 = complex5.pow(complex2);
    complex7.NaN.cosh();
    complex0.log();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/NaturalLogarithm.html"" TARGET=""_top"">
 * natural logarithm</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   log(a + bi) = ln(|a + bi|) + arg(a + bi)i
 *  </code>
 * </pre>
 * where ln on the right hand side is {@link java.lang.Math#log},
 * {@code |a + bi|} is the modulus, {@link Complex#abs},  and
 * {@code arg(a + bi) = }{@link java.lang.Math#atan2}(b, a).
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   log(1 &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/2)i
 *   log(INFINITY + i) = INFINITY + 0i
 *   log(-INFINITY + i) = INFINITY + &pi;i
 *   log(INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/4)i
 *   log(-INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (3&pi;/4)i
 *   log(0 + 0i) = -INFINITY + 0i
 *  </code>
 * </pre>
 *
 * @return the value <code>ln &nbsp; this</code>, the natural logarithm
 * of {@code this}.
 * @since 1.2
 */"
"public Complex add(Complex addend) throws NullArgumentException {
    MathUtils.checkNotNull(addend);
    if (isNaN || addend.isNaN) {
        return NaN;
    }
    return createComplex(real + addend.getReal(), imaginary + addend.getImaginary());
}","public void test05656() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.sinh();
    complex1.toString();
    Complex complex2 = complex1.NaN.tanh();
    complex2.ONE.sinh();
    Complex complex3 = complex0.INF.tanh();
    complex0.nthRoot(2377);
    complex3.hashCode();
    complex0.getReal();
    Complex complex4 = Complex.valueOf(370.4486452049);
    Complex.valueOf(0.0);
    complex4.atan();
    complex3.add(complex1);
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this + addend)}.
 * Uses the definitional formula
 * <pre>
 *  <code>
 *   (a + bi) + (c + di) = (a+c) + (b+d)i
 *  </code>
 * </pre>
 * <br/>
 * If either {@code this} or {@code addend} has a {@code NaN} value in
 * either part, {@link #NaN} is returned; otherwise {@code Infinite}
 * and {@code NaN} values are returned in the parts of the result
 * according to the rules for {@link java.lang.Double} arithmetic.
 *
 * @param  addend Value to be added to this {@code Complex}.
 * @return {@code this + addend}.
 * @throws NullArgumentException if {@code addend} is {@code null}.
 */"
"public double getReal() {
    return real;
}","public void test05757() throws Throwable {
    Complex complex0 = Complex.valueOf(304.61329);
    Complex complex1 = complex0.log();
    complex0.NaN.asin();
    complex1.ZERO.nthRoot(2765);
    complex1.divide(304.61329);
    complex0.getReal();
}","/**
 * Access the real part.
 *
 * @return the real part.
 */"
"public Complex add(double addend) {
    if (isNaN || Double.isNaN(addend)) {
        return NaN;
    }
    return createComplex(real + addend, imaginary);
}","public void test05858() throws Throwable {
    Complex complex0 = new Complex(899.0, 899.0);
    Complex complex1 = new Complex(899.0, 899.0);
    Complex complex2 = complex0.multiply(complex1);
    complex2.INF.acos();
    complex0.getImaginary();
    complex0.asin();
    complex1.add(899.0);
}","/**
 * Returns a {@code Complex} whose value is {@code (this + addend)},
 * with {@code addend} interpreted as a real number.
 *
 * @param addend Value to be added to this {@code Complex}.
 * @return {@code this + addend}.
 * @see #add(Complex)
 */"
"public Complex log() {
    if (isNaN) {
        return NaN;
    }
    return createComplex(FastMath.log(abs()), FastMath.atan2(imaginary, real));
}","public void test05959() throws Throwable {
    Complex complex0 = Complex.valueOf(0.0, 0.19999954120254515);
    Complex complex1 = complex0.createComplex((-4676.564), 2421.231213461219);
    Complex complex2 = complex1.divide(complex0);
    complex1.NaN.nthRoot(1);
    complex2.ONE.toString();
    complex1.isInfinite();
    complex1.log();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/NaturalLogarithm.html"" TARGET=""_top"">
 * natural logarithm</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   log(a + bi) = ln(|a + bi|) + arg(a + bi)i
 *  </code>
 * </pre>
 * where ln on the right hand side is {@link java.lang.Math#log},
 * {@code |a + bi|} is the modulus, {@link Complex#abs},  and
 * {@code arg(a + bi) = }{@link java.lang.Math#atan2}(b, a).
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   log(1 &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/2)i
 *   log(INFINITY + i) = INFINITY + 0i
 *   log(-INFINITY + i) = INFINITY + &pi;i
 *   log(INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/4)i
 *   log(-INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (3&pi;/4)i
 *   log(0 + 0i) = -INFINITY + 0i
 *  </code>
 * </pre>
 *
 * @return the value <code>ln &nbsp; this</code>, the natural logarithm
 * of {@code this}.
 * @since 1.2
 */"
"public boolean isNaN() {
    return isNaN;
}","public void test06060() throws Throwable {
    Complex complex0 = Complex.valueOf(1956.6, 1956.6);
    Complex complex1 = complex0.INF.subtract(Double.NaN);
    Complex complex2 = complex0.tanh();
    complex1.add(255.48228475795665);
    Complex complex3 = Complex.valueOf(1956.6, 200.9600880936);
    Complex complex4 = complex3.I.createComplex(89.18336117, 2119.06574035);
    complex4.ZERO.multiply(complex2);
    complex0.toString();
    complex1.hashCode();
    complex2.isNaN();
}","/**
 * Checks whether either or both parts of this complex number is
 * {@code NaN}.
 *
 * @return true if either or both parts of this complex number is
 * {@code NaN}; false otherwise.
 */"
"public Complex add(Complex addend) throws NullArgumentException {
    MathUtils.checkNotNull(addend);
    if (isNaN || addend.isNaN) {
        return NaN;
    }
    return createComplex(real + addend.getReal(), imaginary + addend.getImaginary());
}","public void test06161() throws Throwable {
    Complex complex0 = new Complex(0.0);
    Complex complex1 = complex0.NaN.atan();
    Complex complex2 = complex0.ZERO.pow(complex1);
    Complex complex3 = complex2.ONE.log();
    complex0.ONE.divide(complex1);
    Complex complex4 = complex0.NaN.tan();
    complex4.ONE.tanh();
    complex0.abs();
    Complex complex5 = complex1.cosh();
    complex5.add(complex3);
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this + addend)}.
 * Uses the definitional formula
 * <pre>
 *  <code>
 *   (a + bi) + (c + di) = (a+c) + (b+d)i
 *  </code>
 * </pre>
 * <br/>
 * If either {@code this} or {@code addend} has a {@code NaN} value in
 * either part, {@link #NaN} is returned; otherwise {@code Infinite}
 * and {@code NaN} values are returned in the parts of the result
 * according to the rules for {@link java.lang.Double} arithmetic.
 *
 * @param  addend Value to be added to this {@code Complex}.
 * @return {@code this + addend}.
 * @throws NullArgumentException if {@code addend} is {@code null}.
 */"
"protected Complex createComplex(double realPart, double imaginaryPart) {
    return new Complex(realPart, imaginaryPart);
}","public void test06262() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.divide((-1.0));
    complex1.I.hashCode();
    complex1.INF.abs();
    Complex complex2 = complex0.NaN.asin();
    complex2.NaN.subtract(complex0);
    complex1.NaN.createComplex(0.0, Double.NaN);
    Complex complex3 = complex2.NaN.tanh();
    Complex complex4 = complex0.pow(complex1);
    complex4.getField();
    complex0.readResolve();
    complex3.createComplex(Double.POSITIVE_INFINITY, (-4154.983845027));
}","/**
 * Create a complex number given the real and imaginary parts.
 *
 * @param realPart Real part.
 * @param imaginaryPart Imaginary part.
 * @return a new complex number instance.
 * @since 1.2
 * @see #valueOf(double, double)
 */"
"public ComplexField getField() {
    return ComplexField.getInstance();
}","public void test06363() throws Throwable {
    Complex complex0 = new Complex(231.772612109326);
    Complex complex1 = Complex.NaN;
    Complex complex2 = complex1.INF.cosh();
    complex2.NaN.conjugate();
    Complex complex3 = complex0.I.pow((-2836.58));
    complex0.ZERO.pow(complex1);
    complex3.ONE.negate();
    complex0.abs();
    complex0.getImaginary();
    complex3.subtract(complex0);
    Complex complex4 = complex3.cosh();
    complex4.getField();
}","/**
 * {@inheritDoc}
 */"
"public Complex tan() {
    if (isNaN) {
        return NaN;
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = FastMath.cos(real2) + MathUtils.cosh(imaginary2);
    return createComplex(FastMath.sin(real2) / d, MathUtils.sinh(imaginary2) / d);
}","public void test06464() throws Throwable {
    Complex complex0 = Complex.valueOf(1179.18081, 1559.264433296705);
    Complex complex1 = complex0.ONE.cos();
    complex1.I.getArgument();
    complex0.getArgument();
    Complex complex2 = complex0.conjugate();
    Complex complex3 = complex2.I.tanh();
    Complex complex4 = complex0.I.createComplex(1.5707963267948966, 1179.18081);
    complex3.NaN.getField();
    Complex complex5 = Complex.I;
    Complex complex6 = Complex.valueOf(1179.18081);
    Complex complex7 = complex4.asin();
    complex1.getImaginary();
    complex6.sqrt();
    complex7.tan();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Tangent.html"" TARGET=""_top"">
 * tangent</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   tan(1 &plusmn; INFINITY i) = 0 + NaN i
 *   tan(&plusmn;INFINITY + i) = NaN + NaN i
 *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *   tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i
 *  </code>
 * </pre>
 *
 * @return the tangent of {@code this}.
 * @since 1.2
 */"
"public boolean isInfinite() {
    return isInfinite;
}","public void test06565() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = complex0.pow(1283.164);
    Complex.valueOf(1283.164, 1283.164);
    complex1.INF.acos();
    Complex complex2 = complex0.pow(complex1);
    complex0.tan();
    complex2.isInfinite();
}","/**
 * Checks whether either the real or imaginary part of this complex number
 * takes an infinite value (either {@code Double.POSITIVE_INFINITY} or
 * {@code Double.NEGATIVE_INFINITY}) and neither part
 * is {@code NaN}.
 *
 * @return true if one or both parts of this complex number are infinite
 * and neither part is {@code NaN}.
 */"
"public Complex multiply(Complex factor) throws NullArgumentException {
    MathUtils.checkNotNull(factor);
    if (isNaN || factor.isNaN) {
        return NaN;
    }
    if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(factor.real) || Double.isInfinite(factor.imaginary)) {
        // we don't use isInfinite() to avoid testing for NaN again
        return INF;
    }
    return createComplex(real * factor.real - imaginary * factor.imaginary, real * factor.imaginary + imaginary * factor.real);
}","public void test06666() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.ONE.acos();
    complex1.INF.divide((-448.3463));
    Complex complex2 = complex0.asin();
    Complex complex3 = complex2.INF.atan();
    complex3.I.exp();
    Complex complex4 = Complex.valueOf(770.0);
    Complex complex5 = complex4.I.asin();
    complex0.getField();
    complex3.getArgument();
    complex1.multiply(complex5);
}","/**
 * Returns a {@code Complex} whose value is {@code this * factor}.
 * Implements preliminary checks for {@code NaN} and infinity followed by
 * the definitional formula:
 * <pre>
 *  <code>
 *   (a + bi)(c + di) = (ac - bd) + (ad + bc)i
 *  </code>
 * </pre>
 * Returns {@link #NaN} if either {@code this} or {@code factor} has one or
 * more {@code NaN} parts.
 * <br/>
 * Returns {@link #INF} if neither {@code this} nor {@code factor} has one
 * or more {@code NaN} parts and if either {@code this} or {@code factor}
 * has one or more infinite parts (same result is returned regardless of
 * the sign of the components).
 * <br/>
 * Returns finite values in components of the result per the definitional
 * formula in all remaining cases.
 *
 * @param  factor value to be multiplied by this {@code Complex}.
 * @return {@code this * factor}.
 * @throws NullArgumentException if {@code factor} is {@code null}.
 */"
"public Complex sqrt1z() {
    return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();
}","public void test06767() throws Throwable {
    Complex complex0 = new Complex(1.997844754509471E-9, 1227.35957140178);
    Complex complex1 = complex0.ONE.atan();
    complex0.abs();
    Complex complex2 = complex0.asin();
    Complex complex3 = complex2.I.multiply((-2573.8717282));
    complex0.isInfinite();
    Complex complex4 = complex2.pow(complex0);
    Complex complex5 = complex1.cosh();
    Complex.valueOf(1.997844754509471E-9, (-2573.8717282));
    Complex complex6 = complex5.ONE.multiply(0.0);
    complex6.INF.conjugate();
    complex0.multiply(complex3);
    Complex complex7 = complex2.cos();
    Complex complex8 = complex7.exp();
    complex8.NaN.multiply((-2573.8717282));
    complex4.sqrt1z();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/SquareRoot.html"" TARGET=""_top"">
 * square root</a> of <code>1 - this<sup>2</sup></code> for this complex
 * number.
 * Computes the result directly as
 * {@code sqrt(ONE.subtract(z.multiply(z)))}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 *
 * @return the square root of <code>1 - this<sup>2</sup></code>.
 * @since 1.2
 */"
"public Complex exp() {
    if (isNaN) {
        return NaN;
    }
    double expReal = FastMath.exp(real);
    return createComplex(expReal * FastMath.cos(imaginary), expReal * FastMath.sin(imaginary));
}","public void test06868() throws Throwable {
    Complex complex0 = new Complex((-622.25), 1.0);
    complex0.exp();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/ExponentialFunction.html"" TARGET=""_top"">
 * exponential function</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#exp}, {@link java.lang.Math#cos}, and
 * {@link java.lang.Math#sin}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   exp(1 &plusmn; INFINITY i) = NaN + NaN i
 *   exp(INFINITY + i) = INFINITY + INFINITY i
 *   exp(-INFINITY + i) = 0 + 0i
 *   exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *  </code>
 * </pre>
 *
 * @return <code><i>e</i><sup>this</sup></code>.
 * @since 1.2
 */"
"public Complex atan() {
    if (isNaN) {
        return NaN;
    }
    return this.add(I).divide(I.subtract(this)).log().multiply(I.divide(createComplex(2.0, 0.0)));
}","public void test06969() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = Complex.INF;
    complex1.NaN.exp();
    Complex complex2 = complex0.subtract(complex1);
    complex2.ZERO.multiply(Double.POSITIVE_INFINITY);
    Complex complex3 = Complex.ONE;
    Complex complex4 = complex0.multiply(complex3);
    Complex complex5 = complex3.sinh();
    complex5.getArgument();
    Complex complex6 = complex4.negate();
    complex6.ONE.multiply(Double.POSITIVE_INFINITY);
    complex6.atan();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/InverseTangent.html"" TARGET=""_top"">
 * inverse tangent</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   atan(z) = (i/2) log((i + z)/(i - z))
 *  </code>
 * </pre>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite.
 *
 * @return the inverse tangent of this complex number
 * @since 1.2
 */"
"public Complex multiply(double factor) {
    if (isNaN || Double.isNaN(factor)) {
        return NaN;
    }
    if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(factor)) {
        // we don't use isInfinite() to avoid testing for NaN again
        return INF;
    }
    return createComplex(real * factor, imaginary * factor);
}","public void test07070() throws Throwable {
    Complex complex0 = new Complex(0.0);
    Complex complex1 = complex0.sqrt();
    complex1.I.tanh();
    complex1.ZERO.divide(0.0);
    complex1.tanh();
    complex1.toString();
    complex0.multiply(0.0);
}","/**
 * Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}
 * interpreted as a real number.
 *
 * @param  factor value to be multiplied by this {@code Complex}.
 * @return {@code this * factor}.
 * @see #multiply(Complex)
 */"
"public Complex tanh() {
    if (isNaN) {
        return NaN;
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = MathUtils.cosh(real2) + FastMath.cos(imaginary2);
    return createComplex(MathUtils.sinh(real2) / d, FastMath.sin(imaginary2) / d);
}","public void test07171() throws Throwable {
    Complex complex0 = new Complex(0.16666666666666666);
    complex0.I.createComplex(0.16666666666666666, 0.16666666666666666);
    Complex.valueOf(0.16666666666666666, 6.123233995736766E-17);
    Complex complex1 = complex0.add(0.0);
    complex1.tanh();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/HyperbolicTangent.html"" TARGET=""_top"">
 * hyperbolic tangent</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   tanh(1 &plusmn; INFINITY i) = NaN + NaN i
 *   tanh(&plusmn;INFINITY + i) = NaN + 0 i
 *   tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *   tanh(0 + (&pi;/2)i) = NaN + INFINITY i
 *  </code>
 * </pre>
 *
 * @return the hyperbolic tangent of {@code this}.
 * @since 1.2
 */"
"protected final Object readResolve() {
    return createComplex(real, imaginary);
}","public void test07272() throws Throwable {
    Complex complex0 = Complex.valueOf((-284.5248018489));
    complex0.ONE.createComplex((-119.711), (-284.5248018489));
    complex0.readResolve();
}","/**
 * Resolve the transient fields in a deserialized Complex Object.
 * Subclasses will need to override {@link #createComplex} to
 * deserialize properly.
 *
 * @return A Complex instance with all fields resolved.
 * @since 2.0
 */"
"public double getImaginary() {
    return imaginary;
}","public void test07373() throws Throwable {
    Complex complex0 = new Complex(2230.116, 6.283185307179586);
    complex0.getImaginary();
    complex0.NaN.negate();
    Complex complex1 = Complex.valueOf(1.0);
    complex1.conjugate();
    complex0.getImaginary();
}","/**
 * Access the imaginary part.
 *
 * @return the imaginary part.
 */"
"public Complex conjugate() {
    if (isNaN) {
        return NaN;
    }
    return createComplex(real, -imaginary);
}","public void test07474() throws Throwable {
    Complex complex0 = Complex.I;
    complex0.I.readResolve();
    Complex complex1 = complex0.cosh();
    Complex complex2 = complex0.add(complex1);
    Complex complex3 = complex1.negate();
    complex2.cosh();
    complex3.isNaN();
    complex0.asin();
    complex2.toString();
    complex0.conjugate();
}","/**
 * Return the conjugate of this complex number.
 * The conjugate of {@code a + bi} is {@code a - bi}.
 * <br/>
 * {@link #NaN} is returned if either the real or imaginary
 * part of this Complex number equals {@code Double.NaN}.
 * <br/>
 * If the imaginary part is infinite, and the real part is not
 * {@code NaN}, the returned value has infinite imaginary part
 * of the opposite sign, e.g. the conjugate of
 * {@code 1 + POSITIVE_INFINITY i} is {@code 1 - NEGATIVE_INFINITY i}.
 *
 * @return the conjugate of this Complex object.
 */"
"public Complex cosh() {
    if (isNaN) {
        return NaN;
    }
    return createComplex(MathUtils.cosh(real) * FastMath.cos(imaginary), MathUtils.sinh(real) * FastMath.sin(imaginary));
}","public void test07575() throws Throwable {
    Complex complex0 = Complex.NaN;
    complex0.asin();
    complex0.cosh();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/HyperbolicCosine.html"" TARGET=""_top"">
 * hyperbolic cosine</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i}
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   cosh(1 &plusmn; INFINITY i) = NaN + NaN i
 *   cosh(&plusmn;INFINITY + i) = INFINITY &plusmn; INFINITY i
 *   cosh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *  </code>
 * </pre>
 *
 * @return the hyperbolic cosine of this complex number.
 * @since 1.2
 */"
"public double getImaginary() {
    return imaginary;
}","public void test07676() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = complex0.log();
    Complex complex2 = complex1.conjugate();
    Complex complex3 = complex2.ZERO.subtract(complex1);
    Complex complex4 = complex3.INF.createComplex((-1917.2566645), (-1917.2566645));
    complex4.add(complex0);
    complex3.I.pow((-480.12940172));
    complex0.divide(complex2);
    complex3.getImaginary();
}","/**
 * Access the imaginary part.
 *
 * @return the imaginary part.
 */"
"public ComplexField getField() {
    return ComplexField.getInstance();
}","public void test07777() throws Throwable {
    Complex complex0 = new Complex(393.960084492, 393.960084492);
    complex0.NaN.abs();
    Complex complex1 = complex0.pow(393.960084492);
    complex0.toString();
    complex1.isNaN();
    Complex complex2 = complex1.divide(complex0);
    complex2.INF.getField();
    complex0.getImaginary();
    Complex complex3 = complex1.subtract(393.960084492);
    Complex.valueOf(0.0);
    complex1.getField();
    complex3.getField();
}","/**
 * {@inheritDoc}
 */"
"public Complex cos() {
    if (isNaN) {
        return NaN;
    }
    return createComplex(FastMath.cos(real) * MathUtils.cosh(imaginary), -FastMath.sin(real) * MathUtils.sinh(imaginary));
}","public void test07878() throws Throwable {
    Complex complex0 = Complex.INF;
    complex0.I.cosh();
    complex0.NaN.tan();
    complex0.add(0.0);
    Complex complex1 = complex0.subtract(0.0);
    complex1.INF.cosh();
    complex1.cos();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Cosine.html"" TARGET=""_top"">
 * cosine</a>
 * of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   cos(1 &plusmn; INFINITY i) = 1 &#x2213; INFINITY i
 *   cos(&plusmn;INFINITY + i) = NaN + NaN i
 *   cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *  </code>
 * </pre>
 *
 * @return the cosine of this complex number.
 * @since 1.2
 */"
"public Complex add(double addend) {
    if (isNaN || Double.isNaN(addend)) {
        return NaN;
    }
    return createComplex(real + addend, imaginary);
}","public void test07979() throws Throwable {
    Complex complex0 = new Complex((-877.79251249), 3085.66284);
    Complex complex1 = complex0.ONE.sqrt();
    Complex complex2 = complex1.I.conjugate();
    Complex complex3 = complex2.ONE.add(complex0);
    complex2.NaN.sqrt();
    complex0.cos();
    complex3.add((-82.968385));
}","/**
 * Returns a {@code Complex} whose value is {@code (this + addend)},
 * with {@code addend} interpreted as a real number.
 *
 * @param addend Value to be added to this {@code Complex}.
 * @return {@code this + addend}.
 * @see #add(Complex)
 */"
"@Override
public String toString() {
    return ""("" + real + "", "" + imaginary + "")"";
}","public void test08080() throws Throwable {
    Complex complex0 = Complex.valueOf((-670.0));
    Complex complex1 = Complex.NaN;
    Complex complex2 = complex0.I.add(complex1);
    complex0.asin();
    Complex complex3 = complex0.tan();
    complex3.INF.sin();
    complex1.ZERO.negate();
    Complex complex4 = complex3.log();
    complex2.pow(complex4);
    complex3.toString();
}","/**
 * {@inheritDoc}
 */"
"public Complex atan() {
    if (isNaN) {
        return NaN;
    }
    return this.add(I).divide(I.subtract(this)).log().multiply(I.divide(createComplex(2.0, 0.0)));
}","public void test08181() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = complex0.ZERO.cosh();
    complex1.I.pow(complex0);
    complex0.hashCode();
    complex0.abs();
    Complex complex2 = complex0.log();
    Complex complex3 = complex2.I.cos();
    complex3.nthRoot(1);
    complex0.atan();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/InverseTangent.html"" TARGET=""_top"">
 * inverse tangent</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   atan(z) = (i/2) log((i + z)/(i - z))
 *  </code>
 * </pre>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite.
 *
 * @return the inverse tangent of this complex number
 * @since 1.2
 */"
"public List<Complex> nthRoot(int n) {
    if (n <= 0) {
        throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N, n);
    }
    final List<Complex> result = new ArrayList<Complex>();
    if (isNaN) {
        result.add(NaN);
        return result;
    }
    if (isInfinite()) {
        result.add(INF);
        return result;
    }
    // nth root of abs -- faster / more accurate to use a solver here?
    final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);
    // Compute nth roots of complex number with k = 0, 1, ... n-1
    final double nthPhi = getArgument() / n;
    final double slice = 2 * FastMath.PI / n;
    double innerPart = nthPhi;
    for (int k = 0; k < n; k++) {
        // inner part
        final double realPart = nthRootOfAbs * FastMath.cos(innerPart);
        final double imaginaryPart = nthRootOfAbs * FastMath.sin(innerPart);
        result.add(createComplex(realPart, imaginaryPart));
        innerPart += slice;
    }
    return result;
}","public void test08282() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.NaN.multiply((-0.7853981633974483));
    complex0.ZERO.toString();
    complex0.sqrt1z();
    // Undeclared exception!
    try {
        complex1.nthRoot(0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot compute nth root for null or negative n: 0
        //
        verifyException(""org.apache.commons.math.complex.Complex"", e);
    }
}","/**
 * Computes the n-th roots of this complex number.
 * The nth roots are defined by the formula:
 * <pre>
 *  <code>
 *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))
 *  </code>
 * </pre>
 * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}
 * are respectively the {@link #abs() modulus} and
 * {@link #getArgument() argument} of this complex number.
 * <br/>
 * If one or both parts of this complex number is NaN, a list with just
 * one element, {@link #NaN} is returned.
 * if neither part is NaN, but at least one part is infinite, the result
 * is a one-element list containing {@link #INF}.
 *
 * @param n Degree of root.
 * @return a List<Complex> of all {@code n}-th roots of {@code this}.
 * @throws NotPositiveException if {@code n <= 0}.
 * @since 2.0
 */"
"public static Complex valueOf(double realPart, double imaginaryPart) {
    if (Double.isNaN(realPart) || Double.isNaN(imaginaryPart)) {
        return NaN;
    }
    return new Complex(realPart, imaginaryPart);
}","public void test08383() throws Throwable {
    Complex complex0 = Complex.I;
    complex0.I.multiply(0.5);
    complex0.toString();
    Complex.valueOf(0.11764700710773468, 0.11764700710773468);
}","/**
 * Create a complex number given the real and imaginary parts.
 *
 * @param realPart Real part.
 * @param imaginaryPart Imaginary part.
 * @return a Complex instance.
 */"
"public Complex divide(double divisor) {
    if (isNaN || Double.isNaN(divisor)) {
        return NaN;
    }
    if (divisor == 0d) {
        return NaN;
    }
    if (Double.isInfinite(divisor)) {
        return !isInfinite() ? ZERO : NaN;
    }
    return createComplex(real / divisor, imaginary / divisor);
}","public void test08484() throws Throwable {
    Complex complex0 = new Complex((-2289.0505632029985), (-36.04));
    Complex complex1 = new Complex(630.736923883764, (-2289.0505632029985));
    complex1.I.negate();
    complex1.NaN.divide(complex0);
    complex1.NaN.toString();
    Complex complex2 = complex0.subtract(complex1);
    complex2.isInfinite();
    complex2.divide(0.0);
}","/**
 * Returns a {@code Complex} whose value is {@code (this / divisor)},
 * with {@code divisor} interpreted as a real number.
 *
 * @param  divisor Value by which this {@code Complex} is to be divided.
 * @return {@code this / divisor}.
 * @see #divide(Complex)
 */"
"public Complex tanh() {
    if (isNaN) {
        return NaN;
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = MathUtils.cosh(real2) + FastMath.cos(imaginary2);
    return createComplex(MathUtils.sinh(real2) / d, FastMath.sin(imaginary2) / d);
}","public void test08585() throws Throwable {
    Complex complex0 = Complex.NaN;
    Complex complex1 = Complex.NaN;
    Complex complex2 = complex0.subtract(complex1);
    Complex complex3 = complex2.tan();
    complex3.subtract(complex2);
    complex3.abs();
    complex3.tanh();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/HyperbolicTangent.html"" TARGET=""_top"">
 * hyperbolic tangent</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link MathUtils#cosh} and {@link MathUtils#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   tanh(1 &plusmn; INFINITY i) = NaN + NaN i
 *   tanh(&plusmn;INFINITY + i) = NaN + 0 i
 *   tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *   tanh(0 + (&pi;/2)i) = NaN + INFINITY i
 *  </code>
 * </pre>
 *
 * @return the hyperbolic tangent of {@code this}.
 * @since 1.2
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Complex) {
        Complex c = (Complex) other;
        if (c.isNaN) {
            return isNaN;
        } else {
            return (real == c.real) && (imaginary == c.imaginary);
        }
    }
    return false;
}","public void test08686() throws Throwable {
    Complex complex0 = new Complex(0.3333333134651184, 2.0);
    Complex complex1 = complex0.sqrt1z();
    complex1.ZERO.getArgument();
    Complex complex2 = complex1.sqrt1z();
    complex1.I.atan();
    complex2.getArgument();
    Complex complex3 = complex1.multiply(0.0);
    complex3.I.sqrt1z();
    Complex complex4 = complex3.tanh();
    complex3.equals(complex4);
}","/**
 * Test for the equality of two Complex objects.
 * If both the real and imaginary parts of two complex numbers
 * are exactly the same, and neither is {@code Double.NaN}, the two
 * Complex objects are considered to be equal.
 * All {@code NaN} values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to {@code Double.NaN}, the complex number is equal to
 * {@code NaN}.
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if object is
 * {@code null}, not an instance of Complex, or not equal to this Complex
 * instance.
 */"
"public Complex pow(Complex x) throws NullArgumentException {
    MathUtils.checkNotNull(x);
    return this.log().multiply(x).exp();
}","public void test08787() throws Throwable {
    Complex complex0 = Complex.valueOf((-1361.4611261272), 0.0);
    Complex complex1 = Complex.NaN;
    complex0.pow(complex1);
}","/**
 * Returns of value of this complex number raised to the power of {@code x}.
 * Implements the formula:
 * <pre>
 *  <code>
 *   y<sup>x</sup> = exp(x&middot;log(y))
 *  </code>
 * </pre>
 * where {@code exp} and {@code log} are {@link #exp} and
 * {@link #log}, respectively.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite, or if {@code y}
 * equals {@link Complex#ZERO}.
 *
 * @param  x exponent to which this {@code Complex} is to be raised.
 * @return <code> this<sup>{@code x}</sup></code>.
 * @throws NullArgumentException if x is {@code null}.
 * @since 1.2
 */"
"public boolean isInfinite() {
    return isInfinite;
}","public void test08888() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = Complex.valueOf(1333.55);
    complex0.add(complex1);
    complex0.isInfinite();
}","/**
 * Checks whether either the real or imaginary part of this complex number
 * takes an infinite value (either {@code Double.POSITIVE_INFINITY} or
 * {@code Double.NEGATIVE_INFINITY}) and neither part
 * is {@code NaN}.
 *
 * @return true if one or both parts of this complex number are infinite
 * and neither part is {@code NaN}.
 */"
"public Complex add(Complex addend) throws NullArgumentException {
    MathUtils.checkNotNull(addend);
    if (isNaN || addend.isNaN) {
        return NaN;
    }
    return createComplex(real + addend.getReal(), imaginary + addend.getImaginary());
}","public void test08989() throws Throwable {
    Complex complex0 = new Complex(0.0, 0.0);
    complex0.I.cos();
    Complex complex1 = complex0.NaN.tanh();
    Complex complex2 = complex0.negate();
    complex2.getArgument();
    complex2.add(complex1);
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this + addend)}.
 * Uses the definitional formula
 * <pre>
 *  <code>
 *   (a + bi) + (c + di) = (a+c) + (b+d)i
 *  </code>
 * </pre>
 * <br/>
 * If either {@code this} or {@code addend} has a {@code NaN} value in
 * either part, {@link #NaN} is returned; otherwise {@code Infinite}
 * and {@code NaN} values are returned in the parts of the result
 * according to the rules for {@link java.lang.Double} arithmetic.
 *
 * @param  addend Value to be added to this {@code Complex}.
 * @return {@code this + addend}.
 * @throws NullArgumentException if {@code addend} is {@code null}.
 */"
"public Complex add(double addend) {
    if (isNaN || Double.isNaN(addend)) {
        return NaN;
    }
    return createComplex(real + addend, imaginary);
}","public void test09090() throws Throwable {
    Complex complex0 = Complex.ONE;
    complex0.ZERO.cos();
    complex0.add(171.057);
}","/**
 * Returns a {@code Complex} whose value is {@code (this + addend)},
 * with {@code addend} interpreted as a real number.
 *
 * @param addend Value to be added to this {@code Complex}.
 * @return {@code this + addend}.
 * @see #add(Complex)
 */"
"public double getArgument() {
    return FastMath.atan2(getImaginary(), getReal());
}","public void test09191() throws Throwable {
    Complex complex0 = Complex.I;
    complex0.getImaginary();
    complex0.abs();
    Complex complex1 = complex0.cosh();
    complex1.INF.subtract(1.0);
    complex1.getArgument();
}","/**
 * Compute the argument of this complex number.
 * The argument is the angle phi between the positive real axis and
 * the point representing this number in the complex plane.
 * The value returned is between -PI (not inclusive)
 * and PI (inclusive), with negative values returned for numbers with
 * negative imaginary parts.
 * <br/>
 * If either real or imaginary part (or both) is NaN, NaN is returned.
 * Infinite parts are handled as {@code Math.atan2} handles them,
 * essentially treating finite parts as zero in the presence of an
 * infinite coordinate and returning a multiple of pi/4 depending on
 * the signs of the infinite parts.
 * See the javadoc for {@code Math.atan2} for full details.
 *
 * @return the argument of {@code this}.
 */"
"public Complex subtract(Complex subtrahend) throws NullArgumentException {
    MathUtils.checkNotNull(subtrahend);
    if (isNaN || subtrahend.isNaN) {
        return NaN;
    }
    return createComplex(real - subtrahend.getReal(), imaginary - subtrahend.getImaginary());
}","public void test09292() throws Throwable {
    Complex complex0 = Complex.ZERO;
    try {
        complex0.INF.subtract((Complex) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // null is not allowed
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this - subtrahend)}.
 * Uses the definitional formula
 * <pre>
 *  <code>
 *   (a + bi) - (c + di) = (a-c) + (b-d)i
 *  </code>
 * </pre>
 * If either {@code this} or {@code subtrahend} has a {@code NaN]} value in either part,
 * {@link #NaN} is returned; otherwise infinite and {@code NaN} values are
 * returned in the parts of the result according to the rules for
 * {@link java.lang.Double} arithmetic.
 *
 * @param  subtrahend value to be subtracted from this {@code Complex}.
 * @return {@code this - subtrahend}.
 * @throws NullArgumentException if {@code subtrahend} is {@code null}.
 */"
"public Complex sqrt() {
    if (isNaN) {
        return NaN;
    }
    if (real == 0.0 && imaginary == 0.0) {
        return createComplex(0.0, 0.0);
    }
    double t = FastMath.sqrt((FastMath.abs(real) + abs()) / 2.0);
    if (real >= 0.0) {
        return createComplex(t, imaginary / (2.0 * t));
    } else {
        return createComplex(FastMath.abs(imaginary) / (2.0 * t), MathUtils.indicator(imaginary) * t);
    }
}","public void test09393() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = complex0.ONE.log();
    Complex complex2 = complex1.I.acos();
    complex0.INF.abs();
    Complex complex3 = complex0.tan();
    Complex.valueOf(Double.NaN, 1269.4028396762067);
    complex0.INF.pow((-2851.0975952218));
    complex3.getField();
    Complex complex4 = complex0.negate();
    complex4.I.log();
    complex4.divide(complex0);
    complex2.getField();
    complex3.divide(10.0);
    complex3.sqrt();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/SquareRoot.html"" TARGET=""_top"">
 * square root</a> of this complex number.
 * Implements the following algorithm to compute {@code sqrt(a + bi)}:
 * <ol><li>Let {@code t = sqrt((|a| + |a + bi|) / 2)}</li>
 * <li><pre>if {@code  a &#8805; 0} return {@code t + (b/2t)i}
 *  else return {@code |b|/2t + sign(b)t i }</pre></li>
 * </ol>
 * where <ul>
 * <li>{@code |a| = }{@link Math#abs}(a)</li>
 * <li>{@code |a + bi| = }{@link Complex#abs}(a + bi)</li>
 * <li>{@code sign(b) =  }{@link MathUtils#indicator}(b)
 * </ul>
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i
 *   sqrt(INFINITY + i) = INFINITY + 0i
 *   sqrt(-INFINITY + i) = 0 + INFINITY i
 *   sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i
 *   sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i
 *  </code>
 * </pre>
 *
 * @return the square root of {@code this}.
 * @since 1.2
 */"
"public Complex negate() {
    if (isNaN) {
        return NaN;
    }
    return createComplex(-real, -imaginary);
}","public void test09494() throws Throwable {
    Complex complex0 = new Complex(Double.NaN, Double.NaN);
    Complex complex1 = complex0.atan();
    complex1.negate();
}","/**
 * Returns a {@code Complex} whose value is {@code (-this)}.
 * Returns {@code NaN} if either real or imaginary
 * part of this Complex number equals {@code Double.NaN}.
 *
 * @return {@code -this}.
 */"
"public Complex exp() {
    if (isNaN) {
        return NaN;
    }
    double expReal = FastMath.exp(real);
    return createComplex(expReal * FastMath.cos(imaginary), expReal * FastMath.sin(imaginary));
}","public void test09595() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = complex0.INF.atan();
    Complex complex2 = complex0.ZERO.asin();
    Complex complex3 = complex0.negate();
    Complex complex4 = complex0.add(complex3);
    complex2.add(complex3);
    Complex complex5 = complex4.add(complex2);
    complex5.divide((-202.3));
    complex1.conjugate();
    complex4.exp();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/ExponentialFunction.html"" TARGET=""_top"">
 * exponential function</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#exp}, {@link java.lang.Math#cos}, and
 * {@link java.lang.Math#sin}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   exp(1 &plusmn; INFINITY i) = NaN + NaN i
 *   exp(INFINITY + i) = INFINITY + INFINITY i
 *   exp(-INFINITY + i) = 0 + 0i
 *   exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *  </code>
 * </pre>
 *
 * @return <code><i>e</i><sup>this</sup></code>.
 * @since 1.2
 */"
"public Complex add(double addend) {
    if (isNaN || Double.isNaN(addend)) {
        return NaN;
    }
    return createComplex(real + addend, imaginary);
}","public void test09696() throws Throwable {
    Complex complex0 = Complex.ZERO;
    complex0.toString();
    complex0.sqrt1z();
    complex0.add(Double.NaN);
}","/**
 * Returns a {@code Complex} whose value is {@code (this + addend)},
 * with {@code addend} interpreted as a real number.
 *
 * @param addend Value to be added to this {@code Complex}.
 * @return {@code this + addend}.
 * @see #add(Complex)
 */"
"public Complex divide(double divisor) {
    if (isNaN || Double.isNaN(divisor)) {
        return NaN;
    }
    if (divisor == 0d) {
        return NaN;
    }
    if (Double.isInfinite(divisor)) {
        return !isInfinite() ? ZERO : NaN;
    }
    return createComplex(real / divisor, imaginary / divisor);
}","public void test09797() throws Throwable {
    Complex complex0 = new Complex((-2304.035705716513), (-319.5240611725));
    complex0.divide((-319.5240611725));
}","/**
 * Returns a {@code Complex} whose value is {@code (this / divisor)},
 * with {@code divisor} interpreted as a real number.
 *
 * @param  divisor Value by which this {@code Complex} is to be divided.
 * @return {@code this / divisor}.
 * @see #divide(Complex)
 */"
"public double getArgument() {
    return FastMath.atan2(getImaginary(), getReal());
}","public void test09898() throws Throwable {
    Complex complex0 = Complex.I;
    complex0.getImaginary();
    complex0.abs();
    Complex complex1 = complex0.cosh();
    complex1.getArgument();
}","/**
 * Compute the argument of this complex number.
 * The argument is the angle phi between the positive real axis and
 * the point representing this number in the complex plane.
 * The value returned is between -PI (not inclusive)
 * and PI (inclusive), with negative values returned for numbers with
 * negative imaginary parts.
 * <br/>
 * If either real or imaginary part (or both) is NaN, NaN is returned.
 * Infinite parts are handled as {@code Math.atan2} handles them,
 * essentially treating finite parts as zero in the presence of an
 * infinite coordinate and returning a multiple of pi/4 depending on
 * the signs of the infinite parts.
 * See the javadoc for {@code Math.atan2} for full details.
 *
 * @return the argument of {@code this}.
 */"
"protected final Object readResolve() {
    return createComplex(real, imaginary);
}","public void test09999() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = complex0.negate();
    complex1.NaN.abs();
    Complex complex2 = complex1.add(complex0);
    complex2.atan();
    complex0.readResolve();
}","/**
 * Resolve the transient fields in a deserialized Complex Object.
 * Subclasses will need to override {@link #createComplex} to
 * deserialize properly.
 *
 * @return A Complex instance with all fields resolved.
 * @since 2.0
 */"
"public Complex subtract(double subtrahend) {
    if (isNaN || Double.isNaN(subtrahend)) {
        return NaN;
    }
    return createComplex(real - subtrahend, imaginary);
}","public void test100100() throws Throwable {
    Complex complex0 = new Complex(4500.020425281427, 4500.020425281427);
    complex0.INF.sqrt1z();
    complex0.subtract(4500.020425281427);
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this - subtrahend)}.
 *
 * @param  subtrahend value to be subtracted from this {@code Complex}.
 * @return {@code this - subtrahend}.
 * @see #subtract(Complex)
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Complex) {
        Complex c = (Complex) other;
        if (c.isNaN) {
            return isNaN;
        } else {
            return (real == c.real) && (imaginary == c.imaginary);
        }
    }
    return false;
}","public void test101101() throws Throwable {
    Complex complex0 = new Complex((-5243.2324));
    Complex complex1 = new Complex((-5243.2324));
    complex1.I.sinh();
    complex0.multiply(complex1);
    Object object0 = new Object();
    complex0.equals(object0);
}","/**
 * Test for the equality of two Complex objects.
 * If both the real and imaginary parts of two complex numbers
 * are exactly the same, and neither is {@code Double.NaN}, the two
 * Complex objects are considered to be equal.
 * All {@code NaN} values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to {@code Double.NaN}, the complex number is equal to
 * {@code NaN}.
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if object is
 * {@code null}, not an instance of Complex, or not equal to this Complex
 * instance.
 */"
"public Complex asin() {
    if (isNaN) {
        return NaN;
    }
    return sqrt1z().add(this.multiply(I)).log().multiply(I.negate());
}","public void test102102() throws Throwable {
    Complex complex0 = Complex.ONE;
    complex0.NaN.divide((-1284.45113536849));
    complex0.asin();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/InverseSine.html"" TARGET=""_top"">
 * inverse sine</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz))
 *  </code>
 * </pre>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite.
 *
 * @return the inverse sine of this complex number.
 * @since 1.2
 */"
"public Complex conjugate() {
    if (isNaN) {
        return NaN;
    }
    return createComplex(real, -imaginary);
}","public void test103103() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = complex0.tan();
    Complex complex2 = complex1.log();
    complex2.conjugate();
}","/**
 * Return the conjugate of this complex number.
 * The conjugate of {@code a + bi} is {@code a - bi}.
 * <br/>
 * {@link #NaN} is returned if either the real or imaginary
 * part of this Complex number equals {@code Double.NaN}.
 * <br/>
 * If the imaginary part is infinite, and the real part is not
 * {@code NaN}, the returned value has infinite imaginary part
 * of the opposite sign, e.g. the conjugate of
 * {@code 1 + POSITIVE_INFINITY i} is {@code 1 - NEGATIVE_INFINITY i}.
 *
 * @return the conjugate of this Complex object.
 */"
"public Complex pow(double x) {
    return this.log().multiply(x).exp();
}","public void test104104() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = complex0.add(0.0);
    complex1.I.pow(0.0);
    complex0.sqrt1z();
    complex0.pow((-472.86906330773));
}","/**
 * Returns of value of this complex number raised to the power of {@code x}.
 *
 * @param  x exponent to which this {@code Complex} is to be raised.
 * @return <code>this<sup>x</sup></code>.
 * @see #pow(Complex)
 */"
"public List<Complex> nthRoot(int n) {
    if (n <= 0) {
        throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N, n);
    }
    final List<Complex> result = new ArrayList<Complex>();
    if (isNaN) {
        result.add(NaN);
        return result;
    }
    if (isInfinite()) {
        result.add(INF);
        return result;
    }
    // nth root of abs -- faster / more accurate to use a solver here?
    final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);
    // Compute nth roots of complex number with k = 0, 1, ... n-1
    final double nthPhi = getArgument() / n;
    final double slice = 2 * FastMath.PI / n;
    double innerPart = nthPhi;
    for (int k = 0; k < n; k++) {
        // inner part
        final double realPart = nthRootOfAbs * FastMath.cos(innerPart);
        final double imaginaryPart = nthRootOfAbs * FastMath.sin(innerPart);
        result.add(createComplex(realPart, imaginaryPart));
        innerPart += slice;
    }
    return result;
}","public void test105105() throws Throwable {
    double double0 = (-3330.0);
    Complex complex0 = new Complex((-3330.0), 2597.88);
    Complex complex1 = Complex.INF;
    Complex complex2 = complex0.subtract(complex1);
    Complex complex3 = complex1.NaN.subtract(complex0);
    complex3.ONE.multiply(complex1);
    complex0.abs();
    Complex complex4 = Complex.valueOf((-3330.0));
    Complex complex5 = complex1.INF.divide(complex0);
    complex5.INF.multiply(complex1);
    complex1.divide(complex0);
    complex2.exp();
    complex3.I.tanh();
    Complex complex6 = complex0.acos();
    complex6.divide(complex1);
    complex1.ONE.tan();
    Complex complex7 = complex3.add(complex2);
    complex7.I.tanh();
    complex4.conjugate();
    complex6.ONE.log();
    double double1 = (-2.647648);
    Complex complex8 = Complex.valueOf((-2.647648), (-1645.2035586420611));
    complex8.I.negate();
    int int0 = (-1968);
    // Undeclared exception!
    try {
        complex2.nthRoot((-1968));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot compute nth root for null or negative n: -1,968
        //
        verifyException(""org.apache.commons.math.complex.Complex"", e);
    }
}","/**
 * Computes the n-th roots of this complex number.
 * The nth roots are defined by the formula:
 * <pre>
 *  <code>
 *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))
 *  </code>
 * </pre>
 * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}
 * are respectively the {@link #abs() modulus} and
 * {@link #getArgument() argument} of this complex number.
 * <br/>
 * If one or both parts of this complex number is NaN, a list with just
 * one element, {@link #NaN} is returned.
 * if neither part is NaN, but at least one part is infinite, the result
 * is a one-element list containing {@link #INF}.
 *
 * @param n Degree of root.
 * @return a List<Complex> of all {@code n}-th roots of {@code this}.
 * @throws NotPositiveException if {@code n <= 0}.
 * @since 2.0
 */"
"public Complex sqrt1z() {
    return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();
}","public void test106106() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.I.acos();
    Complex complex2 = complex1.INF.createComplex(924.0048839990227, (-2511.0));
    Complex complex3 = complex0.NaN.asin();
    Complex complex4 = complex3.sinh();
    Complex complex5 = complex4.ZERO.pow(5.613391611251);
    Complex complex6 = complex3.INF.tanh();
    complex1.abs();
    complex4.INF.subtract(2.85040095144011776E17);
    Complex complex7 = complex3.NaN.subtract(complex1);
    complex0.equals("""");
    Complex.valueOf(Double.NaN);
    Complex complex8 = complex1.I.cosh();
    complex1.pow(1.0);
    Complex complex9 = complex7.sinh();
    complex0.subtract(complex2);
    complex6.sin();
    complex6.negate();
    Complex complex10 = complex7.add(complex5);
    complex8.tan();
    Complex complex11 = complex9.subtract(complex10);
    complex11.sqrt1z();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/SquareRoot.html"" TARGET=""_top"">
 * square root</a> of <code>1 - this<sup>2</sup></code> for this complex
 * number.
 * Computes the result directly as
 * {@code sqrt(ONE.subtract(z.multiply(z)))}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 *
 * @return the square root of <code>1 - this<sup>2</sup></code>.
 * @since 1.2
 */"
"public List<Complex> nthRoot(int n) {
    if (n <= 0) {
        throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N, n);
    }
    final List<Complex> result = new ArrayList<Complex>();
    if (isNaN) {
        result.add(NaN);
        return result;
    }
    if (isInfinite()) {
        result.add(INF);
        return result;
    }
    // nth root of abs -- faster / more accurate to use a solver here?
    final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);
    // Compute nth roots of complex number with k = 0, 1, ... n-1
    final double nthPhi = getArgument() / n;
    final double slice = 2 * FastMath.PI / n;
    double innerPart = nthPhi;
    for (int k = 0; k < n; k++) {
        // inner part
        final double realPart = nthRootOfAbs * FastMath.cos(innerPart);
        final double imaginaryPart = nthRootOfAbs * FastMath.sin(innerPart);
        result.add(createComplex(realPart, imaginaryPart));
        innerPart += slice;
    }
    return result;
}","public void test107107() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = new Complex(125.255577);
    Complex complex2 = Complex.ONE;
    Complex.valueOf(125.255577, Double.NaN);
    complex0.INF.pow(complex2);
    complex0.pow(complex1);
    Complex complex3 = complex0.ONE.subtract(complex0);
    complex3.divide(0.0);
    Complex.valueOf(0.0, 836.3305);
    complex0.ZERO.pow(0.0);
    Complex complex4 = Complex.I;
    complex4.NaN.tanh();
    Complex complex5 = complex0.multiply(complex4);
    complex0.INF.tanh();
    // Undeclared exception!
    try {
        complex5.I.nthRoot((-472));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot compute nth root for null or negative n: -472
        //
        verifyException(""org.apache.commons.math.complex.Complex"", e);
    }
}","/**
 * Computes the n-th roots of this complex number.
 * The nth roots are defined by the formula:
 * <pre>
 *  <code>
 *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))
 *  </code>
 * </pre>
 * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}
 * are respectively the {@link #abs() modulus} and
 * {@link #getArgument() argument} of this complex number.
 * <br/>
 * If one or both parts of this complex number is NaN, a list with just
 * one element, {@link #NaN} is returned.
 * if neither part is NaN, but at least one part is infinite, the result
 * is a one-element list containing {@link #INF}.
 *
 * @param n Degree of root.
 * @return a List<Complex> of all {@code n}-th roots of {@code this}.
 * @throws NotPositiveException if {@code n <= 0}.
 * @since 2.0
 */"
"public List<Complex> nthRoot(int n) {
    if (n <= 0) {
        throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N, n);
    }
    final List<Complex> result = new ArrayList<Complex>();
    if (isNaN) {
        result.add(NaN);
        return result;
    }
    if (isInfinite()) {
        result.add(INF);
        return result;
    }
    // nth root of abs -- faster / more accurate to use a solver here?
    final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);
    // Compute nth roots of complex number with k = 0, 1, ... n-1
    final double nthPhi = getArgument() / n;
    final double slice = 2 * FastMath.PI / n;
    double innerPart = nthPhi;
    for (int k = 0; k < n; k++) {
        // inner part
        final double realPart = nthRootOfAbs * FastMath.cos(innerPart);
        final double imaginaryPart = nthRootOfAbs * FastMath.sin(innerPart);
        result.add(createComplex(realPart, imaginaryPart));
        innerPart += slice;
    }
    return result;
}","public void test108108() throws Throwable {
    Complex complex0 = Complex.NaN;
    Complex complex1 = Complex.I;
    Complex complex2 = complex0.divide(complex1);
    complex2.INF.getField();
    Complex complex3 = complex0.multiply(1.3245471311735498E-8);
    Complex complex4 = Complex.valueOf(0.0);
    complex4.ZERO.negate();
    complex0.I.log();
    Complex complex5 = complex3.negate();
    complex1.ONE.abs();
    Complex complex6 = complex0.sin();
    Complex complex7 = Complex.valueOf(1.3245471311735498E-8, 1.3245471311735498E-8);
    complex0.equals(complex7);
    complex6.negate();
    complex2.hashCode();
    complex6.pow(1.3245471311735498E-8);
    complex5.sinh();
    // Undeclared exception!
    try {
        complex3.nthRoot(0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot compute nth root for null or negative n: 0
        //
        verifyException(""org.apache.commons.math.complex.Complex"", e);
    }
}","/**
 * Computes the n-th roots of this complex number.
 * The nth roots are defined by the formula:
 * <pre>
 *  <code>
 *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))
 *  </code>
 * </pre>
 * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}
 * are respectively the {@link #abs() modulus} and
 * {@link #getArgument() argument} of this complex number.
 * <br/>
 * If one or both parts of this complex number is NaN, a list with just
 * one element, {@link #NaN} is returned.
 * if neither part is NaN, but at least one part is infinite, the result
 * is a one-element list containing {@link #INF}.
 *
 * @param n Degree of root.
 * @return a List<Complex> of all {@code n}-th roots of {@code this}.
 * @throws NotPositiveException if {@code n <= 0}.
 * @since 2.0
 */"
"public boolean isInfinite() {
    return isInfinite;
}","public void test109109() throws Throwable {
    Complex complex0 = new Complex((-2595.188104221), (-2595.188104221));
    complex0.ZERO.readResolve();
    complex0.readResolve();
    Complex complex1 = Complex.valueOf(0.0, (-2595.188104221));
    Complex complex2 = Complex.valueOf(0.0, 0.0);
    Complex complex3 = complex2.ONE.cosh();
    Complex complex4 = complex2.add(0.0);
    complex4.acos();
    complex4.INF.asin();
    Complex complex5 = complex2.createComplex((-2595.188104221), (-1077.1));
    complex5.divide(complex2);
    complex0.getReal();
    Complex complex6 = complex0.sinh();
    complex6.INF.multiply((-2595.188104221));
    Complex complex7 = complex1.sqrt1z();
    Complex.valueOf(0.0);
    complex3.cos();
    complex2.NaN.abs();
    Complex.valueOf((-2595.188104221));
    Complex complex8 = complex7.subtract(complex2);
    complex3.cos();
    Complex complex9 = complex6.sinh();
    complex9.createComplex(0.041666666666621166, 892.28875252206);
    Complex complex10 = complex8.sinh();
    complex9.subtract(Double.NaN);
    Complex complex11 = new Complex(0.0);
    complex3.divide(complex11);
    Complex complex12 = complex6.divide(0.0);
    complex3.divide(complex12);
    complex11.acos();
    complex3.getField();
    complex10.isInfinite();
}","/**
 * Checks whether either the real or imaginary part of this complex number
 * takes an infinite value (either {@code Double.POSITIVE_INFINITY} or
 * {@code Double.NEGATIVE_INFINITY}) and neither part
 * is {@code NaN}.
 *
 * @return true if one or both parts of this complex number are infinite
 * and neither part is {@code NaN}.
 */"
"public List<Complex> nthRoot(int n) {
    if (n <= 0) {
        throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N, n);
    }
    final List<Complex> result = new ArrayList<Complex>();
    if (isNaN) {
        result.add(NaN);
        return result;
    }
    if (isInfinite()) {
        result.add(INF);
        return result;
    }
    // nth root of abs -- faster / more accurate to use a solver here?
    final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);
    // Compute nth roots of complex number with k = 0, 1, ... n-1
    final double nthPhi = getArgument() / n;
    final double slice = 2 * FastMath.PI / n;
    double innerPart = nthPhi;
    for (int k = 0; k < n; k++) {
        // inner part
        final double realPart = nthRootOfAbs * FastMath.cos(innerPart);
        final double imaginaryPart = nthRootOfAbs * FastMath.sin(innerPart);
        result.add(createComplex(realPart, imaginaryPart));
        innerPart += slice;
    }
    return result;
}","public void test110110() throws Throwable {
    Complex complex0 = new Complex(1015.7, Double.POSITIVE_INFINITY);
    complex0.NaN.pow(0.16666666666666666);
    Complex complex1 = complex0.sin();
    Complex complex2 = complex0.exp();
    complex2.ZERO.cos();
    Complex complex3 = complex0.pow(complex1);
    complex0.INF.cosh();
    Complex complex4 = complex3.tan();
    complex4.NaN.getArgument();
    Complex complex5 = complex1.createComplex((-50.36), Double.POSITIVE_INFINITY);
    Complex complex6 = complex1.conjugate();
    Complex complex7 = complex3.multiply(1015.7);
    complex7.NaN.sqrt();
    Complex complex8 = complex7.INF.acos();
    complex3.abs();
    Complex complex9 = complex5.asin();
    complex9.NaN.cos();
    Complex.valueOf(Double.NaN, 0.0);
    complex0.ONE.asin();
    complex6.nthRoot(47);
    complex0.toString();
    complex8.exp();
    complex1.conjugate();
    // Undeclared exception!
    try {
        complex5.nthRoot((-1));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot compute nth root for null or negative n: -1
        //
        verifyException(""org.apache.commons.math.complex.Complex"", e);
    }
}","/**
 * Computes the n-th roots of this complex number.
 * The nth roots are defined by the formula:
 * <pre>
 *  <code>
 *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))
 *  </code>
 * </pre>
 * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}
 * are respectively the {@link #abs() modulus} and
 * {@link #getArgument() argument} of this complex number.
 * <br/>
 * If one or both parts of this complex number is NaN, a list with just
 * one element, {@link #NaN} is returned.
 * if neither part is NaN, but at least one part is infinite, the result
 * is a one-element list containing {@link #INF}.
 *
 * @param n Degree of root.
 * @return a List<Complex> of all {@code n}-th roots of {@code this}.
 * @throws NotPositiveException if {@code n <= 0}.
 * @since 2.0
 */"
"public boolean isNaN() {
    return isNaN;
}","public void test111111() throws Throwable {
    Complex complex0 = Complex.valueOf(0.003, 0.003);
    Complex complex1 = complex0.sqrt();
    complex1.INF.pow(0.0);
    Complex complex2 = Complex.valueOf(0.003);
    complex0.INF.divide(0.0);
    Complex complex3 = complex1.INF.atan();
    Complex complex4 = complex0.log();
    Complex complex5 = complex3.INF.sqrt1z();
    Complex complex6 = Complex.valueOf(0.003);
    complex1.toString();
    complex3.ZERO.multiply(complex2);
    Complex complex7 = complex3.sinh();
    complex7.asin();
    complex6.toString();
    Complex complex8 = complex6.divide(complex0);
    complex5.subtract(0.0);
    Complex complex9 = complex3.pow(complex6);
    complex9.multiply(complex1);
    complex9.INF.sin();
    complex8.createComplex(0.0, 1776.746099015292);
    complex4.isNaN();
}","/**
 * Checks whether either or both parts of this complex number is
 * {@code NaN}.
 *
 * @return true if either or both parts of this complex number is
 * {@code NaN}; false otherwise.
 */"
"public Complex conjugate() {
    if (isNaN) {
        return NaN;
    }
    return createComplex(real, -imaginary);
}","public void test112112() throws Throwable {
    Complex complex0 = Complex.NaN;
    complex0.ONE.getArgument();
    Complex complex1 = complex0.divide(0.2);
    Complex complex2 = complex1.INF.cos();
    complex2.readResolve();
    Complex complex3 = complex0.pow(complex1);
    complex3.subtract(complex2);
    Complex complex4 = Complex.valueOf(0.2);
    Complex complex5 = complex4.ONE.sqrt1z();
    complex5.ZERO.log();
    complex5.ZERO.sin();
    Complex complex6 = Complex.valueOf(0.0, (-642.02215));
    complex2.ZERO.multiply(complex0);
    Complex complex7 = complex2.add(complex0);
    complex7.I.abs();
    Complex complex8 = complex7.INF.createComplex((-1211.0), 0.0);
    complex6.toString();
    Complex complex9 = complex6.pow(6.283185307179586);
    complex9.INF.abs();
    Complex complex10 = Complex.valueOf((-2161.582167348243), 1772.9070940932968);
    Complex complex11 = complex10.ZERO.createComplex((-1211.0), Double.POSITIVE_INFINITY);
    Complex complex12 = complex6.NaN.pow(complex0);
    Complex complex13 = complex12.ONE.cos();
    Object object0 = complex3.readResolve();
    complex1.equals(object0);
    Complex complex14 = complex8.conjugate();
    complex14.divide(1766.39814103);
    complex11.sqrt();
    complex4.subtract(1772.9070940932968);
    complex13.subtract(0.2);
    complex2.conjugate();
}","/**
 * Return the conjugate of this complex number.
 * The conjugate of {@code a + bi} is {@code a - bi}.
 * <br/>
 * {@link #NaN} is returned if either the real or imaginary
 * part of this Complex number equals {@code Double.NaN}.
 * <br/>
 * If the imaginary part is infinite, and the real part is not
 * {@code NaN}, the returned value has infinite imaginary part
 * of the opposite sign, e.g. the conjugate of
 * {@code 1 + POSITIVE_INFINITY i} is {@code 1 - NEGATIVE_INFINITY i}.
 *
 * @return the conjugate of this Complex object.
 */"
"public List<Complex> nthRoot(int n) {
    if (n <= 0) {
        throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N, n);
    }
    final List<Complex> result = new ArrayList<Complex>();
    if (isNaN) {
        result.add(NaN);
        return result;
    }
    if (isInfinite()) {
        result.add(INF);
        return result;
    }
    // nth root of abs -- faster / more accurate to use a solver here?
    final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);
    // Compute nth roots of complex number with k = 0, 1, ... n-1
    final double nthPhi = getArgument() / n;
    final double slice = 2 * FastMath.PI / n;
    double innerPart = nthPhi;
    for (int k = 0; k < n; k++) {
        // inner part
        final double realPart = nthRootOfAbs * FastMath.cos(innerPart);
        final double imaginaryPart = nthRootOfAbs * FastMath.sin(innerPart);
        result.add(createComplex(realPart, imaginaryPart));
        innerPart += slice;
    }
    return result;
}","public void test113113() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = complex0.I.sin();
    complex1.INF.divide(complex0);
    complex1.I.abs();
    Complex complex2 = complex1.ONE.tan();
    complex2.toString();
    complex0.multiply(0.0);
    complex1.getArgument();
    Complex complex3 = complex1.createComplex(0.0, 1.5707963267948966);
    Complex complex4 = complex1.multiply((-1837.5053));
    complex1.getField();
    Complex complex5 = complex4.INF.cos();
    complex3.pow(0.0);
    Complex complex6 = complex2.negate();
    Complex complex7 = Complex.valueOf(0.0, 0.0);
    Complex complex8 = complex6.ONE.multiply(complex7);
    complex7.multiply((-1.0000003035640237));
    complex8.NaN.cosh();
    complex3.INF.pow(complex5);
    complex8.cos();
    // Undeclared exception!
    try {
        complex6.nthRoot(0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot compute nth root for null or negative n: 0
        //
        verifyException(""org.apache.commons.math.complex.Complex"", e);
    }
}","/**
 * Computes the n-th roots of this complex number.
 * The nth roots are defined by the formula:
 * <pre>
 *  <code>
 *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))
 *  </code>
 * </pre>
 * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}
 * are respectively the {@link #abs() modulus} and
 * {@link #getArgument() argument} of this complex number.
 * <br/>
 * If one or both parts of this complex number is NaN, a list with just
 * one element, {@link #NaN} is returned.
 * if neither part is NaN, but at least one part is infinite, the result
 * is a one-element list containing {@link #INF}.
 *
 * @param n Degree of root.
 * @return a List<Complex> of all {@code n}-th roots of {@code this}.
 * @throws NotPositiveException if {@code n <= 0}.
 * @since 2.0
 */"
"public double getImaginary() {
    return imaginary;
}","public void test114114() throws Throwable {
    Complex complex0 = Complex.ONE;
    complex0.toString();
    Complex complex1 = complex0.NaN.tan();
    Complex complex2 = complex1.I.pow(complex0);
    complex2.INF.hashCode();
    Complex complex3 = complex0.pow((-1.0));
    Complex complex4 = complex3.INF.tanh();
    complex4.NaN.sqrt1z();
    complex3.isInfinite();
    complex3.atan();
    complex4.getImaginary();
}","/**
 * Access the imaginary part.
 *
 * @return the imaginary part.
 */"
"@Override
public String toString() {
    return ""("" + real + "", "" + imaginary + "")"";
}","public void test115116() throws Throwable {
    Complex complex0 = new Complex(3294198.0, 3294198.0);
    Complex complex1 = complex0.I.conjugate();
    Complex complex2 = complex0.ONE.divide(3294198.0);
    List<Complex> list0 = complex2.ONE.nthRoot(3814);
    Complex complex3 = Complex.NaN;
    Complex complex4 = complex2.cos();
    Complex complex5 = complex4.NaN.add(8.0E298);
    Complex complex6 = complex0.subtract(complex3);
    complex3.isNaN();
    complex2.isInfinite();
    complex6.abs();
    complex2.abs();
    Complex complex7 = complex1.negate();
    Complex complex8 = complex0.ONE.sqrt1z();
    String string0 = complex7.ZERO.toString();
    assertEquals(""(0.0, 0.0)"", string0);
}","/**
 * {@inheritDoc}
 */"
"public double getImaginary() {
    return imaginary;
}","public void test115117() throws Throwable {
    Complex complex0 = new Complex(3294198.0, 3294198.0);
    Complex complex1 = complex0.I.conjugate();
    Complex complex2 = complex0.ONE.divide(3294198.0);
    List<Complex> list0 = complex2.ONE.nthRoot(3814);
    Complex complex3 = Complex.NaN;
    Complex complex4 = complex2.cos();
    Complex complex5 = complex4.NaN.add(8.0E298);
    Complex complex6 = complex0.subtract(complex3);
    complex3.isNaN();
    complex2.isInfinite();
    complex6.abs();
    complex2.abs();
    Complex complex7 = complex1.negate();
    Complex complex8 = complex0.ONE.sqrt1z();
    String string0 = complex7.ZERO.toString();
    complex6.nthRoot(3814);
    Complex complex9 = Complex.I;
    complex3.ZERO.add(3294198.0);
    complex3.I.add(2.0);
    complex4.subtract(complex9);
    assertEquals(-0.0, complex4.getImaginary(), 0.01);
}","/**
 * Access the imaginary part.
 *
 * @return the imaginary part.
 */"
"public double getReal() {
    return real;
}","public void test115118() throws Throwable {
    Complex complex0 = new Complex(3294198.0, 3294198.0);
    Complex complex1 = complex0.I.conjugate();
    Complex complex2 = complex0.ONE.divide(3294198.0);
    List<Complex> list0 = complex2.ONE.nthRoot(3814);
    Complex complex3 = Complex.NaN;
    Complex complex4 = complex2.cos();
    Complex complex5 = complex4.NaN.add(8.0E298);
    Complex complex6 = complex0.subtract(complex3);
    complex3.isNaN();
    complex2.isInfinite();
    complex6.abs();
    complex2.abs();
    Complex complex7 = complex1.negate();
    Complex complex8 = complex0.ONE.sqrt1z();
    String string0 = complex7.ZERO.toString();
    complex6.nthRoot(3814);
    Complex complex9 = Complex.I;
    complex3.ZERO.add(3294198.0);
    complex3.I.add(2.0);
    complex4.subtract(complex9);
    assertEquals(0.9999999999999539, complex4.getReal(), 0.01);
}","/**
 * Access the real part.
 *
 * @return the real part.
 */"
"public double getImaginary() {
    return imaginary;
}","public void test115119() throws Throwable {
    Complex complex0 = new Complex(3294198.0, 3294198.0);
    Complex complex1 = complex0.I.conjugate();
    Complex complex2 = complex0.ONE.divide(3294198.0);
    List<Complex> list0 = complex2.ONE.nthRoot(3814);
    Complex complex3 = Complex.NaN;
    Complex complex4 = complex2.cos();
    Complex complex5 = complex4.NaN.add(8.0E298);
    Complex complex6 = complex0.subtract(complex3);
    complex3.isNaN();
    complex2.isInfinite();
    complex6.abs();
    complex2.abs();
    Complex complex7 = complex1.negate();
    Complex complex8 = complex0.ONE.sqrt1z();
    String string0 = complex7.ZERO.toString();
    complex6.nthRoot(3814);
    Complex complex9 = Complex.I;
    complex3.ZERO.add(3294198.0);
    complex3.I.add(2.0);
    complex4.subtract(complex9);
    Complex complex10 = complex9.sqrt();
    assertEquals(0.7071067811865475, complex10.getImaginary(), 0.01);
}","/**
 * Access the imaginary part.
 *
 * @return the imaginary part.
 */"
"public double getImaginary() {
    return imaginary;
}","public void test115120() throws Throwable {
    Complex complex0 = new Complex(3294198.0, 3294198.0);
    Complex complex1 = complex0.I.conjugate();
    Complex complex2 = complex0.ONE.divide(3294198.0);
    List<Complex> list0 = complex2.ONE.nthRoot(3814);
    Complex complex3 = Complex.NaN;
    Complex complex4 = complex2.cos();
    Complex complex5 = complex4.NaN.add(8.0E298);
    Complex complex6 = complex0.subtract(complex3);
    complex3.isNaN();
    complex2.isInfinite();
    complex6.abs();
    complex2.abs();
    Complex complex7 = complex1.negate();
    Complex complex8 = complex0.ONE.sqrt1z();
    String string0 = complex7.ZERO.toString();
    complex6.nthRoot(3814);
    Complex complex9 = Complex.I;
    complex3.ZERO.add(3294198.0);
    complex3.I.add(2.0);
    complex4.subtract(complex9);
    Complex complex10 = complex9.sqrt();
    Complex complex11 = complex7.acos();
    assertEquals((-0.8813735870195429), complex11.getImaginary(), 0.01);
}","/**
 * Access the imaginary part.
 *
 * @return the imaginary part.
 */"
"public double getImaginary() {
    return imaginary;
}","public void test115121() throws Throwable {
    Complex complex0 = new Complex(3294198.0, 3294198.0);
    Complex complex1 = complex0.I.conjugate();
    Complex complex2 = complex0.ONE.divide(3294198.0);
    List<Complex> list0 = complex2.ONE.nthRoot(3814);
    Complex complex3 = Complex.NaN;
    Complex complex4 = complex2.cos();
    Complex complex5 = complex4.NaN.add(8.0E298);
    Complex complex6 = complex0.subtract(complex3);
    complex3.isNaN();
    complex2.isInfinite();
    complex6.abs();
    complex2.abs();
    Complex complex7 = complex1.negate();
    Complex complex8 = complex0.ONE.sqrt1z();
    String string0 = complex7.ZERO.toString();
    complex6.nthRoot(3814);
    Complex complex9 = Complex.I;
    complex3.ZERO.add(3294198.0);
    complex3.I.add(2.0);
    complex4.subtract(complex9);
    Complex complex10 = complex9.sqrt();
    Complex complex11 = complex7.acos();
    Complex complex12 = complex8.atan();
    assertEquals(0.0, complex12.getImaginary(), 0.01);
}","/**
 * Access the imaginary part.
 *
 * @return the imaginary part.
 */"
"public Complex atan() {
    if (isNaN) {
        return NaN;
    }
    return this.add(I).divide(I.subtract(this)).log().multiply(I.divide(createComplex(2.0, 0.0)));
}","public void test115122() throws Throwable {
    Complex complex0 = new Complex(3294198.0, 3294198.0);
    Complex complex1 = complex0.I.conjugate();
    Complex complex2 = complex0.ONE.divide(3294198.0);
    List<Complex> list0 = complex2.ONE.nthRoot(3814);
    Complex complex3 = Complex.NaN;
    Complex complex4 = complex2.cos();
    Complex complex5 = complex4.NaN.add(8.0E298);
    Complex complex6 = complex0.subtract(complex3);
    complex3.isNaN();
    complex2.isInfinite();
    complex6.abs();
    complex2.abs();
    Complex complex7 = complex1.negate();
    Complex complex8 = complex0.ONE.sqrt1z();
    String string0 = complex7.ZERO.toString();
    complex6.nthRoot(3814);
    Complex complex9 = Complex.I;
    complex3.ZERO.add(3294198.0);
    complex3.I.add(2.0);
    complex4.subtract(complex9);
    Complex complex10 = complex9.sqrt();
    Complex complex11 = complex7.acos();
    Complex complex12 = complex8.atan();
    complex8.conjugate();
    Complex complex13 = complex6.atan();
    assertSame(complex13, complex5);
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/InverseTangent.html"" TARGET=""_top"">
 * inverse tangent</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   atan(z) = (i/2) log((i + z)/(i - z))
 *  </code>
 * </pre>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite.
 *
 * @return the inverse tangent of this complex number
 * @since 1.2
 */"
"public double getImaginary() {
    return imaginary;
}","public void test115123() throws Throwable {
    Complex complex0 = new Complex(3294198.0, 3294198.0);
    Complex complex1 = complex0.I.conjugate();
    Complex complex2 = complex0.ONE.divide(3294198.0);
    List<Complex> list0 = complex2.ONE.nthRoot(3814);
    Complex complex3 = Complex.NaN;
    Complex complex4 = complex2.cos();
    Complex complex5 = complex4.NaN.add(8.0E298);
    Complex complex6 = complex0.subtract(complex3);
    complex3.isNaN();
    complex2.isInfinite();
    complex6.abs();
    complex2.abs();
    Complex complex7 = complex1.negate();
    Complex complex8 = complex0.ONE.sqrt1z();
    String string0 = complex7.ZERO.toString();
    complex6.nthRoot(3814);
    Complex complex9 = Complex.I;
    complex3.ZERO.add(3294198.0);
    complex3.I.add(2.0);
    complex4.subtract(complex9);
    Complex complex10 = complex9.sqrt();
    Complex complex11 = complex7.acos();
    Complex complex12 = complex8.atan();
    complex8.conjugate();
    Complex complex13 = complex6.atan();
    Complex complex14 = complex2.atan();
    assertEquals(0.0, complex14.getImaginary(), 0.01);
}","/**
 * Access the imaginary part.
 *
 * @return the imaginary part.
 */"
"public double getReal() {
    return real;
}","public void test115124() throws Throwable {
    Complex complex0 = new Complex(3294198.0, 3294198.0);
    Complex complex1 = complex0.I.conjugate();
    Complex complex2 = complex0.ONE.divide(3294198.0);
    List<Complex> list0 = complex2.ONE.nthRoot(3814);
    Complex complex3 = Complex.NaN;
    Complex complex4 = complex2.cos();
    Complex complex5 = complex4.NaN.add(8.0E298);
    Complex complex6 = complex0.subtract(complex3);
    complex3.isNaN();
    complex2.isInfinite();
    complex6.abs();
    complex2.abs();
    Complex complex7 = complex1.negate();
    Complex complex8 = complex0.ONE.sqrt1z();
    String string0 = complex7.ZERO.toString();
    complex6.nthRoot(3814);
    Complex complex9 = Complex.I;
    complex3.ZERO.add(3294198.0);
    complex3.I.add(2.0);
    complex4.subtract(complex9);
    Complex complex10 = complex9.sqrt();
    Complex complex11 = complex7.acos();
    Complex complex12 = complex8.atan();
    complex8.conjugate();
    Complex complex13 = complex6.atan();
    Complex complex14 = complex2.atan();
    assertEquals(3.035640237775535E-7, complex14.getReal(), 0.01);
}","/**
 * Access the real part.
 *
 * @return the real part.
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Complex) {
        Complex c = (Complex) other;
        if (c.isNaN) {
            return isNaN;
        } else {
            return (real == c.real) && (imaginary == c.imaginary);
        }
    }
    return false;
}","public void test115125() throws Throwable {
    Complex complex0 = new Complex(3294198.0, 3294198.0);
    Complex complex1 = complex0.I.conjugate();
    Complex complex2 = complex0.ONE.divide(3294198.0);
    List<Complex> list0 = complex2.ONE.nthRoot(3814);
    Complex complex3 = Complex.NaN;
    Complex complex4 = complex2.cos();
    Complex complex5 = complex4.NaN.add(8.0E298);
    Complex complex6 = complex0.subtract(complex3);
    complex3.isNaN();
    complex2.isInfinite();
    complex6.abs();
    complex2.abs();
    Complex complex7 = complex1.negate();
    Complex complex8 = complex0.ONE.sqrt1z();
    String string0 = complex7.ZERO.toString();
    complex6.nthRoot(3814);
    Complex complex9 = Complex.I;
    complex3.ZERO.add(3294198.0);
    complex3.I.add(2.0);
    complex4.subtract(complex9);
    Complex complex10 = complex9.sqrt();
    Complex complex11 = complex7.acos();
    Complex complex12 = complex8.atan();
    complex8.conjugate();
    Complex complex13 = complex6.atan();
    Complex complex14 = complex2.atan();
    complex6.createComplex(2.0, 5.861389442564046);
    assertFalse(complex3.equals((Object) complex8));
}","/**
 * Test for the equality of two Complex objects.
 * If both the real and imaginary parts of two complex numbers
 * are exactly the same, and neither is {@code Double.NaN}, the two
 * Complex objects are considered to be equal.
 * All {@code NaN} values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to {@code Double.NaN}, the complex number is equal to
 * {@code NaN}.
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if object is
 * {@code null}, not an instance of Complex, or not equal to this Complex
 * instance.
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Complex) {
        Complex c = (Complex) other;
        if (c.isNaN) {
            return isNaN;
        } else {
            return (real == c.real) && (imaginary == c.imaginary);
        }
    }
    return false;
}","public void test116126() throws Throwable {
    Complex complex0 = Complex.valueOf(0.0);
    complex0.createComplex(0.0, 3593.98163);
    complex0.cosh();
    Complex complex1 = new Complex(0.0);
    complex0.equals(complex1);
}","/**
 * Test for the equality of two Complex objects.
 * If both the real and imaginary parts of two complex numbers
 * are exactly the same, and neither is {@code Double.NaN}, the two
 * Complex objects are considered to be equal.
 * All {@code NaN} values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to {@code Double.NaN}, the complex number is equal to
 * {@code NaN}.
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if object is
 * {@code null}, not an instance of Complex, or not equal to this Complex
 * instance.
 */"
