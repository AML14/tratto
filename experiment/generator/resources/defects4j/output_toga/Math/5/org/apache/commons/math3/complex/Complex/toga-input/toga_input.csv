focal_method,test_prefix,docstring
"public Complex reciprocal() {
    if (isNaN) {
        return NaN;
    }
    if (real == 0.0 && imaginary == 0.0) {
        return NaN;
    }
    if (isInfinite) {
        return ZERO;
    }
    if (FastMath.abs(real) < FastMath.abs(imaginary)) {
        double q = real / imaginary;
        double scale = 1. / (real * q + imaginary);
        return createComplex(scale * q, -scale);
    } else {
        double q = imaginary / real;
        double scale = 1. / (imaginary * q + real);
        return createComplex(scale, -scale * q);
    }
}","public void test0000() throws Throwable {
    Complex complex0 = new Complex((-220.8858633578), (-2206.522845379));
    Complex complex1 = Complex.I;
    Complex complex2 = complex0.NaN.multiply(933.56062);
    Complex complex3 = complex0.I.subtract(complex1);
    complex0.nthRoot(384);
    Complex complex4 = complex0.cosh();
    Complex complex5 = complex4.NaN.pow((double) 384);
    Object object0 = new Object();
    complex2.equals(object0);
    Complex.valueOf(933.56062, (-220.8858633578));
    Complex.valueOf(2405.78, 0.0);
    complex2.createComplex(0.0, 933.56062);
    complex4.ONE.hashCode();
    complex4.NaN.add(0.0);
    Complex complex6 = complex4.cos();
    complex4.ONE.hashCode();
    Complex complex7 = complex6.multiply(384);
    complex7.sqrt1z();
    Complex complex8 = Complex.valueOf((-220.8858633578));
    complex7.hashCode();
    Complex complex9 = complex5.cos();
    complex9.add(933.56062);
    complex3.exp();
    complex6.sin();
    complex0.equals(complex8);
    complex1.reciprocal();
}","/**
 * {@inheritDoc}
 */"
"protected final Object readResolve() {
    return createComplex(real, imaginary);
}","public void test0011() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = Complex.ONE;
    Complex complex2 = complex0.exp();
    complex2.multiply(complex1);
    Complex complex3 = Complex.I;
    Complex complex4 = complex3.negate();
    Complex complex5 = complex3.multiply(981305269);
    Complex complex6 = complex3.atan();
    Complex complex7 = complex4.add((double) 981305269);
    Complex complex8 = complex7.acos();
    complex4.multiply(981305269);
    complex7.getArgument();
    complex7.toString();
    complex2.equals(complex5);
    Complex complex9 = complex6.exp();
    complex9.getField();
    Complex complex10 = complex3.tanh();
    complex10.NaN.divide((-1.0190508821164803E-9));
    complex10.log();
    Complex complex11 = complex8.add(complex1);
    complex11.readResolve();
}","/**
 * Resolve the transient fields in a deserialized Complex Object.
 * Subclasses will need to override {@link #createComplex} to
 * deserialize properly.
 *
 * @return A Complex instance with all fields resolved.
 * @since 2.0
 */"
"public Complex exp() {
    if (isNaN) {
        return NaN;
    }
    double expReal = FastMath.exp(real);
    return createComplex(expReal * FastMath.cos(imaginary), expReal * FastMath.sin(imaginary));
}","public void test0022() throws Throwable {
    Complex complex0 = new Complex(2.0, 2.0);
    Complex complex1 = new Complex(2.0);
    Complex complex2 = Complex.ZERO;
    complex1.ZERO.getField();
    Complex complex3 = complex1.add(0.0);
    complex3.I.toString();
    Complex complex4 = complex1.INF.log();
    complex2.INF.readResolve();
    complex1.isInfinite();
    Complex complex5 = complex0.exp();
    Complex complex6 = complex5.NaN.createComplex(1852.1590224026, 1852.1590224026);
    Complex complex7 = Complex.valueOf(2.0, 2776.0);
    complex5.acos();
    complex7.ONE.sin();
    Complex complex8 = complex7.sqrt1z();
    Complex complex9 = complex8.atan();
    complex8.cosh();
    complex8.isInfinite();
    complex1.isNaN();
    complex6.reciprocal();
    Complex complex10 = Complex.valueOf(0.0);
    complex9.equals(complex10);
    complex4.sqrt();
    complex6.exp();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/ExponentialFunction.html"" TARGET=""_top"">
 * exponential function</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#exp}, {@link java.lang.Math#cos}, and
 * {@link java.lang.Math#sin}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   exp(1 &plusmn; INFINITY i) = NaN + NaN i
 *   exp(INFINITY + i) = INFINITY + INFINITY i
 *   exp(-INFINITY + i) = 0 + 0i
 *   exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *  </code>
 * </pre>
 *
 * @return <code><i>e</i><sup>this</sup></code>.
 * @since 1.2
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Complex) {
        Complex c = (Complex) other;
        if (c.isNaN) {
            return isNaN;
        } else {
            return (real == c.real) && (imaginary == c.imaginary);
        }
    }
    return false;
}","public void test0033() throws Throwable {
    Complex complex0 = new Complex(2.0, 2.0);
    Complex complex1 = new Complex(2.0);
    Complex complex2 = complex0.multiply(complex1);
    complex1.ZERO.getField();
    Complex complex3 = complex1.add(0.0);
    complex3.I.toString();
    complex1.INF.log();
    complex2.INF.readResolve();
    complex1.isInfinite();
    Complex complex4 = complex0.exp();
    Complex complex5 = complex4.NaN.createComplex(1852.1590224026, 1852.1590224026);
    Complex complex6 = Complex.valueOf(2.0, 2776.0);
    complex4.acos();
    Complex complex7 = Complex.ZERO;
    Complex complex8 = complex6.sqrt1z();
    Complex complex9 = Complex.I;
    complex8.cosh();
    complex8.isInfinite();
    complex1.isNaN();
    complex5.reciprocal();
    Complex complex10 = Complex.valueOf(0.0);
    complex9.equals(complex10);
}","/**
 * Test for the equality of two Complex objects.
 * If both the real and imaginary parts of two complex numbers
 * are exactly the same, and neither is {@code Double.NaN}, the two
 * Complex objects are considered to be equal.
 * All {@code NaN} values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to {@code Double.NaN}, the complex number is equal to
 * {@code NaN}.
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if object is
 * {@code null}, not an instance of Complex, or not equal to this Complex
 * instance.
 */"
"public List<Complex> nthRoot(int n) throws NotPositiveException {
    if (n <= 0) {
        throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N, n);
    }
    final List<Complex> result = new ArrayList<Complex>();
    if (isNaN) {
        result.add(NaN);
        return result;
    }
    if (isInfinite()) {
        result.add(INF);
        return result;
    }
    // nth root of abs -- faster / more accurate to use a solver here?
    final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);
    // Compute nth roots of complex number with k = 0, 1, ... n-1
    final double nthPhi = getArgument() / n;
    final double slice = 2 * FastMath.PI / n;
    double innerPart = nthPhi;
    for (int k = 0; k < n; k++) {
        // inner part
        final double realPart = nthRootOfAbs * FastMath.cos(innerPart);
        final double imaginaryPart = nthRootOfAbs * FastMath.sin(innerPart);
        result.add(createComplex(realPart, imaginaryPart));
        innerPart += slice;
    }
    return result;
}","public void test0044() throws Throwable {
    Complex complex0 = new Complex((-440.88));
    Complex.valueOf((-3972.416), (-20.0));
    Complex complex1 = complex0.add((-3972.416));
    complex1.NaN.atan();
    Complex complex2 = complex1.ZERO.sqrt();
    int int0 = 1073741824;
    Complex complex3 = complex2.multiply(complex1);
    complex2.NaN.cos();
    Complex complex4 = complex3.ONE.add(complex2);
    double double0 = (-3350.13657);
    complex4.pow((-3350.13657));
    // Undeclared exception!
    complex0.nthRoot(1073741824);
}","/**
 * Computes the n-th roots of this complex number.
 * The nth roots are defined by the formula:
 * <pre>
 *  <code>
 *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))
 *  </code>
 * </pre>
 * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}
 * are respectively the {@link #abs() modulus} and
 * {@link #getArgument() argument} of this complex number.
 * <br/>
 * If one or both parts of this complex number is NaN, a list with just
 * one element, {@link #NaN} is returned.
 * if neither part is NaN, but at least one part is infinite, the result
 * is a one-element list containing {@link #INF}.
 *
 * @param n Degree of root.
 * @return a List<Complex> of all {@code n}-th roots of {@code this}.
 * @throws NotPositiveException if {@code n <= 0}.
 * @since 2.0
 */"
"public List<Complex> nthRoot(int n) throws NotPositiveException {
    if (n <= 0) {
        throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N, n);
    }
    final List<Complex> result = new ArrayList<Complex>();
    if (isNaN) {
        result.add(NaN);
        return result;
    }
    if (isInfinite()) {
        result.add(INF);
        return result;
    }
    // nth root of abs -- faster / more accurate to use a solver here?
    final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);
    // Compute nth roots of complex number with k = 0, 1, ... n-1
    final double nthPhi = getArgument() / n;
    final double slice = 2 * FastMath.PI / n;
    double innerPart = nthPhi;
    for (int k = 0; k < n; k++) {
        // inner part
        final double realPart = nthRootOfAbs * FastMath.cos(innerPart);
        final double imaginaryPart = nthRootOfAbs * FastMath.sin(innerPart);
        result.add(createComplex(realPart, imaginaryPart));
        innerPart += slice;
    }
    return result;
}","public void test0055() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.divide(1602.95755678);
    Complex complex2 = complex1.tanh();
    Complex complex3 = complex2.ONE.tanh();
    Complex complex4 = complex2.multiply(37);
    Complex.valueOf(328.766847813523);
    complex1.equals((Object) null);
    complex4.INF.hashCode();
    complex1.INF.negate();
    complex4.multiply(0.0);
    Complex complex5 = complex4.sqrt1z();
    Complex complex6 = new Complex(Double.POSITIVE_INFINITY, 37);
    complex3.atan();
    Complex.valueOf(0.0, 0.0);
    complex5.conjugate();
    Complex complex7 = Complex.valueOf(328.766847813523);
    try {
        complex7.ZERO.nthRoot((-2651));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot compute nth root for null or negative n: -2,651
        //
        verifyException(""org.apache.commons.math3.complex.Complex"", e);
    }
}","/**
 * Computes the n-th roots of this complex number.
 * The nth roots are defined by the formula:
 * <pre>
 *  <code>
 *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))
 *  </code>
 * </pre>
 * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}
 * are respectively the {@link #abs() modulus} and
 * {@link #getArgument() argument} of this complex number.
 * <br/>
 * If one or both parts of this complex number is NaN, a list with just
 * one element, {@link #NaN} is returned.
 * if neither part is NaN, but at least one part is infinite, the result
 * is a one-element list containing {@link #INF}.
 *
 * @param n Degree of root.
 * @return a List<Complex> of all {@code n}-th roots of {@code this}.
 * @throws NotPositiveException if {@code n <= 0}.
 * @since 2.0
 */"
"public Complex asin() {
    if (isNaN) {
        return NaN;
    }
    return sqrt1z().add(this.multiply(I)).log().multiply(I.negate());
}","public void test0066() throws Throwable {
    Complex complex0 = Complex.NaN;
    Complex complex1 = complex0.ZERO.log();
    Complex complex2 = Complex.valueOf(0.0, 1.0812448255518705E-301);
    Complex complex3 = complex2.NaN.tanh();
    complex3.ZERO.getField();
    Complex complex4 = complex0.createComplex((-1019.8015), (-1019.8015));
    complex4.NaN.getArgument();
    complex4.I.asin();
    complex4.INF.conjugate();
    Complex complex5 = complex2.add(complex0);
    Complex complex6 = complex2.subtract(0.0);
    Complex complex7 = new Complex(Double.NaN, 0.0);
    Complex complex8 = complex7.ZERO.divide(complex5);
    complex8.I.getField();
    Complex complex9 = complex1.add(0.0);
    complex9.INF.toString();
    Complex complex10 = complex9.add(0.0);
    complex10.ZERO.multiply((-2323.058664706638));
    complex9.multiply(complex6);
    complex4.subtract(Double.NaN);
    Complex.valueOf(1.0812448255518705E-301, Double.NaN);
    complex4.asin();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/InverseSine.html"" TARGET=""_top"">
 * inverse sine</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz))
 *  </code>
 * </pre>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite.
 *
 * @return the inverse sine of this complex number.
 * @since 1.2
 */"
"public Complex asin() {
    if (isNaN) {
        return NaN;
    }
    return sqrt1z().add(this.multiply(I)).log().multiply(I.negate());
}","public void test0077() throws Throwable {
    Complex complex0 = Complex.NaN;
    Complex complex1 = complex0.ZERO.log();
    Complex complex2 = Complex.valueOf(0.0, 1.0812448255518705E-301);
    Complex complex3 = complex2.NaN.tanh();
    complex3.ZERO.getField();
    Complex complex4 = complex0.createComplex((-1019.8015), (-1019.8015));
    complex4.NaN.getArgument();
    complex4.I.asin();
    complex4.INF.conjugate();
    Complex complex5 = complex2.add(complex0);
    Complex complex6 = complex2.subtract(0.0);
    Complex complex7 = complex6.ZERO.sqrt();
    Complex complex8 = complex7.ZERO.divide(complex5);
    complex8.I.getField();
    Complex complex9 = complex1.add(0.0);
    complex9.INF.toString();
    Complex complex10 = complex9.add(0.0);
    complex10.ZERO.multiply((-2323.058664706638));
    complex9.multiply(complex6);
    complex4.subtract(Double.NaN);
    Complex.valueOf(1.0812448255518705E-301, Double.NaN);
    complex4.asin();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/InverseSine.html"" TARGET=""_top"">
 * inverse sine</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz))
 *  </code>
 * </pre>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite.
 *
 * @return the inverse sine of this complex number.
 * @since 1.2
 */"
"public Complex divide(Complex divisor) throws NullArgumentException {
    MathUtils.checkNotNull(divisor);
    if (isNaN || divisor.isNaN) {
        return NaN;
    }
    final double c = divisor.getReal();
    final double d = divisor.getImaginary();
    if (c == 0.0 && d == 0.0) {
        return NaN;
    }
    if (divisor.isInfinite() && !isInfinite()) {
        return ZERO;
    }
    if (FastMath.abs(c) < FastMath.abs(d)) {
        double q = c / d;
        double denominator = c * q + d;
        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);
    } else {
        double q = d / c;
        double denominator = d * q + c;
        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
    }
}","public void test0088() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = complex0.sqrt();
    Complex complex2 = complex0.ZERO.pow(complex1);
    Complex complex3 = complex1.ONE.sin();
    Complex complex4 = complex0.sqrt1z();
    Complex complex5 = complex4.NaN.cos();
    complex4.I.toString();
    complex1.toString();
    Complex complex6 = complex2.NaN.cos();
    complex2.abs();
    complex1.subtract(Double.NaN);
    complex3.INF.divide((-1778.526830813));
    complex5.abs();
    complex3.sqrt1z();
    complex6.cosh();
    complex6.divide(complex1);
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this / divisor)}.
 * Implements the definitional formula
 * <pre>
 *  <code>
 *    a + bi          ac + bd + (bc - ad)i
 *    ----------- = -------------------------
 *    c + di         c<sup>2</sup> + d<sup>2</sup>
 *  </code>
 * </pre>
 * but uses
 * <a href=""http://doi.acm.org/10.1145/1039813.1039814"">
 * prescaling of operands</a> to limit the effects of overflows and
 * underflows in the computation.
 * <br/>
 * {@code Infinite} and {@code NaN} values are handled according to the
 * following rules, applied in the order presented:
 * <ul>
 *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value
 *   in either part, {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code divisor} equals {@link #ZERO}, {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code this} and {@code divisor} are both infinite,
 *   {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or
 *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts
 *   infinite), {@link #ZERO} is returned.
 *  </li>
 *  <li>If {@code this} is infinite and {@code divisor} is finite,
 *   {@code NaN} values are returned in the parts of the result if the
 *   {@link java.lang.Double} rules applied to the definitional formula
 *   force {@code NaN} results.
 *  </li>
 * </ul>
 *
 * @param divisor Value by which this {@code Complex} is to be divided.
 * @return {@code this / divisor}.
 * @throws NullArgumentException if {@code divisor} is {@code null}.
 */"
"public boolean isInfinite() {
    return isInfinite;
}","public void test0099() throws Throwable {
    Complex complex0 = Complex.valueOf(0.0);
    Complex complex1 = Complex.valueOf(0.0, 1.4035923083915864E217);
    Complex complex2 = complex0.I.add(complex1);
    Complex complex3 = complex0.asin();
    Complex complex4 = complex0.add(complex3);
    Complex complex5 = complex4.add(complex0);
    complex3.NaN.readResolve();
    complex0.sqrt1z();
    complex5.hashCode();
    Complex complex6 = Complex.NaN;
    complex5.I.subtract(complex6);
    complex4.NaN.cosh();
    complex3.INF.tan();
    Complex complex7 = complex0.sinh();
    complex7.readResolve();
    Complex complex8 = complex2.subtract(complex0);
    complex7.log();
    complex8.INF.sqrt1z();
    complex7.isInfinite();
    Complex complex9 = complex5.pow(complex8);
    complex9.NaN.multiply((-3035));
    Complex complex10 = complex2.add(1398.073);
    complex3.add(complex10);
    complex4.isInfinite();
    complex8.sqrt1z();
    Complex complex11 = complex2.add(complex0);
    complex1.atan();
    complex11.toString();
    complex9.isInfinite();
}","/**
 * Checks whether either the real or imaginary part of this complex number
 * takes an infinite value (either {@code Double.POSITIVE_INFINITY} or
 * {@code Double.NEGATIVE_INFINITY}) and neither part
 * is {@code NaN}.
 *
 * @return true if one or both parts of this complex number are infinite
 * and neither part is {@code NaN}.
 */"
"public Complex pow(double x) {
    return this.log().multiply(x).exp();
}","public void test01010() throws Throwable {
    Complex complex0 = Complex.valueOf(Double.NaN);
    Complex complex1 = complex0.subtract(Double.NaN);
    Complex complex2 = complex1.ZERO.divide(complex0);
    Complex complex3 = complex0.sin();
    Complex complex4 = complex0.tanh();
    complex4.NaN.tan();
    complex0.INF.getField();
    complex4.pow(305.07576780617114);
    Complex complex5 = complex0.cos();
    complex5.INF.tan();
    complex3.tan();
    complex0.cos();
    complex2.pow(0.6075552701950073);
}","/**
 * Returns of value of this complex number raised to the power of {@code x}.
 *
 * @param  x exponent to which this {@code Complex} is to be raised.
 * @return <code>this<sup>x</sup></code>.
 * @see #pow(Complex)
 */"
"public Complex divide(double divisor) {
    if (isNaN || Double.isNaN(divisor)) {
        return NaN;
    }
    if (divisor == 0d) {
        return NaN;
    }
    if (Double.isInfinite(divisor)) {
        return !isInfinite() ? ZERO : NaN;
    }
    return createComplex(real / divisor, imaginary / divisor);
}","public void test01111() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = complex0.I.exp();
    complex1.INF.pow(0.0);
    Complex complex2 = complex0.multiply((-242));
    Complex complex3 = complex2.ONE.conjugate();
    Complex complex4 = complex1.I.exp();
    complex4.ZERO.getArgument();
    complex4.NaN.toString();
    complex2.isNaN();
    complex1.isInfinite();
    complex0.getField();
    Complex complex5 = Complex.valueOf((-1391.132968));
    complex5.divide((double) (-242));
    Complex complex6 = complex5.add(Double.NaN);
    complex3.isInfinite();
    Complex complex7 = complex1.createComplex(Double.NaN, 1415.77374343);
    complex7.isInfinite();
    complex6.getArgument();
    complex4.divide((-1787.0131831217));
}","/**
 * Returns a {@code Complex} whose value is {@code (this / divisor)},
 * with {@code divisor} interpreted as a real number.
 *
 * @param  divisor Value by which this {@code Complex} is to be divided.
 * @return {@code this / divisor}.
 * @see #divide(Complex)
 */"
"public Complex multiply(final int factor) {
    if (isNaN) {
        return NaN;
    }
    if (Double.isInfinite(real) || Double.isInfinite(imaginary)) {
        return INF;
    }
    return createComplex(real * factor, imaginary * factor);
}","public void test01212() throws Throwable {
    Complex complex0 = Complex.NaN;
    Complex complex1 = complex0.cosh();
    complex0.I.abs();
    complex1.abs();
    complex0.I.multiply(833);
    complex1.ZERO.subtract(complex0);
    Complex complex2 = complex1.ZERO.add(Double.NaN);
    Complex complex3 = complex2.I.pow(2.0);
    complex3.ZERO.divide(complex2);
    Complex complex4 = complex1.subtract(1.5704330804213333);
    Complex complex5 = complex0.divide(1.5704330804213333);
    complex5.ONE.toString();
    Complex complex6 = complex2.subtract(complex0);
    complex5.sqrt1z();
    complex6.ZERO.pow(2.0);
    complex4.getField();
    complex6.cos();
    complex2.multiply(833);
}","/**
 * Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}
 * interpreted as a integer number.
 *
 * @param  factor value to be multiplied by this {@code Complex}.
 * @return {@code this * factor}.
 * @see #multiply(Complex)
 */"
"public Complex tan() {
    if (isNaN || Double.isInfinite(real)) {
        return NaN;
    }
    if (imaginary > 20.0) {
        return createComplex(0.0, 1.0);
    }
    if (imaginary < -20.0) {
        return createComplex(0.0, -1.0);
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = FastMath.cos(real2) + FastMath.cosh(imaginary2);
    return createComplex(FastMath.sin(real2) / d, FastMath.sinh(imaginary2) / d);
}","public void test01313() throws Throwable {
    Complex complex0 = new Complex((-431.812708092), (-431.812708092));
    Complex complex1 = complex0.ZERO.acos();
    complex1.pow(complex0);
    Complex complex2 = complex0.createComplex((-431.812708092), (-2359.1068));
    Complex complex3 = complex0.tan();
    Complex complex4 = complex0.NaN.divide((-2359.1068));
    complex3.isInfinite();
    Complex complex5 = complex0.reciprocal();
    complex0.NaN.readResolve();
    Complex complex6 = Complex.valueOf((-431.812708092), (-2359.1068));
    Complex complex7 = complex6.ONE.sinh();
    complex7.toString();
    complex5.NaN.conjugate();
    complex2.getArgument();
    complex5.I.multiply((-4223));
    Complex complex8 = complex2.subtract(complex5);
    Complex complex9 = complex0.multiply((-2487));
    Complex complex10 = complex5.ONE.acos();
    Complex complex11 = complex9.I.multiply(0.0);
    complex11.ZERO.abs();
    complex9.hashCode();
    complex8.isNaN();
    complex3.isNaN();
    Complex complex12 = complex10.sinh();
    Complex complex13 = complex5.subtract((-2359.1068));
    Complex complex14 = complex13.INF.createComplex((-1849.561), 973.4118501601226);
    complex1.cosh();
    complex12.sqrt();
    complex9.divide(0.0);
    complex3.divide(complex4);
    complex14.tan();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Tangent.html"" TARGET=""_top"">
 * tangent</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and
 * {@link FastMath#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   tan(a &plusmn; INFINITY i) = 0 &plusmn; i
 *   tan(&plusmn;INFINITY + bi) = NaN + NaN i
 *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *   tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i
 *  </code>
 * </pre>
 *
 * @return the tangent of {@code this}.
 * @since 1.2
 */"
"public Complex sinh() {
    if (isNaN) {
        return NaN;
    }
    return createComplex(FastMath.sinh(real) * FastMath.cos(imaginary), FastMath.cosh(real) * FastMath.sin(imaginary));
}","public void test01414() throws Throwable {
    Complex complex0 = new Complex((-54.752), (-1305.981));
    Complex complex1 = Complex.valueOf((-54.752), Double.POSITIVE_INFINITY);
    complex1.cosh();
    Complex complex2 = complex0.NaN.tan();
    complex2.INF.hashCode();
    Complex complex3 = complex0.reciprocal();
    Complex complex4 = complex0.pow(complex2);
    complex4.NaN.hashCode();
    Complex complex5 = complex2.I.sqrt();
    Complex complex6 = complex3.pow((-54.752));
    complex3.I.sinh();
    Complex complex7 = complex6.ZERO.conjugate();
    complex7.ZERO.subtract(complex3);
    complex0.divide(complex2);
    Complex complex8 = complex3.sqrt1z();
    complex8.ONE.conjugate();
    complex8.ZERO.pow(complex4);
    Complex complex9 = complex6.acos();
    Complex.valueOf((-1305.981), (-54.752));
    Complex complex10 = complex0.pow(70.532908);
    Complex complex11 = complex0.sinh();
    Complex complex12 = complex9.divide(complex10);
    complex12.INF.getArgument();
    complex5.getField();
    complex9.cos();
    complex12.asin();
    Complex complex13 = complex5.multiply(complex11);
    complex11.getReal();
    complex13.sinh();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/HyperbolicSine.html"" TARGET=""_top"">
 * hyperbolic sine</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link FastMath#cosh} and {@link FastMath#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   sinh(1 &plusmn; INFINITY i) = NaN + NaN i
 *   sinh(&plusmn;INFINITY + i) = &plusmn; INFINITY + INFINITY i
 *   sinh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *  </code>
 * </pre>
 *
 * @return the hyperbolic sine of {@code this}.
 * @since 1.2
 */"
"public double abs() {
    if (isNaN) {
        return Double.NaN;
    }
    if (isInfinite()) {
        return Double.POSITIVE_INFINITY;
    }
    if (FastMath.abs(real) < FastMath.abs(imaginary)) {
        if (imaginary == 0.0) {
            return FastMath.abs(real);
        }
        double q = real / imaginary;
        return FastMath.abs(imaginary) * FastMath.sqrt(1 + q * q);
    } else {
        if (real == 0.0) {
            return FastMath.abs(imaginary);
        }
        double q = imaginary / real;
        return FastMath.abs(real) * FastMath.sqrt(1 + q * q);
    }
}","public void test01515() throws Throwable {
    Complex complex0 = new Complex(2.0, (-1456.87));
    Complex complex1 = Complex.NaN;
    Complex complex2 = complex0.I.pow(complex1);
    Complex complex3 = complex0.log();
    Complex complex4 = complex3.reciprocal();
    Complex complex5 = complex0.sqrt();
    Complex complex6 = complex4.sin();
    Complex complex7 = complex6.ONE.acos();
    complex3.I.readResolve();
    complex3.getField();
    complex5.getReal();
    complex0.ZERO.conjugate();
    complex7.isInfinite();
    complex7.subtract(complex6);
    Complex complex8 = complex0.multiply(Double.POSITIVE_INFINITY);
    Complex complex9 = complex8.ONE.multiply(complex6);
    complex9.multiply(complex8);
    Complex complex10 = complex6.atan();
    complex10.NaN.cosh();
    complex8.I.divide((-3982.60736));
    complex6.isNaN();
    complex7.readResolve();
    complex3.getField();
    Complex complex11 = complex8.multiply(complex3);
    complex11.NaN.reciprocal();
    complex2.acos();
    complex0.abs();
}","/**
 * Return the absolute value of this complex number.
 * Returns {@code NaN} if either real or imaginary part is {@code NaN}
 * and {@code Double.POSITIVE_INFINITY} if neither part is {@code NaN},
 * but at least one part is infinite.
 *
 * @return the absolute value.
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Complex) {
        Complex c = (Complex) other;
        if (c.isNaN) {
            return isNaN;
        } else {
            return (real == c.real) && (imaginary == c.imaginary);
        }
    }
    return false;
}","public void test01616() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.pow(11104.0);
    Complex complex2 = complex1.asin();
    complex2.ONE.sqrt();
    complex2.ONE.add(11104.0);
    Complex complex3 = complex1.sqrt1z();
    complex2.tanh();
    Complex complex4 = complex3.negate();
    complex4.equals(complex1);
}","/**
 * Test for the equality of two Complex objects.
 * If both the real and imaginary parts of two complex numbers
 * are exactly the same, and neither is {@code Double.NaN}, the two
 * Complex objects are considered to be equal.
 * All {@code NaN} values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to {@code Double.NaN}, the complex number is equal to
 * {@code NaN}.
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if object is
 * {@code null}, not an instance of Complex, or not equal to this Complex
 * instance.
 */"
"public Complex conjugate() {
    if (isNaN) {
        return NaN;
    }
    return createComplex(real, -imaginary);
}","public void test01717() throws Throwable {
    Complex complex0 = Complex.valueOf(Double.POSITIVE_INFINITY);
    Complex complex1 = complex0.sin();
    Complex complex2 = complex0.NaN.divide(complex1);
    complex2.INF.multiply(Double.POSITIVE_INFINITY);
    Complex complex3 = complex2.createComplex(192.1345, Double.POSITIVE_INFINITY);
    complex3.I.acos();
    Complex complex4 = Complex.valueOf(0.0);
    Complex complex5 = complex4.ONE.divide((-264.283023385));
    complex0.toString();
    Complex complex6 = complex4.cos();
    complex5.nthRoot(1);
    complex6.multiply(2334);
    Complex complex7 = complex4.log();
    complex7.conjugate();
}","/**
 * Return the conjugate of this complex number.
 * The conjugate of {@code a + bi} is {@code a - bi}.
 * <br/>
 * {@link #NaN} is returned if either the real or imaginary
 * part of this Complex number equals {@code Double.NaN}.
 * <br/>
 * If the imaginary part is infinite, and the real part is not
 * {@code NaN}, the returned value has infinite imaginary part
 * of the opposite sign, e.g. the conjugate of
 * {@code 1 + POSITIVE_INFINITY i} is {@code 1 - NEGATIVE_INFINITY i}.
 *
 * @return the conjugate of this Complex object.
 */"
"public Complex pow(Complex x) throws NullArgumentException {
    MathUtils.checkNotNull(x);
    return this.log().multiply(x).exp();
}","public void test01818() throws Throwable {
    Complex complex0 = Complex.NaN;
    Complex complex1 = complex0.pow((-1748.38));
    complex0.exp();
    complex1.readResolve();
    Complex complex2 = complex0.sin();
    complex2.pow(complex1);
    complex2.sqrt1z();
    Complex complex3 = complex0.multiply(complex1);
    complex3.INF.divide((-4323.12239188411));
    complex3.pow(complex1);
}","/**
 * Returns of value of this complex number raised to the power of {@code x}.
 * Implements the formula:
 * <pre>
 *  <code>
 *   y<sup>x</sup> = exp(x&middot;log(y))
 *  </code>
 * </pre>
 * where {@code exp} and {@code log} are {@link #exp} and
 * {@link #log}, respectively.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite, or if {@code y}
 * equals {@link Complex#ZERO}.
 *
 * @param  x exponent to which this {@code Complex} is to be raised.
 * @return <code> this<sup>{@code x}</sup></code>.
 * @throws NullArgumentException if x is {@code null}.
 * @since 1.2
 */"
"public Complex sinh() {
    if (isNaN) {
        return NaN;
    }
    return createComplex(FastMath.sinh(real) * FastMath.cos(imaginary), FastMath.cosh(real) * FastMath.sin(imaginary));
}","public void test01919() throws Throwable {
    Complex complex0 = Complex.NaN;
    Complex complex1 = new Complex(959.12);
    Complex complex2 = complex0.INF.add(complex1);
    Complex complex3 = Complex.valueOf((-683.4726135995209));
    Complex complex4 = complex3.INF.cosh();
    complex0.getField();
    complex3.ZERO.conjugate();
    complex2.ZERO.reciprocal();
    Complex complex5 = Complex.valueOf((-683.4726135995209), 1202.73);
    Object object0 = complex2.readResolve();
    complex0.equals(object0);
    complex5.sin();
    complex4.sin();
    Complex complex6 = complex5.negate();
    Complex complex7 = complex6.sinh();
    complex7.tan();
    complex5.sinh();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/HyperbolicSine.html"" TARGET=""_top"">
 * hyperbolic sine</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link FastMath#cosh} and {@link FastMath#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   sinh(1 &plusmn; INFINITY i) = NaN + NaN i
 *   sinh(&plusmn;INFINITY + i) = &plusmn; INFINITY + INFINITY i
 *   sinh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *  </code>
 * </pre>
 *
 * @return the hyperbolic sine of {@code this}.
 * @since 1.2
 */"
"public Complex tan() {
    if (isNaN || Double.isInfinite(real)) {
        return NaN;
    }
    if (imaginary > 20.0) {
        return createComplex(0.0, 1.0);
    }
    if (imaginary < -20.0) {
        return createComplex(0.0, -1.0);
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = FastMath.cos(real2) + FastMath.cosh(imaginary2);
    return createComplex(FastMath.sin(real2) / d, FastMath.sinh(imaginary2) / d);
}","public void test02020() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = Complex.I;
    complex0.I.subtract(complex1);
    complex0.getField();
    Complex complex2 = complex0.conjugate();
    Complex complex3 = complex2.ZERO.subtract(2253.86183);
    complex2.INF.abs();
    Object object0 = complex2.readResolve();
    complex2.equals(object0);
    complex3.exp();
    complex3.tan();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Tangent.html"" TARGET=""_top"">
 * tangent</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and
 * {@link FastMath#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   tan(a &plusmn; INFINITY i) = 0 &plusmn; i
 *   tan(&plusmn;INFINITY + bi) = NaN + NaN i
 *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *   tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i
 *  </code>
 * </pre>
 *
 * @return the tangent of {@code this}.
 * @since 1.2
 */"
"public ComplexField getField() {
    return ComplexField.getInstance();
}","public void test02121() throws Throwable {
    Complex complex0 = Complex.NaN;
    complex0.ZERO.readResolve();
    complex0.getField();
    Complex complex1 = complex0.createComplex((-640.598), 2772.2);
    Complex complex2 = complex1.atan();
    complex1.ONE.tan();
    complex1.createComplex(1608.5279, (-620.0947));
    Complex complex3 = complex1.tanh();
    Complex complex4 = complex3.NaN.negate();
    complex4.ONE.abs();
    Complex complex5 = complex2.add(1608.5279);
    Complex complex6 = complex5.I.log();
    complex5.log();
    complex6.acos();
    Complex.valueOf((-620.0947), (-620.0947));
    complex1.getField();
}","/**
 * {@inheritDoc}
 */"
"public Complex tanh() {
    if (isNaN || Double.isInfinite(imaginary)) {
        return NaN;
    }
    if (real > 20.0) {
        return createComplex(1.0, 0.0);
    }
    if (real < -20.0) {
        return createComplex(-1.0, 0.0);
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);
    return createComplex(FastMath.sinh(real2) / d, FastMath.sin(imaginary2) / d);
}","public void test02222() throws Throwable {
    Complex complex0 = Complex.NaN;
    Complex complex1 = Complex.valueOf(0.2622140049934387);
    Complex complex2 = complex0.subtract(complex1);
    Complex complex3 = complex0.divide(0.0);
    Complex complex4 = complex0.pow(complex3);
    Complex complex5 = Complex.valueOf(3122.88, 3122.88);
    complex5.INF.getArgument();
    Complex complex6 = complex0.cos();
    Complex complex7 = complex6.NaN.log();
    complex4.pow(complex3);
    complex6.nthRoot(1150);
    complex3.isNaN();
    complex7.equals(complex0);
    complex7.getArgument();
    complex2.tanh();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/HyperbolicTangent.html"" TARGET=""_top"">
 * hyperbolic tangent</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and
 * {@link FastMath#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   tanh(a &plusmn; INFINITY i) = NaN + NaN i
 *   tanh(&plusmn;INFINITY + bi) = &plusmn;1 + 0 i
 *   tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *   tanh(0 + (&pi;/2)i) = NaN + INFINITY i
 *  </code>
 * </pre>
 *
 * @return the hyperbolic tangent of {@code this}.
 * @since 1.2
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Complex) {
        Complex c = (Complex) other;
        if (c.isNaN) {
            return isNaN;
        } else {
            return (real == c.real) && (imaginary == c.imaginary);
        }
    }
    return false;
}","public void test02323() throws Throwable {
    Complex complex0 = Complex.valueOf(5.926057457356852E-43);
    complex0.INF.sqrt1z();
    Complex complex1 = Complex.valueOf(0.0, 501.6);
    complex0.ONE.abs();
    Complex complex2 = complex0.sqrt1z();
    complex2.atan();
    Complex complex3 = complex1.multiply(501.6);
    complex1.exp();
    Object object0 = complex3.readResolve();
    complex0.equals(object0);
}","/**
 * Test for the equality of two Complex objects.
 * If both the real and imaginary parts of two complex numbers
 * are exactly the same, and neither is {@code Double.NaN}, the two
 * Complex objects are considered to be equal.
 * All {@code NaN} values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to {@code Double.NaN}, the complex number is equal to
 * {@code NaN}.
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if object is
 * {@code null}, not an instance of Complex, or not equal to this Complex
 * instance.
 */"
"public Complex subtract(Complex subtrahend) throws NullArgumentException {
    MathUtils.checkNotNull(subtrahend);
    if (isNaN || subtrahend.isNaN) {
        return NaN;
    }
    return createComplex(real - subtrahend.getReal(), imaginary - subtrahend.getImaginary());
}","public void test02424() throws Throwable {
    Complex complex0 = Complex.valueOf(0.0, 0.0);
    Complex complex1 = complex0.INF.negate();
    Complex complex2 = Complex.I;
    complex0.pow(complex2);
    Complex complex3 = complex2.add(complex0);
    complex3.ONE.abs();
    complex1.abs();
    Complex complex4 = Complex.valueOf(1011.13);
    Complex complex5 = complex4.INF.divide(complex3);
    complex1.multiply(94.55);
    complex5.sin();
    complex1.subtract(complex4);
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this - subtrahend)}.
 * Uses the definitional formula
 * <pre>
 *  <code>
 *   (a + bi) - (c + di) = (a-c) + (b-d)i
 *  </code>
 * </pre>
 * If either {@code this} or {@code subtrahend} has a {@code NaN]} value in either part,
 * {@link #NaN} is returned; otherwise infinite and {@code NaN} values are
 * returned in the parts of the result according to the rules for
 * {@link java.lang.Double} arithmetic.
 *
 * @param  subtrahend value to be subtracted from this {@code Complex}.
 * @return {@code this - subtrahend}.
 * @throws NullArgumentException if {@code subtrahend} is {@code null}.
 */"
"public Complex pow(Complex x) throws NullArgumentException {
    MathUtils.checkNotNull(x);
    return this.log().multiply(x).exp();
}","public void test02525() throws Throwable {
    Complex complex0 = new Complex((-1161.507980828377), 2.0);
    complex0.I.add(0.0);
    try {
        complex0.pow((Complex) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // null is not allowed
        //
        verifyException(""org.apache.commons.math3.util.MathUtils"", e);
    }
}","/**
 * Returns of value of this complex number raised to the power of {@code x}.
 * Implements the formula:
 * <pre>
 *  <code>
 *   y<sup>x</sup> = exp(x&middot;log(y))
 *  </code>
 * </pre>
 * where {@code exp} and {@code log} are {@link #exp} and
 * {@link #log}, respectively.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite, or if {@code y}
 * equals {@link Complex#ZERO}.
 *
 * @param  x exponent to which this {@code Complex} is to be raised.
 * @return <code> this<sup>{@code x}</sup></code>.
 * @throws NullArgumentException if x is {@code null}.
 * @since 1.2
 */"
"public boolean isNaN() {
    return isNaN;
}","public void test02626() throws Throwable {
    Complex complex0 = new Complex(0.0, 6.283185307179586);
    Complex complex1 = complex0.sqrt1z();
    Complex complex2 = complex0.pow(6.283185307179586);
    complex2.hashCode();
    complex0.isNaN();
    complex2.getField();
    complex0.getImaginary();
    Complex complex3 = complex0.ONE.acos();
    complex2.getReal();
    complex1.isNaN();
    Complex complex4 = complex2.atan();
    Complex complex5 = complex4.createComplex(6.283185307179586, 1616.5833721);
    complex5.hashCode();
    complex5.cos();
    complex3.sqrt1z();
    complex5.isNaN();
}","/**
 * Checks whether either or both parts of this complex number is
 * {@code NaN}.
 *
 * @return true if either or both parts of this complex number is
 * {@code NaN}; false otherwise.
 */"
"public Complex atan() {
    if (isNaN) {
        return NaN;
    }
    return this.add(I).divide(I.subtract(this)).log().multiply(I.divide(createComplex(2.0, 0.0)));
}","public void test02727() throws Throwable {
    Complex complex0 = Complex.valueOf(20.0, 463.610560731626);
    Complex complex1 = complex0.INF.conjugate();
    complex0.getArgument();
    Complex complex2 = complex0.cos();
    complex0.sqrt();
    complex1.NaN.pow(complex0);
    Complex complex3 = complex2.NaN.sin();
    complex2.getField();
    Complex complex4 = complex2.asin();
    complex4.ZERO.conjugate();
    complex4.INF.tan();
    complex1.getField();
    complex0.add(complex4);
    Complex complex5 = Complex.I;
    complex0.add(complex5);
    complex3.multiply(complex4);
    Complex complex6 = Complex.valueOf(1746.86);
    complex2.pow(complex6);
    complex3.atan();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/InverseTangent.html"" TARGET=""_top"">
 * inverse tangent</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   atan(z) = (i/2) log((i + z)/(i - z))
 *  </code>
 * </pre>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite.
 *
 * @return the inverse tangent of this complex number
 * @since 1.2
 */"
"public Complex divide(double divisor) {
    if (isNaN || Double.isNaN(divisor)) {
        return NaN;
    }
    if (divisor == 0d) {
        return NaN;
    }
    if (Double.isInfinite(divisor)) {
        return !isInfinite() ? ZERO : NaN;
    }
    return createComplex(real / divisor, imaginary / divisor);
}","public void test02828() throws Throwable {
    Complex complex0 = new Complex(1.2599210498948732, 0.0032568115392321417);
    Complex complex1 = Complex.valueOf(1143.5397259066847, (-20.0));
    Complex complex2 = complex0.INF.subtract(complex1);
    complex2.ONE.cosh();
    Complex complex3 = complex0.cos();
    complex3.ONE.createComplex(1143.5397259066847, (-20.0));
    Complex complex4 = complex3.ONE.tanh();
    complex4.INF.add((-2577.29));
    complex1.I.abs();
    complex1.divide(7.462678536479685E-9);
}","/**
 * Returns a {@code Complex} whose value is {@code (this / divisor)},
 * with {@code divisor} interpreted as a real number.
 *
 * @param  divisor Value by which this {@code Complex} is to be divided.
 * @return {@code this / divisor}.
 * @see #divide(Complex)
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Complex) {
        Complex c = (Complex) other;
        if (c.isNaN) {
            return isNaN;
        } else {
            return (real == c.real) && (imaginary == c.imaginary);
        }
    }
    return false;
}","public void test02929() throws Throwable {
    Complex complex0 = new Complex(0.0, 0.0);
    Complex complex1 = Complex.INF;
    complex0.NaN.add(0.0);
    Complex complex2 = complex0.ONE.pow(complex1);
    Complex complex3 = complex2.tanh();
    complex3.acos();
    Complex complex4 = complex3.sinh();
    complex4.NaN.readResolve();
    Complex complex5 = complex0.sqrt();
    Complex complex6 = complex5.subtract(0.0);
    Complex complex7 = complex0.acos();
    complex1.isInfinite();
    Complex complex8 = complex1.conjugate();
    Complex complex9 = complex8.I.reciprocal();
    complex6.I.divide(1488.2062);
    complex0.getArgument();
    complex7.ZERO.atan();
    complex1.nthRoot(3371);
    complex7.multiply(complex0);
    Complex complex10 = complex1.asin();
    complex10.INF.pow(complex6);
    Complex complex11 = complex6.exp();
    complex11.I.sin();
    complex0.NaN.multiply(0.0);
    complex11.NaN.add((-20.0));
    complex6.abs();
    complex5.pow(complex0);
    Complex complex12 = complex5.tan();
    complex12.NaN.conjugate();
    complex9.atan();
    complex1.equals(complex7);
}","/**
 * Test for the equality of two Complex objects.
 * If both the real and imaginary parts of two complex numbers
 * are exactly the same, and neither is {@code Double.NaN}, the two
 * Complex objects are considered to be equal.
 * All {@code NaN} values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to {@code Double.NaN}, the complex number is equal to
 * {@code NaN}.
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if object is
 * {@code null}, not an instance of Complex, or not equal to this Complex
 * instance.
 */"
"public Complex add(Complex addend) throws NullArgumentException {
    MathUtils.checkNotNull(addend);
    if (isNaN || addend.isNaN) {
        return NaN;
    }
    return createComplex(real + addend.getReal(), imaginary + addend.getImaginary());
}","public void test03030() throws Throwable {
    Complex complex0 = Complex.valueOf((-879.322541214), 0.0);
    complex0.ONE.pow(2969.33717141241);
    try {
        complex0.add((Complex) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // null is not allowed
        //
        verifyException(""org.apache.commons.math3.util.MathUtils"", e);
    }
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this + addend)}.
 * Uses the definitional formula
 * <pre>
 *  <code>
 *   (a + bi) + (c + di) = (a+c) + (b+d)i
 *  </code>
 * </pre>
 * <br/>
 * If either {@code this} or {@code addend} has a {@code NaN} value in
 * either part, {@link #NaN} is returned; otherwise {@code Infinite}
 * and {@code NaN} values are returned in the parts of the result
 * according to the rules for {@link java.lang.Double} arithmetic.
 *
 * @param  addend Value to be added to this {@code Complex}.
 * @return {@code this + addend}.
 * @throws NullArgumentException if {@code addend} is {@code null}.
 */"
"@Override
public int hashCode() {
    if (isNaN) {
        return 7;
    }
    return 37 * (17 * MathUtils.hash(imaginary) + MathUtils.hash(real));
}","public void test03131() throws Throwable {
    Complex complex0 = Complex.valueOf(783.043, (-2008.895426));
    Complex complex1 = complex0.INF.asin();
    Complex complex2 = complex1.NaN.createComplex((-43.47631730348), 6.283185307179586);
    Complex complex3 = complex1.ZERO.pow(complex0);
    complex3.ONE.toString();
    complex3.INF.cosh();
    Complex complex4 = complex0.tanh();
    Complex complex5 = complex0.exp();
    Complex complex6 = complex5.sinh();
    complex5.getReal();
    Complex complex7 = complex6.divide((-2686.97019));
    complex5.INF.getArgument();
    Complex complex8 = complex7.NaN.sinh();
    Complex complex9 = complex5.add(complex0);
    Complex complex10 = new Complex(6.283185307179586, 6.283185307179586);
    complex6.NaN.add(complex10);
    Complex complex11 = complex9.multiply(646);
    complex11.divide(complex8);
    complex4.isInfinite();
    complex1.cos();
    Complex complex12 = complex7.cos();
    complex2.pow(0.0);
    Complex complex13 = complex10.tanh();
    complex7.sqrt();
    complex13.pow(complex12);
    complex9.hashCode();
}","/**
 * Get a hashCode for the complex number.
 * Any {@code Double.NaN} value in real or imaginary part produces
 * the same hash code {@code 7}.
 *
 * @return a hash code value for this object.
 */"
"public Complex add(double addend) {
    if (isNaN || Double.isNaN(addend)) {
        return NaN;
    }
    return createComplex(real + addend, imaginary);
}","public void test03232() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = complex0.I.subtract((-2003.4322116849));
    Complex complex2 = complex0.log();
    complex1.exp();
    Complex.valueOf((-2003.4322116849), (-2003.4322116849));
    Complex complex3 = complex0.sin();
    complex3.INF.pow(Double.POSITIVE_INFINITY);
    complex1.multiply(complex0);
    complex3.reciprocal();
    complex2.getField();
    complex0.getArgument();
    complex1.add(0.5051454305648804);
}","/**
 * Returns a {@code Complex} whose value is {@code (this + addend)},
 * with {@code addend} interpreted as a real number.
 *
 * @param addend Value to be added to this {@code Complex}.
 * @return {@code this + addend}.
 * @see #add(Complex)
 */"
"public Complex multiply(Complex factor) throws NullArgumentException {
    MathUtils.checkNotNull(factor);
    if (isNaN || factor.isNaN) {
        return NaN;
    }
    if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(factor.real) || Double.isInfinite(factor.imaginary)) {
        // we don't use isInfinite() to avoid testing for NaN again
        return INF;
    }
    return createComplex(real * factor.real - imaginary * factor.imaginary, real * factor.imaginary + imaginary * factor.real);
}","public void test03333() throws Throwable {
    Complex complex0 = Complex.valueOf((-1009.7903));
    Complex complex1 = complex0.conjugate();
    Complex complex2 = complex1.atan();
    complex0.conjugate();
    Complex complex3 = complex1.I.reciprocal();
    complex3.hashCode();
    complex1.I.hashCode();
    complex3.hashCode();
    Complex complex4 = complex0.NaN.log();
    Complex complex5 = complex2.I.multiply((-2794));
    complex3.ZERO.nthRoot(1);
    Complex complex6 = complex0.cos();
    complex6.I.add(complex3);
    Complex complex7 = complex2.subtract(complex0);
    complex7.ONE.subtract(complex4);
    Complex complex8 = complex1.multiply(1);
    complex3.nthRoot(1);
    complex0.subtract(complex5);
    complex2.add(complex3);
    complex1.sqrt();
    complex8.hashCode();
    complex4.multiply(complex8);
}","/**
 * Returns a {@code Complex} whose value is {@code this * factor}.
 * Implements preliminary checks for {@code NaN} and infinity followed by
 * the definitional formula:
 * <pre>
 *  <code>
 *   (a + bi)(c + di) = (ac - bd) + (ad + bc)i
 *  </code>
 * </pre>
 * Returns {@link #NaN} if either {@code this} or {@code factor} has one or
 * more {@code NaN} parts.
 * <br/>
 * Returns {@link #INF} if neither {@code this} nor {@code factor} has one
 * or more {@code NaN} parts and if either {@code this} or {@code factor}
 * has one or more infinite parts (same result is returned regardless of
 * the sign of the components).
 * <br/>
 * Returns finite values in components of the result per the definitional
 * formula in all remaining cases.
 *
 * @param  factor value to be multiplied by this {@code Complex}.
 * @return {@code this * factor}.
 * @throws NullArgumentException if {@code factor} is {@code null}.
 */"
"public double abs() {
    if (isNaN) {
        return Double.NaN;
    }
    if (isInfinite()) {
        return Double.POSITIVE_INFINITY;
    }
    if (FastMath.abs(real) < FastMath.abs(imaginary)) {
        if (imaginary == 0.0) {
            return FastMath.abs(real);
        }
        double q = real / imaginary;
        return FastMath.abs(imaginary) * FastMath.sqrt(1 + q * q);
    } else {
        if (real == 0.0) {
            return FastMath.abs(imaginary);
        }
        double q = imaginary / real;
        return FastMath.abs(real) * FastMath.sqrt(1 + q * q);
    }
}","public void test03434() throws Throwable {
    Complex complex0 = new Complex(Double.NaN);
    Complex complex1 = complex0.NaN.atan();
    Complex complex2 = complex0.subtract(0.0);
    Complex complex3 = complex2.ZERO.divide(complex1);
    Complex complex4 = complex0.log();
    Complex complex5 = complex4.INF.subtract(complex1);
    complex3.NaN.cos();
    double double0 = complex4.ZERO.abs();
    assertEquals(0.0, double0, 0.01);
}","/**
 * Return the absolute value of this complex number.
 * Returns {@code NaN} if either real or imaginary part is {@code NaN}
 * and {@code Double.POSITIVE_INFINITY} if neither part is {@code NaN},
 * but at least one part is infinite.
 *
 * @return the absolute value.
 */"
"public double abs() {
    if (isNaN) {
        return Double.NaN;
    }
    if (isInfinite()) {
        return Double.POSITIVE_INFINITY;
    }
    if (FastMath.abs(real) < FastMath.abs(imaginary)) {
        if (imaginary == 0.0) {
            return FastMath.abs(real);
        }
        double q = real / imaginary;
        return FastMath.abs(imaginary) * FastMath.sqrt(1 + q * q);
    } else {
        if (real == 0.0) {
            return FastMath.abs(imaginary);
        }
        double q = imaginary / real;
        return FastMath.abs(real) * FastMath.sqrt(1 + q * q);
    }
}","public void test03435() throws Throwable {
    Complex complex0 = new Complex(Double.NaN);
    Complex complex1 = complex0.NaN.atan();
    Complex complex2 = complex0.subtract(0.0);
    Complex complex3 = complex2.ZERO.divide(complex1);
    Complex complex4 = complex0.log();
    Complex complex5 = complex4.INF.subtract(complex1);
    complex3.NaN.cos();
    double double0 = complex4.ZERO.abs();
    Complex complex6 = complex0.sqrt1z();
    Complex complex7 = complex4.ONE.asin();
    Complex complex8 = complex7.tan();
    complex7.ZERO.negate();
    Complex complex9 = complex8.createComplex(0.0, (-300.57874955));
    Complex complex10 = complex9.INF.pow(complex6);
    Complex complex11 = complex9.NaN.acos();
    complex4.INF.toString();
    double double1 = complex0.abs();
    assertEquals(Double.NaN, double1, 0.01);
}","/**
 * Return the absolute value of this complex number.
 * Returns {@code NaN} if either real or imaginary part is {@code NaN}
 * and {@code Double.POSITIVE_INFINITY} if neither part is {@code NaN},
 * but at least one part is infinite.
 *
 * @return the absolute value.
 */"
"public Complex subtract(Complex subtrahend) throws NullArgumentException {
    MathUtils.checkNotNull(subtrahend);
    if (isNaN || subtrahend.isNaN) {
        return NaN;
    }
    return createComplex(real - subtrahend.getReal(), imaginary - subtrahend.getImaginary());
}","public void test03436() throws Throwable {
    Complex complex0 = new Complex(Double.NaN);
    Complex complex1 = complex0.NaN.atan();
    Complex complex2 = complex0.subtract(0.0);
    Complex complex3 = complex2.ZERO.divide(complex1);
    Complex complex4 = complex0.log();
    Complex complex5 = complex4.INF.subtract(complex1);
    complex3.NaN.cos();
    double double0 = complex4.ZERO.abs();
    Complex complex6 = complex0.sqrt1z();
    Complex complex7 = complex4.ONE.asin();
    Complex complex8 = complex7.tan();
    complex7.ZERO.negate();
    Complex complex9 = complex8.createComplex(0.0, (-300.57874955));
    Complex complex10 = complex9.INF.pow(complex6);
    Complex complex11 = complex9.NaN.acos();
    complex4.INF.toString();
    double double1 = complex0.abs();
    complex0.add(complex5);
    Complex complex12 = complex0.ONE.acos();
    complex5.toString();
    complex5.createComplex(Double.NaN, 5627.840250944935);
    Complex complex13 = Complex.valueOf((-1596.23024));
    complex3.log();
    Complex complex14 = complex13.subtract(complex8);
    assertSame(complex14, complex10);
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this - subtrahend)}.
 * Uses the definitional formula
 * <pre>
 *  <code>
 *   (a + bi) - (c + di) = (a-c) + (b-d)i
 *  </code>
 * </pre>
 * If either {@code this} or {@code subtrahend} has a {@code NaN]} value in either part,
 * {@link #NaN} is returned; otherwise infinite and {@code NaN} values are
 * returned in the parts of the result according to the rules for
 * {@link java.lang.Double} arithmetic.
 *
 * @param  subtrahend value to be subtracted from this {@code Complex}.
 * @return {@code this - subtrahend}.
 * @throws NullArgumentException if {@code subtrahend} is {@code null}.
 */"
"public double getReal() {
    return real;
}","public void test03437() throws Throwable {
    Complex complex0 = new Complex(Double.NaN);
    Complex complex1 = complex0.NaN.atan();
    Complex complex2 = complex0.subtract(0.0);
    Complex complex3 = complex2.ZERO.divide(complex1);
    Complex complex4 = complex0.log();
    Complex complex5 = complex4.INF.subtract(complex1);
    complex3.NaN.cos();
    double double0 = complex4.ZERO.abs();
    Complex complex6 = complex0.sqrt1z();
    Complex complex7 = complex4.ONE.asin();
    Complex complex8 = complex7.tan();
    complex7.ZERO.negate();
    Complex complex9 = complex8.createComplex(0.0, (-300.57874955));
    Complex complex10 = complex9.INF.pow(complex6);
    Complex complex11 = complex9.NaN.acos();
    complex4.INF.toString();
    double double1 = complex0.abs();
    complex0.add(complex5);
    Complex complex12 = complex0.ONE.acos();
    complex5.toString();
    complex5.createComplex(Double.NaN, 5627.840250944935);
    Complex complex13 = Complex.valueOf((-1596.23024));
    complex3.log();
    Complex complex14 = complex13.subtract(complex8);
    Complex complex15 = complex13.multiply((-61.25461971));
    complex2.createComplex(0.0, (-1506.638287109));
    complex8.multiply(3140);
    Complex complex16 = complex9.reciprocal();
    assertEquals(0.0, complex16.getReal(), 0.01);
}","/**
 * Access the real part.
 *
 * @return the real part.
 */"
"public double getImaginary() {
    return imaginary;
}","public void test03438() throws Throwable {
    Complex complex0 = new Complex(Double.NaN);
    Complex complex1 = complex0.NaN.atan();
    Complex complex2 = complex0.subtract(0.0);
    Complex complex3 = complex2.ZERO.divide(complex1);
    Complex complex4 = complex0.log();
    Complex complex5 = complex4.INF.subtract(complex1);
    complex3.NaN.cos();
    double double0 = complex4.ZERO.abs();
    Complex complex6 = complex0.sqrt1z();
    Complex complex7 = complex4.ONE.asin();
    Complex complex8 = complex7.tan();
    complex7.ZERO.negate();
    Complex complex9 = complex8.createComplex(0.0, (-300.57874955));
    Complex complex10 = complex9.INF.pow(complex6);
    Complex complex11 = complex9.NaN.acos();
    complex4.INF.toString();
    double double1 = complex0.abs();
    complex0.add(complex5);
    Complex complex12 = complex0.ONE.acos();
    complex5.toString();
    complex5.createComplex(Double.NaN, 5627.840250944935);
    Complex complex13 = Complex.valueOf((-1596.23024));
    complex3.log();
    Complex complex14 = complex13.subtract(complex8);
    Complex complex15 = complex13.multiply((-61.25461971));
    complex2.createComplex(0.0, (-1506.638287109));
    complex8.multiply(3140);
    Complex complex16 = complex9.reciprocal();
    List<Complex> list0 = complex15.nthRoot(3140);
    assertEquals(-0.0, complex15.getImaginary(), 0.01);
}","/**
 * Access the imaginary part.
 *
 * @return the imaginary part.
 */"
"public static Complex valueOf(double realPart) {
    if (Double.isNaN(realPart)) {
        return NaN;
    }
    return new Complex(realPart);
}","public void test03440() throws Throwable {
    Complex complex0 = new Complex(Double.NaN);
    Complex complex1 = complex0.NaN.atan();
    Complex complex2 = complex0.subtract(0.0);
    Complex complex3 = complex2.ZERO.divide(complex1);
    Complex complex4 = complex0.log();
    Complex complex5 = complex4.INF.subtract(complex1);
    complex3.NaN.cos();
    double double0 = complex4.ZERO.abs();
    Complex complex6 = complex0.sqrt1z();
    Complex complex7 = complex4.ONE.asin();
    Complex complex8 = complex7.tan();
    complex7.ZERO.negate();
    Complex complex9 = complex8.createComplex(0.0, (-300.57874955));
    Complex complex10 = complex9.INF.pow(complex6);
    Complex complex11 = complex9.NaN.acos();
    complex4.INF.toString();
    double double1 = complex0.abs();
    complex0.add(complex5);
    Complex complex12 = complex0.ONE.acos();
    complex5.toString();
    complex5.createComplex(Double.NaN, 5627.840250944935);
    Complex complex13 = Complex.valueOf((-1596.23024));
    complex3.log();
    Complex complex14 = complex13.subtract(complex8);
    Complex complex15 = complex13.multiply((-61.25461971));
    complex2.createComplex(0.0, (-1506.638287109));
    complex8.multiply(3140);
    Complex complex16 = complex9.reciprocal();
    List<Complex> list0 = complex15.nthRoot(3140);
    Complex complex17 = Complex.valueOf(Double.NaN);
    assertSame(complex17, complex2);
}","/**
 * Create a complex number given only the real part.
 *
 * @param realPart Real part.
 * @return a Complex instance.
 */"
"public Complex pow(Complex x) throws NullArgumentException {
    MathUtils.checkNotNull(x);
    return this.log().multiply(x).exp();
}","public void test03441() throws Throwable {
    Complex complex0 = new Complex(Double.NaN);
    Complex complex1 = complex0.NaN.atan();
    Complex complex2 = complex0.subtract(0.0);
    Complex complex3 = complex2.ZERO.divide(complex1);
    Complex complex4 = complex0.log();
    Complex complex5 = complex4.INF.subtract(complex1);
    complex3.NaN.cos();
    double double0 = complex4.ZERO.abs();
    Complex complex6 = complex0.sqrt1z();
    Complex complex7 = complex4.ONE.asin();
    Complex complex8 = complex7.tan();
    complex7.ZERO.negate();
    Complex complex9 = complex8.createComplex(0.0, (-300.57874955));
    Complex complex10 = complex9.INF.pow(complex6);
    Complex complex11 = complex9.NaN.acos();
    complex4.INF.toString();
    double double1 = complex0.abs();
    complex0.add(complex5);
    Complex complex12 = complex0.ONE.acos();
    complex5.toString();
    complex5.createComplex(Double.NaN, 5627.840250944935);
    Complex complex13 = Complex.valueOf((-1596.23024));
    complex3.log();
    Complex complex14 = complex13.subtract(complex8);
    Complex complex15 = complex13.multiply((-61.25461971));
    complex2.createComplex(0.0, (-1506.638287109));
    complex8.multiply(3140);
    Complex complex16 = complex9.reciprocal();
    List<Complex> list0 = complex15.nthRoot(3140);
    Complex complex17 = Complex.valueOf(Double.NaN);
    complex12.pow(complex8);
    assertSame(complex4, complex11);
}","/**
 * Returns of value of this complex number raised to the power of {@code x}.
 * Implements the formula:
 * <pre>
 *  <code>
 *   y<sup>x</sup> = exp(x&middot;log(y))
 *  </code>
 * </pre>
 * where {@code exp} and {@code log} are {@link #exp} and
 * {@link #log}, respectively.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite, or if {@code y}
 * equals {@link Complex#ZERO}.
 *
 * @param  x exponent to which this {@code Complex} is to be raised.
 * @return <code> this<sup>{@code x}</sup></code>.
 * @throws NullArgumentException if x is {@code null}.
 * @since 1.2
 */"
"public double getReal() {
    return real;
}","public void test03442() throws Throwable {
    Complex complex0 = new Complex(Double.NaN);
    Complex complex1 = complex0.NaN.atan();
    Complex complex2 = complex0.subtract(0.0);
    Complex complex3 = complex2.ZERO.divide(complex1);
    Complex complex4 = complex0.log();
    Complex complex5 = complex4.INF.subtract(complex1);
    complex3.NaN.cos();
    double double0 = complex4.ZERO.abs();
    Complex complex6 = complex0.sqrt1z();
    Complex complex7 = complex4.ONE.asin();
    Complex complex8 = complex7.tan();
    complex7.ZERO.negate();
    Complex complex9 = complex8.createComplex(0.0, (-300.57874955));
    Complex complex10 = complex9.INF.pow(complex6);
    Complex complex11 = complex9.NaN.acos();
    complex4.INF.toString();
    double double1 = complex0.abs();
    complex0.add(complex5);
    Complex complex12 = complex0.ONE.acos();
    complex5.toString();
    complex5.createComplex(Double.NaN, 5627.840250944935);
    Complex complex13 = Complex.valueOf((-1596.23024));
    complex3.log();
    Complex complex14 = complex13.subtract(complex8);
    Complex complex15 = complex13.multiply((-61.25461971));
    complex2.createComplex(0.0, (-1506.638287109));
    complex8.multiply(3140);
    Complex complex16 = complex9.reciprocal();
    List<Complex> list0 = complex15.nthRoot(3140);
    Complex complex17 = Complex.valueOf(Double.NaN);
    complex12.pow(complex8);
    assertEquals(Double.POSITIVE_INFINITY, complex8.getReal(), 0.01);
}","/**
 * Access the real part.
 *
 * @return the real part.
 */"
"public double getReal() {
    return real;
}","public void test03443() throws Throwable {
    Complex complex0 = new Complex(Double.NaN);
    Complex complex1 = complex0.NaN.atan();
    Complex complex2 = complex0.subtract(0.0);
    Complex complex3 = complex2.ZERO.divide(complex1);
    Complex complex4 = complex0.log();
    Complex complex5 = complex4.INF.subtract(complex1);
    complex3.NaN.cos();
    double double0 = complex4.ZERO.abs();
    Complex complex6 = complex0.sqrt1z();
    Complex complex7 = complex4.ONE.asin();
    Complex complex8 = complex7.tan();
    complex7.ZERO.negate();
    Complex complex9 = complex8.createComplex(0.0, (-300.57874955));
    Complex complex10 = complex9.INF.pow(complex6);
    Complex complex11 = complex9.NaN.acos();
    complex4.INF.toString();
    double double1 = complex0.abs();
    complex0.add(complex5);
    Complex complex12 = complex0.ONE.acos();
    complex5.toString();
    complex5.createComplex(Double.NaN, 5627.840250944935);
    Complex complex13 = Complex.valueOf((-1596.23024));
    complex3.log();
    Complex complex14 = complex13.subtract(complex8);
    Complex complex15 = complex13.multiply((-61.25461971));
    complex2.createComplex(0.0, (-1506.638287109));
    complex8.multiply(3140);
    Complex complex16 = complex9.reciprocal();
    List<Complex> list0 = complex15.nthRoot(3140);
    Complex complex17 = Complex.valueOf(Double.NaN);
    complex12.pow(complex8);
    assertEquals(0.0, complex12.getReal(), 0.01);
}","/**
 * Access the real part.
 *
 * @return the real part.
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Complex) {
        Complex c = (Complex) other;
        if (c.isNaN) {
            return isNaN;
        } else {
            return (real == c.real) && (imaginary == c.imaginary);
        }
    }
    return false;
}","public void test03444() throws Throwable {
    Complex complex0 = new Complex(Double.NaN);
    Complex complex1 = complex0.NaN.atan();
    Complex complex2 = complex0.subtract(0.0);
    Complex complex3 = complex2.ZERO.divide(complex1);
    Complex complex4 = complex0.log();
    Complex complex5 = complex4.INF.subtract(complex1);
    complex3.NaN.cos();
    double double0 = complex4.ZERO.abs();
    Complex complex6 = complex0.sqrt1z();
    Complex complex7 = complex4.ONE.asin();
    Complex complex8 = complex7.tan();
    complex7.ZERO.negate();
    Complex complex9 = complex8.createComplex(0.0, (-300.57874955));
    Complex complex10 = complex9.INF.pow(complex6);
    Complex complex11 = complex9.NaN.acos();
    complex4.INF.toString();
    double double1 = complex0.abs();
    complex0.add(complex5);
    Complex complex12 = complex0.ONE.acos();
    complex5.toString();
    complex5.createComplex(Double.NaN, 5627.840250944935);
    Complex complex13 = Complex.valueOf((-1596.23024));
    complex3.log();
    Complex complex14 = complex13.subtract(complex8);
    Complex complex15 = complex13.multiply((-61.25461971));
    complex2.createComplex(0.0, (-1506.638287109));
    complex8.multiply(3140);
    Complex complex16 = complex9.reciprocal();
    List<Complex> list0 = complex15.nthRoot(3140);
    Complex complex17 = Complex.valueOf(Double.NaN);
    complex12.pow(complex8);
    assertFalse(complex12.equals((Object) complex16));
}","/**
 * Test for the equality of two Complex objects.
 * If both the real and imaginary parts of two complex numbers
 * are exactly the same, and neither is {@code Double.NaN}, the two
 * Complex objects are considered to be equal.
 * All {@code NaN} values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to {@code Double.NaN}, the complex number is equal to
 * {@code NaN}.
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if object is
 * {@code null}, not an instance of Complex, or not equal to this Complex
 * instance.
 */"
"public Complex reciprocal() {
    if (isNaN) {
        return NaN;
    }
    if (real == 0.0 && imaginary == 0.0) {
        return NaN;
    }
    if (isInfinite) {
        return ZERO;
    }
    if (FastMath.abs(real) < FastMath.abs(imaginary)) {
        double q = real / imaginary;
        double scale = 1. / (real * q + imaginary);
        return createComplex(scale * q, -scale);
    } else {
        double q = imaginary / real;
        double scale = 1. / (imaginary * q + real);
        return createComplex(scale, -scale * q);
    }
}","public void test03545() throws Throwable {
    Complex complex0 = Complex.INF;
    complex0.ONE.reciprocal();
    complex0.I.getField();
    complex0.I.subtract(1853.3643);
    Complex complex1 = Complex.NaN;
    complex0.equals(complex1);
    Complex complex2 = Complex.valueOf(0.0, 0.0);
    Complex complex3 = complex2.INF.subtract((-20.0));
    Complex complex4 = complex2.sin();
    Complex complex5 = complex4.ZERO.divide((-20.0));
    complex5.ONE.add(complex3);
    complex3.tanh();
    complex4.reciprocal();
}","/**
 * {@inheritDoc}
 */"
"public double abs() {
    if (isNaN) {
        return Double.NaN;
    }
    if (isInfinite()) {
        return Double.POSITIVE_INFINITY;
    }
    if (FastMath.abs(real) < FastMath.abs(imaginary)) {
        if (imaginary == 0.0) {
            return FastMath.abs(real);
        }
        double q = real / imaginary;
        return FastMath.abs(imaginary) * FastMath.sqrt(1 + q * q);
    } else {
        if (real == 0.0) {
            return FastMath.abs(imaginary);
        }
        double q = imaginary / real;
        return FastMath.abs(real) * FastMath.sqrt(1 + q * q);
    }
}","public void test03646() throws Throwable {
    Complex complex0 = new Complex(Double.NaN);
    Complex complex1 = complex0.createComplex(1.356201171875, Double.NaN);
    complex0.ZERO.cosh();
    complex1.I.asin();
    Complex complex2 = complex0.INF.sqrt();
    Complex complex3 = complex2.NaN.atan();
    complex0.I.reciprocal();
    Complex complex4 = complex0.createComplex(Double.NaN, Double.NaN);
    complex4.ONE.sinh();
    Complex complex5 = complex0.subtract(1.356201171875);
    complex5.ONE.multiply(Double.NaN);
    Complex complex6 = complex5.sin();
    complex3.atan();
    complex3.pow(complex6);
    complex6.abs();
}","/**
 * Return the absolute value of this complex number.
 * Returns {@code NaN} if either real or imaginary part is {@code NaN}
 * and {@code Double.POSITIVE_INFINITY} if neither part is {@code NaN},
 * but at least one part is infinite.
 *
 * @return the absolute value.
 */"
"public Complex subtract(double subtrahend) {
    if (isNaN || Double.isNaN(subtrahend)) {
        return NaN;
    }
    return createComplex(real - subtrahend, imaginary);
}","public void test03747() throws Throwable {
    Complex complex0 = new Complex(0.0, 0.0);
    complex0.subtract(0.0);
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this - subtrahend)}.
 *
 * @param  subtrahend value to be subtracted from this {@code Complex}.
 * @return {@code this - subtrahend}.
 * @see #subtract(Complex)
 */"
"public Complex multiply(Complex factor) throws NullArgumentException {
    MathUtils.checkNotNull(factor);
    if (isNaN || factor.isNaN) {
        return NaN;
    }
    if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(factor.real) || Double.isInfinite(factor.imaginary)) {
        // we don't use isInfinite() to avoid testing for NaN again
        return INF;
    }
    return createComplex(real * factor.real - imaginary * factor.imaginary, real * factor.imaginary + imaginary * factor.real);
}","public void test03848() throws Throwable {
    Complex complex0 = Complex.valueOf(2.0, 2.0);
    complex0.abs();
    Complex complex1 = Complex.valueOf(0.0, (-2532.4582014));
    complex1.ZERO.nthRoot(1);
    Complex complex2 = complex0.subtract(890.0);
    Complex complex3 = complex2.tan();
    Complex complex4 = complex3.pow(complex2);
    Complex complex5 = complex2.reciprocal();
    complex2.I.atan();
    complex3.cosh();
    Complex complex6 = complex0.I.tanh();
    Complex complex7 = complex5.divide((-2324.9947));
    complex7.INF.exp();
    complex3.ONE.subtract((-2838.56312075));
    complex3.isInfinite();
    Complex complex8 = complex0.exp();
    complex4.pow((-853.2));
    Complex complex9 = complex0.multiply(complex6);
    complex9.ZERO.conjugate();
    Complex complex10 = complex8.pow(complex2);
    Complex complex11 = Complex.valueOf(2.8284271247461903, 154.29284748061);
    complex10.multiply(complex11);
}","/**
 * Returns a {@code Complex} whose value is {@code this * factor}.
 * Implements preliminary checks for {@code NaN} and infinity followed by
 * the definitional formula:
 * <pre>
 *  <code>
 *   (a + bi)(c + di) = (ac - bd) + (ad + bc)i
 *  </code>
 * </pre>
 * Returns {@link #NaN} if either {@code this} or {@code factor} has one or
 * more {@code NaN} parts.
 * <br/>
 * Returns {@link #INF} if neither {@code this} nor {@code factor} has one
 * or more {@code NaN} parts and if either {@code this} or {@code factor}
 * has one or more infinite parts (same result is returned regardless of
 * the sign of the components).
 * <br/>
 * Returns finite values in components of the result per the definitional
 * formula in all remaining cases.
 *
 * @param  factor value to be multiplied by this {@code Complex}.
 * @return {@code this * factor}.
 * @throws NullArgumentException if {@code factor} is {@code null}.
 */"
"public Complex pow(Complex x) throws NullArgumentException {
    MathUtils.checkNotNull(x);
    return this.log().multiply(x).exp();
}","public void test03949() throws Throwable {
    Complex complex0 = Complex.valueOf((-3422.8));
    Complex complex1 = complex0.negate();
    complex1.pow(complex0);
}","/**
 * Returns of value of this complex number raised to the power of {@code x}.
 * Implements the formula:
 * <pre>
 *  <code>
 *   y<sup>x</sup> = exp(x&middot;log(y))
 *  </code>
 * </pre>
 * where {@code exp} and {@code log} are {@link #exp} and
 * {@link #log}, respectively.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite, or if {@code y}
 * equals {@link Complex#ZERO}.
 *
 * @param  x exponent to which this {@code Complex} is to be raised.
 * @return <code> this<sup>{@code x}</sup></code>.
 * @throws NullArgumentException if x is {@code null}.
 * @since 1.2
 */"
"public Complex sqrt1z() {
    return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();
}","public void test04050() throws Throwable {
    Complex complex0 = new Complex((-18.5323301726));
    Complex complex1 = complex0.ZERO.asin();
    Complex complex2 = complex0.add((-18.5323301726));
    Complex complex3 = complex2.ONE.negate();
    Complex complex4 = complex3.ONE.subtract(complex0);
    complex0.isInfinite();
    complex4.NaN.acos();
    Complex complex5 = complex0.sinh();
    Complex complex6 = complex1.acos();
    complex0.ONE.subtract(complex1);
    complex6.I.conjugate();
    Complex complex7 = complex2.multiply(complex4);
    complex5.tan();
    complex0.tan();
    complex7.sqrt1z();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/SquareRoot.html"" TARGET=""_top"">
 * square root</a> of <code>1 - this<sup>2</sup></code> for this complex
 * number.
 * Computes the result directly as
 * {@code sqrt(ONE.subtract(z.multiply(z)))}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 *
 * @return the square root of <code>1 - this<sup>2</sup></code>.
 * @since 1.2
 */"
"public Complex cosh() {
    if (isNaN) {
        return NaN;
    }
    return createComplex(FastMath.cosh(real) * FastMath.cos(imaginary), FastMath.sinh(real) * FastMath.sin(imaginary));
}","public void test04151() throws Throwable {
    Complex complex0 = new Complex(2.0, 1.4380402565002441);
    Complex complex1 = new Complex(1.4380402565002441, 1.4380402565002441);
    Complex complex2 = complex0.pow(complex1);
    Complex complex3 = Complex.ONE;
    complex2.subtract(complex3);
    complex0.divide(complex1);
    complex0.NaN.conjugate();
    complex0.negate();
    complex2.cosh();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/HyperbolicCosine.html"" TARGET=""_top"">
 * hyperbolic cosine</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i}
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link FastMath#cosh} and {@link FastMath#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   cosh(1 &plusmn; INFINITY i) = NaN + NaN i
 *   cosh(&plusmn;INFINITY + i) = INFINITY &plusmn; INFINITY i
 *   cosh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *  </code>
 * </pre>
 *
 * @return the hyperbolic cosine of this complex number.
 * @since 1.2
 */"
"public Complex cos() {
    if (isNaN) {
        return NaN;
    }
    return createComplex(FastMath.cos(real) * FastMath.cosh(imaginary), -FastMath.sin(real) * FastMath.sinh(imaginary));
}","public void test04252() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = Complex.valueOf(410.74671926924213);
    complex0.ZERO.multiply(617.3);
    Complex complex2 = complex1.ONE.createComplex(410.74671926924213, (-3737.74531));
    complex2.I.divide(1330.447275424);
    Complex complex3 = complex1.divide(410.74671926924213);
    complex3.acos();
    complex0.multiply(complex1);
    complex2.cos();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Cosine.html"" TARGET=""_top"">
 * cosine</a>
 * of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link FastMath#cosh} and {@link FastMath#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   cos(1 &plusmn; INFINITY i) = 1 &#x2213; INFINITY i
 *   cos(&plusmn;INFINITY + i) = NaN + NaN i
 *   cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *  </code>
 * </pre>
 *
 * @return the cosine of this complex number.
 * @since 1.2
 */"
"public Complex pow(Complex x) throws NullArgumentException {
    MathUtils.checkNotNull(x);
    return this.log().multiply(x).exp();
}","public void test04353() throws Throwable {
    Complex complex0 = new Complex((-3142.95));
    Complex complex1 = complex0.acos();
    Complex complex2 = complex1.INF.conjugate();
    complex0.ZERO.nthRoot(477);
    Complex complex3 = complex2.INF.exp();
    Complex complex4 = complex0.sin();
    Complex complex5 = complex4.multiply(complex0);
    Complex complex6 = complex1.cos();
    complex2.toString();
    Complex complex7 = complex2.negate();
    complex7.acos();
    complex7.isInfinite();
    complex6.getField();
    Complex complex8 = complex5.pow((-3142.95));
    complex8.I.nthRoot(477);
    complex8.getReal();
    complex1.add((double) 477);
    complex2.abs();
    complex1.readResolve();
    complex4.log();
    complex7.subtract(Double.POSITIVE_INFINITY);
    complex8.pow(complex3);
}","/**
 * Returns of value of this complex number raised to the power of {@code x}.
 * Implements the formula:
 * <pre>
 *  <code>
 *   y<sup>x</sup> = exp(x&middot;log(y))
 *  </code>
 * </pre>
 * where {@code exp} and {@code log} are {@link #exp} and
 * {@link #log}, respectively.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite, or if {@code y}
 * equals {@link Complex#ZERO}.
 *
 * @param  x exponent to which this {@code Complex} is to be raised.
 * @return <code> this<sup>{@code x}</sup></code>.
 * @throws NullArgumentException if x is {@code null}.
 * @since 1.2
 */"
"public Complex multiply(Complex factor) throws NullArgumentException {
    MathUtils.checkNotNull(factor);
    if (isNaN || factor.isNaN) {
        return NaN;
    }
    if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(factor.real) || Double.isInfinite(factor.imaginary)) {
        // we don't use isInfinite() to avoid testing for NaN again
        return INF;
    }
    return createComplex(real * factor.real - imaginary * factor.imaginary, real * factor.imaginary + imaginary * factor.real);
}","public void test04454() throws Throwable {
    Complex complex0 = Complex.valueOf((-2152.884662036));
    Complex complex1 = complex0.cos();
    Complex complex2 = complex0.INF.add(81.0383094);
    complex2.INF.exp();
    complex0.getImaginary();
    Complex complex3 = complex1.ONE.pow(0.0);
    Complex complex4 = complex0.multiply(complex2);
    Complex complex5 = complex4.negate();
    complex5.ZERO.sqrt1z();
    complex5.divide(37.32);
    complex1.log();
    complex1.sin();
    complex3.multiply(complex5);
}","/**
 * Returns a {@code Complex} whose value is {@code this * factor}.
 * Implements preliminary checks for {@code NaN} and infinity followed by
 * the definitional formula:
 * <pre>
 *  <code>
 *   (a + bi)(c + di) = (ac - bd) + (ad + bc)i
 *  </code>
 * </pre>
 * Returns {@link #NaN} if either {@code this} or {@code factor} has one or
 * more {@code NaN} parts.
 * <br/>
 * Returns {@link #INF} if neither {@code this} nor {@code factor} has one
 * or more {@code NaN} parts and if either {@code this} or {@code factor}
 * has one or more infinite parts (same result is returned regardless of
 * the sign of the components).
 * <br/>
 * Returns finite values in components of the result per the definitional
 * formula in all remaining cases.
 *
 * @param  factor value to be multiplied by this {@code Complex}.
 * @return {@code this * factor}.
 * @throws NullArgumentException if {@code factor} is {@code null}.
 */"
"public List<Complex> nthRoot(int n) throws NotPositiveException {
    if (n <= 0) {
        throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N, n);
    }
    final List<Complex> result = new ArrayList<Complex>();
    if (isNaN) {
        result.add(NaN);
        return result;
    }
    if (isInfinite()) {
        result.add(INF);
        return result;
    }
    // nth root of abs -- faster / more accurate to use a solver here?
    final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);
    // Compute nth roots of complex number with k = 0, 1, ... n-1
    final double nthPhi = getArgument() / n;
    final double slice = 2 * FastMath.PI / n;
    double innerPart = nthPhi;
    for (int k = 0; k < n; k++) {
        // inner part
        final double realPart = nthRootOfAbs * FastMath.cos(innerPart);
        final double imaginaryPart = nthRootOfAbs * FastMath.sin(innerPart);
        result.add(createComplex(realPart, imaginaryPart));
        innerPart += slice;
    }
    return result;
}","public void test04555() throws Throwable {
    Complex complex0 = Complex.NaN;
    complex0.cos();
    Complex complex1 = complex0.ONE.acos();
    try {
        complex1.INF.nthRoot(0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot compute nth root for null or negative n: 0
        //
        verifyException(""org.apache.commons.math3.complex.Complex"", e);
    }
}","/**
 * Computes the n-th roots of this complex number.
 * The nth roots are defined by the formula:
 * <pre>
 *  <code>
 *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))
 *  </code>
 * </pre>
 * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}
 * are respectively the {@link #abs() modulus} and
 * {@link #getArgument() argument} of this complex number.
 * <br/>
 * If one or both parts of this complex number is NaN, a list with just
 * one element, {@link #NaN} is returned.
 * if neither part is NaN, but at least one part is infinite, the result
 * is a one-element list containing {@link #INF}.
 *
 * @param n Degree of root.
 * @return a List<Complex> of all {@code n}-th roots of {@code this}.
 * @throws NotPositiveException if {@code n <= 0}.
 * @since 2.0
 */"
"protected Complex createComplex(double realPart, double imaginaryPart) {
    return new Complex(realPart, imaginaryPart);
}","public void test04656() throws Throwable {
    Complex complex0 = new Complex(0.0, 5.203033137154554E-8);
    Complex complex1 = complex0.ONE.exp();
    Complex complex2 = complex1.I.negate();
    complex2.NaN.multiply(5.203033137154554E-8);
    complex0.nthRoot(775);
    complex1.getImaginary();
    Complex complex3 = complex1.pow(complex2);
    Object object0 = complex3.readResolve();
    complex2.equals(object0);
    complex0.pow(complex1);
    complex3.createComplex(0.0, 1.0);
}","/**
 * Create a complex number given the real and imaginary parts.
 *
 * @param realPart Real part.
 * @param imaginaryPart Imaginary part.
 * @return a new complex number instance.
 * @since 1.2
 * @see #valueOf(double, double)
 */"
"public Complex multiply(Complex factor) throws NullArgumentException {
    MathUtils.checkNotNull(factor);
    if (isNaN || factor.isNaN) {
        return NaN;
    }
    if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(factor.real) || Double.isInfinite(factor.imaginary)) {
        // we don't use isInfinite() to avoid testing for NaN again
        return INF;
    }
    return createComplex(real * factor.real - imaginary * factor.imaginary, real * factor.imaginary + imaginary * factor.real);
}","public void test04757() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = Complex.ONE;
    Complex complex2 = complex1.ZERO.pow(complex0);
    complex2.tan();
    Complex complex3 = complex0.subtract(complex1);
    try {
        complex3.multiply((Complex) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // null is not allowed
        //
        verifyException(""org.apache.commons.math3.util.MathUtils"", e);
    }
}","/**
 * Returns a {@code Complex} whose value is {@code this * factor}.
 * Implements preliminary checks for {@code NaN} and infinity followed by
 * the definitional formula:
 * <pre>
 *  <code>
 *   (a + bi)(c + di) = (ac - bd) + (ad + bc)i
 *  </code>
 * </pre>
 * Returns {@link #NaN} if either {@code this} or {@code factor} has one or
 * more {@code NaN} parts.
 * <br/>
 * Returns {@link #INF} if neither {@code this} nor {@code factor} has one
 * or more {@code NaN} parts and if either {@code this} or {@code factor}
 * has one or more infinite parts (same result is returned regardless of
 * the sign of the components).
 * <br/>
 * Returns finite values in components of the result per the definitional
 * formula in all remaining cases.
 *
 * @param  factor value to be multiplied by this {@code Complex}.
 * @return {@code this * factor}.
 * @throws NullArgumentException if {@code factor} is {@code null}.
 */"
"public boolean isNaN() {
    return isNaN;
}","public void test04858() throws Throwable {
    Complex complex0 = Complex.ONE;
    complex0.hashCode();
    complex0.NaN.tanh();
    complex0.INF.getField();
    Complex complex1 = complex0.I.add(2.037139607241041E305);
    Complex complex2 = complex1.multiply(complex0);
    Complex complex3 = complex0.acos();
    complex0.toString();
    Complex complex4 = complex3.cosh();
    Complex complex5 = Complex.valueOf(2.037139607241041E305);
    complex5.NaN.sqrt();
    complex4.NaN.getArgument();
    Complex complex6 = complex1.tanh();
    Complex complex7 = complex6.ZERO.createComplex(2.037139607241041E305, (-629.2));
    complex7.I.divide(Double.NaN);
    complex1.add(complex0);
    complex0.tan();
    complex2.negate();
    complex2.isNaN();
}","/**
 * Checks whether either or both parts of this complex number is
 * {@code NaN}.
 *
 * @return true if either or both parts of this complex number is
 * {@code NaN}; false otherwise.
 */"
"public Complex add(double addend) {
    if (isNaN || Double.isNaN(addend)) {
        return NaN;
    }
    return createComplex(real + addend, imaginary);
}","public void test04959() throws Throwable {
    Complex complex0 = new Complex((-2236.84), (-2236.84));
    Complex complex1 = Complex.valueOf((-2236.84));
    complex0.INF.abs();
    Complex complex2 = Complex.valueOf((-2180.971));
    complex0.abs();
    Complex complex3 = complex2.pow(Double.POSITIVE_INFINITY);
    complex3.ONE.sinh();
    complex1.acos();
    complex2.add(1851.6813594113);
}","/**
 * Returns a {@code Complex} whose value is {@code (this + addend)},
 * with {@code addend} interpreted as a real number.
 *
 * @param addend Value to be added to this {@code Complex}.
 * @return {@code this + addend}.
 * @see #add(Complex)
 */"
"public Complex sin() {
    if (isNaN) {
        return NaN;
    }
    return createComplex(FastMath.sin(real) * FastMath.cosh(imaginary), FastMath.cos(real) * FastMath.sinh(imaginary));
}","public void test05060() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = new Complex(0.0);
    complex0.subtract(complex1);
    complex0.readResolve();
    complex0.sin();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Sine.html"" TARGET=""_top"">
 * sine</a>
 * of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link FastMath#cosh} and {@link FastMath#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or {@code NaN} values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   sin(1 &plusmn; INFINITY i) = 1 &plusmn; INFINITY i
 *   sin(&plusmn;INFINITY + i) = NaN + NaN i
 *   sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *  </code>
 * </pre>
 *
 * @return the sine of this complex number.
 * @since 1.2
 */"
"public Complex subtract(Complex subtrahend) throws NullArgumentException {
    MathUtils.checkNotNull(subtrahend);
    if (isNaN || subtrahend.isNaN) {
        return NaN;
    }
    return createComplex(real - subtrahend.getReal(), imaginary - subtrahend.getImaginary());
}","public void test05161() throws Throwable {
    Complex complex0 = Complex.ZERO;
    complex0.ONE.getField();
    Complex complex1 = complex0.exp();
    Complex complex2 = complex1.ONE.asin();
    Complex complex3 = complex1.NaN.acos();
    complex1.INF.abs();
    complex0.ZERO.divide(Double.POSITIVE_INFINITY);
    complex1.tan();
    Complex complex4 = complex1.ZERO.pow(complex0);
    Complex complex5 = complex4.INF.pow(complex3);
    complex5.INF.tanh();
    Complex complex6 = complex1.INF.atan();
    complex2.NaN.abs();
    Complex.valueOf(0.0);
    Complex complex7 = complex2.multiply(728);
    Complex complex8 = complex1.pow(complex0);
    complex7.pow((-2978.708));
    complex1.isInfinite();
    complex8.getReal();
    try {
        complex6.subtract((Complex) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // null is not allowed
        //
        verifyException(""org.apache.commons.math3.util.MathUtils"", e);
    }
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this - subtrahend)}.
 * Uses the definitional formula
 * <pre>
 *  <code>
 *   (a + bi) - (c + di) = (a-c) + (b-d)i
 *  </code>
 * </pre>
 * If either {@code this} or {@code subtrahend} has a {@code NaN]} value in either part,
 * {@link #NaN} is returned; otherwise infinite and {@code NaN} values are
 * returned in the parts of the result according to the rules for
 * {@link java.lang.Double} arithmetic.
 *
 * @param  subtrahend value to be subtracted from this {@code Complex}.
 * @return {@code this - subtrahend}.
 * @throws NullArgumentException if {@code subtrahend} is {@code null}.
 */"
"public boolean isInfinite() {
    return isInfinite;
}","public void test05262() throws Throwable {
    Complex complex0 = Complex.INF;
    complex0.INF.divide(Double.NaN);
    Complex complex1 = complex0.ZERO.sin();
    complex1.ONE.pow(Double.NaN);
    complex0.isInfinite();
}","/**
 * Checks whether either the real or imaginary part of this complex number
 * takes an infinite value (either {@code Double.POSITIVE_INFINITY} or
 * {@code Double.NEGATIVE_INFINITY}) and neither part
 * is {@code NaN}.
 *
 * @return true if one or both parts of this complex number are infinite
 * and neither part is {@code NaN}.
 */"
"protected final Object readResolve() {
    return createComplex(real, imaginary);
}","public void test05363() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = complex0.I.log();
    Complex complex2 = complex0.exp();
    complex2.multiply(complex1);
    Complex complex3 = complex0.exp();
    Complex complex4 = complex3.negate();
    Complex complex5 = complex3.multiply(981305269);
    Complex complex6 = complex3.atan();
    Complex complex7 = complex4.add((double) 981305269);
    Complex complex8 = complex7.acos();
    Complex complex9 = complex4.multiply(981305269);
    complex9.NaN.getArgument();
    complex7.toString();
    complex2.equals(complex5);
    Complex complex10 = complex6.exp();
    complex10.getField();
    Complex complex11 = complex3.tanh();
    complex11.I.cosh();
    complex11.NaN.divide(Double.NaN);
    complex11.log();
    Complex complex12 = complex8.add(complex1);
    complex12.readResolve();
}","/**
 * Resolve the transient fields in a deserialized Complex Object.
 * Subclasses will need to override {@link #createComplex} to
 * deserialize properly.
 *
 * @return A Complex instance with all fields resolved.
 * @since 2.0
 */"
"public ComplexField getField() {
    return ComplexField.getInstance();
}","public void test05464() throws Throwable {
    Complex complex0 = Complex.valueOf((-2350.488384));
    complex0.negate();
    Complex complex1 = complex0.ONE.cosh();
    complex1.ZERO.divide((-1.0));
    Complex complex2 = complex0.NaN.sinh();
    Complex complex3 = complex1.NaN.divide(complex2);
    Complex complex4 = complex3.ZERO.asin();
    complex3.nthRoot(1);
    Complex complex5 = complex0.atan();
    Complex complex6 = complex5.ZERO.sqrt1z();
    complex6.tanh();
    complex5.NaN.readResolve();
    complex0.cosh();
    Complex complex7 = complex5.tan();
    complex1.ONE.pow(complex2);
    Complex complex8 = complex1.divide(complex7);
    complex8.toString();
    complex2.isInfinite();
    complex4.getField();
}","/**
 * {@inheritDoc}
 */"
"public boolean isInfinite() {
    return isInfinite;
}","public void test05565() throws Throwable {
    Complex complex0 = new Complex(0.42926812171936035);
    complex0.isInfinite();
    Complex complex1 = Complex.INF;
    complex0.pow(complex1);
    complex0.isInfinite();
}","/**
 * Checks whether either the real or imaginary part of this complex number
 * takes an infinite value (either {@code Double.POSITIVE_INFINITY} or
 * {@code Double.NEGATIVE_INFINITY}) and neither part
 * is {@code NaN}.
 *
 * @return true if one or both parts of this complex number are infinite
 * and neither part is {@code NaN}.
 */"
"public Complex multiply(final int factor) {
    if (isNaN) {
        return NaN;
    }
    if (Double.isInfinite(real) || Double.isInfinite(imaginary)) {
        return INF;
    }
    return createComplex(real * factor, imaginary * factor);
}","public void test05666() throws Throwable {
    Complex complex0 = Complex.NaN;
    complex0.multiply((-2006));
}","/**
 * Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}
 * interpreted as a integer number.
 *
 * @param  factor value to be multiplied by this {@code Complex}.
 * @return {@code this * factor}.
 * @see #multiply(Complex)
 */"
"public double getImaginary() {
    return imaginary;
}","public void test05767() throws Throwable {
    Complex complex0 = new Complex((-4457.8323));
    Complex complex1 = complex0.I.add((-4457.8323));
    complex1.I.divide((-1045.278543));
    Complex complex2 = complex0.atan();
    complex2.getReal();
    complex2.sqrt1z();
    complex0.exp();
    complex1.getImaginary();
}","/**
 * Access the imaginary part.
 *
 * @return the imaginary part.
 */"
"public double getImaginary() {
    return imaginary;
}","public void test05868() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = Complex.INF;
    complex1.ONE.log();
    Complex.valueOf(0.0);
    Complex complex2 = complex0.add(complex1);
    complex2.getImaginary();
}","/**
 * Access the imaginary part.
 *
 * @return the imaginary part.
 */"
"public boolean isInfinite() {
    return isInfinite;
}","public void test05969() throws Throwable {
    Complex complex0 = new Complex(79.1515712, (-20.0));
    Complex complex1 = complex0.tan();
    Complex complex2 = complex0.ONE.sinh();
    Complex complex3 = complex2.INF.divide(0.0);
    complex1.getImaginary();
    complex0.getField();
    complex2.getArgument();
    Complex complex4 = complex1.sqrt1z();
    Complex complex5 = complex4.NaN.asin();
    Complex complex6 = complex5.INF.acos();
    Complex complex7 = complex1.sqrt1z();
    complex7.hashCode();
    complex0.hashCode();
    complex7.tanh();
    complex0.add(complex2);
    Complex complex8 = complex6.add((-1.0));
    complex8.subtract(complex3);
    complex2.isInfinite();
}","/**
 * Checks whether either the real or imaginary part of this complex number
 * takes an infinite value (either {@code Double.POSITIVE_INFINITY} or
 * {@code Double.NEGATIVE_INFINITY}) and neither part
 * is {@code NaN}.
 *
 * @return true if one or both parts of this complex number are infinite
 * and neither part is {@code NaN}.
 */"
"public Complex acos() {
    if (isNaN) {
        return NaN;
    }
    return this.add(this.sqrt1z().multiply(I)).log().multiply(I.negate());
}","public void test06070() throws Throwable {
    Complex complex0 = Complex.ZERO;
    complex0.NaN.nthRoot(1);
    complex0.acos();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/InverseCosine.html"" TARGET=""_top"">
 * inverse cosine</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))
 *  </code>
 * </pre>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite.
 *
 * @return the inverse cosine of this complex number.
 * @since 1.2
 */"
"public Complex add(double addend) {
    if (isNaN || Double.isNaN(addend)) {
        return NaN;
    }
    return createComplex(real + addend, imaginary);
}","public void test06171() throws Throwable {
    Complex complex0 = new Complex((-189.44), 0.3870677351951599);
    complex0.NaN.cos();
    Complex.valueOf((-189.44));
    Complex complex1 = complex0.sinh();
    complex0.isInfinite();
    complex0.conjugate();
    complex0.getImaginary();
    complex1.add(3615.8);
}","/**
 * Returns a {@code Complex} whose value is {@code (this + addend)},
 * with {@code addend} interpreted as a real number.
 *
 * @param addend Value to be added to this {@code Complex}.
 * @return {@code this + addend}.
 * @see #add(Complex)
 */"
"public Complex tan() {
    if (isNaN || Double.isInfinite(real)) {
        return NaN;
    }
    if (imaginary > 20.0) {
        return createComplex(0.0, 1.0);
    }
    if (imaginary < -20.0) {
        return createComplex(0.0, -1.0);
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = FastMath.cos(real2) + FastMath.cosh(imaginary2);
    return createComplex(FastMath.sin(real2) / d, FastMath.sinh(imaginary2) / d);
}","public void test06272() throws Throwable {
    Complex complex0 = Complex.valueOf(809.662269086, (-2164.175568227));
    complex0.tan();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Tangent.html"" TARGET=""_top"">
 * tangent</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and
 * {@link FastMath#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   tan(a &plusmn; INFINITY i) = 0 &plusmn; i
 *   tan(&plusmn;INFINITY + bi) = NaN + NaN i
 *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *   tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i
 *  </code>
 * </pre>
 *
 * @return the tangent of {@code this}.
 * @since 1.2
 */"
"public Complex multiply(final int factor) {
    if (isNaN) {
        return NaN;
    }
    if (Double.isInfinite(real) || Double.isInfinite(imaginary)) {
        return INF;
    }
    return createComplex(real * factor, imaginary * factor);
}","public void test06373() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.tanh();
    Complex complex2 = complex1.tan();
    complex2.INF.cosh();
    complex1.I.conjugate();
    complex2.cos();
    complex1.divide(0.0);
    complex1.hashCode();
    complex1.multiply(730);
}","/**
 * Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}
 * interpreted as a integer number.
 *
 * @param  factor value to be multiplied by this {@code Complex}.
 * @return {@code this * factor}.
 * @see #multiply(Complex)
 */"
"public Complex asin() {
    if (isNaN) {
        return NaN;
    }
    return sqrt1z().add(this.multiply(I)).log().multiply(I.negate());
}","public void test06474() throws Throwable {
    Complex complex0 = new Complex(459.557442, Double.POSITIVE_INFINITY);
    complex0.NaN.getField();
    complex0.INF.getArgument();
    complex0.toString();
    complex0.asin();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/InverseSine.html"" TARGET=""_top"">
 * inverse sine</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz))
 *  </code>
 * </pre>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite.
 *
 * @return the inverse sine of this complex number.
 * @since 1.2
 */"
"public boolean isNaN() {
    return isNaN;
}","public void test06575() throws Throwable {
    Complex complex0 = new Complex(0.0);
    Complex complex1 = complex0.negate();
    complex1.ONE.hashCode();
    Complex complex2 = complex0.pow(0.0);
    Complex complex3 = complex0.createComplex(2454.90173, 2454.90173);
    Complex complex4 = complex3.NaN.sqrt();
    complex0.getImaginary();
    complex0.add(2454.90173);
    complex2.multiply(0.0);
    complex4.isNaN();
}","/**
 * Checks whether either or both parts of this complex number is
 * {@code NaN}.
 *
 * @return true if either or both parts of this complex number is
 * {@code NaN}; false otherwise.
 */"
"public Complex sqrt() {
    if (isNaN) {
        return NaN;
    }
    if (real == 0.0 && imaginary == 0.0) {
        return createComplex(0.0, 0.0);
    }
    double t = FastMath.sqrt((FastMath.abs(real) + abs()) / 2.0);
    if (real >= 0.0) {
        return createComplex(t, imaginary / (2.0 * t));
    } else {
        return createComplex(FastMath.abs(imaginary) / (2.0 * t), FastMath.copySign(1d, imaginary) * t);
    }
}","public void test06676() throws Throwable {
    Complex complex0 = Complex.valueOf(0.0, 0.0);
    Complex complex1 = Complex.ZERO;
    Complex complex2 = complex0.ONE.add(complex1);
    complex2.subtract(complex0);
    Complex complex3 = complex0.ZERO.reciprocal();
    complex0.nthRoot(1);
    Complex complex4 = complex3.ONE.conjugate();
    complex4.tanh();
    complex0.sqrt1z();
    complex3.divide(complex0);
    complex1.sqrt();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/SquareRoot.html"" TARGET=""_top"">
 * square root</a> of this complex number.
 * Implements the following algorithm to compute {@code sqrt(a + bi)}:
 * <ol><li>Let {@code t = sqrt((|a| + |a + bi|) / 2)}</li>
 * <li><pre>if {@code  a &#8805; 0} return {@code t + (b/2t)i}
 *  else return {@code |b|/2t + sign(b)t i }</pre></li>
 * </ol>
 * where <ul>
 * <li>{@code |a| = }{@link Math#abs}(a)</li>
 * <li>{@code |a + bi| = }{@link Complex#abs}(a + bi)</li>
 * <li>{@code sign(b) =  }{@link FastMath#copySign(double,double) copySign(1d, b)}
 * </ul>
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i
 *   sqrt(INFINITY + i) = INFINITY + 0i
 *   sqrt(-INFINITY + i) = 0 + INFINITY i
 *   sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i
 *   sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i
 *  </code>
 * </pre>
 *
 * @return the square root of {@code this}.
 * @since 1.2
 */"
"public Complex multiply(double factor) {
    if (isNaN || Double.isNaN(factor)) {
        return NaN;
    }
    if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(factor)) {
        // we don't use isInfinite() to avoid testing for NaN again
        return INF;
    }
    return createComplex(real * factor, imaginary * factor);
}","public void test06777() throws Throwable {
    Complex complex0 = Complex.valueOf((-469.23), (-962.625682634));
    Complex complex1 = complex0.asin();
    Complex complex2 = complex0.multiply((-2294));
    Complex complex3 = complex2.pow((-54.03));
    complex3.INF.tanh();
    complex3.INF.divide((-54.03));
    complex3.I.readResolve();
    complex3.INF.add((-54.03));
    complex2.abs();
    Complex complex4 = complex0.add((-469.23));
    complex4.ONE.toString();
    complex2.multiply(0.0);
    complex1.multiply(complex2);
    complex1.multiply((-469.23));
}","/**
 * Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}
 * interpreted as a real number.
 *
 * @param  factor value to be multiplied by this {@code Complex}.
 * @return {@code this * factor}.
 * @see #multiply(Complex)
 */"
"public Complex sin() {
    if (isNaN) {
        return NaN;
    }
    return createComplex(FastMath.sin(real) * FastMath.cosh(imaginary), FastMath.cos(real) * FastMath.sinh(imaginary));
}","public void test06878() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.createComplex(4.151794514828518E-8, (-2507.0));
    complex0.ONE.asin();
    complex1.add(4.151794514828518E-8);
    complex1.I.createComplex(4.151794514828518E-8, (-20.0));
    complex0.cos();
    complex1.sin();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Sine.html"" TARGET=""_top"">
 * sine</a>
 * of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link FastMath#cosh} and {@link FastMath#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or {@code NaN} values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   sin(1 &plusmn; INFINITY i) = 1 &plusmn; INFINITY i
 *   sin(&plusmn;INFINITY + i) = NaN + NaN i
 *   sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *  </code>
 * </pre>
 *
 * @return the sine of this complex number.
 * @since 1.2
 */"
"@Override
public int hashCode() {
    if (isNaN) {
        return 7;
    }
    return 37 * (17 * MathUtils.hash(imaginary) + MathUtils.hash(real));
}","public void test06979() throws Throwable {
    Complex complex0 = Complex.valueOf(0.0);
    complex0.isNaN();
    Complex complex1 = complex0.subtract(920.47253);
    complex1.INF.add(0.0);
    complex1.INF.tan();
    complex1.hashCode();
}","/**
 * Get a hashCode for the complex number.
 * Any {@code Double.NaN} value in real or imaginary part produces
 * the same hash code {@code 7}.
 *
 * @return a hash code value for this object.
 */"
"public Complex multiply(Complex factor) throws NullArgumentException {
    MathUtils.checkNotNull(factor);
    if (isNaN || factor.isNaN) {
        return NaN;
    }
    if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(factor.real) || Double.isInfinite(factor.imaginary)) {
        // we don't use isInfinite() to avoid testing for NaN again
        return INF;
    }
    return createComplex(real * factor.real - imaginary * factor.imaginary, real * factor.imaginary + imaginary * factor.real);
}","public void test07080() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = Complex.valueOf((-20.0), (-20.0));
    complex0.multiply(complex1);
}","/**
 * Returns a {@code Complex} whose value is {@code this * factor}.
 * Implements preliminary checks for {@code NaN} and infinity followed by
 * the definitional formula:
 * <pre>
 *  <code>
 *   (a + bi)(c + di) = (ac - bd) + (ad + bc)i
 *  </code>
 * </pre>
 * Returns {@link #NaN} if either {@code this} or {@code factor} has one or
 * more {@code NaN} parts.
 * <br/>
 * Returns {@link #INF} if neither {@code this} nor {@code factor} has one
 * or more {@code NaN} parts and if either {@code this} or {@code factor}
 * has one or more infinite parts (same result is returned regardless of
 * the sign of the components).
 * <br/>
 * Returns finite values in components of the result per the definitional
 * formula in all remaining cases.
 *
 * @param  factor value to be multiplied by this {@code Complex}.
 * @return {@code this * factor}.
 * @throws NullArgumentException if {@code factor} is {@code null}.
 */"
"public boolean isInfinite() {
    return isInfinite;
}","public void test07181() throws Throwable {
    Complex complex0 = Complex.ONE;
    complex0.conjugate();
    complex0.ZERO.multiply(1);
    complex0.sinh();
    complex0.isInfinite();
}","/**
 * Checks whether either the real or imaginary part of this complex number
 * takes an infinite value (either {@code Double.POSITIVE_INFINITY} or
 * {@code Double.NEGATIVE_INFINITY}) and neither part
 * is {@code NaN}.
 *
 * @return true if one or both parts of this complex number are infinite
 * and neither part is {@code NaN}.
 */"
"public Complex pow(double x) {
    return this.log().multiply(x).exp();
}","public void test07282() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = Complex.INF;
    complex0.subtract(complex1);
    Complex complex2 = Complex.valueOf(Double.POSITIVE_INFINITY, 0.0);
    complex2.toString();
    Complex complex3 = complex2.divide(complex1);
    Complex complex4 = complex1.reciprocal();
    complex4.ZERO.hashCode();
    Complex complex5 = complex3.acos();
    Complex complex6 = new Complex(0.0);
    complex6.I.cos();
    complex0.multiply(complex6);
    complex5.getReal();
    complex5.pow(Double.POSITIVE_INFINITY);
}","/**
 * Returns of value of this complex number raised to the power of {@code x}.
 *
 * @param  x exponent to which this {@code Complex} is to be raised.
 * @return <code>this<sup>x</sup></code>.
 * @see #pow(Complex)
 */"
"public Complex exp() {
    if (isNaN) {
        return NaN;
    }
    double expReal = FastMath.exp(real);
    return createComplex(expReal * FastMath.cos(imaginary), expReal * FastMath.sin(imaginary));
}","public void test07383() throws Throwable {
    Complex complex0 = Complex.valueOf(0.0, 0.0);
    Complex complex1 = complex0.INF.tan();
    complex1.NaN.multiply(complex0);
    Complex complex2 = Complex.NaN;
    Complex complex3 = complex2.ZERO.multiply(0.0);
    complex2.ONE.add(complex0);
    complex0.NaN.add(complex2);
    Complex complex4 = complex0.I.add(0.0);
    Complex complex5 = complex0.cosh();
    complex2.ZERO.tanh();
    Complex complex6 = complex5.ZERO.multiply((-747));
    complex6.ZERO.sinh();
    Complex complex7 = complex5.acos();
    Complex complex8 = complex7.I.multiply(37);
    complex8.INF.toString();
    complex4.divide(complex7);
    complex3.add(complex0);
    complex7.exp();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/ExponentialFunction.html"" TARGET=""_top"">
 * exponential function</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#exp}, {@link java.lang.Math#cos}, and
 * {@link java.lang.Math#sin}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   exp(1 &plusmn; INFINITY i) = NaN + NaN i
 *   exp(INFINITY + i) = INFINITY + INFINITY i
 *   exp(-INFINITY + i) = 0 + 0i
 *   exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *  </code>
 * </pre>
 *
 * @return <code><i>e</i><sup>this</sup></code>.
 * @since 1.2
 */"
"protected Complex createComplex(double realPart, double imaginaryPart) {
    return new Complex(realPart, imaginaryPart);
}","public void test07484() throws Throwable {
    Complex complex0 = new Complex(0.0, Double.NaN);
    Complex complex1 = complex0.divide(Double.NaN);
    Complex complex2 = complex1.I.reciprocal();
    Complex complex3 = complex1.pow(complex0);
    Complex complex4 = complex3.sinh();
    complex4.I.createComplex(0.0, 0.0);
    complex1.NaN.pow(0.0);
    complex4.readResolve();
    complex2.getArgument();
    complex4.cosh();
    complex3.createComplex(0.0, 0.0);
}","/**
 * Create a complex number given the real and imaginary parts.
 *
 * @param realPart Real part.
 * @param imaginaryPart Imaginary part.
 * @return a new complex number instance.
 * @since 1.2
 * @see #valueOf(double, double)
 */"
"public Complex subtract(Complex subtrahend) throws NullArgumentException {
    MathUtils.checkNotNull(subtrahend);
    if (isNaN || subtrahend.isNaN) {
        return NaN;
    }
    return createComplex(real - subtrahend.getReal(), imaginary - subtrahend.getImaginary());
}","public void test07585() throws Throwable {
    Complex complex0 = new Complex(0.0, 0.0);
    complex0.multiply((-1510.16));
    Complex complex1 = complex0.atan();
    complex0.subtract(complex1);
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this - subtrahend)}.
 * Uses the definitional formula
 * <pre>
 *  <code>
 *   (a + bi) - (c + di) = (a-c) + (b-d)i
 *  </code>
 * </pre>
 * If either {@code this} or {@code subtrahend} has a {@code NaN]} value in either part,
 * {@link #NaN} is returned; otherwise infinite and {@code NaN} values are
 * returned in the parts of the result according to the rules for
 * {@link java.lang.Double} arithmetic.
 *
 * @param  subtrahend value to be subtracted from this {@code Complex}.
 * @return {@code this - subtrahend}.
 * @throws NullArgumentException if {@code subtrahend} is {@code null}.
 */"
"public Complex log() {
    if (isNaN) {
        return NaN;
    }
    return createComplex(FastMath.log(abs()), FastMath.atan2(imaginary, real));
}","public void test07686() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex.valueOf(2.0);
    complex0.ONE.tan();
    Complex complex1 = complex0.cosh();
    complex1.getArgument();
    complex0.log();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/NaturalLogarithm.html"" TARGET=""_top"">
 * natural logarithm</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   log(a + bi) = ln(|a + bi|) + arg(a + bi)i
 *  </code>
 * </pre>
 * where ln on the right hand side is {@link java.lang.Math#log},
 * {@code |a + bi|} is the modulus, {@link Complex#abs},  and
 * {@code arg(a + bi) = }{@link java.lang.Math#atan2}(b, a).
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   log(1 &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/2)i
 *   log(INFINITY + i) = INFINITY + 0i
 *   log(-INFINITY + i) = INFINITY + &pi;i
 *   log(INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/4)i
 *   log(-INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (3&pi;/4)i
 *   log(0 + 0i) = -INFINITY + 0i
 *  </code>
 * </pre>
 *
 * @return the value <code>ln &nbsp; this</code>, the natural logarithm
 * of {@code this}.
 * @since 1.2
 */"
"public Complex acos() {
    if (isNaN) {
        return NaN;
    }
    return this.add(this.sqrt1z().multiply(I)).log().multiply(I.negate());
}","public void test07787() throws Throwable {
    Complex complex0 = Complex.ONE;
    complex0.nthRoot(1);
    complex0.NaN.getField();
    Complex complex1 = complex0.pow(0.0);
    complex1.NaN.sqrt();
    complex1.INF.abs();
    complex0.acos();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/InverseCosine.html"" TARGET=""_top"">
 * inverse cosine</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))
 *  </code>
 * </pre>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite.
 *
 * @return the inverse cosine of this complex number.
 * @since 1.2
 */"
"public Complex multiply(Complex factor) throws NullArgumentException {
    MathUtils.checkNotNull(factor);
    if (isNaN || factor.isNaN) {
        return NaN;
    }
    if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(factor.real) || Double.isInfinite(factor.imaginary)) {
        // we don't use isInfinite() to avoid testing for NaN again
        return INF;
    }
    return createComplex(real * factor.real - imaginary * factor.imaginary, real * factor.imaginary + imaginary * factor.real);
}","public void test07888() throws Throwable {
    Complex complex0 = Complex.valueOf(4346.7092332);
    complex0.conjugate();
    Complex.valueOf(4346.7092332, 1601.13460539);
    Complex complex1 = complex0.acos();
    complex1.multiply(complex0);
}","/**
 * Returns a {@code Complex} whose value is {@code this * factor}.
 * Implements preliminary checks for {@code NaN} and infinity followed by
 * the definitional formula:
 * <pre>
 *  <code>
 *   (a + bi)(c + di) = (ac - bd) + (ad + bc)i
 *  </code>
 * </pre>
 * Returns {@link #NaN} if either {@code this} or {@code factor} has one or
 * more {@code NaN} parts.
 * <br/>
 * Returns {@link #INF} if neither {@code this} nor {@code factor} has one
 * or more {@code NaN} parts and if either {@code this} or {@code factor}
 * has one or more infinite parts (same result is returned regardless of
 * the sign of the components).
 * <br/>
 * Returns finite values in components of the result per the definitional
 * formula in all remaining cases.
 *
 * @param  factor value to be multiplied by this {@code Complex}.
 * @return {@code this * factor}.
 * @throws NullArgumentException if {@code factor} is {@code null}.
 */"
"@Override
public String toString() {
    return ""("" + real + "", "" + imaginary + "")"";
}","public void test07989() throws Throwable {
    Complex complex0 = Complex.INF;
    complex0.abs();
    complex0.toString();
}","/**
 * {@inheritDoc}
 */"
"public Complex add(Complex addend) throws NullArgumentException {
    MathUtils.checkNotNull(addend);
    if (isNaN || addend.isNaN) {
        return NaN;
    }
    return createComplex(real + addend.getReal(), imaginary + addend.getImaginary());
}","public void test08090() throws Throwable {
    Complex complex0 = new Complex(Double.NaN);
    complex0.I.readResolve();
    Complex complex1 = complex0.add(Double.NaN);
    complex0.add(complex1);
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this + addend)}.
 * Uses the definitional formula
 * <pre>
 *  <code>
 *   (a + bi) + (c + di) = (a+c) + (b+d)i
 *  </code>
 * </pre>
 * <br/>
 * If either {@code this} or {@code addend} has a {@code NaN} value in
 * either part, {@link #NaN} is returned; otherwise {@code Infinite}
 * and {@code NaN} values are returned in the parts of the result
 * according to the rules for {@link java.lang.Double} arithmetic.
 *
 * @param  addend Value to be added to this {@code Complex}.
 * @return {@code this + addend}.
 * @throws NullArgumentException if {@code addend} is {@code null}.
 */"
"public Complex multiply(Complex factor) throws NullArgumentException {
    MathUtils.checkNotNull(factor);
    if (isNaN || factor.isNaN) {
        return NaN;
    }
    if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(factor.real) || Double.isInfinite(factor.imaginary)) {
        // we don't use isInfinite() to avoid testing for NaN again
        return INF;
    }
    return createComplex(real * factor.real - imaginary * factor.imaginary, real * factor.imaginary + imaginary * factor.real);
}","public void test08191() throws Throwable {
    Complex complex0 = new Complex((-2289.0505632029985), (-36.04));
    Complex complex1 = complex0.subtract((-763.75318048848));
    Complex complex2 = complex0.tanh();
    Complex complex3 = complex2.multiply(complex1);
    Complex complex4 = complex2.asin();
    complex4.ZERO.readResolve();
    complex1.tanh();
    complex3.createComplex((-2289.0505632029985), (-36.04));
    complex4.multiply(complex2);
}","/**
 * Returns a {@code Complex} whose value is {@code this * factor}.
 * Implements preliminary checks for {@code NaN} and infinity followed by
 * the definitional formula:
 * <pre>
 *  <code>
 *   (a + bi)(c + di) = (ac - bd) + (ad + bc)i
 *  </code>
 * </pre>
 * Returns {@link #NaN} if either {@code this} or {@code factor} has one or
 * more {@code NaN} parts.
 * <br/>
 * Returns {@link #INF} if neither {@code this} nor {@code factor} has one
 * or more {@code NaN} parts and if either {@code this} or {@code factor}
 * has one or more infinite parts (same result is returned regardless of
 * the sign of the components).
 * <br/>
 * Returns finite values in components of the result per the definitional
 * formula in all remaining cases.
 *
 * @param  factor value to be multiplied by this {@code Complex}.
 * @return {@code this * factor}.
 * @throws NullArgumentException if {@code factor} is {@code null}.
 */"
"public Complex sinh() {
    if (isNaN) {
        return NaN;
    }
    return createComplex(FastMath.sinh(real) * FastMath.cos(imaginary), FastMath.cosh(real) * FastMath.sin(imaginary));
}","public void test08292() throws Throwable {
    Complex complex0 = new Complex(0.11343331634998322);
    Complex complex1 = Complex.valueOf((-669.88619), (-669.88619));
    complex0.ZERO.multiply(complex1);
    complex0.ONE.add((-119.71));
    complex0.divide((-284.5248018489));
    complex0.sinh();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/HyperbolicSine.html"" TARGET=""_top"">
 * hyperbolic sine</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link FastMath#cosh} and {@link FastMath#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   sinh(1 &plusmn; INFINITY i) = NaN + NaN i
 *   sinh(&plusmn;INFINITY + i) = &plusmn; INFINITY + INFINITY i
 *   sinh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *  </code>
 * </pre>
 *
 * @return the hyperbolic sine of {@code this}.
 * @since 1.2
 */"
"public Complex add(Complex addend) throws NullArgumentException {
    MathUtils.checkNotNull(addend);
    if (isNaN || addend.isNaN) {
        return NaN;
    }
    return createComplex(real + addend.getReal(), imaginary + addend.getImaginary());
}","public void test08393() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.INF.negate();
    complex0.ZERO.abs();
    Complex complex2 = complex1.I.divide((-366.422758));
    complex0.sin();
    Complex complex3 = complex2.negate();
    complex3.reciprocal();
    complex3.equals(complex1);
    complex3.add(complex0);
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this + addend)}.
 * Uses the definitional formula
 * <pre>
 *  <code>
 *   (a + bi) + (c + di) = (a+c) + (b+d)i
 *  </code>
 * </pre>
 * <br/>
 * If either {@code this} or {@code addend} has a {@code NaN} value in
 * either part, {@link #NaN} is returned; otherwise {@code Infinite}
 * and {@code NaN} values are returned in the parts of the result
 * according to the rules for {@link java.lang.Double} arithmetic.
 *
 * @param  addend Value to be added to this {@code Complex}.
 * @return {@code this + addend}.
 * @throws NullArgumentException if {@code addend} is {@code null}.
 */"
"public double getImaginary() {
    return imaginary;
}","public void test08494() throws Throwable {
    Complex complex0 = Complex.ZERO;
    complex0.INF.hashCode();
    complex0.getImaginary();
}","/**
 * Access the imaginary part.
 *
 * @return the imaginary part.
 */"
"@Override
public String toString() {
    return ""("" + real + "", "" + imaginary + "")"";
}","public void test08595() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = complex0.ONE.sqrt1z();
    Complex complex2 = complex1.ZERO.tanh();
    complex1.sqrt();
    Complex complex3 = Complex.valueOf(0.0, (-881.4961392311019));
    complex0.I.readResolve();
    Complex.valueOf(2.0, 1685.078963);
    complex1.I.createComplex((-1841.092649813), 0.0);
    Complex complex4 = complex0.divide(complex3);
    Complex complex5 = complex2.divide(0.0);
    complex5.NaN.sinh();
    complex4.subtract(complex0);
    complex1.toString();
}","/**
 * {@inheritDoc}
 */"
"public ComplexField getField() {
    return ComplexField.getInstance();
}","public void test08696() throws Throwable {
    Complex complex0 = new Complex(8.598369704466743E-136);
    complex0.ONE.multiply((-1));
    Complex complex1 = complex0.exp();
    complex1.ZERO.subtract((-84.230041));
    complex1.getField();
}","/**
 * {@inheritDoc}
 */"
"public List<Complex> nthRoot(int n) throws NotPositiveException {
    if (n <= 0) {
        throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N, n);
    }
    final List<Complex> result = new ArrayList<Complex>();
    if (isNaN) {
        result.add(NaN);
        return result;
    }
    if (isInfinite()) {
        result.add(INF);
        return result;
    }
    // nth root of abs -- faster / more accurate to use a solver here?
    final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);
    // Compute nth roots of complex number with k = 0, 1, ... n-1
    final double nthPhi = getArgument() / n;
    final double slice = 2 * FastMath.PI / n;
    double innerPart = nthPhi;
    for (int k = 0; k < n; k++) {
        // inner part
        final double realPart = nthRootOfAbs * FastMath.cos(innerPart);
        final double imaginaryPart = nthRootOfAbs * FastMath.sin(innerPart);
        result.add(createComplex(realPart, imaginaryPart));
        innerPart += slice;
    }
    return result;
}","public void test08797() throws Throwable {
    Complex complex0 = Complex.NaN;
    Complex complex1 = complex0.sqrt1z();
    Complex complex2 = complex1.NaN.cos();
    Complex complex3 = complex1.atan();
    complex3.ONE.conjugate();
    complex1.NaN.toString();
    Complex complex4 = complex0.createComplex(0.0, 0.0);
    complex4.NaN.abs();
    complex0.NaN.abs();
    complex0.INF.createComplex(0.0, 0.0);
    complex4.readResolve();
    complex1.ONE.sqrt();
    Complex complex5 = complex0.tan();
    complex5.I.atan();
    complex5.multiply(complex2);
    complex1.NaN.toString();
    try {
        complex0.nthRoot((-3728));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot compute nth root for null or negative n: -3,728
        //
        verifyException(""org.apache.commons.math3.complex.Complex"", e);
    }
}","/**
 * Computes the n-th roots of this complex number.
 * The nth roots are defined by the formula:
 * <pre>
 *  <code>
 *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))
 *  </code>
 * </pre>
 * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}
 * are respectively the {@link #abs() modulus} and
 * {@link #getArgument() argument} of this complex number.
 * <br/>
 * If one or both parts of this complex number is NaN, a list with just
 * one element, {@link #NaN} is returned.
 * if neither part is NaN, but at least one part is infinite, the result
 * is a one-element list containing {@link #INF}.
 *
 * @param n Degree of root.
 * @return a List<Complex> of all {@code n}-th roots of {@code this}.
 * @throws NotPositiveException if {@code n <= 0}.
 * @since 2.0
 */"
"public Complex divide(Complex divisor) throws NullArgumentException {
    MathUtils.checkNotNull(divisor);
    if (isNaN || divisor.isNaN) {
        return NaN;
    }
    final double c = divisor.getReal();
    final double d = divisor.getImaginary();
    if (c == 0.0 && d == 0.0) {
        return NaN;
    }
    if (divisor.isInfinite() && !isInfinite()) {
        return ZERO;
    }
    if (FastMath.abs(c) < FastMath.abs(d)) {
        double q = c / d;
        double denominator = c * q + d;
        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);
    } else {
        double q = d / c;
        double denominator = d * q + c;
        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);
    }
}","public void test08898() throws Throwable {
    Complex complex0 = Complex.ONE;
    Complex complex1 = complex0.NaN.conjugate();
    double double0 = 1.8356062677502141E202;
    complex0.ZERO.add(1.8356062677502141E202);
    complex1.toString();
    Complex complex2 = complex0.NaN.reciprocal();
    try {
        complex2.NaN.divide((Complex) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // null is not allowed
        //
        verifyException(""org.apache.commons.math3.util.MathUtils"", e);
    }
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this / divisor)}.
 * Implements the definitional formula
 * <pre>
 *  <code>
 *    a + bi          ac + bd + (bc - ad)i
 *    ----------- = -------------------------
 *    c + di         c<sup>2</sup> + d<sup>2</sup>
 *  </code>
 * </pre>
 * but uses
 * <a href=""http://doi.acm.org/10.1145/1039813.1039814"">
 * prescaling of operands</a> to limit the effects of overflows and
 * underflows in the computation.
 * <br/>
 * {@code Infinite} and {@code NaN} values are handled according to the
 * following rules, applied in the order presented:
 * <ul>
 *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value
 *   in either part, {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code divisor} equals {@link #ZERO}, {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code this} and {@code divisor} are both infinite,
 *   {@link #NaN} is returned.
 *  </li>
 *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or
 *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts
 *   infinite), {@link #ZERO} is returned.
 *  </li>
 *  <li>If {@code this} is infinite and {@code divisor} is finite,
 *   {@code NaN} values are returned in the parts of the result if the
 *   {@link java.lang.Double} rules applied to the definitional formula
 *   force {@code NaN} results.
 *  </li>
 * </ul>
 *
 * @param divisor Value by which this {@code Complex} is to be divided.
 * @return {@code this / divisor}.
 * @throws NullArgumentException if {@code divisor} is {@code null}.
 */"
"public Complex cos() {
    if (isNaN) {
        return NaN;
    }
    return createComplex(FastMath.cos(real) * FastMath.cosh(imaginary), -FastMath.sin(real) * FastMath.sinh(imaginary));
}","public void test08999() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = Complex.valueOf(0.0);
    Complex complex2 = complex0.add(complex1);
    complex0.sqrt();
    complex2.cos();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Cosine.html"" TARGET=""_top"">
 * cosine</a>
 * of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},
 * {@link FastMath#cosh} and {@link FastMath#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   cos(1 &plusmn; INFINITY i) = 1 &#x2213; INFINITY i
 *   cos(&plusmn;INFINITY + i) = NaN + NaN i
 *   cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *  </code>
 * </pre>
 *
 * @return the cosine of this complex number.
 * @since 1.2
 */"
"public static Complex valueOf(double realPart, double imaginaryPart) {
    if (Double.isNaN(realPart) || Double.isNaN(imaginaryPart)) {
        return NaN;
    }
    return new Complex(realPart, imaginaryPart);
}","public void test090100() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.INF.cos();
    complex0.ZERO.multiply(complex1);
    complex0.getField();
    complex1.ONE.getArgument();
    complex0.getReal();
    complex0.isInfinite();
    complex1.readResolve();
    Complex complex2 = complex1.cosh();
    complex2.NaN.readResolve();
    Complex.valueOf(0.0, 0.0);
}","/**
 * Create a complex number given the real and imaginary parts.
 *
 * @param realPart Real part.
 * @param imaginaryPart Imaginary part.
 * @return a Complex instance.
 */"
"public List<Complex> nthRoot(int n) throws NotPositiveException {
    if (n <= 0) {
        throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N, n);
    }
    final List<Complex> result = new ArrayList<Complex>();
    if (isNaN) {
        result.add(NaN);
        return result;
    }
    if (isInfinite()) {
        result.add(INF);
        return result;
    }
    // nth root of abs -- faster / more accurate to use a solver here?
    final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);
    // Compute nth roots of complex number with k = 0, 1, ... n-1
    final double nthPhi = getArgument() / n;
    final double slice = 2 * FastMath.PI / n;
    double innerPart = nthPhi;
    for (int k = 0; k < n; k++) {
        // inner part
        final double realPart = nthRootOfAbs * FastMath.cos(innerPart);
        final double imaginaryPart = nthRootOfAbs * FastMath.sin(innerPart);
        result.add(createComplex(realPart, imaginaryPart));
        innerPart += slice;
    }
    return result;
}","public void test091101() throws Throwable {
    Complex complex0 = new Complex(0.0);
    try {
        complex0.nthRoot((-1798));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot compute nth root for null or negative n: -1,798
        //
        verifyException(""org.apache.commons.math3.complex.Complex"", e);
    }
}","/**
 * Computes the n-th roots of this complex number.
 * The nth roots are defined by the formula:
 * <pre>
 *  <code>
 *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))
 *  </code>
 * </pre>
 * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}
 * are respectively the {@link #abs() modulus} and
 * {@link #getArgument() argument} of this complex number.
 * <br/>
 * If one or both parts of this complex number is NaN, a list with just
 * one element, {@link #NaN} is returned.
 * if neither part is NaN, but at least one part is infinite, the result
 * is a one-element list containing {@link #INF}.
 *
 * @param n Degree of root.
 * @return a List<Complex> of all {@code n}-th roots of {@code this}.
 * @throws NotPositiveException if {@code n <= 0}.
 * @since 2.0
 */"
"public static Complex valueOf(double realPart, double imaginaryPart) {
    if (Double.isNaN(realPart) || Double.isNaN(imaginaryPart)) {
        return NaN;
    }
    return new Complex(realPart, imaginaryPart);
}","public void test092102() throws Throwable {
    Complex complex0 = Complex.NaN;
    complex0.ONE.sqrt();
    complex0.sqrt();
    Complex.valueOf(2.0, 240.8);
}","/**
 * Create a complex number given the real and imaginary parts.
 *
 * @param realPart Real part.
 * @param imaginaryPart Imaginary part.
 * @return a Complex instance.
 */"
"public Complex asin() {
    if (isNaN) {
        return NaN;
    }
    return sqrt1z().add(this.multiply(I)).log().multiply(I.negate());
}","public void test093103() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = new Complex((-197.1425765927), (-1358.467856));
    complex0.NaN.subtract(complex1);
    complex0.I.multiply(1.2085883617401123);
    complex0.asin();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/InverseSine.html"" TARGET=""_top"">
 * inverse sine</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz))
 *  </code>
 * </pre>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite.
 *
 * @return the inverse sine of this complex number.
 * @since 1.2
 */"
"public Complex asin() {
    if (isNaN) {
        return NaN;
    }
    return sqrt1z().add(this.multiply(I)).log().multiply(I.negate());
}","public void test094104() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = Complex.INF;
    complex0.ZERO.subtract(complex1);
    complex0.cos();
    complex0.ZERO.getArgument();
    complex0.atan();
    complex0.asin();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/InverseSine.html"" TARGET=""_top"">
 * inverse sine</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz))
 *  </code>
 * </pre>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite.
 *
 * @return the inverse sine of this complex number.
 * @since 1.2
 */"
"public Complex multiply(double factor) {
    if (isNaN || Double.isNaN(factor)) {
        return NaN;
    }
    if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(factor)) {
        // we don't use isInfinite() to avoid testing for NaN again
        return INF;
    }
    return createComplex(real * factor, imaginary * factor);
}","public void test095105() throws Throwable {
    Complex complex0 = new Complex(0.0, 0.0);
    Complex complex1 = complex0.tan();
    complex1.NaN.createComplex(0.0, 0.0);
    Complex complex2 = complex1.NaN.divide(complex0);
    complex2.NaN.abs();
    complex1.getArgument();
    complex0.multiply(0.0);
}","/**
 * Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}
 * interpreted as a real number.
 *
 * @param  factor value to be multiplied by this {@code Complex}.
 * @return {@code this * factor}.
 * @see #multiply(Complex)
 */"
"public boolean isInfinite() {
    return isInfinite;
}","public void test096106() throws Throwable {
    Complex complex0 = Complex.I;
    complex0.ONE.hashCode();
    Complex complex1 = Complex.NaN;
    complex0.ONE.readResolve();
    Complex complex2 = complex0.pow(complex1);
    complex1.ONE.divide(complex2);
    Complex complex3 = complex1.log();
    Complex complex4 = complex3.NaN.cos();
    complex3.I.log();
    complex3.hashCode();
    complex3.readResolve();
    complex4.negate();
    complex4.isInfinite();
}","/**
 * Checks whether either the real or imaginary part of this complex number
 * takes an infinite value (either {@code Double.POSITIVE_INFINITY} or
 * {@code Double.NEGATIVE_INFINITY}) and neither part
 * is {@code NaN}.
 *
 * @return true if one or both parts of this complex number are infinite
 * and neither part is {@code NaN}.
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Complex) {
        Complex c = (Complex) other;
        if (c.isNaN) {
            return isNaN;
        } else {
            return (real == c.real) && (imaginary == c.imaginary);
        }
    }
    return false;
}","public void test097107() throws Throwable {
    Complex complex0 = Complex.valueOf(Double.NaN, Double.NaN);
    Object object0 = new Object();
    complex0.equals(object0);
}","/**
 * Test for the equality of two Complex objects.
 * If both the real and imaginary parts of two complex numbers
 * are exactly the same, and neither is {@code Double.NaN}, the two
 * Complex objects are considered to be equal.
 * All {@code NaN} values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to {@code Double.NaN}, the complex number is equal to
 * {@code NaN}.
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if object is
 * {@code null}, not an instance of Complex, or not equal to this Complex
 * instance.
 */"
"public static Complex valueOf(double realPart, double imaginaryPart) {
    if (Double.isNaN(realPart) || Double.isNaN(imaginaryPart)) {
        return NaN;
    }
    return new Complex(realPart, imaginaryPart);
}","public void test098108() throws Throwable {
    Complex complex0 = Complex.NaN;
    complex0.ONE.getArgument();
    complex0.readResolve();
    complex0.conjugate();
    complex0.sinh();
    complex0.add(0.0);
    complex0.atan();
    Complex.valueOf(0.0, (-2487.3843));
}","/**
 * Create a complex number given the real and imaginary parts.
 *
 * @param realPart Real part.
 * @param imaginaryPart Imaginary part.
 * @return a Complex instance.
 */"
"public Complex tanh() {
    if (isNaN || Double.isInfinite(imaginary)) {
        return NaN;
    }
    if (real > 20.0) {
        return createComplex(1.0, 0.0);
    }
    if (real < -20.0) {
        return createComplex(-1.0, 0.0);
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);
    return createComplex(FastMath.sinh(real2) / d, FastMath.sin(imaginary2) / d);
}","public void test099109() throws Throwable {
    Complex complex0 = Complex.I;
    complex0.sinh();
    complex0.tanh();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/HyperbolicTangent.html"" TARGET=""_top"">
 * hyperbolic tangent</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and
 * {@link FastMath#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   tanh(a &plusmn; INFINITY i) = NaN + NaN i
 *   tanh(&plusmn;INFINITY + bi) = &plusmn;1 + 0 i
 *   tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *   tanh(0 + (&pi;/2)i) = NaN + INFINITY i
 *  </code>
 * </pre>
 *
 * @return the hyperbolic tangent of {@code this}.
 * @since 1.2
 */"
"@Override
public int hashCode() {
    if (isNaN) {
        return 7;
    }
    return 37 * (17 * MathUtils.hash(imaginary) + MathUtils.hash(real));
}","public void test100110() throws Throwable {
    Complex complex0 = new Complex((-3491.067328733715));
    Complex complex1 = complex0.tan();
    Complex complex2 = complex1.NaN.sinh();
    complex2.ZERO.sqrt();
    complex0.INF.tanh();
    complex0.getImaginary();
    complex1.hashCode();
}","/**
 * Get a hashCode for the complex number.
 * Any {@code Double.NaN} value in real or imaginary part produces
 * the same hash code {@code 7}.
 *
 * @return a hash code value for this object.
 */"
"public Complex divide(double divisor) {
    if (isNaN || Double.isNaN(divisor)) {
        return NaN;
    }
    if (divisor == 0d) {
        return NaN;
    }
    if (Double.isInfinite(divisor)) {
        return !isInfinite() ? ZERO : NaN;
    }
    return createComplex(real / divisor, imaginary / divisor);
}","public void test101111() throws Throwable {
    Complex complex0 = new Complex(0.40806591510772705);
    Complex complex1 = Complex.I;
    Complex complex2 = complex0.ONE.pow(complex1);
    Complex complex3 = complex2.NaN.atan();
    Complex complex4 = complex0.ZERO.sqrt1z();
    complex0.getArgument();
    complex3.sin();
    complex4.divide(0.0);
}","/**
 * Returns a {@code Complex} whose value is {@code (this / divisor)},
 * with {@code divisor} interpreted as a real number.
 *
 * @param  divisor Value by which this {@code Complex} is to be divided.
 * @return {@code this / divisor}.
 * @see #divide(Complex)
 */"
"public List<Complex> nthRoot(int n) throws NotPositiveException {
    if (n <= 0) {
        throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N, n);
    }
    final List<Complex> result = new ArrayList<Complex>();
    if (isNaN) {
        result.add(NaN);
        return result;
    }
    if (isInfinite()) {
        result.add(INF);
        return result;
    }
    // nth root of abs -- faster / more accurate to use a solver here?
    final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);
    // Compute nth roots of complex number with k = 0, 1, ... n-1
    final double nthPhi = getArgument() / n;
    final double slice = 2 * FastMath.PI / n;
    double innerPart = nthPhi;
    for (int k = 0; k < n; k++) {
        // inner part
        final double realPart = nthRootOfAbs * FastMath.cos(innerPart);
        final double imaginaryPart = nthRootOfAbs * FastMath.sin(innerPart);
        result.add(createComplex(realPart, imaginaryPart));
        innerPart += slice;
    }
    return result;
}","public void test102112() throws Throwable {
    Complex complex0 = Complex.ONE;
    complex0.negate();
    complex0.NaN.hashCode();
    complex0.ONE.cosh();
    complex0.ZERO.tan();
    Complex complex1 = complex0.NaN.cos();
    complex1.INF.hashCode();
    try {
        complex0.nthRoot((-867));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // cannot compute nth root for null or negative n: -867
        //
        verifyException(""org.apache.commons.math3.complex.Complex"", e);
    }
}","/**
 * Computes the n-th roots of this complex number.
 * The nth roots are defined by the formula:
 * <pre>
 *  <code>
 *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))
 *  </code>
 * </pre>
 * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}
 * are respectively the {@link #abs() modulus} and
 * {@link #getArgument() argument} of this complex number.
 * <br/>
 * If one or both parts of this complex number is NaN, a list with just
 * one element, {@link #NaN} is returned.
 * if neither part is NaN, but at least one part is infinite, the result
 * is a one-element list containing {@link #INF}.
 *
 * @param n Degree of root.
 * @return a List<Complex> of all {@code n}-th roots of {@code this}.
 * @throws NotPositiveException if {@code n <= 0}.
 * @since 2.0
 */"
"public static Complex valueOf(double realPart) {
    if (Double.isNaN(realPart)) {
        return NaN;
    }
    return new Complex(realPart);
}","public void test103113() throws Throwable {
    Complex complex0 = Complex.valueOf(Double.POSITIVE_INFINITY, 0.0);
    Complex complex1 = complex0.ZERO.tan();
    Complex complex2 = complex0.ZERO.reciprocal();
    Complex complex3 = complex0.NaN.cosh();
    complex3.INF.toString();
    Complex complex4 = complex3.INF.add(complex0);
    Complex complex5 = complex0.asin();
    Complex complex6 = complex3.I.add(complex1);
    complex5.I.hashCode();
    Complex complex7 = Complex.I;
    Complex.valueOf(0.0);
    complex1.pow(complex7);
    Complex complex8 = complex4.sqrt1z();
    complex7.multiply(Double.POSITIVE_INFINITY);
    complex6.divide(complex4);
    complex3.subtract(complex8);
    complex2.sin();
    Complex.valueOf((-2086.19502705));
}","/**
 * Create a complex number given only the real part.
 *
 * @param realPart Real part.
 * @return a Complex instance.
 */"
"public Complex pow(Complex x) throws NullArgumentException {
    MathUtils.checkNotNull(x);
    return this.log().multiply(x).exp();
}","public void test104114() throws Throwable {
    Complex complex0 = Complex.valueOf(32.0, (-89.189320776));
    Complex complex1 = complex0.tanh();
    complex1.ONE.add(32.0);
    Complex complex2 = complex0.NaN.divide((-89.189320776));
    Complex complex3 = complex2.I.createComplex(32.0, 4629.973026927966);
    Complex complex4 = complex0.multiply(7);
    Complex complex5 = complex4.divide((double) 7);
    complex5.NaN.multiply((-800.83));
    complex4.reciprocal();
    complex3.atan();
    complex2.pow(complex3);
}","/**
 * Returns of value of this complex number raised to the power of {@code x}.
 * Implements the formula:
 * <pre>
 *  <code>
 *   y<sup>x</sup> = exp(x&middot;log(y))
 *  </code>
 * </pre>
 * where {@code exp} and {@code log} are {@link #exp} and
 * {@link #log}, respectively.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite, or if {@code y}
 * equals {@link Complex#ZERO}.
 *
 * @param  x exponent to which this {@code Complex} is to be raised.
 * @return <code> this<sup>{@code x}</sup></code>.
 * @throws NullArgumentException if x is {@code null}.
 * @since 1.2
 */"
"public Complex multiply(double factor) {
    if (isNaN || Double.isNaN(factor)) {
        return NaN;
    }
    if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(factor)) {
        // we don't use isInfinite() to avoid testing for NaN again
        return INF;
    }
    return createComplex(real * factor, imaginary * factor);
}","public void test105115() throws Throwable {
    Complex complex0 = new Complex((-1396.9305028891006));
    complex0.nthRoot(1);
    Complex complex1 = complex0.asin();
    Complex complex2 = complex1.INF.multiply(complex0);
    Complex complex3 = complex0.atan();
    complex3.ZERO.sinh();
    Complex complex4 = complex3.pow(1.0);
    complex4.I.sqrt1z();
    complex2.NaN.sin();
    Complex.valueOf((-1396.9305028891006));
    Complex complex5 = complex4.I.sqrt1z();
    Complex complex6 = complex0.tanh();
    complex6.ZERO.abs();
    Complex complex7 = complex3.INF.conjugate();
    complex1.ZERO.add(3337.5729587);
    Complex complex8 = complex7.ZERO.tan();
    complex8.I.log();
    Complex complex9 = complex4.sqrt();
    complex9.INF.pow(complex5);
    complex0.tan();
    complex2.getArgument();
    Complex complex10 = complex9.multiply((-1396.9305028891006));
    Complex complex11 = complex6.asin();
    Complex complex12 = complex11.reciprocal();
    complex12.I.nthRoot(1);
    complex10.multiply((-527.0));
}","/**
 * Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}
 * interpreted as a real number.
 *
 * @param  factor value to be multiplied by this {@code Complex}.
 * @return {@code this * factor}.
 * @see #multiply(Complex)
 */"
"public static Complex valueOf(double realPart, double imaginaryPart) {
    if (Double.isNaN(realPart) || Double.isNaN(imaginaryPart)) {
        return NaN;
    }
    return new Complex(realPart, imaginaryPart);
}","public void test106116() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = Complex.valueOf((-0.9999992214047598));
    complex0.nthRoot(363);
    Complex complex2 = complex1.subtract(830.62417);
    Complex complex3 = complex0.pow(830.62417);
    complex2.INF.subtract((-0.9999992214047598));
    Complex complex4 = complex3.INF.divide((-2889.9293));
    Complex complex5 = complex2.ZERO.divide(830.62417);
    Complex complex6 = complex0.sinh();
    complex5.INF.createComplex((-0.9999992214047598), 830.62417);
    complex0.ZERO.negate();
    Complex complex7 = complex6.I.multiply(363);
    Complex complex8 = complex7.NaN.negate();
    complex7.ONE.acos();
    Complex complex9 = complex2.divide(complex3);
    Complex complex10 = complex9.reciprocal();
    complex5.atan();
    complex4.INF.negate();
    complex10.NaN.readResolve();
    complex2.sqrt();
    Complex complex11 = complex10.reciprocal();
    complex7.INF.sqrt1z();
    complex4.pow(505.253642908);
    Complex complex12 = complex3.log();
    complex11.add(complex9);
    complex6.sqrt();
    complex12.equals(complex8);
    complex11.asin();
    Complex.valueOf((-2889.9293), 788.258);
}","/**
 * Create a complex number given the real and imaginary parts.
 *
 * @param realPart Real part.
 * @param imaginaryPart Imaginary part.
 * @return a Complex instance.
 */"
"public Complex acos() {
    if (isNaN) {
        return NaN;
    }
    return this.add(this.sqrt1z().multiply(I)).log().multiply(I.negate());
}","public void test107117() throws Throwable {
    Complex complex0 = Complex.ZERO;
    Complex complex1 = Complex.I;
    complex0.I.subtract(complex1);
    complex0.getField();
    Complex complex2 = complex0.conjugate();
    Complex complex3 = complex2.INF.reciprocal();
    complex3.ONE.toString();
    Complex complex4 = complex2.ZERO.subtract(2253.86183);
    complex2.INF.abs();
    Object object0 = complex2.readResolve();
    ((Complex) object0).ONE.divide(Double.POSITIVE_INFINITY);
    complex2.equals(object0);
    complex2.I.pow(complex0);
    Complex complex5 = complex4.exp();
    complex4.tan();
    Complex complex6 = complex5.negate();
    complex6.negate();
    complex6.acos();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/InverseCosine.html"" TARGET=""_top"">
 * inverse cosine</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))
 *  </code>
 * </pre>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN} or infinite.
 *
 * @return the inverse cosine of this complex number.
 * @since 1.2
 */"
"public Complex reciprocal() {
    if (isNaN) {
        return NaN;
    }
    if (real == 0.0 && imaginary == 0.0) {
        return NaN;
    }
    if (isInfinite) {
        return ZERO;
    }
    if (FastMath.abs(real) < FastMath.abs(imaginary)) {
        double q = real / imaginary;
        double scale = 1. / (real * q + imaginary);
        return createComplex(scale * q, -scale);
    } else {
        double q = imaginary / real;
        double scale = 1. / (imaginary * q + real);
        return createComplex(scale, -scale * q);
    }
}","public void test108118() throws Throwable {
    Complex complex0 = Complex.NaN;
    Complex complex1 = Complex.ZERO;
    Complex complex2 = complex0.add(complex1);
    Complex complex3 = complex2.ONE.acos();
    Complex complex4 = complex3.NaN.sqrt1z();
    complex3.ZERO.getField();
    Complex complex5 = complex1.cosh();
    complex2.nthRoot(37);
    Complex complex6 = complex5.divide(1795.1766391074);
    Complex complex7 = complex2.reciprocal();
    Complex complex8 = complex4.sqrt();
    Complex complex9 = complex1.atan();
    Complex complex10 = complex9.ZERO.cosh();
    Complex complex11 = complex2.subtract(complex6);
    Complex complex12 = complex11.tan();
    complex12.tanh();
    complex6.sin();
    Complex.valueOf((double) 37, (double) 37);
    complex10.ONE.nthRoot(37);
    Complex complex13 = complex7.subtract(2.1628672925745152E-105);
    Complex.valueOf(1.5704360964732835);
    complex9.multiply(37);
    complex8.abs();
    complex7.conjugate();
    complex10.subtract(complex1);
    complex12.pow(complex2);
    Complex.valueOf((double) 37, 204.852554117);
    complex13.asin();
    complex10.reciprocal();
}","/**
 * {@inheritDoc}
 */"
"public Complex reciprocal() {
    if (isNaN) {
        return NaN;
    }
    if (real == 0.0 && imaginary == 0.0) {
        return NaN;
    }
    if (isInfinite) {
        return ZERO;
    }
    if (FastMath.abs(real) < FastMath.abs(imaginary)) {
        double q = real / imaginary;
        double scale = 1. / (real * q + imaginary);
        return createComplex(scale * q, -scale);
    } else {
        double q = imaginary / real;
        double scale = 1. / (imaginary * q + real);
        return createComplex(scale, -scale * q);
    }
}","public void test109119() throws Throwable {
    Complex complex0 = new Complex(1914.95776, 2914.845181);
    complex0.NaN.getArgument();
    Complex complex1 = complex0.ONE.acos();
    complex0.readResolve();
    Complex complex2 = Complex.valueOf(93.0, 1.7040729233031016E-5);
    Complex complex3 = complex2.NaN.atan();
    Complex complex4 = complex0.acos();
    Complex complex5 = complex4.ZERO.tanh();
    Complex complex6 = complex2.pow(complex1);
    Complex complex7 = complex0.add(complex2);
    complex7.I.createComplex(1.8386917534879182E-8, 1914.95776);
    Complex complex8 = complex5.multiply(Double.NaN);
    Complex.valueOf(1914.95776);
    complex3.multiply(7);
    Complex complex9 = complex1.pow(complex8);
    complex9.I.pow((double) 7);
    complex1.equals(complex5);
    complex9.toString();
    complex2.getField();
    Complex complex10 = complex0.log();
    complex3.ONE.acos();
    complex10.NaN.reciprocal();
    complex0.add(complex6);
    Complex complex11 = complex4.multiply(complex9);
    Complex complex12 = complex3.divide((double) 7);
    complex12.divide(Double.NaN);
    complex4.pow(complex11);
    complex12.reciprocal();
}","/**
 * {@inheritDoc}
 */"
"public Complex add(Complex addend) throws NullArgumentException {
    MathUtils.checkNotNull(addend);
    if (isNaN || addend.isNaN) {
        return NaN;
    }
    return createComplex(real + addend.getReal(), imaginary + addend.getImaginary());
}","public void test110120() throws Throwable {
    Complex complex0 = Complex.ZERO;
    complex0.ZERO.divide(844.11757802136);
    Complex complex1 = complex0.NaN.log();
    complex0.NaN.getArgument();
    Complex complex2 = complex0.atan();
    Complex complex3 = complex2.ONE.cos();
    Complex complex4 = complex0.divide(complex1);
    complex4.I.acos();
    Complex.valueOf(0.0, Double.NaN);
    Complex.valueOf(Double.NaN, 0.0);
    Complex complex5 = complex3.createComplex((-1181.0736), 0.0);
    complex5.add(complex0);
}","/**
 * Returns a {@code Complex} whose value is
 * {@code (this + addend)}.
 * Uses the definitional formula
 * <pre>
 *  <code>
 *   (a + bi) + (c + di) = (a+c) + (b+d)i
 *  </code>
 * </pre>
 * <br/>
 * If either {@code this} or {@code addend} has a {@code NaN} value in
 * either part, {@link #NaN} is returned; otherwise {@code Infinite}
 * and {@code NaN} values are returned in the parts of the result
 * according to the rules for {@link java.lang.Double} arithmetic.
 *
 * @param  addend Value to be added to this {@code Complex}.
 * @return {@code this + addend}.
 * @throws NullArgumentException if {@code addend} is {@code null}.
 */"
"public Complex add(double addend) {
    if (isNaN || Double.isNaN(addend)) {
        return NaN;
    }
    return createComplex(real + addend, imaginary);
}","public void test111121() throws Throwable {
    Complex complex0 = Complex.I;
    Complex complex1 = complex0.INF.sqrt();
    Complex complex2 = complex0.log();
    Complex complex3 = complex1.NaN.log();
    Complex complex4 = complex1.add(complex2);
    Complex complex5 = complex1.divide(5.662033727488754E-22);
    Complex complex6 = complex5.acos();
    Complex complex7 = complex0.divide(complex4);
    Complex complex8 = complex7.INF.log();
    Complex complex9 = complex1.subtract((-6.1837904549178745E-9));
    complex9.I.atan();
    Complex complex10 = complex9.divide(complex6);
    complex1.add(complex2);
    Complex complex11 = complex3.sinh();
    complex11.NaN.multiply((-6.1837904549178745E-9));
    complex3.exp();
    complex10.sqrt1z();
    complex9.pow((-1501.8));
    complex8.add(3.81131861433539E-8);
}","/**
 * Returns a {@code Complex} whose value is {@code (this + addend)},
 * with {@code addend} interpreted as a real number.
 *
 * @param addend Value to be added to this {@code Complex}.
 * @return {@code this + addend}.
 * @see #add(Complex)
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Complex) {
        Complex c = (Complex) other;
        if (c.isNaN) {
            return isNaN;
        } else {
            return (real == c.real) && (imaginary == c.imaginary);
        }
    }
    return false;
}","public void test112122() throws Throwable {
    Complex complex0 = new Complex(2.0, 2.0);
    Complex complex1 = new Complex(2.0);
    Complex complex2 = complex0.multiply(complex1);
    complex1.ZERO.getField();
    Complex complex3 = complex1.add(0.0);
    complex3.I.toString();
    complex1.INF.log();
    complex2.INF.readResolve();
    complex1.isInfinite();
    Complex complex4 = complex0.exp();
    Complex complex5 = complex4.NaN.createComplex(1852.1590224026, 1852.1590224026);
    Complex complex6 = Complex.valueOf(2.0, 2776.0);
    complex4.acos();
    complex6.ONE.sin();
    Complex complex7 = complex6.sqrt1z();
    Complex complex8 = complex7.atan();
    complex7.cosh();
    complex7.isInfinite();
    complex1.isNaN();
    complex5.reciprocal();
    Complex complex9 = Complex.valueOf(0.0);
    complex8.equals(complex9);
}","/**
 * Test for the equality of two Complex objects.
 * If both the real and imaginary parts of two complex numbers
 * are exactly the same, and neither is {@code Double.NaN}, the two
 * Complex objects are considered to be equal.
 * All {@code NaN} values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to {@code Double.NaN}, the complex number is equal to
 * {@code NaN}.
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if object is
 * {@code null}, not an instance of Complex, or not equal to this Complex
 * instance.
 */"
"public Complex exp() {
    if (isNaN) {
        return NaN;
    }
    double expReal = FastMath.exp(real);
    return createComplex(expReal * FastMath.cos(imaginary), expReal * FastMath.sin(imaginary));
}","public void test113123() throws Throwable {
    Complex complex0 = new Complex(79.1515712, (-20.0));
    Complex complex1 = complex0.tan();
    Complex complex2 = complex0.ONE.sinh();
    complex1.I.sqrt1z();
    Complex complex3 = complex2.INF.divide(0.0);
    complex1.getImaginary();
    complex0.getField();
    complex2.getArgument();
    Complex complex4 = complex1.sqrt1z();
    Complex complex5 = complex4.NaN.asin();
    Complex complex6 = complex5.INF.acos();
    Complex complex7 = complex1.sqrt1z();
    complex7.hashCode();
    complex0.hashCode();
    complex7.tanh();
    complex0.add(complex2);
    Complex complex8 = complex6.add((-1.0));
    complex8.subtract(complex3);
    complex2.isInfinite();
    complex7.exp();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/ExponentialFunction.html"" TARGET=""_top"">
 * exponential function</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link java.lang.Math#exp}, {@link java.lang.Math#cos}, and
 * {@link java.lang.Math#sin}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite values in real or imaginary parts of the input may result in
 * infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   exp(1 &plusmn; INFINITY i) = NaN + NaN i
 *   exp(INFINITY + i) = INFINITY + INFINITY i
 *   exp(-INFINITY + i) = 0 + 0i
 *   exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *  </code>
 * </pre>
 *
 * @return <code><i>e</i><sup>this</sup></code>.
 * @since 1.2
 */"
"protected Complex createComplex(double realPart, double imaginaryPart) {
    return new Complex(realPart, imaginaryPart);
}","public void test114124() throws Throwable {
    Complex complex0 = Complex.INF;
    Complex complex1 = complex0.INF.multiply(1313);
    complex0.nthRoot(3514);
    complex0.nthRoot(3514);
    Complex complex2 = complex1.sin();
    Complex complex3 = complex2.ONE.atan();
    complex3.ZERO.divide(complex1);
    complex2.ZERO.log();
    Complex complex4 = complex0.asin();
    Complex complex5 = complex4.multiply(0.0);
    complex5.ONE.exp();
    complex5.NaN.pow(0.0);
    complex4.toString();
    Complex complex6 = complex2.asin();
    Complex.valueOf((double) 1313);
    complex6.createComplex(1313, (-2394.18));
}","/**
 * Create a complex number given the real and imaginary parts.
 *
 * @param realPart Real part.
 * @param imaginaryPart Imaginary part.
 * @return a new complex number instance.
 * @since 1.2
 * @see #valueOf(double, double)
 */"
"public Complex tan() {
    if (isNaN || Double.isInfinite(real)) {
        return NaN;
    }
    if (imaginary > 20.0) {
        return createComplex(0.0, 1.0);
    }
    if (imaginary < -20.0) {
        return createComplex(0.0, -1.0);
    }
    double real2 = 2.0 * real;
    double imaginary2 = 2.0 * imaginary;
    double d = FastMath.cos(real2) + FastMath.cosh(imaginary2);
    return createComplex(FastMath.sin(real2) / d, FastMath.sinh(imaginary2) / d);
}","public void test115125() throws Throwable {
    Complex complex0 = new Complex(578.16691, 578.16691);
    Complex complex1 = complex0.INF.divide(578.16691);
    Complex complex2 = complex1.ONE.multiply(2553);
    complex2.NaN.tan();
    complex0.toString();
    complex0.isNaN();
    Complex complex3 = complex1.atan();
    complex3.nthRoot(2553);
    Complex complex4 = Complex.valueOf((-6.292835950782));
    Complex complex5 = complex1.multiply(complex4);
    Complex complex6 = complex5.INF.subtract((-6.292835950782));
    Complex complex7 = complex4.add(complex5);
    complex7.NaN.reciprocal();
    complex0.multiply(complex2);
    complex0.asin();
    complex6.tan();
}","/**
 * Compute the
 * <a href=""http://mathworld.wolfram.com/Tangent.html"" TARGET=""_top"">
 * tangent</a> of this complex number.
 * Implements the formula:
 * <pre>
 *  <code>
 *   tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i
 *  </code>
 * </pre>
 * where the (real) functions on the right-hand side are
 * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and
 * {@link FastMath#sinh}.
 * <br/>
 * Returns {@link Complex#NaN} if either real or imaginary part of the
 * input argument is {@code NaN}.
 * <br/>
 * Infinite (or critical) values in real or imaginary parts of the input may
 * result in infinite or NaN values returned in parts of the result.
 * <pre>
 *  Examples:
 *  <code>
 *   tan(a &plusmn; INFINITY i) = 0 &plusmn; i
 *   tan(&plusmn;INFINITY + bi) = NaN + NaN i
 *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i
 *   tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i
 *  </code>
 * </pre>
 *
 * @return the tangent of {@code this}.
 * @since 1.2
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Complex) {
        Complex c = (Complex) other;
        if (c.isNaN) {
            return isNaN;
        } else {
            return (real == c.real) && (imaginary == c.imaginary);
        }
    }
    return false;
}","public void test116126() throws Throwable {
    Complex complex0 = new Complex((-464.584278398));
    Complex complex1 = complex0.ZERO.multiply((-464.584278398));
    Complex complex2 = complex1.I.divide(complex0);
    Complex complex3 = complex2.sinh();
    Complex complex4 = complex2.NaN.cos();
    complex4.I.hashCode();
    complex2.ONE.toString();
    Complex complex5 = complex0.cos();
    Complex.valueOf(0.0, (-464.584278398));
    Complex complex6 = complex5.ZERO.tanh();
    complex6.I.nthRoot(828);
    complex0.nthRoot(817);
    Complex complex7 = complex0.exp();
    complex5.NaN.sin();
    Complex complex8 = complex7.reciprocal();
    complex8.I.createComplex(828, (-464.584278398));
    complex3.ZERO.pow(0.0);
    complex5.ONE.sqrt1z();
    Complex complex9 = complex5.divide(Double.NaN);
    complex3.INF.pow(Double.NaN);
    complex9.subtract(complex6);
    complex7.getReal();
    complex3.atan();
    complex1.equals(complex2);
}","/**
 * Test for the equality of two Complex objects.
 * If both the real and imaginary parts of two complex numbers
 * are exactly the same, and neither is {@code Double.NaN}, the two
 * Complex objects are considered to be equal.
 * All {@code NaN} values are considered to be equal - i.e, if either
 * (or both) real and imaginary parts of the complex number are equal
 * to {@code Double.NaN}, the complex number is equal to
 * {@code NaN}.
 *
 * @param other Object to test for equality to this
 * @return true if two Complex objects are equal, false if object is
 * {@code null}, not an instance of Complex, or not equal to this Complex
 * instance.
 */"
