focal_method,test_prefix,docstring
"public int getCount(int... c) throws OutOfRangeException {
    if (c.length != dimension) {
        throw new DimensionMismatchException(c.length, dimension);
    }
    int count = 0;
    for (int i = 0; i < dimension; i++) {
        final int index = c[i];
        if (index < 0 || index >= size[i]) {
            throw new OutOfRangeException(index, 0, size[i] - 1);
        }
        count += uniCounterOffset[i] * c[i];
    }
    return count + c[last];
}","public void test022() throws Throwable {
    int[] intArray0 = new int[2];
    intArray0[0] = 2097;
    intArray0[1] = 1383;
    MultidimensionalCounter multidimensionalCounter0 = new MultidimensionalCounter(intArray0);
    MultidimensionalCounter.Iterator multidimensionalCounter_Iterator0 = multidimensionalCounter0.iterator();
    multidimensionalCounter0.getSize();
    multidimensionalCounter0.getSizes();
    MultidimensionalCounter.Iterator multidimensionalCounter_Iterator1 = multidimensionalCounter0.iterator();
    multidimensionalCounter0.spliterator();
    int[] intArray1 = multidimensionalCounter_Iterator1.getCounts();
    int int0 = new Integer(1383);
    multidimensionalCounter_Iterator0.hasNext();
    try {
        multidimensionalCounter0.getCount(intArray1);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // -1 out of [0, 1,382] range
        //
        verifyException(""org.apache.commons.math.util.MultidimensionalCounter"", e);
    }
}","/**
 * Convert to unidimensional counter.
 *
 * @param c Indices in multidimensional counter.
 * @return the index within the unidimensionl counter.
 * @throws DimensionMismatchException if the size of {@code c}
 * does not match the size of the array given in the constructor.
 * @throws OutOfRangeException if a value of {@code c} is not in
 * the range of the corresponding dimension, as defined in the
 * {@link MultidimensionalCounter#MultidimensionalCounter(int...) constructor}.
 */"
"public int getCount(int... c) throws OutOfRangeException {
    if (c.length != dimension) {
        throw new DimensionMismatchException(c.length, dimension);
    }
    int count = 0;
    for (int i = 0; i < dimension; i++) {
        final int index = c[i];
        if (index < 0 || index >= size[i]) {
            throw new OutOfRangeException(index, 0, size[i] - 1);
        }
        count += uniCounterOffset[i] * c[i];
    }
    return count + c[last];
}","public void test033() throws Throwable {
    int[] intArray0 = new int[2];
    intArray0[0] = (-672);
    intArray0[1] = (-672);
    MultidimensionalCounter multidimensionalCounter0 = new MultidimensionalCounter(intArray0);
    multidimensionalCounter0.spliterator();
    MultidimensionalCounter.Iterator multidimensionalCounter_Iterator0 = multidimensionalCounter0.iterator();
    int[] intArray1 = multidimensionalCounter_Iterator0.getCounts();
    multidimensionalCounter_Iterator0.hasNext();
    try {
        multidimensionalCounter0.getCount(intArray1);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // 0 out of [0, -673] range
        //
        verifyException(""org.apache.commons.math.util.MultidimensionalCounter"", e);
    }
}","/**
 * Convert to unidimensional counter.
 *
 * @param c Indices in multidimensional counter.
 * @return the index within the unidimensionl counter.
 * @throws DimensionMismatchException if the size of {@code c}
 * does not match the size of the array given in the constructor.
 * @throws OutOfRangeException if a value of {@code c} is not in
 * the range of the corresponding dimension, as defined in the
 * {@link MultidimensionalCounter#MultidimensionalCounter(int...) constructor}.
 */"
"public int getCount(int... c) throws OutOfRangeException {
    if (c.length != dimension) {
        throw new DimensionMismatchException(c.length, dimension);
    }
    int count = 0;
    for (int i = 0; i < dimension; i++) {
        final int index = c[i];
        if (index < 0 || index >= size[i]) {
            throw new OutOfRangeException(index, 0, size[i] - 1);
        }
        count += uniCounterOffset[i] * c[i];
    }
    return count + c[last];
}","public void test055() throws Throwable {
    int[] intArray0 = new int[6];
    intArray0[1] = (-529);
    intArray0[1] = 12;
    intArray0[2] = 787;
    intArray0[3] = 0;
    intArray0[4] = (-291);
    int int0 = 0;
    intArray0[5] = (-291);
    int[] intArray1 = null;
    int[] intArray2 = new int[4];
    intArray2[0] = (-291);
    intArray2[1] = (-291);
    intArray2[2] = 787;
    intArray2[3] = 787;
    MultidimensionalCounter multidimensionalCounter0 = new MultidimensionalCounter(intArray2);
    // Undeclared exception!
    try {
        multidimensionalCounter0.getCount((int[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.util.MultidimensionalCounter"", e);
    }
}","/**
 * Convert to unidimensional counter.
 *
 * @param c Indices in multidimensional counter.
 * @return the index within the unidimensionl counter.
 * @throws DimensionMismatchException if the size of {@code c}
 * does not match the size of the array given in the constructor.
 * @throws OutOfRangeException if a value of {@code c} is not in
 * the range of the corresponding dimension, as defined in the
 * {@link MultidimensionalCounter#MultidimensionalCounter(int...) constructor}.
 */"
"public int[] getCounts(int index) {
    if (index < 0 || index >= totalSize) {
        throw new OutOfRangeException(index, 0, totalSize);
    }
    final int[] indices = new int[dimension];
    int count = 0;
    for (int i = 0; i < last; i++) {
        int idx = 0;
        final int offset = uniCounterOffset[i];
        while (count <= index) {
            count += offset;
            ++idx;
        }
        --idx;
        count -= offset;
        indices[i] = idx;
    }
    int idx = 1;
    while (count < index) {
        count += idx;
        ++idx;
    }
    --idx;
    indices[last] = idx;
    return indices;
}","public void test077() throws Throwable {
    int[] intArray0 = new int[1];
    int int0 = 1860;
    intArray0[0] = 1860;
    MultidimensionalCounter multidimensionalCounter0 = new MultidimensionalCounter(intArray0);
    Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
    multidimensionalCounter0.forEach(consumer0);
    multidimensionalCounter0.spliterator();
    multidimensionalCounter0.spliterator();
    Consumer<Integer> consumer1 = (Consumer<Integer>) mock(Consumer.class, new ViolatedAssumptionAnswer());
    multidimensionalCounter0.toString();
    multidimensionalCounter0.forEach(consumer1);
    // Undeclared exception!
    try {
        multidimensionalCounter0.getCounts(2690);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // 2,690 out of [0, 1,860] range
        //
        verifyException(""org.apache.commons.math.util.MultidimensionalCounter"", e);
    }
}","/**
 * Convert to multidimensional counter.
 *
 * @param index Index in unidimensional counter.
 * @return the multidimensional counts.
 * @throws OutOfRangeException if {@code index} is not between
 * {@code 0} and the value returned by {@link #getSize()} (excluded).
 */"
"public int[] getCounts(int index) {
    if (index < 0 || index >= totalSize) {
        throw new OutOfRangeException(index, 0, totalSize);
    }
    final int[] indices = new int[dimension];
    int count = 0;
    for (int i = 0; i < last; i++) {
        int idx = 0;
        final int offset = uniCounterOffset[i];
        while (count <= index) {
            count += offset;
            ++idx;
        }
        --idx;
        count -= offset;
        indices[i] = idx;
    }
    int idx = 1;
    while (count < index) {
        count += idx;
        ++idx;
    }
    --idx;
    indices[last] = idx;
    return indices;
}","public void test1010() throws Throwable {
    int[] intArray0 = new int[3];
    intArray0[0] = (-924);
    int int0 = 1189;
    intArray0[1] = 1189;
    intArray0[2] = (-1743);
    MultidimensionalCounter multidimensionalCounter0 = new MultidimensionalCounter(intArray0);
    multidimensionalCounter0.getSizes();
    multidimensionalCounter0.spliterator();
    // Undeclared exception!
    multidimensionalCounter0.getCounts(1189);
}","/**
 * Convert to multidimensional counter.
 *
 * @param index Index in unidimensional counter.
 * @return the multidimensional counts.
 * @throws OutOfRangeException if {@code index} is not between
 * {@code 0} and the value returned by {@link #getSize()} (excluded).
 */"
"public int[] getCounts(int index) {
    if (index < 0 || index >= totalSize) {
        throw new OutOfRangeException(index, 0, totalSize);
    }
    final int[] indices = new int[dimension];
    int count = 0;
    for (int i = 0; i < last; i++) {
        int idx = 0;
        final int offset = uniCounterOffset[i];
        while (count <= index) {
            count += offset;
            ++idx;
        }
        --idx;
        count -= offset;
        indices[i] = idx;
    }
    int idx = 1;
    while (count < index) {
        count += idx;
        ++idx;
    }
    --idx;
    indices[last] = idx;
    return indices;
}","public void test1111() throws Throwable {
    int[] intArray0 = new int[1];
    intArray0[0] = 1;
    MultidimensionalCounter multidimensionalCounter0 = new MultidimensionalCounter(intArray0);
    multidimensionalCounter0.toString();
    // Undeclared exception!
    try {
        multidimensionalCounter0.getCounts(1);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // 1 out of [0, 1] range
        //
        verifyException(""org.apache.commons.math.util.MultidimensionalCounter"", e);
    }
}","/**
 * Convert to multidimensional counter.
 *
 * @param index Index in unidimensional counter.
 * @return the multidimensional counts.
 * @throws OutOfRangeException if {@code index} is not between
 * {@code 0} and the value returned by {@link #getSize()} (excluded).
 */"
"public int[] getCounts(int index) {
    if (index < 0 || index >= totalSize) {
        throw new OutOfRangeException(index, 0, totalSize);
    }
    final int[] indices = new int[dimension];
    int count = 0;
    for (int i = 0; i < last; i++) {
        int idx = 0;
        final int offset = uniCounterOffset[i];
        while (count <= index) {
            count += offset;
            ++idx;
        }
        --idx;
        count -= offset;
        indices[i] = idx;
    }
    int idx = 1;
    while (count < index) {
        count += idx;
        ++idx;
    }
    --idx;
    indices[last] = idx;
    return indices;
}","public void test1212() throws Throwable {
    int[] intArray0 = new int[1];
    intArray0[0] = 1;
    MultidimensionalCounter multidimensionalCounter0 = new MultidimensionalCounter(intArray0);
    // Undeclared exception!
    try {
        multidimensionalCounter0.getCounts(1);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // 1 out of [0, 1] range
        //
        verifyException(""org.apache.commons.math.util.MultidimensionalCounter"", e);
    }
}","/**
 * Convert to multidimensional counter.
 *
 * @param index Index in unidimensional counter.
 * @return the multidimensional counts.
 * @throws OutOfRangeException if {@code index} is not between
 * {@code 0} and the value returned by {@link #getSize()} (excluded).
 */"
"public int getCount(int... c) throws OutOfRangeException {
    if (c.length != dimension) {
        throw new DimensionMismatchException(c.length, dimension);
    }
    int count = 0;
    for (int i = 0; i < dimension; i++) {
        final int index = c[i];
        if (index < 0 || index >= size[i]) {
            throw new OutOfRangeException(index, 0, size[i] - 1);
        }
        count += uniCounterOffset[i] * c[i];
    }
    return count + c[last];
}","public void test1313() throws Throwable {
    int[] intArray0 = new int[1];
    intArray0[0] = 3047;
    MultidimensionalCounter multidimensionalCounter0 = new MultidimensionalCounter(intArray0);
    int[] intArray1 = new int[3];
    intArray1[0] = 3047;
    intArray1[1] = 3047;
    intArray1[2] = 3047;
    // Undeclared exception!
    try {
        multidimensionalCounter0.getCount(intArray1);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // 3 != 1
        //
        verifyException(""org.apache.commons.math.util.MultidimensionalCounter"", e);
    }
}","/**
 * Convert to unidimensional counter.
 *
 * @param c Indices in multidimensional counter.
 * @return the index within the unidimensionl counter.
 * @throws DimensionMismatchException if the size of {@code c}
 * does not match the size of the array given in the constructor.
 * @throws OutOfRangeException if a value of {@code c} is not in
 * the range of the corresponding dimension, as defined in the
 * {@link MultidimensionalCounter#MultidimensionalCounter(int...) constructor}.
 */"
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    for (int i = 0; i < dimension; i++) {
        sb.append(""["").append(getCount(i)).append(""]"");
    }
    return sb.toString();
}","public void test1414() throws Throwable {
    int[] intArray0 = new int[2];
    intArray0[0] = (-483);
    intArray0[1] = (-2744);
    MultidimensionalCounter multidimensionalCounter0 = new MultidimensionalCounter(intArray0);
    // Undeclared exception!
    try {
        multidimensionalCounter0.toString();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // 1 != 2
        //
        verifyException(""org.apache.commons.math.util.MultidimensionalCounter"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    for (int i = 0; i < dimension; i++) {
        sb.append(""["").append(getCount(i)).append(""]"");
    }
    return sb.toString();
}","public void test1515() throws Throwable {
    int[] intArray0 = new int[3];
    intArray0[0] = 35;
    intArray0[1] = 1;
    intArray0[2] = 1;
    MultidimensionalCounter multidimensionalCounter0 = new MultidimensionalCounter(intArray0);
    multidimensionalCounter0.getDimension();
    // Undeclared exception!
    try {
        multidimensionalCounter0.toString();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // 1 != 3
        //
        verifyException(""org.apache.commons.math.util.MultidimensionalCounter"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public int getCount(int... c) throws OutOfRangeException {
    if (c.length != dimension) {
        throw new DimensionMismatchException(c.length, dimension);
    }
    int count = 0;
    for (int i = 0; i < dimension; i++) {
        final int index = c[i];
        if (index < 0 || index >= size[i]) {
            throw new OutOfRangeException(index, 0, size[i] - 1);
        }
        count += uniCounterOffset[i] * c[i];
    }
    return count + c[last];
}","public void test1616() throws Throwable {
    int[] intArray0 = new int[7];
    intArray0[0] = (-2014);
    intArray0[1] = (-817);
    intArray0[2] = 276;
    intArray0[3] = (-1);
    intArray0[4] = 840;
    intArray0[5] = 1873;
    intArray0[6] = (-3518);
    MultidimensionalCounter multidimensionalCounter0 = new MultidimensionalCounter(intArray0);
    multidimensionalCounter0.iterator();
    multidimensionalCounter0.spliterator();
    try {
        multidimensionalCounter0.getCount(intArray0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // -2,014 out of [0, -2,015] range
        //
        verifyException(""org.apache.commons.math.util.MultidimensionalCounter"", e);
    }
}","/**
 * Convert to unidimensional counter.
 *
 * @param c Indices in multidimensional counter.
 * @return the index within the unidimensionl counter.
 * @throws DimensionMismatchException if the size of {@code c}
 * does not match the size of the array given in the constructor.
 * @throws OutOfRangeException if a value of {@code c} is not in
 * the range of the corresponding dimension, as defined in the
 * {@link MultidimensionalCounter#MultidimensionalCounter(int...) constructor}.
 */"
"public int getCount(int... c) throws OutOfRangeException {
    if (c.length != dimension) {
        throw new DimensionMismatchException(c.length, dimension);
    }
    int count = 0;
    for (int i = 0; i < dimension; i++) {
        final int index = c[i];
        if (index < 0 || index >= size[i]) {
            throw new OutOfRangeException(index, 0, size[i] - 1);
        }
        count += uniCounterOffset[i] * c[i];
    }
    return count + c[last];
}","public void test1717() throws Throwable {
    int[] intArray0 = new int[3];
    intArray0[0] = (-4460);
    intArray0[1] = (-1677);
    intArray0[2] = 1900;
    MultidimensionalCounter multidimensionalCounter0 = new MultidimensionalCounter(intArray0);
    try {
        multidimensionalCounter0.getCount(intArray0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // -4,460 out of [0, -4,461] range
        //
        verifyException(""org.apache.commons.math.util.MultidimensionalCounter"", e);
    }
}","/**
 * Convert to unidimensional counter.
 *
 * @param c Indices in multidimensional counter.
 * @return the index within the unidimensionl counter.
 * @throws DimensionMismatchException if the size of {@code c}
 * does not match the size of the array given in the constructor.
 * @throws OutOfRangeException if a value of {@code c} is not in
 * the range of the corresponding dimension, as defined in the
 * {@link MultidimensionalCounter#MultidimensionalCounter(int...) constructor}.
 */"
"public int getCount(int... c) throws OutOfRangeException {
    if (c.length != dimension) {
        throw new DimensionMismatchException(c.length, dimension);
    }
    int count = 0;
    for (int i = 0; i < dimension; i++) {
        final int index = c[i];
        if (index < 0 || index >= size[i]) {
            throw new OutOfRangeException(index, 0, size[i] - 1);
        }
        count += uniCounterOffset[i] * c[i];
    }
    return count + c[last];
}","public void test1818() throws Throwable {
    int[] intArray0 = new int[1];
    intArray0[0] = 188;
    MultidimensionalCounter multidimensionalCounter0 = new MultidimensionalCounter(intArray0);
    try {
        multidimensionalCounter0.getCount(intArray0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // 188 out of [0, 187] range
        //
        verifyException(""org.apache.commons.math.util.MultidimensionalCounter"", e);
    }
}","/**
 * Convert to unidimensional counter.
 *
 * @param c Indices in multidimensional counter.
 * @return the index within the unidimensionl counter.
 * @throws DimensionMismatchException if the size of {@code c}
 * does not match the size of the array given in the constructor.
 * @throws OutOfRangeException if a value of {@code c} is not in
 * the range of the corresponding dimension, as defined in the
 * {@link MultidimensionalCounter#MultidimensionalCounter(int...) constructor}.
 */"
"public int getSize() {
    return totalSize;
}","public void test1919() throws Throwable {
    int[] intArray0 = new int[3];
    intArray0[0] = (-757);
    intArray0[1] = (-900);
    intArray0[2] = 367;
    MultidimensionalCounter multidimensionalCounter0 = new MultidimensionalCounter(intArray0);
    multidimensionalCounter0.getSize();
}","/**
 * Get the total number of elements.
 *
 * @return the total size of the unidimensional counter.
 */"
"public MultidimensionalCounter(int... size) {
    dimension = size.length;
    this.size = MathUtils.copyOf(size);
    uniCounterOffset = new int[dimension];
    last = dimension - 1;
    int tS = size[last];
    for (int i = 0; i < last; i++) {
        int count = 1;
        for (int j = i + 1; j < dimension; j++) {
            count *= size[j];
        }
        uniCounterOffset[i] = count;
        tS *= size[i];
    }
    uniCounterOffset[last] = 0;
    if (tS <= 0) {
        throw new NotStrictlyPositiveException(tS);
    }
    totalSize = tS;
}","public void test2020() throws Throwable {
    MultidimensionalCounter multidimensionalCounter0 = null;
    try {
        multidimensionalCounter0 = new MultidimensionalCounter((int[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.util.MultidimensionalCounter"", e);
    }
}","/**
 * Create a counter.
 *
 * @param size Counter sizes (number of slots in each dimension).
 * @throws NotStrictlyPositiveException if one of the sizes is
 * negative or zero.
 */"
"public MultidimensionalCounter(int... size) {
    dimension = size.length;
    this.size = MathUtils.copyOf(size);
    uniCounterOffset = new int[dimension];
    last = dimension - 1;
    int tS = size[last];
    for (int i = 0; i < last; i++) {
        int count = 1;
        for (int j = i + 1; j < dimension; j++) {
            count *= size[j];
        }
        uniCounterOffset[i] = count;
        tS *= size[i];
    }
    uniCounterOffset[last] = 0;
    if (tS <= 0) {
        throw new NotStrictlyPositiveException(tS);
    }
    totalSize = tS;
}","public void test2424() throws Throwable {
    int[] intArray0 = new int[0];
    MultidimensionalCounter multidimensionalCounter0 = null;
    try {
        multidimensionalCounter0 = new MultidimensionalCounter(intArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1
        //
        verifyException(""org.apache.commons.math.util.MultidimensionalCounter"", e);
    }
}","/**
 * Create a counter.
 *
 * @param size Counter sizes (number of slots in each dimension).
 * @throws NotStrictlyPositiveException if one of the sizes is
 * negative or zero.
 */"
"public MultidimensionalCounter(int... size) {
    dimension = size.length;
    this.size = MathUtils.copyOf(size);
    uniCounterOffset = new int[dimension];
    last = dimension - 1;
    int tS = size[last];
    for (int i = 0; i < last; i++) {
        int count = 1;
        for (int j = i + 1; j < dimension; j++) {
            count *= size[j];
        }
        uniCounterOffset[i] = count;
        tS *= size[i];
    }
    uniCounterOffset[last] = 0;
    if (tS <= 0) {
        throw new NotStrictlyPositiveException(tS);
    }
    totalSize = tS;
}","public void test2525() throws Throwable {
    int[] intArray0 = new int[6];
    intArray0[0] = 0;
    intArray0[1] = 750;
    intArray0[2] = (-1);
    intArray0[3] = 1;
    intArray0[4] = 507;
    intArray0[5] = 0;
    MultidimensionalCounter multidimensionalCounter0 = null;
    try {
        multidimensionalCounter0 = new MultidimensionalCounter(intArray0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // 0 is smaller than, or equal to, the minimum (0)
        //
        verifyException(""org.apache.commons.math.util.MultidimensionalCounter"", e);
    }
}","/**
 * Create a counter.
 *
 * @param size Counter sizes (number of slots in each dimension).
 * @throws NotStrictlyPositiveException if one of the sizes is
 * negative or zero.
 */"
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    for (int i = 0; i < dimension; i++) {
        sb.append(""["").append(getCount(i)).append(""]"");
    }
    return sb.toString();
}","public void test2626() throws Throwable {
    int[] intArray0 = new int[1];
    intArray0[0] = 567;
    MultidimensionalCounter multidimensionalCounter0 = new MultidimensionalCounter(intArray0);
    Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
    multidimensionalCounter0.forEach(consumer0);
    multidimensionalCounter0.toString();
    String string0 = multidimensionalCounter0.toString();
    assertEquals(""[0]"", string0);
}","/**
 * {@inheritDoc}
 */"
"public int getSize() {
    return totalSize;
}","public void test2627() throws Throwable {
    int[] intArray0 = new int[1];
    intArray0[0] = 567;
    MultidimensionalCounter multidimensionalCounter0 = new MultidimensionalCounter(intArray0);
    Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
    multidimensionalCounter0.forEach(consumer0);
    multidimensionalCounter0.toString();
    String string0 = multidimensionalCounter0.toString();
    assertEquals(567, multidimensionalCounter0.getSize());
}","/**
 * Get the total number of elements.
 *
 * @return the total size of the unidimensional counter.
 */"
"public int getSize() {
    return totalSize;
}","public void test2728() throws Throwable {
    int[] intArray0 = new int[4];
    intArray0[0] = 2454;
    intArray0[1] = 113;
    intArray0[2] = 3051;
    intArray0[3] = 173;
    MultidimensionalCounter multidimensionalCounter0 = new MultidimensionalCounter(intArray0);
    MultidimensionalCounter.Iterator multidimensionalCounter_Iterator0 = multidimensionalCounter0.new Iterator();
    boolean boolean0 = multidimensionalCounter_Iterator0.hasNext();
    assertEquals(337485482, multidimensionalCounter0.getSize());
}","/**
 * Get the total number of elements.
 *
 * @return the total size of the unidimensional counter.
 */"
"public int getSize() {
    return totalSize;
}","public void test2832() throws Throwable {
    int[] intArray0 = new int[8];
    intArray0[0] = (-322);
    intArray0[1] = 127;
    intArray0[2] = 412;
    intArray0[3] = 1362;
    intArray0[4] = (-1799);
    intArray0[5] = (-1462);
    intArray0[6] = 9958;
    intArray0[7] = 1099;
    MultidimensionalCounter multidimensionalCounter0 = new MultidimensionalCounter(intArray0);
    Integer integer0 = new Integer(127);
    MultidimensionalCounter.Iterator multidimensionalCounter_Iterator0 = multidimensionalCounter0.new Iterator();
    multidimensionalCounter_Iterator0.hasNext();
    int[] intArray1 = multidimensionalCounter0.getCounts(182);
    assertEquals(239459520, multidimensionalCounter0.getSize());
}","/**
 * Get the total number of elements.
 *
 * @return the total size of the unidimensional counter.
 */"
"public int[] getCounts(int index) {
    if (index < 0 || index >= totalSize) {
        throw new OutOfRangeException(index, 0, totalSize);
    }
    final int[] indices = new int[dimension];
    int count = 0;
    for (int i = 0; i < last; i++) {
        int idx = 0;
        final int offset = uniCounterOffset[i];
        while (count <= index) {
            count += offset;
            ++idx;
        }
        --idx;
        count -= offset;
        indices[i] = idx;
    }
    int idx = 1;
    while (count < index) {
        count += idx;
        ++idx;
    }
    --idx;
    indices[last] = idx;
    return indices;
}","public void test2833() throws Throwable {
    int[] intArray0 = new int[8];
    intArray0[0] = (-322);
    intArray0[1] = 127;
    intArray0[2] = 412;
    intArray0[3] = 1362;
    intArray0[4] = (-1799);
    intArray0[5] = (-1462);
    intArray0[6] = 9958;
    intArray0[7] = 1099;
    MultidimensionalCounter multidimensionalCounter0 = new MultidimensionalCounter(intArray0);
    Integer integer0 = new Integer(127);
    MultidimensionalCounter.Iterator multidimensionalCounter_Iterator0 = multidimensionalCounter0.new Iterator();
    multidimensionalCounter_Iterator0.hasNext();
    int[] intArray1 = multidimensionalCounter0.getCounts(182);
    assertArrayEquals(new int[] { 0, 8, 5, 1, 1, 0, 5412, 44 }, intArray1);
}","/**
 * Convert to multidimensional counter.
 *
 * @param index Index in unidimensional counter.
 * @return the multidimensional counts.
 * @throws OutOfRangeException if {@code index} is not between
 * {@code 0} and the value returned by {@link #getSize()} (excluded).
 */"
"public int[] getCounts(int index) {
    if (index < 0 || index >= totalSize) {
        throw new OutOfRangeException(index, 0, totalSize);
    }
    final int[] indices = new int[dimension];
    int count = 0;
    for (int i = 0; i < last; i++) {
        int idx = 0;
        final int offset = uniCounterOffset[i];
        while (count <= index) {
            count += offset;
            ++idx;
        }
        --idx;
        count -= offset;
        indices[i] = idx;
    }
    int idx = 1;
    while (count < index) {
        count += idx;
        ++idx;
    }
    --idx;
    indices[last] = idx;
    return indices;
}","public void test2934() throws Throwable {
    int[] intArray0 = new int[2];
    intArray0[0] = 2504;
    intArray0[1] = 8;
    MultidimensionalCounter multidimensionalCounter0 = new MultidimensionalCounter(intArray0);
    multidimensionalCounter0.spliterator();
    // Undeclared exception!
    try {
        multidimensionalCounter0.getCounts((-4029));
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // -4,029 out of [0, 20,032] range
        //
        verifyException(""org.apache.commons.math.util.MultidimensionalCounter"", e);
    }
}","/**
 * Convert to multidimensional counter.
 *
 * @param index Index in unidimensional counter.
 * @return the multidimensional counts.
 * @throws OutOfRangeException if {@code index} is not between
 * {@code 0} and the value returned by {@link #getSize()} (excluded).
 */"
"public MultidimensionalCounter(int... size) {
    dimension = size.length;
    this.size = MathUtils.copyOf(size);
    uniCounterOffset = new int[dimension];
    last = dimension - 1;
    int tS = size[last];
    for (int i = 0; i < last; i++) {
        int count = 1;
        for (int j = i + 1; j < dimension; j++) {
            count *= size[j];
        }
        uniCounterOffset[i] = count;
        tS *= size[i];
    }
    uniCounterOffset[last] = 0;
    if (tS <= 0) {
        throw new NotStrictlyPositiveException(tS);
    }
    totalSize = tS;
}","public void test3035() throws Throwable {
    int[] intArray0 = new int[5];
    int int0 = 2083;
    intArray0[0] = 2083;
    intArray0[1] = 879;
    intArray0[2] = 0;
    intArray0[3] = 0;
    intArray0[4] = 2047;
    MultidimensionalCounter multidimensionalCounter0 = null;
    try {
        multidimensionalCounter0 = new MultidimensionalCounter(intArray0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // 0 is smaller than, or equal to, the minimum (0)
        //
        verifyException(""org.apache.commons.math.util.MultidimensionalCounter"", e);
    }
}","/**
 * Create a counter.
 *
 * @param size Counter sizes (number of slots in each dimension).
 * @throws NotStrictlyPositiveException if one of the sizes is
 * negative or zero.
 */"
"public MultidimensionalCounter(int... size) {
    dimension = size.length;
    this.size = MathUtils.copyOf(size);
    uniCounterOffset = new int[dimension];
    last = dimension - 1;
    int tS = size[last];
    for (int i = 0; i < last; i++) {
        int count = 1;
        for (int j = i + 1; j < dimension; j++) {
            count *= size[j];
        }
        uniCounterOffset[i] = count;
        tS *= size[i];
    }
    uniCounterOffset[last] = 0;
    if (tS <= 0) {
        throw new NotStrictlyPositiveException(tS);
    }
    totalSize = tS;
}","public void test3136() throws Throwable {
    int[] intArray0 = new int[5];
    intArray0[0] = 0;
    intArray0[1] = 0;
    intArray0[2] = (-1464);
    intArray0[3] = 1495;
    intArray0[4] = (-1);
    MultidimensionalCounter multidimensionalCounter0 = null;
    try {
        multidimensionalCounter0 = new MultidimensionalCounter(intArray0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // 0 is smaller than, or equal to, the minimum (0)
        //
        verifyException(""org.apache.commons.math.util.MultidimensionalCounter"", e);
    }
}","/**
 * Create a counter.
 *
 * @param size Counter sizes (number of slots in each dimension).
 * @throws NotStrictlyPositiveException if one of the sizes is
 * negative or zero.
 */"
"public MultidimensionalCounter(int... size) {
    dimension = size.length;
    this.size = MathUtils.copyOf(size);
    uniCounterOffset = new int[dimension];
    last = dimension - 1;
    int tS = size[last];
    for (int i = 0; i < last; i++) {
        int count = 1;
        for (int j = i + 1; j < dimension; j++) {
            count *= size[j];
        }
        uniCounterOffset[i] = count;
        tS *= size[i];
    }
    uniCounterOffset[last] = 0;
    if (tS <= 0) {
        throw new NotStrictlyPositiveException(tS);
    }
    totalSize = tS;
}","public void test3237() throws Throwable {
    int[] intArray0 = new int[5];
    intArray0[0] = 0;
    intArray0[1] = 2128;
    intArray0[2] = 565;
    intArray0[3] = (-1505);
    intArray0[4] = 874;
    MultidimensionalCounter multidimensionalCounter0 = null;
    try {
        multidimensionalCounter0 = new MultidimensionalCounter(intArray0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // 0 is smaller than, or equal to, the minimum (0)
        //
        verifyException(""org.apache.commons.math.util.MultidimensionalCounter"", e);
    }
}","/**
 * Create a counter.
 *
 * @param size Counter sizes (number of slots in each dimension).
 * @throws NotStrictlyPositiveException if one of the sizes is
 * negative or zero.
 */"
"public int getCount(int... c) throws OutOfRangeException {
    if (c.length != dimension) {
        throw new DimensionMismatchException(c.length, dimension);
    }
    int count = 0;
    for (int i = 0; i < dimension; i++) {
        final int index = c[i];
        if (index < 0 || index >= size[i]) {
            throw new OutOfRangeException(index, 0, size[i] - 1);
        }
        count += uniCounterOffset[i] * c[i];
    }
    return count + c[last];
}","public void test3338() throws Throwable {
    int[] intArray0 = new int[1];
    intArray0[0] = 3064;
    MultidimensionalCounter multidimensionalCounter0 = new MultidimensionalCounter(intArray0);
    int[] intArray1 = new int[5];
    intArray1[0] = 3064;
    multidimensionalCounter0.getSizes();
    intArray1[1] = 3064;
    int int0 = 0;
    try {
        multidimensionalCounter0.getCount(intArray0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // 3,064 out of [0, 3,063] range
        //
        verifyException(""org.apache.commons.math.util.MultidimensionalCounter"", e);
    }
}","/**
 * Convert to unidimensional counter.
 *
 * @param c Indices in multidimensional counter.
 * @return the index within the unidimensionl counter.
 * @throws DimensionMismatchException if the size of {@code c}
 * does not match the size of the array given in the constructor.
 * @throws OutOfRangeException if a value of {@code c} is not in
 * the range of the corresponding dimension, as defined in the
 * {@link MultidimensionalCounter#MultidimensionalCounter(int...) constructor}.
 */"
"@Override
public String toString() {
    final StringBuilder sb = new StringBuilder();
    for (int i = 0; i < dimension; i++) {
        sb.append(""["").append(getCount(i)).append(""]"");
    }
    return sb.toString();
}","public void test3439() throws Throwable {
    int[] intArray0 = new int[2];
    intArray0[0] = 1215;
    intArray0[1] = 8388607;
    MultidimensionalCounter multidimensionalCounter0 = new MultidimensionalCounter(intArray0);
    multidimensionalCounter0.spliterator();
    multidimensionalCounter0.getSize();
    multidimensionalCounter0.getCounts(8388607);
    multidimensionalCounter0.getDimension();
    MultidimensionalCounter.Iterator multidimensionalCounter_Iterator0 = multidimensionalCounter0.iterator();
    Consumer<Integer> consumer0 = (Consumer<Integer>) mock(Consumer.class, new ViolatedAssumptionAnswer());
    multidimensionalCounter_Iterator0.getCounts();
    multidimensionalCounter_Iterator0.getCounts();
    // Undeclared exception!
    try {
        multidimensionalCounter0.toString();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // 1 != 2
        //
        verifyException(""org.apache.commons.math.util.MultidimensionalCounter"", e);
    }
}","/**
 * {@inheritDoc}
 */"
