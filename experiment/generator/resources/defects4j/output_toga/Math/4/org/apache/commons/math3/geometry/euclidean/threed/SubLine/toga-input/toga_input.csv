focal_method,test_prefix,docstring
"public SubLine(final Vector3D start, final Vector3D end) throws MathIllegalArgumentException {
    this(new Line(start, end), buildIntervalSet(start, end));
}","public void test000() throws Throwable {
    Vector3D vector3D0 = Vector3D.NaN;
    SubLine subLine0 = new SubLine(vector3D0, vector3D0);
}","/**
 * Create a sub-line from two endpoints.
 * @param start start point
 * @param end end point
 * @exception MathIllegalArgumentException if the points are equal
 */"
"public double getZ() {
    return z;
}","public void test011() throws Throwable {
    Vector3D vector3D0 = Vector3D.PLUS_K;
    Vector3D vector3D1 = new Vector3D(291.5, vector3D0, (-397.80643760046), vector3D0, 1.0, vector3D0);
    Line line0 = new Line(vector3D1, vector3D0);
    SubLine subLine0 = line0.wholeLine();
    Vector3D vector3D2 = subLine0.intersection(subLine0, false);
    assertEquals((-4.904884955916964E-15), vector3D2.getZ(), 0.01);
}","/**
 * Get the height of the vector.
 * @return height of the vector
 * @see #Vector3D(double, double, double)
 */"
"public double getNormSq() {
    // there are no cancellation problems here, so we use the straightforward formula
    return x * x + y * y + z * z;
}","public void test022() throws Throwable {
    Vector3D vector3D0 = new Vector3D(4420.3, 1.0, 4420.3);
    Vector3D vector3D1 = Vector3D.MINUS_J;
    Line line0 = new Line(vector3D1, vector3D0);
    SubLine subLine0 = line0.wholeLine();
    Vector3D vector3D2 = subLine0.intersection(subLine0, true);
    assertEquals(0.9999998976408995, vector3D2.getNormSq(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {
    // compute the intersection on infinite line
    Vector3D v1D = line.intersection(subLine.line);
    // check location of point with respect to first sub-line
    Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
    // check location of point with respect to second sub-line
    Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
    if (includeEndPoints) {
        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;
    } else {
        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;
    }
}","public void test033() throws Throwable {
    Vector3D vector3D0 = Vector3D.PLUS_J;
    Vector3D vector3D1 = Vector3D.MINUS_I;
    Line line0 = new Line(vector3D0, vector3D1);
    SubLine subLine0 = line0.wholeLine();
    Vector3D vector3D2 = subLine0.intersection(subLine0, true);
    assertNotSame(vector3D1, vector3D2);
}","/**
 * Get the intersection of the instance and another sub-line.
 * <p>
 * This method is related to the {@link Line#intersection(Line)
 * intersection} method in the {@link Line Line} class, but in addition
 * to compute the point along infinite lines, it also checks the point
 * lies on both sub-line ranges.
 * </p>
 * @param subLine other sub-line which may intersect instance
 * @param includeEndPoints if true, endpoints are considered to belong to
 * instance (i.e. they are closed sets) and may be returned, otherwise endpoints
 * are considered to not belong to instance (i.e. they are open sets) and intersection
 * occurring on endpoints lead to null being returned
 * @return the intersection point if there is one, null if the sub-lines don't intersect
 */"
"public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {
    // compute the intersection on infinite line
    Vector3D v1D = line.intersection(subLine.line);
    // check location of point with respect to first sub-line
    Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
    // check location of point with respect to second sub-line
    Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
    if (includeEndPoints) {
        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;
    } else {
        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;
    }
}","public void test044() throws Throwable {
    Vector3D vector3D0 = Vector3D.PLUS_J;
    Vector3D vector3D1 = new Vector3D(0.0, vector3D0);
    Line line0 = new Line(vector3D0, vector3D1);
    IntervalsSet intervalsSet0 = new IntervalsSet();
    SubLine subLine0 = new SubLine(line0, intervalsSet0);
    Vector3D vector3D2 = subLine0.intersection(subLine0, true);
    assertNotSame(vector3D0, vector3D2);
}","/**
 * Get the intersection of the instance and another sub-line.
 * <p>
 * This method is related to the {@link Line#intersection(Line)
 * intersection} method in the {@link Line Line} class, but in addition
 * to compute the point along infinite lines, it also checks the point
 * lies on both sub-line ranges.
 * </p>
 * @param subLine other sub-line which may intersect instance
 * @param includeEndPoints if true, endpoints are considered to belong to
 * instance (i.e. they are closed sets) and may be returned, otherwise endpoints
 * are considered to not belong to instance (i.e. they are open sets) and intersection
 * occurring on endpoints lead to null being returned
 * @return the intersection point if there is one, null if the sub-lines don't intersect
 */"
"public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {
    // compute the intersection on infinite line
    Vector3D v1D = line.intersection(subLine.line);
    // check location of point with respect to first sub-line
    Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
    // check location of point with respect to second sub-line
    Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
    if (includeEndPoints) {
        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;
    } else {
        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;
    }
}","public void test055() throws Throwable {
    Vector3D vector3D0 = Vector3D.PLUS_J;
    Vector3D vector3D1 = Vector3D.MINUS_I;
    Line line0 = new Line(vector3D0, vector3D1);
    SubLine subLine0 = line0.wholeLine();
    // Undeclared exception!
    try {
        subLine0.intersection((SubLine) null, true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.geometry.euclidean.threed.SubLine"", e);
    }
}","/**
 * Get the intersection of the instance and another sub-line.
 * <p>
 * This method is related to the {@link Line#intersection(Line)
 * intersection} method in the {@link Line Line} class, but in addition
 * to compute the point along infinite lines, it also checks the point
 * lies on both sub-line ranges.
 * </p>
 * @param subLine other sub-line which may intersect instance
 * @param includeEndPoints if true, endpoints are considered to belong to
 * instance (i.e. they are closed sets) and may be returned, otherwise endpoints
 * are considered to not belong to instance (i.e. they are open sets) and intersection
 * occurring on endpoints lead to null being returned
 * @return the intersection point if there is one, null if the sub-lines don't intersect
 */"
"public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {
    // compute the intersection on infinite line
    Vector3D v1D = line.intersection(subLine.line);
    // check location of point with respect to first sub-line
    Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
    // check location of point with respect to second sub-line
    Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
    if (includeEndPoints) {
        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;
    } else {
        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;
    }
}","public void test066() throws Throwable {
    Vector3D vector3D0 = Vector3D.PLUS_K;
    Vector3D vector3D1 = new Vector3D(291.5, vector3D0, 291.5, vector3D0, 291.5, vector3D0);
    Line line0 = new Line(vector3D1, vector3D0);
    SubLine subLine0 = line0.wholeLine();
    Vector1D vector1D0 = Vector1D.NaN;
    OrientedPoint orientedPoint0 = new OrientedPoint(vector1D0, true);
    IntervalsSet intervalsSet0 = orientedPoint0.wholeSpace();
    SubOrientedPoint subOrientedPoint0 = new SubOrientedPoint(orientedPoint0, intervalsSet0);
    BSPTree<Euclidean1D> bSPTree0 = new BSPTree<Euclidean1D>(subOrientedPoint0);
    IntervalsSet intervalsSet1 = intervalsSet0.buildNew(bSPTree0);
    SubLine subLine1 = new SubLine(line0, intervalsSet1);
    // Undeclared exception!
    try {
        subLine0.intersection(subLine1, true);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint cannot be cast to java.lang.Boolean
        //
        verifyException(""org.apache.commons.math3.geometry.partitioning.AbstractRegion"", e);
    }
}","/**
 * Get the intersection of the instance and another sub-line.
 * <p>
 * This method is related to the {@link Line#intersection(Line)
 * intersection} method in the {@link Line Line} class, but in addition
 * to compute the point along infinite lines, it also checks the point
 * lies on both sub-line ranges.
 * </p>
 * @param subLine other sub-line which may intersect instance
 * @param includeEndPoints if true, endpoints are considered to belong to
 * instance (i.e. they are closed sets) and may be returned, otherwise endpoints
 * are considered to not belong to instance (i.e. they are open sets) and intersection
 * occurring on endpoints lead to null being returned
 * @return the intersection point if there is one, null if the sub-lines don't intersect
 */"
"public List<Segment> getSegments() {
    final List<Interval> list = remainingRegion.asList();
    final List<Segment> segments = new ArrayList<Segment>();
    for (final Interval interval : list) {
        final Vector3D start = line.toSpace(new Vector1D(interval.getInf()));
        final Vector3D end = line.toSpace(new Vector1D(interval.getSup()));
        segments.add(new Segment(start, end, line));
    }
    return segments;
}","public void test077() throws Throwable {
    Vector3D vector3D0 = Vector3D.POSITIVE_INFINITY;
    Plane plane0 = new Plane(vector3D0, vector3D0);
    Line line0 = plane0.intersection(plane0);
    IntervalsSet intervalsSet0 = new IntervalsSet((-2448.464), (-2448.464));
    IntervalsSet intervalsSet1 = intervalsSet0.buildNew((BSPTree<Euclidean1D>) null);
    SubLine subLine0 = new SubLine(line0, intervalsSet1);
    // Undeclared exception!
    try {
        subLine0.getSegments();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet"", e);
    }
}","/**
 * Get the endpoints of the sub-line.
 * <p>
 * A subline may be any arbitrary number of disjoints segments, so the endpoints
 * are provided as a list of endpoint pairs. Each element of the list represents
 * one segment, and each segment contains a start point at index 0 and an end point
 * at index 1. If the sub-line is unbounded in the negative infinity direction,
 * the start point of the first segment will have infinite coordinates. If the
 * sub-line is unbounded in the positive infinity direction, the end point of the
 * last segment will have infinite coordinates. So a sub-line covering the whole
 * line will contain just one row and both elements of this row will have infinite
 * coordinates. If the sub-line is empty, the returned list will contain 0 segments.
 * </p>
 * @return list of segments endpoints
 */"
"public List<Segment> getSegments() {
    final List<Interval> list = remainingRegion.asList();
    final List<Segment> segments = new ArrayList<Segment>();
    for (final Interval interval : list) {
        final Vector3D start = line.toSpace(new Vector1D(interval.getInf()));
        final Vector3D end = line.toSpace(new Vector1D(interval.getSup()));
        segments.add(new Segment(start, end, line));
    }
    return segments;
}","public void test088() throws Throwable {
    Vector3D vector3D0 = Vector3D.POSITIVE_INFINITY;
    Plane plane0 = new Plane(vector3D0, vector3D0);
    Line line0 = plane0.intersection(plane0);
    IntervalsSet intervalsSet0 = new IntervalsSet((-2448.464), (-2448.464));
    BSPTree<Euclidean1D> bSPTree0 = new BSPTree<Euclidean1D>(""n5D`yg^|E7HA"");
    IntervalsSet intervalsSet1 = intervalsSet0.buildNew(bSPTree0);
    SubLine subLine0 = new SubLine(line0, intervalsSet1);
    // Undeclared exception!
    try {
        subLine0.getSegments();
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // java.lang.String cannot be cast to java.lang.Boolean
        //
        verifyException(""org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet"", e);
    }
}","/**
 * Get the endpoints of the sub-line.
 * <p>
 * A subline may be any arbitrary number of disjoints segments, so the endpoints
 * are provided as a list of endpoint pairs. Each element of the list represents
 * one segment, and each segment contains a start point at index 0 and an end point
 * at index 1. If the sub-line is unbounded in the negative infinity direction,
 * the start point of the first segment will have infinite coordinates. If the
 * sub-line is unbounded in the positive infinity direction, the end point of the
 * last segment will have infinite coordinates. So a sub-line covering the whole
 * line will contain just one row and both elements of this row will have infinite
 * coordinates. If the sub-line is empty, the returned list will contain 0 segments.
 * </p>
 * @return list of segments endpoints
 */"
"public SubLine(final Vector3D start, final Vector3D end) throws MathIllegalArgumentException {
    this(new Line(start, end), buildIntervalSet(start, end));
}","public void test099() throws Throwable {
    SubLine subLine0 = null;
    try {
        subLine0 = new SubLine((Vector3D) null, (Vector3D) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.geometry.euclidean.threed.Line"", e);
    }
}","/**
 * Create a sub-line from two endpoints.
 * @param start start point
 * @param end end point
 * @exception MathIllegalArgumentException if the points are equal
 */"
"public SubLine(final Segment segment) throws MathIllegalArgumentException {
    this(segment.getLine(), buildIntervalSet(segment.getStart(), segment.getEnd()));
}","public void test1010() throws Throwable {
    SubLine subLine0 = null;
    try {
        subLine0 = new SubLine((Segment) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.geometry.euclidean.threed.SubLine"", e);
    }
}","/**
 * Create a sub-line from a segment.
 * @param segment single segment forming the sub-line
 * @exception MathIllegalArgumentException if the segment endpoints are equal
 */"
"public SubLine(final Segment segment) throws MathIllegalArgumentException {
    this(segment.getLine(), buildIntervalSet(segment.getStart(), segment.getEnd()));
}","public void test1111() throws Throwable {
    Vector3D vector3D0 = Vector3D.PLUS_J;
    Vector3D vector3D1 = Vector3D.MINUS_I;
    Line line0 = new Line(vector3D0, vector3D1);
    Segment segment0 = new Segment(vector3D1, vector3D0, line0);
    SubLine subLine0 = new SubLine(segment0);
}","/**
 * Create a sub-line from a segment.
 * @param segment single segment forming the sub-line
 * @exception MathIllegalArgumentException if the segment endpoints are equal
 */"
"public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {
    // compute the intersection on infinite line
    Vector3D v1D = line.intersection(subLine.line);
    // check location of point with respect to first sub-line
    Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
    // check location of point with respect to second sub-line
    Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
    if (includeEndPoints) {
        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;
    } else {
        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;
    }
}","public void test1212() throws Throwable {
    Vector3D vector3D0 = Vector3D.MINUS_K;
    Vector3D vector3D1 = new Vector3D(332.8866725, vector3D0);
    Line line0 = new Line(vector3D1, vector3D0);
    SubLine subLine0 = line0.wholeLine();
    SubLine subLine1 = new SubLine(vector3D0, vector3D1);
    Vector3D vector3D2 = subLine0.intersection(subLine1, false);
    assertNull(vector3D2);
}","/**
 * Get the intersection of the instance and another sub-line.
 * <p>
 * This method is related to the {@link Line#intersection(Line)
 * intersection} method in the {@link Line Line} class, but in addition
 * to compute the point along infinite lines, it also checks the point
 * lies on both sub-line ranges.
 * </p>
 * @param subLine other sub-line which may intersect instance
 * @param includeEndPoints if true, endpoints are considered to belong to
 * instance (i.e. they are closed sets) and may be returned, otherwise endpoints
 * are considered to not belong to instance (i.e. they are open sets) and intersection
 * occurring on endpoints lead to null being returned
 * @return the intersection point if there is one, null if the sub-lines don't intersect
 */"
"public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {
    // compute the intersection on infinite line
    Vector3D v1D = line.intersection(subLine.line);
    // check location of point with respect to first sub-line
    Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
    // check location of point with respect to second sub-line
    Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
    if (includeEndPoints) {
        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;
    } else {
        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;
    }
}","public void test1313() throws Throwable {
    Vector3D vector3D0 = Vector3D.MINUS_K;
    Vector3D vector3D1 = new Vector3D(332.8866725, vector3D0);
    Line line0 = new Line(vector3D1, vector3D0);
    SubLine subLine0 = line0.wholeLine();
    SubLine subLine1 = new SubLine(vector3D0, vector3D1);
    Vector3D vector3D2 = subLine1.intersection(subLine0, false);
    assertNull(vector3D2);
}","/**
 * Get the intersection of the instance and another sub-line.
 * <p>
 * This method is related to the {@link Line#intersection(Line)
 * intersection} method in the {@link Line Line} class, but in addition
 * to compute the point along infinite lines, it also checks the point
 * lies on both sub-line ranges.
 * </p>
 * @param subLine other sub-line which may intersect instance
 * @param includeEndPoints if true, endpoints are considered to belong to
 * instance (i.e. they are closed sets) and may be returned, otherwise endpoints
 * are considered to not belong to instance (i.e. they are open sets) and intersection
 * occurring on endpoints lead to null being returned
 * @return the intersection point if there is one, null if the sub-lines don't intersect
 */"
"public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {
    // compute the intersection on infinite line
    Vector3D v1D = line.intersection(subLine.line);
    // check location of point with respect to first sub-line
    Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
    // check location of point with respect to second sub-line
    Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
    if (includeEndPoints) {
        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;
    } else {
        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;
    }
}","public void test1414() throws Throwable {
    Vector3D vector3D0 = Vector3D.MINUS_K;
    Vector3D vector3D1 = new Vector3D(332.8866725, vector3D0);
    Line line0 = new Line(vector3D1, vector3D0);
    SubLine subLine0 = line0.wholeLine();
    SubLine subLine1 = new SubLine(vector3D0, vector3D1);
    Vector3D vector3D2 = subLine0.intersection(subLine1, true);
    assertNull(vector3D2);
}","/**
 * Get the intersection of the instance and another sub-line.
 * <p>
 * This method is related to the {@link Line#intersection(Line)
 * intersection} method in the {@link Line Line} class, but in addition
 * to compute the point along infinite lines, it also checks the point
 * lies on both sub-line ranges.
 * </p>
 * @param subLine other sub-line which may intersect instance
 * @param includeEndPoints if true, endpoints are considered to belong to
 * instance (i.e. they are closed sets) and may be returned, otherwise endpoints
 * are considered to not belong to instance (i.e. they are open sets) and intersection
 * occurring on endpoints lead to null being returned
 * @return the intersection point if there is one, null if the sub-lines don't intersect
 */"
"public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {
    // compute the intersection on infinite line
    Vector3D v1D = line.intersection(subLine.line);
    // check location of point with respect to first sub-line
    Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
    // check location of point with respect to second sub-line
    Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
    if (includeEndPoints) {
        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;
    } else {
        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;
    }
}","public void test1515() throws Throwable {
    Vector3D vector3D0 = Vector3D.MINUS_K;
    Vector3D vector3D1 = new Vector3D(332.8866725, vector3D0);
    Line line0 = new Line(vector3D1, vector3D0);
    SubLine subLine0 = line0.wholeLine();
    SubLine subLine1 = new SubLine(vector3D0, vector3D1);
    Vector3D vector3D2 = subLine1.intersection(subLine0, true);
    assertNull(vector3D2);
}","/**
 * Get the intersection of the instance and another sub-line.
 * <p>
 * This method is related to the {@link Line#intersection(Line)
 * intersection} method in the {@link Line Line} class, but in addition
 * to compute the point along infinite lines, it also checks the point
 * lies on both sub-line ranges.
 * </p>
 * @param subLine other sub-line which may intersect instance
 * @param includeEndPoints if true, endpoints are considered to belong to
 * instance (i.e. they are closed sets) and may be returned, otherwise endpoints
 * are considered to not belong to instance (i.e. they are open sets) and intersection
 * occurring on endpoints lead to null being returned
 * @return the intersection point if there is one, null if the sub-lines don't intersect
 */"
"public SubLine(final Segment segment) throws MathIllegalArgumentException {
    this(segment.getLine(), buildIntervalSet(segment.getStart(), segment.getEnd()));
}","public void test1717() throws Throwable {
    RotationOrder rotationOrder0 = RotationOrder.YXY;
    Vector3D vector3D0 = rotationOrder0.getA1();
    Segment segment0 = new Segment(vector3D0, vector3D0, (Line) null);
    SubLine subLine0 = null;
    try {
        subLine0 = new SubLine(segment0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // zero norm
        //
        verifyException(""org.apache.commons.math3.geometry.euclidean.threed.Line"", e);
    }
}","/**
 * Create a sub-line from a segment.
 * @param segment single segment forming the sub-line
 * @exception MathIllegalArgumentException if the segment endpoints are equal
 */"
"public SubLine(final Vector3D start, final Vector3D end) throws MathIllegalArgumentException {
    this(new Line(start, end), buildIntervalSet(start, end));
}","public void test1818() throws Throwable {
    Vector3D vector3D0 = Vector3D.MINUS_I;
    SubLine subLine0 = null;
    try {
        subLine0 = new SubLine(vector3D0, vector3D0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // zero norm
        //
        verifyException(""org.apache.commons.math3.geometry.euclidean.threed.Line"", e);
    }
}","/**
 * Create a sub-line from two endpoints.
 * @param start start point
 * @param end end point
 * @exception MathIllegalArgumentException if the points are equal
 */"
