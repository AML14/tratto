focal_method,test_prefix,docstring
"public AbstractSubHyperplane<S, T> copySelf() {
    return buildNew(hyperplane, remainingRegion);
}","public void test000() throws Throwable {
    Vector2D vector2D0 = Vector2D.ZERO;
    Line line0 = new Line(vector2D0, vector2D0);
    SubLine subLine0 = line0.wholeHyperplane();
    AbstractSubHyperplane<Euclidean2D, Euclidean1D> abstractSubHyperplane0 = subLine0.copySelf();
    assertNotSame(subLine0, abstractSubHyperplane0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public Side side(final Hyperplane<Euclidean2D> hyperplane) {
    final Line thisLine = (Line) getHyperplane();
    final Line otherLine = (Line) hyperplane;
    final Vector2D crossing = thisLine.intersection(otherLine);
    if (crossing == null) {
        // the lines are parallel,
        final double global = otherLine.getOffset(thisLine);
        return (global < -1.0e-10) ? Side.MINUS : ((global > 1.0e-10) ? Side.PLUS : Side.HYPER);
    }
    // the lines do intersect
    final boolean direct = FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) < 0;
    final Vector1D x = thisLine.toSubSpace(crossing);
    return getRemainingRegion().side(new OrientedPoint(x, direct));
}","public void test011() throws Throwable {
    Vector2D vector2D0 = Vector2D.ZERO;
    Line line0 = new Line(vector2D0, (-3026.663285856013));
    Segment segment0 = new Segment(vector2D0, vector2D0, line0);
    SubLine subLine0 = new SubLine(segment0);
    Side side0 = subLine0.side(line0);
    assertEquals(Side.HYPER, side0);
}","/**
 * {@inheritDoc}
 */"
"public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {
    // retrieve the underlying lines
    Line line1 = (Line) getHyperplane();
    Line line2 = (Line) subLine.getHyperplane();
    // compute the intersection on infinite line
    Vector2D v2D = line1.intersection(line2);
    // check location of point with respect to first sub-line
    Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));
    // check location of point with respect to second sub-line
    Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));
    if (includeEndPoints) {
        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;
    } else {
        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;
    }
}","public void test022() throws Throwable {
    Vector2D vector2D0 = Vector2D.NaN;
    SubLine subLine0 = new SubLine(vector2D0, vector2D0);
    Vector2D vector2D1 = subLine0.intersection(subLine0, true);
    assertNull(vector2D1);
}","/**
 * Get the intersection of the instance and another sub-line.
 * <p>
 * This method is related to the {@link Line#intersection(Line)
 * intersection} method in the {@link Line Line} class, but in addition
 * to compute the point along infinite lines, it also checks the point
 * lies on both sub-line ranges.
 * </p>
 * @param subLine other sub-line which may intersect instance
 * @param includeEndPoints if true, endpoints are considered to belong to
 * instance (i.e. they are closed sets) and may be returned, otherwise endpoints
 * are considered to not belong to instance (i.e. they are open sets) and intersection
 * occurring on endpoints lead to null being returned
 * @return the intersection point if there is one, null if the sub-lines don't intersect
 */"
"public double getNorm1() {
    return FastMath.abs(x) + FastMath.abs(y);
}","public void test044() throws Throwable {
    Vector2D vector2D0 = Vector2D.NaN;
    Line line0 = new Line(vector2D0, vector2D0);
    SubLine subLine0 = line0.wholeHyperplane();
    Vector2D vector2D1 = subLine0.intersection(subLine0, false);
    assertEquals(Double.NaN, vector2D1.getNorm1(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"@Override
public boolean equals(Object other) {
    if (this == other) {
        return true;
    }
    if (other instanceof Vector2D) {
        final Vector2D rhs = (Vector2D) other;
        if (rhs.isNaN()) {
            return this.isNaN();
        }
        return (x == rhs.x) && (y == rhs.y);
    }
    return false;
}","public void test055() throws Throwable {
    Vector2D vector2D0 = Vector2D.NaN;
    Line line0 = new Line(vector2D0, vector2D0);
    SubLine subLine0 = line0.wholeHyperplane();
    Vector2D vector2D1 = subLine0.intersection(subLine0, true);
    assertTrue(vector2D1.equals((Object) vector2D0));
}","/**
 * Test for the equality of two 2D vectors.
 * <p>
 * If all coordinates of two 2D vectors are exactly the same, and none are
 * <code>Double.NaN</code>, the two 2D vectors are considered to be equal.
 * </p>
 * <p>
 * <code>NaN</code> coordinates are considered to affect globally the vector
 * and be equals to each other - i.e, if either (or all) coordinates of the
 * 2D vector are equal to <code>Double.NaN</code>, the 2D vector is equal to
 * {@link #NaN}.
 * </p>
 *
 * @param other Object to test for equality to this
 * @return true if two 2D vector objects are equal, false if
 *         object is null, not an instance of Vector2D, or
 *         not equal to this Vector2D instance
 */"
"public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {
    // retrieve the underlying lines
    Line line1 = (Line) getHyperplane();
    Line line2 = (Line) subLine.getHyperplane();
    // compute the intersection on infinite line
    Vector2D v2D = line1.intersection(line2);
    // check location of point with respect to first sub-line
    Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));
    // check location of point with respect to second sub-line
    Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));
    if (includeEndPoints) {
        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;
    } else {
        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;
    }
}","public void test066() throws Throwable {
    Vector2D vector2D0 = Vector2D.POSITIVE_INFINITY;
    SubLine subLine0 = new SubLine(vector2D0, vector2D0);
    Hyperplane<Euclidean2D> hyperplane0 = subLine0.getHyperplane();
    IntervalsSet intervalsSet0 = new IntervalsSet();
    SubLine subLine1 = new SubLine(hyperplane0, intervalsSet0);
    Vector2D vector2D1 = subLine1.intersection(subLine0, true);
    assertNull(vector2D1);
}","/**
 * Get the intersection of the instance and another sub-line.
 * <p>
 * This method is related to the {@link Line#intersection(Line)
 * intersection} method in the {@link Line Line} class, but in addition
 * to compute the point along infinite lines, it also checks the point
 * lies on both sub-line ranges.
 * </p>
 * @param subLine other sub-line which may intersect instance
 * @param includeEndPoints if true, endpoints are considered to belong to
 * instance (i.e. they are closed sets) and may be returned, otherwise endpoints
 * are considered to not belong to instance (i.e. they are open sets) and intersection
 * occurring on endpoints lead to null being returned
 * @return the intersection point if there is one, null if the sub-lines don't intersect
 */"
"public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {
    // retrieve the underlying lines
    Line line1 = (Line) getHyperplane();
    Line line2 = (Line) subLine.getHyperplane();
    // compute the intersection on infinite line
    Vector2D v2D = line1.intersection(line2);
    // check location of point with respect to first sub-line
    Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));
    // check location of point with respect to second sub-line
    Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));
    if (includeEndPoints) {
        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;
    } else {
        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;
    }
}","public void test077() throws Throwable {
    Vector2D vector2D0 = Vector2D.NaN;
    SubLine subLine0 = new SubLine(vector2D0, vector2D0);
    Vector2D vector2D1 = subLine0.intersection(subLine0, false);
    assertNull(vector2D1);
}","/**
 * Get the intersection of the instance and another sub-line.
 * <p>
 * This method is related to the {@link Line#intersection(Line)
 * intersection} method in the {@link Line Line} class, but in addition
 * to compute the point along infinite lines, it also checks the point
 * lies on both sub-line ranges.
 * </p>
 * @param subLine other sub-line which may intersect instance
 * @param includeEndPoints if true, endpoints are considered to belong to
 * instance (i.e. they are closed sets) and may be returned, otherwise endpoints
 * are considered to not belong to instance (i.e. they are open sets) and intersection
 * occurring on endpoints lead to null being returned
 * @return the intersection point if there is one, null if the sub-lines don't intersect
 */"
"public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {
    // retrieve the underlying lines
    Line line1 = (Line) getHyperplane();
    Line line2 = (Line) subLine.getHyperplane();
    // compute the intersection on infinite line
    Vector2D v2D = line1.intersection(line2);
    // check location of point with respect to first sub-line
    Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));
    // check location of point with respect to second sub-line
    Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));
    if (includeEndPoints) {
        return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;
    } else {
        return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;
    }
}","public void test088() throws Throwable {
    Vector2D vector2D0 = Vector2D.POSITIVE_INFINITY;
    SubLine subLine0 = new SubLine(vector2D0, vector2D0);
    Hyperplane<Euclidean2D> hyperplane0 = subLine0.getHyperplane();
    IntervalsSet intervalsSet0 = new IntervalsSet();
    SubLine subLine1 = new SubLine(hyperplane0, intervalsSet0);
    Vector2D vector2D1 = subLine1.intersection(subLine0, false);
    assertNull(vector2D1);
}","/**
 * Get the intersection of the instance and another sub-line.
 * <p>
 * This method is related to the {@link Line#intersection(Line)
 * intersection} method in the {@link Line Line} class, but in addition
 * to compute the point along infinite lines, it also checks the point
 * lies on both sub-line ranges.
 * </p>
 * @param subLine other sub-line which may intersect instance
 * @param includeEndPoints if true, endpoints are considered to belong to
 * instance (i.e. they are closed sets) and may be returned, otherwise endpoints
 * are considered to not belong to instance (i.e. they are open sets) and intersection
 * occurring on endpoints lead to null being returned
 * @return the intersection point if there is one, null if the sub-lines don't intersect
 */"
"@Override
public Side side(final Hyperplane<Euclidean2D> hyperplane) {
    final Line thisLine = (Line) getHyperplane();
    final Line otherLine = (Line) hyperplane;
    final Vector2D crossing = thisLine.intersection(otherLine);
    if (crossing == null) {
        // the lines are parallel,
        final double global = otherLine.getOffset(thisLine);
        return (global < -1.0e-10) ? Side.MINUS : ((global > 1.0e-10) ? Side.PLUS : Side.HYPER);
    }
    // the lines do intersect
    final boolean direct = FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) < 0;
    final Vector1D x = thisLine.toSubSpace(crossing);
    return getRemainingRegion().side(new OrientedPoint(x, direct));
}","public void test099() throws Throwable {
    Vector2D vector2D0 = Vector2D.POSITIVE_INFINITY;
    SubLine subLine0 = new SubLine(vector2D0, vector2D0);
    Hyperplane<Euclidean2D> hyperplane0 = subLine0.getHyperplane();
    Side side0 = subLine0.side(hyperplane0);
    assertEquals(Side.MINUS, side0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public Side side(final Hyperplane<Euclidean2D> hyperplane) {
    final Line thisLine = (Line) getHyperplane();
    final Line otherLine = (Line) hyperplane;
    final Vector2D crossing = thisLine.intersection(otherLine);
    if (crossing == null) {
        // the lines are parallel,
        final double global = otherLine.getOffset(thisLine);
        return (global < -1.0e-10) ? Side.MINUS : ((global > 1.0e-10) ? Side.PLUS : Side.HYPER);
    }
    // the lines do intersect
    final boolean direct = FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) < 0;
    final Vector1D x = thisLine.toSubSpace(crossing);
    return getRemainingRegion().side(new OrientedPoint(x, direct));
}","public void test1010() throws Throwable {
    Vector2D vector2D0 = Vector2D.ZERO;
    Line line0 = new Line(vector2D0, (-3026.663285856013));
    Line line1 = new Line(line0);
    Segment segment0 = new Segment(vector2D0, vector2D0, line1);
    SubLine subLine0 = new SubLine(segment0);
    line0.setOriginOffset((-2489.84438345));
    Side side0 = subLine0.side(line0);
    assertEquals(Side.MINUS, side0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public Side side(final Hyperplane<Euclidean2D> hyperplane) {
    final Line thisLine = (Line) getHyperplane();
    final Line otherLine = (Line) hyperplane;
    final Vector2D crossing = thisLine.intersection(otherLine);
    if (crossing == null) {
        // the lines are parallel,
        final double global = otherLine.getOffset(thisLine);
        return (global < -1.0e-10) ? Side.MINUS : ((global > 1.0e-10) ? Side.PLUS : Side.HYPER);
    }
    // the lines do intersect
    final boolean direct = FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) < 0;
    final Vector1D x = thisLine.toSubSpace(crossing);
    return getRemainingRegion().side(new OrientedPoint(x, direct));
}","public void test1111() throws Throwable {
    Vector2D vector2D0 = Vector2D.ZERO;
    Line line0 = new Line(vector2D0, (-619.764576640369));
    IntervalsSet intervalsSet0 = new IntervalsSet();
    SubLine subLine0 = new SubLine(line0, intervalsSet0);
    Line line1 = new Line(vector2D0, (-619.764576640369));
    line0.setOriginOffset((-184.191494550068));
    Side side0 = subLine0.side(line1);
    assertEquals(Side.PLUS, side0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public Side side(final Hyperplane<Euclidean2D> hyperplane) {
    final Line thisLine = (Line) getHyperplane();
    final Line otherLine = (Line) hyperplane;
    final Vector2D crossing = thisLine.intersection(otherLine);
    if (crossing == null) {
        // the lines are parallel,
        final double global = otherLine.getOffset(thisLine);
        return (global < -1.0e-10) ? Side.MINUS : ((global > 1.0e-10) ? Side.PLUS : Side.HYPER);
    }
    // the lines do intersect
    final boolean direct = FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) < 0;
    final Vector1D x = thisLine.toSubSpace(crossing);
    return getRemainingRegion().side(new OrientedPoint(x, direct));
}","public void test1212() throws Throwable {
    Vector2D vector2D0 = Vector2D.ZERO;
    Line line0 = new Line(vector2D0, 1.0);
    SubLine subLine0 = new SubLine(vector2D0, vector2D0);
    Side side0 = subLine0.side(line0);
    assertEquals(Side.PLUS, side0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public SplitSubHyperplane<Euclidean2D> split(final Hyperplane<Euclidean2D> hyperplane) {
    final Line thisLine = (Line) getHyperplane();
    final Line otherLine = (Line) hyperplane;
    final Vector2D crossing = thisLine.intersection(otherLine);
    if (crossing == null) {
        // the lines are parallel
        final double global = otherLine.getOffset(thisLine);
        return (global < -1.0e-10) ? new SplitSubHyperplane<Euclidean2D>(null, this) : new SplitSubHyperplane<Euclidean2D>(this, null);
    }
    // the lines do intersect
    final boolean direct = FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) < 0;
    final Vector1D x = thisLine.toSubSpace(crossing);
    final SubHyperplane<Euclidean1D> subPlus = new OrientedPoint(x, !direct).wholeHyperplane();
    final SubHyperplane<Euclidean1D> subMinus = new OrientedPoint(x, direct).wholeHyperplane();
    final BSPTree<Euclidean1D> splitTree = getRemainingRegion().getTree(false).split(subMinus);
    final BSPTree<Euclidean1D> plusTree = getRemainingRegion().isEmpty(splitTree.getPlus()) ? new BSPTree<Euclidean1D>(Boolean.FALSE) : new BSPTree<Euclidean1D>(subPlus, new BSPTree<Euclidean1D>(Boolean.FALSE), splitTree.getPlus(), null);
    final BSPTree<Euclidean1D> minusTree = getRemainingRegion().isEmpty(splitTree.getMinus()) ? new BSPTree<Euclidean1D>(Boolean.FALSE) : new BSPTree<Euclidean1D>(subMinus, new BSPTree<Euclidean1D>(Boolean.FALSE), splitTree.getMinus(), null);
    return new SplitSubHyperplane<Euclidean2D>(new SubLine(thisLine.copySelf(), new IntervalsSet(plusTree)), new SubLine(thisLine.copySelf(), new IntervalsSet(minusTree)));
}","public void test1313() throws Throwable {
    Vector2D vector2D0 = Vector2D.ZERO;
    Line line0 = new Line(vector2D0, (-619.764576640369));
    IntervalsSet intervalsSet0 = new IntervalsSet();
    SubLine subLine0 = new SubLine(line0, intervalsSet0);
    SubHyperplane.SplitSubHyperplane<Euclidean2D> subHyperplane_SplitSubHyperplane0 = subLine0.split(line0);
    assertNotNull(subHyperplane_SplitSubHyperplane0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public SplitSubHyperplane<Euclidean2D> split(final Hyperplane<Euclidean2D> hyperplane) {
    final Line thisLine = (Line) getHyperplane();
    final Line otherLine = (Line) hyperplane;
    final Vector2D crossing = thisLine.intersection(otherLine);
    if (crossing == null) {
        // the lines are parallel
        final double global = otherLine.getOffset(thisLine);
        return (global < -1.0e-10) ? new SplitSubHyperplane<Euclidean2D>(null, this) : new SplitSubHyperplane<Euclidean2D>(this, null);
    }
    // the lines do intersect
    final boolean direct = FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) < 0;
    final Vector1D x = thisLine.toSubSpace(crossing);
    final SubHyperplane<Euclidean1D> subPlus = new OrientedPoint(x, !direct).wholeHyperplane();
    final SubHyperplane<Euclidean1D> subMinus = new OrientedPoint(x, direct).wholeHyperplane();
    final BSPTree<Euclidean1D> splitTree = getRemainingRegion().getTree(false).split(subMinus);
    final BSPTree<Euclidean1D> plusTree = getRemainingRegion().isEmpty(splitTree.getPlus()) ? new BSPTree<Euclidean1D>(Boolean.FALSE) : new BSPTree<Euclidean1D>(subPlus, new BSPTree<Euclidean1D>(Boolean.FALSE), splitTree.getPlus(), null);
    final BSPTree<Euclidean1D> minusTree = getRemainingRegion().isEmpty(splitTree.getMinus()) ? new BSPTree<Euclidean1D>(Boolean.FALSE) : new BSPTree<Euclidean1D>(subMinus, new BSPTree<Euclidean1D>(Boolean.FALSE), splitTree.getMinus(), null);
    return new SplitSubHyperplane<Euclidean2D>(new SubLine(thisLine.copySelf(), new IntervalsSet(plusTree)), new SubLine(thisLine.copySelf(), new IntervalsSet(minusTree)));
}","public void test1414() throws Throwable {
    Vector2D vector2D0 = Vector2D.ZERO;
    Line line0 = new Line(vector2D0, vector2D0);
    SubLine subLine0 = line0.wholeHyperplane();
    Line line1 = new Line(line0);
    line1.setOriginOffset((-0.06441789580971566));
    SubHyperplane.SplitSubHyperplane<Euclidean2D> subHyperplane_SplitSubHyperplane0 = subLine0.split(line1);
    assertNotNull(subHyperplane_SplitSubHyperplane0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public SplitSubHyperplane<Euclidean2D> split(final Hyperplane<Euclidean2D> hyperplane) {
    final Line thisLine = (Line) getHyperplane();
    final Line otherLine = (Line) hyperplane;
    final Vector2D crossing = thisLine.intersection(otherLine);
    if (crossing == null) {
        // the lines are parallel
        final double global = otherLine.getOffset(thisLine);
        return (global < -1.0e-10) ? new SplitSubHyperplane<Euclidean2D>(null, this) : new SplitSubHyperplane<Euclidean2D>(this, null);
    }
    // the lines do intersect
    final boolean direct = FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) < 0;
    final Vector1D x = thisLine.toSubSpace(crossing);
    final SubHyperplane<Euclidean1D> subPlus = new OrientedPoint(x, !direct).wholeHyperplane();
    final SubHyperplane<Euclidean1D> subMinus = new OrientedPoint(x, direct).wholeHyperplane();
    final BSPTree<Euclidean1D> splitTree = getRemainingRegion().getTree(false).split(subMinus);
    final BSPTree<Euclidean1D> plusTree = getRemainingRegion().isEmpty(splitTree.getPlus()) ? new BSPTree<Euclidean1D>(Boolean.FALSE) : new BSPTree<Euclidean1D>(subPlus, new BSPTree<Euclidean1D>(Boolean.FALSE), splitTree.getPlus(), null);
    final BSPTree<Euclidean1D> minusTree = getRemainingRegion().isEmpty(splitTree.getMinus()) ? new BSPTree<Euclidean1D>(Boolean.FALSE) : new BSPTree<Euclidean1D>(subMinus, new BSPTree<Euclidean1D>(Boolean.FALSE), splitTree.getMinus(), null);
    return new SplitSubHyperplane<Euclidean2D>(new SubLine(thisLine.copySelf(), new IntervalsSet(plusTree)), new SubLine(thisLine.copySelf(), new IntervalsSet(minusTree)));
}","public void test1515() throws Throwable {
    Vector2D vector2D0 = Vector2D.ZERO;
    Line line0 = new Line(vector2D0, 45.27502593443734);
    SubLine subLine0 = new SubLine(vector2D0, vector2D0);
    SubHyperplane.SplitSubHyperplane<Euclidean2D> subHyperplane_SplitSubHyperplane0 = subLine0.split(line0);
    assertNotNull(subHyperplane_SplitSubHyperplane0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public SplitSubHyperplane<Euclidean2D> split(final Hyperplane<Euclidean2D> hyperplane) {
    final Line thisLine = (Line) getHyperplane();
    final Line otherLine = (Line) hyperplane;
    final Vector2D crossing = thisLine.intersection(otherLine);
    if (crossing == null) {
        // the lines are parallel
        final double global = otherLine.getOffset(thisLine);
        return (global < -1.0e-10) ? new SplitSubHyperplane<Euclidean2D>(null, this) : new SplitSubHyperplane<Euclidean2D>(this, null);
    }
    // the lines do intersect
    final boolean direct = FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) < 0;
    final Vector1D x = thisLine.toSubSpace(crossing);
    final SubHyperplane<Euclidean1D> subPlus = new OrientedPoint(x, !direct).wholeHyperplane();
    final SubHyperplane<Euclidean1D> subMinus = new OrientedPoint(x, direct).wholeHyperplane();
    final BSPTree<Euclidean1D> splitTree = getRemainingRegion().getTree(false).split(subMinus);
    final BSPTree<Euclidean1D> plusTree = getRemainingRegion().isEmpty(splitTree.getPlus()) ? new BSPTree<Euclidean1D>(Boolean.FALSE) : new BSPTree<Euclidean1D>(subPlus, new BSPTree<Euclidean1D>(Boolean.FALSE), splitTree.getPlus(), null);
    final BSPTree<Euclidean1D> minusTree = getRemainingRegion().isEmpty(splitTree.getMinus()) ? new BSPTree<Euclidean1D>(Boolean.FALSE) : new BSPTree<Euclidean1D>(subMinus, new BSPTree<Euclidean1D>(Boolean.FALSE), splitTree.getMinus(), null);
    return new SplitSubHyperplane<Euclidean2D>(new SubLine(thisLine.copySelf(), new IntervalsSet(plusTree)), new SubLine(thisLine.copySelf(), new IntervalsSet(minusTree)));
}","public void test1616() throws Throwable {
    Vector2D vector2D0 = Vector2D.NaN;
    Line line0 = new Line(vector2D0, vector2D0);
    SubLine subLine0 = new SubLine(vector2D0, vector2D0);
    SubHyperplane.SplitSubHyperplane<Euclidean2D> subHyperplane_SplitSubHyperplane0 = subLine0.split(line0);
    assertNotNull(subHyperplane_SplitSubHyperplane0);
}","/**
 * {@inheritDoc}
 */"
