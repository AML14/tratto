focal_method,test_prefix,docstring
"public double cosine(RealVector v) {
    final double norm = getNorm();
    final double vNorm = v.getNorm();
    if (norm == 0 || vNorm == 0) {
        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);
    }
    return dotProduct(v) / (norm * vNorm);
}","public void test0000() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0);
    openMapRealVector0.dotProduct((RealVector) openMapRealVector1);
    openMapRealVector1.isInfinite();
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 0.0;
    RealVector realVector0 = openMapRealVector1.mapMultiplyToSelf((-641.0));
    doubleArray0[1] = 0.0;
    doubleArray0[2] = 0.0;
    RealVectorChangingVisitor realVectorChangingVisitor0 = mock(RealVectorChangingVisitor.class, new ViolatedAssumptionAnswer());
    openMapRealVector0.subtract((RealVector) openMapRealVector1);
    doubleArray0[3] = 0.0;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0);
    openMapRealVector1.append(0.0);
    // Undeclared exception!
    try {
        openMapRealVector1.cosine(realVector0);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // zero norm
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * Computes the cosine of the angle between this vector and the
 * argument.
 *
 * @param v Vector.
 * @return the cosine of the angle between this vector and {@code v}.
 */"
"public double walkInOptimizedOrder(final RealVectorChangingVisitor visitor) {
    return walkInDefaultOrder(visitor);
}","public void test0011() throws Throwable {
    int int0 = 0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0, 0);
    openMapRealVector0.hashCode();
    OpenMapRealVector openMapRealVector2 = openMapRealVector1.append((RealVector) openMapRealVector0);
    OpenMapRealVector openMapRealVector3 = new OpenMapRealVector(0);
    RealVectorPreservingVisitor realVectorPreservingVisitor0 = mock(RealVectorPreservingVisitor.class, new ViolatedAssumptionAnswer());
    doReturn(1.0E-12).when(realVectorPreservingVisitor0).end();
    openMapRealVector3.walkInDefaultOrder(realVectorPreservingVisitor0);
    openMapRealVector1.equals(openMapRealVector3);
    openMapRealVector1.getMaxIndex();
    OpenIntToDoubleHashMap.Iterator openIntToDoubleHashMap_Iterator0 = mock(OpenIntToDoubleHashMap.Iterator.class, new ViolatedAssumptionAnswer());
    doReturn(1.0E-12).when(openIntToDoubleHashMap_Iterator0).value();
    OpenMapRealVector.OpenMapEntry openMapRealVector_OpenMapEntry0 = openMapRealVector1.new OpenMapEntry(openIntToDoubleHashMap_Iterator0);
    openMapRealVector2.mapAdd((-1));
    openMapRealVector1.mapDivideToSelf(1.0E-12);
    openMapRealVector_OpenMapEntry0.getValue();
    OpenMapRealVector openMapRealVector4 = openMapRealVector1.append(585.50939104);
    // Undeclared exception!
    try {
        openMapRealVector4.walkInOptimizedOrder((RealVectorChangingVisitor) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * Visits (and possibly alters) all entries of this vector in optimized
 * order. The order in which the entries are visited is selected so as to
 * lead to the most efficient implementation; it might depend on the
 * concrete implementation of this abstract class.
 *
 * @param visitor the visitor to be used to process the entries of this
 * vector
 * @return the value returned by {@link RealVectorChangingVisitor#end()}
 * at the end of the walk
 */"
"@Override
public OpenMapRealVector ebeMultiply(RealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = new OpenMapRealVector(this);
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));
    }
    /*
         * MATH-803: the above loop assumes that 0d * x  = 0d for any double x,
         * which allows to consider only the non-zero entries of this. However,
         * this fails if this[i] == 0d and (v[i] = NaN or v[i] = Infinity).
         *
         * These special cases are handled below.
         */
    return res;
}","public void test0022() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = 0.0;
    doubleArray0[1] = (-132.09534419319735);
    doubleArray0[3] = 6.283185307179586;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((RealVector) openMapRealVector0);
    RealVectorPreservingVisitor realVectorPreservingVisitor0 = mock(RealVectorPreservingVisitor.class, new ViolatedAssumptionAnswer());
    doReturn(3.775134371775124E-11).when(realVectorPreservingVisitor0).end();
    openMapRealVector1.walkInOptimizedOrder(realVectorPreservingVisitor0);
    OpenMapRealVector openMapRealVector2 = new OpenMapRealVector(doubleArray0, (-1137.450939));
    openMapRealVector1.dotProduct((RealVector) openMapRealVector2);
    OpenMapRealVector openMapRealVector3 = new OpenMapRealVector(openMapRealVector1);
    openMapRealVector3.set(289.80654792);
    openMapRealVector3.dotProduct((RealVector) openMapRealVector1);
    OpenMapRealVector openMapRealVector4 = new OpenMapRealVector(openMapRealVector3);
    openMapRealVector0.getDistance(openMapRealVector4);
    openMapRealVector1.ebeDivide(openMapRealVector3);
    double[] doubleArray1 = new double[4];
    doubleArray1[0] = 289.80654792;
    doubleArray1[1] = 3.775134371775124E-11;
    doubleArray1[2] = 2.5811686515808105;
    doubleArray1[3] = (-170.24);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray1);
    // Undeclared exception!
    try {
        openMapRealVector1.ebeMultiply(arrayRealVector0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 5 != 4
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public void setSubVector(int index, RealVector v) {
    checkIndex(index);
    checkIndex(index + v.getDimension() - 1);
    for (int i = 0; i < v.getDimension(); i++) {
        setEntry(i + index, v.getEntry(i));
    }
}","public void test0033() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 0.0;
    doubleArray0[1] = (-132.09534419319735);
    doubleArray0[2] = (-170.24);
    doubleArray0[3] = 6.283185307179586;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((RealVector) openMapRealVector0);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(185);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, true);
    openMapRealVector1.append((RealVector) arrayRealVector1);
    RealVectorPreservingVisitor realVectorPreservingVisitor0 = mock(RealVectorPreservingVisitor.class, new ViolatedAssumptionAnswer());
    doReturn(1.0E-12).when(realVectorPreservingVisitor0).end();
    openMapRealVector1.walkInOptimizedOrder(realVectorPreservingVisitor0);
    OpenMapRealVector openMapRealVector2 = new OpenMapRealVector(openMapRealVector1);
    openMapRealVector2.dotProduct((RealVector) openMapRealVector1);
    OpenMapRealVector openMapRealVector3 = openMapRealVector0.unitVector();
    openMapRealVector3.hashCode();
    openMapRealVector2.getL1Distance((RealVector) openMapRealVector3);
    openMapRealVector2.append(openMapRealVector0);
    openMapRealVector1.sparseIterator();
    // Undeclared exception!
    try {
        openMapRealVector1.setSubVector(1265, arrayRealVector0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (1,265)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public void addToEntry(int index, double increment) {
    setEntry(index, getEntry(index) + increment);
}","public void test0044() throws Throwable {
    Double[] doubleArray0 = new Double[0];
    double double0 = 26.30591167467474;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 26.30591167467474);
    int int0 = 31;
    Double[] doubleArray1 = new Double[0];
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray1, 31);
    openMapRealVector0.getLInfDistance(openMapRealVector1);
    // Undeclared exception!
    try {
        openMapRealVector0.addToEntry(31, 26.30591167467474);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (31)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * Change an entry at the specified index.
 *
 * @param index Index location of entry to be set.
 * @param increment Value to add to the vector entry.
 * @throws org.apache.commons.math3.exception.OutOfRangeException if
 * the index is not valid.
 * @since 3.0
 */"
"@Override
protected void checkVectorDimensions(RealVector v) {
    checkVectorDimensions(v.getDimension());
}","public void test0055() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector();
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.mapAddToSelf(2.0);
    openMapRealVector1.getNorm();
    int int0 = 1054;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(1054, 0.0);
    openMapRealVector1.getNorm();
    // Undeclared exception!
    try {
        arrayRealVector0.checkVectorDimensions(openMapRealVector0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 1,054 != 0
        //
        verifyException(""org.apache.commons.math3.linear.ArrayRealVector"", e);
    }
}","/**
 * Check if instance and specified vectors have the same dimension.
 *
 * @param v Vector to compare instance with.
 * @throws DimensionMismatchException if the vectors do not
 * have the same dimension.
 */"
"@Override
public OpenMapRealVector getSubVector(int index, int n) {
    checkIndex(index);
    if (n < 0) {
        throw new NotPositiveException(LocalizedFormats.NUMBER_OF_ELEMENTS_SHOULD_BE_POSITIVE, n);
    }
    checkIndex(index + n - 1);
    OpenMapRealVector res = new OpenMapRealVector(n);
    int end = index + n;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (key >= index && key < end) {
            res.setEntry(key - index, iter.value());
        }
    }
    return res;
}","public void test0066() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(2795, 2795);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((RealVector) openMapRealVector0);
    OpenMapRealVector openMapRealVector2 = openMapRealVector1.add(openMapRealVector0);
    RealVectorChangingVisitor realVectorChangingVisitor0 = mock(RealVectorChangingVisitor.class, new ViolatedAssumptionAnswer());
    doReturn(0.0).when(realVectorChangingVisitor0).end();
    doReturn(0.0, 0.0, 0.0, 0.0, 0.0).when(realVectorChangingVisitor0).visit(anyInt(), anyDouble());
    openMapRealVector0.walkInOptimizedOrder(realVectorChangingVisitor0);
    openMapRealVector2.set(2795);
    openMapRealVector1.getDistance(openMapRealVector2);
    // Undeclared exception!
    try {
        openMapRealVector1.getSubVector(2795, 23);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (2,795)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public void setEntry(int index, double value) {
    checkIndex(index);
    if (!isDefaultValue(value)) {
        entries.put(index, value);
    } else if (entries.containsKey(index)) {
        entries.remove(index);
    }
}","public void test0077() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector();
    openMapRealVector0.isInfinite();
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.subtract(openMapRealVector0);
    openMapRealVector0.mapSubtract((-2072.12));
    openMapRealVector0.add((RealVector) openMapRealVector0);
    // Undeclared exception!
    try {
        openMapRealVector1.setEntry(0, 0.0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (0)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getEntry(int index) {
    checkIndex(index);
    return entries.get(index);
}","public void test0088() throws Throwable {
    Double[] doubleArray0 = new Double[4];
    Double double0 = new Double((-968.5766984261));
    doubleArray0[0] = double0;
    Double double1 = new Double((-968.5766984261));
    doubleArray0[1] = double1;
    Double double2 = new Double(0.0);
    Double.min(0.0, 770.181);
    Double.max(0.0, 0.0);
    doubleArray0[2] = double2;
    Double double3 = new Double(0.0);
    doubleArray0[3] = double3;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (double) doubleArray0[1]);
    openMapRealVector0.iterator();
    openMapRealVector0.iterator();
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0);
    openMapRealVector0.hashCode();
    OpenMapRealVector openMapRealVector2 = openMapRealVector0.mapAdd(0.0);
    openMapRealVector1.mapAdd(1.0E-12);
    openMapRealVector1.isInfinite();
    Double.sum(0.0, (-1456.2699882864913));
    OpenIntToDoubleHashMap.Iterator openIntToDoubleHashMap_Iterator0 = mock(OpenIntToDoubleHashMap.Iterator.class, new ViolatedAssumptionAnswer());
    doReturn(2455).when(openIntToDoubleHashMap_Iterator0).key();
    OpenMapRealVector.OpenMapEntry openMapRealVector_OpenMapEntry0 = openMapRealVector2.new OpenMapEntry(openIntToDoubleHashMap_Iterator0);
    OpenMapRealVector openMapRealVector3 = openMapRealVector1.ebeDivide(openMapRealVector2);
    OpenMapRealVector openMapRealVector4 = openMapRealVector2.unitVector();
    openMapRealVector4.ebeMultiply(openMapRealVector1);
    openMapRealVector4.isNaN();
    openMapRealVector_OpenMapEntry0.setValue(0.0);
    openMapRealVector3.isInfinite();
    // Undeclared exception!
    try {
        openMapRealVector2.getEntry((-1423));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (-1,423)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public ArrayRealVector ebeMultiply(RealVector v) {
    if (v instanceof ArrayRealVector) {
        final double[] vData = ((ArrayRealVector) v).data;
        final int dim = vData.length;
        checkVectorDimensions(dim);
        ArrayRealVector result = new ArrayRealVector(dim);
        double[] resultData = result.data;
        for (int i = 0; i < dim; i++) {
            resultData[i] = data[i] * vData[i];
        }
        return result;
    } else {
        checkVectorDimensions(v);
        double[] out = data.clone();
        for (int i = 0; i < data.length; i++) {
            out[i] *= v.getEntry(i);
        }
        return new ArrayRealVector(out, false);
    }
}","public void test0099() throws Throwable {
    int int0 = (-1968);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-1968), (-1968), 1731.65572417);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((-1968));
    Sinc sinc0 = new Sinc(true);
    openMapRealVector1.mapToSelf(sinc0);
    openMapRealVector0.getLInfDistance(openMapRealVector1);
    double[] doubleArray0 = new double[1];
    openMapRealVector1.isDefaultValue(0.0);
    openMapRealVector0.set(982.8);
    doubleArray0[0] = 1.0E-12;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, doubleArray0);
    openMapRealVector1.equals(openMapRealVector0);
    RealVectorChangingVisitor realVectorChangingVisitor0 = mock(RealVectorChangingVisitor.class, new ViolatedAssumptionAnswer());
    doReturn((-968.5766984261)).when(realVectorChangingVisitor0).end();
    openMapRealVector1.walkInOptimizedOrder(realVectorChangingVisitor0);
    // Undeclared exception!
    try {
        arrayRealVector0.ebeMultiply(openMapRealVector0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 2 != -1,968
        //
        verifyException(""org.apache.commons.math3.linear.ArrayRealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public OpenMapRealVector subtract(OpenMapRealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = copy();
    Iterator iter = v.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (entries.containsKey(key)) {
            res.setEntry(key, entries.get(key) - iter.value());
        } else {
            res.setEntry(key, -iter.value());
        }
    }
    return res;
}","public void test01010() throws Throwable {
    Double[] doubleArray0 = new Double[3];
    Double double0 = new Double((-837.1));
    doubleArray0[0] = double0;
    Double double1 = new Double((-2327.7999));
    doubleArray0[1] = double1;
    Double double2 = new Double((double) doubleArray0[0]);
    Double.min((double) doubleArray0[0], 6.283185307179586);
    Double.sum(6.283185307179586, 588.5125100185);
    doubleArray0[2] = double2;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (double) doubleArray0[2]);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.copy();
    openMapRealVector1.getL1Distance(openMapRealVector0);
    openMapRealVector0.mapSubtract(1.0);
    openMapRealVector1.isInfinite();
    openMapRealVector1.getMaxValue();
    Double.isFinite((-2318.18141019));
    openMapRealVector0.getDistance((RealVector) openMapRealVector1);
    openMapRealVector0.getSparsity();
    openMapRealVector0.getDistance((RealVector) openMapRealVector1);
    openMapRealVector0.hashCode();
    OpenMapRealVector openMapRealVector2 = openMapRealVector1.add(openMapRealVector0);
    RealVector realVector0 = openMapRealVector1.add((RealVector) openMapRealVector0);
    Double.isFinite((-837.1));
    OpenMapRealVector openMapRealVector3 = openMapRealVector2.append(openMapRealVector1);
    openMapRealVector2.add(realVector0);
    openMapRealVector3.toArray();
    OpenMapRealVector openMapRealVector4 = openMapRealVector2.copy();
    // Undeclared exception!
    try {
        openMapRealVector3.subtract(openMapRealVector4);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 6 != 3
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * Optimized method to subtract OpenMapRealVectors.
 *
 * @param v Vector to subtract from {@code this}.
 * @return the difference of {@code this} and {@code v}.
 * @throws org.apache.commons.math3.exception.DimensionMismatchException
 * if the dimensions do not match.
 */"
"public RealVector combineToSelf(double a, double b, RealVector y) {
    checkVectorDimensions(y);
    for (int i = 0; i < getDimension(); i++) {
        final double xi = getEntry(i);
        final double yi = y.getEntry(i);
        setEntry(i, a * xi + b * yi);
    }
    return this;
}","public void test01111() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-442));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0);
    openMapRealVector1.equals(""c"");
    OpenMapRealVector openMapRealVector2 = openMapRealVector1.ebeMultiply(openMapRealVector0);
    RealVector realVector0 = RealVector.unmodifiableRealVector(openMapRealVector1);
    openMapRealVector1.equals("""");
    openMapRealVector0.getDistance(openMapRealVector1);
    // Undeclared exception!
    try {
        realVector0.combineToSelf(1.0E-12, 0.0, openMapRealVector2);
        fail(""Expecting exception: MathUnsupportedOperationException"");
    } catch (MathUnsupportedOperationException e) {
        //
        // unsupported operation
        //
        verifyException(""org.apache.commons.math3.linear.RealVector$2"", e);
    }
}","/**
 * Updates {@code this} with the linear combination of {@code this} and
 * {@code y}.
 *
 * @param a Weight of {@code this}.
 * @param b Weight of {@code y}.
 * @param y Vector with which {@code this} is linearly combined.
 * @return {@code this}, with components equal to
 * {@code a * this[i] + b * y[i]} for all {@code i}.
 * @throws org.apache.commons.math3.exception.DimensionMismatchException
 * if {@code y} is not the same size as this vector.
 */"
"@Override
public void setEntry(int index, double value) {
    checkIndex(index);
    if (!isDefaultValue(value)) {
        entries.put(index, value);
    } else if (entries.containsKey(index)) {
        entries.remove(index);
    }
}","public void test01212() throws Throwable {
    Double[] doubleArray0 = new Double[7];
    Double double0 = new Double((-1.0));
    doubleArray0[0] = double0;
    Double double1 = new Double((double) doubleArray0[0]);
    doubleArray0[1] = double1;
    Double double2 = new Double(1.0);
    doubleArray0[2] = double2;
    Double double3 = new Double(310.66427041);
    doubleArray0[3] = double3;
    Double double4 = new Double((double) doubleArray0[1]);
    doubleArray0[4] = double4;
    Double double5 = new Double((double) doubleArray0[1]);
    doubleArray0[5] = double5;
    Double.max((double) doubleArray0[3], 2568.2101);
    Double double6 = new Double((double) doubleArray0[3]);
    doubleArray0[6] = double6;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0);
    openMapRealVector1.unitize();
    OpenMapRealVector openMapRealVector2 = openMapRealVector0.subtract(openMapRealVector1);
    Double.min(2568.2101, 1.0E-12);
    openMapRealVector1.mapSubtractToSelf((double) doubleArray0[6]);
    OpenMapRealVector openMapRealVector3 = new OpenMapRealVector(doubleArray0, 132.09534419319735);
    Double.min(566.855241899, (-1.0));
    openMapRealVector0.getLInfDistance(openMapRealVector3);
    OpenMapRealVector openMapRealVector4 = openMapRealVector2.add(openMapRealVector3);
    openMapRealVector4.getDistance(openMapRealVector3);
    openMapRealVector0.getLInfDistance(openMapRealVector1);
    openMapRealVector1.unitVector();
    // Undeclared exception!
    try {
        openMapRealVector0.setEntry((-2090), (double) doubleArray0[5]);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (-2,090)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public RealVector add(RealVector v) {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return add((OpenMapRealVector) v);
    } else {
        return super.add(v);
    }
}","public void test01313() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-903));
    double[] doubleArray0 = new double[0];
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0, 41.94845886296);
    // Undeclared exception!
    try {
        openMapRealVector0.add((RealVector) openMapRealVector1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // -903 != 0
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public OpenMapRealVector(int dimension, int expectedSize) {
    this(dimension, expectedSize, DEFAULT_ZERO_TOLERANCE);
}","public void test01414() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(3184, 3184);
}","/**
 * Build a vector with known the sparseness (for advanced use only).
 *
 * @param dimension Size of the vector.
 * @param expectedSize The expected number of non-zero entries.
 */"
"@Override
public double[] toArray() {
    double[] res = new double[virtualSize];
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res[iter.key()] = iter.value();
    }
    return res;
}","public void test01616() throws Throwable {
    Double[] doubleArray0 = new Double[2];
    Double double0 = new Double(1734.11);
    doubleArray0[0] = double0;
    Double double1 = new Double(1734.11);
    Double.min((-1.0), 3495.3);
    Double.min(3495.3, (double) doubleArray0[0]);
    doubleArray0[1] = double1;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    openMapRealVector0.getL1Norm();
    openMapRealVector0.toArray();
}","/**
 * {@inheritDoc}
 */"
"@Override
public OpenMapRealVector copy() {
    return new OpenMapRealVector(this);
}","public void test01717() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(0, 0, 1550.42645689037);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0);
    OpenMapRealVector openMapRealVector2 = new OpenMapRealVector(openMapRealVector1, 289);
    OpenMapRealVector openMapRealVector3 = new OpenMapRealVector((RealVector) openMapRealVector2);
    openMapRealVector3.copy();
}","/**
 * {@inheritDoc}
 * @since 2.1
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test01818() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(32, 1.0);
    openMapRealVector0.getSparsity();
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"@Override
public OpenMapRealVector mapAdd(double d) {
    return copy().mapAddToSelf(d);
}","public void test01919() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 0.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, Double.POSITIVE_INFINITY);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0);
    OpenMapRealVector openMapRealVector2 = new OpenMapRealVector((RealVector) openMapRealVector1);
    openMapRealVector2.mapAdd(1375.243);
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getL1Distance(RealVector v) {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return getL1Distance((OpenMapRealVector) v);
    } else {
        return super.getL1Distance(v);
    }
}","public void test02020() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-1100));
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = 1.0E-12;
    doubleArray0[1] = 1.0E-12;
    doubleArray0[2] = (double) (-1100);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0, Double.NaN);
    // Undeclared exception!
    try {
        openMapRealVector0.getL1Distance((RealVector) openMapRealVector1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // -1,100 != 3
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public OpenMapRealVector(double[] values) {
    this(values, DEFAULT_ZERO_TOLERANCE);
}","public void test02121() throws Throwable {
    OpenMapRealVector openMapRealVector0 = null;
    try {
        openMapRealVector0 = new OpenMapRealVector((double[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.linear.OpenMapRealVector"", e);
    }
}","/**
 * Create from an array.
 * Only non-zero entries will be stored.
 *
 * @param values Set of values to create from.
 */"
"public OpenMapRealVector(double[] values, double epsilon) {
    virtualSize = values.length;
    entries = new OpenIntToDoubleHashMap(0.0);
    this.epsilon = epsilon;
    for (int key = 0; key < values.length; key++) {
        double value = values[key];
        if (!isDefaultValue(value)) {
            entries.put(key, value);
        }
    }
}","public void test02222() throws Throwable {
    double[] doubleArray0 = null;
    OpenMapRealVector openMapRealVector0 = null;
    try {
        openMapRealVector0 = new OpenMapRealVector((double[]) null, (-1289.274505946));
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.linear.OpenMapRealVector"", e);
    }
}","/**
 * Create from an array, specifying zero tolerance.
 * Only non-zero entries will be stored.
 *
 * @param values Set of values to create from.
 * @param epsilon Tolerance below which a value is considered zero.
 */"
"public OpenMapRealVector(Double[] values, double epsilon) {
    virtualSize = values.length;
    entries = new OpenIntToDoubleHashMap(0.0);
    this.epsilon = epsilon;
    for (int key = 0; key < values.length; key++) {
        double value = values[key].doubleValue();
        if (!isDefaultValue(value)) {
            entries.put(key, value);
        }
    }
}","public void test02323() throws Throwable {
    Double[] doubleArray0 = null;
    double double0 = 0.0;
    OpenMapRealVector openMapRealVector0 = null;
    try {
        openMapRealVector0 = new OpenMapRealVector((Double[]) null, 0.0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.linear.OpenMapRealVector"", e);
    }
}","/**
 * Create from an array.
 * Only non-zero entries will be stored.
 *
 * @param values Set of values to create from.
 * @param epsilon Tolerance below which a value is considered zero.
 */"
"public double getSparsity() {
    return (double) entries.size() / (double) getDimension();
}","public void test02424() throws Throwable {
    Double[] doubleArray0 = new Double[4];
    Double double0 = new Double(1413.763634870159);
    doubleArray0[0] = double0;
    Double double1 = new Double((double) doubleArray0[0]);
    doubleArray0[1] = double1;
    Double double2 = new Double(1.0);
    doubleArray0[2] = double2;
    Double double3 = new Double(1493.5658845);
    doubleArray0[3] = double3;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0, 2007);
    openMapRealVector1.getSparsity();
}","/**
 * @return the percentage of none zero elements as a decimal percent.
 * @since 2.2
 */"
"@Override
public void set(double value) {
    for (int i = 0; i < virtualSize; i++) {
        setEntry(i, value);
    }
}","public void test02727() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(32, 190, 32);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0);
    Asinh asinh0 = new Asinh();
    UnivariateFunction univariateFunction0 = asinh0.derivative();
    openMapRealVector1.map(univariateFunction0);
    openMapRealVector0.outerProduct(openMapRealVector1);
    openMapRealVector1.set(1746.922221);
}","/**
 * {@inheritDoc}
 */"
"public RealVector combineToSelf(double a, double b, RealVector y) {
    checkVectorDimensions(y);
    for (int i = 0; i < getDimension(); i++) {
        final double xi = getEntry(i);
        final double yi = y.getEntry(i);
        setEntry(i, a * xi + b * yi);
    }
    return this;
}","public void test02828() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(1492);
    double[] doubleArray0 = new double[0];
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0);
    // Undeclared exception!
    try {
        openMapRealVector0.combineToSelf(1492, 1492, openMapRealVector1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 1,492 != 0
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * Updates {@code this} with the linear combination of {@code this} and
 * {@code y}.
 *
 * @param a Weight of {@code this}.
 * @param b Weight of {@code y}.
 * @param y Vector with which {@code this} is linearly combined.
 * @return {@code this}, with components equal to
 * {@code a * this[i] + b * y[i]} for all {@code i}.
 * @throws org.apache.commons.math3.exception.DimensionMismatchException
 * if {@code y} is not the same size as this vector.
 */"
"public double dotProduct(OpenMapRealVector v) {
    checkVectorDimensions(v.getDimension());
    boolean thisIsSmaller = entries.size() < v.entries.size();
    Iterator iter = thisIsSmaller ? entries.iterator() : v.entries.iterator();
    OpenIntToDoubleHashMap larger = thisIsSmaller ? v.entries : entries;
    double d = 0;
    while (iter.hasNext()) {
        iter.advance();
        d += iter.value() * larger.get(iter.key());
    }
    return d;
}","public void test02929() throws Throwable {
    double[] doubleArray0 = new double[0];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    openMapRealVector0.mapAdd(0.0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0);
    openMapRealVector1.combineToSelf(0.0, (-1262.0), openMapRealVector0);
    openMapRealVector1.dotProduct(openMapRealVector0);
}","/**
 * Optimized method to compute the dot product with an OpenMapRealVector.
 * It iterates over the smallest of the two.
 *
 * @param v Cector to compute the dot product with.
 * @return the dot product of {@code this} and {@code v}.
 * @throws org.apache.commons.math3.exception.DimensionMismatchException
 * if the dimensions do not match.
 */"
"@Override
public RealVector projection(RealVector v) {
    checkVectorDimensions(v.getDimension());
    return v.mapMultiply(dotProduct(v) / v.dotProduct(v));
}","public void test03030() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(0, 0);
    openMapRealVector1.getMinValue();
    openMapRealVector0.getLInfDistance(openMapRealVector1);
    OpenMapRealVector openMapRealVector2 = openMapRealVector1.append((RealVector) openMapRealVector0);
    openMapRealVector1.getSparsity();
    openMapRealVector1.sparseIterator();
    openMapRealVector0.iterator();
    openMapRealVector1.getMinIndex();
    openMapRealVector0.isDefaultValue(0.0);
    openMapRealVector1.isDefaultValue(0.0);
    openMapRealVector0.projection(openMapRealVector2);
}","/**
 * {@inheritDoc}
 */"
"@Override
public OpenMapRealVector mapAdd(double d) {
    return copy().mapAddToSelf(d);
}","public void test03131() throws Throwable {
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = (-4305.03);
    doubleArray0[1] = Double.NEGATIVE_INFINITY;
    doubleArray0[2] = (-2182.71593815);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-4305.03));
    OpenMapRealVector.OpenMapSparseIterator openMapRealVector_OpenMapSparseIterator0 = openMapRealVector0.new OpenMapSparseIterator();
    openMapRealVector0.isDefaultValue(0.0);
    openMapRealVector_OpenMapSparseIterator0.next();
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0);
    openMapRealVector1.mapDivide((-4305.03));
    openMapRealVector0.append((RealVector) openMapRealVector1);
    openMapRealVector0.isInfinite();
    openMapRealVector0.mapAdd((-709.0431304857449));
}","/**
 * {@inheritDoc}
 */"
"@Override
public boolean isNaN() {
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        if (Double.isNaN(iter.value())) {
            return true;
        }
    }
    return false;
}","public void test03232() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(1200, 4616.4);
    openMapRealVector0.getMinIndex();
    openMapRealVector0.isNaN();
}","/**
 * {@inheritDoc}
 */"
"@Override
public OpenMapRealVector append(double d) {
    OpenMapRealVector res = new OpenMapRealVector(this, 1);
    res.setEntry(virtualSize, d);
    return res;
}","public void test03333() throws Throwable {
    int int0 = (-3079);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-3079), (-3079));
    openMapRealVector0.getMinIndex();
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0);
    openMapRealVector1.getL1Distance((RealVector) openMapRealVector0);
    double double0 = (-1577.3530691);
    OpenMapRealVector openMapRealVector2 = openMapRealVector1.mapAdd((-1577.3530691));
    openMapRealVector2.mapAddToSelf(1.0E-12);
    openMapRealVector1.getSparsity();
    openMapRealVector1.getDistance((RealVector) openMapRealVector0);
    // Undeclared exception!
    try {
        openMapRealVector1.append(0.0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (-3,079)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double cosine(RealVector v) {
    final double norm = getNorm();
    final double vNorm = v.getNorm();
    if (norm == 0 || vNorm == 0) {
        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);
    }
    return dotProduct(v) / (norm * vNorm);
}","public void test03434() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0);
    openMapRealVector0.dotProduct((RealVector) openMapRealVector1);
    openMapRealVector1.isInfinite();
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 0.0;
    RealVector realVector0 = openMapRealVector1.mapMultiplyToSelf((-641.0));
    doubleArray0[1] = 0.0;
    doubleArray0[2] = 0.0;
    RealVectorChangingVisitor realVectorChangingVisitor0 = mock(RealVectorChangingVisitor.class, new ViolatedAssumptionAnswer());
    doReturn(0.0).when(realVectorChangingVisitor0).end();
    realVector0.walkInOptimizedOrder(realVectorChangingVisitor0);
    openMapRealVector0.subtract((RealVector) openMapRealVector1);
    doubleArray0[3] = 0.0;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0);
    openMapRealVector1.append(0.0);
    // Undeclared exception!
    try {
        openMapRealVector1.cosine(realVector0);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // zero norm
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * Computes the cosine of the angle between this vector and the
 * argument.
 *
 * @param v Vector.
 * @return the cosine of the angle between this vector and {@code v}.
 */"
"@Override
public void unitize() {
    double norm = getNorm();
    if (isDefaultValue(norm)) {
        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        entries.put(iter.key(), iter.value() / norm);
    }
}","public void test03535() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-132), (-309));
    // Undeclared exception!
    try {
        openMapRealVector0.unitize();
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // zero norm
        //
        verifyException(""org.apache.commons.math3.linear.OpenMapRealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public OpenMapRealVector(OpenMapRealVector v) {
    virtualSize = v.getDimension();
    entries = new OpenIntToDoubleHashMap(v.getEntries());
    epsilon = v.epsilon;
}","public void test03636() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = 0.0;
    doubleArray0[1] = 0.0;
    doubleArray0[2] = 511.2578056;
    doubleArray0[3] = 2173.7475097;
    doubleArray0[4] = (-433.180479761631);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(arrayRealVector0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0);
}","/**
 * Copy constructor.
 *
 * @param v Instance to copy from.
 */"
"public double getDistance(OpenMapRealVector v) {
    Iterator iter = entries.iterator();
    double res = 0;
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        double delta;
        delta = iter.value() - v.getEntry(key);
        res += delta * delta;
    }
    iter = v.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (!entries.containsKey(key)) {
            final double value = iter.value();
            res += value * value;
        }
    }
    return FastMath.sqrt(res);
}","public void test03737() throws Throwable {
    Double[] doubleArray0 = new Double[3];
    Double double0 = new Double((-383.63114));
    doubleArray0[0] = double0;
    Double double1 = new Double((double) doubleArray0[0]);
    doubleArray0[1] = double1;
    Double double2 = new Double((-1708.078266));
    doubleArray0[2] = double2;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    double[] doubleArray1 = new double[2];
    doubleArray1[0] = (double) doubleArray0[1];
    doubleArray1[1] = (-383.63114);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray1);
    // Undeclared exception!
    try {
        openMapRealVector0.getDistance(openMapRealVector1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (2)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * Optimized method to compute distance.
 *
 * @param v Vector to compute distance to.
 * @return the distance from {@code this} and {@code v}.
 * @throws org.apache.commons.math3.exception.DimensionMismatchException
 * if the dimensions do not match.
 */"
"@Override
public double dotProduct(RealVector v) {
    if (v instanceof OpenMapRealVector) {
        return dotProduct((OpenMapRealVector) v);
    } else {
        return super.dotProduct(v);
    }
}","public void test03838() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(48, (-1.0));
    OpenIntToDoubleHashMap.Iterator openIntToDoubleHashMap_Iterator0 = mock(OpenIntToDoubleHashMap.Iterator.class, new ViolatedAssumptionAnswer());
    doReturn(0).when(openIntToDoubleHashMap_Iterator0).key();
    OpenMapRealVector.OpenMapEntry openMapRealVector_OpenMapEntry0 = openMapRealVector0.new OpenMapEntry(openIntToDoubleHashMap_Iterator0);
    openMapRealVector_OpenMapEntry0.setValue(1.0);
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = 1.0E-12;
    doubleArray0[1] = (double) 48;
    doubleArray0[2] = 1.0E-12;
    doubleArray0[3] = 1.0;
    doubleArray0[4] = (-1.0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0);
    // Undeclared exception!
    try {
        openMapRealVector0.dotProduct((RealVector) openMapRealVector1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 48 != 5
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public double[] toArray() {
    double[] res = new double[virtualSize];
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res[iter.key()] = iter.value();
    }
    return res;
}","public void test03939() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-50), 273, (-2070.890162066553));
    openMapRealVector0.isNaN();
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0);
    openMapRealVector1.iterator();
    openMapRealVector1.getLInfDistance(openMapRealVector0);
    // Undeclared exception!
    try {
        openMapRealVector0.toArray();
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.linear.OpenMapRealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public void unitize() {
    double norm = getNorm();
    if (isDefaultValue(norm)) {
        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        entries.put(iter.key(), iter.value() / norm);
    }
}","public void test04040() throws Throwable {
    int int0 = 928;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(921, 928);
    double double0 = 459.5574418;
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.append(459.5574418);
    openMapRealVector1.set(921);
    openMapRealVector0.isInfinite();
    OpenIntToDoubleHashMap.Iterator openIntToDoubleHashMap_Iterator0 = mock(OpenIntToDoubleHashMap.Iterator.class, new ViolatedAssumptionAnswer());
    RealVector.unmodifiableRealVector(openMapRealVector1);
    OpenMapRealVector.OpenMapEntry openMapRealVector_OpenMapEntry0 = openMapRealVector0.new OpenMapEntry(openIntToDoubleHashMap_Iterator0);
    // Undeclared exception!
    try {
        openMapRealVector0.unitize();
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // zero norm
        //
        verifyException(""org.apache.commons.math3.linear.OpenMapRealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double getDistance(OpenMapRealVector v) {
    Iterator iter = entries.iterator();
    double res = 0;
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        double delta;
        delta = iter.value() - v.getEntry(key);
        res += delta * delta;
    }
    iter = v.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (!entries.containsKey(key)) {
            final double value = iter.value();
            res += value * value;
        }
    }
    return FastMath.sqrt(res);
}","public void test04141() throws Throwable {
    double[] doubleArray0 = new double[8];
    doubleArray0[0] = (-1.0);
    doubleArray0[1] = (-555.23151285);
    doubleArray0[2] = 1.0E-12;
    doubleArray0[3] = (-369.60533);
    doubleArray0[4] = 0.0;
    doubleArray0[5] = 0.0;
    doubleArray0[6] = (-193.2025);
    doubleArray0[7] = 0.0;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, false);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(doubleArray0, arrayRealVector0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(arrayRealVector1);
    openMapRealVector0.set(621.47835800219);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0, Double.NEGATIVE_INFINITY);
    // Undeclared exception!
    try {
        openMapRealVector0.getDistance(openMapRealVector1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (8)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * Optimized method to compute distance.
 *
 * @param v Vector to compute distance to.
 * @return the distance from {@code this} and {@code v}.
 * @throws org.apache.commons.math3.exception.DimensionMismatchException
 * if the dimensions do not match.
 */"
"@Override
public OpenMapRealVector getSubVector(int index, int n) {
    checkIndex(index);
    if (n < 0) {
        throw new NotPositiveException(LocalizedFormats.NUMBER_OF_ELEMENTS_SHOULD_BE_POSITIVE, n);
    }
    checkIndex(index + n - 1);
    OpenMapRealVector res = new OpenMapRealVector(n);
    int end = index + n;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (key >= index && key < end) {
            res.setEntry(key - index, iter.value());
        }
    }
    return res;
}","public void test04242() throws Throwable {
    Double[] doubleArray0 = new Double[4];
    Double double0 = new Double((-1.0));
    doubleArray0[0] = double0;
    Double double1 = new Double((-1.0));
    Double.isFinite((double) doubleArray0[0]);
    doubleArray0[1] = double1;
    Double double2 = new Double((double) doubleArray0[1]);
    doubleArray0[2] = double2;
    Double.isFinite((double) doubleArray0[2]);
    Double double3 = new Double((double) doubleArray0[0]);
    doubleArray0[3] = double3;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (double) doubleArray0[3]);
    openMapRealVector0.hashCode();
    openMapRealVector0.getSubVector(2, 2);
}","/**
 * {@inheritDoc}
 */"
"@Override
public OpenMapRealVector unitVector() {
    OpenMapRealVector res = copy();
    res.unitize();
    return res;
}","public void test04444() throws Throwable {
    Double[] doubleArray0 = new Double[0];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    // Undeclared exception!
    try {
        openMapRealVector0.unitVector();
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // zero norm
        //
        verifyException(""org.apache.commons.math3.linear.OpenMapRealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public RealVector add(RealVector v) {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return add((OpenMapRealVector) v);
    } else {
        return super.add(v);
    }
}","public void test04545() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector();
    openMapRealVector0.mapMultiplyToSelf(0.0);
    openMapRealVector0.mapDivide((-2141.879062277274));
    openMapRealVector0.getNorm();
    openMapRealVector0.sparseIterator();
    // Undeclared exception!
    try {
        openMapRealVector0.add((RealVector) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.linear.OpenMapRealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public OpenMapRealVector add(OpenMapRealVector v) {
    checkVectorDimensions(v.getDimension());
    boolean copyThis = entries.size() > v.entries.size();
    OpenMapRealVector res = copyThis ? this.copy() : v.copy();
    Iterator iter = copyThis ? v.entries.iterator() : entries.iterator();
    OpenIntToDoubleHashMap randomAccess = copyThis ? entries : v.entries;
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (randomAccess.containsKey(key)) {
            res.setEntry(key, randomAccess.get(key) + iter.value());
        } else {
            res.setEntry(key, iter.value());
        }
    }
    return res;
}","public void test04646() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 0.73493;
    doubleArray0[1] = (-1139.0);
    doubleArray0[2] = 4.0;
    doubleArray0[3] = 1.0E-12;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    Double[] doubleArray1 = new Double[0];
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray1);
    openMapRealVector0.set(200.88708505484);
    // Undeclared exception!
    try {
        openMapRealVector0.add(openMapRealVector1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 4 != 0
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * Optimized method to add two OpenMapRealVectors.
 * It copies the larger vector, then iterates over the smaller.
 *
 * @param v Vector to add.
 * @return the sum of {@code this} and {@code v}.
 * @throws org.apache.commons.math3.exception.DimensionMismatchException
 * if the dimensions do not match.
 */"
"@Override
public OpenMapRealVector unitVector() {
    OpenMapRealVector res = copy();
    res.unitize();
    return res;
}","public void test04747() throws Throwable {
    int int0 = (-1);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-1), (-1));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((RealVector) openMapRealVector0);
    OpenMapRealVector openMapRealVector2 = new OpenMapRealVector(openMapRealVector1, 0);
    RealVectorPreservingVisitor realVectorPreservingVisitor0 = mock(RealVectorPreservingVisitor.class, new ViolatedAssumptionAnswer());
    // Undeclared exception!
    try {
        openMapRealVector1.unitVector();
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // zero norm
        //
        verifyException(""org.apache.commons.math3.linear.OpenMapRealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public void setEntry(int index, double value) {
    checkIndex(index);
    if (!isDefaultValue(value)) {
        entries.put(index, value);
    } else if (entries.containsKey(index)) {
        entries.remove(index);
    }
}","public void test04848() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(763);
    openMapRealVector0.isInfinite();
    Double[] doubleArray0 = new Double[6];
    doubleArray0[0] = (Double) 1.0E-12;
    doubleArray0[1] = (Double) 1.0E-12;
    doubleArray0[2] = (Double) 1.0E-12;
    doubleArray0[3] = (Double) 1.0E-12;
    doubleArray0[4] = (Double) 1.0E-12;
    doubleArray0[5] = (Double) 1.0E-12;
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0, (double) doubleArray0[5]);
    RealVector realVector0 = openMapRealVector1.mapSubtractToSelf(0.0);
    realVector0.append((RealVector) openMapRealVector0);
    openMapRealVector0.getDistance(openMapRealVector1);
    // Undeclared exception!
    try {
        openMapRealVector0.setEntry(763, 763);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (763)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public void unitize() {
    double norm = getNorm();
    if (isDefaultValue(norm)) {
        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        entries.put(iter.key(), iter.value() / norm);
    }
}","public void test04949() throws Throwable {
    double[] doubleArray0 = new double[8];
    doubleArray0[0] = 637.788936890229;
    doubleArray0[1] = 1.0E-12;
    doubleArray0[2] = (-2076.4462805);
    doubleArray0[3] = 1391.8477101776673;
    doubleArray0[4] = 1911.7;
    doubleArray0[5] = (-886.20516);
    doubleArray0[6] = 0.0;
    doubleArray0[7] = 0.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    openMapRealVector0.unitize();
}","/**
 * {@inheritDoc}
 */"
"@Override
public void setEntry(int index, double value) {
    checkIndex(index);
    if (!isDefaultValue(value)) {
        entries.put(index, value);
    } else if (entries.containsKey(index)) {
        entries.remove(index);
    }
}","public void test05050() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = 1.0E-12;
    doubleArray0[1] = 2327.0;
    doubleArray0[2] = 1489.50017;
    doubleArray0[3] = 4296.248715417795;
    doubleArray0[4] = (-1.0);
    doubleArray0[5] = 879.4894717304545;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-18.935));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0, 879.4894717304545);
    openMapRealVector0.getL1Norm();
    openMapRealVector0.getDistance((RealVector) openMapRealVector1);
    OpenIntToDoubleHashMap.Iterator openIntToDoubleHashMap_Iterator0 = mock(OpenIntToDoubleHashMap.Iterator.class, new ViolatedAssumptionAnswer());
    doReturn(0.0, 0.0).when(openIntToDoubleHashMap_Iterator0).value();
    OpenMapRealVector.OpenMapEntry openMapRealVector_OpenMapEntry0 = openMapRealVector0.new OpenMapEntry(openIntToDoubleHashMap_Iterator0);
    openMapRealVector_OpenMapEntry0.getValue();
    openMapRealVector0.getDistance(openMapRealVector1);
    openMapRealVector_OpenMapEntry0.setIndex((-2599));
    openMapRealVector_OpenMapEntry0.setIndex(696);
    openMapRealVector_OpenMapEntry0.getValue();
    openMapRealVector1.unitize();
    // Undeclared exception!
    try {
        openMapRealVector1.setEntry(16, 497.6698146777);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (16)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"private double getLInfDistance(OpenMapRealVector v) {
    double max = 0;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double delta = FastMath.abs(iter.value() - v.getEntry(iter.key()));
        if (delta > max) {
            max = delta;
        }
    }
    iter = v.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (!entries.containsKey(key)) {
            if (iter.value() > max) {
                max = iter.value();
            }
        }
    }
    return max;
}","public void test05151() throws Throwable {
    Double[] doubleArray0 = new Double[7];
    Double double0 = new Double((-938.4529));
    doubleArray0[0] = double0;
    Double double1 = new Double(1920.5762099);
    doubleArray0[1] = double1;
    Double double2 = new Double((-294.80249371));
    doubleArray0[2] = double2;
    Double double3 = new Double((-938.4529));
    doubleArray0[3] = double3;
    Double double4 = new Double((double) doubleArray0[0]);
    doubleArray0[4] = double4;
    Double double5 = new Double((double) doubleArray0[3]);
    doubleArray0[5] = double5;
    Double double6 = new Double(1920.5762099);
    doubleArray0[6] = double6;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0, 32);
    // Undeclared exception!
    try {
        openMapRealVector1.getLInfDistance(openMapRealVector0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 39 != 7
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * Optimized method to compute LInfDistance.
 *
 * @param v Vector to compute distance from.
 * @return the LInfDistance.
 */"
"@Override
public double getEntry(int index) {
    checkIndex(index);
    return entries.get(index);
}","public void test05252() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-2114));
    int int0 = 32;
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((-2114), 32, (-2727.48584195589));
    RealVectorChangingVisitor realVectorChangingVisitor0 = mock(RealVectorChangingVisitor.class, new ViolatedAssumptionAnswer());
    doReturn(0.0).when(realVectorChangingVisitor0).end();
    openMapRealVector0.walkInDefaultOrder(realVectorChangingVisitor0);
    openMapRealVector0.append(openMapRealVector1);
    // Undeclared exception!
    try {
        openMapRealVector0.getEntry(31);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (31)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public OpenMapRealVector(OpenMapRealVector v) {
    virtualSize = v.getDimension();
    entries = new OpenIntToDoubleHashMap(v.getEntries());
    epsilon = v.epsilon;
}","public void test05353() throws Throwable {
    OpenMapRealVector openMapRealVector0 = null;
    OpenMapRealVector openMapRealVector1 = null;
    try {
        openMapRealVector1 = new OpenMapRealVector((OpenMapRealVector) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.linear.OpenMapRealVector"", e);
    }
}","/**
 * Copy constructor.
 *
 * @param v Instance to copy from.
 */"
"@Override
public void setEntry(int index, double value) {
    checkIndex(index);
    if (!isDefaultValue(value)) {
        entries.put(index, value);
    } else if (entries.containsKey(index)) {
        entries.remove(index);
    }
}","public void test05454() throws Throwable {
    Double[] doubleArray0 = new Double[4];
    Double double0 = new Double(0.0);
    doubleArray0[0] = double0;
    Double double1 = new Double(0.0);
    doubleArray0[1] = double1;
    Double double2 = new Double((double) doubleArray0[0]);
    doubleArray0[2] = double2;
    Double.sum((double) doubleArray0[0], 2691.9645);
    Double double3 = new Double((-3816.0));
    doubleArray0[3] = double3;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-3816.0));
    openMapRealVector0.getDimension();
    // Undeclared exception!
    try {
        openMapRealVector0.setEntry((-1580), 0.0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (-1,580)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public OpenMapRealVector ebeDivide(RealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = new OpenMapRealVector(this);
    /*
         * MATH-803: it is not sufficient to loop through non zero entries of
         * this only. Indeed, if this[i] = 0d and v[i] = 0d, then
         * this[i] / v[i] = NaN, and not 0d.
         */
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));
    }
    return res;
}","public void test05555() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(0, 0);
    // Undeclared exception!
    try {
        openMapRealVector0.ebeDivide((RealVector) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.linear.OpenMapRealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public OpenMapRealVector ebeDivide(RealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = new OpenMapRealVector(this);
    /*
         * MATH-803: it is not sufficient to loop through non zero entries of
         * this only. Indeed, if this[i] = 0d and v[i] = 0d, then
         * this[i] / v[i] = NaN, and not 0d.
         */
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));
    }
    return res;
}","public void test05656() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = (-2840.252126363322);
    doubleArray0[1] = 0.0;
    doubleArray0[2] = (-1.0);
    doubleArray0[3] = (-1578.600484847);
    doubleArray0[4] = 0.0;
    doubleArray0[5] = 0.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 1439.0658706);
    Double[] doubleArray1 = new Double[5];
    doubleArray1[0] = (Double) (-2840.252126363322);
    doubleArray1[1] = (Double) 0.0;
    doubleArray1[2] = (Double) (-1578.600484847);
    doubleArray1[3] = (Double) 0.0;
    doubleArray1[4] = (Double) (-1.0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray1, 0.0);
    // Undeclared exception!
    try {
        openMapRealVector0.ebeDivide(openMapRealVector1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 6 != 5
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public OpenMapRealVector(RealVector v) {
    virtualSize = v.getDimension();
    entries = new OpenIntToDoubleHashMap(0.0);
    epsilon = DEFAULT_ZERO_TOLERANCE;
    for (int key = 0; key < virtualSize; key++) {
        double value = v.getEntry(key);
        if (!isDefaultValue(value)) {
            entries.put(key, value);
        }
    }
}","public void test05757() throws Throwable {
    RealVector realVector0 = null;
    OpenMapRealVector openMapRealVector0 = null;
    try {
        openMapRealVector0 = new OpenMapRealVector((RealVector) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Generic copy constructor.
 *
 * @param v Instance to copy from.
 */"
"@Override
public RealVector add(RealVector v) {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return add((OpenMapRealVector) v);
    } else {
        return super.add(v);
    }
}","public void test05858() throws Throwable {
    int int0 = 293;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(293, Double.NEGATIVE_INFINITY);
    openMapRealVector0.toArray();
    ArrayRealVector arrayRealVector0 = new ArrayRealVector();
    arrayRealVector0.mapDivide(1.0E-12);
    arrayRealVector0.iterator();
    // Undeclared exception!
    try {
        openMapRealVector0.add((RealVector) arrayRealVector0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 293 != 0
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public OpenMapRealVector getSubVector(int index, int n) {
    checkIndex(index);
    if (n < 0) {
        throw new NotPositiveException(LocalizedFormats.NUMBER_OF_ELEMENTS_SHOULD_BE_POSITIVE, n);
    }
    checkIndex(index + n - 1);
    OpenMapRealVector res = new OpenMapRealVector(n);
    int end = index + n;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (key >= index && key < end) {
            res.setEntry(key - index, iter.value());
        }
    }
    return res;
}","public void test05959() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 0.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 0.0);
    RealVector.unmodifiableRealVector(openMapRealVector0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(0);
    OpenMapRealVector openMapRealVector2 = openMapRealVector0.append(openMapRealVector1);
    openMapRealVector2.equals((Object) null);
    openMapRealVector0.mapDivideToSelf(0.0);
    openMapRealVector0.unitize();
    openMapRealVector2.set(0.0);
    openMapRealVector0.isNaN();
    int int0 = 0;
    // Undeclared exception!
    try {
        openMapRealVector1.getSubVector(0, 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (0)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getEntry(int index) {
    checkIndex(index);
    return entries.get(index);
}","public void test06060() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = 0.0;
    doubleArray0[1] = (-93.2265);
    doubleArray0[2] = 1720.67353737;
    doubleArray0[3] = 0.0;
    doubleArray0[4] = Double.POSITIVE_INFINITY;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0);
    openMapRealVector1.ebeDivide(openMapRealVector0);
    openMapRealVector0.getLInfDistance(openMapRealVector1);
    openMapRealVector1.getEntry(1);
}","/**
 * {@inheritDoc}
 */"
"@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    long temp;
    temp = Double.doubleToLongBits(epsilon);
    result = prime * result + (int) (temp ^ (temp >>> 32));
    result = prime * result + virtualSize;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        temp = Double.doubleToLongBits(iter.value());
        result = prime * result + (int) (temp ^ (temp >> 32));
    }
    return result;
}","public void test06262() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector();
    openMapRealVector0.mapDivide((-459.7));
    openMapRealVector0.isInfinite();
    openMapRealVector0.hashCode();
}","/**
 * {@inheritDoc}
 * Implementation Note: This works on exact values, and as a result
 * it is possible for {@code a.subtract(b)} to be the zero vector, while
 * {@code a.hashCode() != b.hashCode()}.
 */"
"@Override
public void unitize() {
    double norm = getNorm();
    if (isDefaultValue(norm)) {
        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        entries.put(iter.key(), iter.value() / norm);
    }
}","public void test06363() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector();
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.copy();
    OpenMapRealVector openMapRealVector2 = openMapRealVector1.mapAdd((-1713.99593376706));
    // Undeclared exception!
    try {
        openMapRealVector2.unitize();
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // zero norm
        //
        verifyException(""org.apache.commons.math3.linear.OpenMapRealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public void unitize() {
    double norm = getNorm();
    if (isDefaultValue(norm)) {
        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);
    }
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        entries.put(iter.key(), iter.value() / norm);
    }
}","public void test06464() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(224);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((RealVector) openMapRealVector0);
    openMapRealVector0.getDistance(openMapRealVector1);
    // Undeclared exception!
    try {
        openMapRealVector0.unitize();
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // zero norm
        //
        verifyException(""org.apache.commons.math3.linear.OpenMapRealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public OpenMapRealVector subtract(OpenMapRealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = copy();
    Iterator iter = v.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (entries.containsKey(key)) {
            res.setEntry(key, entries.get(key) - iter.value());
        } else {
            res.setEntry(key, -iter.value());
        }
    }
    return res;
}","public void test06565() throws Throwable {
    Double[] doubleArray0 = new Double[4];
    Double double0 = new Double(1.0);
    doubleArray0[0] = double0;
    Double double1 = Double.valueOf((double) doubleArray0[0]);
    doubleArray0[1] = double1;
    Double double2 = new Double(1.0);
    doubleArray0[2] = double2;
    Double double3 = new Double(1.0);
    doubleArray0[3] = double3;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0);
    openMapRealVector0.subtract(openMapRealVector1);
}","/**
 * Optimized method to subtract OpenMapRealVectors.
 *
 * @param v Vector to subtract from {@code this}.
 * @return the difference of {@code this} and {@code v}.
 * @throws org.apache.commons.math3.exception.DimensionMismatchException
 * if the dimensions do not match.
 */"
"public RealMatrix outerProduct(RealVector v) {
    RealMatrix product;
    if (v instanceof SparseRealVector || this instanceof SparseRealVector) {
        product = new OpenMapRealMatrix(this.getDimension(), v.getDimension());
    } else {
        product = new Array2DRowRealMatrix(this.getDimension(), v.getDimension());
    }
    Iterator<Entry> thisIt = sparseIterator();
    while (thisIt.hasNext()) {
        final Entry thisE = thisIt.next();
        Iterator<Entry> otherIt = v.sparseIterator();
        while (otherIt.hasNext()) {
            final Entry otherE = otherIt.next();
            product.setEntry(thisE.getIndex(), otherE.getIndex(), thisE.getValue() * otherE.getValue());
        }
    }
    return product;
}","public void test06666() throws Throwable {
    int int0 = (-1464);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-1464), (-780.2));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0, 0);
    OpenIntToDoubleHashMap.Iterator openIntToDoubleHashMap_Iterator0 = mock(OpenIntToDoubleHashMap.Iterator.class, new ViolatedAssumptionAnswer());
    doReturn(0.0).when(openIntToDoubleHashMap_Iterator0).value();
    OpenMapRealVector.OpenMapEntry openMapRealVector_OpenMapEntry0 = openMapRealVector1.new OpenMapEntry(openIntToDoubleHashMap_Iterator0);
    openMapRealVector_OpenMapEntry0.setIndex(0);
    openMapRealVector_OpenMapEntry0.getValue();
    RealVector realVector0 = openMapRealVector1.subtract((RealVector) openMapRealVector0);
    openMapRealVector1.getDistance(realVector0);
    OpenMapRealVector openMapRealVector2 = openMapRealVector0.add(openMapRealVector1);
    OpenMapRealVector openMapRealVector3 = openMapRealVector1.ebeDivide(realVector0);
    OpenMapRealVector openMapRealVector4 = openMapRealVector3.copy();
    RealVectorPreservingVisitor realVectorPreservingVisitor0 = mock(RealVectorPreservingVisitor.class, new ViolatedAssumptionAnswer());
    doReturn(0.0).when(realVectorPreservingVisitor0).end();
    openMapRealVector4.walkInOptimizedOrder(realVectorPreservingVisitor0);
    realVector0.isNaN();
    openMapRealVector3.getLInfDistance(openMapRealVector2);
    // Undeclared exception!
    try {
        openMapRealVector4.outerProduct(openMapRealVector2);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // -1,464 is smaller than, or equal to, the minimum (0)
        //
        verifyException(""org.apache.commons.math3.linear.AbstractRealMatrix"", e);
    }
}","/**
 * Compute the outer product.
 *
 * @param v Vector with which outer product should be computed.
 * @return the matrix outer product between this instance and {@code v}.
 */"
"@Override
public double dotProduct(RealVector v) {
    if (v instanceof OpenMapRealVector) {
        return dotProduct((OpenMapRealVector) v);
    } else {
        return super.dotProduct(v);
    }
}","public void test06868() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = 0.0;
    doubleArray0[1] = (-132.09534419319735);
    doubleArray0[2] = (-170.24);
    doubleArray0[3] = 6.283185307179586;
    doubleArray0[4] = 0.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((RealVector) openMapRealVector0);
    OpenMapRealVector openMapRealVector2 = new OpenMapRealVector(openMapRealVector1);
    openMapRealVector2.dotProduct((RealVector) openMapRealVector1);
}","/**
 * {@inheritDoc}
 */"
"@Override
public RealVector subtract(RealVector v) {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return subtract((OpenMapRealVector) v);
    } else {
        return super.subtract(v);
    }
}","public void test06969() throws Throwable {
    Double[] doubleArray0 = new Double[3];
    Double double0 = new Double(0.0);
    doubleArray0[0] = double0;
    Double double1 = new Double(0.0);
    doubleArray0[1] = double1;
    Double.max((double) doubleArray0[0], 693.41);
    Double double2 = new Double(0.0);
    doubleArray0[2] = double2;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-937.682037205));
    // Undeclared exception!
    try {
        openMapRealVector0.subtract((RealVector) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.linear.OpenMapRealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public RealVector subtract(RealVector v) {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return subtract((OpenMapRealVector) v);
    } else {
        return super.subtract(v);
    }
}","public void test07070() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 2685.3643084031;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    int int0 = (-503);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(1621);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(doubleArray0, arrayRealVector0);
    ArrayRealVector arrayRealVector2 = new ArrayRealVector(arrayRealVector1);
    ArrayRealVector arrayRealVector3 = new ArrayRealVector(arrayRealVector1, arrayRealVector2);
    ArrayRealVector arrayRealVector4 = new ArrayRealVector(arrayRealVector3, arrayRealVector1);
    ArrayRealVector arrayRealVector5 = new ArrayRealVector(openMapRealVector0, arrayRealVector4);
    // Undeclared exception!
    try {
        openMapRealVector0.subtract((RealVector) arrayRealVector5);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 1 != 4,867
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public RealVector projection(RealVector v) {
    checkVectorDimensions(v.getDimension());
    return v.mapMultiply(dotProduct(v) / v.dotProduct(v));
}","public void test07171() throws Throwable {
    Double[] doubleArray0 = new Double[8];
    Double double0 = new Double((-2853.55932));
    doubleArray0[0] = double0;
    Double double1 = new Double((double) doubleArray0[0]);
    doubleArray0[1] = double1;
    Double double2 = new Double((double) doubleArray0[0]);
    doubleArray0[2] = double2;
    Double double3 = new Double(1076.0);
    doubleArray0[3] = double3;
    Double double4 = new Double((double) doubleArray0[0]);
    doubleArray0[4] = double4;
    Double double5 = new Double((double) doubleArray0[1]);
    doubleArray0[5] = double5;
    Double.min(0.0, (double) doubleArray0[0]);
    Double double6 = new Double((-1522.609231593));
    doubleArray0[6] = double6;
    Double double7 = new Double(0.0);
    Double.sum((-1522.609231593), (-1135.1106966266227));
    Double.min((double) doubleArray0[4], (double) doubleArray0[5]);
    Double.max(933.1, 2140.88436858175);
    Double.isFinite(237.0810242);
    doubleArray0[7] = double7;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((RealVector) openMapRealVector0);
    openMapRealVector1.projection(openMapRealVector0);
}","/**
 * {@inheritDoc}
 */"
"protected void checkVectorDimensions(int n) {
    int d = getDimension();
    if (d != n) {
        throw new DimensionMismatchException(d, n);
    }
}","public void test07272() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(47, 47, (-1409.046116306145));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(47, 32);
    openMapRealVector1.getL1Distance(openMapRealVector0);
    openMapRealVector0.dotProduct(openMapRealVector1);
    OpenMapRealVector.OpenMapSparseIterator openMapRealVector_OpenMapSparseIterator0 = openMapRealVector0.new OpenMapSparseIterator();
    openMapRealVector_OpenMapSparseIterator0.hasNext();
    // Undeclared exception!
    try {
        openMapRealVector0.checkVectorDimensions(1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 47 != 1
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * Check if instance dimension is equal to some expected value.
 *
 * @param n Expected dimension.
 * @throws DimensionMismatchException if the dimension is
 * inconsistent with the vector size.
 */"
"public double walkInOptimizedOrder(final RealVectorPreservingVisitor visitor, final int start, final int end) {
    return walkInDefaultOrder(visitor, start, end);
}","public void test07373() throws Throwable {
    double[] doubleArray0 = new double[0];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-727.1219));
    RealVectorPreservingVisitor realVectorPreservingVisitor0 = mock(RealVectorPreservingVisitor.class, new ViolatedAssumptionAnswer());
    RealVector realVector0 = RealVector.unmodifiableRealVector(openMapRealVector0);
    realVector0.mapMultiply(2916.936571886845);
    openMapRealVector0.ebeDivide(realVector0);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0);
    openMapRealVector0.ebeDivide(arrayRealVector0);
    // Undeclared exception!
    try {
        openMapRealVector0.walkInOptimizedOrder(realVectorPreservingVisitor0, 3701, (-2240));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (3,701)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * Visits (but does not alter) some entries of this vector in optimized
 * order. The order in which the entries are visited is selected so as to
 * lead to the most efficient implementation; it might depend on the
 * concrete implementation of this abstract class.
 *
 * @param visitor visitor to be used to process the entries of this vector
 * @param start the index of the first entry to be visited
 * @param end the index of the last entry to be visited (inclusive)
 * @return the value returned by {@link RealVectorPreservingVisitor#end()}
 * at the end of the walk
 * @throws org.apache.commons.math3.exception.OutOfRangeException if
 * the indices are not valid.
 */"
"@Override
public double getL1Distance(RealVector v) {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return getL1Distance((OpenMapRealVector) v);
    } else {
        return super.getL1Distance(v);
    }
}","public void test07474() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 1905.041;
    doubleArray0[1] = (-1.0);
    doubleArray0[2] = (-1.0);
    doubleArray0[3] = 0.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-1.0));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(0, 1905.041);
    // Undeclared exception!
    try {
        openMapRealVector0.getL1Distance((RealVector) openMapRealVector1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 4 != 0
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public OpenMapRealVector mapAddToSelf(double d) {
    for (int i = 0; i < virtualSize; i++) {
        setEntry(i, getEntry(i) + d);
    }
    return this;
}","public void test07575() throws Throwable {
    Double[] doubleArray0 = new Double[3];
    Double double0 = new Double((-2753.17));
    doubleArray0[0] = double0;
    Double double1 = new Double((-1.0));
    doubleArray0[1] = double1;
    Double double2 = new Double((-2753.17));
    doubleArray0[2] = double2;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (double) doubleArray0[0]);
    openMapRealVector0.mapAddToSelf(0.0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public void setSubVector(int index, RealVector v) {
    checkIndex(index);
    checkIndex(index + v.getDimension() - 1);
    for (int i = 0; i < v.getDimension(); i++) {
        setEntry(i + index, v.getEntry(i));
    }
}","public void test07777() throws Throwable {
    double[] doubleArray0 = new double[3];
    double double0 = (-2102.6039973958987);
    doubleArray0[0] = (-2102.6039973958987);
    doubleArray0[1] = Double.NaN;
    double double1 = 0.0;
    doubleArray0[2] = 0.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    Acosh acosh0 = new Acosh();
    UnivariateFunction univariateFunction0 = acosh0.derivative();
    openMapRealVector0.map(univariateFunction0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0);
    openMapRealVector1.getL1Distance(openMapRealVector0);
    OpenMapRealVector openMapRealVector2 = openMapRealVector1.mapAdd(0.0);
    openMapRealVector2.mapAdd(0.0);
    // Undeclared exception!
    try {
        openMapRealVector0.setSubVector((-126), openMapRealVector1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (-126)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public OpenMapRealVector(Double[] values) {
    this(values, DEFAULT_ZERO_TOLERANCE);
}","public void test07878() throws Throwable {
    Double[] doubleArray0 = null;
    OpenMapRealVector openMapRealVector0 = null;
    try {
        openMapRealVector0 = new OpenMapRealVector((Double[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.linear.OpenMapRealVector"", e);
    }
}","/**
 * Create from an array.
 * Only non-zero entries will be stored.
 *
 * @param values The set of values to create from
 */"
"public double dotProduct(OpenMapRealVector v) {
    checkVectorDimensions(v.getDimension());
    boolean thisIsSmaller = entries.size() < v.entries.size();
    Iterator iter = thisIsSmaller ? entries.iterator() : v.entries.iterator();
    OpenIntToDoubleHashMap larger = thisIsSmaller ? v.entries : entries;
    double d = 0;
    while (iter.hasNext()) {
        iter.advance();
        d += iter.value() * larger.get(iter.key());
    }
    return d;
}","public void test07979() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(1312);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.copy();
    OpenMapRealVector openMapRealVector2 = openMapRealVector1.append((RealVector) openMapRealVector0);
    // Undeclared exception!
    try {
        openMapRealVector2.dotProduct(openMapRealVector0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 2,624 != 1,312
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * Optimized method to compute the dot product with an OpenMapRealVector.
 * It iterates over the smallest of the two.
 *
 * @param v Cector to compute the dot product with.
 * @return the dot product of {@code this} and {@code v}.
 * @throws org.apache.commons.math3.exception.DimensionMismatchException
 * if the dimensions do not match.
 */"
"@Override
public void setEntry(int index, double value) {
    checkIndex(index);
    if (!isDefaultValue(value)) {
        entries.put(index, value);
    } else if (entries.containsKey(index)) {
        entries.remove(index);
    }
}","public void test08080() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(0, (-3039), 0);
    openMapRealVector0.mapAddToSelf(1732.69);
    // Undeclared exception!
    try {
        openMapRealVector0.setEntry(0, 1790.428648);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (0)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public void addToEntry(int index, double increment) {
    setEntry(index, getEntry(index) + increment);
}","public void test08181() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector();
    openMapRealVector0.mapDivide((-1385.918928706));
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.copy();
    OpenMapRealVector openMapRealVector2 = openMapRealVector0.add(openMapRealVector1);
    openMapRealVector1.isDefaultValue((-1069.0));
    OpenMapRealVector openMapRealVector3 = openMapRealVector1.append(openMapRealVector2);
    openMapRealVector3.isDefaultValue(1.0E-12);
    openMapRealVector3.mapSubtract(0);
    // Undeclared exception!
    try {
        openMapRealVector0.addToEntry(0, 1.0E-12);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (0)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * Change an entry at the specified index.
 *
 * @param index Index location of entry to be set.
 * @param increment Value to add to the vector entry.
 * @throws org.apache.commons.math3.exception.OutOfRangeException if
 * the index is not valid.
 * @since 3.0
 */"
"public double getDistance(OpenMapRealVector v) {
    Iterator iter = entries.iterator();
    double res = 0;
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        double delta;
        delta = iter.value() - v.getEntry(key);
        res += delta * delta;
    }
    iter = v.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (!entries.containsKey(key)) {
            final double value = iter.value();
            res += value * value;
        }
    }
    return FastMath.sqrt(res);
}","public void test08282() throws Throwable {
    Double[] doubleArray0 = new Double[5];
    Double double0 = new Double(0.0);
    doubleArray0[0] = double0;
    Double double1 = new Double(982.8);
    doubleArray0[1] = double1;
    Double double2 = new Double((double) doubleArray0[0]);
    doubleArray0[2] = double2;
    Double double3 = new Double(0.0);
    doubleArray0[3] = double3;
    Double double4 = new Double((-652.53616));
    doubleArray0[4] = double4;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 2954.84);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0, 982.8);
    openMapRealVector0.getDistance(openMapRealVector1);
}","/**
 * Optimized method to compute distance.
 *
 * @param v Vector to compute distance to.
 * @return the distance from {@code this} and {@code v}.
 * @throws org.apache.commons.math3.exception.DimensionMismatchException
 * if the dimensions do not match.
 */"
"public OpenMapRealVector append(OpenMapRealVector v) {
    OpenMapRealVector res = new OpenMapRealVector(this, v.getDimension());
    Iterator iter = v.entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key() + virtualSize, iter.value());
    }
    return res;
}","public void test08383() throws Throwable {
    Double[] doubleArray0 = new Double[7];
    Double double0 = new Double(2.0);
    doubleArray0[0] = double0;
    Double double1 = new Double((-2404.419386274));
    doubleArray0[1] = double1;
    Double double2 = new Double(0.0);
    doubleArray0[2] = double2;
    Double double3 = new Double((double) doubleArray0[1]);
    doubleArray0[3] = double3;
    Double double4 = new Double(0.0);
    doubleArray0[4] = double4;
    Double double5 = new Double(1328.5);
    doubleArray0[5] = double5;
    Double double6 = new Double((double) doubleArray0[0]);
    doubleArray0[6] = double6;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0);
    openMapRealVector0.append(openMapRealVector1);
}","/**
 * Optimized method to append a OpenMapRealVector.
 * @param v vector to append
 * @return The result of appending {@code v} to self
 */"
"@Override
public RealVector projection(RealVector v) {
    checkVectorDimensions(v.getDimension());
    return v.mapMultiply(dotProduct(v) / v.dotProduct(v));
}","public void test08585() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(0, (-1));
    OpenIntToDoubleHashMap.Iterator openIntToDoubleHashMap_Iterator0 = mock(OpenIntToDoubleHashMap.Iterator.class, new ViolatedAssumptionAnswer());
    OpenMapRealVector.OpenMapEntry openMapRealVector_OpenMapEntry0 = openMapRealVector0.new OpenMapEntry(openIntToDoubleHashMap_Iterator0);
    double[] doubleArray0 = new double[8];
    doubleArray0[0] = (double) (-1);
    doubleArray0[1] = (double) (-1);
    doubleArray0[2] = (double) 0;
    doubleArray0[3] = 1.0E-12;
    doubleArray0[4] = (double) (-1);
    doubleArray0[5] = 1.0E-12;
    doubleArray0[6] = 1.0E-9;
    doubleArray0[7] = (double) (-1);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0);
    // Undeclared exception!
    try {
        openMapRealVector0.projection(arrayRealVector0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 0 != 8
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public void setEntry(int index, double value) {
    checkIndex(index);
    if (!isDefaultValue(value)) {
        entries.put(index, value);
    } else if (entries.containsKey(index)) {
        entries.remove(index);
    }
}","public void test08686() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-2295), (-2295), (-2295));
    RealVectorChangingVisitor realVectorChangingVisitor0 = mock(RealVectorChangingVisitor.class, new ViolatedAssumptionAnswer());
    doReturn(0.0).when(realVectorChangingVisitor0).end();
    openMapRealVector0.walkInOptimizedOrder(realVectorChangingVisitor0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((RealVector) openMapRealVector0);
    openMapRealVector1.getMinValue();
    openMapRealVector1.getL1Distance(openMapRealVector0);
    openMapRealVector1.getDistance(openMapRealVector0);
    openMapRealVector1.getL1Distance((RealVector) openMapRealVector0);
    openMapRealVector1.getDistance((RealVector) openMapRealVector0);
    // Undeclared exception!
    try {
        openMapRealVector1.setEntry(1, 0.0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (1)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public void setSubVector(int index, RealVector v) {
    checkIndex(index);
    checkIndex(index + v.getDimension() - 1);
    for (int i = 0; i < v.getDimension(); i++) {
        setEntry(i + index, v.getEntry(i));
    }
}","public void test08787() throws Throwable {
    int int0 = (-1);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-1));
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.mapAddToSelf((-1));
    RealVector realVector0 = openMapRealVector1.combineToSelf((-1), (-1), openMapRealVector0);
    int int1 = 0;
    // Undeclared exception!
    try {
        openMapRealVector0.setSubVector(0, realVector0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (0)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getLInfDistance(RealVector v) {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return getLInfDistance((OpenMapRealVector) v);
    } else {
        return super.getLInfDistance(v);
    }
}","public void test08888() throws Throwable {
    double[] doubleArray0 = new double[8];
    doubleArray0[0] = 0.0;
    doubleArray0[1] = (-16.0);
    doubleArray0[2] = 2454.1874907714;
    doubleArray0[3] = 1368.4981715;
    doubleArray0[4] = 251.0;
    doubleArray0[5] = (-70.87221);
    doubleArray0[6] = 0.0;
    doubleArray0[7] = (-1817.7996510790445);
    double[] doubleArray1 = new double[7];
    doubleArray1[0] = 0.0;
    doubleArray1[1] = 0.0;
    doubleArray1[2] = (-16.0);
    doubleArray1[3] = (-16.0);
    doubleArray1[4] = 0.0;
    doubleArray1[5] = (-70.87221);
    doubleArray1[6] = (-1817.7996510790445);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, doubleArray1);
    RealVector realVector0 = RealVector.unmodifiableRealVector(arrayRealVector0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(realVector0);
    openMapRealVector0.getLInfDistance(arrayRealVector0);
}","/**
 * {@inheritDoc}
 */"
"public RealVector map(UnivariateFunction function) {
    return copy().mapToSelf(function);
}","public void test08989() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(610, 610);
    RealVector realVector0 = RealVector.unmodifiableRealVector(openMapRealVector0);
    openMapRealVector0.add(realVector0);
    realVector0.iterator();
    // Undeclared exception!
    try {
        openMapRealVector0.map((UnivariateFunction) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * Acts as if implemented as:
 * <pre>
 *  return copy().mapToSelf(function);
 * </pre>
 * Returns a new vector. Does not change instance data.
 *
 * @param function Function to apply to each entry.
 * @return a new vector.
 */"
"@Override
public RealVector add(RealVector v) {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return add((OpenMapRealVector) v);
    } else {
        return super.add(v);
    }
}","public void test09090() throws Throwable {
    int int0 = 1313;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(1313, 1313);
    RealVector realVector0 = RealVector.unmodifiableRealVector(openMapRealVector0);
    openMapRealVector0.getEntry(0);
    realVector0.getL1Norm();
    // Undeclared exception!
    openMapRealVector0.add(realVector0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public OpenMapRealVector getSubVector(int index, int n) {
    checkIndex(index);
    if (n < 0) {
        throw new NotPositiveException(LocalizedFormats.NUMBER_OF_ELEMENTS_SHOULD_BE_POSITIVE, n);
    }
    checkIndex(index + n - 1);
    OpenMapRealVector res = new OpenMapRealVector(n);
    int end = index + n;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (key >= index && key < end) {
            res.setEntry(key - index, iter.value());
        }
    }
    return res;
}","public void test09191() throws Throwable {
    Double[] doubleArray0 = new Double[5];
    Double double0 = new Double(248.427);
    doubleArray0[0] = double0;
    Double double1 = new Double((double) doubleArray0[0]);
    doubleArray0[1] = double1;
    Double double2 = new Double((double) doubleArray0[1]);
    Double.isFinite(0.0);
    Double.min(248.427, 1176.8221);
    doubleArray0[2] = double2;
    Double double3 = new Double((double) doubleArray0[2]);
    doubleArray0[3] = double3;
    Double double4 = new Double((double) doubleArray0[3]);
    doubleArray0[4] = double4;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    Double.min(248.427, 0.0);
    // Undeclared exception!
    try {
        openMapRealVector0.getSubVector(1151, 1151);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (1,151)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public OpenMapRealVector getSubVector(int index, int n) {
    checkIndex(index);
    if (n < 0) {
        throw new NotPositiveException(LocalizedFormats.NUMBER_OF_ELEMENTS_SHOULD_BE_POSITIVE, n);
    }
    checkIndex(index + n - 1);
    OpenMapRealVector res = new OpenMapRealVector(n);
    int end = index + n;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (key >= index && key < end) {
            res.setEntry(key - index, iter.value());
        }
    }
    return res;
}","public void test09292() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(32);
    // Undeclared exception!
    try {
        openMapRealVector0.getSubVector(862, (-1428));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (862)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double walkInDefaultOrder(final RealVectorPreservingVisitor visitor, final int start, final int end) {
    checkIndices(start, end);
    visitor.start(getDimension(), start, end);
    for (int i = start; i <= end; i++) {
        visitor.visit(i, getEntry(i));
    }
    return visitor.end();
}","public void test09393() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector();
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((RealVector) openMapRealVector0);
    openMapRealVector0.getDistance(openMapRealVector1);
    openMapRealVector0.equals(openMapRealVector1);
    OpenMapRealVector openMapRealVector2 = openMapRealVector0.append(openMapRealVector1);
    RealVectorPreservingVisitor realVectorPreservingVisitor0 = mock(RealVectorPreservingVisitor.class, new ViolatedAssumptionAnswer());
    // Undeclared exception!
    try {
        openMapRealVector2.walkInDefaultOrder(realVectorPreservingVisitor0, (-1), (-1));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (-1)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * Visits (but does not alter) some entries of this vector in default order
 * (increasing index).
 *
 * @param visitor visitor to be used to process the entries of this vector
 * @param start the index of the first entry to be visited
 * @param end the index of the last entry to be visited (inclusive)
 * @return the value returned by {@link RealVectorPreservingVisitor#end()}
 * at the end of the walk
 * @throws org.apache.commons.math3.exception.OutOfRangeException if
 * the indices are not valid.
 */"
"@Override
public double dotProduct(RealVector v) {
    if (v instanceof OpenMapRealVector) {
        return dotProduct((OpenMapRealVector) v);
    } else {
        return super.dotProduct(v);
    }
}","public void test09494() throws Throwable {
    Double[] doubleArray0 = new Double[5];
    Double double0 = new Double(2268.74527);
    doubleArray0[0] = double0;
    Double double1 = new Double(2268.74527);
    doubleArray0[1] = double1;
    Double double2 = new Double(2268.74527);
    doubleArray0[2] = double2;
    Double double3 = new Double(2268.74527);
    doubleArray0[3] = double3;
    Double double4 = new Double((double) doubleArray0[3]);
    doubleArray0[4] = double4;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    double[] doubleArray1 = new double[9];
    doubleArray1[0] = 0.0;
    doubleArray1[1] = (double) doubleArray0[0];
    doubleArray1[2] = 2268.74527;
    doubleArray1[3] = (double) doubleArray0[1];
    doubleArray1[4] = 2268.74527;
    doubleArray1[5] = (double) doubleArray0[2];
    doubleArray1[6] = (double) doubleArray0[4];
    doubleArray1[7] = 1.0E-9;
    doubleArray1[8] = (double) doubleArray0[3];
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray1);
    // Undeclared exception!
    try {
        openMapRealVector0.dotProduct((RealVector) arrayRealVector0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 5 != 9
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public OpenMapRealVector ebeMultiply(RealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = new OpenMapRealVector(this);
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));
    }
    /*
         * MATH-803: the above loop assumes that 0d * x  = 0d for any double x,
         * which allows to consider only the non-zero entries of this. However,
         * this fails if this[i] == 0d and (v[i] = NaN or v[i] = Infinity).
         *
         * These special cases are handled below.
         */
    return res;
}","public void test09595() throws Throwable {
    Double[] doubleArray0 = new Double[4];
    double double0 = 0.0;
    Double double1 = new Double(0.0);
    doubleArray0[0] = double1;
    Double double2 = new Double((double) doubleArray0[0]);
    doubleArray0[1] = double2;
    Double double3 = new Double((double) doubleArray0[0]);
    doubleArray0[2] = double3;
    Double double4 = new Double((double) doubleArray0[1]);
    Double.max(1541.1778, 0.0);
    doubleArray0[3] = double4;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-895.4416156));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0, 155);
    openMapRealVector1.hashCode();
    Double.isFinite(1.0E-12);
    // Undeclared exception!
    try {
        openMapRealVector1.ebeMultiply(openMapRealVector0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 159 != 4
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public RealVector combineToSelf(double a, double b, RealVector y) {
    checkVectorDimensions(y);
    for (int i = 0; i < getDimension(); i++) {
        final double xi = getEntry(i);
        final double yi = y.getEntry(i);
        setEntry(i, a * xi + b * yi);
    }
    return this;
}","public void test09696() throws Throwable {
    int int0 = (-442);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-442));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0);
    openMapRealVector1.equals(""c"");
    OpenMapRealVector openMapRealVector2 = openMapRealVector1.ebeMultiply(openMapRealVector0);
    RealVector realVector0 = RealVector.unmodifiableRealVector(openMapRealVector1);
    openMapRealVector1.equals("""");
    openMapRealVector0.getDistance(openMapRealVector1);
    // Undeclared exception!
    try {
        realVector0.combineToSelf(Double.NaN, 0.0, openMapRealVector2);
        fail(""Expecting exception: MathUnsupportedOperationException"");
    } catch (MathUnsupportedOperationException e) {
        //
        // unsupported operation
        //
        verifyException(""org.apache.commons.math3.linear.RealVector$2"", e);
    }
}","/**
 * Updates {@code this} with the linear combination of {@code this} and
 * {@code y}.
 *
 * @param a Weight of {@code this}.
 * @param b Weight of {@code y}.
 * @param y Vector with which {@code this} is linearly combined.
 * @return {@code this}, with components equal to
 * {@code a * this[i] + b * y[i]} for all {@code i}.
 * @throws org.apache.commons.math3.exception.DimensionMismatchException
 * if {@code y} is not the same size as this vector.
 */"
"@Override
public void setSubVector(int index, RealVector v) {
    checkIndex(index);
    checkIndex(index + v.getDimension() - 1);
    for (int i = 0; i < v.getDimension(); i++) {
        setEntry(i + index, v.getEntry(i));
    }
}","public void test09797() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(270, 270, 270);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.mapAddToSelf(0.0);
    OpenIntToDoubleHashMap.Iterator openIntToDoubleHashMap_Iterator0 = mock(OpenIntToDoubleHashMap.Iterator.class, new ViolatedAssumptionAnswer());
    OpenMapRealVector.OpenMapEntry openMapRealVector_OpenMapEntry0 = openMapRealVector0.new OpenMapEntry(openIntToDoubleHashMap_Iterator0);
    openMapRealVector0.setSubVector(0, openMapRealVector1);
}","/**
 * {@inheritDoc}
 */"
"public OpenMapRealVector subtract(OpenMapRealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = copy();
    Iterator iter = v.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (entries.containsKey(key)) {
            res.setEntry(key, entries.get(key) - iter.value());
        } else {
            res.setEntry(key, -iter.value());
        }
    }
    return res;
}","public void test09898() throws Throwable {
    Double[] doubleArray0 = new Double[8];
    Double double0 = new Double(0.0);
    doubleArray0[0] = double0;
    Double double1 = new Double(146.55936311632829);
    doubleArray0[1] = double1;
    Double double2 = new Double(0.0);
    doubleArray0[2] = double2;
    Double double3 = new Double(1.0);
    doubleArray0[3] = double3;
    Double double4 = new Double((double) doubleArray0[2]);
    doubleArray0[4] = double4;
    Double double5 = new Double((-1782.0612488));
    doubleArray0[5] = double5;
    Double double6 = new Double(0.0);
    doubleArray0[6] = double6;
    Double double7 = new Double((-4788.020642772908));
    doubleArray0[7] = double7;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0, 0);
    double[] doubleArray1 = new double[9];
    doubleArray1[0] = (double) doubleArray0[2];
    doubleArray1[1] = (double) doubleArray0[7];
    doubleArray1[2] = 1.0E-9;
    doubleArray1[3] = (double) doubleArray0[4];
    doubleArray1[4] = 0.0;
    doubleArray1[5] = 1.0E-12;
    doubleArray1[6] = (-1782.0612488);
    doubleArray1[7] = (double) doubleArray0[6];
    doubleArray1[8] = (double) doubleArray0[5];
    OpenMapRealVector openMapRealVector2 = new OpenMapRealVector(doubleArray1);
    // Undeclared exception!
    try {
        openMapRealVector1.subtract(openMapRealVector2);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 8 != 9
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * Optimized method to subtract OpenMapRealVectors.
 *
 * @param v Vector to subtract from {@code this}.
 * @return the difference of {@code this} and {@code v}.
 * @throws org.apache.commons.math3.exception.DimensionMismatchException
 * if the dimensions do not match.
 */"
"public ArrayRealVector(RealVector v1, ArrayRealVector v2) {
    final int l1 = v1.getDimension();
    final int l2 = v2.data.length;
    data = new double[l1 + l2];
    for (int i = 0; i < l1; ++i) {
        data[i] = v1.getEntry(i);
    }
    System.arraycopy(v2.data, 0, data, l1, l2);
}","public void test09999() throws Throwable {
    int int0 = (-1399);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-1399), Double.POSITIVE_INFINITY);
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = (double) (-1399);
    doubleArray0[1] = Double.POSITIVE_INFINITY;
    doubleArray0[2] = Double.POSITIVE_INFINITY;
    doubleArray0[3] = 1.0E-12;
    Double[] doubleArray1 = new Double[7];
    doubleArray1[0] = (Double) Double.POSITIVE_INFINITY;
    doubleArray1[1] = (Double) (-1399.0);
    doubleArray1[2] = (Double) Double.POSITIVE_INFINITY;
    Double double0 = new Double(Double.POSITIVE_INFINITY);
    doubleArray1[3] = double0;
    doubleArray1[4] = (Double) 1.0E-12;
    doubleArray1[5] = (Double) Double.POSITIVE_INFINITY;
    doubleArray1[6] = (Double) 1.0E-12;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray1);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(arrayRealVector0, doubleArray0);
    ArrayRealVector arrayRealVector2 = new ArrayRealVector(doubleArray0, arrayRealVector1);
    ArrayRealVector arrayRealVector3 = new ArrayRealVector(arrayRealVector2, arrayRealVector0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((-1399), 1.0E-12);
    openMapRealVector0.subtract(openMapRealVector1);
    ArrayRealVector arrayRealVector4 = null;
    try {
        arrayRealVector4 = new ArrayRealVector(openMapRealVector0, arrayRealVector3);
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.linear.ArrayRealVector"", e);
    }
}","/**
 * Construct a vector by appending one vector to another vector.
 * @param v1 First vector (will be put in front of the new vector).
 * @param v2 Second vector (will be put at back of the new vector).
 */"
"@Override
public void set(double value) {
    for (int i = 0; i < virtualSize; i++) {
        setEntry(i, value);
    }
}","public void test100100() throws Throwable {
    Double[] doubleArray0 = new Double[6];
    Double double0 = new Double(3502.98567);
    doubleArray0[0] = double0;
    Double double1 = new Double((double) doubleArray0[0]);
    doubleArray0[1] = double1;
    Double double2 = new Double(3502.98567);
    doubleArray0[2] = double2;
    Double double3 = new Double(3502.98567);
    doubleArray0[3] = double3;
    Double double4 = new Double((-1.0));
    doubleArray0[4] = double4;
    Double double5 = new Double(Double.NaN);
    doubleArray0[5] = double5;
    Double.sum((double) doubleArray0[2], 0.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    Double.isFinite(Double.NaN);
    openMapRealVector0.sparseIterator();
    OpenIntToDoubleHashMap.Iterator openIntToDoubleHashMap_Iterator0 = mock(OpenIntToDoubleHashMap.Iterator.class, new ViolatedAssumptionAnswer());
    doReturn(0.0).when(openIntToDoubleHashMap_Iterator0).value();
    Double.min(0.0, 386.034701613817);
    OpenMapRealVector.OpenMapEntry openMapRealVector_OpenMapEntry0 = openMapRealVector0.new OpenMapEntry(openIntToDoubleHashMap_Iterator0);
    openMapRealVector_OpenMapEntry0.getValue();
    OpenMapRealVector.OpenMapSparseIterator openMapRealVector_OpenMapSparseIterator0 = openMapRealVector0.new OpenMapSparseIterator();
    openMapRealVector_OpenMapSparseIterator0.next();
    openMapRealVector_OpenMapSparseIterator0.next();
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(208);
    openMapRealVector0.append((RealVector) arrayRealVector0);
    openMapRealVector0.set((double) doubleArray0[0]);
}","/**
 * {@inheritDoc}
 */"
"public OpenMapRealVector subtract(OpenMapRealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = copy();
    Iterator iter = v.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (entries.containsKey(key)) {
            res.setEntry(key, entries.get(key) - iter.value());
        } else {
            res.setEntry(key, -iter.value());
        }
    }
    return res;
}","public void test101101() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector();
    openMapRealVector0.isInfinite();
    OpenMapRealVector openMapRealVector1 = null;
    // Undeclared exception!
    try {
        openMapRealVector0.subtract((OpenMapRealVector) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.linear.OpenMapRealVector"", e);
    }
}","/**
 * Optimized method to subtract OpenMapRealVectors.
 *
 * @param v Vector to subtract from {@code this}.
 * @return the difference of {@code this} and {@code v}.
 * @throws org.apache.commons.math3.exception.DimensionMismatchException
 * if the dimensions do not match.
 */"
"public double getL1Distance(OpenMapRealVector v) {
    double max = 0;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double delta = FastMath.abs(iter.value() - v.getEntry(iter.key()));
        max += delta;
    }
    iter = v.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (!entries.containsKey(key)) {
            double delta = FastMath.abs(iter.value());
            max += FastMath.abs(delta);
        }
    }
    return max;
}","public void test102102() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector();
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((RealVector) openMapRealVector0);
    OpenIntToDoubleHashMap.Iterator openIntToDoubleHashMap_Iterator0 = mock(OpenIntToDoubleHashMap.Iterator.class, new ViolatedAssumptionAnswer());
    doReturn(0, 0).when(openIntToDoubleHashMap_Iterator0).key();
    doReturn(0.0, 0.0).when(openIntToDoubleHashMap_Iterator0).value();
    openMapRealVector1.mapDivide(785.4);
    OpenMapRealVector.OpenMapEntry openMapRealVector_OpenMapEntry0 = openMapRealVector1.new OpenMapEntry(openIntToDoubleHashMap_Iterator0);
    openMapRealVector_OpenMapEntry0.setIndex(0);
    openMapRealVector_OpenMapEntry0.setValue(846.6658548388768);
    openMapRealVector_OpenMapEntry0.getValue();
    openMapRealVector_OpenMapEntry0.getIndex();
    openMapRealVector_OpenMapEntry0.getValue();
    openMapRealVector1.set(1.0E-12);
    // Undeclared exception!
    try {
        openMapRealVector1.getL1Distance(openMapRealVector0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (0)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * Distance between two vectors.
 * This method computes the distance consistent with
 * L<sub>1</sub> norm, i.e. the sum of the absolute values of
 * elements differences.
 *
 * @param v Vector to which distance is requested.
 * @return distance between this vector and {@code v}.
 */"
"@Override
public double getEntry(int index) {
    checkIndex(index);
    return entries.get(index);
}","public void test103103() throws Throwable {
    int int0 = 0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-695), 0, (-695));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0);
    openMapRealVector0.append((RealVector) openMapRealVector1);
    openMapRealVector0.mapSubtract(0);
    // Undeclared exception!
    try {
        openMapRealVector0.getEntry(0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (0)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"protected OpenMapRealVector(OpenMapRealVector v, int resize) {
    virtualSize = v.getDimension() + resize;
    entries = new OpenIntToDoubleHashMap(v.entries);
    epsilon = v.epsilon;
}","public void test104104() throws Throwable {
    OpenMapRealVector openMapRealVector0 = null;
    int int0 = 0;
    OpenMapRealVector openMapRealVector1 = null;
    try {
        openMapRealVector1 = new OpenMapRealVector((OpenMapRealVector) null, 0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.linear.OpenMapRealVector"", e);
    }
}","/**
 * Build a resized vector, for use with append.
 *
 * @param v Original vector.
 * @param resize Amount to add.
 */"
"public double getL1Distance(OpenMapRealVector v) {
    double max = 0;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double delta = FastMath.abs(iter.value() - v.getEntry(iter.key()));
        max += delta;
    }
    iter = v.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (!entries.containsKey(key)) {
            double delta = FastMath.abs(iter.value());
            max += FastMath.abs(delta);
        }
    }
    return max;
}","public void test105105() throws Throwable {
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = 6.283185307179586;
    doubleArray0[1] = 0.0;
    doubleArray0[2] = 194.7860361;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 6.283185307179586);
    openMapRealVector0.mapDivideToSelf(6.283185307179586);
    // Undeclared exception!
    try {
        openMapRealVector0.getL1Distance((OpenMapRealVector) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.linear.OpenMapRealVector"", e);
    }
}","/**
 * Distance between two vectors.
 * This method computes the distance consistent with
 * L<sub>1</sub> norm, i.e. the sum of the absolute values of
 * elements differences.
 *
 * @param v Vector to which distance is requested.
 * @return distance between this vector and {@code v}.
 */"
"public OpenMapRealVector(int dimension, int expectedSize, double epsilon) {
    virtualSize = dimension;
    entries = new OpenIntToDoubleHashMap(expectedSize, 0.0);
    this.epsilon = epsilon;
}","public void test106106() throws Throwable {
    OpenMapRealVector openMapRealVector0 = null;
    try {
        openMapRealVector0 = new OpenMapRealVector(2146590879, 2146590879, 1145.8947);
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.OpenIntToDoubleHashMap"", e);
    }
}","/**
 * Build a vector with known the sparseness and zero tolerance
 * setting (for advanced use only).
 *
 * @param dimension Size of the vector.
 * @param expectedSize Expected number of non-zero entries.
 * @param epsilon Tolerance below which a value is considered zero.
 */"
"@Override
public double getDistance(RealVector v) {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return getDistance((OpenMapRealVector) v);
    } else {
        return super.getDistance(v);
    }
}","public void test107107() throws Throwable {
    int int0 = 0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(0, (-3039), 0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((-1), (-1062.57));
    // Undeclared exception!
    try {
        openMapRealVector0.getDistance((RealVector) openMapRealVector1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 0 != -1
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public void setEntry(int index, double value) {
    checkIndex(index);
    if (!isDefaultValue(value)) {
        entries.put(index, value);
    } else if (entries.containsKey(index)) {
        entries.remove(index);
    }
}","public void test108108() throws Throwable {
    Double[] doubleArray0 = new Double[3];
    Double double0 = new Double((-1673.0146288));
    doubleArray0[0] = double0;
    Double double1 = new Double((-1.0));
    doubleArray0[1] = double1;
    Double double2 = Double.valueOf((-1673.0146288));
    Double.min(0.5, 0.0);
    doubleArray0[2] = double2;
    Double.sum((double) doubleArray0[1], (-2122.2405150722));
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    openMapRealVector0.toArray();
    Double.max(2063.216324559, (-372.7136391293));
    openMapRealVector0.isNaN();
    OpenMapRealVector.OpenMapSparseIterator openMapRealVector_OpenMapSparseIterator0 = openMapRealVector0.new OpenMapSparseIterator();
    Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
    openMapRealVector_OpenMapSparseIterator0.forEachRemaining(consumer0);
    openMapRealVector_OpenMapSparseIterator0.hasNext();
    openMapRealVector_OpenMapSparseIterator0.hasNext();
    // Undeclared exception!
    try {
        openMapRealVector0.setEntry((-418), 2063.216324559);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (-418)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double walkInOptimizedOrder(final RealVectorPreservingVisitor visitor, final int start, final int end) {
    return walkInDefaultOrder(visitor, start, end);
}","public void test109109() throws Throwable {
    double[] doubleArray0 = new double[0];
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (-727.1219));
    RealVectorPreservingVisitor realVectorPreservingVisitor0 = mock(RealVectorPreservingVisitor.class, new ViolatedAssumptionAnswer());
    RealVector realVector0 = RealVector.unmodifiableRealVector(openMapRealVector0);
    RealVector realVector1 = realVector0.mapMultiply(2916.936571886845);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.ebeDivide(realVector0);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0);
    openMapRealVector0.ebeDivide(arrayRealVector0);
    arrayRealVector0.equals(realVector1);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(doubleArray0, doubleArray0);
    openMapRealVector1.getL1Distance((RealVector) arrayRealVector1);
    // Undeclared exception!
    try {
        openMapRealVector0.walkInOptimizedOrder(realVectorPreservingVisitor0, 3701, (-2240));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (3,701)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * Visits (but does not alter) some entries of this vector in optimized
 * order. The order in which the entries are visited is selected so as to
 * lead to the most efficient implementation; it might depend on the
 * concrete implementation of this abstract class.
 *
 * @param visitor visitor to be used to process the entries of this vector
 * @param start the index of the first entry to be visited
 * @param end the index of the last entry to be visited (inclusive)
 * @return the value returned by {@link RealVectorPreservingVisitor#end()}
 * at the end of the walk
 * @throws org.apache.commons.math3.exception.OutOfRangeException if
 * the indices are not valid.
 */"
"@Override
public void setSubVector(int index, RealVector v) {
    checkIndex(index);
    checkIndex(index + v.getDimension() - 1);
    for (int i = 0; i < v.getDimension(); i++) {
        setEntry(i + index, v.getEntry(i));
    }
}","public void test110110() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(1447, 0.0);
    openMapRealVector0.combine(0.0, 1447, openMapRealVector0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.unitVector();
    // Undeclared exception!
    try {
        openMapRealVector1.setSubVector(1150, openMapRealVector0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (2,596)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public OpenMapRealVector unitVector() {
    OpenMapRealVector res = copy();
    res.unitize();
    return res;
}","public void test111111() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = 0.0;
    doubleArray0[1] = (-132.09534419319735);
    doubleArray0[2] = (-170.24);
    doubleArray0[3] = 6.283185307179586;
    doubleArray0[4] = 0.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((RealVector) openMapRealVector0);
    RealVectorPreservingVisitor realVectorPreservingVisitor0 = mock(RealVectorPreservingVisitor.class, new ViolatedAssumptionAnswer());
    doReturn(0.0).when(realVectorPreservingVisitor0).end();
    openMapRealVector1.walkInOptimizedOrder(realVectorPreservingVisitor0);
    OpenMapRealVector openMapRealVector2 = new OpenMapRealVector(openMapRealVector1);
    openMapRealVector2.dotProduct((RealVector) openMapRealVector1);
    openMapRealVector0.unitVector();
}","/**
 * {@inheritDoc}
 */"
"protected void checkIndices(final int start, final int end) {
    final int dim = getDimension();
    if ((start < 0) || (start >= dim)) {
        throw new OutOfRangeException(LocalizedFormats.INDEX, start, 0, dim - 1);
    }
    if ((end < 0) || (end >= dim)) {
        throw new OutOfRangeException(LocalizedFormats.INDEX, end, 0, dim - 1);
    }
    if (end < start) {
        // TODO Use more specific error message
        throw new NumberIsTooSmallException(LocalizedFormats.INITIAL_ROW_AFTER_FINAL_ROW, end, start, false);
    }
}","public void test113113() throws Throwable {
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = 4111.0;
    doubleArray0[1] = 649.9224;
    doubleArray0[2] = (-763.7758205708);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(1396, 4111.0);
    ArrayRealVector arrayRealVector1 = new ArrayRealVector(openMapRealVector0, arrayRealVector0);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.append((RealVector) arrayRealVector1);
    OpenMapRealVector openMapRealVector2 = new OpenMapRealVector(doubleArray0, (-372.3350457044207));
    openMapRealVector0.dotProduct(openMapRealVector2);
    openMapRealVector2.getL1Distance((RealVector) openMapRealVector0);
    // Undeclared exception!
    try {
        openMapRealVector1.checkIndices(1396, (-868));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (-868)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * Checks that the indices of a subvector are valid.
 *
 * @param start the index of the first entry of the subvector
 * @param end the index of the last entry of the subvector (inclusive)
 * @throws OutOfRangeException if {@code start} of {@code end} are not valid
 * @throws NumberIsTooSmallException if {@code end < start}
 */"
"public double cosine(RealVector v) {
    final double norm = getNorm();
    final double vNorm = v.getNorm();
    if (norm == 0 || vNorm == 0) {
        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);
    }
    return dotProduct(v) / (norm * vNorm);
}","public void test114114() throws Throwable {
    int int0 = 995;
    int int1 = (-728);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(995, 995);
    openMapRealVector0.toArray();
    openMapRealVector0.mapMultiply(1132.05355);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.ebeMultiply(openMapRealVector0);
    // Undeclared exception!
    try {
        openMapRealVector1.cosine(openMapRealVector0);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // zero norm
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * Computes the cosine of the angle between this vector and the
 * argument.
 *
 * @param v Vector.
 * @return the cosine of the angle between this vector and {@code v}.
 */"
"@Override
public OpenMapRealVector getSubVector(int index, int n) {
    checkIndex(index);
    if (n < 0) {
        throw new NotPositiveException(LocalizedFormats.NUMBER_OF_ELEMENTS_SHOULD_BE_POSITIVE, n);
    }
    checkIndex(index + n - 1);
    OpenMapRealVector res = new OpenMapRealVector(n);
    int end = index + n;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (key >= index && key < end) {
            res.setEntry(key - index, iter.value());
        }
    }
    return res;
}","public void test115115() throws Throwable {
    int int0 = 181;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(181, 181);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(2716, 181, 1.0E-12);
    // Undeclared exception!
    try {
        openMapRealVector1.getSubVector(181, 2716);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (2,896)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double dotProduct(RealVector v) {
    checkVectorDimensions(v);
    double d = 0;
    Iterator<Entry> it = sparseIterator();
    while (it.hasNext()) {
        final Entry e = it.next();
        d += e.getValue() * v.getEntry(e.getIndex());
    }
    return d;
}","public void test116116() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-21));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0, (-21));
    openMapRealVector0.hashCode();
    OpenMapRealVector openMapRealVector2 = openMapRealVector1.append((RealVector) openMapRealVector0);
    OpenMapRealVector openMapRealVector3 = new OpenMapRealVector((-21));
    RealVectorPreservingVisitor realVectorPreservingVisitor0 = mock(RealVectorPreservingVisitor.class, new ViolatedAssumptionAnswer());
    doReturn(1.0E-12).when(realVectorPreservingVisitor0).end();
    openMapRealVector3.walkInDefaultOrder(realVectorPreservingVisitor0);
    openMapRealVector1.equals(openMapRealVector3);
    openMapRealVector1.getMaxIndex();
    double double0 = 44.4735551249935;
    OpenIntToDoubleHashMap.Iterator openIntToDoubleHashMap_Iterator0 = mock(OpenIntToDoubleHashMap.Iterator.class, new ViolatedAssumptionAnswer());
    OpenMapRealVector.OpenMapEntry openMapRealVector_OpenMapEntry0 = openMapRealVector1.new OpenMapEntry(openIntToDoubleHashMap_Iterator0);
    openMapRealVector2.mapAdd((-1));
    RealVector realVector0 = openMapRealVector1.mapDivideToSelf(1.0E-12);
    // Undeclared exception!
    try {
        realVector0.dotProduct((RealVector) openMapRealVector2);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // -42 != -63
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * Compute the dot product of this vector with {@code v}.
 *
 * @param v Vector with which dot product should be computed
 * @return the scalar dot product between this instance and {@code v}.
 * @throws org.apache.commons.math3.exception.DimensionMismatchException
 * if {@code v} is not the same size as this vector.
 */"
"public double walkInOptimizedOrder(final RealVectorChangingVisitor visitor) {
    return walkInDefaultOrder(visitor);
}","public void test117117() throws Throwable {
    int int0 = 0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0, 0);
    openMapRealVector0.hashCode();
    OpenMapRealVector openMapRealVector2 = openMapRealVector1.append((RealVector) openMapRealVector0);
    OpenMapRealVector openMapRealVector3 = new OpenMapRealVector(0);
    RealVectorPreservingVisitor realVectorPreservingVisitor0 = mock(RealVectorPreservingVisitor.class, new ViolatedAssumptionAnswer());
    doReturn((-4.8402541351522003E-36)).when(realVectorPreservingVisitor0).end();
    openMapRealVector3.walkInDefaultOrder(realVectorPreservingVisitor0);
    openMapRealVector1.equals(openMapRealVector3);
    openMapRealVector1.getMaxIndex();
    OpenIntToDoubleHashMap.Iterator openIntToDoubleHashMap_Iterator0 = mock(OpenIntToDoubleHashMap.Iterator.class, new ViolatedAssumptionAnswer());
    doReturn((-4.8402541351522003E-36)).when(openIntToDoubleHashMap_Iterator0).value();
    OpenMapRealVector.OpenMapEntry openMapRealVector_OpenMapEntry0 = openMapRealVector1.new OpenMapEntry(openIntToDoubleHashMap_Iterator0);
    OpenMapRealVector openMapRealVector4 = openMapRealVector2.mapAdd((-1));
    openMapRealVector1.mapDivideToSelf(1.0E-12);
    openMapRealVector_OpenMapEntry0.getValue();
    OpenMapRealVector openMapRealVector5 = openMapRealVector1.append(585.50939104);
    openMapRealVector4.ebeMultiply(openMapRealVector0);
    // Undeclared exception!
    try {
        openMapRealVector5.walkInOptimizedOrder((RealVectorChangingVisitor) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * Visits (and possibly alters) all entries of this vector in optimized
 * order. The order in which the entries are visited is selected so as to
 * lead to the most efficient implementation; it might depend on the
 * concrete implementation of this abstract class.
 *
 * @param visitor the visitor to be used to process the entries of this
 * vector
 * @return the value returned by {@link RealVectorChangingVisitor#end()}
 * at the end of the walk
 */"
"@Override
public void set(double value) {
    for (int i = 0; i < virtualSize; i++) {
        setEntry(i, value);
    }
}","public void test118118() throws Throwable {
    int int0 = 2146970693;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(2146970693);
    // Undeclared exception!
    openMapRealVector0.set(2146970693);
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getEntry(int index) {
    checkIndex(index);
    return entries.get(index);
}","public void test119119() throws Throwable {
    Double[] doubleArray0 = new Double[4];
    Double double0 = new Double((-968.5766984261));
    doubleArray0[0] = double0;
    Double double1 = new Double((-968.5766984261));
    doubleArray0[1] = double1;
    Double double2 = new Double(0.0);
    Double.min(0.0, 770.181);
    Double.max(0.0, 0.0);
    doubleArray0[2] = doubleArray0[1];
    Double double3 = new Double(0.0);
    doubleArray0[3] = double3;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (double) doubleArray0[1]);
    openMapRealVector0.iterator();
    openMapRealVector0.iterator();
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0);
    openMapRealVector0.hashCode();
    OpenMapRealVector openMapRealVector2 = openMapRealVector0.mapAdd(0.0);
    OpenMapRealVector openMapRealVector3 = openMapRealVector1.mapAdd(1.0E-12);
    openMapRealVector1.isInfinite();
    OpenIntToDoubleHashMap.Iterator openIntToDoubleHashMap_Iterator0 = mock(OpenIntToDoubleHashMap.Iterator.class, new ViolatedAssumptionAnswer());
    doReturn(2146805545).when(openIntToDoubleHashMap_Iterator0).key();
    OpenMapRealVector.OpenMapEntry openMapRealVector_OpenMapEntry0 = openMapRealVector2.new OpenMapEntry(openIntToDoubleHashMap_Iterator0);
    openMapRealVector_OpenMapEntry0.setValue(0.0);
    openMapRealVector0.append((double) (-1410));
    openMapRealVector3.getL1Distance((RealVector) openMapRealVector0);
    // Undeclared exception!
    try {
        openMapRealVector2.getEntry((-1410));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (-1,410)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public OpenMapRealVector mapAddToSelf(double d) {
    for (int i = 0; i < virtualSize; i++) {
        setEntry(i, getEntry(i) + d);
    }
    return this;
}","public void test120120() throws Throwable {
    int int0 = 2795;
    int int1 = (-3137);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(2795, (-3137));
    // Undeclared exception!
    try {
        openMapRealVector0.mapAddToSelf(2795);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getLInfDistance(RealVector v) {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return getLInfDistance((OpenMapRealVector) v);
    } else {
        return super.getLInfDistance(v);
    }
}","public void test121121() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector();
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.mapAddToSelf((-7.3304404046850136E-9));
    openMapRealVector1.mapAddToSelf(2688.306219726303);
    OpenMapRealVector openMapRealVector2 = openMapRealVector1.append(openMapRealVector0);
    openMapRealVector0.getDimension();
    openMapRealVector2.mapAddToSelf(1.0E-12);
    openMapRealVector0.getSparsity();
    // Undeclared exception!
    try {
        openMapRealVector1.getLInfDistance((RealVector) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.linear.OpenMapRealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getEntry(int index) {
    checkIndex(index);
    return entries.get(index);
}","public void test123123() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(405, 5037.293389903);
    RealVector.unmodifiableRealVector(openMapRealVector0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((RealVector) openMapRealVector0);
    Sinc sinc0 = new Sinc();
    openMapRealVector1.mapToSelf(sinc0);
    openMapRealVector1.getL1Distance(openMapRealVector0);
    openMapRealVector1.add((RealVector) openMapRealVector0);
    // Undeclared exception!
    try {
        openMapRealVector1.getEntry((-3720));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (-3,720)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getDistance(RealVector v) {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return getDistance((OpenMapRealVector) v);
    } else {
        return super.getDistance(v);
    }
}","public void test124124() throws Throwable {
    Double[] doubleArray0 = new Double[6];
    Double double0 = new Double((-3520.949999));
    doubleArray0[0] = double0;
    Double double1 = new Double(Double.NaN);
    doubleArray0[1] = double1;
    Double double2 = new Double(3.141592653589793);
    doubleArray0[2] = double2;
    Double double3 = new Double(588.5125100185);
    doubleArray0[3] = double3;
    Double.sum((-1922.0), 6176.2973302566);
    Double double4 = new Double(2480.0);
    doubleArray0[4] = double4;
    Double double5 = new Double(3.141592653589793);
    doubleArray0[5] = double5;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    double[] doubleArray1 = new double[6];
    doubleArray1[0] = (-2139.08106043888);
    doubleArray1[1] = 6176.2973302566;
    doubleArray1[2] = 4254.2973302566;
    doubleArray1[3] = (double) doubleArray0[0];
    doubleArray1[4] = 6176.2973302566;
    doubleArray1[5] = (-3520.949999);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray1, true);
    openMapRealVector0.dotProduct((RealVector) arrayRealVector0);
    openMapRealVector0.set((double) doubleArray0[2]);
    openMapRealVector0.unitize();
    openMapRealVector0.getDistance((RealVector) arrayRealVector0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public ArrayRealVector ebeMultiply(RealVector v) {
    if (v instanceof ArrayRealVector) {
        final double[] vData = ((ArrayRealVector) v).data;
        final int dim = vData.length;
        checkVectorDimensions(dim);
        ArrayRealVector result = new ArrayRealVector(dim);
        double[] resultData = result.data;
        for (int i = 0; i < dim; i++) {
            resultData[i] = data[i] * vData[i];
        }
        return result;
    } else {
        checkVectorDimensions(v);
        double[] out = data.clone();
        for (int i = 0; i < data.length; i++) {
            out[i] *= v.getEntry(i);
        }
        return new ArrayRealVector(out, false);
    }
}","public void test125125() throws Throwable {
    int int0 = (-1968);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-1968), (-1968), 1731.65572417);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((-1968));
    Sinc sinc0 = new Sinc(true);
    openMapRealVector1.mapToSelf(sinc0);
    openMapRealVector0.getLInfDistance(openMapRealVector1);
    double[] doubleArray0 = new double[1];
    openMapRealVector1.isDefaultValue(0.0);
    openMapRealVector0.set(982.8);
    doubleArray0[0] = 1.0E-12;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, doubleArray0);
    openMapRealVector1.equals(openMapRealVector0);
    RealVectorChangingVisitor realVectorChangingVisitor0 = mock(RealVectorChangingVisitor.class, new ViolatedAssumptionAnswer());
    doReturn(0.0).when(realVectorChangingVisitor0).end();
    openMapRealVector1.walkInOptimizedOrder(realVectorChangingVisitor0);
    // Undeclared exception!
    try {
        arrayRealVector0.ebeMultiply(openMapRealVector0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 2 != -1,968
        //
        verifyException(""org.apache.commons.math3.linear.ArrayRealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public OpenMapRealVector getSubVector(int index, int n) {
    checkIndex(index);
    if (n < 0) {
        throw new NotPositiveException(LocalizedFormats.NUMBER_OF_ELEMENTS_SHOULD_BE_POSITIVE, n);
    }
    checkIndex(index + n - 1);
    OpenMapRealVector res = new OpenMapRealVector(n);
    int end = index + n;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (key >= index && key < end) {
            res.setEntry(key - index, iter.value());
        }
    }
    return res;
}","public void test126126() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(1570, 1570);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.copy();
    openMapRealVector1.outerProduct(openMapRealVector0);
    Consumer<RealVector.Entry> consumer0 = (Consumer<RealVector.Entry>) mock(Consumer.class, new ViolatedAssumptionAnswer());
    openMapRealVector0.isNaN();
    OpenIntToDoubleHashMap.Iterator openIntToDoubleHashMap_Iterator0 = mock(OpenIntToDoubleHashMap.Iterator.class, new ViolatedAssumptionAnswer());
    doReturn(0, 0, 0).when(openIntToDoubleHashMap_Iterator0).key();
    doReturn(0.0, 0.0).when(openIntToDoubleHashMap_Iterator0).value();
    OpenMapRealVector.OpenMapEntry openMapRealVector_OpenMapEntry0 = openMapRealVector1.new OpenMapEntry(openIntToDoubleHashMap_Iterator0);
    openMapRealVector_OpenMapEntry0.getValue();
    openMapRealVector_OpenMapEntry0.setIndex(81);
    openMapRealVector_OpenMapEntry0.setValue(1570);
    openMapRealVector_OpenMapEntry0.getIndex();
    openMapRealVector1.sparseIterator();
    openMapRealVector_OpenMapEntry0.getValue();
    openMapRealVector_OpenMapEntry0.getIndex();
    RealVector realVector0 = openMapRealVector1.projection(openMapRealVector0);
    openMapRealVector0.sparseIterator();
    openMapRealVector1.getDistance((RealVector) openMapRealVector0);
    RealVector realVector1 = openMapRealVector1.projection(realVector0);
    openMapRealVector0.isNaN();
    openMapRealVector1.add(realVector1);
    // Undeclared exception!
    try {
        openMapRealVector1.getSubVector((-1543), 2352);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (-1,543)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public void setEntry(int index, double value) {
    checkIndex(index);
    if (!isDefaultValue(value)) {
        entries.put(index, value);
    } else if (entries.containsKey(index)) {
        entries.remove(index);
    }
}","public void test127127() throws Throwable {
    Double[] doubleArray0 = new Double[7];
    Double double0 = new Double((-1282.0));
    doubleArray0[0] = double0;
    Double double1 = new Double((double) doubleArray0[0]);
    doubleArray0[1] = double1;
    Double double2 = new Double((-1282.0));
    doubleArray0[2] = double2;
    Double double3 = new Double(1457.60997);
    doubleArray0[3] = double3;
    Double double4 = new Double((double) doubleArray0[2]);
    doubleArray0[4] = double4;
    Double double5 = new Double(1003.955);
    doubleArray0[5] = double5;
    Double.sum((double) doubleArray0[0], (double) doubleArray0[1]);
    Double double6 = new Double(944.0);
    doubleArray0[6] = double6;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 15.3);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.mapAdd(1457.60997);
    OpenMapRealVector openMapRealVector2 = openMapRealVector1.ebeDivide(openMapRealVector0);
    OpenMapRealVector openMapRealVector3 = openMapRealVector1.ebeMultiply(openMapRealVector2);
    openMapRealVector2.append(15.3);
    openMapRealVector3.copy();
    openMapRealVector0.setEntry(0, (-2564.0));
    // Undeclared exception!
    try {
        openMapRealVector2.setEntry((-1775), (double) doubleArray0[0]);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (-1,775)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public ArrayRealVector ebeMultiply(RealVector v) {
    if (v instanceof ArrayRealVector) {
        final double[] vData = ((ArrayRealVector) v).data;
        final int dim = vData.length;
        checkVectorDimensions(dim);
        ArrayRealVector result = new ArrayRealVector(dim);
        double[] resultData = result.data;
        for (int i = 0; i < dim; i++) {
            resultData[i] = data[i] * vData[i];
        }
        return result;
    } else {
        checkVectorDimensions(v);
        double[] out = data.clone();
        for (int i = 0; i < data.length; i++) {
            out[i] *= v.getEntry(i);
        }
        return new ArrayRealVector(out, false);
    }
}","public void test128128() throws Throwable {
    int int0 = (-1968);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-1968), (-1968), 1731.65572417);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((-1968), (-1968), (-1968));
    Sinc sinc0 = new Sinc(true);
    openMapRealVector1.mapToSelf(sinc0);
    double[] doubleArray0 = new double[1];
    openMapRealVector1.isDefaultValue(1.0E-12);
    openMapRealVector0.set(982.8);
    doubleArray0[0] = 1.0E-12;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, doubleArray0);
    sinc0.value((-1968));
    openMapRealVector1.equals(openMapRealVector0);
    RealVectorChangingVisitor realVectorChangingVisitor0 = mock(RealVectorChangingVisitor.class, new ViolatedAssumptionAnswer());
    // Undeclared exception!
    try {
        arrayRealVector0.ebeMultiply(openMapRealVector0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 2 != -1,968
        //
        verifyException(""org.apache.commons.math3.linear.ArrayRealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getL1Distance(RealVector v) {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return getL1Distance((OpenMapRealVector) v);
    } else {
        return super.getL1Distance(v);
    }
}","public void test129129() throws Throwable {
    int int0 = 2795;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(2795, 2795);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((RealVector) openMapRealVector0);
    OpenMapRealVector openMapRealVector2 = openMapRealVector1.add(openMapRealVector0);
    openMapRealVector1.append((RealVector) openMapRealVector0);
    // Undeclared exception!
    openMapRealVector0.getL1Distance((RealVector) openMapRealVector2);
}","/**
 * {@inheritDoc}
 */"
"@Override
public void setSubVector(int index, RealVector v) {
    checkIndex(index);
    checkIndex(index + v.getDimension() - 1);
    for (int i = 0; i < v.getDimension(); i++) {
        setEntry(i + index, v.getEntry(i));
    }
}","public void test130130() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 1477.7111623;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 1477.7111623);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0);
    openMapRealVector0.getL1Distance(openMapRealVector1);
    OpenMapRealVector openMapRealVector2 = openMapRealVector1.ebeMultiply(openMapRealVector0);
    openMapRealVector2.sparseIterator();
    openMapRealVector1.add((RealVector) openMapRealVector0);
    int int0 = 2146375643;
    // Undeclared exception!
    try {
        openMapRealVector0.setSubVector(2146375643, openMapRealVector2);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (2,146,375,643)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public OpenMapRealVector mapAdd(double d) {
    return copy().mapAddToSelf(d);
}","public void test131131() throws Throwable {
    int int0 = 33;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(33, (-901));
    openMapRealVector0.isDefaultValue(2.5440783580508475);
    double double0 = 1766.2;
    // Undeclared exception!
    try {
        openMapRealVector0.mapAdd((-901));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    long temp;
    temp = Double.doubleToLongBits(epsilon);
    result = prime * result + (int) (temp ^ (temp >>> 32));
    result = prime * result + virtualSize;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        temp = Double.doubleToLongBits(iter.value());
        result = prime * result + (int) (temp ^ (temp >> 32));
    }
    return result;
}","public void test132132() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-1338));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0);
    openMapRealVector0.getL1Distance(openMapRealVector1);
    OpenMapRealVector openMapRealVector2 = new OpenMapRealVector((RealVector) openMapRealVector1);
    openMapRealVector2.getDimension();
    openMapRealVector1.dotProduct((RealVector) openMapRealVector0);
    OpenMapRealVector openMapRealVector3 = openMapRealVector2.mapAdd(0.0);
    openMapRealVector1.projection(openMapRealVector0);
    openMapRealVector1.equals(openMapRealVector3);
    openMapRealVector3.getDistance(openMapRealVector2);
    openMapRealVector2.hashCode();
}","/**
 * {@inheritDoc}
 * Implementation Note: This works on exact values, and as a result
 * it is possible for {@code a.subtract(b)} to be the zero vector, while
 * {@code a.hashCode() != b.hashCode()}.
 */"
"public OpenMapRealVector(int dimension, int expectedSize) {
    this(dimension, expectedSize, DEFAULT_ZERO_TOLERANCE);
}","public void test133133() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = 0.0;
    doubleArray0[1] = (-132.09534419319735);
    doubleArray0[2] = (-170.24);
    doubleArray0[1] = 6.283185307179586;
    doubleArray0[4] = 0.0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((RealVector) openMapRealVector0);
    RealVectorPreservingVisitor realVectorPreservingVisitor0 = mock(RealVectorPreservingVisitor.class, new ViolatedAssumptionAnswer());
    doReturn((-623.7)).when(realVectorPreservingVisitor0).end();
    openMapRealVector1.walkInOptimizedOrder(realVectorPreservingVisitor0);
    OpenMapRealVector openMapRealVector2 = new OpenMapRealVector(openMapRealVector1);
    openMapRealVector2.dotProduct((RealVector) openMapRealVector1);
    openMapRealVector0.unitVector();
    OpenMapRealVector openMapRealVector3 = null;
    try {
        openMapRealVector3 = new OpenMapRealVector(1241, 2145598059);
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.util.OpenIntToDoubleHashMap"", e);
    }
}","/**
 * Build a vector with known the sparseness (for advanced use only).
 *
 * @param dimension Size of the vector.
 * @param expectedSize The expected number of non-zero entries.
 */"
"public OpenMapRealVector add(OpenMapRealVector v) {
    checkVectorDimensions(v.getDimension());
    boolean copyThis = entries.size() > v.entries.size();
    OpenMapRealVector res = copyThis ? this.copy() : v.copy();
    Iterator iter = copyThis ? v.entries.iterator() : entries.iterator();
    OpenIntToDoubleHashMap randomAccess = copyThis ? entries : v.entries;
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (randomAccess.containsKey(key)) {
            res.setEntry(key, randomAccess.get(key) + iter.value());
        } else {
            res.setEntry(key, iter.value());
        }
    }
    return res;
}","public void test134134() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(31, 32);
    Double[] doubleArray0 = new Double[6];
    doubleArray0[0] = (Double) 1.0E-12;
    doubleArray0[1] = (Double) 1.0E-12;
    doubleArray0[2] = (Double) 1.0E-12;
    doubleArray0[3] = (Double) 1.0E-12;
    doubleArray0[4] = (Double) 1.0E-12;
    doubleArray0[5] = (Double) 1.0E-12;
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0);
    openMapRealVector0.equals(openMapRealVector1);
    // Undeclared exception!
    try {
        openMapRealVector1.add(openMapRealVector0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 6 != 31
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * Optimized method to add two OpenMapRealVectors.
 * It copies the larger vector, then iterates over the smaller.
 *
 * @param v Vector to add.
 * @return the sum of {@code this} and {@code v}.
 * @throws org.apache.commons.math3.exception.DimensionMismatchException
 * if the dimensions do not match.
 */"
"public double walkInOptimizedOrder(final RealVectorChangingVisitor visitor) {
    return walkInDefaultOrder(visitor);
}","public void test135135() throws Throwable {
    int int0 = 0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0, 0);
    openMapRealVector0.hashCode();
    OpenMapRealVector openMapRealVector2 = openMapRealVector1.append((RealVector) openMapRealVector0);
    RealVectorPreservingVisitor realVectorPreservingVisitor0 = mock(RealVectorPreservingVisitor.class, new ViolatedAssumptionAnswer());
    doReturn((-185.87)).when(realVectorPreservingVisitor0).end();
    openMapRealVector1.walkInDefaultOrder(realVectorPreservingVisitor0);
    openMapRealVector1.equals(openMapRealVector1);
    openMapRealVector1.getMaxIndex();
    openMapRealVector2.mapAdd((-1));
    openMapRealVector1.mapDivideToSelf(1.0E-12);
    OpenMapRealVector openMapRealVector3 = openMapRealVector1.append(585.50939104);
    // Undeclared exception!
    try {
        openMapRealVector3.walkInOptimizedOrder((RealVectorChangingVisitor) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * Visits (and possibly alters) all entries of this vector in optimized
 * order. The order in which the entries are visited is selected so as to
 * lead to the most efficient implementation; it might depend on the
 * concrete implementation of this abstract class.
 *
 * @param visitor the visitor to be used to process the entries of this
 * vector
 * @return the value returned by {@link RealVectorChangingVisitor#end()}
 * at the end of the walk
 */"
"@Override
public double[] toArray() {
    double[] res = new double[virtualSize];
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res[iter.key()] = iter.value();
    }
    return res;
}","public void test136136() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-1033), (-1033));
    RealVector realVector0 = RealVector.unmodifiableRealVector(openMapRealVector0);
    openMapRealVector0.subtract(realVector0);
    // Undeclared exception!
    try {
        openMapRealVector0.toArray();
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.linear.OpenMapRealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public void setSubVector(int index, RealVector v) {
    checkIndex(index);
    checkIndex(index + v.getDimension() - 1);
    for (int i = 0; i < v.getDimension(); i++) {
        setEntry(i + index, v.getEntry(i));
    }
}","public void test137137() throws Throwable {
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = 0.0;
    doubleArray0[1] = 587.63959690005;
    doubleArray0[2] = (-1.0);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0, 375);
    OpenMapRealVector openMapRealVector2 = new OpenMapRealVector((RealVector) openMapRealVector1);
    openMapRealVector2.setSubVector(375, openMapRealVector0);
}","/**
 * {@inheritDoc}
 */"
"public OpenMapRealVector(RealVector v) {
    virtualSize = v.getDimension();
    entries = new OpenIntToDoubleHashMap(0.0);
    epsilon = DEFAULT_ZERO_TOLERANCE;
    for (int key = 0; key < virtualSize; key++) {
        double value = v.getEntry(key);
        if (!isDefaultValue(value)) {
            entries.put(key, value);
        }
    }
}","public void test138138() throws Throwable {
    int int0 = (-3137);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(2808, (-3137));
    OpenMapRealVector openMapRealVector1 = null;
    try {
        openMapRealVector1 = new OpenMapRealVector((RealVector) openMapRealVector0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Generic copy constructor.
 *
 * @param v Instance to copy from.
 */"
"@Override
public ArrayRealVector ebeMultiply(RealVector v) {
    if (v instanceof ArrayRealVector) {
        final double[] vData = ((ArrayRealVector) v).data;
        final int dim = vData.length;
        checkVectorDimensions(dim);
        ArrayRealVector result = new ArrayRealVector(dim);
        double[] resultData = result.data;
        for (int i = 0; i < dim; i++) {
            resultData[i] = data[i] * vData[i];
        }
        return result;
    } else {
        checkVectorDimensions(v);
        double[] out = data.clone();
        for (int i = 0; i < data.length; i++) {
            out[i] *= v.getEntry(i);
        }
        return new ArrayRealVector(out, false);
    }
}","public void test139139() throws Throwable {
    int int0 = (-1968);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-1968), (-1968), (-1968));
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((-1968));
    Sinc sinc0 = new Sinc(true);
    openMapRealVector1.mapToSelf(sinc0);
    openMapRealVector0.getLInfDistance(openMapRealVector1);
    double[] doubleArray0 = new double[1];
    openMapRealVector1.isDefaultValue(0.0);
    openMapRealVector0.set(982.8);
    doubleArray0[0] = 1.0E-12;
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray0, doubleArray0);
    openMapRealVector1.equals(openMapRealVector0);
    RealVectorChangingVisitor realVectorChangingVisitor0 = mock(RealVectorChangingVisitor.class, new ViolatedAssumptionAnswer());
    doReturn((-968.5766984261)).when(realVectorChangingVisitor0).end();
    openMapRealVector1.walkInOptimizedOrder(realVectorChangingVisitor0);
    // Undeclared exception!
    try {
        arrayRealVector0.ebeMultiply(openMapRealVector0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 2 != -1,968
        //
        verifyException(""org.apache.commons.math3.linear.ArrayRealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public OpenMapRealVector(OpenMapRealVector v) {
    virtualSize = v.getDimension();
    entries = new OpenIntToDoubleHashMap(v.getEntries());
    epsilon = v.epsilon;
}","public void test140140() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = 0.0;
    doubleArray0[1] = (-132.09534419319735);
    doubleArray0[2] = (-170.24);
    doubleArray0[3] = 6.283185307179586;
    doubleArray0[4] = 2.5811686515808105;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((RealVector) openMapRealVector0);
    RealVectorPreservingVisitor realVectorPreservingVisitor0 = mock(RealVectorPreservingVisitor.class, new ViolatedAssumptionAnswer());
    doReturn(3.775134371775124E-11).when(realVectorPreservingVisitor0).end();
    openMapRealVector1.walkInOptimizedOrder(realVectorPreservingVisitor0);
    OpenMapRealVector openMapRealVector2 = new OpenMapRealVector(openMapRealVector1);
    openMapRealVector2.set(289.80654792);
    openMapRealVector2.dotProduct((RealVector) openMapRealVector1);
    OpenMapRealVector openMapRealVector3 = new OpenMapRealVector(openMapRealVector2);
}","/**
 * Copy constructor.
 *
 * @param v Instance to copy from.
 */"
"@Override
public double getEntry(int index) {
    checkIndex(index);
    return entries.get(index);
}","public void test141141() throws Throwable {
    Double[] doubleArray0 = new Double[4];
    Double double0 = new Double((-968.5766984261));
    doubleArray0[0] = double0;
    Double double1 = new Double((-968.5766984261));
    doubleArray0[1] = double1;
    Double double2 = new Double(0.0);
    Double.min(0.0, 770.181);
    Double.max(0.0, 0.0);
    doubleArray0[2] = double2;
    Double double3 = new Double(0.0);
    doubleArray0[3] = double3;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (double) doubleArray0[1]);
    openMapRealVector0.iterator();
    openMapRealVector0.iterator();
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0);
    openMapRealVector0.hashCode();
    OpenMapRealVector openMapRealVector2 = openMapRealVector0.mapAdd(0.0);
    OpenMapRealVector openMapRealVector3 = openMapRealVector1.mapAdd(1.0E-12);
    openMapRealVector1.isInfinite();
    Double.sum(0.0, (-1456.2699882864913));
    OpenIntToDoubleHashMap.Iterator openIntToDoubleHashMap_Iterator0 = mock(OpenIntToDoubleHashMap.Iterator.class, new ViolatedAssumptionAnswer());
    doReturn(2455).when(openIntToDoubleHashMap_Iterator0).key();
    doReturn(0.0).when(openIntToDoubleHashMap_Iterator0).value();
    OpenMapRealVector.OpenMapEntry openMapRealVector_OpenMapEntry0 = openMapRealVector2.new OpenMapEntry(openIntToDoubleHashMap_Iterator0);
    openMapRealVector_OpenMapEntry0.getValue();
    openMapRealVector1.ebeDivide(openMapRealVector2);
    openMapRealVector2.unitVector();
    openMapRealVector_OpenMapEntry0.setValue(0.0);
    openMapRealVector3.getLInfDistance(openMapRealVector2);
    // Undeclared exception!
    try {
        openMapRealVector2.getEntry((-1423));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (-1,423)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double getDistance(OpenMapRealVector v) {
    Iterator iter = entries.iterator();
    double res = 0;
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        double delta;
        delta = iter.value() - v.getEntry(key);
        res += delta * delta;
    }
    iter = v.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (!entries.containsKey(key)) {
            final double value = iter.value();
            res += value * value;
        }
    }
    return FastMath.sqrt(res);
}","public void test142142() throws Throwable {
    int int0 = (-3527);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector((-3527), (-3527));
    double[] doubleArray0 = new double[8];
    doubleArray0[0] = (double) (-3527);
    doubleArray0[1] = (double) (-3527);
    doubleArray0[2] = 1.0E-12;
    doubleArray0[3] = (double) (-3527);
    doubleArray0[4] = 1.0;
    doubleArray0[5] = (double) (-3527);
    doubleArray0[6] = (-1093.0);
    openMapRealVector0.copy();
    doubleArray0[7] = (double) (-3527);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0, 1.0);
    openMapRealVector1.mapMultiply((-1239.113300407071));
    // Undeclared exception!
    try {
        openMapRealVector0.getDistance(openMapRealVector1);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Optimized method to compute distance.
 *
 * @param v Vector to compute distance to.
 * @return the distance from {@code this} and {@code v}.
 * @throws org.apache.commons.math3.exception.DimensionMismatchException
 * if the dimensions do not match.
 */"
"@Override
public double getDistance(RealVector v) {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return getDistance((OpenMapRealVector) v);
    } else {
        return super.getDistance(v);
    }
}","public void test143143() throws Throwable {
    int int0 = 672366247;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(672366247, 672366247);
    // Undeclared exception!
    try {
        openMapRealVector0.getDistance((RealVector) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.linear.OpenMapRealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getDistance(RealVector v) {
    checkVectorDimensions(v.getDimension());
    if (v instanceof OpenMapRealVector) {
        return getDistance((OpenMapRealVector) v);
    } else {
        return super.getDistance(v);
    }
}","public void test144144() throws Throwable {
    Double[] doubleArray0 = new Double[7];
    Double double0 = new Double(2.0);
    doubleArray0[0] = double0;
    Double double1 = new Double(9.253781621373885E29);
    doubleArray0[1] = double1;
    Double.max(585.50939104, (double) doubleArray0[0]);
    Double double2 = new Double(0.0);
    doubleArray0[2] = double2;
    Double double3 = new Double((double) doubleArray0[1]);
    doubleArray0[3] = double3;
    Double double4 = new Double(0.0);
    doubleArray0[4] = double4;
    Double double5 = new Double(1328.5);
    doubleArray0[5] = double5;
    Double double6 = new Double((double) doubleArray0[0]);
    doubleArray0[6] = double6;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector2 = openMapRealVector0.append(openMapRealVector1);
    openMapRealVector0.equals(openMapRealVector1);
    // Undeclared exception!
    try {
        openMapRealVector1.getDistance((RealVector) openMapRealVector2);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 7 != 14
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public double[] toArray() {
    double[] res = new double[virtualSize];
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res[iter.key()] = iter.value();
    }
    return res;
}","public void test145145() throws Throwable {
    Double[] doubleArray0 = new Double[7];
    Double double0 = new Double(2.0);
    doubleArray0[0] = double0;
    Double double1 = new Double(9.253781621373885E29);
    doubleArray0[1] = double1;
    Double double2 = new Double(0.0);
    doubleArray0[2] = double2;
    Double double3 = new Double((double) doubleArray0[1]);
    doubleArray0[3] = double3;
    Double double4 = new Double(0.0);
    doubleArray0[4] = double4;
    Double double5 = new Double(1328.5);
    doubleArray0[5] = double5;
    Double double6 = new Double((double) doubleArray0[0]);
    doubleArray0[6] = double6;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector2 = openMapRealVector0.append(openMapRealVector1);
    openMapRealVector1.getL1Distance(openMapRealVector2);
    openMapRealVector0.toArray();
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getEntry(int index) {
    checkIndex(index);
    return entries.get(index);
}","public void test146146() throws Throwable {
    Double[] doubleArray0 = new Double[4];
    Double double0 = new Double((-968.5766984261));
    doubleArray0[0] = double0;
    Double double1 = new Double((-968.5766984261));
    doubleArray0[1] = double1;
    Double double2 = new Double(0.0);
    Double.min(0.0, 770.181);
    Double.max(0.0, 0.0);
    doubleArray0[2] = double2;
    Double double3 = new Double(0.0);
    doubleArray0[3] = double3;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (double) doubleArray0[1]);
    openMapRealVector0.iterator();
    openMapRealVector0.iterator();
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0);
    openMapRealVector0.hashCode();
    openMapRealVector1.combine(0.0, 938140.8207340033, openMapRealVector0);
    OpenMapRealVector openMapRealVector2 = openMapRealVector0.mapAdd(0.0);
    openMapRealVector1.mapAdd(1.0E-12);
    openMapRealVector1.isInfinite();
    Double.sum(0.0, (-1456.2699882864913));
    OpenIntToDoubleHashMap.Iterator openIntToDoubleHashMap_Iterator0 = mock(OpenIntToDoubleHashMap.Iterator.class, new ViolatedAssumptionAnswer());
    doReturn(2455).when(openIntToDoubleHashMap_Iterator0).key();
    OpenMapRealVector.OpenMapEntry openMapRealVector_OpenMapEntry0 = openMapRealVector2.new OpenMapEntry(openIntToDoubleHashMap_Iterator0);
    OpenMapRealVector openMapRealVector3 = openMapRealVector1.ebeDivide(openMapRealVector2);
    OpenMapRealVector openMapRealVector4 = openMapRealVector2.unitVector();
    openMapRealVector_OpenMapEntry0.setValue(0.0);
    openMapRealVector0.dotProduct(openMapRealVector2);
    openMapRealVector4.getL1Distance((RealVector) openMapRealVector3);
    // Undeclared exception!
    try {
        openMapRealVector2.getEntry((-1423));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (-1,423)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"private double getLInfDistance(OpenMapRealVector v) {
    double max = 0;
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        double delta = FastMath.abs(iter.value() - v.getEntry(iter.key()));
        if (delta > max) {
            max = delta;
        }
    }
    iter = v.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (!entries.containsKey(key)) {
            if (iter.value() > max) {
                max = iter.value();
            }
        }
    }
    return max;
}","public void test147147() throws Throwable {
    int int0 = 2795;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(2795, 2795, 2795.0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(2795);
    Sinc sinc0 = new Sinc(true);
    openMapRealVector1.mapToSelf(sinc0);
    // Undeclared exception!
    openMapRealVector0.getLInfDistance(openMapRealVector1);
}","/**
 * Optimized method to compute LInfDistance.
 *
 * @param v Vector to compute distance from.
 * @return the LInfDistance.
 */"
"@Override
public OpenMapRealVector append(double d) {
    OpenMapRealVector res = new OpenMapRealVector(this, 1);
    res.setEntry(virtualSize, d);
    return res;
}","public void test148148() throws Throwable {
    int int0 = 2795;
    int int1 = (-3137);
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(2795, (-3137));
    // Undeclared exception!
    try {
        openMapRealVector0.append((double) 2795);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public OpenMapRealVector unitVector() {
    OpenMapRealVector res = copy();
    res.unitize();
    return res;
}","public void test149149() throws Throwable {
    Double[] doubleArray0 = new Double[7];
    Double double0 = new Double((-1.0));
    doubleArray0[0] = double0;
    Double double1 = new Double((double) doubleArray0[0]);
    doubleArray0[1] = double1;
    Double double2 = new Double(1.0);
    doubleArray0[2] = double2;
    Double double3 = new Double(310.66427041);
    doubleArray0[3] = double3;
    Double double4 = new Double((-1177.585));
    doubleArray0[4] = double4;
    Double double5 = new Double((double) doubleArray0[1]);
    doubleArray0[5] = double5;
    Double.max((double) doubleArray0[3], 2568.2101);
    Double double6 = new Double((double) doubleArray0[3]);
    doubleArray0[6] = double6;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(doubleArray0);
    openMapRealVector1.unitize();
    OpenMapRealVector openMapRealVector2 = openMapRealVector0.subtract(openMapRealVector1);
    Double.min(2568.2101, 1.0E-12);
    openMapRealVector1.mapSubtractToSelf((double) doubleArray0[6]);
    OpenMapRealVector openMapRealVector3 = new OpenMapRealVector(doubleArray0, 132.09534419319735);
    Double.min(566.855241899, (-1.0));
    openMapRealVector0.getLInfDistance(openMapRealVector3);
    OpenMapRealVector openMapRealVector4 = openMapRealVector2.add(openMapRealVector3);
    openMapRealVector4.getDistance(openMapRealVector3);
    openMapRealVector0.getLInfDistance(openMapRealVector1);
    openMapRealVector1.getSparsity();
    openMapRealVector1.unitVector();
}","/**
 * {@inheritDoc}
 */"
"public double getDistance(OpenMapRealVector v) {
    Iterator iter = entries.iterator();
    double res = 0;
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        double delta;
        delta = iter.value() - v.getEntry(key);
        res += delta * delta;
    }
    iter = v.getEntries().iterator();
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (!entries.containsKey(key)) {
            final double value = iter.value();
            res += value * value;
        }
    }
    return FastMath.sqrt(res);
}","public void test150150() throws Throwable {
    int int0 = 2795;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(2795, 2795);
    int int1 = 929;
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((RealVector) openMapRealVector0);
    OpenMapRealVector openMapRealVector2 = openMapRealVector1.add(openMapRealVector0);
    RealVectorChangingVisitor realVectorChangingVisitor0 = mock(RealVectorChangingVisitor.class, new ViolatedAssumptionAnswer());
    doReturn(1.0E-12).when(realVectorChangingVisitor0).end();
    doReturn((double) 929, (double) 929, (double) 2795, 1.0, 1.0).when(realVectorChangingVisitor0).visit(anyInt(), anyDouble());
    openMapRealVector0.walkInOptimizedOrder(realVectorChangingVisitor0);
    openMapRealVector2.set(2795);
    openMapRealVector2.mapDivideToSelf((-1193.745234));
    int int2 = 23;
    // Undeclared exception!
    openMapRealVector1.getDistance(openMapRealVector2);
}","/**
 * Optimized method to compute distance.
 *
 * @param v Vector to compute distance to.
 * @return the distance from {@code this} and {@code v}.
 * @throws org.apache.commons.math3.exception.DimensionMismatchException
 * if the dimensions do not match.
 */"
"@Override
public double[] toArray() {
    double[] res = new double[virtualSize];
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res[iter.key()] = iter.value();
    }
    return res;
}","public void test151151() throws Throwable {
    int int0 = 2795;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(2795, 2795);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((RealVector) openMapRealVector0);
    OpenMapRealVector openMapRealVector2 = openMapRealVector1.add(openMapRealVector0);
    RealVectorChangingVisitor realVectorChangingVisitor0 = mock(RealVectorChangingVisitor.class, new ViolatedAssumptionAnswer());
    doReturn((double) 929).when(realVectorChangingVisitor0).end();
    doReturn(1.0E-12, (-1.0), (double) 2795, (-1.0), (-1.0)).when(realVectorChangingVisitor0).visit(anyInt(), anyDouble());
    openMapRealVector0.walkInOptimizedOrder(realVectorChangingVisitor0);
    openMapRealVector2.set(2795);
    int int1 = 23;
    openMapRealVector1.getDistance(openMapRealVector2);
    // Undeclared exception!
    openMapRealVector2.toArray();
}","/**
 * {@inheritDoc}
 */"
"@Override
public double dotProduct(RealVector v) {
    if (v instanceof OpenMapRealVector) {
        return dotProduct((OpenMapRealVector) v);
    } else {
        return super.dotProduct(v);
    }
}","public void test152152() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(1962);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0);
    // Undeclared exception!
    try {
        openMapRealVector0.dotProduct((RealVector) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public OpenMapRealVector ebeDivide(RealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = new OpenMapRealVector(this);
    /*
         * MATH-803: it is not sufficient to loop through non zero entries of
         * this only. Indeed, if this[i] = 0d and v[i] = 0d, then
         * this[i] / v[i] = NaN, and not 0d.
         */
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));
    }
    return res;
}","public void test153153() throws Throwable {
    int int0 = 2795;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(2795, 2795);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((RealVector) openMapRealVector0);
    OpenMapRealVector openMapRealVector2 = openMapRealVector1.add(openMapRealVector0);
    RealVectorChangingVisitor realVectorChangingVisitor0 = mock(RealVectorChangingVisitor.class, new ViolatedAssumptionAnswer());
    doReturn(1.0E-12).when(realVectorChangingVisitor0).end();
    doReturn((double) 929, (-2454.879), 2.5811686515808105, (double) 929, 1.0E-12).when(realVectorChangingVisitor0).visit(anyInt(), anyDouble());
    openMapRealVector0.walkInOptimizedOrder(realVectorChangingVisitor0);
    openMapRealVector2.set(2795);
    int int1 = 23;
    openMapRealVector1.append(1.0E-12);
    // Undeclared exception!
    openMapRealVector0.ebeDivide(openMapRealVector2);
}","/**
 * {@inheritDoc}
 */"
"@Override
public OpenMapRealVector ebeMultiply(RealVector v) {
    checkVectorDimensions(v.getDimension());
    OpenMapRealVector res = new OpenMapRealVector(this);
    Iterator iter = entries.iterator();
    while (iter.hasNext()) {
        iter.advance();
        res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));
    }
    /*
         * MATH-803: the above loop assumes that 0d * x  = 0d for any double x,
         * which allows to consider only the non-zero entries of this. However,
         * this fails if this[i] == 0d and (v[i] = NaN or v[i] = Infinity).
         *
         * These special cases are handled below.
         */
    return res;
}","public void test154154() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = 0.0;
    doubleArray0[1] = (-132.09534419319735);
    doubleArray0[3] = 6.283185307179586;
    doubleArray0[4] = 2.5811686515808105;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector((RealVector) openMapRealVector0);
    RealVectorPreservingVisitor realVectorPreservingVisitor0 = mock(RealVectorPreservingVisitor.class, new ViolatedAssumptionAnswer());
    doReturn(3.775134371775124E-11).when(realVectorPreservingVisitor0).end();
    openMapRealVector1.walkInOptimizedOrder(realVectorPreservingVisitor0);
    OpenMapRealVector openMapRealVector2 = new OpenMapRealVector(openMapRealVector1);
    openMapRealVector2.set(289.80654792);
    openMapRealVector2.dotProduct((RealVector) openMapRealVector1);
    OpenMapRealVector openMapRealVector3 = new OpenMapRealVector(openMapRealVector2);
    openMapRealVector0.getDistance(openMapRealVector3);
    openMapRealVector1.ebeDivide(openMapRealVector2);
    double[] doubleArray1 = new double[4];
    doubleArray1[0] = 289.80654792;
    doubleArray1[1] = 3.775134371775124E-11;
    doubleArray1[2] = 2.5811686515808105;
    doubleArray1[3] = (-170.24);
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(doubleArray1);
    openMapRealVector1.subtract(openMapRealVector3);
    arrayRealVector0.append((-1.5536658521931418E118));
    // Undeclared exception!
    try {
        openMapRealVector1.ebeMultiply(arrayRealVector0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 5 != 4
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public void setEntry(int index, double value) {
    checkIndex(index);
    if (!isDefaultValue(value)) {
        entries.put(index, value);
    } else if (entries.containsKey(index)) {
        entries.remove(index);
    }
}","public void test155155() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = (-837.1);
    doubleArray0[1] = 2239.0;
    doubleArray0[2] = 1750.6568849334;
    doubleArray0[3] = 2.5635838508605957;
    doubleArray0[4] = 0.006432712288963109;
    doubleArray0[5] = 1.4754809136835937E-8;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, 2239.0);
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0, (-4024));
    openMapRealVector1.getMaxValue();
    OpenMapRealVector openMapRealVector2 = new OpenMapRealVector((RealVector) openMapRealVector1);
    openMapRealVector0.hashCode();
    openMapRealVector2.mapAdd(548.241761);
    openMapRealVector1.mapAddToSelf(972.023990461);
    openMapRealVector0.append(972.023990461);
    // Undeclared exception!
    try {
        openMapRealVector2.setEntry((-2163), 0.006432712288963109);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (-2,163)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public double dotProduct(OpenMapRealVector v) {
    checkVectorDimensions(v.getDimension());
    boolean thisIsSmaller = entries.size() < v.entries.size();
    Iterator iter = thisIsSmaller ? entries.iterator() : v.entries.iterator();
    OpenIntToDoubleHashMap larger = thisIsSmaller ? v.entries : entries;
    double d = 0;
    while (iter.hasNext()) {
        iter.advance();
        d += iter.value() * larger.get(iter.key());
    }
    return d;
}","public void test156156() throws Throwable {
    int int0 = 2765;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(2765);
    OpenMapRealVector openMapRealVector1 = null;
    // Undeclared exception!
    try {
        openMapRealVector0.dotProduct((OpenMapRealVector) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.linear.OpenMapRealVector"", e);
    }
}","/**
 * Optimized method to compute the dot product with an OpenMapRealVector.
 * It iterates over the smallest of the two.
 *
 * @param v Cector to compute the dot product with.
 * @return the dot product of {@code this} and {@code v}.
 * @throws org.apache.commons.math3.exception.DimensionMismatchException
 * if the dimensions do not match.
 */"
"@Override
public OpenMapRealVector append(RealVector v) {
    if (v instanceof OpenMapRealVector) {
        return append((OpenMapRealVector) v);
    } else {
        final OpenMapRealVector res = new OpenMapRealVector(this, v.getDimension());
        for (int i = 0; i < v.getDimension(); i++) {
            res.setEntry(i + virtualSize, v.getEntry(i));
        }
        return res;
    }
}","public void test157157() throws Throwable {
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(3392, 3392);
    OpenMapRealVector openMapRealVector1 = openMapRealVector0.mapAdd(3392);
    // Undeclared exception!
    openMapRealVector0.append((RealVector) openMapRealVector1);
}","/**
 * {@inheritDoc}
 */"
"@Override
public void setSubVector(int index, RealVector v) {
    checkIndex(index);
    checkIndex(index + v.getDimension() - 1);
    for (int i = 0; i < v.getDimension(); i++) {
        setEntry(i + index, v.getEntry(i));
    }
}","public void test158158() throws Throwable {
    int int0 = 2137567749;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(2137567749, 3959, 3959);
    RealVectorChangingVisitor realVectorChangingVisitor0 = mock(RealVectorChangingVisitor.class, new ViolatedAssumptionAnswer());
    // Undeclared exception!
    try {
        openMapRealVector0.setSubVector(3959, (RealVector) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.linear.OpenMapRealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public RealVector projection(RealVector v) {
    checkVectorDimensions(v.getDimension());
    return v.mapMultiply(dotProduct(v) / v.dotProduct(v));
}","public void test159159() throws Throwable {
    int int0 = 0;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(1709, 0);
    openMapRealVector0.isDefaultValue(0);
    openMapRealVector0.getNorm();
    ArrayRealVector arrayRealVector0 = new ArrayRealVector(1709);
    int int1 = 750;
    arrayRealVector0.setEntry(750, 1709);
    // Undeclared exception!
    try {
        openMapRealVector0.projection((RealVector) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.linear.OpenMapRealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public OpenMapRealVector add(OpenMapRealVector v) {
    checkVectorDimensions(v.getDimension());
    boolean copyThis = entries.size() > v.entries.size();
    OpenMapRealVector res = copyThis ? this.copy() : v.copy();
    Iterator iter = copyThis ? v.entries.iterator() : entries.iterator();
    OpenIntToDoubleHashMap randomAccess = copyThis ? entries : v.entries;
    while (iter.hasNext()) {
        iter.advance();
        int key = iter.key();
        if (randomAccess.containsKey(key)) {
            res.setEntry(key, randomAccess.get(key) + iter.value());
        } else {
            res.setEntry(key, iter.value());
        }
    }
    return res;
}","public void test160160() throws Throwable {
    int int0 = 2795;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(2795, 2795);
    // Undeclared exception!
    try {
        openMapRealVector0.add((OpenMapRealVector) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.linear.OpenMapRealVector"", e);
    }
}","/**
 * Optimized method to add two OpenMapRealVectors.
 * It copies the larger vector, then iterates over the smaller.
 *
 * @param v Vector to add.
 * @return the sum of {@code this} and {@code v}.
 * @throws org.apache.commons.math3.exception.DimensionMismatchException
 * if the dimensions do not match.
 */"
"@Override
public OpenMapRealVector append(RealVector v) {
    if (v instanceof OpenMapRealVector) {
        return append((OpenMapRealVector) v);
    } else {
        final OpenMapRealVector res = new OpenMapRealVector(this, v.getDimension());
        for (int i = 0; i < v.getDimension(); i++) {
            res.setEntry(i + virtualSize, v.getEntry(i));
        }
        return res;
    }
}","public void test161161() throws Throwable {
    Double[] doubleArray0 = new Double[4];
    Double double0 = new Double((-968.5766984261));
    doubleArray0[0] = double0;
    Double double1 = new Double((-968.5766984261));
    doubleArray0[1] = double1;
    Double double2 = new Double(0.0);
    Double.min(0.0, 770.181);
    Double.max(0.0, 0.0);
    doubleArray0[2] = double2;
    Double.isFinite(0.008906522886064439);
    Double double3 = new Double(0.0);
    doubleArray0[3] = double3;
    OpenMapRealVector openMapRealVector0 = new OpenMapRealVector(doubleArray0, (double) doubleArray0[1]);
    openMapRealVector0.iterator();
    openMapRealVector0.iterator();
    OpenMapRealVector openMapRealVector1 = new OpenMapRealVector(openMapRealVector0);
    openMapRealVector0.hashCode();
    OpenMapRealVector openMapRealVector2 = openMapRealVector0.mapAdd(0.0);
    openMapRealVector1.mapAdd(1.0E-12);
    openMapRealVector1.isInfinite();
    Double.sum(0.0, (-1456.2699882864913));
    OpenIntToDoubleHashMap.Iterator openIntToDoubleHashMap_Iterator0 = mock(OpenIntToDoubleHashMap.Iterator.class, new ViolatedAssumptionAnswer());
    doReturn(2455).when(openIntToDoubleHashMap_Iterator0).key();
    OpenMapRealVector.OpenMapEntry openMapRealVector_OpenMapEntry0 = openMapRealVector2.new OpenMapEntry(openIntToDoubleHashMap_Iterator0);
    openMapRealVector1.ebeDivide(openMapRealVector2);
    OpenMapRealVector openMapRealVector3 = openMapRealVector2.unitVector();
    openMapRealVector3.isNaN();
    openMapRealVector_OpenMapEntry0.setValue(0.0);
    // Undeclared exception!
    try {
        openMapRealVector1.append((RealVector) openMapRealVector2);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // index (2,459)
        //
        verifyException(""org.apache.commons.math3.linear.RealVector"", e);
    }
}","/**
 * {@inheritDoc}
 */"
