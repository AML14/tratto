focal_method,test_prefix,docstring
"public final int getJacobianEvaluations() {
    return jacobianEvaluations;
}","public void test000() throws Throwable {
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    WeightedMeasurement weightedMeasurement0 = mock(WeightedMeasurement.class, new ViolatedAssumptionAnswer());
    doReturn(0.0).when(weightedMeasurement0).getPartial(any(org.apache.commons.math.estimation.EstimatedParameter.class));
    doReturn(0.0).when(weightedMeasurement0).getResidual();
    doReturn(0.0, (-1.0)).when(weightedMeasurement0).getWeight();
    EstimatedParameter estimatedParameter0 = new EstimatedParameter(""LU decomposition requires that the matrix be square."", 1.0);
    simpleEstimationProblem0.addParameter(estimatedParameter0);
    simpleEstimationProblem0.addMeasurement(weightedMeasurement0);
    WeightedMeasurement weightedMeasurement1 = mock(WeightedMeasurement.class, new ViolatedAssumptionAnswer());
    doReturn(0.0).when(weightedMeasurement1).getPartial(any(org.apache.commons.math.estimation.EstimatedParameter.class));
    doReturn(0.0).when(weightedMeasurement1).getResidual();
    doReturn(1590.261196097777, Double.POSITIVE_INFINITY).when(weightedMeasurement1).getWeight();
    simpleEstimationProblem0.addMeasurement(weightedMeasurement1);
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    levenbergMarquardtEstimator0.initializeEstimate(simpleEstimationProblem0);
    levenbergMarquardtEstimator0.guessParametersErrors(simpleEstimationProblem0);
    assertEquals(1, levenbergMarquardtEstimator0.getJacobianEvaluations());
}","/**
 * Get the number of jacobian evaluations.
 *
 * @return number of jacobian evaluations
 */"
"public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException {
    int m = problem.getMeasurements().length;
    int p = problem.getAllParameters().length;
    if (m <= p) {
        throw new EstimationException(""no degrees of freedom ({0} measurements, {1} parameters)"", new Object[] { new Integer(m), new Integer(p) });
    }
    double[] errors = new double[problem.getAllParameters().length];
    final double c = Math.sqrt(getChiSquare(problem) / (m - p));
    double[][] covar = getCovariances(problem);
    for (int i = 0; i < errors.length; ++i) {
        errors[i] = Math.sqrt(covar[i][i]) * c;
    }
    return errors;
}","public void test011() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    EstimatedParameter estimatedParameter0 = new EstimatedParameter(""unable to compute covariances: singular problem"", 0.0, true);
    estimatedParameter0.setBound(false);
    simpleEstimationProblem0.addParameter(estimatedParameter0);
    levenbergMarquardtEstimator0.initializeEstimate(simpleEstimationProblem0);
    try {
        levenbergMarquardtEstimator0.guessParametersErrors(simpleEstimationProblem0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // no degrees of freedom (0 measurements, 1 parameters)
        //
        verifyException(""org.apache.commons.math.estimation.AbstractEstimator"", e);
    }
}","/**
 * Guess the errors in unbound estimated parameters.
 * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>
 * @param problem estimation problem
 * @return errors in estimated parameters
 * @exception EstimationException if the covariances matrix cannot be computed
 * or the number of degrees of freedom is not positive (number of measurements
 * lesser or equal to number of parameters)
 */"
"public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException {
    int m = problem.getMeasurements().length;
    int p = problem.getAllParameters().length;
    if (m <= p) {
        throw new EstimationException(""no degrees of freedom ({0} measurements, {1} parameters)"", new Object[] { new Integer(m), new Integer(p) });
    }
    double[] errors = new double[problem.getAllParameters().length];
    final double c = Math.sqrt(getChiSquare(problem) / (m - p));
    double[][] covar = getCovariances(problem);
    for (int i = 0; i < errors.length; ++i) {
        errors[i] = Math.sqrt(covar[i][i]) * c;
    }
    return errors;
}","public void test022() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    levenbergMarquardtEstimator0.rows = (-108);
    try {
        levenbergMarquardtEstimator0.guessParametersErrors(simpleEstimationProblem0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // no degrees of freedom (0 measurements, 0 parameters)
        //
        verifyException(""org.apache.commons.math.estimation.AbstractEstimator"", e);
    }
}","/**
 * Guess the errors in unbound estimated parameters.
 * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>
 * @param problem estimation problem
 * @return errors in estimated parameters
 * @exception EstimationException if the covariances matrix cannot be computed
 * or the number of degrees of freedom is not positive (number of measurements
 * lesser or equal to number of parameters)
 */"
"public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException {
    int m = problem.getMeasurements().length;
    int p = problem.getAllParameters().length;
    if (m <= p) {
        throw new EstimationException(""no degrees of freedom ({0} measurements, {1} parameters)"", new Object[] { new Integer(m), new Integer(p) });
    }
    double[] errors = new double[problem.getAllParameters().length];
    final double c = Math.sqrt(getChiSquare(problem) / (m - p));
    double[][] covar = getCovariances(problem);
    for (int i = 0; i < errors.length; ++i) {
        errors[i] = Math.sqrt(covar[i][i]) * c;
    }
    return errors;
}","public void test033() throws Throwable {
    GaussNewtonEstimator gaussNewtonEstimator0 = new GaussNewtonEstimator((-2672), (-2672), (-2672));
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    simpleEstimationProblem0.addParameter((EstimatedParameter) null);
    try {
        gaussNewtonEstimator0.guessParametersErrors(simpleEstimationProblem0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // no degrees of freedom (0 measurements, 1 parameters)
        //
        verifyException(""org.apache.commons.math.estimation.AbstractEstimator"", e);
    }
}","/**
 * Guess the errors in unbound estimated parameters.
 * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>
 * @param problem estimation problem
 * @return errors in estimated parameters
 * @exception EstimationException if the covariances matrix cannot be computed
 * or the number of degrees of freedom is not positive (number of measurements
 * lesser or equal to number of parameters)
 */"
"public double[][] getCovariances(EstimationProblem problem) throws EstimationException {
    // set up the jacobian
    updateJacobian();
    // compute transpose(J).J, avoiding building big intermediate matrices
    final int rows = problem.getMeasurements().length;
    final int cols = problem.getAllParameters().length;
    final int max = cols * rows;
    double[][] jTj = new double[cols][cols];
    for (int i = 0; i < cols; ++i) {
        for (int j = i; j < cols; ++j) {
            double sum = 0;
            for (int k = 0; k < max; k += cols) {
                sum += jacobian[k + i] * jacobian[k + j];
            }
            jTj[i][j] = sum;
            jTj[j][i] = sum;
        }
    }
    try {
        // compute the covariances matrix
        return new RealMatrixImpl(jTj).inverse().getData();
    } catch (InvalidMatrixException ime) {
        throw new EstimationException(""unable to compute covariances: singular problem"", new Object[0]);
    }
}","public void test044() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    WeightedMeasurement weightedMeasurement0 = mock(WeightedMeasurement.class, new ViolatedAssumptionAnswer());
    doReturn(0.0, 0.0, 0.0, 0.0).when(weightedMeasurement0).getPartial(any(org.apache.commons.math.estimation.EstimatedParameter.class));
    doReturn(0.0).when(weightedMeasurement0).getResidual();
    doReturn(0.0, 0.0, 0.0, 0.0).when(weightedMeasurement0).getWeight();
    simpleEstimationProblem0.addMeasurement(weightedMeasurement0);
    EstimatedParameter estimatedParameter0 = new EstimatedParameter(""vX~uBD,J#n/L2^QZ8z"", (-2246.12086661453));
    simpleEstimationProblem0.addParameter(estimatedParameter0);
    simpleEstimationProblem0.addParameter(estimatedParameter0);
    levenbergMarquardtEstimator0.estimate(simpleEstimationProblem0);
    try {
        levenbergMarquardtEstimator0.getCovariances(simpleEstimationProblem0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // unable to compute covariances: singular problem
        //
        verifyException(""org.apache.commons.math.estimation.AbstractEstimator"", e);
    }
}","/**
 * Get the covariance matrix of unbound estimated parameters.
 * @param problem estimation problem
 * @return covariance matrix
 * @exception EstimationException if the covariance matrix
 * cannot be computed (singular problem)
 */"
"public double getRMS(EstimationProblem problem) {
    WeightedMeasurement[] wm = problem.getMeasurements();
    double criterion = 0;
    for (int i = 0; i < wm.length; ++i) {
        double residual = wm[i].getResidual();
        criterion += wm[i].getWeight() * residual * residual;
    }
    return Math.sqrt(criterion / wm.length);
}","public void test055() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    WeightedMeasurement weightedMeasurement0 = mock(WeightedMeasurement.class, new ViolatedAssumptionAnswer());
    doReturn(Double.NEGATIVE_INFINITY).when(weightedMeasurement0).getResidual();
    doReturn(0.0).when(weightedMeasurement0).getWeight();
    simpleEstimationProblem0.addMeasurement(weightedMeasurement0);
    double double0 = levenbergMarquardtEstimator0.getRMS(simpleEstimationProblem0);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Get the Root Mean Square value.
 * Get the Root Mean Square value, i.e. the root of the arithmetic
 * mean of the square of all weighted residuals. This is related to the
 * criterion that is minimized by the estimator as follows: if
 * <em>c</em> if the criterion, and <em>n</em> is the number of
 * measurements, then the RMS is <em>sqrt (c/n)</em>.
 *
 * @param problem estimation problem
 * @return RMS value
 */"
"public final int getCostEvaluations() {
    return costEvaluations;
}","public void test066() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    WeightedMeasurement weightedMeasurement0 = mock(WeightedMeasurement.class, new ViolatedAssumptionAnswer());
    doReturn(0.0).when(weightedMeasurement0).getResidual();
    doReturn(0.0).when(weightedMeasurement0).getWeight();
    simpleEstimationProblem0.addMeasurement(weightedMeasurement0);
    levenbergMarquardtEstimator0.initializeEstimate(simpleEstimationProblem0);
    double double0 = levenbergMarquardtEstimator0.getRMS(simpleEstimationProblem0);
    assertEquals(0, levenbergMarquardtEstimator0.getCostEvaluations());
}","/**
 * Get the number of cost evaluations.
 *
 * @return number of cost evaluations
 */"
"public double getRMS(EstimationProblem problem) {
    WeightedMeasurement[] wm = problem.getMeasurements();
    double criterion = 0;
    for (int i = 0; i < wm.length; ++i) {
        double residual = wm[i].getResidual();
        criterion += wm[i].getWeight() * residual * residual;
    }
    return Math.sqrt(criterion / wm.length);
}","public void test067() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    WeightedMeasurement weightedMeasurement0 = mock(WeightedMeasurement.class, new ViolatedAssumptionAnswer());
    doReturn(0.0).when(weightedMeasurement0).getResidual();
    doReturn(0.0).when(weightedMeasurement0).getWeight();
    simpleEstimationProblem0.addMeasurement(weightedMeasurement0);
    levenbergMarquardtEstimator0.initializeEstimate(simpleEstimationProblem0);
    double double0 = levenbergMarquardtEstimator0.getRMS(simpleEstimationProblem0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Get the Root Mean Square value.
 * Get the Root Mean Square value, i.e. the root of the arithmetic
 * mean of the square of all weighted residuals. This is related to the
 * criterion that is minimized by the estimator as follows: if
 * <em>c</em> if the criterion, and <em>n</em> is the number of
 * measurements, then the RMS is <em>sqrt (c/n)</em>.
 *
 * @param problem estimation problem
 * @return RMS value
 */"
"public final int getJacobianEvaluations() {
    return jacobianEvaluations;
}","public void test068() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    WeightedMeasurement weightedMeasurement0 = mock(WeightedMeasurement.class, new ViolatedAssumptionAnswer());
    doReturn(0.0).when(weightedMeasurement0).getResidual();
    doReturn(0.0).when(weightedMeasurement0).getWeight();
    simpleEstimationProblem0.addMeasurement(weightedMeasurement0);
    levenbergMarquardtEstimator0.initializeEstimate(simpleEstimationProblem0);
    double double0 = levenbergMarquardtEstimator0.getRMS(simpleEstimationProblem0);
    assertEquals(0, levenbergMarquardtEstimator0.getJacobianEvaluations());
}","/**
 * Get the number of jacobian evaluations.
 *
 * @return number of jacobian evaluations
 */"
"public double getRMS(EstimationProblem problem) {
    WeightedMeasurement[] wm = problem.getMeasurements();
    double criterion = 0;
    for (int i = 0; i < wm.length; ++i) {
        double residual = wm[i].getResidual();
        criterion += wm[i].getWeight() * residual * residual;
    }
    return Math.sqrt(criterion / wm.length);
}","public void test079() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    WeightedMeasurement weightedMeasurement0 = mock(WeightedMeasurement.class, new ViolatedAssumptionAnswer());
    doReturn(0.0).when(weightedMeasurement0).getResidual();
    doReturn(0.0).when(weightedMeasurement0).getWeight();
    simpleEstimationProblem0.addMeasurement(weightedMeasurement0);
    WeightedMeasurement weightedMeasurement1 = mock(WeightedMeasurement.class, new ViolatedAssumptionAnswer());
    doReturn(0.0).when(weightedMeasurement1).getResidual();
    doReturn(0.0).when(weightedMeasurement1).getWeight();
    simpleEstimationProblem0.addMeasurement(weightedMeasurement1);
    double double0 = levenbergMarquardtEstimator0.getRMS(simpleEstimationProblem0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Get the Root Mean Square value.
 * Get the Root Mean Square value, i.e. the root of the arithmetic
 * mean of the square of all weighted residuals. This is related to the
 * criterion that is minimized by the estimator as follows: if
 * <em>c</em> if the criterion, and <em>n</em> is the number of
 * measurements, then the RMS is <em>sqrt (c/n)</em>.
 *
 * @param problem estimation problem
 * @return RMS value
 */"
"public final int getCostEvaluations() {
    return costEvaluations;
}","public void test0810() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    levenbergMarquardtEstimator0.rows = (-2563);
    levenbergMarquardtEstimator0.updateResidualsAndCost();
    assertEquals(1, levenbergMarquardtEstimator0.getCostEvaluations());
}","/**
 * Get the number of cost evaluations.
 *
 * @return number of cost evaluations
 */"
"public final int getCostEvaluations() {
    return costEvaluations;
}","public void test0911() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    levenbergMarquardtEstimator0.setMaxCostEval(1);
    levenbergMarquardtEstimator0.updateResidualsAndCost();
    assertEquals(1, levenbergMarquardtEstimator0.getCostEvaluations());
}","/**
 * Get the number of cost evaluations.
 *
 * @return number of cost evaluations
 */"
"public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException {
    int m = problem.getMeasurements().length;
    int p = problem.getAllParameters().length;
    if (m <= p) {
        throw new EstimationException(""no degrees of freedom ({0} measurements, {1} parameters)"", new Object[] { new Integer(m), new Integer(p) });
    }
    double[] errors = new double[problem.getAllParameters().length];
    final double c = Math.sqrt(getChiSquare(problem) / (m - p));
    double[][] covar = getCovariances(problem);
    for (int i = 0; i < errors.length; ++i) {
        errors[i] = Math.sqrt(covar[i][i]) * c;
    }
    return errors;
}","public void test1012() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    WeightedMeasurement weightedMeasurement0 = mock(WeightedMeasurement.class, new ViolatedAssumptionAnswer());
    doReturn(0.001, Double.POSITIVE_INFINITY).when(weightedMeasurement0).getResidual();
    doReturn(0.0, 0.001, 0.001, 0.001, 0.0).when(weightedMeasurement0).getWeight();
    simpleEstimationProblem0.addMeasurement(weightedMeasurement0);
    levenbergMarquardtEstimator0.estimate(simpleEstimationProblem0);
    levenbergMarquardtEstimator0.cols = (-3648);
    // Undeclared exception!
    try {
        levenbergMarquardtEstimator0.guessParametersErrors(simpleEstimationProblem0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Matrix must have at least one row.
        //
        verifyException(""org.apache.commons.math.linear.RealMatrixImpl"", e);
    }
}","/**
 * Guess the errors in unbound estimated parameters.
 * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>
 * @param problem estimation problem
 * @return errors in estimated parameters
 * @exception EstimationException if the covariances matrix cannot be computed
 * or the number of degrees of freedom is not positive (number of measurements
 * lesser or equal to number of parameters)
 */"
"public final int getJacobianEvaluations() {
    return jacobianEvaluations;
}","public void test1113() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    WeightedMeasurement weightedMeasurement0 = mock(WeightedMeasurement.class, new ViolatedAssumptionAnswer());
    doReturn(0.0).when(weightedMeasurement0).getResidual();
    doReturn(0.0, 0.0, 0.0).when(weightedMeasurement0).getWeight();
    simpleEstimationProblem0.addMeasurement(weightedMeasurement0);
    WeightedMeasurement weightedMeasurement1 = mock(WeightedMeasurement.class, new ViolatedAssumptionAnswer());
    doReturn(0.0).when(weightedMeasurement1).getResidual();
    doReturn(0.0, 0.0, 0.0).when(weightedMeasurement1).getWeight();
    simpleEstimationProblem0.addMeasurement(weightedMeasurement1);
    levenbergMarquardtEstimator0.estimate(simpleEstimationProblem0);
    assertEquals(1, levenbergMarquardtEstimator0.getJacobianEvaluations());
}","/**
 * Get the number of jacobian evaluations.
 *
 * @return number of jacobian evaluations
 */"
"public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException {
    int m = problem.getMeasurements().length;
    int p = problem.getAllParameters().length;
    if (m <= p) {
        throw new EstimationException(""no degrees of freedom ({0} measurements, {1} parameters)"", new Object[] { new Integer(m), new Integer(p) });
    }
    double[] errors = new double[problem.getAllParameters().length];
    final double c = Math.sqrt(getChiSquare(problem) / (m - p));
    double[][] covar = getCovariances(problem);
    for (int i = 0; i < errors.length; ++i) {
        errors[i] = Math.sqrt(covar[i][i]) * c;
    }
    return errors;
}","public void test1214() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    WeightedMeasurement weightedMeasurement0 = mock(WeightedMeasurement.class, new ViolatedAssumptionAnswer());
    doReturn(0.0).when(weightedMeasurement0).getResidual();
    doReturn(0.0).when(weightedMeasurement0).getWeight();
    simpleEstimationProblem0.addMeasurement(weightedMeasurement0);
    levenbergMarquardtEstimator0.initializeEstimate(simpleEstimationProblem0);
    levenbergMarquardtEstimator0.rows = (-1);
    // Undeclared exception!
    try {
        levenbergMarquardtEstimator0.guessParametersErrors(simpleEstimationProblem0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Matrix must have at least one row.
        //
        verifyException(""org.apache.commons.math.linear.RealMatrixImpl"", e);
    }
}","/**
 * Guess the errors in unbound estimated parameters.
 * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>
 * @param problem estimation problem
 * @return errors in estimated parameters
 * @exception EstimationException if the covariances matrix cannot be computed
 * or the number of degrees of freedom is not positive (number of measurements
 * lesser or equal to number of parameters)
 */"
"public final int getJacobianEvaluations() {
    return jacobianEvaluations;
}","public void test1315() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    levenbergMarquardtEstimator0.estimate(simpleEstimationProblem0);
    assertEquals(1, levenbergMarquardtEstimator0.getJacobianEvaluations());
}","/**
 * Get the number of jacobian evaluations.
 *
 * @return number of jacobian evaluations
 */"
"public final int getCostEvaluations() {
    return costEvaluations;
}","public void test1416() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    WeightedMeasurement weightedMeasurement0 = mock(WeightedMeasurement.class, new ViolatedAssumptionAnswer());
    doReturn(0.0, 480.34893).when(weightedMeasurement0).getResidual();
    doReturn(0.0, 0.0, 0.0, 1.0E-11).when(weightedMeasurement0).getWeight();
    simpleEstimationProblem0.addMeasurement(weightedMeasurement0);
    levenbergMarquardtEstimator0.estimate(simpleEstimationProblem0);
    double double0 = levenbergMarquardtEstimator0.getRMS(simpleEstimationProblem0);
    assertEquals(1, levenbergMarquardtEstimator0.getCostEvaluations());
}","/**
 * Get the number of cost evaluations.
 *
 * @return number of cost evaluations
 */"
"public double getRMS(EstimationProblem problem) {
    WeightedMeasurement[] wm = problem.getMeasurements();
    double criterion = 0;
    for (int i = 0; i < wm.length; ++i) {
        double residual = wm[i].getResidual();
        criterion += wm[i].getWeight() * residual * residual;
    }
    return Math.sqrt(criterion / wm.length);
}","public void test1417() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    WeightedMeasurement weightedMeasurement0 = mock(WeightedMeasurement.class, new ViolatedAssumptionAnswer());
    doReturn(0.0, 480.34893).when(weightedMeasurement0).getResidual();
    doReturn(0.0, 0.0, 0.0, 1.0E-11).when(weightedMeasurement0).getWeight();
    simpleEstimationProblem0.addMeasurement(weightedMeasurement0);
    levenbergMarquardtEstimator0.estimate(simpleEstimationProblem0);
    double double0 = levenbergMarquardtEstimator0.getRMS(simpleEstimationProblem0);
    assertEquals(0.0015189966904247845, double0, 0.01);
}","/**
 * Get the Root Mean Square value.
 * Get the Root Mean Square value, i.e. the root of the arithmetic
 * mean of the square of all weighted residuals. This is related to the
 * criterion that is minimized by the estimator as follows: if
 * <em>c</em> if the criterion, and <em>n</em> is the number of
 * measurements, then the RMS is <em>sqrt (c/n)</em>.
 *
 * @param problem estimation problem
 * @return RMS value
 */"
"public final int getJacobianEvaluations() {
    return jacobianEvaluations;
}","public void test1518() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    levenbergMarquardtEstimator0.incrementJacobianEvaluationsCounter();
    int int0 = levenbergMarquardtEstimator0.getJacobianEvaluations();
    assertEquals(1, int0);
}","/**
 * Get the number of jacobian evaluations.
 *
 * @return number of jacobian evaluations
 */"
"public final int getJacobianEvaluations() {
    return jacobianEvaluations;
}","public void test1619() throws Throwable {
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    EstimatedParameter estimatedParameter0 = new EstimatedParameter(""LU decomposition requires that the matrix be square."", 1.0);
    simpleEstimationProblem0.addParameter(estimatedParameter0);
    WeightedMeasurement weightedMeasurement0 = mock(WeightedMeasurement.class, new ViolatedAssumptionAnswer());
    doReturn((-1502.78691445)).when(weightedMeasurement0).getPartial(any(org.apache.commons.math.estimation.EstimatedParameter.class));
    doReturn((-1.0)).when(weightedMeasurement0).getWeight();
    simpleEstimationProblem0.addMeasurement(weightedMeasurement0);
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    levenbergMarquardtEstimator0.initializeEstimate(simpleEstimationProblem0);
    levenbergMarquardtEstimator0.getCovariances(simpleEstimationProblem0);
    assertEquals(1, levenbergMarquardtEstimator0.getJacobianEvaluations());
}","/**
 * Get the number of jacobian evaluations.
 *
 * @return number of jacobian evaluations
 */"
"public final int getCostEvaluations() {
    return costEvaluations;
}","public void test1720() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    levenbergMarquardtEstimator0.updateResidualsAndCost();
    int int0 = levenbergMarquardtEstimator0.getCostEvaluations();
    assertEquals(1, int0);
}","/**
 * Get the number of cost evaluations.
 *
 * @return number of cost evaluations
 */"
"public double getChiSquare(EstimationProblem problem) {
    WeightedMeasurement[] wm = problem.getMeasurements();
    double chiSquare = 0;
    for (int i = 0; i < wm.length; ++i) {
        double residual = wm[i].getResidual();
        chiSquare += residual * residual / wm[i].getWeight();
    }
    return chiSquare;
}","public void test1821() throws Throwable {
    GaussNewtonEstimator gaussNewtonEstimator0 = new GaussNewtonEstimator(0, 584.6735773400344, 0);
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    WeightedMeasurement weightedMeasurement0 = mock(WeightedMeasurement.class, new ViolatedAssumptionAnswer());
    doReturn((-1250.2)).when(weightedMeasurement0).getResidual();
    doReturn(584.6735773400344).when(weightedMeasurement0).getWeight();
    simpleEstimationProblem0.addMeasurement(weightedMeasurement0);
    double double0 = gaussNewtonEstimator0.getChiSquare(simpleEstimationProblem0);
    assertEquals(2673.2866005521414, double0, 0.01);
}","/**
 * Get the Chi-Square value.
 * @param problem estimation problem
 * @return chi-square value
 */"
"public double getChiSquare(EstimationProblem problem) {
    WeightedMeasurement[] wm = problem.getMeasurements();
    double chiSquare = 0;
    for (int i = 0; i < wm.length; ++i) {
        double residual = wm[i].getResidual();
        chiSquare += residual * residual / wm[i].getWeight();
    }
    return chiSquare;
}","public void test1922() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    WeightedMeasurement weightedMeasurement0 = mock(WeightedMeasurement.class, new ViolatedAssumptionAnswer());
    doReturn(2.2204E-16, 2.2204E-16).when(weightedMeasurement0).getResidual();
    doReturn(2.2204E-16, (-2334.9), (-532.18208538391), 0.0).when(weightedMeasurement0).getWeight();
    simpleEstimationProblem0.addMeasurement(weightedMeasurement0);
    levenbergMarquardtEstimator0.estimate(simpleEstimationProblem0);
    double double0 = levenbergMarquardtEstimator0.getChiSquare(simpleEstimationProblem0);
    //  // Unstable assertion: assertEquals(1, levenbergMarquardtEstimator0.getJacobianEvaluations());
    //  // Unstable assertion: assertEquals((-2.1115149085613945E-35), double0, 0.01);
}","/**
 * Get the Chi-Square value.
 * @param problem estimation problem
 * @return chi-square value
 */"
"protected void updateResidualsAndCost() throws EstimationException {
    if (++costEvaluations > maxCostEval) {
        throw new EstimationException(""maximal number of evaluations exceeded ({0})"", new Object[] { new Integer(maxCostEval) });
    }
    cost = 0;
    for (int i = 0, index = 0; i < rows; i++, index += cols) {
        WeightedMeasurement wm = measurements[i];
        double residual = wm.getResidual();
        residuals[i] = Math.sqrt(wm.getWeight()) * residual;
        cost += wm.getWeight() * residual * residual;
    }
    cost = Math.sqrt(cost);
}","public void test2023() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    levenbergMarquardtEstimator0.rows = 1278;
    // Undeclared exception!
    try {
        levenbergMarquardtEstimator0.updateResidualsAndCost();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.estimation.AbstractEstimator"", e);
    }
}","/**
 * Update the residuals array and cost function value.
 * @exception EstimationException if the number of cost evaluations
 * exceeds the maximum allowed
 */"
"protected void updateResidualsAndCost() throws EstimationException {
    if (++costEvaluations > maxCostEval) {
        throw new EstimationException(""maximal number of evaluations exceeded ({0})"", new Object[] { new Integer(maxCostEval) });
    }
    cost = 0;
    for (int i = 0, index = 0; i < rows; i++, index += cols) {
        WeightedMeasurement wm = measurements[i];
        double residual = wm.getResidual();
        residuals[i] = Math.sqrt(wm.getWeight()) * residual;
        cost += wm.getWeight() * residual * residual;
    }
    cost = Math.sqrt(cost);
}","public void test2124() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    levenbergMarquardtEstimator0.initializeEstimate(simpleEstimationProblem0);
    levenbergMarquardtEstimator0.rows = 2786;
    // Undeclared exception!
    try {
        levenbergMarquardtEstimator0.updateResidualsAndCost();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.math.estimation.AbstractEstimator"", e);
    }
}","/**
 * Update the residuals array and cost function value.
 * @exception EstimationException if the number of cost evaluations
 * exceeds the maximum allowed
 */"
"protected void updateJacobian() {
    incrementJacobianEvaluationsCounter();
    Arrays.fill(jacobian, 0);
    for (int i = 0, index = 0; i < rows; i++) {
        WeightedMeasurement wm = measurements[i];
        double factor = -Math.sqrt(wm.getWeight());
        for (int j = 0; j < cols; ++j) {
            jacobian[index++] = factor * wm.getPartial(parameters[j]);
        }
    }
}","public void test2225() throws Throwable {
    GaussNewtonEstimator gaussNewtonEstimator0 = new GaussNewtonEstimator(0, 4984.32166029148, (-1721.36667));
    // Undeclared exception!
    try {
        gaussNewtonEstimator0.updateJacobian();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.Arrays"", e);
    }
}","/**
 * Update the jacobian matrix.
 */"
"protected void initializeEstimate(EstimationProblem problem) {
    // reset counters
    costEvaluations = 0;
    jacobianEvaluations = 0;
    // retrieve the equations and the parameters
    measurements = problem.getMeasurements();
    parameters = problem.getUnboundParameters();
    // arrays shared with the other private methods
    rows = measurements.length;
    cols = parameters.length;
    jacobian = new double[rows * cols];
    residuals = new double[rows];
    cost = Double.POSITIVE_INFINITY;
}","public void test2326() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    // Undeclared exception!
    try {
        levenbergMarquardtEstimator0.initializeEstimate((EstimationProblem) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.estimation.AbstractEstimator"", e);
    }
}","/**
 * Initialization of the common parts of the estimation.
 * <p>This method <em>must</em> be called at the start
 * of the {@link #estimate(EstimationProblem) estimate}
 * method.</p>
 * @param problem estimation problem to solve
 */"
"public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException {
    int m = problem.getMeasurements().length;
    int p = problem.getAllParameters().length;
    if (m <= p) {
        throw new EstimationException(""no degrees of freedom ({0} measurements, {1} parameters)"", new Object[] { new Integer(m), new Integer(p) });
    }
    double[] errors = new double[problem.getAllParameters().length];
    final double c = Math.sqrt(getChiSquare(problem) / (m - p));
    double[][] covar = getCovariances(problem);
    for (int i = 0; i < errors.length; ++i) {
        errors[i] = Math.sqrt(covar[i][i]) * c;
    }
    return errors;
}","public void test2427() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    WeightedMeasurement weightedMeasurement0 = mock(WeightedMeasurement.class, new ViolatedAssumptionAnswer());
    doReturn(0.0).when(weightedMeasurement0).getResidual();
    doReturn(0.0).when(weightedMeasurement0).getWeight();
    simpleEstimationProblem0.addMeasurement(weightedMeasurement0);
    // Undeclared exception!
    try {
        levenbergMarquardtEstimator0.guessParametersErrors(simpleEstimationProblem0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.Arrays"", e);
    }
}","/**
 * Guess the errors in unbound estimated parameters.
 * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>
 * @param problem estimation problem
 * @return errors in estimated parameters
 * @exception EstimationException if the covariances matrix cannot be computed
 * or the number of degrees of freedom is not positive (number of measurements
 * lesser or equal to number of parameters)
 */"
"public double getRMS(EstimationProblem problem) {
    WeightedMeasurement[] wm = problem.getMeasurements();
    double criterion = 0;
    for (int i = 0; i < wm.length; ++i) {
        double residual = wm[i].getResidual();
        criterion += wm[i].getWeight() * residual * residual;
    }
    return Math.sqrt(criterion / wm.length);
}","public void test2528() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    simpleEstimationProblem0.addMeasurement((WeightedMeasurement) null);
    // Undeclared exception!
    try {
        levenbergMarquardtEstimator0.getRMS(simpleEstimationProblem0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.estimation.AbstractEstimator"", e);
    }
}","/**
 * Get the Root Mean Square value.
 * Get the Root Mean Square value, i.e. the root of the arithmetic
 * mean of the square of all weighted residuals. This is related to the
 * criterion that is minimized by the estimator as follows: if
 * <em>c</em> if the criterion, and <em>n</em> is the number of
 * measurements, then the RMS is <em>sqrt (c/n)</em>.
 *
 * @param problem estimation problem
 * @return RMS value
 */"
"public double[][] getCovariances(EstimationProblem problem) throws EstimationException {
    // set up the jacobian
    updateJacobian();
    // compute transpose(J).J, avoiding building big intermediate matrices
    final int rows = problem.getMeasurements().length;
    final int cols = problem.getAllParameters().length;
    final int max = cols * rows;
    double[][] jTj = new double[cols][cols];
    for (int i = 0; i < cols; ++i) {
        for (int j = i; j < cols; ++j) {
            double sum = 0;
            for (int k = 0; k < max; k += cols) {
                sum += jacobian[k + i] * jacobian[k + j];
            }
            jTj[i][j] = sum;
            jTj[j][i] = sum;
        }
    }
    try {
        // compute the covariances matrix
        return new RealMatrixImpl(jTj).inverse().getData();
    } catch (InvalidMatrixException ime) {
        throw new EstimationException(""unable to compute covariances: singular problem"", new Object[0]);
    }
}","public void test2629() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    // Undeclared exception!
    try {
        levenbergMarquardtEstimator0.getCovariances(simpleEstimationProblem0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.Arrays"", e);
    }
}","/**
 * Get the covariance matrix of unbound estimated parameters.
 * @param problem estimation problem
 * @return covariance matrix
 * @exception EstimationException if the covariance matrix
 * cannot be computed (singular problem)
 */"
"public double[][] getCovariances(EstimationProblem problem) throws EstimationException {
    // set up the jacobian
    updateJacobian();
    // compute transpose(J).J, avoiding building big intermediate matrices
    final int rows = problem.getMeasurements().length;
    final int cols = problem.getAllParameters().length;
    final int max = cols * rows;
    double[][] jTj = new double[cols][cols];
    for (int i = 0; i < cols; ++i) {
        for (int j = i; j < cols; ++j) {
            double sum = 0;
            for (int k = 0; k < max; k += cols) {
                sum += jacobian[k + i] * jacobian[k + j];
            }
            jTj[i][j] = sum;
            jTj[j][i] = sum;
        }
    }
    try {
        // compute the covariances matrix
        return new RealMatrixImpl(jTj).inverse().getData();
    } catch (InvalidMatrixException ime) {
        throw new EstimationException(""unable to compute covariances: singular problem"", new Object[0]);
    }
}","public void test2730() throws Throwable {
    GaussNewtonEstimator gaussNewtonEstimator0 = new GaussNewtonEstimator(938, 938, 938);
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    gaussNewtonEstimator0.initializeEstimate(simpleEstimationProblem0);
    // Undeclared exception!
    try {
        gaussNewtonEstimator0.getCovariances(simpleEstimationProblem0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Matrix must have at least one row.
        //
        verifyException(""org.apache.commons.math.linear.RealMatrixImpl"", e);
    }
}","/**
 * Get the covariance matrix of unbound estimated parameters.
 * @param problem estimation problem
 * @return covariance matrix
 * @exception EstimationException if the covariance matrix
 * cannot be computed (singular problem)
 */"
"public double[][] getCovariances(EstimationProblem problem) throws EstimationException {
    // set up the jacobian
    updateJacobian();
    // compute transpose(J).J, avoiding building big intermediate matrices
    final int rows = problem.getMeasurements().length;
    final int cols = problem.getAllParameters().length;
    final int max = cols * rows;
    double[][] jTj = new double[cols][cols];
    for (int i = 0; i < cols; ++i) {
        for (int j = i; j < cols; ++j) {
            double sum = 0;
            for (int k = 0; k < max; k += cols) {
                sum += jacobian[k + i] * jacobian[k + j];
            }
            jTj[i][j] = sum;
            jTj[j][i] = sum;
        }
    }
    try {
        // compute the covariances matrix
        return new RealMatrixImpl(jTj).inverse().getData();
    } catch (InvalidMatrixException ime) {
        throw new EstimationException(""unable to compute covariances: singular problem"", new Object[0]);
    }
}","public void test2831() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    levenbergMarquardtEstimator0.initializeEstimate(simpleEstimationProblem0);
    EstimatedParameter estimatedParameter0 = new EstimatedParameter(""Caused by: "", 285.0);
    simpleEstimationProblem0.addParameter(estimatedParameter0);
    simpleEstimationProblem0.addMeasurement((WeightedMeasurement) null);
    // Undeclared exception!
    try {
        levenbergMarquardtEstimator0.getCovariances(simpleEstimationProblem0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.math.estimation.AbstractEstimator"", e);
    }
}","/**
 * Get the covariance matrix of unbound estimated parameters.
 * @param problem estimation problem
 * @return covariance matrix
 * @exception EstimationException if the covariance matrix
 * cannot be computed (singular problem)
 */"
"public double getChiSquare(EstimationProblem problem) {
    WeightedMeasurement[] wm = problem.getMeasurements();
    double chiSquare = 0;
    for (int i = 0; i < wm.length; ++i) {
        double residual = wm[i].getResidual();
        chiSquare += residual * residual / wm[i].getWeight();
    }
    return chiSquare;
}","public void test2932() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    // Undeclared exception!
    try {
        levenbergMarquardtEstimator0.getChiSquare((EstimationProblem) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.estimation.AbstractEstimator"", e);
    }
}","/**
 * Get the Chi-Square value.
 * @param problem estimation problem
 * @return chi-square value
 */"
"public void estimate(EstimationProblem problem) throws EstimationException {
    initializeEstimate(problem);
    // arrays shared with the other private methods
    solvedCols = Math.min(rows, cols);
    diagR = new double[cols];
    jacNorm = new double[cols];
    beta = new double[cols];
    permutation = new int[cols];
    lmDir = new double[cols];
    // local variables
    double delta = 0, xNorm = 0;
    double[] diag = new double[cols];
    double[] oldX = new double[cols];
    double[] oldRes = new double[rows];
    double[] work1 = new double[cols];
    double[] work2 = new double[cols];
    double[] work3 = new double[cols];
    // evaluate the function at the starting point and calculate its norm
    updateResidualsAndCost();
    // outer loop
    lmPar = 0;
    boolean firstIteration = true;
    while (true) {
        // compute the Q.R. decomposition of the jacobian matrix
        updateJacobian();
        qrDecomposition();
        // compute Qt.res
        qTy(residuals);
        // now we don't need Q anymore,
        // so let jacobian contain the R matrix with its diagonal elements
        for (int k = 0; k < solvedCols; ++k) {
            int pk = permutation[k];
            jacobian[k * cols + pk] = diagR[pk];
        }
        if (firstIteration) {
            // scale the variables according to the norms of the columns
            // of the initial jacobian
            xNorm = 0;
            for (int k = 0; k < cols; ++k) {
                double dk = jacNorm[k];
                if (dk == 0) {
                    dk = 1.0;
                }
                double xk = dk * parameters[k].getEstimate();
                xNorm += xk * xk;
                diag[k] = dk;
            }
            xNorm = Math.sqrt(xNorm);
            // initialize the step bound delta
            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
        }
        // check orthogonality between function vector and jacobian columns
        double maxCosine = 0;
        if (cost != 0) {
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double s = jacNorm[pj];
                if (s != 0) {
                    double sum = 0;
                    for (int i = 0, index = pj; i <= j; ++i, index += cols) {
                        sum += jacobian[index] * residuals[i];
                    }
                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                }
            }
        }
        if (maxCosine <= orthoTolerance) {
            return;
        }
        // rescale if necessary
        for (int j = 0; j < cols; ++j) {
            diag[j] = Math.max(diag[j], jacNorm[j]);
        }
        // inner loop
        for (double ratio = 0; ratio < 1.0e-4; ) {
            // save the state
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                oldX[pj] = parameters[pj].getEstimate();
            }
            double previousCost = cost;
            double[] tmpVec = residuals;
            residuals = oldRes;
            oldRes = tmpVec;
            // determine the Levenberg-Marquardt parameter
            determineLMParameter(oldRes, delta, diag, work1, work2, work3);
            // compute the new point and the norm of the evolution direction
            double lmNorm = 0;
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                lmDir[pj] = -lmDir[pj];
                parameters[pj].setEstimate(oldX[pj] + lmDir[pj]);
                double s = diag[pj] * lmDir[pj];
                lmNorm += s * s;
            }
            lmNorm = Math.sqrt(lmNorm);
            // on the first iteration, adjust the initial step bound.
            if (firstIteration) {
                delta = Math.min(delta, lmNorm);
            }
            // evaluate the function at x + p and calculate its norm
            updateResidualsAndCost();
            // compute the scaled actual reduction
            double actRed = -1.0;
            if (0.1 * cost < previousCost) {
                double r = cost / previousCost;
                actRed = 1.0 - r * r;
            }
            // compute the scaled predicted reduction
            // and the scaled directional derivative
            for (int j = 0; j < solvedCols; ++j) {
                int pj = permutation[j];
                double dirJ = lmDir[pj];
                work1[j] = 0;
                for (int i = 0, index = pj; i <= j; ++i, index += cols) {
                    work1[i] += jacobian[index] * dirJ;
                }
            }
            double coeff1 = 0;
            for (int j = 0; j < solvedCols; ++j) {
                coeff1 += work1[j] * work1[j];
            }
            double pc2 = previousCost * previousCost;
            coeff1 = coeff1 / pc2;
            double coeff2 = lmPar * lmNorm * lmNorm / pc2;
            double preRed = coeff1 + 2 * coeff2;
            double dirDer = -(coeff1 + coeff2);
            // ratio of the actual to the predicted reduction
            ratio = (preRed == 0) ? 0 : (actRed / preRed);
            // update the step bound
            if (ratio <= 0.25) {
                double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
                    tmp = 0.1;
                }
                delta = tmp * Math.min(delta, 10.0 * lmNorm);
                lmPar /= tmp;
            } else if ((lmPar == 0) || (ratio >= 0.75)) {
                delta = 2 * lmNorm;
                lmPar *= 0.5;
            }
            // test for successful iteration.
            if (ratio >= 1.0e-4) {
                // successful iteration, update the norm
                firstIteration = false;
                xNorm = 0;
                for (int k = 0; k < cols; ++k) {
                    double xK = diag[k] * parameters[k].getEstimate();
                    xNorm += xK * xK;
                }
                xNorm = Math.sqrt(xNorm);
            } else {
                // failed iteration, reset the previous values
                cost = previousCost;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    parameters[pj].setEstimate(oldX[pj]);
                }
                tmpVec = residuals;
                residuals = oldRes;
                oldRes = tmpVec;
            }
            // tests for convergence.
            if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) {
                return;
            }
            // tests for termination and stringent tolerances
            // (2.2204e-16 is the machine epsilon for IEEE754)
            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                throw new EstimationException(""cost relative tolerance is too small ({0}),"" + "" no further reduction in the"" + "" sum of squares is possible"", new Object[] { new Double(costRelativeTolerance) });
            } else if (delta <= 2.2204e-16 * xNorm) {
                throw new EstimationException(""parameters relative tolerance is too small"" + "" ({0}), no further improvement in"" + "" the approximate solution is possible"", new Object[] { new Double(parRelativeTolerance) });
            } else if (maxCosine <= 2.2204e-16) {
                throw new EstimationException(""orthogonality tolerance is too small ({0}),"" + "" solution is orthogonal to the jacobian"", new Object[] { new Double(orthoTolerance) });
            }
        }
    }
}","public void test3033() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    EstimatedParameter estimatedParameter0 = new EstimatedParameter(""-$C#:Xv%H9/d"", (-2025.2));
    simpleEstimationProblem0.addParameter(estimatedParameter0);
    WeightedMeasurement weightedMeasurement0 = mock(WeightedMeasurement.class, new ViolatedAssumptionAnswer());
    doReturn(0.0).when(weightedMeasurement0).getPartial(any(org.apache.commons.math.estimation.EstimatedParameter.class));
    doReturn(Double.POSITIVE_INFINITY).when(weightedMeasurement0).getResidual();
    doReturn(Double.POSITIVE_INFINITY, (-2025.2), (-2025.2)).when(weightedMeasurement0).getWeight();
    simpleEstimationProblem0.addMeasurement(weightedMeasurement0);
    try {
        levenbergMarquardtEstimator0.estimate(simpleEstimationProblem0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // unable to perform Q.R decomposition on the 1x1 jacobian matrix
        //
        verifyException(""org.apache.commons.math.estimation.LevenbergMarquardtEstimator"", e);
    }
}","/**
 * Solve an estimation problem using the Levenberg-Marquardt algorithm.
 * <p>The algorithm used is a modified Levenberg-Marquardt one, based
 * on the MINPACK <a href=""http://www.netlib.org/minpack/lmder.f"">lmder</a>
 * routine. The algorithm settings must have been set up before this method
 * is called with the {@link #setInitialStepBoundFactor},
 * {@link #setMaxCostEval}, {@link #setCostRelativeTolerance},
 * {@link #setParRelativeTolerance} and {@link #setOrthoTolerance} methods.
 * If these methods have not been called, the default values set up by the
 * {@link #LevenbergMarquardtEstimator() constructor} will be used.</p>
 * <p>The authors of the original fortran function are:</p>
 * <ul>
 *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>
 *   <li>Burton  S. Garbow</li>
 *   <li>Kenneth E. Hillstrom</li>
 *   <li>Jorge   J. More</li>
 *   </ul>
 * <p>Luc Maisonobe did the Java translation.</p>
 *
 * @param problem estimation problem to solve
 * @exception EstimationException if convergence cannot be
 * reached with the specified algorithm settings or if there are more variables
 * than equations
 * @see #setInitialStepBoundFactor
 * @see #setCostRelativeTolerance
 * @see #setParRelativeTolerance
 * @see #setOrthoTolerance
 */"
"public void estimate(EstimationProblem problem) throws EstimationException {
    initializeEstimate(problem);
    // work matrices
    double[] grad = new double[parameters.length];
    RealMatrixImpl bDecrement = new RealMatrixImpl(parameters.length, 1);
    double[][] bDecrementData = bDecrement.getDataRef();
    RealMatrixImpl wGradGradT = new RealMatrixImpl(parameters.length, parameters.length);
    double[][] wggData = wGradGradT.getDataRef();
    // iterate until convergence is reached
    double previous = Double.POSITIVE_INFINITY;
    do {
        // build the linear problem
        incrementJacobianEvaluationsCounter();
        RealMatrix b = new RealMatrixImpl(parameters.length, 1);
        RealMatrix a = new RealMatrixImpl(parameters.length, parameters.length);
        for (int i = 0; i < measurements.length; ++i) {
            if (!measurements[i].isIgnored()) {
                double weight = measurements[i].getWeight();
                double residual = measurements[i].getResidual();
                // compute the normal equation
                for (int j = 0; j < parameters.length; ++j) {
                    grad[j] = measurements[i].getPartial(parameters[j]);
                    bDecrementData[j][0] = weight * residual * grad[j];
                }
                // build the contribution matrix for measurement i
                for (int k = 0; k < parameters.length; ++k) {
                    double[] wggRow = wggData[k];
                    double gk = grad[k];
                    for (int l = 0; l < parameters.length; ++l) {
                        wggRow[l] = weight * gk * grad[l];
                    }
                }
                // update the matrices
                a = a.add(wGradGradT);
                b = b.add(bDecrement);
            }
        }
        try {
            // solve the linearized least squares problem
            RealMatrix dX = a.solve(b);
            // update the estimated parameters
            for (int i = 0; i < parameters.length; ++i) {
                parameters[i].setEstimate(parameters[i].getEstimate() + dX.getEntry(i, 0));
            }
        } catch (InvalidMatrixException e) {
            throw new EstimationException(""unable to solve: singular problem"", new Object[0]);
        }
        previous = cost;
        updateResidualsAndCost();
    } while ((getCostEvaluations() < 2) || (Math.abs(previous - cost) > (cost * steadyStateThreshold) && (Math.abs(cost) > convergence)));
}","public void test3134() throws Throwable {
    GaussNewtonEstimator gaussNewtonEstimator0 = new GaussNewtonEstimator(0, 0, 0);
    // Undeclared exception!
    try {
        gaussNewtonEstimator0.estimate((EstimationProblem) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.estimation.AbstractEstimator"", e);
    }
}","/**
 * Solve an estimation problem using a least squares criterion.
 *
 * <p>This method set the unbound parameters of the given problem
 * starting from their current values through several iterations. At
 * each step, the unbound parameters are changed in order to
 * minimize a weighted least square criterion based on the
 * measurements of the problem.</p>
 *
 * <p>The iterations are stopped either when the criterion goes
 * below a physical threshold under which improvement are considered
 * useless or when the algorithm is unable to improve it (even if it
 * is still high). The first condition that is met stops the
 * iterations. If the convergence it nos reached before the maximum
 * number of iterations, an {@link EstimationException} is
 * thrown.</p>
 *
 * @param problem estimation problem to solve
 * @exception EstimationException if the problem cannot be solved
 *
 * @see EstimationProblem
 */"
"public void estimate(EstimationProblem problem) throws EstimationException {
    initializeEstimate(problem);
    // work matrices
    double[] grad = new double[parameters.length];
    RealMatrixImpl bDecrement = new RealMatrixImpl(parameters.length, 1);
    double[][] bDecrementData = bDecrement.getDataRef();
    RealMatrixImpl wGradGradT = new RealMatrixImpl(parameters.length, parameters.length);
    double[][] wggData = wGradGradT.getDataRef();
    // iterate until convergence is reached
    double previous = Double.POSITIVE_INFINITY;
    do {
        // build the linear problem
        incrementJacobianEvaluationsCounter();
        RealMatrix b = new RealMatrixImpl(parameters.length, 1);
        RealMatrix a = new RealMatrixImpl(parameters.length, parameters.length);
        for (int i = 0; i < measurements.length; ++i) {
            if (!measurements[i].isIgnored()) {
                double weight = measurements[i].getWeight();
                double residual = measurements[i].getResidual();
                // compute the normal equation
                for (int j = 0; j < parameters.length; ++j) {
                    grad[j] = measurements[i].getPartial(parameters[j]);
                    bDecrementData[j][0] = weight * residual * grad[j];
                }
                // build the contribution matrix for measurement i
                for (int k = 0; k < parameters.length; ++k) {
                    double[] wggRow = wggData[k];
                    double gk = grad[k];
                    for (int l = 0; l < parameters.length; ++l) {
                        wggRow[l] = weight * gk * grad[l];
                    }
                }
                // update the matrices
                a = a.add(wGradGradT);
                b = b.add(bDecrement);
            }
        }
        try {
            // solve the linearized least squares problem
            RealMatrix dX = a.solve(b);
            // update the estimated parameters
            for (int i = 0; i < parameters.length; ++i) {
                parameters[i].setEstimate(parameters[i].getEstimate() + dX.getEntry(i, 0));
            }
        } catch (InvalidMatrixException e) {
            throw new EstimationException(""unable to solve: singular problem"", new Object[0]);
        }
        previous = cost;
        updateResidualsAndCost();
    } while ((getCostEvaluations() < 2) || (Math.abs(previous - cost) > (cost * steadyStateThreshold) && (Math.abs(cost) > convergence)));
}","public void test3235() throws Throwable {
    GaussNewtonEstimator gaussNewtonEstimator0 = new GaussNewtonEstimator((-584), (-584), (-584));
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    // Undeclared exception!
    try {
        gaussNewtonEstimator0.estimate(simpleEstimationProblem0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // row and column dimensions must be postive
        //
        verifyException(""org.apache.commons.math.linear.RealMatrixImpl"", e);
    }
}","/**
 * Solve an estimation problem using a least squares criterion.
 *
 * <p>This method set the unbound parameters of the given problem
 * starting from their current values through several iterations. At
 * each step, the unbound parameters are changed in order to
 * minimize a weighted least square criterion based on the
 * measurements of the problem.</p>
 *
 * <p>The iterations are stopped either when the criterion goes
 * below a physical threshold under which improvement are considered
 * useless or when the algorithm is unable to improve it (even if it
 * is still high). The first condition that is met stops the
 * iterations. If the convergence it nos reached before the maximum
 * number of iterations, an {@link EstimationException} is
 * thrown.</p>
 *
 * @param problem estimation problem to solve
 * @exception EstimationException if the problem cannot be solved
 *
 * @see EstimationProblem
 */"
"public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException {
    int m = problem.getMeasurements().length;
    int p = problem.getAllParameters().length;
    if (m <= p) {
        throw new EstimationException(""no degrees of freedom ({0} measurements, {1} parameters)"", new Object[] { new Integer(m), new Integer(p) });
    }
    double[] errors = new double[problem.getAllParameters().length];
    final double c = Math.sqrt(getChiSquare(problem) / (m - p));
    double[][] covar = getCovariances(problem);
    for (int i = 0; i < errors.length; ++i) {
        errors[i] = Math.sqrt(covar[i][i]) * c;
    }
    return errors;
}","public void test3336() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    WeightedMeasurement weightedMeasurement0 = mock(WeightedMeasurement.class, new ViolatedAssumptionAnswer());
    doReturn(0.0).when(weightedMeasurement0).getResidual();
    doReturn(0.0).when(weightedMeasurement0).getWeight();
    EstimatedParameter estimatedParameter0 = new EstimatedParameter(""LU decomposition requires that the matrix be square."", 1.0);
    simpleEstimationProblem0.addParameter(estimatedParameter0);
    simpleEstimationProblem0.addMeasurement(weightedMeasurement0);
    WeightedMeasurement weightedMeasurement1 = mock(WeightedMeasurement.class, new ViolatedAssumptionAnswer());
    doReturn(0.0).when(weightedMeasurement1).getResidual();
    doReturn(0.0).when(weightedMeasurement1).getWeight();
    simpleEstimationProblem0.addMeasurement(weightedMeasurement1);
    double[] doubleArray0 = new double[8];
    levenbergMarquardtEstimator0.jacobian = doubleArray0;
    try {
        levenbergMarquardtEstimator0.guessParametersErrors(simpleEstimationProblem0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // unable to compute covariances: singular problem
        //
        verifyException(""org.apache.commons.math.estimation.AbstractEstimator"", e);
    }
}","/**
 * Guess the errors in unbound estimated parameters.
 * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>
 * @param problem estimation problem
 * @return errors in estimated parameters
 * @exception EstimationException if the covariances matrix cannot be computed
 * or the number of degrees of freedom is not positive (number of measurements
 * lesser or equal to number of parameters)
 */"
"public double[] guessParametersErrors(EstimationProblem problem) throws EstimationException {
    int m = problem.getMeasurements().length;
    int p = problem.getAllParameters().length;
    if (m <= p) {
        throw new EstimationException(""no degrees of freedom ({0} measurements, {1} parameters)"", new Object[] { new Integer(m), new Integer(p) });
    }
    double[] errors = new double[problem.getAllParameters().length];
    final double c = Math.sqrt(getChiSquare(problem) / (m - p));
    double[][] covar = getCovariances(problem);
    for (int i = 0; i < errors.length; ++i) {
        errors[i] = Math.sqrt(covar[i][i]) * c;
    }
    return errors;
}","public void test3437() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    WeightedMeasurement weightedMeasurement0 = mock(WeightedMeasurement.class, new ViolatedAssumptionAnswer());
    doReturn(0.0, 0.0).when(weightedMeasurement0).getPartial(any(org.apache.commons.math.estimation.EstimatedParameter.class));
    doReturn(0.0, 0.0).when(weightedMeasurement0).getResidual();
    doReturn(0.0, 0.0, 0.0, 0.0, 0.0).when(weightedMeasurement0).getWeight();
    EstimatedParameter estimatedParameter0 = new EstimatedParameter(""LU decomposition requires that the matrix be square."", 1.0);
    simpleEstimationProblem0.addParameter(estimatedParameter0);
    simpleEstimationProblem0.addMeasurement(weightedMeasurement0);
    levenbergMarquardtEstimator0.estimate(simpleEstimationProblem0);
    WeightedMeasurement weightedMeasurement1 = mock(WeightedMeasurement.class, new ViolatedAssumptionAnswer());
    doReturn(0.0).when(weightedMeasurement1).getResidual();
    doReturn(0.0).when(weightedMeasurement1).getWeight();
    simpleEstimationProblem0.addMeasurement(weightedMeasurement1);
    // Undeclared exception!
    try {
        levenbergMarquardtEstimator0.guessParametersErrors(simpleEstimationProblem0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 1
        //
        verifyException(""org.apache.commons.math.estimation.AbstractEstimator"", e);
    }
}","/**
 * Guess the errors in unbound estimated parameters.
 * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>
 * @param problem estimation problem
 * @return errors in estimated parameters
 * @exception EstimationException if the covariances matrix cannot be computed
 * or the number of degrees of freedom is not positive (number of measurements
 * lesser or equal to number of parameters)
 */"
"public double getChiSquare(EstimationProblem problem) {
    WeightedMeasurement[] wm = problem.getMeasurements();
    double chiSquare = 0;
    for (int i = 0; i < wm.length; ++i) {
        double residual = wm[i].getResidual();
        chiSquare += residual * residual / wm[i].getWeight();
    }
    return chiSquare;
}","public void test3538() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    double double0 = levenbergMarquardtEstimator0.getChiSquare(simpleEstimationProblem0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Get the Chi-Square value.
 * @param problem estimation problem
 * @return chi-square value
 */"
"protected void updateResidualsAndCost() throws EstimationException {
    if (++costEvaluations > maxCostEval) {
        throw new EstimationException(""maximal number of evaluations exceeded ({0})"", new Object[] { new Integer(maxCostEval) });
    }
    cost = 0;
    for (int i = 0, index = 0; i < rows; i++, index += cols) {
        WeightedMeasurement wm = measurements[i];
        double residual = wm.getResidual();
        residuals[i] = Math.sqrt(wm.getWeight()) * residual;
        cost += wm.getWeight() * residual * residual;
    }
    cost = Math.sqrt(cost);
}","public void test3639() throws Throwable {
    GaussNewtonEstimator gaussNewtonEstimator0 = new GaussNewtonEstimator((-817), (-817), (-817));
    try {
        gaussNewtonEstimator0.updateResidualsAndCost();
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // maximal number of evaluations exceeded (-817)
        //
        verifyException(""org.apache.commons.math.estimation.AbstractEstimator"", e);
    }
}","/**
 * Update the residuals array and cost function value.
 * @exception EstimationException if the number of cost evaluations
 * exceeds the maximum allowed
 */"
"public final int getJacobianEvaluations() {
    return jacobianEvaluations;
}","public void test3740() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    SimpleEstimationProblem simpleEstimationProblem0 = new SimpleEstimationProblem();
    levenbergMarquardtEstimator0.estimate(simpleEstimationProblem0);
    levenbergMarquardtEstimator0.updateJacobian();
    assertEquals(2, levenbergMarquardtEstimator0.getJacobianEvaluations());
}","/**
 * Get the number of jacobian evaluations.
 *
 * @return number of jacobian evaluations
 */"
"public final int getJacobianEvaluations() {
    return jacobianEvaluations;
}","public void test3841() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    int int0 = levenbergMarquardtEstimator0.getJacobianEvaluations();
    assertEquals(0, int0);
}","/**
 * Get the number of jacobian evaluations.
 *
 * @return number of jacobian evaluations
 */"
"public final int getCostEvaluations() {
    return costEvaluations;
}","public void test3942() throws Throwable {
    LevenbergMarquardtEstimator levenbergMarquardtEstimator0 = new LevenbergMarquardtEstimator();
    int int0 = levenbergMarquardtEstimator0.getCostEvaluations();
    assertEquals(0, int0);
}","/**
 * Get the number of cost evaluations.
 *
 * @return number of cost evaluations
 */"
