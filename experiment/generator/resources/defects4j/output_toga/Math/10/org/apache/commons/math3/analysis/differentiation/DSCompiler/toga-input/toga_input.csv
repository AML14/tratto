focal_method,test_prefix,docstring
"public void compose(final double[] operand, final int operandOffset, final double[] f, final double[] result, final int resultOffset) {
    for (int i = 0; i < compIndirection.length; ++i) {
        final int[][] mappingI = compIndirection[i];
        double r = 0;
        for (int j = 0; j < mappingI.length; ++j) {
            final int[] mappingIJ = mappingI[j];
            double product = mappingIJ[0] * f[mappingIJ[1]];
            for (int k = 2; k < mappingIJ.length; ++k) {
                product *= operand[operandOffset + mappingIJ[k]];
            }
            r += product;
        }
        result[resultOffset + i] = r;
    }
}","public void test000() throws Throwable {
    int int0 = 3;
    int int1 = 0;
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(3, 0);
    double[] doubleArray0 = new double[8];
    doubleArray0[0] = (double) 3;
    doubleArray0[1] = (double) 3;
    doubleArray0[2] = (double) 0;
    doubleArray0[3] = (double) 3;
    doubleArray0[4] = 2805.6104957987;
    doubleArray0[5] = (double) 0;
    doubleArray0[6] = (double) 3;
    doubleArray0[7] = (double) 3;
    double[] doubleArray1 = new double[1];
    doubleArray1[0] = 2805.6104957987;
    // Undeclared exception!
    try {
        dSCompiler0.compose(doubleArray0, 0, doubleArray0, doubleArray1, 3);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 3
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute composition of a derivative structure by a function.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param f array of value and derivatives of the function at
 * the current point (i.e. at {@code operand[operandOffset]}).
 * @param result array where result must be stored (for
 * composition the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
"public void divide(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) {
    final double[] reciprocal = new double[getSize()];
    pow(rhs, lhsOffset, -1, reciprocal, 0);
    multiply(lhs, lhsOffset, reciprocal, 0, result, resultOffset);
}","public void test011() throws Throwable {
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 0);
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (double) 0;
    doubleArray0[1] = (-305.8274);
    doubleArray0[2] = (double) 0;
    doubleArray0[3] = (double) 0;
    doubleArray0[4] = (double) 0;
    int int0 = (-1318);
    // Undeclared exception!
    try {
        dSCompiler0.divide(doubleArray0, 0, doubleArray0, 0, doubleArray0, (-1318));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1318
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Perform division of two derivative structures.
 * @param lhs array holding left hand side of division
 * @param lhsOffset offset of the left hand side in its array
 * @param rhs array right hand side of division
 * @param rhsOffset offset of the right hand side in its array
 * @param result array where result must be stored (for
 * division the result array <em>cannot</em> be one of
 * the input arrays)
 * @param resultOffset offset of the result in its array
 */"
"public void atan(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {
    // create the function value and derivatives
    double[] function = new double[1 + order];
    final double x = operand[operandOffset];
    function[0] = FastMath.atan(x);
    if (order > 0) {
        // the nth order derivative of atan has the form:
        // dn(atan(x)/dxn = Q_n(x) / (1 + x^2)^n
        // where Q_n(x) is a degree n-1 polynomial with same parity as n-1
        // Q_1(x) = 1, Q_2(x) = -2x, Q_3(x) = 6x^2 - 2 ...
        // the general recurrence relation for Q_n is:
        // Q_n(x) = (1+x^2) Q_(n-1)'(x) - 2(n-1) x Q_(n-1)(x)
        // as per polynomial parity, we can store coefficients of both Q_(n-1) and Q_n in the same array
        final double[] q = new double[order];
        q[0] = 1;
        final double x2 = x * x;
        final double f = 1.0 / (1 + x2);
        double coeff = f;
        function[1] = coeff * q[0];
        for (int n = 2; n <= order; ++n) {
            // update and evaluate polynomial Q_n(x)
            double v = 0;
            q[n - 1] = -n * q[n - 2];
            for (int k = n - 1; k >= 0; k -= 2) {
                v = v * x2 + q[k];
                if (k > 2) {
                    q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3];
                } else if (k == 2) {
                    q[0] = q[1];
                }
            }
            if ((n & 0x1) == 0) {
                v *= x;
            }
            coeff *= f;
            function[n] = coeff * v;
        }
    }
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test022() throws Throwable {
    int int0 = 0;
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 0);
    double double0 = 0.0;
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = (double) 0;
    dSCompiler0.linearCombination(0.0, doubleArray0, 0, (-3.141592653589793), doubleArray0, 0, 0.0, doubleArray0, 0, (-4396.0), doubleArray0, 0, doubleArray0, 0);
    doubleArray0[1] = 0.0;
    doubleArray0[2] = 0.0;
    doubleArray0[3] = 0.0;
    double double1 = 0.0;
    double[] doubleArray1 = null;
    int int1 = 0;
    int int2 = 2444;
    // Undeclared exception!
    try {
        dSCompiler0.atan(doubleArray0, 0, (double[]) null, 2444);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute arc tangent of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param result array where result must be stored (for
 * arc tangent the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
"public void atanh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {
    // create the function value and derivatives
    double[] function = new double[1 + order];
    final double x = operand[operandOffset];
    function[0] = FastMath.atanh(x);
    if (order > 0) {
        // the nth order derivative of atanh has the form:
        // dn(atanh(x)/dxn = Q_n(x) / (1 - x^2)^n
        // where Q_n(x) is a degree n-1 polynomial with same parity as n-1
        // Q_1(x) = 1, Q_2(x) = 2x, Q_3(x) = 6x^2 + 2 ...
        // the general recurrence relation for Q_n is:
        // Q_n(x) = (1-x^2) Q_(n-1)'(x) + 2(n-1) x Q_(n-1)(x)
        // as per polynomial parity, we can store coefficients of both Q_(n-1) and Q_n in the same array
        final double[] q = new double[order];
        q[0] = 1;
        final double x2 = x * x;
        final double f = 1.0 / (1 - x2);
        double coeff = f;
        function[1] = coeff * q[0];
        for (int n = 2; n <= order; ++n) {
            // update and evaluate polynomial Q_n(x)
            double v = 0;
            q[n - 1] = n * q[n - 2];
            for (int k = n - 1; k >= 0; k -= 2) {
                v = v * x2 + q[k];
                if (k > 2) {
                    q[k - 2] = (k - 1) * q[k - 1] + (2 * n - k + 1) * q[k - 3];
                } else if (k == 2) {
                    q[0] = q[1];
                }
            }
            if ((n & 0x1) == 0) {
                v *= x;
            }
            coeff *= f;
            function[n] = coeff * v;
        }
    }
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test033() throws Throwable {
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 0);
    double[] doubleArray0 = new double[7];
    doubleArray0[0] = (double) 0;
    doubleArray0[1] = (double) 0;
    doubleArray0[2] = (double) 0;
    doubleArray0[3] = (double) 0;
    doubleArray0[4] = 0.0;
    doubleArray0[5] = 0.0;
    doubleArray0[6] = (double) 0;
    // Undeclared exception!
    try {
        dSCompiler0.atanh(doubleArray0, (-1007), doubleArray0, 0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1007
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute inverse hyperbolic tangent of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param result array where result must be stored (for
 * inverse hyperbolic tangent the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
"public void add(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) {
    for (int i = 0; i < getSize(); ++i) {
        result[resultOffset + i] = lhs[lhsOffset + i] + rhs[rhsOffset + i];
    }
}","public void test044() throws Throwable {
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(2, 2);
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 0.0;
    doubleArray0[1] = (-804.6489);
    doubleArray0[2] = (double) 2;
    doubleArray0[3] = (double) 2;
    int int0 = (-1643);
    // Undeclared exception!
    try {
        dSCompiler0.add(doubleArray0, 2, doubleArray0, (-1643), doubleArray0, (-1643));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1643
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Perform addition of two derivative structures.
 * @param lhs array holding left hand side of addition
 * @param lhsOffset offset of the left hand side in its array
 * @param rhs array right hand side of addition
 * @param rhsOffset offset of the right hand side in its array
 * @param result array where result must be stored (it may be
 * one of the input arrays)
 * @param resultOffset offset of the result in its array
 */"
"public void acosh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {
    // create the function value and derivatives
    double[] function = new double[1 + order];
    final double x = operand[operandOffset];
    function[0] = FastMath.acosh(x);
    if (order > 0) {
        // the nth order derivative of acosh has the form:
        // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)
        // where P_n(x) is a degree n-1 polynomial with same parity as n-1
        // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...
        // the general recurrence relation for P_n is:
        // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)
        // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array
        final double[] p = new double[order];
        p[0] = 1;
        final double x2 = x * x;
        final double f = 1.0 / (x2 - 1);
        double coeff = FastMath.sqrt(f);
        function[1] = coeff * p[0];
        for (int n = 2; n <= order; ++n) {
            // update and evaluate polynomial P_n(x)
            double v = 0;
            p[n - 1] = (1 - n) * p[n - 2];
            for (int k = n - 1; k >= 0; k -= 2) {
                v = v * x2 + p[k];
                if (k > 2) {
                    p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];
                } else if (k == 2) {
                    p[0] = -p[1];
                }
            }
            if ((n & 0x1) == 0) {
                v *= x;
            }
            coeff *= f;
            function[n] = coeff * v;
        }
    }
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test055() throws Throwable {
    int int0 = 0;
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 0);
    double[] doubleArray0 = new double[0];
    // Undeclared exception!
    try {
        dSCompiler0.acosh(doubleArray0, 0, doubleArray0, (-3895));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute inverse hyperbolic cosine of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param result array where result must be stored (for
 * inverse hyperbolic cosine the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
"public void pow(final double[] operand, final int operandOffset, final int n, final double[] result, final int resultOffset) {
    if (n == 0) {
        // special case, x^0 = 1 for all x
        result[resultOffset] = 1.0;
        Arrays.fill(result, resultOffset + 1, resultOffset + getSize(), 0);
        return;
    }
    // create the power function value and derivatives
    // [x^n, nx^(n-1), n(n-1)x^(n-2), ... ]
    double[] function = new double[1 + order];
    if (n > 0) {
        // strictly positive power
        final int maxOrder = FastMath.min(order, n);
        double xk = FastMath.pow(operand[operandOffset], n - maxOrder);
        for (int i = maxOrder; i > 0; --i) {
            function[i] = xk;
            xk *= operand[operandOffset];
        }
        function[0] = xk;
    } else {
        // strictly negative power
        final double inv = 1.0 / operand[operandOffset];
        double xk = FastMath.pow(inv, -n);
        for (int i = 0; i <= order; ++i) {
            function[i] = xk;
            xk *= inv;
        }
    }
    double coefficient = n;
    for (int i = 1; i <= order; ++i) {
        function[i] *= coefficient;
        coefficient *= n - i;
    }
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test066() throws Throwable {
    int int0 = 0;
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(1596, 0);
    dSCompiler0.getSize();
    double[] doubleArray0 = new double[5];
    int int1 = 0;
    dSCompiler0.log10(doubleArray0, 0, doubleArray0, 0);
    doubleArray0[0] = (double) 1;
    doubleArray0[1] = (double) 1;
    doubleArray0[2] = (double) 1596;
    doubleArray0[3] = (double) 1;
    // Undeclared exception!
    try {
        dSCompiler0.pow(doubleArray0, 620, (-122), doubleArray0, 620);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 620
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute integer power of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param n power to apply
 * @param result array where result must be stored (for
 * power the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
"public void expm1(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {
    // create the function value and derivatives
    double[] function = new double[1 + order];
    function[0] = FastMath.expm1(operand[operandOffset]);
    Arrays.fill(function, 1, 1 + order, FastMath.exp(operand[operandOffset]));
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test077() throws Throwable {
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 97);
    double[] doubleArray0 = new double[7];
    doubleArray0[0] = (double) 0;
    doubleArray0[1] = (double) 0;
    doubleArray0[2] = (double) 97;
    doubleArray0[3] = (double) 97;
    doubleArray0[4] = 9.74480384E9;
    doubleArray0[5] = (double) 0;
    doubleArray0[6] = (double) 97;
    // Undeclared exception!
    try {
        dSCompiler0.expm1(doubleArray0, (-472), doubleArray0, (-472));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -472
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute exp(x) - 1 of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param result array where result must be stored (for
 * exponential the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
"public int getPartialDerivativeIndex(final int... orders) throws DimensionMismatchException, NumberIsTooLargeException {
    // safety check
    if (orders.length != getFreeParameters()) {
        throw new DimensionMismatchException(orders.length, getFreeParameters());
    }
    return getPartialDerivativeIndex(parameters, order, sizes, orders);
}","public void test088() throws Throwable {
    int int0 = 0;
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 0);
    double[] doubleArray0 = new double[8];
    dSCompiler0.atan(doubleArray0, 0, doubleArray0, 0);
    doubleArray0[0] = (double) 0;
    doubleArray0[1] = (double) 0;
    doubleArray0[2] = (double) 0;
    doubleArray0[3] = (double) 0;
    doubleArray0[4] = (double) 0;
    doubleArray0[5] = (double) 0;
    doubleArray0[6] = (double) 0;
    doubleArray0[7] = (double) 0;
    int int1 = 0;
    dSCompiler0.pow(doubleArray0, 0, 0, doubleArray0, 0);
    // Undeclared exception!
    try {
        dSCompiler0.getPartialDerivativeIndex((int[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Get the index of a partial derivative in the array.
 * <p>
 * If all orders are set to 0, then the 0<sup>th</sup> order derivative
 * is returned, which is the value of the function.
 * </p>
 * <p>The indices of derivatives are between 0 and {@link #getSize() getSize()} - 1.
 * Their specific order is fixed for a given compiler, but otherwise not
 * publicly specified. There are however some simple cases which have guaranteed
 * indices:
 * </p>
 * <ul>
 *   <li>the index of 0<sup>th</sup> order derivative is always 0</li>
 *   <li>if there is only 1 {@link #getFreeParameters() free parameter}, then the
 *   derivatives are sorted in increasing derivation order (i.e. f at index 0, df/dp
 *   at index 1, d<sup>2</sup>f/dp<sup>2</sup> at index 2 ...
 *   d<sup>k</sup>f/dp<sup>k</sup> at index k),</li>
 *   <li>if the {@link #getOrder() derivation order} is 1, then the derivatives
 *   are sorted in incresing free parameter order (i.e. f at index 0, df/dx<sub>1</sub>
 *   at index 1, df/dx<sub>2</sub> at index 2 ... df/dx<sub>k</sub> at index k),</li>
 *   <li>all other cases are not publicly specified</li>
 * </ul>
 * <p>
 * This method is the inverse of method {@link #getPartialDerivativeOrders(int)}
 * </p>
 * @param orders derivation orders with respect to each parameter
 * @return index of the partial derivative
 * @exception DimensionMismatchException if the numbers of parameters does not
 * match the instance
 * @exception NumberIsTooLargeException if sum of derivation orders is larger
 * than the instance limits
 * @see #getPartialDerivativeOrders(int)
 */"
"public void log(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {
    // create the function value and derivatives
    double[] function = new double[1 + order];
    function[0] = FastMath.log(operand[operandOffset]);
    if (order > 0) {
        double inv = 1.0 / operand[operandOffset];
        double xk = inv;
        for (int i = 1; i <= order; ++i) {
            function[i] = xk;
            xk *= -i * inv;
        }
    }
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test099() throws Throwable {
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(1, 1);
    double[] doubleArray0 = new double[8];
    doubleArray0[0] = (double) 1;
    doubleArray0[1] = (double) 1;
    doubleArray0[2] = 0.5;
    doubleArray0[3] = (double) 1;
    doubleArray0[4] = (double) 1;
    doubleArray0[5] = (double) 1;
    doubleArray0[6] = (double) 1;
    doubleArray0[7] = 2968.0;
    // Undeclared exception!
    try {
        dSCompiler0.log(doubleArray0, 1445, doubleArray0, (-5358));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 1445
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute natural logarithm of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param result array where result must be stored (for
 * logarithm the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
"public void exp(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {
    // create the function value and derivatives
    double[] function = new double[1 + order];
    Arrays.fill(function, FastMath.exp(operand[operandOffset]));
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test1010() throws Throwable {
    int int0 = 0;
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 0);
    double[] doubleArray0 = null;
    // Undeclared exception!
    try {
        dSCompiler0.exp((double[]) null, (-219), (double[]) null, 0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute exponential of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param result array where result must be stored (for
 * exponential the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
"public void tan(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {
    // create the function value and derivatives
    final double[] function = new double[1 + order];
    final double t = FastMath.tan(operand[operandOffset]);
    function[0] = t;
    if (order > 0) {
        // the nth order derivative of tan has the form:
        // dn(tan(x)/dxn = P_n(tan(x))
        // where P_n(t) is a degree n+1 polynomial with same parity as n+1
        // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...
        // the general recurrence relation for P_n is:
        // P_n(x) = (1+t^2) P_(n-1)'(t)
        // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array
        final double[] p = new double[order + 2];
        p[1] = 1;
        final double t2 = t * t;
        for (int n = 1; n <= order; ++n) {
            // update and evaluate polynomial P_n(t)
            double v = 0;
            p[n + 1] = n * p[n];
            for (int k = n + 1; k >= 0; k -= 2) {
                v = v * t2 + p[k];
                if (k > 2) {
                    p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];
                } else if (k == 2) {
                    p[0] = p[1];
                }
            }
            if ((n & 0x1) == 0) {
                v *= t;
            }
            function[n] = v;
        }
    }
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test1111() throws Throwable {
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 0);
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = (double) 0;
    doubleArray0[1] = (double) 0;
    doubleArray0[2] = (double) 0;
    doubleArray0[3] = (double) 0;
    doubleArray0[4] = (double) 0;
    doubleArray0[5] = (double) 0;
    dSCompiler0.expm1(doubleArray0, 0, doubleArray0, 0);
    int[] intArray0 = new int[0];
    dSCompiler0.getPartialDerivativeIndex(intArray0);
    // Undeclared exception!
    try {
        dSCompiler0.tan(doubleArray0, (-2159), doubleArray0, 0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -2159
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute tangent of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param result array where result must be stored (for
 * tangent the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
"public void linearCombination(final double a1, final double[] c1, final int offset1, final double a2, final double[] c2, final int offset2, final double a3, final double[] c3, final int offset3, final double a4, final double[] c4, final int offset4, final double[] result, final int resultOffset) {
    for (int i = 0; i < getSize(); ++i) {
        result[resultOffset + i] = MathArrays.linearCombination(a1, c1[offset1 + i], a2, c2[offset2 + i], a3, c3[offset3 + i], a4, c4[offset4 + i]);
    }
}","public void test1212() throws Throwable {
    int int0 = 1285;
    int int1 = 0;
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(1285, 0);
    double[] doubleArray0 = new double[7];
    doubleArray0[0] = 0.0;
    doubleArray0[1] = (double) 0;
    double[] doubleArray1 = new double[0];
    double[] doubleArray2 = new double[9];
    doubleArray2[0] = (-596.1902107531372);
    doubleArray2[1] = (-8.955768055535647E-8);
    doubleArray2[2] = 5976.126681621543;
    doubleArray2[3] = 1.5367772579193115;
    doubleArray2[4] = (double) 1285;
    doubleArray2[5] = 18.72;
    doubleArray2[6] = (double) 1285;
    doubleArray2[7] = (-1746.7742912364677);
    doubleArray2[8] = (double) 0;
    // Undeclared exception!
    try {
        dSCompiler0.linearCombination((-8.955768055535647E-8), doubleArray1, 0, (double) 1285, doubleArray0, 633, 5976.126681621543, doubleArray0, (-2416), (-1746.7742912364677), doubleArray1, 1285, doubleArray2, 1285);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute linear combination.
 * The derivative structure built will be a1 * ds1 + a2 * ds2 + a3 * ds3 + a4 * ds4
 * @param a1 first scale factor
 * @param c1 first base (unscaled) component
 * @param offset1 offset of first operand in its array
 * @param a2 second scale factor
 * @param c2 second base (unscaled) component
 * @param offset2 offset of second operand in its array
 * @param a3 third scale factor
 * @param c3 third base (unscaled) component
 * @param offset3 offset of third operand in its array
 * @param a4 fourth scale factor
 * @param c4 fourth base (unscaled) component
 * @param offset4 offset of fourth operand in its array
 * @param result array where result must be stored (it may be
 * one of the input arrays)
 * @param resultOffset offset of the result in its array
 */"
"public void pow(final double[] operand, final int operandOffset, final int n, final double[] result, final int resultOffset) {
    if (n == 0) {
        // special case, x^0 = 1 for all x
        result[resultOffset] = 1.0;
        Arrays.fill(result, resultOffset + 1, resultOffset + getSize(), 0);
        return;
    }
    // create the power function value and derivatives
    // [x^n, nx^(n-1), n(n-1)x^(n-2), ... ]
    double[] function = new double[1 + order];
    if (n > 0) {
        // strictly positive power
        final int maxOrder = FastMath.min(order, n);
        double xk = FastMath.pow(operand[operandOffset], n - maxOrder);
        for (int i = maxOrder; i > 0; --i) {
            function[i] = xk;
            xk *= operand[operandOffset];
        }
        function[0] = xk;
    } else {
        // strictly negative power
        final double inv = 1.0 / operand[operandOffset];
        double xk = FastMath.pow(inv, -n);
        for (int i = 0; i <= order; ++i) {
            function[i] = xk;
            xk *= inv;
        }
    }
    double coefficient = n;
    for (int i = 1; i <= order; ++i) {
        function[i] *= coefficient;
        coefficient *= n - i;
    }
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test1313() throws Throwable {
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 0);
    double[] doubleArray0 = new double[9];
    doubleArray0[0] = (double) 0;
    doubleArray0[1] = (double) 0;
    doubleArray0[2] = (double) 0;
    doubleArray0[3] = (double) 0;
    doubleArray0[4] = (double) 0;
    doubleArray0[5] = (double) 0;
    doubleArray0[6] = 0.0;
    doubleArray0[7] = (double) 0;
    doubleArray0[8] = (double) 0;
    dSCompiler0.pow(doubleArray0, 0, 2308, doubleArray0, 0);
}","/**
 * Compute integer power of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param n power to apply
 * @param result array where result must be stored (for
 * power the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
"public void linearCombination(final double a1, final double[] c1, final int offset1, final double a2, final double[] c2, final int offset2, final double a3, final double[] c3, final int offset3, final double a4, final double[] c4, final int offset4, final double[] result, final int resultOffset) {
    for (int i = 0; i < getSize(); ++i) {
        result[resultOffset + i] = MathArrays.linearCombination(a1, c1[offset1 + i], a2, c2[offset2 + i], a3, c3[offset3 + i], a4, c4[offset4 + i]);
    }
}","public void test1414() throws Throwable {
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(2, 2);
    double[] doubleArray0 = new double[0];
    double[] doubleArray1 = new double[9];
    doubleArray1[0] = (-1.7335469415174996E-8);
    doubleArray1[1] = (-1.7335469415174996E-8);
    doubleArray1[2] = (double) 2;
    doubleArray1[3] = (double) 2;
    doubleArray1[4] = (double) (-195);
    doubleArray1[5] = (double) 2;
    doubleArray1[6] = (-1.7335469415174996E-8);
    doubleArray1[7] = (double) 2;
    doubleArray1[8] = 886.1;
    double[] doubleArray2 = new double[2];
    doubleArray2[0] = (-1.7335469415174996E-8);
    doubleArray2[1] = 886.1;
    double[] doubleArray3 = new double[1];
    doubleArray3[0] = (-1.7335469415174996E-8);
    // Undeclared exception!
    try {
        dSCompiler0.linearCombination((double) 2, doubleArray0, 2, 886.1, doubleArray0, (-195), (-1.7335469415174996E-8), doubleArray1, 2, 0.0, doubleArray2, 754, doubleArray3, 2);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 2
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute linear combination.
 * The derivative structure built will be a1 * ds1 + a2 * ds2 + a3 * ds3 + a4 * ds4
 * @param a1 first scale factor
 * @param c1 first base (unscaled) component
 * @param offset1 offset of first operand in its array
 * @param a2 second scale factor
 * @param c2 second base (unscaled) component
 * @param offset2 offset of second operand in its array
 * @param a3 third scale factor
 * @param c3 third base (unscaled) component
 * @param offset3 offset of third operand in its array
 * @param a4 fourth scale factor
 * @param c4 fourth base (unscaled) component
 * @param offset4 offset of fourth operand in its array
 * @param result array where result must be stored (it may be
 * one of the input arrays)
 * @param resultOffset offset of the result in its array
 */"
"public void checkCompatibility(final DSCompiler compiler) throws DimensionMismatchException {
    if (parameters != compiler.parameters) {
        throw new DimensionMismatchException(parameters, compiler.parameters);
    }
    if (order != compiler.order) {
        throw new DimensionMismatchException(order, compiler.order);
    }
}","public void test1515() throws Throwable {
    int int0 = 0;
    int int1 = 731;
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 731);
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = (double) 731;
    doubleArray0[1] = (double) 0;
    doubleArray0[2] = (double) 0;
    int[] intArray0 = new int[9];
    intArray0[0] = 0;
    intArray0[1] = 0;
    intArray0[2] = 2611;
    intArray0[3] = 731;
    int int2 = 0;
    DSCompiler dSCompiler1 = DSCompiler.getCompiler(0, 0);
    try {
        dSCompiler0.checkCompatibility(dSCompiler1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 731 != 0
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Check rules set compatibility.
 * @param compiler other compiler to check against instance
 * @exception DimensionMismatchException if number of free parameters or orders are inconsistent
 */"
"public void asinh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {
    // create the function value and derivatives
    double[] function = new double[1 + order];
    final double x = operand[operandOffset];
    function[0] = FastMath.asinh(x);
    if (order > 0) {
        // the nth order derivative of asinh has the form:
        // dn(asinh(x)/dxn = P_n(x) / [x^2 + 1]^((2n-1)/2)
        // where P_n(x) is a degree n-1 polynomial with same parity as n-1
        // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 - 1 ...
        // the general recurrence relation for P_n is:
        // P_n(x) = (x^2+1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)
        // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array
        final double[] p = new double[order];
        p[0] = 1;
        final double x2 = x * x;
        final double f = 1.0 / (1 + x2);
        double coeff = FastMath.sqrt(f);
        function[1] = coeff * p[0];
        for (int n = 2; n <= order; ++n) {
            // update and evaluate polynomial P_n(x)
            double v = 0;
            p[n - 1] = (1 - n) * p[n - 2];
            for (int k = n - 1; k >= 0; k -= 2) {
                v = v * x2 + p[k];
                if (k > 2) {
                    p[k - 2] = (k - 1) * p[k - 1] + (k - 2 * n) * p[k - 3];
                } else if (k == 2) {
                    p[0] = p[1];
                }
            }
            if ((n & 0x1) == 0) {
                v *= x;
            }
            coeff *= f;
            function[n] = coeff * v;
        }
    }
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test1616() throws Throwable {
    int int0 = 0;
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 0);
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (double) 0;
    doubleArray0[1] = (-1382.2856743257173);
    doubleArray0[2] = (double) 0;
    doubleArray0[3] = (double) 0;
    doubleArray0[4] = (double) 0;
    int int1 = 430;
    int int2 = (-1);
    int int3 = 392;
    // Undeclared exception!
    try {
        dSCompiler0.asinh(doubleArray0, (-1), doubleArray0, 392);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute inverse hyperbolic sine of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param result array where result must be stored (for
 * inverse hyperbolic sine the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
"public static DSCompiler getCompiler(int parameters, int order) {
    // get the cached compilers
    final DSCompiler[][] cache = compilers.get();
    if (cache != null && cache.length > parameters && cache[parameters].length > order) {
        if (cache[parameters][order] != null) {
            // the compiler has already been created
            return cache[parameters][order];
        }
    }
    // we need to create more compilers
    final int maxParameters = FastMath.max(parameters, cache == null ? 0 : cache.length);
    final int maxOrder = FastMath.max(order, cache == null ? 0 : cache[0].length);
    final DSCompiler[][] newCache = new DSCompiler[maxParameters + 1][maxOrder + 1];
    if (cache != null) {
        // preserve the already created compilers
        for (int i = 0; i < cache.length; ++i) {
            System.arraycopy(cache[i], 0, newCache[i], 0, cache[i].length);
        }
    }
    // create the array in increasing diagonal order
    for (int diag = 0; diag <= parameters + order; ++diag) {
        for (int o = FastMath.max(0, diag - parameters); o <= FastMath.min(order, diag); ++o) {
            final int p = diag - o;
            if (newCache[p][o] == null) {
                final DSCompiler valueCompiler = (p == 0) ? null : newCache[p - 1][o];
                final DSCompiler derivativeCompiler = (o == 0) ? null : newCache[p][o - 1];
                newCache[p][o] = new DSCompiler(p, o, valueCompiler, derivativeCompiler);
            }
        }
    }
    // atomically reset the cached compilers array
    compilers.compareAndSet(cache, newCache);
    return newCache[parameters][order];
}","public void test1717() throws Throwable {
    int int0 = 4569;
    int int1 = 0;
    // Undeclared exception!
    DSCompiler.getCompiler(4569, 0);
}","/**
 * Get the compiler for number of free parameters and order.
 * @param parameters number of free parameters
 * @param order derivation order
 * @return cached rules set
 */"
"public void remainder(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) {
    // compute k such that lhs % rhs = lhs - k rhs
    final double rem = lhs[lhsOffset] % rhs[rhsOffset];
    final double k = FastMath.rint((lhs[lhsOffset] - rem) / rhs[rhsOffset]);
    // set up value
    result[resultOffset] = rem;
    // set up partial derivatives
    for (int i = 1; i < getSize(); ++i) {
        result[resultOffset + i] = lhs[lhsOffset + i] - k * rhs[rhsOffset + i];
    }
}","public void test1818() throws Throwable {
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 0);
    dSCompiler0.getPartialDerivativeOrders(0);
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = (double) 0;
    doubleArray0[1] = (double) 0;
    doubleArray0[2] = (double) 0;
    int int0 = (-1477);
    int int1 = 3;
    // Undeclared exception!
    try {
        dSCompiler0.remainder(doubleArray0, 0, doubleArray0, (-1477), doubleArray0, 3);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1477
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Perform remainder of two derivative structures.
 * @param lhs array holding left hand side of remainder
 * @param lhsOffset offset of the left hand side in its array
 * @param rhs array right hand side of remainder
 * @param rhsOffset offset of the right hand side in its array
 * @param result array where result must be stored (it may be
 * one of the input arrays)
 * @param resultOffset offset of the result in its array
 */"
"public void divide(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) {
    final double[] reciprocal = new double[getSize()];
    pow(rhs, lhsOffset, -1, reciprocal, 0);
    multiply(lhs, lhsOffset, reciprocal, 0, result, resultOffset);
}","public void test1919() throws Throwable {
    int int0 = 906;
    int int1 = 0;
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(906, 0);
    double[] doubleArray0 = null;
    int int2 = 1502;
    // Undeclared exception!
    try {
        dSCompiler0.divide((double[]) null, 906, (double[]) null, 906, (double[]) null, 1502);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Perform division of two derivative structures.
 * @param lhs array holding left hand side of division
 * @param lhsOffset offset of the left hand side in its array
 * @param rhs array right hand side of division
 * @param rhsOffset offset of the right hand side in its array
 * @param result array where result must be stored (for
 * division the result array <em>cannot</em> be one of
 * the input arrays)
 * @param resultOffset offset of the result in its array
 */"
"public void divide(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) {
    final double[] reciprocal = new double[getSize()];
    pow(rhs, lhsOffset, -1, reciprocal, 0);
    multiply(lhs, lhsOffset, reciprocal, 0, result, resultOffset);
}","public void test2020() throws Throwable {
    int int0 = 0;
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 0);
    double[] doubleArray0 = new double[9];
    doubleArray0[0] = (double) 0;
    doubleArray0[1] = (double) 0;
    doubleArray0[2] = (double) 0;
    doubleArray0[3] = (double) 0;
    doubleArray0[4] = (double) 0;
    doubleArray0[5] = (double) 0;
    doubleArray0[6] = (double) 0;
    doubleArray0[7] = (double) 0;
    doubleArray0[8] = (double) 0;
    // Undeclared exception!
    try {
        dSCompiler0.divide(doubleArray0, (-6852), doubleArray0, (-6852), doubleArray0, 361);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -6852
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Perform division of two derivative structures.
 * @param lhs array holding left hand side of division
 * @param lhsOffset offset of the left hand side in its array
 * @param rhs array right hand side of division
 * @param rhsOffset offset of the right hand side in its array
 * @param result array where result must be stored (for
 * division the result array <em>cannot</em> be one of
 * the input arrays)
 * @param resultOffset offset of the result in its array
 */"
"public void multiply(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) {
    for (int i = 0; i < multIndirection.length; ++i) {
        final int[][] mappingI = multIndirection[i];
        double r = 0;
        for (int j = 0; j < mappingI.length; ++j) {
            r += mappingI[j][0] * lhs[lhsOffset + mappingI[j][1]] * rhs[rhsOffset + mappingI[j][2]];
        }
        result[resultOffset + i] = r;
    }
}","public void test2121() throws Throwable {
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 2);
    dSCompiler0.getPartialDerivativeOrders(0);
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = (double) 0;
    doubleArray0[1] = (double) 0;
    // Undeclared exception!
    try {
        dSCompiler0.multiply((double[]) null, 0, doubleArray0, 2, doubleArray0, 0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Perform multiplication of two derivative structures.
 * @param lhs array holding left hand side of multiplication
 * @param lhsOffset offset of the left hand side in its array
 * @param rhs array right hand side of multiplication
 * @param rhsOffset offset of the right hand side in its array
 * @param result array where result must be stored (for
 * multiplication the result array <em>cannot</em> be one of
 * the input arrays)
 * @param resultOffset offset of the result in its array
 */"
"public void cosh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {
    // create the function value and derivatives
    double[] function = new double[1 + order];
    function[0] = FastMath.cosh(operand[operandOffset]);
    if (order > 0) {
        function[1] = FastMath.sinh(operand[operandOffset]);
        for (int i = 2; i <= order; ++i) {
            function[i] = function[i - 2];
        }
    }
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test2222() throws Throwable {
    int int0 = 0;
    int int1 = 0;
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 0);
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = (double) 0;
    doubleArray0[1] = (double) 0;
    // Undeclared exception!
    try {
        dSCompiler0.cosh(doubleArray0, (-1250), doubleArray0, 0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1250
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute hyperbolic cosine of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param result array where result must be stored (for
 * hyperbolic cosine the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
"public void cosh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {
    // create the function value and derivatives
    double[] function = new double[1 + order];
    function[0] = FastMath.cosh(operand[operandOffset]);
    if (order > 0) {
        function[1] = FastMath.sinh(operand[operandOffset]);
        for (int i = 2; i <= order; ++i) {
            function[i] = function[i - 2];
        }
    }
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test2323() throws Throwable {
    int int0 = 458;
    int int1 = 0;
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(458, 0);
    double[] doubleArray0 = new double[9];
    doubleArray0[0] = (double) 458;
    doubleArray0[1] = (double) 0;
    doubleArray0[2] = (double) 458;
    doubleArray0[3] = 0.0;
    doubleArray0[4] = (double) 0;
    doubleArray0[5] = (double) 0;
    doubleArray0[6] = (double) 458;
    doubleArray0[7] = (double) 458;
    doubleArray0[8] = (double) 458;
    dSCompiler0.atan(doubleArray0, 0, doubleArray0, 0);
    // Undeclared exception!
    try {
        dSCompiler0.cosh(doubleArray0, 1529, doubleArray0, 458);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 1529
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute hyperbolic cosine of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param result array where result must be stored (for
 * hyperbolic cosine the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
"public void rootN(final double[] operand, final int operandOffset, final int n, final double[] result, final int resultOffset) {
    // create the function value and derivatives
    // [x^(1/n), (1/n)x^((1/n)-1), (1-n)/n^2x^((1/n)-2), ... ]
    double[] function = new double[1 + order];
    double xk;
    if (n == 2) {
        function[0] = FastMath.sqrt(operand[operandOffset]);
        xk = 0.5 / function[0];
    } else if (n == 3) {
        function[0] = FastMath.cbrt(operand[operandOffset]);
        xk = 1.0 / (3.0 * function[0] * function[0]);
    } else {
        function[0] = FastMath.pow(operand[operandOffset], 1.0 / n);
        xk = 1.0 / (n * FastMath.pow(function[0], n - 1));
    }
    final double nReciprocal = 1.0 / n;
    final double xReciprocal = 1.0 / operand[operandOffset];
    for (int i = 1; i <= order; ++i) {
        function[i] = xk;
        xk *= xReciprocal * (nReciprocal - i);
    }
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test2424() throws Throwable {
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 0);
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (double) 0;
    doubleArray0[1] = (double) 0;
    doubleArray0[2] = (double) 0;
    doubleArray0[3] = (double) 0;
    doubleArray0[4] = (double) 0;
    double[] doubleArray1 = new double[0];
    // Undeclared exception!
    try {
        dSCompiler0.rootN(doubleArray0, 4544, 3102, doubleArray1, 4544);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 4544
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute n<sup>th</sup> root of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param n order of the root
 * @param result array where result must be stored (for
 * n<sup>th</sup> root the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
"public void rootN(final double[] operand, final int operandOffset, final int n, final double[] result, final int resultOffset) {
    // create the function value and derivatives
    // [x^(1/n), (1/n)x^((1/n)-1), (1-n)/n^2x^((1/n)-2), ... ]
    double[] function = new double[1 + order];
    double xk;
    if (n == 2) {
        function[0] = FastMath.sqrt(operand[operandOffset]);
        xk = 0.5 / function[0];
    } else if (n == 3) {
        function[0] = FastMath.cbrt(operand[operandOffset]);
        xk = 1.0 / (3.0 * function[0] * function[0]);
    } else {
        function[0] = FastMath.pow(operand[operandOffset], 1.0 / n);
        xk = 1.0 / (n * FastMath.pow(function[0], n - 1));
    }
    final double nReciprocal = 1.0 / n;
    final double xReciprocal = 1.0 / operand[operandOffset];
    for (int i = 1; i <= order; ++i) {
        function[i] = xk;
        xk *= xReciprocal * (nReciprocal - i);
    }
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test2525() throws Throwable {
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(3, 3);
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = (double) 3;
    doubleArray0[1] = (double) 3;
    // Undeclared exception!
    try {
        dSCompiler0.rootN(doubleArray0, (-1684), 3, doubleArray0, 1251);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1684
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute n<sup>th</sup> root of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param n order of the root
 * @param result array where result must be stored (for
 * n<sup>th</sup> root the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
"public void pow(final double[] operand, final int operandOffset, final double p, final double[] result, final int resultOffset) {
    // create the function value and derivatives
    // [x^p, px^(p-1), p(p-1)x^(p-2), ... ]
    double[] function = new double[1 + order];
    double xk = FastMath.pow(operand[operandOffset], p - order);
    for (int i = order; i > 0; --i) {
        function[i] = xk;
        xk *= operand[operandOffset];
    }
    function[0] = xk;
    double coefficient = p;
    for (int i = 1; i <= order; ++i) {
        function[i] *= coefficient;
        coefficient *= p - i;
    }
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test2626() throws Throwable {
    int int0 = 0;
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 0);
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (double) 0;
    doubleArray0[1] = (double) 0;
    doubleArray0[2] = (-3631.0);
    doubleArray0[3] = (double) 0;
    doubleArray0[4] = (double) 0;
    int int1 = 1241;
    // Undeclared exception!
    try {
        dSCompiler0.pow(doubleArray0, 1241, 0.0, doubleArray0, (-352));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 1241
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute power of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param p power to apply
 * @param result array where result must be stored (for
 * power the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
"public void atan2(final double[] y, final int yOffset, final double[] x, final int xOffset, final double[] result, final int resultOffset) {
    // compute r = sqrt(x^2+y^2)
    double[] tmp1 = new double[getSize()];
    // x^2
    multiply(x, xOffset, x, xOffset, tmp1, 0);
    double[] tmp2 = new double[getSize()];
    // y^2
    multiply(y, yOffset, y, yOffset, tmp2, 0);
    // x^2 + y^2
    add(tmp1, 0, tmp2, 0, tmp2, 0);
    // r = sqrt(x^2 + y^2)
    rootN(tmp2, 0, 2, tmp1, 0);
    if (x[xOffset] >= 0) {
        // compute atan2(y, x) = 2 atan(y / (r + x))
        // r + x
        add(tmp1, 0, x, xOffset, tmp2, 0);
        // y /(r + x)
        divide(y, yOffset, tmp2, 0, tmp1, 0);
        // atan(y / (r + x))
        atan(tmp1, 0, tmp2, 0);
        for (int i = 0; i < tmp2.length; ++i) {
            // 2 * atan(y / (r + x))
            result[resultOffset + i] = 2 * tmp2[i];
        }
    } else {
        // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))
        // r - x
        subtract(tmp1, 0, x, xOffset, tmp2, 0);
        // y /(r - x)
        divide(y, yOffset, tmp2, 0, tmp1, 0);
        // atan(y / (r - x))
        atan(tmp1, 0, tmp2, 0);
        result[resultOffset] = // +/-pi - 2 * atan(y / (r - x))
        ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0];
        for (int i = 1; i < tmp2.length; ++i) {
            // +/-pi - 2 * atan(y / (r - x))
            result[resultOffset + i] = -2 * tmp2[i];
        }
    }
    // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly
}","public void test2727() throws Throwable {
    int int0 = 0;
    int int1 = 0;
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 0);
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = (double) 0;
    doubleArray0[1] = (double) 0;
    int int2 = (-2387);
    // Undeclared exception!
    try {
        dSCompiler0.atan2(doubleArray0, (-2387), doubleArray0, 0, doubleArray0, 0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -2387
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute two arguments arc tangent of a derivative structure.
 * @param y array holding the first operand
 * @param yOffset offset of the first operand in its array
 * @param x array holding the second operand
 * @param xOffset offset of the second operand in its array
 * @param result array where result must be stored (for
 * two arguments arc tangent the result array <em>cannot</em>
 * be the input array)
 * @param resultOffset offset of the result in its array
 */"
"public void linearCombination(final double a1, final double[] c1, final int offset1, final double a2, final double[] c2, final int offset2, final double[] result, final int resultOffset) {
    for (int i = 0; i < getSize(); ++i) {
        result[resultOffset + i] = MathArrays.linearCombination(a1, c1[offset1 + i], a2, c2[offset2 + i]);
    }
}","public void test2828() throws Throwable {
    int int0 = 0;
    int int1 = 520;
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 520);
    double[] doubleArray0 = new double[8];
    doubleArray0[0] = 484.40437685;
    doubleArray0[1] = (double) 520;
    doubleArray0[2] = (double) 520;
    doubleArray0[3] = (double) 0;
    doubleArray0[4] = (double) 520;
    doubleArray0[5] = 2.116316283183901E-290;
    double[] doubleArray1 = new double[2];
    doubleArray1[0] = 2.116316283183901E-290;
    doubleArray1[1] = (double) 0;
    // Undeclared exception!
    try {
        dSCompiler0.linearCombination(0.0, doubleArray0, 520, 2.116316283183901E-290, doubleArray0, 1443, doubleArray1, 520);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 520
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute linear combination.
 * The derivative structure built will be a1 * ds1 + a2 * ds2
 * @param a1 first scale factor
 * @param c1 first base (unscaled) component
 * @param offset1 offset of first operand in its array
 * @param a2 second scale factor
 * @param c2 second base (unscaled) component
 * @param offset2 offset of second operand in its array
 * @param result array where result must be stored (it may be
 * one of the input arrays)
 * @param resultOffset offset of the result in its array
 */"
"public void tan(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {
    // create the function value and derivatives
    final double[] function = new double[1 + order];
    final double t = FastMath.tan(operand[operandOffset]);
    function[0] = t;
    if (order > 0) {
        // the nth order derivative of tan has the form:
        // dn(tan(x)/dxn = P_n(tan(x))
        // where P_n(t) is a degree n+1 polynomial with same parity as n+1
        // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...
        // the general recurrence relation for P_n is:
        // P_n(x) = (1+t^2) P_(n-1)'(t)
        // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array
        final double[] p = new double[order + 2];
        p[1] = 1;
        final double t2 = t * t;
        for (int n = 1; n <= order; ++n) {
            // update and evaluate polynomial P_n(t)
            double v = 0;
            p[n + 1] = n * p[n];
            for (int k = n + 1; k >= 0; k -= 2) {
                v = v * t2 + p[k];
                if (k > 2) {
                    p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];
                } else if (k == 2) {
                    p[0] = p[1];
                }
            }
            if ((n & 0x1) == 0) {
                v *= t;
            }
            function[n] = v;
        }
    }
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test2929() throws Throwable {
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 0);
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (double) 0;
    doubleArray0[1] = (double) 0;
    doubleArray0[2] = (double) 0;
    doubleArray0[3] = (double) 0;
    doubleArray0[4] = 193.364787875037;
    dSCompiler0.remainder(doubleArray0, 3, doubleArray0, 0, doubleArray0, 0);
    // Undeclared exception!
    try {
        dSCompiler0.tan((double[]) null, 2019, (double[]) null, 0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute tangent of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param result array where result must be stored (for
 * tangent the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
"public void acos(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {
    // create the function value and derivatives
    double[] function = new double[1 + order];
    final double x = operand[operandOffset];
    function[0] = FastMath.acos(x);
    if (order > 0) {
        // the nth order derivative of acos has the form:
        // dn(acos(x)/dxn = P_n(x) / [1 - x^2]^((2n-1)/2)
        // where P_n(x) is a degree n-1 polynomial with same parity as n-1
        // P_1(x) = -1, P_2(x) = -x, P_3(x) = -2x^2 - 1 ...
        // the general recurrence relation for P_n is:
        // P_n(x) = (1-x^2) P_(n-1)'(x) + (2n-3) x P_(n-1)(x)
        // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array
        final double[] p = new double[order];
        p[0] = -1;
        final double x2 = x * x;
        final double f = 1.0 / (1 - x2);
        double coeff = FastMath.sqrt(f);
        function[1] = coeff * p[0];
        for (int n = 2; n <= order; ++n) {
            // update and evaluate polynomial P_n(x)
            double v = 0;
            p[n - 1] = (n - 1) * p[n - 2];
            for (int k = n - 1; k >= 0; k -= 2) {
                v = v * x2 + p[k];
                if (k > 2) {
                    p[k - 2] = (k - 1) * p[k - 1] + (2 * n - k) * p[k - 3];
                } else if (k == 2) {
                    p[0] = p[1];
                }
            }
            if ((n & 0x1) == 0) {
                v *= x;
            }
            coeff *= f;
            function[n] = coeff * v;
        }
    }
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test3030() throws Throwable {
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 0);
    double[] doubleArray0 = new double[8];
    doubleArray0[0] = (double) 0;
    doubleArray0[1] = (double) 0;
    doubleArray0[2] = (double) 0;
    doubleArray0[3] = (double) 0;
    doubleArray0[4] = (double) 0;
    doubleArray0[5] = (double) 0;
    doubleArray0[6] = (double) 0;
    doubleArray0[7] = (double) 0;
    double[] doubleArray1 = new double[8];
    doubleArray1[0] = (double) (-1);
    doubleArray1[1] = (double) (-1);
    doubleArray1[2] = (double) (-1);
    doubleArray1[3] = (double) 0;
    doubleArray1[4] = (double) (-1);
    doubleArray1[5] = (double) (-1);
    doubleArray1[6] = (-1743.0);
    doubleArray1[7] = (double) (-1);
    // Undeclared exception!
    try {
        dSCompiler0.acos(doubleArray0, (-1), doubleArray1, 0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute arc cosine of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param result array where result must be stored (for
 * arc cosine the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
"public void multiply(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) {
    for (int i = 0; i < multIndirection.length; ++i) {
        final int[][] mappingI = multIndirection[i];
        double r = 0;
        for (int j = 0; j < mappingI.length; ++j) {
            r += mappingI[j][0] * lhs[lhsOffset + mappingI[j][1]] * rhs[rhsOffset + mappingI[j][2]];
        }
        result[resultOffset + i] = r;
    }
}","public void test3131() throws Throwable {
    int int0 = 0;
    int int1 = 0;
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 0);
    double[] doubleArray0 = null;
    int int2 = 0;
    // Undeclared exception!
    try {
        dSCompiler0.multiply((double[]) null, 0, (double[]) null, 0, (double[]) null, 0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Perform multiplication of two derivative structures.
 * @param lhs array holding left hand side of multiplication
 * @param lhsOffset offset of the left hand side in its array
 * @param rhs array right hand side of multiplication
 * @param rhsOffset offset of the right hand side in its array
 * @param result array where result must be stored (for
 * multiplication the result array <em>cannot</em> be one of
 * the input arrays)
 * @param resultOffset offset of the result in its array
 */"
"public void log(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {
    // create the function value and derivatives
    double[] function = new double[1 + order];
    function[0] = FastMath.log(operand[operandOffset]);
    if (order > 0) {
        double inv = 1.0 / operand[operandOffset];
        double xk = inv;
        for (int i = 1; i <= order; ++i) {
            function[i] = xk;
            xk *= -i * inv;
        }
    }
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test3232() throws Throwable {
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(863, 0);
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (double) 0;
    doubleArray0[1] = 0.0;
    doubleArray0[2] = (double) 0;
    doubleArray0[3] = (double) 863;
    doubleArray0[4] = (double) 0;
    dSCompiler0.log(doubleArray0, 0, doubleArray0, 1);
}","/**
 * Compute natural logarithm of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param result array where result must be stored (for
 * logarithm the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
"public void cos(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {
    // create the function value and derivatives
    double[] function = new double[1 + order];
    function[0] = FastMath.cos(operand[operandOffset]);
    if (order > 0) {
        function[1] = -FastMath.sin(operand[operandOffset]);
        for (int i = 2; i <= order; ++i) {
            function[i] = -function[i - 2];
        }
    }
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test3333() throws Throwable {
    int int0 = 0;
    int int1 = 245;
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 245);
    double[] doubleArray0 = new double[7];
    doubleArray0[0] = (double) 245;
    doubleArray0[1] = (double) 0;
    doubleArray0[2] = (double) 245;
    doubleArray0[3] = (double) 0;
    doubleArray0[4] = (double) 0;
    int int2 = 2085;
    // Undeclared exception!
    try {
        dSCompiler0.cos(doubleArray0, 918, doubleArray0, (-740));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 918
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute cosine of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param result array where result must be stored (for
 * cosine the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
"public void acos(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {
    // create the function value and derivatives
    double[] function = new double[1 + order];
    final double x = operand[operandOffset];
    function[0] = FastMath.acos(x);
    if (order > 0) {
        // the nth order derivative of acos has the form:
        // dn(acos(x)/dxn = P_n(x) / [1 - x^2]^((2n-1)/2)
        // where P_n(x) is a degree n-1 polynomial with same parity as n-1
        // P_1(x) = -1, P_2(x) = -x, P_3(x) = -2x^2 - 1 ...
        // the general recurrence relation for P_n is:
        // P_n(x) = (1-x^2) P_(n-1)'(x) + (2n-3) x P_(n-1)(x)
        // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array
        final double[] p = new double[order];
        p[0] = -1;
        final double x2 = x * x;
        final double f = 1.0 / (1 - x2);
        double coeff = FastMath.sqrt(f);
        function[1] = coeff * p[0];
        for (int n = 2; n <= order; ++n) {
            // update and evaluate polynomial P_n(x)
            double v = 0;
            p[n - 1] = (n - 1) * p[n - 2];
            for (int k = n - 1; k >= 0; k -= 2) {
                v = v * x2 + p[k];
                if (k > 2) {
                    p[k - 2] = (k - 1) * p[k - 1] + (2 * n - k) * p[k - 3];
                } else if (k == 2) {
                    p[0] = p[1];
                }
            }
            if ((n & 0x1) == 0) {
                v *= x;
            }
            coeff *= f;
            function[n] = coeff * v;
        }
    }
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test3434() throws Throwable {
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 0);
    double[] doubleArray0 = new double[3];
    doubleArray0[0] = (double) 0;
    doubleArray0[1] = (double) 0;
    doubleArray0[2] = (double) 0;
    dSCompiler0.acos(doubleArray0, 0, doubleArray0, 1);
}","/**
 * Compute arc cosine of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param result array where result must be stored (for
 * arc cosine the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
"public void tan(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {
    // create the function value and derivatives
    final double[] function = new double[1 + order];
    final double t = FastMath.tan(operand[operandOffset]);
    function[0] = t;
    if (order > 0) {
        // the nth order derivative of tan has the form:
        // dn(tan(x)/dxn = P_n(tan(x))
        // where P_n(t) is a degree n+1 polynomial with same parity as n+1
        // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...
        // the general recurrence relation for P_n is:
        // P_n(x) = (1+t^2) P_(n-1)'(t)
        // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array
        final double[] p = new double[order + 2];
        p[1] = 1;
        final double t2 = t * t;
        for (int n = 1; n <= order; ++n) {
            // update and evaluate polynomial P_n(t)
            double v = 0;
            p[n + 1] = n * p[n];
            for (int k = n + 1; k >= 0; k -= 2) {
                v = v * t2 + p[k];
                if (k > 2) {
                    p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];
                } else if (k == 2) {
                    p[0] = p[1];
                }
            }
            if ((n & 0x1) == 0) {
                v *= t;
            }
            function[n] = v;
        }
    }
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test3535() throws Throwable {
    int int0 = 649;
    int int1 = 0;
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(649, 0);
    double[] doubleArray0 = null;
    int int2 = 0;
    int int3 = (-133);
    // Undeclared exception!
    try {
        dSCompiler0.tan((double[]) null, (-133), (double[]) null, 0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute tangent of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param result array where result must be stored (for
 * tangent the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
"public void log1p(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {
    // create the function value and derivatives
    double[] function = new double[1 + order];
    function[0] = FastMath.log1p(operand[operandOffset]);
    if (order > 0) {
        double inv = 1.0 / (1.0 + operand[operandOffset]);
        double xk = inv;
        for (int i = 1; i <= order; ++i) {
            function[i] = xk;
            xk *= -i * inv;
        }
    }
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test3636() throws Throwable {
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 0);
    dSCompiler0.getSize();
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = (double) 0;
    doubleArray0[1] = (-1543.289897274249);
    doubleArray0[2] = (double) 0;
    doubleArray0[3] = (double) 1;
    doubleArray0[4] = (double) 1;
    // Undeclared exception!
    try {
        dSCompiler0.log1p(doubleArray0, (-469), doubleArray0, 47);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -469
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Computes shifted logarithm of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param result array where result must be stored (for
 * shifted logarithm the result array <em>cannot</em> be the input array)
 * @param resultOffset offset of the result in its array
 */"
"public void tanh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {
    // create the function value and derivatives
    final double[] function = new double[1 + order];
    final double t = FastMath.tanh(operand[operandOffset]);
    function[0] = t;
    if (order > 0) {
        // the nth order derivative of tanh has the form:
        // dn(tanh(x)/dxn = P_n(tanh(x))
        // where P_n(t) is a degree n+1 polynomial with same parity as n+1
        // P_0(t) = t, P_1(t) = 1 - t^2, P_2(t) = -2 t (1 - t^2) ...
        // the general recurrence relation for P_n is:
        // P_n(x) = (1-t^2) P_(n-1)'(t)
        // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array
        final double[] p = new double[order + 2];
        p[1] = 1;
        final double t2 = t * t;
        for (int n = 1; n <= order; ++n) {
            // update and evaluate polynomial P_n(t)
            double v = 0;
            p[n + 1] = -n * p[n];
            for (int k = n + 1; k >= 0; k -= 2) {
                v = v * t2 + p[k];
                if (k > 2) {
                    p[k - 2] = (k - 1) * p[k - 1] - (k - 3) * p[k - 3];
                } else if (k == 2) {
                    p[0] = p[1];
                }
            }
            if ((n & 0x1) == 0) {
                v *= t;
            }
            function[n] = v;
        }
    }
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test3737() throws Throwable {
    int int0 = 0;
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 0);
    double[] doubleArray0 = new double[0];
    int int1 = (-1943);
    // Undeclared exception!
    try {
        dSCompiler0.tanh(doubleArray0, (-1943), doubleArray0, (-3224));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1943
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute hyperbolic tangent of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param result array where result must be stored (for
 * hyperbolic tangent the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
"public void asin(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {
    // create the function value and derivatives
    double[] function = new double[1 + order];
    final double x = operand[operandOffset];
    function[0] = FastMath.asin(x);
    if (order > 0) {
        // the nth order derivative of asin has the form:
        // dn(asin(x)/dxn = P_n(x) / [1 - x^2]^((2n-1)/2)
        // where P_n(x) is a degree n-1 polynomial with same parity as n-1
        // P_1(x) = 1, P_2(x) = x, P_3(x) = 2x^2 + 1 ...
        // the general recurrence relation for P_n is:
        // P_n(x) = (1-x^2) P_(n-1)'(x) + (2n-3) x P_(n-1)(x)
        // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array
        final double[] p = new double[order];
        p[0] = 1;
        final double x2 = x * x;
        final double f = 1.0 / (1 - x2);
        double coeff = FastMath.sqrt(f);
        function[1] = coeff * p[0];
        for (int n = 2; n <= order; ++n) {
            // update and evaluate polynomial P_n(x)
            double v = 0;
            p[n - 1] = (n - 1) * p[n - 2];
            for (int k = n - 1; k >= 0; k -= 2) {
                v = v * x2 + p[k];
                if (k > 2) {
                    p[k - 2] = (k - 1) * p[k - 1] + (2 * n - k) * p[k - 3];
                } else if (k == 2) {
                    p[0] = p[1];
                }
            }
            if ((n & 0x1) == 0) {
                v *= x;
            }
            coeff *= f;
            function[n] = coeff * v;
        }
    }
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test3838() throws Throwable {
    int int0 = 0;
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(36, 0);
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = (double) 0;
    doubleArray0[1] = (double) 36;
    doubleArray0[2] = (double) 0;
    doubleArray0[3] = (double) 36;
    doubleArray0[4] = (double) 0;
    doubleArray0[5] = (double) 36;
    // Undeclared exception!
    try {
        dSCompiler0.asin(doubleArray0, 36, doubleArray0, 0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 36
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute arc sine of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param result array where result must be stored (for
 * arc sine the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
"public void asin(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {
    // create the function value and derivatives
    double[] function = new double[1 + order];
    final double x = operand[operandOffset];
    function[0] = FastMath.asin(x);
    if (order > 0) {
        // the nth order derivative of asin has the form:
        // dn(asin(x)/dxn = P_n(x) / [1 - x^2]^((2n-1)/2)
        // where P_n(x) is a degree n-1 polynomial with same parity as n-1
        // P_1(x) = 1, P_2(x) = x, P_3(x) = 2x^2 + 1 ...
        // the general recurrence relation for P_n is:
        // P_n(x) = (1-x^2) P_(n-1)'(x) + (2n-3) x P_(n-1)(x)
        // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array
        final double[] p = new double[order];
        p[0] = 1;
        final double x2 = x * x;
        final double f = 1.0 / (1 - x2);
        double coeff = FastMath.sqrt(f);
        function[1] = coeff * p[0];
        for (int n = 2; n <= order; ++n) {
            // update and evaluate polynomial P_n(x)
            double v = 0;
            p[n - 1] = (n - 1) * p[n - 2];
            for (int k = n - 1; k >= 0; k -= 2) {
                v = v * x2 + p[k];
                if (k > 2) {
                    p[k - 2] = (k - 1) * p[k - 1] + (2 * n - k) * p[k - 3];
                } else if (k == 2) {
                    p[0] = p[1];
                }
            }
            if ((n & 0x1) == 0) {
                v *= x;
            }
            coeff *= f;
            function[n] = coeff * v;
        }
    }
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test3939() throws Throwable {
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 0);
    dSCompiler0.getOrder();
    double[] doubleArray0 = new double[3];
    DSCompiler dSCompiler1 = DSCompiler.getCompiler(0, 0);
    dSCompiler0.checkCompatibility(dSCompiler1);
    doubleArray0[0] = (double) 0;
    doubleArray0[1] = (double) 0;
    doubleArray0[2] = 3.141592653589793;
    dSCompiler0.exp(doubleArray0, 0, doubleArray0, 0);
    // Undeclared exception!
    try {
        dSCompiler0.asin(doubleArray0, (-263), doubleArray0, (-526));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -263
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute arc sine of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param result array where result must be stored (for
 * arc sine the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
"public void log10(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {
    // create the function value and derivatives
    double[] function = new double[1 + order];
    function[0] = FastMath.log10(operand[operandOffset]);
    if (order > 0) {
        double inv = 1.0 / operand[operandOffset];
        double xk = inv / FastMath.log(10.0);
        for (int i = 1; i <= order; ++i) {
            function[i] = xk;
            xk *= -i * inv;
        }
    }
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test4040() throws Throwable {
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(2038, 0);
    // Undeclared exception!
    try {
        dSCompiler0.log10((double[]) null, 2038, (double[]) null, 0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Computes base 10 logarithm of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param result array where result must be stored (for
 * base 10 logarithm the result array <em>cannot</em> be the input array)
 * @param resultOffset offset of the result in its array
 */"
"public int getPartialDerivativeIndex(final int... orders) throws DimensionMismatchException, NumberIsTooLargeException {
    // safety check
    if (orders.length != getFreeParameters()) {
        throw new DimensionMismatchException(orders.length, getFreeParameters());
    }
    return getPartialDerivativeIndex(parameters, order, sizes, orders);
}","public void test4141() throws Throwable {
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 0);
    int[] intArray0 = new int[8];
    intArray0[0] = 0;
    intArray0[1] = 0;
    intArray0[2] = 0;
    intArray0[3] = 0;
    intArray0[4] = 0;
    intArray0[5] = 0;
    intArray0[6] = 0;
    intArray0[7] = 0;
    try {
        dSCompiler0.getPartialDerivativeIndex(intArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 8 != 0
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Get the index of a partial derivative in the array.
 * <p>
 * If all orders are set to 0, then the 0<sup>th</sup> order derivative
 * is returned, which is the value of the function.
 * </p>
 * <p>The indices of derivatives are between 0 and {@link #getSize() getSize()} - 1.
 * Their specific order is fixed for a given compiler, but otherwise not
 * publicly specified. There are however some simple cases which have guaranteed
 * indices:
 * </p>
 * <ul>
 *   <li>the index of 0<sup>th</sup> order derivative is always 0</li>
 *   <li>if there is only 1 {@link #getFreeParameters() free parameter}, then the
 *   derivatives are sorted in increasing derivation order (i.e. f at index 0, df/dp
 *   at index 1, d<sup>2</sup>f/dp<sup>2</sup> at index 2 ...
 *   d<sup>k</sup>f/dp<sup>k</sup> at index k),</li>
 *   <li>if the {@link #getOrder() derivation order} is 1, then the derivatives
 *   are sorted in incresing free parameter order (i.e. f at index 0, df/dx<sub>1</sub>
 *   at index 1, df/dx<sub>2</sub> at index 2 ... df/dx<sub>k</sub> at index k),</li>
 *   <li>all other cases are not publicly specified</li>
 * </ul>
 * <p>
 * This method is the inverse of method {@link #getPartialDerivativeOrders(int)}
 * </p>
 * @param orders derivation orders with respect to each parameter
 * @return index of the partial derivative
 * @exception DimensionMismatchException if the numbers of parameters does not
 * match the instance
 * @exception NumberIsTooLargeException if sum of derivation orders is larger
 * than the instance limits
 * @see #getPartialDerivativeOrders(int)
 */"
"public static DSCompiler getCompiler(int parameters, int order) {
    // get the cached compilers
    final DSCompiler[][] cache = compilers.get();
    if (cache != null && cache.length > parameters && cache[parameters].length > order) {
        if (cache[parameters][order] != null) {
            // the compiler has already been created
            return cache[parameters][order];
        }
    }
    // we need to create more compilers
    final int maxParameters = FastMath.max(parameters, cache == null ? 0 : cache.length);
    final int maxOrder = FastMath.max(order, cache == null ? 0 : cache[0].length);
    final DSCompiler[][] newCache = new DSCompiler[maxParameters + 1][maxOrder + 1];
    if (cache != null) {
        // preserve the already created compilers
        for (int i = 0; i < cache.length; ++i) {
            System.arraycopy(cache[i], 0, newCache[i], 0, cache[i].length);
        }
    }
    // create the array in increasing diagonal order
    for (int diag = 0; diag <= parameters + order; ++diag) {
        for (int o = FastMath.max(0, diag - parameters); o <= FastMath.min(order, diag); ++o) {
            final int p = diag - o;
            if (newCache[p][o] == null) {
                final DSCompiler valueCompiler = (p == 0) ? null : newCache[p - 1][o];
                final DSCompiler derivativeCompiler = (o == 0) ? null : newCache[p][o - 1];
                newCache[p][o] = new DSCompiler(p, o, valueCompiler, derivativeCompiler);
            }
        }
    }
    // atomically reset the cached compilers array
    compilers.compareAndSet(cache, newCache);
    return newCache[parameters][order];
}","public void test4242() throws Throwable {
    int int0 = 700;
    int int1 = 1;
    // Undeclared exception!
    DSCompiler.getCompiler(700, 1);
}","/**
 * Get the compiler for number of free parameters and order.
 * @param parameters number of free parameters
 * @param order derivation order
 * @return cached rules set
 */"
"public static DSCompiler getCompiler(int parameters, int order) {
    // get the cached compilers
    final DSCompiler[][] cache = compilers.get();
    if (cache != null && cache.length > parameters && cache[parameters].length > order) {
        if (cache[parameters][order] != null) {
            // the compiler has already been created
            return cache[parameters][order];
        }
    }
    // we need to create more compilers
    final int maxParameters = FastMath.max(parameters, cache == null ? 0 : cache.length);
    final int maxOrder = FastMath.max(order, cache == null ? 0 : cache[0].length);
    final DSCompiler[][] newCache = new DSCompiler[maxParameters + 1][maxOrder + 1];
    if (cache != null) {
        // preserve the already created compilers
        for (int i = 0; i < cache.length; ++i) {
            System.arraycopy(cache[i], 0, newCache[i], 0, cache[i].length);
        }
    }
    // create the array in increasing diagonal order
    for (int diag = 0; diag <= parameters + order; ++diag) {
        for (int o = FastMath.max(0, diag - parameters); o <= FastMath.min(order, diag); ++o) {
            final int p = diag - o;
            if (newCache[p][o] == null) {
                final DSCompiler valueCompiler = (p == 0) ? null : newCache[p - 1][o];
                final DSCompiler derivativeCompiler = (o == 0) ? null : newCache[p][o - 1];
                newCache[p][o] = new DSCompiler(p, o, valueCompiler, derivativeCompiler);
            }
        }
    }
    // atomically reset the cached compilers array
    compilers.compareAndSet(cache, newCache);
    return newCache[parameters][order];
}","public void test4343() throws Throwable {
    int int0 = 3029;
    // Undeclared exception!
    try {
        DSCompiler.getCompiler(3029, (-5080));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Get the compiler for number of free parameters and order.
 * @param parameters number of free parameters
 * @param order derivation order
 * @return cached rules set
 */"
"public static DSCompiler getCompiler(int parameters, int order) {
    // get the cached compilers
    final DSCompiler[][] cache = compilers.get();
    if (cache != null && cache.length > parameters && cache[parameters].length > order) {
        if (cache[parameters][order] != null) {
            // the compiler has already been created
            return cache[parameters][order];
        }
    }
    // we need to create more compilers
    final int maxParameters = FastMath.max(parameters, cache == null ? 0 : cache.length);
    final int maxOrder = FastMath.max(order, cache == null ? 0 : cache[0].length);
    final DSCompiler[][] newCache = new DSCompiler[maxParameters + 1][maxOrder + 1];
    if (cache != null) {
        // preserve the already created compilers
        for (int i = 0; i < cache.length; ++i) {
            System.arraycopy(cache[i], 0, newCache[i], 0, cache[i].length);
        }
    }
    // create the array in increasing diagonal order
    for (int diag = 0; diag <= parameters + order; ++diag) {
        for (int o = FastMath.max(0, diag - parameters); o <= FastMath.min(order, diag); ++o) {
            final int p = diag - o;
            if (newCache[p][o] == null) {
                final DSCompiler valueCompiler = (p == 0) ? null : newCache[p - 1][o];
                final DSCompiler derivativeCompiler = (o == 0) ? null : newCache[p][o - 1];
                newCache[p][o] = new DSCompiler(p, o, valueCompiler, derivativeCompiler);
            }
        }
    }
    // atomically reset the cached compilers array
    compilers.compareAndSet(cache, newCache);
    return newCache[parameters][order];
}","public void test4444() throws Throwable {
    int int0 = (-2289);
    // Undeclared exception!
    try {
        DSCompiler.getCompiler((-2289), (-2289));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Get the compiler for number of free parameters and order.
 * @param parameters number of free parameters
 * @param order derivation order
 * @return cached rules set
 */"
"public void subtract(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) {
    for (int i = 0; i < getSize(); ++i) {
        result[resultOffset + i] = lhs[lhsOffset + i] - rhs[rhsOffset + i];
    }
}","public void test4545() throws Throwable {
    int int0 = 2512;
    int int1 = 0;
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(2512, 0);
    double[] doubleArray0 = new double[6];
    doubleArray0[0] = (double) 2512;
    dSCompiler0.tan(doubleArray0, 0, doubleArray0, 0);
    doubleArray0[1] = (double) 0;
    doubleArray0[2] = (double) 2512;
    doubleArray0[3] = (double) 0;
    doubleArray0[4] = (double) 2512;
    doubleArray0[5] = (double) 0;
    double[] doubleArray1 = new double[0];
    int int2 = 172;
    // Undeclared exception!
    try {
        dSCompiler0.subtract(doubleArray0, 0, doubleArray0, 2512, doubleArray1, 172);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 2512
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Perform subtraction of two derivative structures.
 * @param lhs array holding left hand side of subtraction
 * @param lhsOffset offset of the left hand side in its array
 * @param rhs array right hand side of subtraction
 * @param rhsOffset offset of the right hand side in its array
 * @param result array where result must be stored (it may be
 * one of the input arrays)
 * @param resultOffset offset of the result in its array
 */"
"public void tanh(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {
    // create the function value and derivatives
    final double[] function = new double[1 + order];
    final double t = FastMath.tanh(operand[operandOffset]);
    function[0] = t;
    if (order > 0) {
        // the nth order derivative of tanh has the form:
        // dn(tanh(x)/dxn = P_n(tanh(x))
        // where P_n(t) is a degree n+1 polynomial with same parity as n+1
        // P_0(t) = t, P_1(t) = 1 - t^2, P_2(t) = -2 t (1 - t^2) ...
        // the general recurrence relation for P_n is:
        // P_n(x) = (1-t^2) P_(n-1)'(t)
        // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array
        final double[] p = new double[order + 2];
        p[1] = 1;
        final double t2 = t * t;
        for (int n = 1; n <= order; ++n) {
            // update and evaluate polynomial P_n(t)
            double v = 0;
            p[n + 1] = -n * p[n];
            for (int k = n + 1; k >= 0; k -= 2) {
                v = v * t2 + p[k];
                if (k > 2) {
                    p[k - 2] = (k - 1) * p[k - 1] - (k - 3) * p[k - 3];
                } else if (k == 2) {
                    p[0] = p[1];
                }
            }
            if ((n & 0x1) == 0) {
                v *= t;
            }
            function[n] = v;
        }
    }
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test4646() throws Throwable {
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 0);
    double[] doubleArray0 = new double[7];
    doubleArray0[0] = (double) 0;
    doubleArray0[1] = (double) 0;
    doubleArray0[2] = (double) 0;
    doubleArray0[3] = (double) 0;
    doubleArray0[4] = (double) 0;
    doubleArray0[5] = (double) 0;
    doubleArray0[6] = 1270.0335;
    dSCompiler0.tanh(doubleArray0, 0, doubleArray0, 2);
}","/**
 * Compute hyperbolic tangent of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param result array where result must be stored (for
 * hyperbolic tangent the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
"public int getPartialDerivativeIndex(final int... orders) throws DimensionMismatchException, NumberIsTooLargeException {
    // safety check
    if (orders.length != getFreeParameters()) {
        throw new DimensionMismatchException(orders.length, getFreeParameters());
    }
    return getPartialDerivativeIndex(parameters, order, sizes, orders);
}","public void test4747() throws Throwable {
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 0);
    int[] intArray0 = new int[2];
    intArray0[0] = 0;
    intArray0[1] = 0;
    try {
        dSCompiler0.getPartialDerivativeIndex(intArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 2 != 0
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Get the index of a partial derivative in the array.
 * <p>
 * If all orders are set to 0, then the 0<sup>th</sup> order derivative
 * is returned, which is the value of the function.
 * </p>
 * <p>The indices of derivatives are between 0 and {@link #getSize() getSize()} - 1.
 * Their specific order is fixed for a given compiler, but otherwise not
 * publicly specified. There are however some simple cases which have guaranteed
 * indices:
 * </p>
 * <ul>
 *   <li>the index of 0<sup>th</sup> order derivative is always 0</li>
 *   <li>if there is only 1 {@link #getFreeParameters() free parameter}, then the
 *   derivatives are sorted in increasing derivation order (i.e. f at index 0, df/dp
 *   at index 1, d<sup>2</sup>f/dp<sup>2</sup> at index 2 ...
 *   d<sup>k</sup>f/dp<sup>k</sup> at index k),</li>
 *   <li>if the {@link #getOrder() derivation order} is 1, then the derivatives
 *   are sorted in incresing free parameter order (i.e. f at index 0, df/dx<sub>1</sub>
 *   at index 1, df/dx<sub>2</sub> at index 2 ... df/dx<sub>k</sub> at index k),</li>
 *   <li>all other cases are not publicly specified</li>
 * </ul>
 * <p>
 * This method is the inverse of method {@link #getPartialDerivativeOrders(int)}
 * </p>
 * @param orders derivation orders with respect to each parameter
 * @return index of the partial derivative
 * @exception DimensionMismatchException if the numbers of parameters does not
 * match the instance
 * @exception NumberIsTooLargeException if sum of derivation orders is larger
 * than the instance limits
 * @see #getPartialDerivativeOrders(int)
 */"
"public double taylor(final double[] ds, final int dsOffset, final double... delta) {
    double value = 0;
    for (int i = getSize() - 1; i >= 0; --i) {
        final int[] orders = getPartialDerivativeOrders(i);
        double term = ds[dsOffset + i];
        for (int k = 0; k < orders.length; ++k) {
            if (orders[k] > 0) {
                term *= FastMath.pow(delta[k], orders[k]) / ArithmeticUtils.factorial(orders[k]);
            }
        }
        value += term;
    }
    return value;
}","public void test4848() throws Throwable {
    int int0 = 0;
    int int1 = 46;
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 46);
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = (double) 46;
    doubleArray0[1] = (double) 46;
    int int2 = (-318);
    int int3 = 524;
    double[] doubleArray1 = new double[0];
    // Undeclared exception!
    try {
        dSCompiler0.taylor(doubleArray1, (-2289), doubleArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -2289
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Evaluate Taylor expansion of a derivative structure.
 * @param ds array holding the derivative structure
 * @param dsOffset offset of the derivative structure in its array
 * @param delta parameters offsets (&Delta;x, &Delta;y, ...)
 * @return value of the Taylor expansion at x + &Delta;x, y + &Delta;y, ...
 */"
"public static DSCompiler getCompiler(int parameters, int order) {
    // get the cached compilers
    final DSCompiler[][] cache = compilers.get();
    if (cache != null && cache.length > parameters && cache[parameters].length > order) {
        if (cache[parameters][order] != null) {
            // the compiler has already been created
            return cache[parameters][order];
        }
    }
    // we need to create more compilers
    final int maxParameters = FastMath.max(parameters, cache == null ? 0 : cache.length);
    final int maxOrder = FastMath.max(order, cache == null ? 0 : cache[0].length);
    final DSCompiler[][] newCache = new DSCompiler[maxParameters + 1][maxOrder + 1];
    if (cache != null) {
        // preserve the already created compilers
        for (int i = 0; i < cache.length; ++i) {
            System.arraycopy(cache[i], 0, newCache[i], 0, cache[i].length);
        }
    }
    // create the array in increasing diagonal order
    for (int diag = 0; diag <= parameters + order; ++diag) {
        for (int o = FastMath.max(0, diag - parameters); o <= FastMath.min(order, diag); ++o) {
            final int p = diag - o;
            if (newCache[p][o] == null) {
                final DSCompiler valueCompiler = (p == 0) ? null : newCache[p - 1][o];
                final DSCompiler derivativeCompiler = (o == 0) ? null : newCache[p][o - 1];
                newCache[p][o] = new DSCompiler(p, o, valueCompiler, derivativeCompiler);
            }
        }
    }
    // atomically reset the cached compilers array
    compilers.compareAndSet(cache, newCache);
    return newCache[parameters][order];
}","public void test4949() throws Throwable {
    int int0 = 559;
    int int1 = 686;
    // Undeclared exception!
    DSCompiler.getCompiler(559, 686);
}","/**
 * Get the compiler for number of free parameters and order.
 * @param parameters number of free parameters
 * @param order derivation order
 * @return cached rules set
 */"
"public static DSCompiler getCompiler(int parameters, int order) {
    // get the cached compilers
    final DSCompiler[][] cache = compilers.get();
    if (cache != null && cache.length > parameters && cache[parameters].length > order) {
        if (cache[parameters][order] != null) {
            // the compiler has already been created
            return cache[parameters][order];
        }
    }
    // we need to create more compilers
    final int maxParameters = FastMath.max(parameters, cache == null ? 0 : cache.length);
    final int maxOrder = FastMath.max(order, cache == null ? 0 : cache[0].length);
    final DSCompiler[][] newCache = new DSCompiler[maxParameters + 1][maxOrder + 1];
    if (cache != null) {
        // preserve the already created compilers
        for (int i = 0; i < cache.length; ++i) {
            System.arraycopy(cache[i], 0, newCache[i], 0, cache[i].length);
        }
    }
    // create the array in increasing diagonal order
    for (int diag = 0; diag <= parameters + order; ++diag) {
        for (int o = FastMath.max(0, diag - parameters); o <= FastMath.min(order, diag); ++o) {
            final int p = diag - o;
            if (newCache[p][o] == null) {
                final DSCompiler valueCompiler = (p == 0) ? null : newCache[p - 1][o];
                final DSCompiler derivativeCompiler = (o == 0) ? null : newCache[p][o - 1];
                newCache[p][o] = new DSCompiler(p, o, valueCompiler, derivativeCompiler);
            }
        }
    }
    // atomically reset the cached compilers array
    compilers.compareAndSet(cache, newCache);
    return newCache[parameters][order];
}","public void test5050() throws Throwable {
    int int0 = 526;
    int int1 = 569;
    // Undeclared exception!
    DSCompiler.getCompiler(526, 569);
}","/**
 * Get the compiler for number of free parameters and order.
 * @param parameters number of free parameters
 * @param order derivation order
 * @return cached rules set
 */"
"public void multiply(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) {
    for (int i = 0; i < multIndirection.length; ++i) {
        final int[][] mappingI = multIndirection[i];
        double r = 0;
        for (int j = 0; j < mappingI.length; ++j) {
            r += mappingI[j][0] * lhs[lhsOffset + mappingI[j][1]] * rhs[rhsOffset + mappingI[j][2]];
        }
        result[resultOffset + i] = r;
    }
}","public void test5151() throws Throwable {
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(328, 0);
    double[] doubleArray0 = new double[2];
    doubleArray0[0] = (double) 328;
    doubleArray0[1] = (double) 328;
    // Undeclared exception!
    try {
        dSCompiler0.multiply(doubleArray0, 0, doubleArray0, 328, doubleArray0, 0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 328
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Perform multiplication of two derivative structures.
 * @param lhs array holding left hand side of multiplication
 * @param lhsOffset offset of the left hand side in its array
 * @param rhs array right hand side of multiplication
 * @param rhsOffset offset of the right hand side in its array
 * @param result array where result must be stored (for
 * multiplication the result array <em>cannot</em> be one of
 * the input arrays)
 * @param resultOffset offset of the result in its array
 */"
"public void sin(final double[] operand, final int operandOffset, final double[] result, final int resultOffset) {
    // create the function value and derivatives
    double[] function = new double[1 + order];
    function[0] = FastMath.sin(operand[operandOffset]);
    if (order > 0) {
        function[1] = FastMath.cos(operand[operandOffset]);
        for (int i = 2; i <= order; ++i) {
            function[i] = -function[i - 2];
        }
    }
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test5252() throws Throwable {
    int int0 = 707;
    int int1 = 0;
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(707, 0);
    double[] doubleArray0 = new double[9];
    doubleArray0[0] = 0.5734702348709106;
    doubleArray0[1] = (double) 707;
    doubleArray0[2] = (double) 0;
    doubleArray0[3] = (double) 707;
    doubleArray0[4] = (double) 707;
    doubleArray0[5] = (double) 0;
    doubleArray0[6] = 0.57;
    doubleArray0[7] = (double) 707;
    doubleArray0[8] = (double) 707;
    // Undeclared exception!
    try {
        dSCompiler0.sin(doubleArray0, 707, doubleArray0, (-1443));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 707
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute sine of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param result array where result must be stored (for
 * sine the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
"public void linearCombination(final double a1, final double[] c1, final int offset1, final double a2, final double[] c2, final int offset2, final double[] result, final int resultOffset) {
    for (int i = 0; i < getSize(); ++i) {
        result[resultOffset + i] = MathArrays.linearCombination(a1, c1[offset1 + i], a2, c2[offset2 + i]);
    }
}","public void test5353() throws Throwable {
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 615);
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = (double) 0;
    doubleArray0[1] = 0.0;
    doubleArray0[2] = (double) 615;
    doubleArray0[3] = (-1509.514525752);
    // Undeclared exception!
    try {
        dSCompiler0.linearCombination(0.0, doubleArray0, 0, 0.0, doubleArray0, 0, doubleArray0, 535);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 535
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute linear combination.
 * The derivative structure built will be a1 * ds1 + a2 * ds2
 * @param a1 first scale factor
 * @param c1 first base (unscaled) component
 * @param offset1 offset of first operand in its array
 * @param a2 second scale factor
 * @param c2 second base (unscaled) component
 * @param offset2 offset of second operand in its array
 * @param result array where result must be stored (it may be
 * one of the input arrays)
 * @param resultOffset offset of the result in its array
 */"
"public void pow(final double[] operand, final int operandOffset, final int n, final double[] result, final int resultOffset) {
    if (n == 0) {
        // special case, x^0 = 1 for all x
        result[resultOffset] = 1.0;
        Arrays.fill(result, resultOffset + 1, resultOffset + getSize(), 0);
        return;
    }
    // create the power function value and derivatives
    // [x^n, nx^(n-1), n(n-1)x^(n-2), ... ]
    double[] function = new double[1 + order];
    if (n > 0) {
        // strictly positive power
        final int maxOrder = FastMath.min(order, n);
        double xk = FastMath.pow(operand[operandOffset], n - maxOrder);
        for (int i = maxOrder; i > 0; --i) {
            function[i] = xk;
            xk *= operand[operandOffset];
        }
        function[0] = xk;
    } else {
        // strictly negative power
        final double inv = 1.0 / operand[operandOffset];
        double xk = FastMath.pow(inv, -n);
        for (int i = 0; i <= order; ++i) {
            function[i] = xk;
            xk *= inv;
        }
    }
    double coefficient = n;
    for (int i = 1; i <= order; ++i) {
        function[i] *= coefficient;
        coefficient *= n - i;
    }
    // apply function composition
    compose(operand, operandOffset, function, result, resultOffset);
}","public void test5454() throws Throwable {
    int int0 = 0;
    DSCompiler dSCompiler0 = DSCompiler.getCompiler(0, 0);
    double[] doubleArray0 = new double[3];
    double double0 = 0.0;
    double double1 = (-1729.96897);
    int int1 = (-3556);
    dSCompiler0.linearCombination((double) 0, doubleArray0, 0, 0.0, doubleArray0, 0, 3836.298489, doubleArray0, 0, doubleArray0, 0);
    int int2 = 0;
    int int3 = (-2852);
    int int4 = (-1525);
    // Undeclared exception!
    try {
        dSCompiler0.pow(doubleArray0, 0, (-2852), doubleArray0, (-1525));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -1525
        //
        verifyException(""org.apache.commons.math3.analysis.differentiation.DSCompiler"", e);
    }
}","/**
 * Compute integer power of a derivative structure.
 * @param operand array holding the operand
 * @param operandOffset offset of the operand in its array
 * @param n power to apply
 * @param result array where result must be stored (for
 * power the result array <em>cannot</em> be the input
 * array)
 * @param resultOffset offset of the result in its array
 */"
