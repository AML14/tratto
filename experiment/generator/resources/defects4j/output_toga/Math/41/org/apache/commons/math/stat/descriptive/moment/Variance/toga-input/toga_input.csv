focal_method,test_prefix,docstring
"public boolean isBiasCorrected() {
    return isBiasCorrected;
}","public void test000() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    Variance variance0 = new Variance(true, secondMoment0);
    boolean boolean0 = variance0.isBiasCorrected();
    assertTrue(boolean0);
}","/**
 * @return Returns the isBiasCorrected.
 */"
"public double evaluate(final double[] values, final double[] weights) {
    return evaluate(values, weights, 0, values.length);
}","public void test011() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[7];
    doubleArray0[0] = 1324.054;
    double[] doubleArray1 = new double[7];
    double double0 = variance0.evaluate(doubleArray1, doubleArray0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * <p>
 * Returns the weighted variance of the entries in the the input array.</p>
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - weightedMean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre>
 * where weightedMean is the weighted mean</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length)); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if either array is null.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @return the weighted variance of the values
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"public long getN() {
    return moment.getN();
}","public void test022() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = 2103.4;
    variance0.incrementAll(doubleArray0);
    variance0.setBiasCorrected(false);
    Variance variance1 = variance0.copy();
    boolean boolean0 = variance1.equals(variance0);
    assertEquals(5L, variance0.getN());
}","/**
 * {@inheritDoc}
 */"
"@Override
public boolean equals(Object object) {
    if (object == this) {
        return true;
    }
    if (object instanceof AbstractStorelessUnivariateStatistic == false) {
        return false;
    }
    AbstractStorelessUnivariateStatistic stat = (AbstractStorelessUnivariateStatistic) object;
    return Precision.equalsIncludingNaN(stat.getResult(), this.getResult()) && Precision.equalsIncludingNaN(stat.getN(), this.getN());
}","public void test023() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[5];
    doubleArray0[0] = 2103.4;
    variance0.incrementAll(doubleArray0);
    variance0.setBiasCorrected(false);
    Variance variance1 = variance0.copy();
    boolean boolean0 = variance1.equals(variance0);
    assertTrue(boolean0);
}","/**
 * Returns true iff <code>object</code> is an
 * <code>AbstractStorelessUnivariateStatistic</code> returning the same
 * values as this for <code>getResult()</code> and <code>getN()</code>
 * @param object object to test equality against.
 * @return true if object returns the same value as this
 */"
"public boolean isBiasCorrected() {
    return isBiasCorrected;
}","public void test034() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    Variance variance0 = new Variance(secondMoment0);
    secondMoment0.n = (-44L);
    double double0 = variance0.getResult();
    assertTrue(variance0.isBiasCorrected());
}","/**
 * @return Returns the isBiasCorrected.
 */"
"@Override
public double getResult() {
    if (moment.n == 0) {
        return Double.NaN;
    } else if (moment.n == 1) {
        return 0d;
    } else {
        if (isBiasCorrected) {
            return moment.m2 / (moment.n - 1d);
        } else {
            return moment.m2 / (moment.n);
        }
    }
}","public void test035() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    Variance variance0 = new Variance(secondMoment0);
    secondMoment0.n = (-44L);
    double double0 = variance0.getResult();
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isBiasCorrected() {
    return isBiasCorrected;
}","public void test046() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    Variance variance0 = new Variance(false, secondMoment0);
    boolean boolean0 = variance0.isBiasCorrected();
    assertFalse(boolean0);
}","/**
 * @return Returns the isBiasCorrected.
 */"
"public long getN() {
    return moment.getN();
}","public void test057() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[7];
    doubleArray0[4] = 1613.543953;
    variance0.incrementAll(doubleArray0);
    double double0 = variance0.getResult();
    assertEquals(7L, variance0.getN());
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getResult() {
    if (moment.n == 0) {
        return Double.NaN;
    } else if (moment.n == 1) {
        return 0d;
    } else {
        if (isBiasCorrected) {
            return moment.m2 / (moment.n - 1d);
        } else {
            return moment.m2 / (moment.n);
        }
    }
}","public void test058() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[7];
    doubleArray0[4] = 1613.543953;
    variance0.incrementAll(doubleArray0);
    double double0 = variance0.getResult();
    assertEquals(371932.01260898093, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isBiasCorrected() {
    return isBiasCorrected;
}","public void test069() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    double[] doubleArray0 = new double[4];
    secondMoment0.setData(doubleArray0);
    secondMoment0.evaluate();
    Variance variance0 = new Variance(secondMoment0);
    variance0.getN();
    assertTrue(variance0.isBiasCorrected());
}","/**
 * @return Returns the isBiasCorrected.
 */"
"public boolean isBiasCorrected() {
    return isBiasCorrected;
}","public void test0710() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    SecondMoment secondMoment1 = new SecondMoment(secondMoment0);
    Variance variance0 = new Variance(false, secondMoment1);
    secondMoment1.n = (-1974L);
    variance0.getN();
    assertFalse(variance0.isBiasCorrected());
}","/**
 * @return Returns the isBiasCorrected.
 */"
"public double evaluate(final double[] values, final double[] weights, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, weights, begin, length)) {
        clear();
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            Mean mean = new Mean();
            double m = mean.evaluate(values, weights, begin, length);
            var = evaluate(values, weights, m, begin, length);
        }
    }
    return var;
}","public void test0811() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[7];
    doubleArray0[2] = 2383.658299371;
    doubleArray0[3] = 1865.065158242;
    double double0 = variance0.evaluate(doubleArray0, doubleArray0, 2, 2);
    assertEquals(66248.62144558044, double0, 0.01);
}","/**
 * <p>Returns the weighted variance of the entries in the specified portion of
 * the input array, or <code>Double.NaN</code> if the designated subarray
 * is empty.</p>
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - weightedMean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre>
 * where weightedMean is the weighted mean</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length)); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 *     <li>the start and length arguments do not determine a valid array</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if either array is null.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the weighted variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, weights, begin, length)) {
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            double accum = 0.0;
            double dev = 0.0;
            double accum2 = 0.0;
            for (int i = begin; i < begin + length; i++) {
                dev = values[i] - mean;
                accum += weights[i] * (dev * dev);
                accum2 += weights[i] * dev;
            }
            double sumWts = 0;
            for (int i = 0; i < weights.length; i++) {
                sumWts += weights[i];
            }
            if (isBiasCorrected) {
                var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);
            } else {
                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;
            }
        }
    }
    return var;
}","public void test0912() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[7];
    doubleArray0[2] = 2383.658299371;
    double double0 = variance0.evaluate(doubleArray0, doubleArray0, 0.0, 2, 2);
    assertEquals((-8.005128697287491E-10), double0, 0.01);
}","/**
 * Returns the weighted variance of the entries in the specified portion of
 * the input array, using the precomputed weighted mean value.  Returns
 * <code>Double.NaN</code> if the designated subarray is empty.
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre></p>
 * <p>
 * The formula used assumes that the supplied mean value is the weighted arithmetic
 * mean of the sample data, not a known population parameter. This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 *     <li>the start and length arguments do not determine a valid array</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param mean the precomputed weighted mean value
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"public boolean isBiasCorrected() {
    return isBiasCorrected;
}","public void test1013() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    Variance variance0 = new Variance(false, secondMoment0);
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 1.0;
    double double0 = variance0.evaluate(doubleArray0, doubleArray0, 1.0);
    assertFalse(variance0.isBiasCorrected());
}","/**
 * @return Returns the isBiasCorrected.
 */"
"public double evaluate(final double[] values, final double[] weights, final double mean) {
    return evaluate(values, weights, mean, 0, values.length);
}","public void test1014() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    Variance variance0 = new Variance(false, secondMoment0);
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = 1.0;
    double double0 = variance0.evaluate(doubleArray0, doubleArray0, 1.0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * <p>Returns the weighted variance of the values in the input array, using
 * the precomputed weighted mean value.</p>
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre></p>
 * <p>
 * The formula used assumes that the supplied mean value is the weighted arithmetic
 * mean of the sample data, not a known population parameter. This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param mean the precomputed weighted mean value
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"public double evaluate(final double[] values, final double[] weights, final double mean) {
    return evaluate(values, weights, mean, 0, values.length);
}","public void test1115() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    Variance variance0 = new Variance(true, secondMoment0);
    double[] doubleArray0 = new double[7];
    doubleArray0[2] = 2394.040597304;
    double double0 = variance0.evaluate(doubleArray0, doubleArray0, 1918.4329756877335);
    assertEquals(4.981498838134315E-11, double0, 0.01);
}","/**
 * <p>Returns the weighted variance of the values in the input array, using
 * the precomputed weighted mean value.</p>
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre></p>
 * <p>
 * The formula used assumes that the supplied mean value is the weighted arithmetic
 * mean of the sample data, not a known population parameter. This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param mean the precomputed weighted mean value
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"public double evaluate(final double[] values, final double[] weights, final double mean) {
    return evaluate(values, weights, mean, 0, values.length);
}","public void test1216() throws Throwable {
    Variance variance0 = new Variance(false);
    double[] doubleArray0 = new double[7];
    doubleArray0[1] = 2137.40131972;
    double double0 = variance0.evaluate(doubleArray0, doubleArray0, 1507.0);
    assertEquals((-5.577300268832887E-11), double0, 0.01);
}","/**
 * <p>Returns the weighted variance of the values in the input array, using
 * the precomputed weighted mean value.</p>
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre></p>
 * <p>
 * The formula used assumes that the supplied mean value is the weighted arithmetic
 * mean of the sample data, not a known population parameter. This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param mean the precomputed weighted mean value
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"public double evaluate(final double[] values, final double[] weights) {
    return evaluate(values, weights, 0, values.length);
}","public void test1317() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    Variance variance0 = new Variance(false, secondMoment0);
    double[] doubleArray0 = new double[6];
    doubleArray0[1] = 3204.43740185;
    doubleArray0[2] = 102.46238;
    double double0 = variance0.evaluate(doubleArray0, doubleArray0);
    assertEquals(288902.1390784272, double0, 0.01);
}","/**
 * <p>
 * Returns the weighted variance of the entries in the the input array.</p>
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - weightedMean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre>
 * where weightedMean is the weighted mean</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length)); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if either array is null.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @return the weighted variance of the values
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"@Override
public double evaluate(final double[] values, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, begin, length)) {
        clear();
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            Mean mean = new Mean();
            double m = mean.evaluate(values, begin, length);
            var = evaluate(values, m, begin, length);
        }
    }
    return var;
}","public void test1418() throws Throwable {
    Variance variance0 = new Variance(false, (SecondMoment) null);
    double[] doubleArray0 = new double[7];
    doubleArray0[0] = (-1.0);
    double double0 = variance0.evaluate(doubleArray0, 0, 2);
    assertEquals(0.25, double0, 0.01);
}","/**
 * Returns the variance of the entries in the specified portion of
 * the input array, or <code>Double.NaN</code> if the designated subarray
 * is empty.
 * <p>
 * See {@link Variance} for details on the computing algorithm.</p>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if the array is null.</p>
 *
 * @param values the input array
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the array is null or the array index
 *  parameters are not valid
 */"
"public double evaluate(final double[] values, final double mean) {
    return evaluate(values, mean, 0, values.length);
}","public void test1519() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    Variance variance0 = new Variance(false, secondMoment0);
    double[] doubleArray0 = new double[6];
    double double0 = variance0.evaluate(doubleArray0, 102.46238);
    assertEquals(2.4253192047278085E-12, double0, 0.01);
}","/**
 * Returns the variance of the entries in the input array, using the
 * precomputed mean value.  Returns <code>Double.NaN</code> if the array
 * is empty.
 * <p>
 * See {@link Variance} for details on the computing algorithm.</p>
 * <p>
 * If <code>isBiasCorrected</code> is <code>true</code> the formula used
 * assumes that the supplied mean value is the arithmetic mean of the
 * sample data, not a known population parameter.  If the mean is a known
 * population parameter, or if the ""population"" version of the variance is
 * desired, set <code>isBiasCorrected</code> to <code>false</code> before
 * invoking this method.</p>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if the array is null.</p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param mean the precomputed mean value
 * @return the variance of the values or Double.NaN if the array is empty
 * @throws IllegalArgumentException if the array is null
 */"
"public double evaluate(final double[] values, final double mean) {
    return evaluate(values, mean, 0, values.length);
}","public void test1620() throws Throwable {
    double[] doubleArray0 = new double[6];
    doubleArray0[1] = 1.184154459111628E-8;
    doubleArray0[4] = 1.184154459111628E-8;
    SecondMoment secondMoment0 = new SecondMoment();
    Variance variance0 = new Variance(secondMoment0);
    double double0 = variance0.evaluate(doubleArray0, 2106.28253527);
    assertEquals((-7.450580596923829E-10), double0, 0.01);
}","/**
 * Returns the variance of the entries in the input array, using the
 * precomputed mean value.  Returns <code>Double.NaN</code> if the array
 * is empty.
 * <p>
 * See {@link Variance} for details on the computing algorithm.</p>
 * <p>
 * If <code>isBiasCorrected</code> is <code>true</code> the formula used
 * assumes that the supplied mean value is the arithmetic mean of the
 * sample data, not a known population parameter.  If the mean is a known
 * population parameter, or if the ""population"" version of the variance is
 * desired, set <code>isBiasCorrected</code> to <code>false</code> before
 * invoking this method.</p>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if the array is null.</p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param mean the precomputed mean value
 * @return the variance of the values or Double.NaN if the array is empty
 * @throws IllegalArgumentException if the array is null
 */"
"@Override
public double evaluate(final double[] values) {
    if (values == null) {
        throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);
    }
    return evaluate(values, 0, values.length);
}","public void test1721() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    Variance variance0 = new Variance(secondMoment0);
    double[] doubleArray0 = new double[5];
    doubleArray0[1] = 2895.986291783;
    double double0 = variance0.evaluate(doubleArray0);
    assertEquals(1677347.3204390104, double0, 0.01);
}","/**
 * Returns the variance of the entries in the input array, or
 * <code>Double.NaN</code> if the array is empty.
 * <p>
 * See {@link Variance} for details on the computing algorithm.</p>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if the array is null.</p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the array is null
 */"
"public boolean isBiasCorrected() {
    return isBiasCorrected;
}","public void test1822() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    Variance variance0 = new Variance(secondMoment0);
    secondMoment0.increment((-1129.4564596315));
    Variance variance1 = variance0.copy();
    assertTrue(variance1.isBiasCorrected());
}","/**
 * @return Returns the isBiasCorrected.
 */"
"@Override
public Variance copy() {
    Variance result = new Variance();
    copy(this, result);
    return result;
}","public void test1823() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    Variance variance0 = new Variance(secondMoment0);
    secondMoment0.increment((-1129.4564596315));
    Variance variance1 = variance0.copy();
    assertNotSame(variance1, variance0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getResult() {
    if (moment.n == 0) {
        return Double.NaN;
    } else if (moment.n == 1) {
        return 0d;
    } else {
        if (isBiasCorrected) {
            return moment.m2 / (moment.n - 1d);
        } else {
            return moment.m2 / (moment.n);
        }
    }
}","public void test1824() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    Variance variance0 = new Variance(secondMoment0);
    secondMoment0.increment((-1129.4564596315));
    Variance variance1 = variance0.copy();
    assertEquals(0.0, variance1.getResult(), 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isBiasCorrected() {
    return isBiasCorrected;
}","public void test1925() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    secondMoment0.n = (-4267615245585081135L);
    Variance variance0 = new Variance(false, secondMoment0);
    Variance variance1 = variance0.copy();
    assertFalse(variance1.isBiasCorrected());
}","/**
 * @return Returns the isBiasCorrected.
 */"
"public long getN() {
    return moment.getN();
}","public void test1926() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    secondMoment0.n = (-4267615245585081135L);
    Variance variance0 = new Variance(false, secondMoment0);
    Variance variance1 = variance0.copy();
    assertEquals((-4267615245585081135L), variance1.getN());
}","/**
 * {@inheritDoc}
 */"
"@Override
public Variance copy() {
    Variance result = new Variance();
    copy(this, result);
    return result;
}","public void test1927() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    secondMoment0.n = (-4267615245585081135L);
    Variance variance0 = new Variance(false, secondMoment0);
    Variance variance1 = variance0.copy();
    assertNotSame(variance1, variance0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public void increment(final double d) {
    if (incMoment) {
        moment.increment(d);
    }
}","public void test2028() throws Throwable {
    Variance variance0 = new Variance((SecondMoment) null);
    variance0.incMoment = true;
    // Undeclared exception!
    try {
        variance0.increment(0.0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.stat.descriptive.moment.Variance"", e);
    }
}","/**
 * {@inheritDoc}
 * <p>If all values are available, it is more accurate to use
 * {@link #evaluate(double[])} rather than adding values one at a time
 * using this method and then executing {@link #getResult}, since
 * <code>evaluate</code> leverages the fact that is has the full
 * list of values together to execute a two-pass algorithm.
 * See {@link Variance}.</p>
 *
 * <p>Note also that when {@link #Variance(SecondMoment)} is used to
 * create a Variance, this method does nothing. In that case, the
 * SecondMoment should be incremented directly.</p>
 */"
"@Override
public double getResult() {
    if (moment.n == 0) {
        return Double.NaN;
    } else if (moment.n == 1) {
        return 0d;
    } else {
        if (isBiasCorrected) {
            return moment.m2 / (moment.n - 1d);
        } else {
            return moment.m2 / (moment.n);
        }
    }
}","public void test2129() throws Throwable {
    Variance variance0 = new Variance((SecondMoment) null);
    // Undeclared exception!
    try {
        variance0.getResult();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * {@inheritDoc}
 */"
"public long getN() {
    return moment.getN();
}","public void test2230() throws Throwable {
    Variance variance0 = new Variance(true, (SecondMoment) null);
    // Undeclared exception!
    try {
        variance0.getN();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * {@inheritDoc}
 */"
"public double evaluate(final double[] values, final double[] weights, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, weights, begin, length)) {
        clear();
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            Mean mean = new Mean();
            double m = mean.evaluate(values, weights, begin, length);
            var = evaluate(values, weights, m, begin, length);
        }
    }
    return var;
}","public void test2331() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    Variance variance0 = new Variance(secondMoment0);
    double[] doubleArray0 = new double[2];
    // Undeclared exception!
    try {
        variance0.evaluate(doubleArray0, doubleArray0, 2875, (-241));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // weigth array must contain at least one non-zero value
        //
        verifyException(""org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic"", e);
    }
}","/**
 * <p>Returns the weighted variance of the entries in the specified portion of
 * the input array, or <code>Double.NaN</code> if the designated subarray
 * is empty.</p>
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - weightedMean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre>
 * where weightedMean is the weighted mean</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length)); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 *     <li>the start and length arguments do not determine a valid array</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if either array is null.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the weighted variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"public double evaluate(final double[] values, final double[] weights, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, weights, begin, length)) {
        clear();
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            Mean mean = new Mean();
            double m = mean.evaluate(values, weights, begin, length);
            var = evaluate(values, weights, m, begin, length);
        }
    }
    return var;
}","public void test2432() throws Throwable {
    Variance variance0 = new Variance(false);
    double[] doubleArray0 = new double[9];
    double[] doubleArray1 = new double[6];
    // Undeclared exception!
    try {
        variance0.evaluate(doubleArray0, doubleArray1, (-1555), 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 6 != 9
        //
        verifyException(""org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic"", e);
    }
}","/**
 * <p>Returns the weighted variance of the entries in the specified portion of
 * the input array, or <code>Double.NaN</code> if the designated subarray
 * is empty.</p>
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - weightedMean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre>
 * where weightedMean is the weighted mean</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length)); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 *     <li>the start and length arguments do not determine a valid array</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if either array is null.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the weighted variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"public double evaluate(final double[] values, final double[] weights, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, weights, begin, length)) {
        clear();
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            Mean mean = new Mean();
            double m = mean.evaluate(values, weights, begin, length);
            var = evaluate(values, weights, m, begin, length);
        }
    }
    return var;
}","public void test2533() throws Throwable {
    Variance variance0 = new Variance(true);
    // Undeclared exception!
    try {
        variance0.evaluate((double[]) null, (double[]) null, 1460, 1460);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // input array
        //
        verifyException(""org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic"", e);
    }
}","/**
 * <p>Returns the weighted variance of the entries in the specified portion of
 * the input array, or <code>Double.NaN</code> if the designated subarray
 * is empty.</p>
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - weightedMean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre>
 * where weightedMean is the weighted mean</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length)); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 *     <li>the start and length arguments do not determine a valid array</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if either array is null.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the weighted variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"public double evaluate(final double[] values, final double[] weights, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, weights, begin, length)) {
        clear();
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            Mean mean = new Mean();
            double m = mean.evaluate(values, weights, begin, length);
            var = evaluate(values, weights, m, begin, length);
        }
    }
    return var;
}","public void test2634() throws Throwable {
    Variance variance0 = new Variance((SecondMoment) null);
    double[] doubleArray0 = new double[1];
    // Undeclared exception!
    try {
        variance0.evaluate((double[]) null, doubleArray0, 0, 0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic"", e);
    }
}","/**
 * <p>Returns the weighted variance of the entries in the specified portion of
 * the input array, or <code>Double.NaN</code> if the designated subarray
 * is empty.</p>
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - weightedMean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre>
 * where weightedMean is the weighted mean</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length)); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 *     <li>the start and length arguments do not determine a valid array</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if either array is null.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the weighted variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"public double evaluate(final double[] values, final double[] weights, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, weights, begin, length)) {
        clear();
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            Mean mean = new Mean();
            double m = mean.evaluate(values, weights, begin, length);
            var = evaluate(values, weights, m, begin, length);
        }
    }
    return var;
}","public void test2735() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[7];
    // Undeclared exception!
    try {
        variance0.evaluate(doubleArray0, doubleArray0, 2064, 238);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 2064
        //
        verifyException(""org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic"", e);
    }
}","/**
 * <p>Returns the weighted variance of the entries in the specified portion of
 * the input array, or <code>Double.NaN</code> if the designated subarray
 * is empty.</p>
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - weightedMean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre>
 * where weightedMean is the weighted mean</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length)); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 *     <li>the start and length arguments do not determine a valid array</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if either array is null.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the weighted variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, weights, begin, length)) {
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            double accum = 0.0;
            double dev = 0.0;
            double accum2 = 0.0;
            for (int i = begin; i < begin + length; i++) {
                dev = values[i] - mean;
                accum += weights[i] * (dev * dev);
                accum2 += weights[i] * dev;
            }
            double sumWts = 0;
            for (int i = 0; i < weights.length; i++) {
                sumWts += weights[i];
            }
            if (isBiasCorrected) {
                var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);
            } else {
                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;
            }
        }
    }
    return var;
}","public void test2836() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[7];
    // Undeclared exception!
    try {
        variance0.evaluate(doubleArray0, doubleArray0, (-1666.062257387), (-1399), (-1399));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // weigth array must contain at least one non-zero value
        //
        verifyException(""org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic"", e);
    }
}","/**
 * Returns the weighted variance of the entries in the specified portion of
 * the input array, using the precomputed weighted mean value.  Returns
 * <code>Double.NaN</code> if the designated subarray is empty.
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre></p>
 * <p>
 * The formula used assumes that the supplied mean value is the weighted arithmetic
 * mean of the sample data, not a known population parameter. This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 *     <li>the start and length arguments do not determine a valid array</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param mean the precomputed weighted mean value
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, weights, begin, length)) {
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            double accum = 0.0;
            double dev = 0.0;
            double accum2 = 0.0;
            for (int i = begin; i < begin + length; i++) {
                dev = values[i] - mean;
                accum += weights[i] * (dev * dev);
                accum2 += weights[i] * dev;
            }
            double sumWts = 0;
            for (int i = 0; i < weights.length; i++) {
                sumWts += weights[i];
            }
            if (isBiasCorrected) {
                var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);
            } else {
                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;
            }
        }
    }
    return var;
}","public void test2937() throws Throwable {
    Variance variance0 = new Variance(true);
    double[] doubleArray0 = new double[8];
    double[] doubleArray1 = new double[1];
    // Undeclared exception!
    try {
        variance0.evaluate(doubleArray0, doubleArray1, 1083.925273, 79, 603);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 1 != 8
        //
        verifyException(""org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic"", e);
    }
}","/**
 * Returns the weighted variance of the entries in the specified portion of
 * the input array, using the precomputed weighted mean value.  Returns
 * <code>Double.NaN</code> if the designated subarray is empty.
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre></p>
 * <p>
 * The formula used assumes that the supplied mean value is the weighted arithmetic
 * mean of the sample data, not a known population parameter. This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 *     <li>the start and length arguments do not determine a valid array</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param mean the precomputed weighted mean value
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, weights, begin, length)) {
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            double accum = 0.0;
            double dev = 0.0;
            double accum2 = 0.0;
            for (int i = begin; i < begin + length; i++) {
                dev = values[i] - mean;
                accum += weights[i] * (dev * dev);
                accum2 += weights[i] * dev;
            }
            double sumWts = 0;
            for (int i = 0; i < weights.length; i++) {
                sumWts += weights[i];
            }
            if (isBiasCorrected) {
                var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);
            } else {
                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;
            }
        }
    }
    return var;
}","public void test3038() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    Variance variance0 = new Variance(true, secondMoment0);
    // Undeclared exception!
    try {
        variance0.evaluate((double[]) null, (double[]) null, (-1982.691404), 52, 52);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // input array
        //
        verifyException(""org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic"", e);
    }
}","/**
 * Returns the weighted variance of the entries in the specified portion of
 * the input array, using the precomputed weighted mean value.  Returns
 * <code>Double.NaN</code> if the designated subarray is empty.
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre></p>
 * <p>
 * The formula used assumes that the supplied mean value is the weighted arithmetic
 * mean of the sample data, not a known population parameter. This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 *     <li>the start and length arguments do not determine a valid array</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param mean the precomputed weighted mean value
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, weights, begin, length)) {
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            double accum = 0.0;
            double dev = 0.0;
            double accum2 = 0.0;
            for (int i = begin; i < begin + length; i++) {
                dev = values[i] - mean;
                accum += weights[i] * (dev * dev);
                accum2 += weights[i] * dev;
            }
            double sumWts = 0;
            for (int i = 0; i < weights.length; i++) {
                sumWts += weights[i];
            }
            if (isBiasCorrected) {
                var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);
            } else {
                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;
            }
        }
    }
    return var;
}","public void test3139() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    Variance variance0 = new Variance(false, secondMoment0);
    double[] doubleArray0 = new double[8];
    // Undeclared exception!
    try {
        variance0.evaluate((double[]) null, doubleArray0, 0.0, (-670), 4863);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic"", e);
    }
}","/**
 * Returns the weighted variance of the entries in the specified portion of
 * the input array, using the precomputed weighted mean value.  Returns
 * <code>Double.NaN</code> if the designated subarray is empty.
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre></p>
 * <p>
 * The formula used assumes that the supplied mean value is the weighted arithmetic
 * mean of the sample data, not a known population parameter. This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 *     <li>the start and length arguments do not determine a valid array</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param mean the precomputed weighted mean value
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, weights, begin, length)) {
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            double accum = 0.0;
            double dev = 0.0;
            double accum2 = 0.0;
            for (int i = begin; i < begin + length; i++) {
                dev = values[i] - mean;
                accum += weights[i] * (dev * dev);
                accum2 += weights[i] * dev;
            }
            double sumWts = 0;
            for (int i = 0; i < weights.length; i++) {
                sumWts += weights[i];
            }
            if (isBiasCorrected) {
                var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);
            } else {
                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;
            }
        }
    }
    return var;
}","public void test3240() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    Variance variance0 = new Variance(true, secondMoment0);
    double[] doubleArray0 = new double[7];
    // Undeclared exception!
    try {
        variance0.evaluate(doubleArray0, doubleArray0, (-3085.7), (-64), 1746);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -64
        //
        verifyException(""org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic"", e);
    }
}","/**
 * Returns the weighted variance of the entries in the specified portion of
 * the input array, using the precomputed weighted mean value.  Returns
 * <code>Double.NaN</code> if the designated subarray is empty.
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre></p>
 * <p>
 * The formula used assumes that the supplied mean value is the weighted arithmetic
 * mean of the sample data, not a known population parameter. This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 *     <li>the start and length arguments do not determine a valid array</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param mean the precomputed weighted mean value
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"public double evaluate(final double[] values, final double[] weights, final double mean) {
    return evaluate(values, weights, mean, 0, values.length);
}","public void test3341() throws Throwable {
    Variance variance0 = new Variance((SecondMoment) null);
    double[] doubleArray0 = new double[7];
    // Undeclared exception!
    try {
        variance0.evaluate(doubleArray0, doubleArray0, (-1.0));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // weigth array must contain at least one non-zero value
        //
        verifyException(""org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic"", e);
    }
}","/**
 * <p>Returns the weighted variance of the values in the input array, using
 * the precomputed weighted mean value.</p>
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre></p>
 * <p>
 * The formula used assumes that the supplied mean value is the weighted arithmetic
 * mean of the sample data, not a known population parameter. This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param mean the precomputed weighted mean value
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"public double evaluate(final double[] values, final double[] weights, final double mean) {
    return evaluate(values, weights, mean, 0, values.length);
}","public void test3442() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[0];
    double[] doubleArray1 = new double[1];
    // Undeclared exception!
    try {
        variance0.evaluate(doubleArray0, doubleArray1, 608.578211);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 1 != 0
        //
        verifyException(""org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic"", e);
    }
}","/**
 * <p>Returns the weighted variance of the values in the input array, using
 * the precomputed weighted mean value.</p>
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre></p>
 * <p>
 * The formula used assumes that the supplied mean value is the weighted arithmetic
 * mean of the sample data, not a known population parameter. This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param mean the precomputed weighted mean value
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"public double evaluate(final double[] values, final double[] weights, final double mean) {
    return evaluate(values, weights, mean, 0, values.length);
}","public void test3543() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    Variance variance0 = new Variance(secondMoment0);
    // Undeclared exception!
    try {
        variance0.evaluate((double[]) null, (double[]) null, 0.0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.stat.descriptive.moment.Variance"", e);
    }
}","/**
 * <p>Returns the weighted variance of the values in the input array, using
 * the precomputed weighted mean value.</p>
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre></p>
 * <p>
 * The formula used assumes that the supplied mean value is the weighted arithmetic
 * mean of the sample data, not a known population parameter. This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param mean the precomputed weighted mean value
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"public double evaluate(final double[] values, final double[] weights) {
    return evaluate(values, weights, 0, values.length);
}","public void test3644() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[4];
    double[] doubleArray1 = new double[7];
    // Undeclared exception!
    try {
        variance0.evaluate(doubleArray0, doubleArray1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // 7 != 4
        //
        verifyException(""org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic"", e);
    }
}","/**
 * <p>
 * Returns the weighted variance of the entries in the the input array.</p>
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - weightedMean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre>
 * where weightedMean is the weighted mean</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length)); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if either array is null.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @return the weighted variance of the values
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"public double evaluate(final double[] values, final double[] weights) {
    return evaluate(values, weights, 0, values.length);
}","public void test3745() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[2];
    // Undeclared exception!
    try {
        variance0.evaluate(doubleArray0, (double[]) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // input array
        //
        verifyException(""org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic"", e);
    }
}","/**
 * <p>
 * Returns the weighted variance of the entries in the the input array.</p>
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - weightedMean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre>
 * where weightedMean is the weighted mean</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length)); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if either array is null.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @return the weighted variance of the values
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"public double evaluate(final double[] values, final double[] weights) {
    return evaluate(values, weights, 0, values.length);
}","public void test3846() throws Throwable {
    Variance variance0 = new Variance();
    // Undeclared exception!
    try {
        variance0.evaluate((double[]) null, (double[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.stat.descriptive.moment.Variance"", e);
    }
}","/**
 * <p>
 * Returns the weighted variance of the entries in the the input array.</p>
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - weightedMean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre>
 * where weightedMean is the weighted mean</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length)); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if either array is null.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @return the weighted variance of the values
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"@Override
public double evaluate(final double[] values, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, begin, length)) {
        clear();
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            Mean mean = new Mean();
            double m = mean.evaluate(values, begin, length);
            var = evaluate(values, m, begin, length);
        }
    }
    return var;
}","public void test3947() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[7];
    // Undeclared exception!
    try {
        variance0.evaluate(doubleArray0, (-618), 3136);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // start position (-618)
        //
        verifyException(""org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic"", e);
    }
}","/**
 * Returns the variance of the entries in the specified portion of
 * the input array, or <code>Double.NaN</code> if the designated subarray
 * is empty.
 * <p>
 * See {@link Variance} for details on the computing algorithm.</p>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if the array is null.</p>
 *
 * @param values the input array
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the array is null or the array index
 *  parameters are not valid
 */"
"@Override
public double evaluate(final double[] values, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, begin, length)) {
        clear();
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            Mean mean = new Mean();
            double m = mean.evaluate(values, begin, length);
            var = evaluate(values, m, begin, length);
        }
    }
    return var;
}","public void test4048() throws Throwable {
    Variance variance0 = new Variance(true);
    double[] doubleArray0 = new double[9];
    // Undeclared exception!
    try {
        variance0.evaluate(doubleArray0, 0, 46);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // subarray ends after array end
        //
        verifyException(""org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic"", e);
    }
}","/**
 * Returns the variance of the entries in the specified portion of
 * the input array, or <code>Double.NaN</code> if the designated subarray
 * is empty.
 * <p>
 * See {@link Variance} for details on the computing algorithm.</p>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if the array is null.</p>
 *
 * @param values the input array
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the array is null or the array index
 *  parameters are not valid
 */"
"@Override
public double evaluate(final double[] values, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, begin, length)) {
        clear();
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            Mean mean = new Mean();
            double m = mean.evaluate(values, begin, length);
            var = evaluate(values, m, begin, length);
        }
    }
    return var;
}","public void test4149() throws Throwable {
    Variance variance0 = new Variance(true);
    // Undeclared exception!
    try {
        variance0.evaluate((double[]) null, (-2075), (-805));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // input array
        //
        verifyException(""org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic"", e);
    }
}","/**
 * Returns the variance of the entries in the specified portion of
 * the input array, or <code>Double.NaN</code> if the designated subarray
 * is empty.
 * <p>
 * See {@link Variance} for details on the computing algorithm.</p>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if the array is null.</p>
 *
 * @param values the input array
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the array is null or the array index
 *  parameters are not valid
 */"
"public double evaluate(final double[] values, final double mean, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, begin, length)) {
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            double accum = 0.0;
            double dev = 0.0;
            double accum2 = 0.0;
            for (int i = begin; i < begin + length; i++) {
                dev = values[i] - mean;
                accum += dev * dev;
                accum2 += dev;
            }
            double len = length;
            if (isBiasCorrected) {
                var = (accum - (accum2 * accum2 / len)) / (len - 1.0);
            } else {
                var = (accum - (accum2 * accum2 / len)) / len;
            }
        }
    }
    return var;
}","public void test4250() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[8];
    // Undeclared exception!
    try {
        variance0.evaluate(doubleArray0, 1.0, (-2036), (-2036));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // start position (-2,036)
        //
        verifyException(""org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic"", e);
    }
}","/**
 * Returns the variance of the entries in the specified portion of
 * the input array, using the precomputed mean value.  Returns
 * <code>Double.NaN</code> if the designated subarray is empty.
 * <p>
 * See {@link Variance} for details on the computing algorithm.</p>
 * <p>
 * The formula used assumes that the supplied mean value is the arithmetic
 * mean of the sample data, not a known population parameter.  This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if the array is null.</p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param mean the precomputed mean value
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the array is null or the array index
 *  parameters are not valid
 */"
"public double evaluate(final double[] values, final double mean, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, begin, length)) {
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            double accum = 0.0;
            double dev = 0.0;
            double accum2 = 0.0;
            for (int i = begin; i < begin + length; i++) {
                dev = values[i] - mean;
                accum += dev * dev;
                accum2 += dev;
            }
            double len = length;
            if (isBiasCorrected) {
                var = (accum - (accum2 * accum2 / len)) / (len - 1.0);
            } else {
                var = (accum - (accum2 * accum2 / len)) / len;
            }
        }
    }
    return var;
}","public void test4351() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    Variance variance0 = new Variance(secondMoment0);
    double[] doubleArray0 = new double[4];
    // Undeclared exception!
    try {
        variance0.evaluate(doubleArray0, 5440.4, 90, 1860);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // subarray ends after array end
        //
        verifyException(""org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic"", e);
    }
}","/**
 * Returns the variance of the entries in the specified portion of
 * the input array, using the precomputed mean value.  Returns
 * <code>Double.NaN</code> if the designated subarray is empty.
 * <p>
 * See {@link Variance} for details on the computing algorithm.</p>
 * <p>
 * The formula used assumes that the supplied mean value is the arithmetic
 * mean of the sample data, not a known population parameter.  This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if the array is null.</p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param mean the precomputed mean value
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the array is null or the array index
 *  parameters are not valid
 */"
"public double evaluate(final double[] values, final double mean, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, begin, length)) {
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            double accum = 0.0;
            double dev = 0.0;
            double accum2 = 0.0;
            for (int i = begin; i < begin + length; i++) {
                dev = values[i] - mean;
                accum += dev * dev;
                accum2 += dev;
            }
            double len = length;
            if (isBiasCorrected) {
                var = (accum - (accum2 * accum2 / len)) / (len - 1.0);
            } else {
                var = (accum - (accum2 * accum2 / len)) / len;
            }
        }
    }
    return var;
}","public void test4452() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    Variance variance0 = new Variance(true, secondMoment0);
    // Undeclared exception!
    try {
        variance0.evaluate((double[]) null, (-657.8895107140189), 3332, 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // input array
        //
        verifyException(""org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic"", e);
    }
}","/**
 * Returns the variance of the entries in the specified portion of
 * the input array, using the precomputed mean value.  Returns
 * <code>Double.NaN</code> if the designated subarray is empty.
 * <p>
 * See {@link Variance} for details on the computing algorithm.</p>
 * <p>
 * The formula used assumes that the supplied mean value is the arithmetic
 * mean of the sample data, not a known population parameter.  This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if the array is null.</p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param mean the precomputed mean value
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the array is null or the array index
 *  parameters are not valid
 */"
"public double evaluate(final double[] values, final double mean) {
    return evaluate(values, mean, 0, values.length);
}","public void test4553() throws Throwable {
    Variance variance0 = new Variance();
    // Undeclared exception!
    try {
        variance0.evaluate((double[]) null, 0.0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.stat.descriptive.moment.Variance"", e);
    }
}","/**
 * Returns the variance of the entries in the input array, using the
 * precomputed mean value.  Returns <code>Double.NaN</code> if the array
 * is empty.
 * <p>
 * See {@link Variance} for details on the computing algorithm.</p>
 * <p>
 * If <code>isBiasCorrected</code> is <code>true</code> the formula used
 * assumes that the supplied mean value is the arithmetic mean of the
 * sample data, not a known population parameter.  If the mean is a known
 * population parameter, or if the ""population"" version of the variance is
 * desired, set <code>isBiasCorrected</code> to <code>false</code> before
 * invoking this method.</p>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if the array is null.</p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param mean the precomputed mean value
 * @return the variance of the values or Double.NaN if the array is empty
 * @throws IllegalArgumentException if the array is null
 */"
"@Override
public double evaluate(final double[] values) {
    if (values == null) {
        throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);
    }
    return evaluate(values, 0, values.length);
}","public void test4654() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[2];
    Variance variance1 = variance0.copy();
    variance1.moment = null;
    // Undeclared exception!
    try {
        variance1.evaluate(doubleArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.stat.descriptive.moment.Variance"", e);
    }
}","/**
 * Returns the variance of the entries in the input array, or
 * <code>Double.NaN</code> if the array is empty.
 * <p>
 * See {@link Variance} for details on the computing algorithm.</p>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if the array is null.</p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the array is null
 */"
"public static void copy(Variance source, Variance dest) throws NullArgumentException {
    MathUtils.checkNotNull(source);
    MathUtils.checkNotNull(dest);
    dest.setData(source.getDataRef());
    dest.moment = source.moment.copy();
    dest.isBiasCorrected = source.isBiasCorrected;
    dest.incMoment = source.incMoment;
}","public void test4755() throws Throwable {
    try {
        Variance.copy((Variance) null, (Variance) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // null is not allowed
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Copies source to dest.
 * <p>Neither source nor dest can be null.</p>
 *
 * @param source Variance to copy
 * @param dest Variance to copy to
 * @throws NullArgumentException if either source or dest is null
 */"
"public static void copy(Variance source, Variance dest) throws NullArgumentException {
    MathUtils.checkNotNull(source);
    MathUtils.checkNotNull(dest);
    dest.setData(source.getDataRef());
    dest.moment = source.moment.copy();
    dest.isBiasCorrected = source.isBiasCorrected;
    dest.incMoment = source.incMoment;
}","public void test4856() throws Throwable {
    Variance variance0 = new Variance(true);
    variance0.moment = null;
    // Undeclared exception!
    try {
        Variance.copy(variance0, variance0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.stat.descriptive.moment.Variance"", e);
    }
}","/**
 * Copies source to dest.
 * <p>Neither source nor dest can be null.</p>
 *
 * @param source Variance to copy
 * @param dest Variance to copy to
 * @throws NullArgumentException if either source or dest is null
 */"
"@Override
public Variance copy() {
    Variance result = new Variance();
    copy(this, result);
    return result;
}","public void test4957() throws Throwable {
    Variance variance0 = new Variance((SecondMoment) null);
    // Undeclared exception!
    try {
        variance0.copy();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.stat.descriptive.moment.Variance"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public void clear() {
    if (incMoment) {
        moment.clear();
    }
}","public void test5058() throws Throwable {
    Variance variance0 = new Variance(false);
    variance0.moment = null;
    // Undeclared exception!
    try {
        variance0.clear();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.stat.descriptive.moment.Variance"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public Variance(Variance original) {
    copy(original, this);
}","public void test5159() throws Throwable {
    Variance variance0 = null;
    try {
        variance0 = new Variance((Variance) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // null is not allowed
        //
        verifyException(""org.apache.commons.math.util.MathUtils"", e);
    }
}","/**
 * Copy constructor, creates a new {@code Variance} identical
 * to the {@code original}
 *
 * @param original the {@code Variance} instance to copy
 */"
"public Variance(Variance original) {
    copy(original, this);
}","public void test5260() throws Throwable {
    Variance variance0 = new Variance(true, (SecondMoment) null);
    Variance variance1 = null;
    try {
        variance1 = new Variance(variance0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.math.stat.descriptive.moment.Variance"", e);
    }
}","/**
 * Copy constructor, creates a new {@code Variance} identical
 * to the {@code original}
 *
 * @param original the {@code Variance} instance to copy
 */"
"public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, weights, begin, length)) {
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            double accum = 0.0;
            double dev = 0.0;
            double accum2 = 0.0;
            for (int i = begin; i < begin + length; i++) {
                dev = values[i] - mean;
                accum += weights[i] * (dev * dev);
                accum2 += weights[i] * dev;
            }
            double sumWts = 0;
            for (int i = 0; i < weights.length; i++) {
                sumWts += weights[i];
            }
            if (isBiasCorrected) {
                var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);
            } else {
                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;
            }
        }
    }
    return var;
}","public void test5361() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[7];
    doubleArray0[2] = 2383.658299371;
    double double0 = variance0.evaluate(doubleArray0, doubleArray0, (-69.257727), 2, 2);
    assertEquals(8.005128697287491E-10, double0, 0.01);
}","/**
 * Returns the weighted variance of the entries in the specified portion of
 * the input array, using the precomputed weighted mean value.  Returns
 * <code>Double.NaN</code> if the designated subarray is empty.
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre></p>
 * <p>
 * The formula used assumes that the supplied mean value is the weighted arithmetic
 * mean of the sample data, not a known population parameter. This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 *     <li>the start and length arguments do not determine a valid array</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param mean the precomputed weighted mean value
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"public double evaluate(final double[] values, final double mean, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, begin, length)) {
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            double accum = 0.0;
            double dev = 0.0;
            double accum2 = 0.0;
            for (int i = begin; i < begin + length; i++) {
                dev = values[i] - mean;
                accum += dev * dev;
                accum2 += dev;
            }
            double len = length;
            if (isBiasCorrected) {
                var = (accum - (accum2 * accum2 / len)) / (len - 1.0);
            } else {
                var = (accum - (accum2 * accum2 / len)) / len;
            }
        }
    }
    return var;
}","public void test5462() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[6];
    double double0 = variance0.evaluate(doubleArray0, 1564.0723334678, 0, 3);
    assertEquals(9.313225746154785E-10, double0, 0.01);
}","/**
 * Returns the variance of the entries in the specified portion of
 * the input array, using the precomputed mean value.  Returns
 * <code>Double.NaN</code> if the designated subarray is empty.
 * <p>
 * See {@link Variance} for details on the computing algorithm.</p>
 * <p>
 * The formula used assumes that the supplied mean value is the arithmetic
 * mean of the sample data, not a known population parameter.  This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if the array is null.</p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param mean the precomputed mean value
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the array is null or the array index
 *  parameters are not valid
 */"
"public double evaluate(final double[] values, final double mean, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, begin, length)) {
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            double accum = 0.0;
            double dev = 0.0;
            double accum2 = 0.0;
            for (int i = begin; i < begin + length; i++) {
                dev = values[i] - mean;
                accum += dev * dev;
                accum2 += dev;
            }
            double len = length;
            if (isBiasCorrected) {
                var = (accum - (accum2 * accum2 / len)) / (len - 1.0);
            } else {
                var = (accum - (accum2 * accum2 / len)) / len;
            }
        }
    }
    return var;
}","public void test5563() throws Throwable {
    Variance variance0 = new Variance(true);
    double[] doubleArray0 = new double[6];
    double double0 = variance0.evaluate(doubleArray0, 0.0, 1, 1);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Returns the variance of the entries in the specified portion of
 * the input array, using the precomputed mean value.  Returns
 * <code>Double.NaN</code> if the designated subarray is empty.
 * <p>
 * See {@link Variance} for details on the computing algorithm.</p>
 * <p>
 * The formula used assumes that the supplied mean value is the arithmetic
 * mean of the sample data, not a known population parameter.  This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if the array is null.</p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param mean the precomputed mean value
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the array is null or the array index
 *  parameters are not valid
 */"
"public boolean isBiasCorrected() {
    return isBiasCorrected;
}","public void test5564() throws Throwable {
    Variance variance0 = new Variance(true);
    double[] doubleArray0 = new double[6];
    double double0 = variance0.evaluate(doubleArray0, 0.0, 1, 1);
    assertTrue(variance0.isBiasCorrected());
}","/**
 * @return Returns the isBiasCorrected.
 */"
"public double evaluate(final double[] values, final double mean, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, begin, length)) {
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            double accum = 0.0;
            double dev = 0.0;
            double accum2 = 0.0;
            for (int i = begin; i < begin + length; i++) {
                dev = values[i] - mean;
                accum += dev * dev;
                accum2 += dev;
            }
            double len = length;
            if (isBiasCorrected) {
                var = (accum - (accum2 * accum2 / len)) / (len - 1.0);
            } else {
                var = (accum - (accum2 * accum2 / len)) / len;
            }
        }
    }
    return var;
}","public void test5665() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    Variance variance0 = new Variance(false, secondMoment0);
    double[] doubleArray0 = new double[8];
    double double0 = variance0.evaluate(doubleArray0, 0.0, 2143800142, 2143800142);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Returns the variance of the entries in the specified portion of
 * the input array, using the precomputed mean value.  Returns
 * <code>Double.NaN</code> if the designated subarray is empty.
 * <p>
 * See {@link Variance} for details on the computing algorithm.</p>
 * <p>
 * The formula used assumes that the supplied mean value is the arithmetic
 * mean of the sample data, not a known population parameter.  This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if the array is null.</p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param mean the precomputed mean value
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the array is null or the array index
 *  parameters are not valid
 */"
"public boolean isBiasCorrected() {
    return isBiasCorrected;
}","public void test5666() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    Variance variance0 = new Variance(false, secondMoment0);
    double[] doubleArray0 = new double[8];
    double double0 = variance0.evaluate(doubleArray0, 0.0, 2143800142, 2143800142);
    assertFalse(variance0.isBiasCorrected());
}","/**
 * @return Returns the isBiasCorrected.
 */"
"public double evaluate(final double[] values, final double mean, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, begin, length)) {
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            double accum = 0.0;
            double dev = 0.0;
            double accum2 = 0.0;
            for (int i = begin; i < begin + length; i++) {
                dev = values[i] - mean;
                accum += dev * dev;
                accum2 += dev;
            }
            double len = length;
            if (isBiasCorrected) {
                var = (accum - (accum2 * accum2 / len)) / (len - 1.0);
            } else {
                var = (accum - (accum2 * accum2 / len)) / len;
            }
        }
    }
    return var;
}","public void test5767() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[2];
    double double0 = variance0.evaluate(doubleArray0, 185.2, 0, 0);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Returns the variance of the entries in the specified portion of
 * the input array, using the precomputed mean value.  Returns
 * <code>Double.NaN</code> if the designated subarray is empty.
 * <p>
 * See {@link Variance} for details on the computing algorithm.</p>
 * <p>
 * The formula used assumes that the supplied mean value is the arithmetic
 * mean of the sample data, not a known population parameter.  This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if the array is null.</p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param mean the precomputed mean value
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the array is null or the array index
 *  parameters are not valid
 */"
"public boolean isBiasCorrected() {
    return isBiasCorrected;
}","public void test5768() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[2];
    double double0 = variance0.evaluate(doubleArray0, 185.2, 0, 0);
    assertTrue(variance0.isBiasCorrected());
}","/**
 * @return Returns the isBiasCorrected.
 */"
"public double evaluate(final double[] values, final double[] weights, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, weights, begin, length)) {
        clear();
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            Mean mean = new Mean();
            double m = mean.evaluate(values, weights, begin, length);
            var = evaluate(values, weights, m, begin, length);
        }
    }
    return var;
}","public void test5869() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[7];
    doubleArray0[2] = 2383.658299371;
    double double0 = variance0.evaluate(doubleArray0, doubleArray0, 2, 2);
    assertEquals(0.0, double0, 0.01);
}","/**
 * <p>Returns the weighted variance of the entries in the specified portion of
 * the input array, or <code>Double.NaN</code> if the designated subarray
 * is empty.</p>
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - weightedMean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre>
 * where weightedMean is the weighted mean</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length)); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 *     <li>the start and length arguments do not determine a valid array</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if either array is null.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the weighted variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"public boolean isBiasCorrected() {
    return isBiasCorrected;
}","public void test5970() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[7];
    doubleArray0[1] = 2383.658299371;
    double double0 = variance0.evaluate(doubleArray0, doubleArray0, 1, 1);
    assertTrue(variance0.isBiasCorrected());
}","/**
 * @return Returns the isBiasCorrected.
 */"
"public double evaluate(final double[] values, final double[] weights, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, weights, begin, length)) {
        clear();
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            Mean mean = new Mean();
            double m = mean.evaluate(values, weights, begin, length);
            var = evaluate(values, weights, m, begin, length);
        }
    }
    return var;
}","public void test5971() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[7];
    doubleArray0[1] = 2383.658299371;
    double double0 = variance0.evaluate(doubleArray0, doubleArray0, 1, 1);
    assertEquals(0.0, double0, 0.01);
}","/**
 * <p>Returns the weighted variance of the entries in the specified portion of
 * the input array, or <code>Double.NaN</code> if the designated subarray
 * is empty.</p>
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - weightedMean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre>
 * where weightedMean is the weighted mean</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length)); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 *     <li>the start and length arguments do not determine a valid array</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if either array is null.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the weighted variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"@Override
public double evaluate(final double[] values, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, begin, length)) {
        clear();
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            Mean mean = new Mean();
            double m = mean.evaluate(values, begin, length);
            var = evaluate(values, m, begin, length);
        }
    }
    return var;
}","public void test6072() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[5];
    double double0 = variance0.evaluate(doubleArray0, 1, 1);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Returns the variance of the entries in the specified portion of
 * the input array, or <code>Double.NaN</code> if the designated subarray
 * is empty.
 * <p>
 * See {@link Variance} for details on the computing algorithm.</p>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if the array is null.</p>
 *
 * @param values the input array
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the array is null or the array index
 *  parameters are not valid
 */"
"public boolean isBiasCorrected() {
    return isBiasCorrected;
}","public void test6073() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[5];
    double double0 = variance0.evaluate(doubleArray0, 1, 1);
    assertTrue(variance0.isBiasCorrected());
}","/**
 * @return Returns the isBiasCorrected.
 */"
"public boolean isBiasCorrected() {
    return isBiasCorrected;
}","public void test6174() throws Throwable {
    Variance variance0 = new Variance();
    variance0.clear();
    assertTrue(variance0.isBiasCorrected());
}","/**
 * @return Returns the isBiasCorrected.
 */"
"public boolean isBiasCorrected() {
    return isBiasCorrected;
}","public void test6275() throws Throwable {
    SecondMoment secondMoment0 = new SecondMoment();
    Variance variance0 = new Variance(secondMoment0);
    variance0.clear();
    assertTrue(variance0.isBiasCorrected());
}","/**
 * @return Returns the isBiasCorrected.
 */"
"public boolean isBiasCorrected() {
    return isBiasCorrected;
}","public void test6376() throws Throwable {
    Variance variance0 = new Variance();
    Variance.copy(variance0, variance0);
    assertTrue(variance0.isBiasCorrected());
}","/**
 * @return Returns the isBiasCorrected.
 */"
"public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, weights, begin, length)) {
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            double accum = 0.0;
            double dev = 0.0;
            double accum2 = 0.0;
            for (int i = begin; i < begin + length; i++) {
                dev = values[i] - mean;
                accum += weights[i] * (dev * dev);
                accum2 += weights[i] * dev;
            }
            double sumWts = 0;
            for (int i = 0; i < weights.length; i++) {
                sumWts += weights[i];
            }
            if (isBiasCorrected) {
                var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);
            } else {
                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;
            }
        }
    }
    return var;
}","public void test6477() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[9];
    doubleArray0[1] = 2383.658299371;
    double double0 = variance0.evaluate(doubleArray0, doubleArray0, 2383.658299371, 1, 1);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Returns the weighted variance of the entries in the specified portion of
 * the input array, using the precomputed weighted mean value.  Returns
 * <code>Double.NaN</code> if the designated subarray is empty.
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre></p>
 * <p>
 * The formula used assumes that the supplied mean value is the weighted arithmetic
 * mean of the sample data, not a known population parameter. This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 *     <li>the start and length arguments do not determine a valid array</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param mean the precomputed weighted mean value
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"public boolean isBiasCorrected() {
    return isBiasCorrected;
}","public void test6478() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[9];
    doubleArray0[1] = 2383.658299371;
    double double0 = variance0.evaluate(doubleArray0, doubleArray0, 2383.658299371, 1, 1);
    assertTrue(variance0.isBiasCorrected());
}","/**
 * @return Returns the isBiasCorrected.
 */"
"public boolean isBiasCorrected() {
    return isBiasCorrected;
}","public void test6579() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[2];
    variance0.setBiasCorrected(false);
    double double0 = variance0.evaluate(doubleArray0, (-593.756682));
    assertFalse(variance0.isBiasCorrected());
}","/**
 * @return Returns the isBiasCorrected.
 */"
"public double evaluate(final double[] values, final double mean) {
    return evaluate(values, mean, 0, values.length);
}","public void test6580() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[2];
    variance0.setBiasCorrected(false);
    double double0 = variance0.evaluate(doubleArray0, (-593.756682));
    assertEquals(0.0, double0, 0.01);
}","/**
 * Returns the variance of the entries in the input array, using the
 * precomputed mean value.  Returns <code>Double.NaN</code> if the array
 * is empty.
 * <p>
 * See {@link Variance} for details on the computing algorithm.</p>
 * <p>
 * If <code>isBiasCorrected</code> is <code>true</code> the formula used
 * assumes that the supplied mean value is the arithmetic mean of the
 * sample data, not a known population parameter.  If the mean is a known
 * population parameter, or if the ""population"" version of the variance is
 * desired, set <code>isBiasCorrected</code> to <code>false</code> before
 * invoking this method.</p>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if the array is null.</p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param mean the precomputed mean value
 * @return the variance of the values or Double.NaN if the array is empty
 * @throws IllegalArgumentException if the array is null
 */"
"public boolean isBiasCorrected() {
    return isBiasCorrected;
}","public void test6681() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[1];
    double double0 = variance0.evaluate(doubleArray0);
    assertTrue(variance0.isBiasCorrected());
}","/**
 * @return Returns the isBiasCorrected.
 */"
"@Override
public double evaluate(final double[] values) {
    if (values == null) {
        throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);
    }
    return evaluate(values, 0, values.length);
}","public void test6682() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[1];
    double double0 = variance0.evaluate(doubleArray0);
    assertEquals(0.0, double0, 0.01);
}","/**
 * Returns the variance of the entries in the input array, or
 * <code>Double.NaN</code> if the array is empty.
 * <p>
 * See {@link Variance} for details on the computing algorithm.</p>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if the array is null.</p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the array is null
 */"
"public boolean isBiasCorrected() {
    return isBiasCorrected;
}","public void test6783() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[9];
    double double0 = variance0.evaluate(doubleArray0, 0, 0);
    assertTrue(variance0.isBiasCorrected());
}","/**
 * @return Returns the isBiasCorrected.
 */"
"@Override
public double evaluate(final double[] values, final int begin, final int length) {
    double var = Double.NaN;
    if (test(values, begin, length)) {
        clear();
        if (length == 1) {
            var = 0.0;
        } else if (length > 1) {
            Mean mean = new Mean();
            double m = mean.evaluate(values, begin, length);
            var = evaluate(values, m, begin, length);
        }
    }
    return var;
}","public void test6784() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[9];
    double double0 = variance0.evaluate(doubleArray0, 0, 0);
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * Returns the variance of the entries in the specified portion of
 * the input array, or <code>Double.NaN</code> if the designated subarray
 * is empty.
 * <p>
 * See {@link Variance} for details on the computing algorithm.</p>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if the array is null.</p>
 *
 * @param values the input array
 * @param begin index of the first array element to include
 * @param length the number of elements to include
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the array is null or the array index
 *  parameters are not valid
 */"
"public double evaluate() {
    return evaluate(storedData);
}","public void test6885() throws Throwable {
    Variance variance0 = new Variance();
    // Undeclared exception!
    try {
        variance0.evaluate();
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // input array
        //
        verifyException(""org.apache.commons.math.stat.descriptive.moment.Variance"", e);
    }
}","/**
 * Returns the result of evaluating the statistic over the stored data.
 * <p>
 * The stored array is the one which was set by previous calls to
 * </p>
 * @return the value of the statistic applied to the stored data
 */"
"public long getN() {
    return moment.getN();
}","public void test6986() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[2];
    variance0.setBiasCorrected(false);
    variance0.incrementAll(doubleArray0);
    double double0 = variance0.getResult();
    assertEquals(2L, variance0.getN());
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getResult() {
    if (moment.n == 0) {
        return Double.NaN;
    } else if (moment.n == 1) {
        return 0d;
    } else {
        if (isBiasCorrected) {
            return moment.m2 / (moment.n - 1d);
        } else {
            return moment.m2 / (moment.n);
        }
    }
}","public void test6987() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[2];
    variance0.setBiasCorrected(false);
    variance0.incrementAll(doubleArray0);
    double double0 = variance0.getResult();
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public long getN() {
    return moment.getN();
}","public void test7088() throws Throwable {
    Variance variance0 = new Variance();
    variance0.increment(0L);
    double double0 = variance0.getResult();
    assertEquals(1L, variance0.getN());
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getResult() {
    if (moment.n == 0) {
        return Double.NaN;
    } else if (moment.n == 1) {
        return 0d;
    } else {
        if (isBiasCorrected) {
            return moment.m2 / (moment.n - 1d);
        } else {
            return moment.m2 / (moment.n);
        }
    }
}","public void test7089() throws Throwable {
    Variance variance0 = new Variance();
    variance0.increment(0L);
    double double0 = variance0.getResult();
    assertEquals(0.0, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"@Override
public double getResult() {
    if (moment.n == 0) {
        return Double.NaN;
    } else if (moment.n == 1) {
        return 0d;
    } else {
        if (isBiasCorrected) {
            return moment.m2 / (moment.n - 1d);
        } else {
            return moment.m2 / (moment.n);
        }
    }
}","public void test7190() throws Throwable {
    Variance variance0 = new Variance();
    double double0 = variance0.getResult();
    assertEquals(Double.NaN, double0, 0.01);
}","/**
 * {@inheritDoc}
 */"
"public boolean isBiasCorrected() {
    return isBiasCorrected;
}","public void test7191() throws Throwable {
    Variance variance0 = new Variance();
    double double0 = variance0.getResult();
    assertTrue(variance0.isBiasCorrected());
}","/**
 * @return Returns the isBiasCorrected.
 */"
"public boolean isBiasCorrected() {
    return isBiasCorrected;
}","public void test7292() throws Throwable {
    Variance variance0 = new Variance();
    variance0.getN();
    assertTrue(variance0.isBiasCorrected());
}","/**
 * @return Returns the isBiasCorrected.
 */"
"public boolean isBiasCorrected() {
    return isBiasCorrected;
}","public void test7393() throws Throwable {
    Variance variance0 = new Variance((SecondMoment) null);
    variance0.increment((-1542.981158));
    assertTrue(variance0.isBiasCorrected());
}","/**
 * @return Returns the isBiasCorrected.
 */"
"public boolean isBiasCorrected() {
    return isBiasCorrected;
}","public void test7494() throws Throwable {
    Variance variance0 = new Variance();
    Variance variance1 = new Variance(variance0);
    assertTrue(variance1.isBiasCorrected());
}","/**
 * @return Returns the isBiasCorrected.
 */"
"public double evaluate(final double[] values, final double[] weights) {
    return evaluate(values, weights, 0, values.length);
}","public void test7595() throws Throwable {
    Variance variance0 = new Variance();
    double[] doubleArray0 = new double[4];
    // Undeclared exception!
    try {
        variance0.evaluate(doubleArray0, doubleArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // weigth array must contain at least one non-zero value
        //
        verifyException(""org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic"", e);
    }
}","/**
 * <p>
 * Returns the weighted variance of the entries in the the input array.</p>
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - weightedMean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre>
 * where weightedMean is the weighted mean</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length)); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if either array is null.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @return the weighted variance of the values
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"public double evaluate(final double[] values, final double[] weights, final double mean) {
    return evaluate(values, weights, mean, 0, values.length);
}","public void test7696() throws Throwable {
    Variance variance0 = new Variance(true);
    double[] doubleArray0 = new double[5];
    // Undeclared exception!
    try {
        variance0.evaluate(doubleArray0, (double[]) null, 0.25534194707870483);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // input array
        //
        verifyException(""org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic"", e);
    }
}","/**
 * <p>Returns the weighted variance of the values in the input array, using
 * the precomputed weighted mean value.</p>
 * <p>
 * Uses the formula <pre>
 *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)
 * </pre></p>
 * <p>
 * The formula used assumes that the supplied mean value is the weighted arithmetic
 * mean of the sample data, not a known population parameter. This method
 * is supplied only to save computation when the mean has already been
 * computed.</p>
 * <p>
 * This formula will not return the same result as the unweighted variance when all
 * weights are equal, unless all weights are equal to 1. The formula assumes that
 * weights are to be treated as ""expansion values,"" as will be the case if for example
 * the weights represent frequency counts. To normalize weights so that the denominator
 * in the variance computation equals the length of the input vector minus one, use <pre>
 *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>
 * </pre>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if any of the following are true:
 * <ul><li>the values array is null</li>
 *     <li>the weights array is null</li>
 *     <li>the weights array does not have the same length as the values array</li>
 *     <li>the weights array contains one or more infinite values</li>
 *     <li>the weights array contains one or more NaN values</li>
 *     <li>the weights array contains negative values</li>
 * </ul></p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @param weights the weights array
 * @param mean the precomputed weighted mean value
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the parameters are not valid
 * @since 2.1
 */"
"@Override
public double evaluate(final double[] values) {
    if (values == null) {
        throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);
    }
    return evaluate(values, 0, values.length);
}","public void test7797() throws Throwable {
    Variance variance0 = new Variance(false);
    // Undeclared exception!
    try {
        variance0.evaluate((double[]) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // input array
        //
        verifyException(""org.apache.commons.math.stat.descriptive.moment.Variance"", e);
    }
}","/**
 * Returns the variance of the entries in the input array, or
 * <code>Double.NaN</code> if the array is empty.
 * <p>
 * See {@link Variance} for details on the computing algorithm.</p>
 * <p>
 * Returns 0 for a single-value (i.e. length = 1) sample.</p>
 * <p>
 * Throws <code>IllegalArgumentException</code> if the array is null.</p>
 * <p>
 * Does not change the internal state of the statistic.</p>
 *
 * @param values the input array
 * @return the variance of the values or Double.NaN if length = 0
 * @throws IllegalArgumentException if the array is null
 */"
