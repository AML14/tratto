focal_method,test_prefix,docstring
"public String substring(int startIndex, int endIndex) {
    endIndex = validateRange(startIndex, endIndex);
    return new String(buffer, startIndex, endIndex - startIndex);
}","public void test0000() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder("""");
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer();
    StringBuffer stringBuffer0 = new StringBuffer();
    StrBuilder strBuilder1 = strBuilder0.appendln(stringBuffer0);
    Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
    strBuilder0.toString();
    StrTokenizer.getCSVInstance();
    strBuilder_StrBuilderTokenizer0.forEachRemaining(consumer0);
    strBuilder_StrBuilderTokenizer0.reset("""");
    strBuilder_StrBuilderTokenizer0.getContent();
    int int0 = 32;
    strBuilder0.lastIndexOf('k', 32);
    float float0 = 3071.121F;
    StrBuilder strBuilder2 = strBuilder0.appendln(3071.121F);
    strBuilder2.toStringBuffer();
    // Undeclared exception!
    try {
        strBuilder1.substring((-1), 32);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -1
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Extracts a portion of this string builder as a string.
 * <p>
 * Note: This method treats an endIndex greater than the length of the
 * builder as equal to the length of the builder, and continues
 * without error, unlike StringBuffer or String.
 *
 * @param startIndex  the start index, inclusive, must be valid
 * @param endIndex  the end index, exclusive, must be valid except
 *  that if too large it is treated as end of string
 * @return the new string
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public int lastIndexOf(String str, int startIndex) {
    startIndex = (startIndex >= size ? size - 1 : startIndex);
    if (str == null || startIndex < 0) {
        return -1;
    }
    int strLen = str.length();
    if (strLen > 0 && strLen <= size) {
        if (strLen == 1) {
            return lastIndexOf(str.charAt(0), startIndex);
        }
        outer: for (int i = startIndex - strLen + 1; i >= 0; i--) {
            for (int j = 0; j < strLen; j++) {
                if (str.charAt(j) != buffer[i + j]) {
                    continue outer;
                }
            }
            return i;
        }
    } else if (strLen == 0) {
        return startIndex;
    }
    return -1;
}","public void test0011() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder((-552));
    StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader();
    strBuilder_StrBuilderReader0.mark((-552));
    StrBuilder.StrBuilderWriter strBuilder_StrBuilderWriter0 = strBuilder0.new StrBuilderWriter();
    char[] charArray0 = new char[8];
    charArray0[0] = 'f';
    charArray0[1] = 'f';
    charArray0[2] = '{';
    charArray0[3] = 'L';
    charArray0[4] = 'O';
    charArray0[5] = '[';
    charArray0[6] = '+';
    charArray0[7] = 'G';
    strBuilder_StrBuilderWriter0.write(charArray0);
    strBuilder_StrBuilderWriter0.write(4);
    strBuilder_StrBuilderWriter0.flush();
    StrBuilder strBuilder1 = strBuilder0.deleteAll('N');
    strBuilder_StrBuilderReader0.close();
    strBuilder1.replaceAll((String) null, ""!E|@^;:4aA79"");
    strBuilder1.insert(0, ""0VrUXQ*z"");
    strBuilder1.lastIndexOf(""0VrUXQ*z"", 101);
}","/**
 * Searches the string builder to find the last reference to the specified
 * string starting searching from the given index.
 * <p>
 * Note that a null input string will return -1, whereas the JDK throws an exception.
 *
 * @param str  the string to find, null returns -1
 * @param startIndex  the index to start at, invalid index rounded to edge
 * @return the last index of the string, or -1 if not found
 */"
"public StrBuilder replaceFirst(String searchStr, String replaceStr) {
    int searchLen = (searchStr == null ? 0 : searchStr.length());
    if (searchLen > 0) {
        int index = indexOf(searchStr, 0);
        if (index >= 0) {
            int replaceLen = (replaceStr == null ? 0 : replaceStr.length());
            replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);
        }
    }
    return this;
}","public void test0022() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(0);
    strBuilder0.midString(0, 0);
    strBuilder0.size = 0;
    StrBuilder strBuilder1 = strBuilder0.appendln('[');
    StrBuilder strBuilder2 = strBuilder1.insert(0, ']');
    strBuilder2.appendln(strBuilder0, 0, 0);
    StrBuilder strBuilder3 = strBuilder2.ensureCapacity(4);
    strBuilder3.setNewLineText("""");
    strBuilder1.asReader();
    strBuilder0.appendln((StringBuffer) null);
    strBuilder0.hashCode();
    StrBuilder strBuilder4 = strBuilder1.appendln((Object) strBuilder0);
    StrMatcher strMatcher0 = StrMatcher.doubleQuoteMatcher();
    strBuilder4.lastIndexOf(strMatcher0, 685);
    StrBuilder strBuilder5 = strBuilder4.append('q');
    strBuilder5.asTokenizer();
    strBuilder1.replaceFirst((String) null, """");
}","/**
 * Replaces the first instance of the search string with the replace string.
 *
 * @param searchStr  the search string, null causes no action to occur
 * @param replaceStr  the replace string, null is equivalent to an empty string
 * @return this, to enable chaining
 */"
"public StrBuilder append(int value) {
    return append(String.valueOf(value));
}","public void test0033() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""R/6*Sy"");
    strBuilder0.setNewLineText(""E/rUkv\""*AV\""z./;IRE7"");
    strBuilder0.append(108);
}","/**
 * Appends an int value to the string builder using <code>String.valueOf</code>.
 *
 * @param value  the value to append
 * @return this, to enable chaining
 */"
"public StrBuilder append(StringBuffer str, int startIndex, int length) {
    if (str == null) {
        return appendNull();
    }
    if (startIndex < 0 || startIndex > str.length()) {
        throw new StringIndexOutOfBoundsException(""startIndex must be valid"");
    }
    if (length < 0 || (startIndex + length) > str.length()) {
        throw new StringIndexOutOfBoundsException(""length must be valid"");
    }
    if (length > 0) {
        int len = length();
        ensureCapacity(len + length);
        str.getChars(startIndex, startIndex + length, buffer, len);
        size += length;
    }
    return this;
}","public void test0055() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(834);
    String string0 = ""IP"";
    strBuilder0.setNullText(""IP"");
    StrMatcher strMatcher0 = StrMatcher.charSetMatcher(""Zur`0X0?1G`1b ^\"""");
    strBuilder0.contains(strMatcher0);
    strBuilder0.appendFixedWidthPadRight(834, 1754, 'a');
    int int0 = 2432;
    StrBuilder strBuilder1 = strBuilder0.insert(32, 2432);
    StringBuffer stringBuffer0 = new StringBuffer();
    // Undeclared exception!
    try {
        strBuilder1.append(stringBuffer0, (-2840), (-2840));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // startIndex must be valid
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends part of a string buffer to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 */"
"public StrBuilder deleteCharAt(int index) {
    if (index < 0 || index >= size) {
        throw new StringIndexOutOfBoundsException(index);
    }
    deleteImpl(index, index + 1, 1);
    return this;
}","public void test0066() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(0);
    StrBuilder strBuilder1 = strBuilder0.insert(0, true);
    StrBuilder strBuilder2 = strBuilder1.appendln(strBuilder0);
    StrMatcher.NoMatcher strMatcher_NoMatcher0 = new StrMatcher.NoMatcher();
    strBuilder0.lastIndexOf((StrMatcher) strMatcher_NoMatcher0, 0);
    StrBuilder strBuilder3 = strBuilder0.setLength(1959);
    strBuilder0.contains((StrMatcher) null);
    strBuilder0.asTokenizer();
    StrBuilder strBuilder4 = strBuilder0.appendln((double) 0);
    strBuilder2.equalsIgnoreCase(strBuilder4);
    strBuilder4.substring(0);
    strBuilder1.midString(1, 1);
    strBuilder3.asReader();
    strBuilder3.toString();
    strBuilder0.midString(114, 2859);
    strBuilder2.indexOf((StrMatcher) strMatcher_NoMatcher0);
    strBuilder3.insert(989, false);
    strBuilder4.deleteCharAt(114);
}","/**
 * Deletes the character at the specified index.
 *
 * @see #charAt(int)
 * @see #setCharAt(int, char)
 * @param index  the index to delete
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the character at the specified index.
 *
 * @see #setCharAt(int, char)
 * @see #deleteCharAt(int)
 * @param index  the index to retrieve, must be valid
 * @return the character at the index
 * @throws IndexOutOfBoundsException if the index is invalid
 */
public char charAt(int index) {
    if (index < 0 || index >= length()) {
        throw new StringIndexOutOfBoundsException(index);
    }
    return buffer[index];
}","public void test0077() throws Throwable {
    String string0 = ""Invalid startIndex: "";
    StrBuilder strBuilder0 = new StrBuilder(""Invalid startIndex: "");
    String string1 = ""end < start"";
    Object[] objectArray0 = new Object[7];
    // Undeclared exception!
    try {
        strBuilder0.charAt((-894));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -894
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Inserts the string representation of an object into this builder.
 * Inserting null will use the stored null text value.
 *
 * @param index  the index to add at, must be valid
 * @param obj  the object to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */
public StrBuilder insert(int index, Object obj) {
    if (obj == null) {
        return insert(index, nullText);
    }
    return insert(index, obj.toString());
}","public void test0088() throws Throwable {
    String string0 = ""Invalid startIndex: "";
    StrBuilder strBuilder0 = new StrBuilder(""Invalid startIndex: "");
    int int0 = 102;
    // Undeclared exception!
    try {
        strBuilder0.insert(102, (Object) ""Invalid startIndex: "");
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 102
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}",""
"public StrBuilder replace(int startIndex, int endIndex, String replaceStr) {
    endIndex = validateRange(startIndex, endIndex);
    int insertLen = (replaceStr == null ? 0 : replaceStr.length());
    replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen);
    return this;
}","public void test0099() throws Throwable {
    int int0 = 0;
    StrBuilder strBuilder0 = new StrBuilder(0);
    int int1 = 359;
    String string0 = ""$4|MKf2*BS>:o"";
    // Undeclared exception!
    try {
        strBuilder0.replace(359, 1331, ""$4|MKf2*BS>:o"");
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // end < start
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Replaces a portion of the string builder with another string.
 * The length of the inserted string does not have to match the removed length.
 *
 * @param startIndex  the start index, inclusive, must be valid
 * @param endIndex  the end index, exclusive, must be valid except
 *  that if too large it is treated as end of string
 * @param replaceStr  the string to replace with, null means delete range
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Validates parameters defining a range of the builder.
 *
 * @param startIndex  the start index, inclusive, must be valid
 * @param endIndex  the end index, exclusive, must be valid except
 *  that if too large it is treated as end of string
 * @return the new string
 * @throws IndexOutOfBoundsException if the index is invalid
 */
protected int validateRange(int startIndex, int endIndex) {
    if (startIndex < 0) {
        throw new StringIndexOutOfBoundsException(startIndex);
    }
    if (endIndex > size) {
        endIndex = size;
    }
    if (startIndex > endIndex) {
        throw new StringIndexOutOfBoundsException(""end < start"");
    }
    return endIndex;
}","public void test01010() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    Object object0 = new Object();
    StrBuilder strBuilder1 = strBuilder0.appendln(object0);
    StrMatcher strMatcher0 = StrMatcher.trimMatcher();
    StrMatcher strMatcher1 = StrMatcher.quoteMatcher();
    char[] charArray0 = new char[1];
    charArray0[0] = '0';
    StrMatcher.charSetMatcher(charArray0);
    strBuilder0.appendNull();
    strBuilder1.lastIndexOf(strMatcher1);
    strBuilder1.replaceFirst(strMatcher0, """");
    strBuilder0.getNewLineText();
    strBuilder0.appendSeparator((String) null, 31);
    // Undeclared exception!
    try {
        strBuilder1.validateRange((-481), 3133);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -481
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}",""
"public StrBuilder appendln(StringBuffer str, int startIndex, int length) {
    return append(str, startIndex, length).appendNewLine();
}","public void test01212() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    StringBuffer stringBuffer0 = new StringBuffer();
    // Undeclared exception!
    try {
        strBuilder0.appendln(stringBuffer0, (-1435), 627);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // startIndex must be valid
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends part of a string buffer followed by a new line to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 * @since 2.3
 */"
"public StrBuilder append(StringBuffer str, int startIndex, int length) {
    if (str == null) {
        return appendNull();
    }
    if (startIndex < 0 || startIndex > str.length()) {
        throw new StringIndexOutOfBoundsException(""startIndex must be valid"");
    }
    if (length < 0 || (startIndex + length) > str.length()) {
        throw new StringIndexOutOfBoundsException(""length must be valid"");
    }
    if (length > 0) {
        int len = length();
        ensureCapacity(len + length);
        str.getChars(startIndex, startIndex + length, buffer, len);
        size += length;
    }
    return this;
}","public void test01313() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder((-2289));
    char[] charArray0 = new char[1];
    charArray0[0] = 'U';
    StrMatcher strMatcher0 = StrMatcher.charSetMatcher(charArray0);
    strBuilder0.indexOf(strMatcher0, (-2289));
    strBuilder0.lastIndexOf('U', 0);
    strBuilder0.append((StringBuffer) null, 39, (-2289));
}","/**
 * Appends part of a string buffer to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 */"
"public StrBuilder insert(int index, long value) {
    return insert(index, String.valueOf(value));
}","public void test01414() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    // Undeclared exception!
    try {
        strBuilder0.insert(5255, 0L);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 5255
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts the value into this builder.
 *
 * @param index  the index to add at, must be valid
 * @param value  the value to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the text to be appended when null is added.
 *
 * @return the null text, null means no append
 */
public String getNullText() {
    return nullText;
}","public void test01515() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder((-4755));
    strBuilder0.getNullText();
}",""
"public StrBuilder appendFixedWidthPadLeft(int value, int width, char padChar) {
    return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);
}","public void test01616() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(5);
    strBuilder0.appendFixedWidthPadLeft((-3054), 5, '@');
}","/**
 * Appends an object to the builder padding on the left to a fixed width.
 * The <code>String.valueOf</code> of the <code>int</code> value is used.
 * If the formatted value is larger than the length, the left hand side is lost.
 *
 * @param value  the value to append
 * @param width  the fixed field width, zero or negative has no effect
 * @param padChar  the pad character to use
 * @return this, to enable chaining
 */"
"public StrBuilder append(String str, int startIndex, int length) {
    if (str == null) {
        return appendNull();
    }
    if (startIndex < 0 || startIndex > str.length()) {
        throw new StringIndexOutOfBoundsException(""startIndex must be valid"");
    }
    if (length < 0 || (startIndex + length) > str.length()) {
        throw new StringIndexOutOfBoundsException(""length must be valid"");
    }
    if (length > 0) {
        int len = length();
        ensureCapacity(len + length);
        str.getChars(startIndex, startIndex + length, buffer, len);
        size += length;
    }
    return this;
}","public void test01717() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""end < start"");
    strBuilder0.appendln(2231.297820044);
    strBuilder0.append(""end < start"", 0, 0);
}","/**
 * Appends part of a string to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 */"
"public StrBuilder appendln(String str, int startIndex, int length) {
    return append(str, startIndex, length).appendNewLine();
}","public void test01818() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder("""");
    // Undeclared exception!
    try {
        strBuilder0.appendln("";r:Wjx#u!$'pC;co+,~"", 2358, 102);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // startIndex must be valid
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends part of a string followed by a new line to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 * @since 2.3
 */"
"public StrBuilder insert(int index, char[] chars) {
    validateIndex(index);
    if (chars == null) {
        return insert(index, nullText);
    }
    int len = chars.length;
    if (len > 0) {
        ensureCapacity(size + len);
        System.arraycopy(buffer, index, buffer, index + len, size - index);
        System.arraycopy(chars, 0, buffer, index, len);
        size += len;
    }
    return this;
}","public void test01919() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(102);
    StrBuilder strBuilder1 = strBuilder0.replaceAll('\""', '}');
    // Undeclared exception!
    try {
        strBuilder1.insert(114, (char[]) null);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 114
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts the character array into this builder.
 * Inserting null will use the stored null text value.
 *
 * @param index  the index to add at, must be valid
 * @param chars  the char array to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public int lastIndexOf(String str, int startIndex) {
    startIndex = (startIndex >= size ? size - 1 : startIndex);
    if (str == null || startIndex < 0) {
        return -1;
    }
    int strLen = str.length();
    if (strLen > 0 && strLen <= size) {
        if (strLen == 1) {
            return lastIndexOf(str.charAt(0), startIndex);
        }
        outer: for (int i = startIndex - strLen + 1; i >= 0; i--) {
            for (int j = 0; j < strLen; j++) {
                if (str.charAt(j) != buffer[i + j]) {
                    continue outer;
                }
            }
            return i;
        }
    } else if (strLen == 0) {
        return startIndex;
    }
    return -1;
}","public void test02020() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(834);
    strBuilder0.setNullText("""");
    StrMatcher strMatcher0 = StrMatcher.charSetMatcher(""Zur`0X0?1G`1b ^\"""");
    strBuilder0.contains(strMatcher0);
    strBuilder0.appendFixedWidthPadRight(834, 1754, 'a');
    StrBuilder strBuilder1 = strBuilder0.insert(834, ""O{Foni=+j>qdQ"");
    strBuilder0.insert(32, 2432);
    strBuilder1.lastIndexOf("""", 2432);
}","/**
 * Searches the string builder to find the last reference to the specified
 * string starting searching from the given index.
 * <p>
 * Note that a null input string will return -1, whereas the JDK throws an exception.
 *
 * @param str  the string to find, null returns -1
 * @param startIndex  the index to start at, invalid index rounded to edge
 * @return the last index of the string, or -1 if not found
 */"
"public StrBuilder append(int value) {
    return append(String.valueOf(value));
}","public void test02121() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(0);
    StrMatcher.NoMatcher strMatcher_NoMatcher0 = new StrMatcher.NoMatcher();
    StrBuilder strBuilder1 = strBuilder0.deleteFirst((StrMatcher) strMatcher_NoMatcher0);
    strBuilder1.insert(0, (-1177.988));
    strBuilder0.append(102);
}","/**
 * Appends an int value to the string builder using <code>String.valueOf</code>.
 *
 * @param value  the value to append
 * @return this, to enable chaining
 */"
"public int indexOf(String str, int startIndex) {
    startIndex = (startIndex < 0 ? 0 : startIndex);
    if (str == null || startIndex >= size) {
        return -1;
    }
    int strLen = str.length();
    if (strLen == 1) {
        return indexOf(str.charAt(0), startIndex);
    }
    if (strLen == 0) {
        return startIndex;
    }
    if (strLen > size) {
        return -1;
    }
    char[] thisBuf = buffer;
    int len = size - strLen + 1;
    outer: for (int i = startIndex; i < len; i++) {
        for (int j = 0; j < strLen; j++) {
            if (str.charAt(j) != thisBuf[i + j]) {
                continue outer;
            }
        }
        return i;
    }
    return -1;
}","public void test02222() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(2510);
    strBuilder0.indexOf("""", 2510);
}","/**
 * Searches the string builder to find the first reference to the specified
 * string starting searching from the given index.
 * <p>
 * Note that a null input string will return -1, whereas the JDK throws an exception.
 *
 * @param str  the string to find, null returns -1
 * @param startIndex  the index to start at, invalid index rounded to edge
 * @return the first index of the string, or -1 if not found
 */"
"public StrBuilder appendSeparator(char separator) {
    if (size() > 0) {
        append(separator);
    }
    return this;
}","public void test02323() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""m7C:={b?9kU0J;pg"");
    StrBuilder strBuilder1 = strBuilder0.append('^');
    StrBuilder strBuilder2 = strBuilder0.append(2059);
    strBuilder2.midString(360, 360);
    strBuilder0.isEmpty();
    strBuilder0.asWriter();
    StrBuilder strBuilder3 = strBuilder1.appendln((double) 2059);
    strBuilder3.toString();
    strBuilder1.appendSeparator('$');
}","/**
 * Appends a separator if the builder is currently non-empty.
 * The separator is appended using {@link #append(char)}.
 * <p>
 * This method is useful for adding a separator each time around the
 * loop except the first.
 * <pre>
 * for (Iterator it = list.iterator(); it.hasNext(); ) {
 *   appendSeparator(',');
 *   append(it.next());
 * }
 * </pre>
 * Note that for this simple example, you should use
 * {@link #appendWithSeparators(Collection, String)}.
 *
 * @param separator  the separator to use
 * @return this, to enable chaining
 * @since 2.3
 */"
"public StrBuilder appendln(boolean value) {
    return append(value).appendNewLine();
}","public void test02424() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder("""");
    Integer integer0 = new Integer((-2195));
    StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) integer0, (-2195), '_');
    strBuilder1.appendln(true);
}","/**
 * Appends a boolean value followed by a new line to the string builder.
 *
 * @param value  the value to append
 * @return this, to enable chaining
 * @since 2.3
 */"
"public Object next() {
    if (hasNext()) {
        return tokens[tokenPos++];
    }
    throw new NoSuchElementException();
}","public void test02525() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""org.apache.commons.lang.ArrayUtils"");
    strBuilder0.deleteFirst(""org.apache.commons.lang.ArrayUtils"");
    strBuilder0.contains('{');
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer();
    // Undeclared exception!
    try {
        strBuilder_StrBuilderTokenizer0.next();
        fail(""Expecting exception: NoSuchElementException"");
    } catch (NoSuchElementException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.text.StrTokenizer"", e);
    }
}","/**
 * Gets the next token. This method is equivalent to {@link #nextToken()}.
 *
 * @return the next String token
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the text to be appended when null is added.
 *
 * @return the null text, null means no append
 */
public String getNullText() {
    return nullText;
}","public void test02626() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""@.k"");
    strBuilder0.append(true);
    StringBuffer stringBuffer0 = new StringBuffer(1346);
    strBuilder0.appendln(stringBuffer0);
    strBuilder0.contains('7');
    strBuilder0.asReader();
    strBuilder0.getNullText();
}",""
"public StrBuilder insert(int index, char[] chars, int offset, int length) {
    validateIndex(index);
    if (chars == null) {
        return insert(index, nullText);
    }
    if (offset < 0 || offset > chars.length) {
        throw new StringIndexOutOfBoundsException(""Invalid offset: "" + offset);
    }
    if (length < 0 || offset + length > chars.length) {
        throw new StringIndexOutOfBoundsException(""Invalid length: "" + length);
    }
    if (length > 0) {
        ensureCapacity(size + length);
        System.arraycopy(buffer, index, buffer, index + length, size - index);
        System.arraycopy(chars, offset, buffer, index, length);
        size += length;
    }
    return this;
}","public void test02727() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(456);
    char[] charArray0 = new char[0];
    // Undeclared exception!
    try {
        strBuilder0.insert((-846), charArray0, (-846), 1404);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -846
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts part of the character array into this builder.
 * Inserting null will use the stored null text value.
 *
 * @param index  the index to add at, must be valid
 * @param chars  the char array to insert
 * @param offset  the offset into the character array to start at, must be valid
 * @param length  the length of the character array part to copy, must be positive
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if any index is invalid
 */"
"public StrBuilder appendln(StringBuffer str, int startIndex, int length) {
    return append(str, startIndex, length).appendNewLine();
}","public void test02828() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(31);
    StringBuffer stringBuffer0 = new StringBuffer(31);
    // Undeclared exception!
    try {
        strBuilder0.appendln(stringBuffer0, Integer.MAX_VALUE, Integer.MAX_VALUE);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // startIndex must be valid
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends part of a string buffer followed by a new line to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 * @since 2.3
 */"
"public StrBuilder insert(int index, long value) {
    return insert(index, String.valueOf(value));
}","public void test02929() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder((-36));
    StrBuilder strBuilder1 = strBuilder0.append('[');
    strBuilder1.appendNewLine();
    char[] charArray0 = new char[5];
    charArray0[0] = '[';
    charArray0[1] = 'B';
    charArray0[2] = '[';
    charArray0[3] = '[';
    charArray0[4] = '[';
    strBuilder0.buffer = charArray0;
    // Undeclared exception!
    try {
        strBuilder0.insert((-2793), (long) (-2793));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -2793
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts the value into this builder.
 *
 * @param index  the index to add at, must be valid
 * @param value  the value to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder insert(int index, char[] chars) {
    validateIndex(index);
    if (chars == null) {
        return insert(index, nullText);
    }
    int len = chars.length;
    if (len > 0) {
        ensureCapacity(size + len);
        System.arraycopy(buffer, index, buffer, index + len, size - index);
        System.arraycopy(chars, 0, buffer, index, len);
        size += len;
    }
    return this;
}","public void test03030() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(3);
    char[] charArray0 = new char[3];
    charArray0[0] = '8';
    charArray0[1] = 'F';
    charArray0[2] = 'T';
    // Undeclared exception!
    try {
        strBuilder0.insert(3, charArray0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 3
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts the character array into this builder.
 * Inserting null will use the stored null text value.
 *
 * @param index  the index to add at, must be valid
 * @param chars  the char array to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder insert(int index, double value) {
    return insert(index, String.valueOf(value));
}","public void test03131() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    strBuilder0.asTokenizer();
    StrBuilder strBuilder1 = strBuilder0.setNullText(""org.apache.commons.lang.text.StrBuilder$StrBuilderReader"");
    strBuilder1.asWriter();
    strBuilder0.asTokenizer();
    strBuilder0.indexOf(""abVox2Zob+^G"", 3);
    strBuilder0.asReader();
    // Undeclared exception!
    try {
        strBuilder1.insert((-1), 0.0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -1
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts the value into this builder.
 *
 * @param index  the index to add at, must be valid
 * @param value  the value to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"//-----------------------------------------------------------------------
//    /**
//     * Gets a String version of the string builder by calling the internal
//     * constructor of String by reflection.
//     * <p>
//     * WARNING: You must not use the StrBuilder after calling this method
//     * as the buffer is now shared with the String object. To ensure this,
//     * the internal character array is set to null, so you will get
//     * NullPointerExceptions on all method calls.
//     *
//     * @return the builder as a String
//     */
//    public String toSharedString() {
//        try {
//            Constructor con = String.class.getDeclaredConstructor(
//                new Class[] {int.class, int.class, char[].class});
//            con.setAccessible(true);
//            char[] buffer = buf;
//            buf = null;
//            size = -1;
//            nullText = null;
//            return (String) con.newInstance(
//                new Object[] {new Integer(0), new Integer(size), buffer});
//
//        } catch (Exception ex) {
//            ex.printStackTrace();
//            throw new UnsupportedOperationException(""StrBuilder.toSharedString is unsupported: "" + ex.getMessage());
//        }
//    }
//-----------------------------------------------------------------------
/**
 * Checks the contents of this builder against another to see if they
 * contain the same character content ignoring case.
 *
 * @param other  the object to check, null returns false
 * @return true if the builders contain the same characters in the same order
 */
public boolean equalsIgnoreCase(StrBuilder other) {
    if (this == other) {
        return true;
    }
    if (this.size != other.size) {
        return false;
    }
    char[] thisBuf = this.buffer;
    char[] otherBuf = other.buffer;
    for (int i = size - 1; i >= 0; i--) {
        char c1 = thisBuf[i];
        char c2 = otherBuf[i];
        if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) {
            return false;
        }
    }
    return true;
}","public void test03232() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(4769);
    strBuilder0.toString();
    StrBuilder strBuilder1 = strBuilder0.appendSeparator('r');
    strBuilder1.appendln(4769);
    strBuilder0.equalsIgnoreCase(strBuilder1);
}",""
"public StrBuilder appendln(char[] chars, int startIndex, int length) {
    return append(chars, startIndex, length).appendNewLine();
}","public void test03333() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(325);
    char[] charArray0 = new char[4];
    charArray0[0] = 'G';
    charArray0[1] = '\\';
    charArray0[2] = 'x';
    charArray0[3] = '&';
    // Undeclared exception!
    try {
        strBuilder0.appendln(charArray0, (-4647), (-4647));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // Invalid startIndex: -4647
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends a char array followed by a new line to the string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param chars  the char array to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 * @since 2.3
 */"
"public StrBuilder append(char[] chars, int startIndex, int length) {
    if (chars == null) {
        return appendNull();
    }
    if (startIndex < 0 || startIndex > chars.length) {
        throw new StringIndexOutOfBoundsException(""Invalid startIndex: "" + length);
    }
    if (length < 0 || (startIndex + length) > chars.length) {
        throw new StringIndexOutOfBoundsException(""Invalid length: "" + length);
    }
    if (length > 0) {
        int len = length();
        ensureCapacity(len + length);
        System.arraycopy(chars, startIndex, buffer, len, length);
        size += length;
    }
    return this;
}","public void test03434() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""F@o!8"");
    StrBuilder strBuilder1 = strBuilder0.deleteAll((StrMatcher) null);
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer();
    StrMatcher strMatcher0 = strBuilder_StrBuilderTokenizer0.getIgnoredMatcher();
    strBuilder0.lastIndexOf(strMatcher0);
    char[] charArray0 = new char[8];
    charArray0[0] = '\\';
    charArray0[1] = '1';
    charArray0[2] = ';';
    charArray0[3] = '<';
    charArray0[4] = 'T';
    charArray0[5] = '_';
    charArray0[6] = 'H';
    charArray0[7] = ';';
    // Undeclared exception!
    try {
        strBuilder1.append(charArray0, (-1), (-1));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // Invalid startIndex: -1
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends a char array to the string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param chars  the char array to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 */"
"public StrBuilder appendln(char[] chars, int startIndex, int length) {
    return append(chars, startIndex, length).appendNewLine();
}","public void test03535() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(1147);
    StrMatcher strMatcher0 = StrMatcher.trimMatcher();
    StrMatcher.charSetMatcher(""VEvev5~fcs["");
    StrMatcher.stringMatcher(""Invalid startIndex: "");
    strBuilder0.deleteAll(strMatcher0);
    StrBuilder strBuilder1 = strBuilder0.setNewLineText(""VEvev5~fcs["");
    char[] charArray0 = new char[4];
    charArray0[0] = '#';
    charArray0[1] = '4';
    charArray0[2] = '8';
    charArray0[3] = 'Z';
    // Undeclared exception!
    try {
        strBuilder1.appendln(charArray0, 1147, 1147);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // Invalid startIndex: 1147
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends a char array followed by a new line to the string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param chars  the char array to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 * @since 2.3
 */"
"public StrBuilder appendln(boolean value) {
    return append(value).appendNewLine();
}","public void test03636() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(0);
    StrBuilder strBuilder1 = strBuilder0.append("""");
    StrBuilder strBuilder2 = new StrBuilder(0);
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder2.new StrBuilderTokenizer();
    StrMatcher strMatcher0 = strBuilder_StrBuilderTokenizer0.getQuoteMatcher();
    strBuilder1.replaceFirst(strMatcher0, """");
    strBuilder0.append(true);
    strBuilder0.insert(0, ""nOfir>3qi9T!m"");
    StrBuilder strBuilder3 = strBuilder0.appendNewLine();
    strBuilder0.contains(""nOfir>3qi9T!m"");
    strBuilder3.appendln(true);
}","/**
 * Appends a boolean value followed by a new line to the string builder.
 *
 * @param value  the value to append
 * @return this, to enable chaining
 * @since 2.3
 */"
"public StrBuilder replaceFirst(StrMatcher matcher, String replaceStr) {
    return replace(matcher, replaceStr, 0, size, 1);
}","public void test03737() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    strBuilder0.toStringBuffer();
    StrMatcher strMatcher0 = StrMatcher.trimMatcher();
    char[] charArray0 = new char[6];
    charArray0[0] = 'G';
    charArray0[1] = 'v';
    charArray0[2] = 'F';
    charArray0[3] = ')';
    charArray0[4] = 'z';
    charArray0[5] = 'K';
    StrMatcher.charSetMatcher(charArray0);
    strBuilder0.replaceFirst(strMatcher0, ""qJAKF$}f4^#)k}"");
}","/**
 * Replaces the first match within the builder with the replace string.
 * <p>
 * Matchers can be used to perform advanced replace behaviour.
 * For example you could write a matcher to replace
 * where the character 'a' is followed by a number.
 *
 * @param matcher  the matcher to use to find the deletion, null causes no action
 * @param replaceStr  the replace string, null is equivalent to an empty string
 * @return this, to enable chaining
 */"
"public StrBuilder append(char[] chars, int startIndex, int length) {
    if (chars == null) {
        return appendNull();
    }
    if (startIndex < 0 || startIndex > chars.length) {
        throw new StringIndexOutOfBoundsException(""Invalid startIndex: "" + length);
    }
    if (length < 0 || (startIndex + length) > chars.length) {
        throw new StringIndexOutOfBoundsException(""Invalid length: "" + length);
    }
    if (length > 0) {
        int len = length();
        ensureCapacity(len + length);
        System.arraycopy(chars, startIndex, buffer, len, length);
        size += length;
    }
    return this;
}","public void test03838() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(1);
    StrBuilder strBuilder1 = strBuilder0.appendln((long) 1);
    strBuilder1.replaceFirst(""^}(QHCFk ]cM"", ""^}(QHCFk ]cM"");
    StrBuilder strBuilder2 = strBuilder1.append(1);
    strBuilder2.equals((Object) ""b-rZ@n:cnT*bzu`"");
    StrBuilder strBuilder3 = strBuilder1.replaceAll(""end < start"", ""end < start"");
    char[] charArray0 = new char[9];
    charArray0[0] = 't';
    charArray0[1] = '@';
    charArray0[2] = 'P';
    charArray0[3] = '~';
    charArray0[4] = '*';
    charArray0[5] = '!';
    charArray0[6] = 'K';
    charArray0[7] = '/';
    charArray0[8] = 't';
    strBuilder3.append(charArray0, 1, 1);
}","/**
 * Appends a char array to the string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param chars  the char array to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 */"
"//-----------------------------------------------------------------------
/**
 * Replaces the search character with the replace character
 * throughout the builder.
 *
 * @param search  the search character
 * @param replace  the replace character
 * @return this, to enable chaining
 */
public StrBuilder replaceAll(char search, char replace) {
    if (search != replace) {
        for (int i = 0; i < size; i++) {
            if (buffer[i] == search) {
                buffer[i] = replace;
            }
        }
    }
    return this;
}","public void test03939() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder((-480));
    strBuilder0.appendSeparator((String) null);
    strBuilder0.replaceAll('!', '!');
}",""
"public StrBuilder appendln(char[] chars) {
    return append(chars).appendNewLine();
}","public void test04040() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    char[] charArray0 = new char[3];
    charArray0[0] = 'r';
    charArray0[1] = '8';
    charArray0[2] = 'a';
    strBuilder0.appendln(charArray0);
}","/**
 * Appends a char array followed by a new line to the string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param chars  the char array to append
 * @return this, to enable chaining
 * @since 2.3
 */"
"public StrBuilder appendFixedWidthPadLeft(int value, int width, char padChar) {
    return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);
}","public void test04242() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    StrBuilder.StrBuilderWriter strBuilder_StrBuilderWriter0 = strBuilder0.new StrBuilderWriter();
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer();
    StrTokenizer strTokenizer0 = strBuilder_StrBuilderTokenizer0.setEmptyTokenAsNull(false);
    strBuilder0.appendWithSeparators((Iterator) strTokenizer0, ""nX%?OQrc\""CY\""1z(nX*"");
    strBuilder_StrBuilderWriter0.write(539);
    strBuilder0.appendFixedWidthPadLeft(48, 1972, 'R');
}","/**
 * Appends an object to the builder padding on the left to a fixed width.
 * The <code>String.valueOf</code> of the <code>int</code> value is used.
 * If the formatted value is larger than the length, the left hand side is lost.
 *
 * @param value  the value to append
 * @param width  the fixed field width, zero or negative has no effect
 * @param padChar  the pad character to use
 * @return this, to enable chaining
 */"
"public StrBuilder insert(int index, float value) {
    return insert(index, String.valueOf(value));
}","public void test04343() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(0);
    StrBuilder strBuilder1 = strBuilder0.insert(0, 'd');
    String string0 = """";
    strBuilder1.appendSeparator('d');
    int int0 = (-1396);
    // Undeclared exception!
    try {
        strBuilder0.insert((-1396), (float) (-1396));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -1396
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts the value into this builder.
 *
 * @param index  the index to add at, must be valid
 * @param value  the value to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Reverses the string builder placing each character in the opposite index.
 *
 * @return this, to enable chaining
 */
public StrBuilder reverse() {
    if (size == 0) {
        return this;
    }
    int half = size / 2;
    char[] buf = buffer;
    for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++, rightIdx--) {
        char swap = buf[leftIdx];
        buf[leftIdx] = buf[rightIdx];
        buf[rightIdx] = swap;
    }
    return this;
}","public void test04444() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(0);
    StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader();
    strBuilder_StrBuilderReader0.reset();
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer();
    StrMatcher strMatcher0 = strBuilder_StrBuilderTokenizer0.getDelimiterMatcher();
    strBuilder0.indexOf(strMatcher0, 0);
    strBuilder0.lastIndexOf('m');
    strBuilder0.trim();
    StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((Object) ""2P.nU#v77@y"", 0, 'H');
    strBuilder1.reverse();
}",""
"public StrBuilder append(StringBuffer str, int startIndex, int length) {
    if (str == null) {
        return appendNull();
    }
    if (startIndex < 0 || startIndex > str.length()) {
        throw new StringIndexOutOfBoundsException(""startIndex must be valid"");
    }
    if (length < 0 || (startIndex + length) > str.length()) {
        throw new StringIndexOutOfBoundsException(""length must be valid"");
    }
    if (length > 0) {
        int len = length();
        ensureCapacity(len + length);
        str.getChars(startIndex, startIndex + length, buffer, len);
        size += length;
    }
    return this;
}","public void test04545() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    StrBuilder strBuilder1 = strBuilder0.append(4090.064F);
    StrMatcher strMatcher0 = StrMatcher.doubleQuoteMatcher();
    strBuilder1.contains(strMatcher0);
    StrBuilder strBuilder2 = strBuilder0.reverse();
    StringBuffer stringBuffer0 = new StringBuffer(0);
    // Undeclared exception!
    try {
        strBuilder2.append(stringBuffer0, 3904, 1713);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // startIndex must be valid
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends part of a string buffer to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 */"
"public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {
    if (width > 0) {
        ensureCapacity(size + width);
        String str = (obj == null ? getNullText() : obj.toString());
        int strLen = str.length();
        if (strLen >= width) {
            str.getChars(0, width, buffer, size);
        } else {
            int padLen = width - strLen;
            str.getChars(0, strLen, buffer, size);
            for (int i = 0; i < padLen; i++) {
                buffer[size + strLen + i] = padChar;
            }
        }
        size += width;
    }
    return this;
}","public void test04646() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""aQGev(0"");
    StrBuilder strBuilder1 = strBuilder0.setLength(0);
    strBuilder1.append(false);
    strBuilder1.appendFixedWidthPadLeft(0, 0, '$');
    strBuilder0.appendln((float) 0);
    strBuilder0.getNullText();
    strBuilder0.appendFixedWidthPadRight((Object) ""aQGev(0"", 0, '&');
}","/**
 * Appends an object to the builder padding on the right to a fixed length.
 * The <code>toString</code> of the object is used.
 * If the object is larger than the length, the right hand side is lost.
 * If the object is null, null text value is used.
 *
 * @param obj  the object to append, null uses null text
 * @param width  the fixed field width, zero or negative has no effect
 * @param padChar  the pad character to use
 * @return this, to enable chaining
 */"
"public StrBuilder insert(int index, char[] chars) {
    validateIndex(index);
    if (chars == null) {
        return insert(index, nullText);
    }
    int len = chars.length;
    if (len > 0) {
        ensureCapacity(size + len);
        System.arraycopy(buffer, index, buffer, index + len, size - index);
        System.arraycopy(chars, 0, buffer, index, len);
        size += len;
    }
    return this;
}","public void test04747() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    StrBuilder strBuilder1 = strBuilder0.deleteFirst("""");
    strBuilder1.setLength(779);
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer();
    strBuilder_StrBuilderTokenizer0.getContent();
    char[] charArray0 = new char[7];
    charArray0[0] = 'J';
    charArray0[1] = 'r';
    charArray0[2] = 'p';
    charArray0[3] = 'x';
    charArray0[4] = 'c';
    charArray0[5] = '.';
    charArray0[6] = 'v';
    strBuilder0.insert(115, charArray0);
}","/**
 * Inserts the character array into this builder.
 * Inserting null will use the stored null text value.
 *
 * @param index  the index to add at, must be valid
 * @param chars  the char array to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder insert(int index, boolean value) {
    validateIndex(index);
    if (value) {
        ensureCapacity(size + 4);
        System.arraycopy(buffer, index, buffer, index + 4, size - index);
        buffer[index++] = 't';
        buffer[index++] = 'r';
        buffer[index++] = 'u';
        buffer[index] = 'e';
        size += 4;
    } else {
        ensureCapacity(size + 5);
        System.arraycopy(buffer, index, buffer, index + 5, size - index);
        buffer[index++] = 'f';
        buffer[index++] = 'a';
        buffer[index++] = 'l';
        buffer[index++] = 's';
        buffer[index] = 'e';
        size += 5;
    }
    return this;
}","public void test04848() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""F8rnT"");
    // Undeclared exception!
    try {
        strBuilder0.insert(34, false);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 34
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts the value into this builder.
 *
 * @param index  the index to add at, must be valid
 * @param value  the value to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Trims the builder by removing characters less than or equal to a space
 * from the beginning and end.
 *
 * @return this, to enable chaining
 */
public StrBuilder trim() {
    if (size == 0) {
        return this;
    }
    int len = size;
    char[] buf = buffer;
    int pos = 0;
    while (pos < len && buf[pos] <= ' ') {
        pos++;
    }
    while (pos < len && buf[len - 1] <= ' ') {
        len--;
    }
    if (len < size) {
        delete(len, size);
    }
    if (pos > 0) {
        delete(0, pos);
    }
    return this;
}","public void test04949() throws Throwable {
    StrMatcher.stringMatcher(""0sr$z5YcO{Qh!-"");
    StrMatcher.stringMatcher(""0sr$z5YcO{Qh!-"");
    StrBuilder strBuilder0 = new StrBuilder();
    StrBuilder strBuilder1 = new StrBuilder(""evj=I"");
    strBuilder0.appendln((Object) strBuilder1);
    StrMatcher.stringMatcher("""");
    strBuilder0.trim();
}",""
"public StrBuilder insert(int index, char[] chars, int offset, int length) {
    validateIndex(index);
    if (chars == null) {
        return insert(index, nullText);
    }
    if (offset < 0 || offset > chars.length) {
        throw new StringIndexOutOfBoundsException(""Invalid offset: "" + offset);
    }
    if (length < 0 || offset + length > chars.length) {
        throw new StringIndexOutOfBoundsException(""Invalid length: "" + length);
    }
    if (length > 0) {
        ensureCapacity(size + length);
        System.arraycopy(buffer, index, buffer, index + length, size - index);
        System.arraycopy(chars, offset, buffer, index, length);
        size += length;
    }
    return this;
}","public void test05050() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""Invalid offset: "");
    StrMatcher.StringMatcher strMatcher_StringMatcher0 = new StrMatcher.StringMatcher(""Invalid offset: "");
    strBuilder0.indexOf((StrMatcher) strMatcher_StringMatcher0);
    strBuilder0.indexOf('g', 0);
    StringBuffer stringBuffer0 = new StringBuffer(""Invalid offset: "");
    StrBuilder strBuilder1 = strBuilder0.append(stringBuffer0);
    stringBuffer0.insert(0, 0);
    strBuilder0.append(0);
    char[] charArray0 = new char[1];
    charArray0[0] = 'g';
    strBuilder1.getChars(charArray0);
    // Undeclared exception!
    try {
        strBuilder0.insert(0, charArray0, 1547, 0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // Invalid offset: 1547
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts part of the character array into this builder.
 * Inserting null will use the stored null text value.
 *
 * @param index  the index to add at, must be valid
 * @param chars  the char array to insert
 * @param offset  the offset into the character array to start at, must be valid
 * @param length  the length of the character array part to copy, must be positive
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if any index is invalid
 */"
"public StrBuilder insert(int index, char value) {
    validateIndex(index);
    ensureCapacity(size + 1);
    System.arraycopy(buffer, index, buffer, index + 1, size - index);
    buffer[index] = value;
    size++;
    return this;
}","public void test05151() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder((-1411));
    char[] charArray0 = new char[2];
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer();
    Object object0 = strBuilder_StrBuilderTokenizer0.clone();
    strBuilder0.appendFixedWidthPadLeft(object0, (-1411), 'I');
    charArray0[0] = '^';
    charArray0[1] = 'k';
    StrMatcher strMatcher0 = StrMatcher.charSetMatcher(charArray0);
    strBuilder0.lastIndexOf(strMatcher0);
    // Undeclared exception!
    try {
        strBuilder0.insert((-1), 'B');
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -1
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts the value into this builder.
 *
 * @param index  the index to add at, must be valid
 * @param value  the value to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder clear() {
    size = 0;
    return this;
}","public void test05252() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""[-'7ZJ8:PDo"");
    strBuilder0.contains((StrMatcher) null);
    strBuilder0.clear();
}","/**
 * Clears the string builder (convenience Collections API style method).
 * <p>
 * This method does not reduce the size of the internal character buffer.
 * To do that, call <code>clear()</code> followed by {@link #minimizeCapacity()}.
 * <p>
 * This method is the same as {@link #setLength(int)} called with zero
 * and is provided to match the API of Collections.
 *
 * @return this, to enable chaining
 */"
"public StrBuilder append(String str) {
    if (str == null) {
        return appendNull();
    }
    int strLen = str.length();
    if (strLen > 0) {
        int len = length();
        ensureCapacity(len + strLen);
        str.getChars(0, strLen, buffer, len);
        size += strLen;
    }
    return this;
}","public void test05353() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(0);
    StrBuilder strBuilder1 = new StrBuilder(""}Fks{,-}\""j"");
    strBuilder0.append(strBuilder1, 0, 0);
    char[] charArray0 = strBuilder0.toCharArray(0, 0);
    strBuilder0.getNewLineText();
    StrTokenizer strTokenizer0 = StrTokenizer.getTSVInstance(charArray0);
    StrBuilder strBuilder2 = strBuilder0.appendWithSeparators((Iterator) strTokenizer0, (String) null);
    strBuilder2.appendPadding(101, 'M');
    strBuilder0.contains((String) null);
    strBuilder0.clear();
    strBuilder1.append(""}Fks{,-}\""j"");
}","/**
 * Appends a string to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string to append
 * @return this, to enable chaining
 */"
"public StrBuilder append(StrBuilder str) {
    if (str == null) {
        return appendNull();
    }
    int strLen = str.length();
    if (strLen > 0) {
        int len = length();
        ensureCapacity(len + strLen);
        System.arraycopy(str.buffer, 0, buffer, len, strLen);
        size += strLen;
    }
    return this;
}","public void test05454() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""hfA.sSygE5K RmG>j@"");
    strBuilder0.getNullText();
    Reader reader0 = strBuilder0.asReader();
    StrBuilder strBuilder1 = strBuilder0.appendln(1);
    Object[] objectArray0 = new Object[9];
    objectArray0[0] = (Object) strBuilder0;
    objectArray0[1] = (Object) null;
    objectArray0[2] = (Object) null;
    objectArray0[3] = (Object) null;
    objectArray0[4] = (Object) strBuilder1;
    objectArray0[5] = (Object) strBuilder0;
    objectArray0[6] = (Object) strBuilder1;
    objectArray0[7] = (Object) reader0;
    objectArray0[8] = (Object) strBuilder1;
    strBuilder1.appendWithSeparators(objectArray0, """");
    strBuilder0.append(strBuilder1);
}","/**
 * Appends another string builder to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string builder to append
 * @return this, to enable chaining
 */"
"//-----------------------------------------------------------------------
/**
 * Appends a separator if the builder is currently non-empty.
 * Appending a null separator will have no effect.
 * The separator is appended using {@link #append(String)}.
 * <p>
 * This method is useful for adding a separator each time around the
 * loop except the first.
 * <pre>
 * for (Iterator it = list.iterator(); it.hasNext(); ) {
 *   appendSeparator("","");
 *   append(it.next());
 * }
 * </pre>
 * Note that for this simple example, you should use
 * {@link #appendWithSeparators(Collection, String)}.
 *
 * @param separator  the separator to use, null means no separator
 * @return this, to enable chaining
 * @since 2.3
 */
public StrBuilder appendSeparator(String separator) {
    if (separator != null && size() > 0) {
        append(separator);
    }
    return this;
}","public void test05555() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    StrBuilder strBuilder1 = new StrBuilder((-1976));
    strBuilder0.appendSeparator(""length must be valid"");
}",""
"public StrBuilder minimizeCapacity() {
    if (buffer.length > length()) {
        char[] old = buffer;
        buffer = new char[length()];
        System.arraycopy(old, 0, buffer, 0, size);
    }
    return this;
}","public void test05656() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""!cw?O'"");
    StrMatcher strMatcher0 = StrMatcher.tabMatcher();
    StrBuilder strBuilder1 = strBuilder0.deleteAll(strMatcher0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""!cw?O'"");
    strBuilder1.append(stringBuffer0, 5, 0);
    StrBuilder strBuilder2 = strBuilder0.deleteAll('2');
    strBuilder2.asReader();
    strBuilder0.appendSeparator("",@T \r *13="", 0);
    strBuilder0.insert(0, 0L);
    strBuilder1.minimizeCapacity();
}","/**
 * Minimizes the capacity to the actual length of the string.
 *
 * @return this, to enable chaining
 */"
"public StrBuilder insert(int index, boolean value) {
    validateIndex(index);
    if (value) {
        ensureCapacity(size + 4);
        System.arraycopy(buffer, index, buffer, index + 4, size - index);
        buffer[index++] = 't';
        buffer[index++] = 'r';
        buffer[index++] = 'u';
        buffer[index] = 'e';
        size += 4;
    } else {
        ensureCapacity(size + 5);
        System.arraycopy(buffer, index, buffer, index + 5, size - index);
        buffer[index++] = 'f';
        buffer[index++] = 'a';
        buffer[index++] = 'l';
        buffer[index++] = 's';
        buffer[index] = 'e';
        size += 5;
    }
    return this;
}","public void test05757() throws Throwable {
    String string0 = """";
    StrBuilder strBuilder0 = new StrBuilder("""");
    StrMatcher.NoMatcher strMatcher_NoMatcher0 = new StrMatcher.NoMatcher();
    char[] charArray0 = new char[3];
    charArray0[0] = 'Z';
    strBuilder0.append(0L);
    charArray0[1] = '=';
    charArray0[2] = '{';
    strMatcher_NoMatcher0.isMatch(charArray0, 0);
    strBuilder0.indexOf((StrMatcher) strMatcher_NoMatcher0, 0);
    StrBuilder strBuilder1 = strBuilder0.trim();
    strBuilder0.setLength(44);
    StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader();
    strBuilder_StrBuilderReader0.close();
    // Undeclared exception!
    try {
        strBuilder1.insert((-4608), false);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -4608
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts the value into this builder.
 *
 * @param index  the index to add at, must be valid
 * @param value  the value to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public int indexOf(char ch, int startIndex) {
    startIndex = (startIndex < 0 ? 0 : startIndex);
    if (startIndex >= size) {
        return -1;
    }
    char[] thisBuf = buffer;
    for (int i = startIndex; i < size; i++) {
        if (thisBuf[i] == ch) {
            return i;
        }
    }
    return -1;
}","public void test05858() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    StrBuilder strBuilder1 = strBuilder0.appendln(0.0F);
    strBuilder1.setNullText(""~lK+A\""=1tR"");
    StrBuilder strBuilder2 = strBuilder0.setNewLineText(""Invalid offset: "");
    StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder2.new StrBuilderReader();
    strBuilder_StrBuilderReader0.reset();
    strBuilder_StrBuilderReader0.ready();
    strBuilder2.lastIndexOf('-', 0);
    StrBuilder strBuilder3 = strBuilder2.appendSeparator(""~mx"");
    strBuilder0.append("""");
    strBuilder3.appendPadding(0, '8');
    strBuilder2.appendln((long) (-1));
    strBuilder1.indexOf('8', (-1));
}","/**
 * Searches the string builder to find the first reference to the specified char.
 *
 * @param ch  the character to find
 * @param startIndex  the index to start at, invalid index rounded to edge
 * @return the first index of the character, or -1 if not found
 */"
"public StrBuilder insert(int index, int value) {
    return insert(index, String.valueOf(value));
}","public void test05959() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(0);
    StrBuilder strBuilder1 = new StrBuilder(""hOe"");
    strBuilder0.appendln((Object) strBuilder1);
    StrBuilder strBuilder2 = strBuilder0.appendln((Object) null);
    int int0 = 117;
    strBuilder0.delete(0, 0);
    // Undeclared exception!
    try {
        strBuilder2.insert(117, 1092);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 117
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts the value into this builder.
 *
 * @param index  the index to add at, must be valid
 * @param value  the value to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder insert(int index, char[] chars, int offset, int length) {
    validateIndex(index);
    if (chars == null) {
        return insert(index, nullText);
    }
    if (offset < 0 || offset > chars.length) {
        throw new StringIndexOutOfBoundsException(""Invalid offset: "" + offset);
    }
    if (length < 0 || offset + length > chars.length) {
        throw new StringIndexOutOfBoundsException(""Invalid length: "" + length);
    }
    if (length > 0) {
        ensureCapacity(size + length);
        System.arraycopy(buffer, index, buffer, index + length, size - index);
        System.arraycopy(chars, offset, buffer, index, length);
        size += length;
    }
    return this;
}","public void test06060() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    char char0 = 'C';
    String string0 = """";
    StrBuilder strBuilder1 = strBuilder0.replaceFirst(""file.encoding"", """");
    int int0 = (-3153);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    strBuilder1.appendln(stringBuffer0);
    strBuilder1.asWriter();
    int int1 = 3;
    // Undeclared exception!
    try {
        strBuilder1.insert((-3153), (char[]) null, (-125), 3);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -3153
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts part of the character array into this builder.
 * Inserting null will use the stored null text value.
 *
 * @param index  the index to add at, must be valid
 * @param chars  the char array to insert
 * @param offset  the offset into the character array to start at, must be valid
 * @param length  the length of the character array part to copy, must be positive
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if any index is invalid
 */"
"public StrBuilder insert(int index, float value) {
    return insert(index, String.valueOf(value));
}","public void test06161() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadRight(0, 0, '?');
    int int0 = 97;
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer();
    StrTokenizer strTokenizer0 = strBuilder_StrBuilderTokenizer0.setEmptyTokenAsNull(true);
    StrBuilder strBuilder2 = strBuilder0.appendAll((Iterator) strTokenizer0);
    strBuilder0.appendFixedWidthPadRight(1600, 97, '0');
    char[] charArray0 = new char[1];
    charArray0[0] = '?';
    strBuilder2.appendln(charArray0);
    strBuilder2.reverse();
    StrMatcher.NoMatcher strMatcher_NoMatcher0 = new StrMatcher.NoMatcher();
    StrBuilder strBuilder3 = strBuilder1.deleteFirst((StrMatcher) strMatcher_NoMatcher0);
    String string0 = ""SJx|R!R5YnYXU%"";
    strBuilder3.appendWithSeparators((Iterator) strBuilder_StrBuilderTokenizer0, ""SJx|R!R5YnYXU%"");
    StrBuilder strBuilder4 = strBuilder3.appendFixedWidthPadRight(97, 0, '?');
    // Undeclared exception!
    try {
        strBuilder4.insert((-739), 725.932F);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -739
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts the value into this builder.
 *
 * @param index  the index to add at, must be valid
 * @param value  the value to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder insert(int index, boolean value) {
    validateIndex(index);
    if (value) {
        ensureCapacity(size + 4);
        System.arraycopy(buffer, index, buffer, index + 4, size - index);
        buffer[index++] = 't';
        buffer[index++] = 'r';
        buffer[index++] = 'u';
        buffer[index] = 'e';
        size += 4;
    } else {
        ensureCapacity(size + 5);
        System.arraycopy(buffer, index, buffer, index + 5, size - index);
        buffer[index++] = 'f';
        buffer[index++] = 'a';
        buffer[index++] = 'l';
        buffer[index++] = 's';
        buffer[index] = 'e';
        size += 5;
    }
    return this;
}","public void test06262() throws Throwable {
    String string0 = """";
    StrBuilder strBuilder0 = new StrBuilder("""");
    StrMatcher.NoMatcher strMatcher_NoMatcher0 = new StrMatcher.NoMatcher();
    char[] charArray0 = new char[3];
    charArray0[0] = 'Z';
    strBuilder0.append(0L);
    charArray0[1] = '=';
    charArray0[2] = '{';
    strMatcher_NoMatcher0.isMatch(charArray0, 0);
    strBuilder0.indexOf((StrMatcher) strMatcher_NoMatcher0, 0);
    StrBuilder strBuilder1 = strBuilder0.trim();
    strBuilder0.indexOf('\'', (-4608));
    strBuilder0.setLength(44);
    StrBuilder strBuilder2 = strBuilder0.deleteAll((StrMatcher) strMatcher_NoMatcher0);
    StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder2.new StrBuilderReader();
    strBuilder_StrBuilderReader0.close();
    // Undeclared exception!
    try {
        strBuilder1.insert((-4608), false);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -4608
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts the value into this builder.
 *
 * @param index  the index to add at, must be valid
 * @param value  the value to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder append(String str, int startIndex, int length) {
    if (str == null) {
        return appendNull();
    }
    if (startIndex < 0 || startIndex > str.length()) {
        throw new StringIndexOutOfBoundsException(""startIndex must be valid"");
    }
    if (length < 0 || (startIndex + length) > str.length()) {
        throw new StringIndexOutOfBoundsException(""length must be valid"");
    }
    if (length > 0) {
        int len = length();
        ensureCapacity(len + length);
        str.getChars(startIndex, startIndex + length, buffer, len);
        size += length;
    }
    return this;
}","public void test06363() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer();
    StrMatcher strMatcher0 = strBuilder_StrBuilderTokenizer0.getDelimiterMatcher();
    char[] charArray0 = new char[9];
    charArray0[0] = 'R';
    charArray0[1] = '+';
    charArray0[2] = 'r';
    charArray0[3] = ')';
    charArray0[4] = 'A';
    charArray0[5] = 'w';
    charArray0[6] = 'X';
    charArray0[7] = '|';
    charArray0[8] = 'D';
    StrMatcher.charSetMatcher(charArray0);
    strBuilder0.lastIndexOf(strMatcher0);
    // Undeclared exception!
    try {
        strBuilder0.append(""N+yvh}"", 97, 921);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // startIndex must be valid
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends part of a string to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 */"
"public StrBuilder append(char[] chars, int startIndex, int length) {
    if (chars == null) {
        return appendNull();
    }
    if (startIndex < 0 || startIndex > chars.length) {
        throw new StringIndexOutOfBoundsException(""Invalid startIndex: "" + length);
    }
    if (length < 0 || (startIndex + length) > chars.length) {
        throw new StringIndexOutOfBoundsException(""Invalid length: "" + length);
    }
    if (length > 0) {
        int len = length();
        ensureCapacity(len + length);
        System.arraycopy(chars, startIndex, buffer, len, length);
        size += length;
    }
    return this;
}","public void test06464() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(44);
    char[] charArray0 = new char[8];
    charArray0[0] = 'J';
    char char0 = 'y';
    charArray0[1] = 'y';
    charArray0[2] = 't';
    charArray0[3] = '=';
    charArray0[4] = ',';
    charArray0[5] = '`';
    charArray0[6] = 'g';
    charArray0[7] = '|';
    // Undeclared exception!
    try {
        strBuilder0.append(charArray0, 102, 0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // Invalid startIndex: 0
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends a char array to the string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param chars  the char array to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 */"
"public StrBuilder insert(int index, String str) {
    validateIndex(index);
    if (str == null) {
        str = nullText;
    }
    int strLen = (str == null ? 0 : str.length());
    if (strLen > 0) {
        int newSize = size + strLen;
        ensureCapacity(newSize);
        System.arraycopy(buffer, index, buffer, index + strLen, size - index);
        size = newSize;
        str.getChars(0, strLen, buffer, index);
    }
    return this;
}","public void test06565() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(0);
    StrBuilder strBuilder1 = new StrBuilder(""hOe"");
    strBuilder0.appendln((Object) strBuilder1);
    StrBuilder strBuilder2 = strBuilder0.appendln((Object) null);
    strBuilder0.delete(0, 0);
    strBuilder2.insert(5, 1092);
    String string0 = """";
    // Undeclared exception!
    try {
        strBuilder2.insert(117, """");
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 117
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts the string into this builder.
 * Inserting null will use the stored null text value.
 *
 * @param index  the index to add at, must be valid
 * @param str  the string to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Appends a separator if the builder is currently non-empty.
 * Appending a null separator will have no effect.
 * The separator is appended using {@link #append(String)}.
 * <p>
 * This method is useful for adding a separator each time around the
 * loop except the first.
 * <pre>
 * for (Iterator it = list.iterator(); it.hasNext(); ) {
 *   appendSeparator("","");
 *   append(it.next());
 * }
 * </pre>
 * Note that for this simple example, you should use
 * {@link #appendWithSeparators(Collection, String)}.
 *
 * @param separator  the separator to use, null means no separator
 * @return this, to enable chaining
 * @since 2.3
 */
public StrBuilder appendSeparator(String separator) {
    if (separator != null && size() > 0) {
        append(separator);
    }
    return this;
}","public void test06666() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    StrBuilder strBuilder1 = new StrBuilder((-1976));
    strBuilder0.appendFixedWidthPadLeft((Object) strBuilder1, (-1976), ')');
    strBuilder0.appendSeparator(""length must be valid"");
}",""
"public StrBuilder append(StrBuilder str, int startIndex, int length) {
    if (str == null) {
        return appendNull();
    }
    if (startIndex < 0 || startIndex > str.length()) {
        throw new StringIndexOutOfBoundsException(""startIndex must be valid"");
    }
    if (length < 0 || (startIndex + length) > str.length()) {
        throw new StringIndexOutOfBoundsException(""length must be valid"");
    }
    if (length > 0) {
        int len = length();
        ensureCapacity(len + length);
        str.getChars(startIndex, startIndex + length, buffer, len);
        size += length;
    }
    return this;
}","public void test06767() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    StrBuilder strBuilder1 = new StrBuilder(0);
    StrBuilder strBuilder2 = strBuilder1.append(""StrTokenizer"");
    StrBuilder strBuilder3 = strBuilder0.appendln(strBuilder1);
    strBuilder0.toString();
    Object[] objectArray0 = new Object[5];
    objectArray0[0] = (Object) ""StrTokenizer"";
    objectArray0[1] = (Object) strBuilder3;
    StringBuffer stringBuffer0 = new StringBuffer("""");
    strBuilder2.append(stringBuffer0, 0, 0);
    objectArray0[2] = (Object) strBuilder0;
    objectArray0[3] = (Object) ""StrTokenizer\n"";
    objectArray0[4] = (Object) strBuilder1;
    strBuilder2.appendWithSeparators(objectArray0, ""length must be valid"");
    // Undeclared exception!
    try {
        strBuilder3.append(strBuilder2, (-148), 57);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // startIndex must be valid
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends part of a string builder to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 */"
"//-----------------------------------------------------------------------
/**
 * Inserts the string representation of an object into this builder.
 * Inserting null will use the stored null text value.
 *
 * @param index  the index to add at, must be valid
 * @param obj  the object to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */
public StrBuilder insert(int index, Object obj) {
    if (obj == null) {
        return insert(index, nullText);
    }
    return insert(index, obj.toString());
}","public void test06868() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(0);
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer();
    Object object0 = strBuilder_StrBuilderTokenizer0.cloneReset();
    strBuilder0.appendFixedWidthPadRight(object0, (-1066), 'r');
    strBuilder0.insert(0, (Object) """");
}",""
"public StrBuilder append(String str, int startIndex, int length) {
    if (str == null) {
        return appendNull();
    }
    if (startIndex < 0 || startIndex > str.length()) {
        throw new StringIndexOutOfBoundsException(""startIndex must be valid"");
    }
    if (length < 0 || (startIndex + length) > str.length()) {
        throw new StringIndexOutOfBoundsException(""length must be valid"");
    }
    if (length > 0) {
        int len = length();
        ensureCapacity(len + length);
        str.getChars(startIndex, startIndex + length, buffer, len);
        size += length;
    }
    return this;
}","public void test06969() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer();
    char char0 = '_';
    strBuilder_StrBuilderTokenizer0.setQuoteChar('_');
    int int0 = 4333;
    // Undeclared exception!
    try {
        strBuilder0.append(""sZfnd<-{"", 0, 4333);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // length must be valid
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends part of a string to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 */"
"public StrBuilder appendln(StrBuilder str) {
    return append(str).appendNewLine();
}","public void test07070() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder((String) null);
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer();
    strBuilder_StrBuilderTokenizer0.getContent();
    StrBuilder strBuilder1 = new StrBuilder(0);
    strBuilder0.appendln(strBuilder1);
}","/**
 * Appends another string builder followed by a new line to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string builder to append
 * @return this, to enable chaining
 * @since 2.3
 */"
"public int indexOf(String str) {
    return indexOf(str, 0);
}","public void test07171() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder((String) null);
    StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader();
    strBuilder0.leftString(46);
    strBuilder0.rightString(46);
    StrBuilder strBuilder1 = strBuilder0.appendln(""w}?TDcHSVa_C\u0000]"");
    strBuilder1.hashCode();
    strBuilder1.indexOf(""xs{*:,"");
}","/**
 * Searches the string builder to find the first reference to the specified string.
 * <p>
 * Note that a null input string will return -1, whereas the JDK throws an exception.
 *
 * @param str  the string to find, null returns -1
 * @return the first index of the string, or -1 if not found
 */"
"//-----------------------------------------------------------------------
/**
 * Appends each item in an array to the builder without any separators.
 * Appending a null array will have no effect.
 * Each object is appended using {@link #append(Object)}.
 *
 * @param array  the array to append
 * @return this, to enable chaining
 * @since 2.3
 */
public StrBuilder appendAll(Object[] array) {
    if (array != null && array.length > 0) {
        for (int i = 0; i < array.length; i++) {
            append(array[i]);
        }
    }
    return this;
}","public void test07272() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer();
    StrTokenizer strTokenizer0 = strBuilder_StrBuilderTokenizer0.setQuoteChar('i');
    StrBuilder strBuilder1 = strBuilder0.appendWithSeparators((Iterator) strTokenizer0, """");
    Object[] objectArray0 = new Object[7];
    objectArray0[0] = (Object) """";
    objectArray0[1] = (Object) strBuilder_StrBuilderTokenizer0;
    objectArray0[2] = (Object) strBuilder0;
    objectArray0[3] = (Object) strBuilder1;
    objectArray0[4] = (Object) strTokenizer0;
    objectArray0[5] = (Object) """";
    objectArray0[6] = (Object) strBuilder0;
    strBuilder0.appendAll(objectArray0);
}",""
"//-----------------------------------------------------------------------
/**
 * Extracts a portion of this string builder as a string.
 *
 * @param start  the start index, inclusive, must be valid
 * @return the new string
 * @throws IndexOutOfBoundsException if the index is invalid
 */
public String substring(int start) {
    return substring(start, size);
}","public void test07373() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(31);
    // Undeclared exception!
    try {
        strBuilder0.substring(2749);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // end < start
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}",""
"public void getChars(int startIndex, int endIndex, char[] destination, int destinationIndex) {
    if (startIndex < 0) {
        throw new StringIndexOutOfBoundsException(startIndex);
    }
    if (endIndex < 0 || endIndex > length()) {
        throw new StringIndexOutOfBoundsException(endIndex);
    }
    if (startIndex > endIndex) {
        throw new StringIndexOutOfBoundsException(""end < start"");
    }
    System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);
}","public void test07575() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder((-727));
    int int0 = (-45);
    char char0 = 'o';
    StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadRight((-45), 5899, 'o');
    char[] charArray0 = new char[2];
    charArray0[0] = 'k';
    charArray0[1] = 'o';
    // Undeclared exception!
    try {
        strBuilder1.getChars((-727), (-1745), charArray0, 0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -727
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Copies the character array into the specified array.
 *
 * @param startIndex  first index to copy, inclusive, must be valid
 * @param endIndex  last index, exclusive, must be valid
 * @param destination  the destination array, must not be null or too small
 * @param destinationIndex  the index to start copying in destination
 * @throws NullPointerException if the array is null
 * @throws IndexOutOfBoundsException if any index is invalid
 */"
"public void getChars(int startIndex, int endIndex, char[] destination, int destinationIndex) {
    if (startIndex < 0) {
        throw new StringIndexOutOfBoundsException(startIndex);
    }
    if (endIndex < 0 || endIndex > length()) {
        throw new StringIndexOutOfBoundsException(endIndex);
    }
    if (startIndex > endIndex) {
        throw new StringIndexOutOfBoundsException(""end < start"");
    }
    System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);
}","public void test07676() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    String string0 = null;
    StrBuilder strBuilder1 = new StrBuilder((String) null);
    StrBuilder strBuilder2 = strBuilder1.appendSeparator('e', (-1751));
    char[] charArray0 = new char[6];
    charArray0[0] = 'e';
    charArray0[1] = '{';
    charArray0[2] = 'e';
    charArray0[3] = 'e';
    charArray0[4] = 'e';
    charArray0[5] = 'e';
    // Undeclared exception!
    try {
        strBuilder2.getChars(1364, (-1751), charArray0, (-1751));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -1751
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Copies the character array into the specified array.
 *
 * @param startIndex  first index to copy, inclusive, must be valid
 * @param endIndex  last index, exclusive, must be valid
 * @param destination  the destination array, must not be null or too small
 * @param destinationIndex  the index to start copying in destination
 * @throws NullPointerException if the array is null
 * @throws IndexOutOfBoundsException if any index is invalid
 */"
"public StrBuilder append(String str, int startIndex, int length) {
    if (str == null) {
        return appendNull();
    }
    if (startIndex < 0 || startIndex > str.length()) {
        throw new StringIndexOutOfBoundsException(""startIndex must be valid"");
    }
    if (length < 0 || (startIndex + length) > str.length()) {
        throw new StringIndexOutOfBoundsException(""length must be valid"");
    }
    if (length > 0) {
        int len = length();
        ensureCapacity(len + length);
        str.getChars(startIndex, startIndex + length, buffer, len);
        size += length;
    }
    return this;
}","public void test07878() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""user.region"");
    strBuilder0.clear();
    strBuilder0.capacity();
    StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader();
    strBuilder_StrBuilderReader0.mark(43);
    strBuilder0.append((Object) ""user.region"");
    // Undeclared exception!
    try {
        strBuilder0.append(""java.util.prefs.PreferencesFactory"", 43, 43);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // startIndex must be valid
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends part of a string to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 */"
"public StrBuilder append(boolean value) {
    if (value) {
        ensureCapacity(size + 4);
        buffer[size++] = 't';
        buffer[size++] = 'r';
        buffer[size++] = 'u';
        buffer[size++] = 'e';
    } else {
        ensureCapacity(size + 5);
        buffer[size++] = 'f';
        buffer[size++] = 'a';
        buffer[size++] = 'l';
        buffer[size++] = 's';
        buffer[size++] = 'e';
    }
    return this;
}","public void test07979() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder((String) null);
    Object[] objectArray0 = new Object[7];
    objectArray0[0] = (Object) strBuilder0;
    objectArray0[1] = (Object) strBuilder0;
    objectArray0[2] = (Object) null;
    objectArray0[3] = (Object) strBuilder0;
    objectArray0[4] = (Object) null;
    StrBuilder strBuilder1 = strBuilder0.append(731);
    objectArray0[5] = (Object) strBuilder0;
    objectArray0[6] = (Object) strBuilder0;
    strBuilder0.appendWithSeparators(objectArray0, (String) null);
    strBuilder0.capacity();
    StrBuilder strBuilder2 = strBuilder1.appendNewLine();
    strBuilder2.validateRange(117, 731);
    strBuilder2.insert(253, (char[]) null);
    strBuilder2.insert(117, 'L');
    strBuilder0.rightString(731);
    strBuilder1.append(false);
}","/**
 * Appends a boolean value to the string builder.
 *
 * @param value  the value to append
 * @return this, to enable chaining
 */"
"public StringBuffer toStringBuffer() {
    return new StringBuffer(size).append(buffer, 0, size);
}","public void test08080() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    strBuilder0.deleteFirst(""E^|YbFb@Ba:A[Q"");
    strBuilder0.toStringBuffer();
}","/**
 * Gets a StringBuffer version of the string builder, creating a
 * new instance each time the method is called.
 *
 * @return the builder as a StringBuffer
 */"
"public void getChars(int startIndex, int endIndex, char[] destination, int destinationIndex) {
    if (startIndex < 0) {
        throw new StringIndexOutOfBoundsException(startIndex);
    }
    if (endIndex < 0 || endIndex > length()) {
        throw new StringIndexOutOfBoundsException(endIndex);
    }
    if (startIndex > endIndex) {
        throw new StringIndexOutOfBoundsException(""end < start"");
    }
    System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);
}","public void test08181() throws Throwable {
    int int0 = 5;
    StrBuilder strBuilder0 = new StrBuilder(5);
    StrBuilder strBuilder1 = new StrBuilder();
    char[] charArray0 = new char[2];
    strBuilder1.toStringBuffer();
    charArray0[0] = 'n';
    char char0 = 'c';
    charArray0[1] = 'c';
    StrTokenizer strTokenizer0 = StrTokenizer.getTSVInstance(charArray0);
    strBuilder1.appendAll((Iterator) strTokenizer0);
    StrBuilder strBuilder2 = strBuilder0.append(strBuilder1);
    int int1 = (-1871);
    int int2 = 0;
    StrBuilder strBuilder3 = strBuilder2.appendFixedWidthPadRight((-1871), 0, 'n');
    String string0 = ""4.1"";
    strBuilder3.deleteFirst(""4.1"");
    int int3 = (-13);
    // Undeclared exception!
    try {
        strBuilder3.getChars(0, (-2013), charArray0, (-13));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -2013
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Copies the character array into the specified array.
 *
 * @param startIndex  first index to copy, inclusive, must be valid
 * @param endIndex  last index, exclusive, must be valid
 * @param destination  the destination array, must not be null or too small
 * @param destinationIndex  the index to start copying in destination
 * @throws NullPointerException if the array is null
 * @throws IndexOutOfBoundsException if any index is invalid
 */"
"public StrBuilder append(StrBuilder str) {
    if (str == null) {
        return appendNull();
    }
    int strLen = str.length();
    if (strLen > 0) {
        int len = length();
        ensureCapacity(len + strLen);
        System.arraycopy(str.buffer, 0, buffer, len, strLen);
        size += strLen;
    }
    return this;
}","public void test08383() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder("""");
    StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadRight(48, 0, 'q');
    StrMatcher strMatcher0 = StrMatcher.quoteMatcher();
    strBuilder0.indexOf(strMatcher0, 0);
    strBuilder1.minimizeCapacity();
    strBuilder0.deleteFirst("""");
    strBuilder0.append(strBuilder1);
}","/**
 * Appends another string builder to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string builder to append
 * @return this, to enable chaining
 */"
"//-----------------------------------------------------------------------
/**
 * Appends an array placing separators between each value, but
 * not before the first or after the last.
 * Appending a null array will have no effect.
 * Each object is appended using {@link #append(Object)}.
 *
 * @param array  the array to append
 * @param separator  the separator to use, null means no separator
 * @return this, to enable chaining
 */
public StrBuilder appendWithSeparators(Object[] array, String separator) {
    if (array != null && array.length > 0) {
        separator = (separator == null ? """" : separator);
        append(array[0]);
        for (int i = 1; i < array.length; i++) {
            append(separator);
            append(array[i]);
        }
    }
    return this;
}","public void test08484() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(0);
    strBuilder0.endsWith(""'-!4W[0we($ST"");
    Object[] objectArray0 = new Object[9];
    objectArray0[0] = (Object) ""'-!4W[0we($ST"";
    objectArray0[1] = (Object) strBuilder0;
    objectArray0[2] = (Object) strBuilder0;
    objectArray0[3] = (Object) strBuilder0;
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer();
    Object object0 = strBuilder_StrBuilderTokenizer0.clone();
    objectArray0[4] = object0;
    objectArray0[5] = (Object) strBuilder0;
    objectArray0[6] = (Object) strBuilder0;
    objectArray0[7] = (Object) ""'-!4W[0we($ST"";
    objectArray0[8] = (Object) strBuilder0;
    strBuilder0.appendWithSeparators(objectArray0, """");
}",""
"public StrBuilder insert(int index, boolean value) {
    validateIndex(index);
    if (value) {
        ensureCapacity(size + 4);
        System.arraycopy(buffer, index, buffer, index + 4, size - index);
        buffer[index++] = 't';
        buffer[index++] = 'r';
        buffer[index++] = 'u';
        buffer[index] = 'e';
        size += 4;
    } else {
        ensureCapacity(size + 5);
        System.arraycopy(buffer, index, buffer, index + 5, size - index);
        buffer[index++] = 'f';
        buffer[index++] = 'a';
        buffer[index++] = 'l';
        buffer[index++] = 's';
        buffer[index] = 'e';
        size += 5;
    }
    return this;
}","public void test08585() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""java.specification.name"");
    StringBuffer stringBuffer0 = new StringBuffer(0);
    strBuilder0.append(stringBuffer0, 0, 0);
    int int0 = 1420;
    StrBuilder strBuilder1 = strBuilder0.setLength(1420);
    StrBuilder strBuilder2 = strBuilder1.insert(1420, (Object) ""java.specification.name"");
    strBuilder2.minimizeCapacity();
    String string0 = """";
    strBuilder2.endsWith("""");
    StrMatcher strMatcher0 = StrMatcher.tabMatcher();
    strBuilder1.lastIndexOf(strMatcher0, 0);
    // Undeclared exception!
    try {
        strBuilder0.insert((-1415), false);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -1415
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts the value into this builder.
 *
 * @param index  the index to add at, must be valid
 * @param value  the value to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Searches the string builder to find the last reference to the specified char.
 *
 * @param ch  the character to find
 * @return the last index of the character, or -1 if not found
 */
public int lastIndexOf(char ch) {
    return lastIndexOf(ch, size - 1);
}","public void test08686() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer();
    StrMatcher strMatcher0 = strBuilder_StrBuilderTokenizer0.getQuoteMatcher();
    char[] charArray0 = new char[3];
    charArray0[0] = '4';
    charArray0[1] = 'f';
    charArray0[2] = '}';
    strMatcher0.isMatch(charArray0, 3724, 3724, 3724);
    strBuilder0.append((StrBuilder) null, 0, 0);
    StrMatcher.charMatcher('U');
    strBuilder0.indexOf(strMatcher0, 1955);
    strBuilder0.lastIndexOf('w');
}",""
"public StrBuilder append(StrBuilder str, int startIndex, int length) {
    if (str == null) {
        return appendNull();
    }
    if (startIndex < 0 || startIndex > str.length()) {
        throw new StringIndexOutOfBoundsException(""startIndex must be valid"");
    }
    if (length < 0 || (startIndex + length) > str.length()) {
        throw new StringIndexOutOfBoundsException(""length must be valid"");
    }
    if (length > 0) {
        int len = length();
        ensureCapacity(len + length);
        str.getChars(startIndex, startIndex + length, buffer, len);
        size += length;
    }
    return this;
}","public void test08787() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""j=:4,XR*"");
    int int0 = 9;
    strBuilder0.appendSeparator(""j=:4,XR*"", 9);
    StrBuilder strBuilder1 = new StrBuilder(9);
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder1.new StrBuilderTokenizer();
    char char0 = '+';
    StrTokenizer strTokenizer0 = strBuilder_StrBuilderTokenizer0.setQuoteChar('+');
    strBuilder1.appendAll((Iterator) strTokenizer0);
    int int1 = 4;
    // Undeclared exception!
    try {
        strBuilder0.append(strBuilder1, 4, 9);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // startIndex must be valid
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends part of a string builder to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 */"
"//-----------------------------------------------------------------------
/**
 * Validates parameters defining a range of the builder.
 *
 * @param startIndex  the start index, inclusive, must be valid
 * @param endIndex  the end index, exclusive, must be valid except
 *  that if too large it is treated as end of string
 * @return the new string
 * @throws IndexOutOfBoundsException if the index is invalid
 */
protected int validateRange(int startIndex, int endIndex) {
    if (startIndex < 0) {
        throw new StringIndexOutOfBoundsException(startIndex);
    }
    if (endIndex > size) {
        endIndex = size;
    }
    if (startIndex > endIndex) {
        throw new StringIndexOutOfBoundsException(""end < start"");
    }
    return endIndex;
}","public void test08989() throws Throwable {
    int int0 = 0;
    StrBuilder strBuilder0 = new StrBuilder(0);
    char char0 = 'X';
    strBuilder0.contains('X');
    String string0 = """";
    StrBuilder strBuilder1 = strBuilder0.appendln("""");
    char char1 = '4';
    StrBuilder strBuilder2 = strBuilder1.appendFixedWidthPadLeft(0, 0, '4');
    StrBuilder strBuilder3 = strBuilder2.appendSeparator("""", 0);
    strBuilder3.appendln('X');
    strBuilder2.asWriter();
    int int1 = 1;
    // Undeclared exception!
    try {
        strBuilder1.validateRange(1, 0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // end < start
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}",""
"protected void validateIndex(int index) {
    if (index < 0 || index > size) {
        throw new StringIndexOutOfBoundsException(index);
    }
}","public void test09090() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    int int0 = (-632);
    // Undeclared exception!
    try {
        strBuilder0.validateIndex((-632));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -632
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Validates parameters defining a single index in the builder.
 *
 * @param index  the index, must be valid
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder insert(int index, char[] chars) {
    validateIndex(index);
    if (chars == null) {
        return insert(index, nullText);
    }
    int len = chars.length;
    if (len > 0) {
        ensureCapacity(size + len);
        System.arraycopy(buffer, index, buffer, index + len, size - index);
        System.arraycopy(chars, 0, buffer, index, len);
        size += len;
    }
    return this;
}","public void test09191() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    StrBuilder strBuilder1 = strBuilder0.insert(0, (-1L));
    strBuilder0.append(""org.apache.commons.lang.text.StrBuilder$StrBuilderWriter"");
    StrBuilder.StrBuilderWriter strBuilder_StrBuilderWriter0 = strBuilder1.new StrBuilderWriter();
    strBuilder_StrBuilderWriter0.write(0);
    char[] charArray0 = new char[4];
    charArray0[0] = '9';
    charArray0[1] = '>';
    charArray0[2] = '0';
    charArray0[3] = 'K';
    strBuilder0.insert(0, charArray0);
}","/**
 * Inserts the character array into this builder.
 * Inserting null will use the stored null text value.
 *
 * @param index  the index to add at, must be valid
 * @param chars  the char array to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder append(String str, int startIndex, int length) {
    if (str == null) {
        return appendNull();
    }
    if (startIndex < 0 || startIndex > str.length()) {
        throw new StringIndexOutOfBoundsException(""startIndex must be valid"");
    }
    if (length < 0 || (startIndex + length) > str.length()) {
        throw new StringIndexOutOfBoundsException(""length must be valid"");
    }
    if (length > 0) {
        int len = length();
        ensureCapacity(len + length);
        str.getChars(startIndex, startIndex + length, buffer, len);
        size += length;
    }
    return this;
}","public void test09292() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    StrBuilder strBuilder1 = new StrBuilder();
    strBuilder0.appendFixedWidthPadRight((Object) strBuilder1, (-416), '[');
    // Undeclared exception!
    try {
        strBuilder0.append("""", (-2537), 0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // startIndex must be valid
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends part of a string to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 */"
"public void getChars(int startIndex, int endIndex, char[] destination, int destinationIndex) {
    if (startIndex < 0) {
        throw new StringIndexOutOfBoundsException(startIndex);
    }
    if (endIndex < 0 || endIndex > length()) {
        throw new StringIndexOutOfBoundsException(endIndex);
    }
    if (startIndex > endIndex) {
        throw new StringIndexOutOfBoundsException(""end < start"");
    }
    System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);
}","public void test09494() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""T0/f*"");
    int int0 = 0;
    char[] charArray0 = new char[4];
    charArray0[0] = '[';
    charArray0[1] = '0';
    charArray0[2] = ';';
    charArray0[3] = '1';
    // Undeclared exception!
    try {
        strBuilder0.getChars(0, 0, charArray0, (-2003));
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}","/**
 * Copies the character array into the specified array.
 *
 * @param startIndex  first index to copy, inclusive, must be valid
 * @param endIndex  last index, exclusive, must be valid
 * @param destination  the destination array, must not be null or too small
 * @param destinationIndex  the index to start copying in destination
 * @throws NullPointerException if the array is null
 * @throws IndexOutOfBoundsException if any index is invalid
 */"
"public StrBuilder insert(int index, char value) {
    validateIndex(index);
    ensureCapacity(size + 1);
    System.arraycopy(buffer, index, buffer, index + 1, size - index);
    buffer[index] = value;
    size++;
    return this;
}","public void test09696() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    StrBuilder strBuilder1 = strBuilder0.append(579.8806005091);
    strBuilder1.append(0.0F);
    StringBuffer stringBuffer0 = new StringBuffer();
    // Undeclared exception!
    try {
        strBuilder0.insert(1892, 'b');
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 1892
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts the value into this builder.
 *
 * @param index  the index to add at, must be valid
 * @param value  the value to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public int hashCode() {
    char[] buf = buffer;
    int hash = 0;
    for (int i = size - 1; i >= 0; i--) {
        hash = 31 * hash + buf[i];
    }
    return hash;
}","public void test09797() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""e\""l^5QU3z"");
    strBuilder0.minimizeCapacity();
    strBuilder0.asTokenizer();
    strBuilder0.toString();
    strBuilder0.size = 4207;
    // Undeclared exception!
    try {
        strBuilder0.hashCode();
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 4206
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Gets a suitable hash code for this builder.
 *
 * @return a hash code
 */"
"public StrBuilder insert(int index, int value) {
    return insert(index, String.valueOf(value));
}","public void test09999() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    char[] charArray0 = new char[5];
    charArray0[0] = 'D';
    charArray0[1] = 'z';
    charArray0[2] = 'w';
    charArray0[3] = 'R';
    charArray0[4] = '0';
    StrBuilder strBuilder1 = strBuilder0.append(charArray0, 0, 0);
    LinkedList<StrBuilder> linkedList0 = new LinkedList<StrBuilder>();
    StrBuilder strBuilder2 = strBuilder1.appendWithSeparators((Collection) linkedList0, ""2BW?qhEvAf^M"");
    strBuilder1.buffer = charArray0;
    StrMatcher strMatcher0 = StrMatcher.singleQuoteMatcher();
    strBuilder1.replaceAll(strMatcher0, ""53r^xfe!*`l@X17Z[."");
    StrBuilder strBuilder3 = strBuilder1.appendSeparator(""6EcMg"", 0);
    strBuilder1.getChars(charArray0);
    StrBuilder strBuilder4 = strBuilder1.insert(0, ""(b&`n\""K&gHsATfMT<"");
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder3.new StrBuilderTokenizer();
    strBuilder_StrBuilderTokenizer0.setIgnoredChar('R');
    StrMatcher strMatcher1 = strBuilder_StrBuilderTokenizer0.getDelimiterMatcher();
    strBuilder2.deleteFirst(strMatcher1);
    // Undeclared exception!
    try {
        strBuilder4.insert((-2479), (-215));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -2479
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts the value into this builder.
 *
 * @param index  the index to add at, must be valid
 * @param value  the value to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder setCharAt(int index, char ch) {
    if (index < 0 || index >= length()) {
        throw new StringIndexOutOfBoundsException(index);
    }
    buffer[index] = ch;
    return this;
}","public void test100100() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(1817);
    // Undeclared exception!
    try {
        strBuilder0.setCharAt((-3445), 'T');
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -3445
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Sets the character at the specified index.
 *
 * @see #charAt(int)
 * @see #deleteCharAt(int)
 * @param index  the index to set
 * @param ch  the new character
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the character at the specified index.
 *
 * @see #setCharAt(int, char)
 * @see #deleteCharAt(int)
 * @param index  the index to retrieve, must be valid
 * @return the character at the index
 * @throws IndexOutOfBoundsException if the index is invalid
 */
public char charAt(int index) {
    if (index < 0 || index >= length()) {
        throw new StringIndexOutOfBoundsException(index);
    }
    return buffer[index];
}","public void test101101() throws Throwable {
    int int0 = (-1286);
    StrBuilder strBuilder0 = new StrBuilder((-1286));
    int int1 = 44;
    // Undeclared exception!
    try {
        strBuilder0.charAt(44);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 44
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}",""
"public StrBuilder setCharAt(int index, char ch) {
    if (index < 0 || index >= length()) {
        throw new StringIndexOutOfBoundsException(index);
    }
    buffer[index] = ch;
    return this;
}","public void test103103() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder("""");
    // Undeclared exception!
    try {
        strBuilder0.setCharAt(0, 'Z');
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 0
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Sets the character at the specified index.
 *
 * @see #charAt(int)
 * @see #deleteCharAt(int)
 * @param index  the index to set
 * @param ch  the new character
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder setCharAt(int index, char ch) {
    if (index < 0 || index >= length()) {
        throw new StringIndexOutOfBoundsException(index);
    }
    buffer[index] = ch;
    return this;
}","public void test104104() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    int int0 = 500;
    char char0 = 'I';
    // Undeclared exception!
    try {
        strBuilder0.setCharAt(500, 'I');
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 500
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Sets the character at the specified index.
 *
 * @see #charAt(int)
 * @see #deleteCharAt(int)
 * @param index  the index to set
 * @param ch  the new character
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the character at the specified index.
 *
 * @see #setCharAt(int, char)
 * @see #deleteCharAt(int)
 * @param index  the index to retrieve, must be valid
 * @return the character at the index
 * @throws IndexOutOfBoundsException if the index is invalid
 */
public char charAt(int index) {
    if (index < 0 || index >= length()) {
        throw new StringIndexOutOfBoundsException(index);
    }
    return buffer[index];
}","public void test105105() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    strBuilder0.ensureCapacity(1950);
    int int0 = 101;
    // Undeclared exception!
    try {
        strBuilder0.charAt(101);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 101
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}",""
"public StrBuilder insert(int index, int value) {
    return insert(index, String.valueOf(value));
}","public void test106106() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder((String) null);
    int int0 = 3;
    strBuilder0.append(3);
    // Undeclared exception!
    try {
        strBuilder0.insert(3, 3);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 3
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts the value into this builder.
 *
 * @param index  the index to add at, must be valid
 * @param value  the value to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Replaces the search character with the replace character
 * throughout the builder.
 *
 * @param search  the search character
 * @param replace  the replace character
 * @return this, to enable chaining
 */
public StrBuilder replaceAll(char search, char replace) {
    if (search != replace) {
        for (int i = 0; i < size; i++) {
            if (buffer[i] == search) {
                buffer[i] = replace;
            }
        }
    }
    return this;
}","public void test107107() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""1.5"");
    strBuilder0.replaceAll('B', 'B');
}",""
"public StrBuilder append(char[] chars, int startIndex, int length) {
    if (chars == null) {
        return appendNull();
    }
    if (startIndex < 0 || startIndex > chars.length) {
        throw new StringIndexOutOfBoundsException(""Invalid startIndex: "" + length);
    }
    if (length < 0 || (startIndex + length) > chars.length) {
        throw new StringIndexOutOfBoundsException(""Invalid length: "" + length);
    }
    if (length > 0) {
        int len = length();
        ensureCapacity(len + length);
        System.arraycopy(chars, startIndex, buffer, len, length);
        size += length;
    }
    return this;
}","public void test108108() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(5);
    StrBuilder strBuilder1 = strBuilder0.appendln(false);
    char[] charArray0 = new char[8];
    strBuilder1.appendln(0L);
    charArray0[0] = 'X';
    charArray0[1] = '=';
    charArray0[2] = 'b';
    charArray0[3] = 'a';
    charArray0[4] = ' ';
    charArray0[5] = 'E';
    charArray0[6] = 'N';
    charArray0[7] = 'l';
    // Undeclared exception!
    try {
        strBuilder1.append(charArray0, 5, (-65));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // Invalid length: -65
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends a char array to the string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param chars  the char array to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 */"
"public StrBuilder append(long value) {
    return append(String.valueOf(value));
}","public void test109109() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    StrBuilder strBuilder1 = strBuilder0.appendWithSeparators((Collection) linkedList0, ""WHu-'I|;vxdN"");
    strBuilder1.appendSeparator('m');
    strBuilder0.appendWithSeparators((Collection) linkedList0, ""WHu-'I|;vxdN"");
    StrBuilder strBuilder2 = strBuilder0.deleteAll(' ');
    strBuilder2.appendSeparator('j', 0);
    StrBuilder strBuilder3 = strBuilder0.appendAll((Collection) linkedList0);
    strBuilder3.appendWithSeparators((Collection) linkedList0, ""WHu-'I|;vxdN"");
    strBuilder0.appendln(false);
    StrBuilder strBuilder4 = strBuilder2.append((char[]) null, 1720, 0);
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder4.new StrBuilderTokenizer();
    StringBuffer stringBuffer0 = new StringBuffer(0);
    strBuilder4.appendln(stringBuffer0);
    strBuilder_StrBuilderTokenizer0.tokenize((char[]) null, 48, 1720);
    strBuilder3.append((long) 0);
}","/**
 * Appends a long value to the string builder using <code>String.valueOf</code>.
 *
 * @param value  the value to append
 * @return this, to enable chaining
 */"
"// -----------------------------------------------------------------------
/**
 * Advanced search and replaces within the builder using a matcher.
 * <p>
 * Matchers can be used to perform advanced behaviour.
 * For example you could write a matcher to delete all occurances
 * where the character 'a' is followed by a number.
 *
 * @param matcher  the matcher to use to find the deletion, null causes no action
 * @param replaceStr  the string to replace the match with, null is a delete
 * @param startIndex  the start index, inclusive, must be valid
 * @param endIndex  the end index, exclusive, must be valid except
 *  that if too large it is treated as end of string
 * @param replaceCount  the number of times to replace, -1 for replace all
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if start index is invalid
 */
public StrBuilder replace(StrMatcher matcher, String replaceStr, int startIndex, int endIndex, int replaceCount) {
    endIndex = validateRange(startIndex, endIndex);
    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);
}","public void test111111() throws Throwable {
    int int0 = (-1644);
    StrBuilder strBuilder0 = new StrBuilder((-1644));
    StrMatcher strMatcher0 = StrMatcher.trimMatcher();
    String string0 = ""\\,H| Do&"";
    int int1 = 3933;
    // Undeclared exception!
    try {
        strBuilder0.replace(strMatcher0, "",H| Do&"", 3933, 3933, 3933);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // end < start
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}",""
"public StrBuilder replace(int startIndex, int endIndex, String replaceStr) {
    endIndex = validateRange(startIndex, endIndex);
    int insertLen = (replaceStr == null ? 0 : replaceStr.length());
    replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen);
    return this;
}","public void test112112() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    String string0 = ""startIndex must be valid"";
    StrMatcher.StringMatcher strMatcher_StringMatcher0 = new StrMatcher.StringMatcher(""startIndex must be valid"");
    StrBuilder strBuilder1 = strBuilder0.deleteFirst((StrMatcher) strMatcher_StringMatcher0);
    strBuilder0.indexOf(""`_IQ1EK}"", 39);
    StrBuilder strBuilder2 = strBuilder1.append((-1));
    Object[] objectArray0 = new Object[3];
    objectArray0[0] = (Object) strMatcher_StringMatcher0;
    StrMatcher.stringMatcher(""startIndex must be valid"");
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder1.new StrBuilderTokenizer();
    strBuilder_StrBuilderTokenizer0.hasPrevious();
    strBuilder_StrBuilderTokenizer0.next();
    objectArray0[1] = (Object) ""-1"";
    StrMatcher.stringMatcher(""Invalid length: "");
    objectArray0[2] = (Object) ""startIndex must be valid"";
    strBuilder0.appendWithSeparators(objectArray0, ""java.io.tmpdir"");
    strBuilder0.minimizeCapacity();
    strBuilder2.insert(39, '`');
    int int0 = 0;
    // Undeclared exception!
    try {
        strBuilder0.replace(0, (-1311), """");
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // end < start
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Replaces a portion of the string builder with another string.
 * The length of the inserted string does not have to match the removed length.
 *
 * @param startIndex  the start index, inclusive, must be valid
 * @param endIndex  the end index, exclusive, must be valid except
 *  that if too large it is treated as end of string
 * @param replaceStr  the string to replace with, null means delete range
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder appendln(StrBuilder str, int startIndex, int length) {
    return append(str, startIndex, length).appendNewLine();
}","public void test113113() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    String string0 = """";
    StrBuilder strBuilder1 = new StrBuilder("""");
    int int0 = (-1);
    // Undeclared exception!
    try {
        strBuilder0.appendln(strBuilder1, (-1), (-1));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // startIndex must be valid
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends part of a string builder followed by a new line to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 * @since 2.3
 */"
"public StrBuilder replace(int startIndex, int endIndex, String replaceStr) {
    endIndex = validateRange(startIndex, endIndex);
    int insertLen = (replaceStr == null ? 0 : replaceStr.length());
    replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen);
    return this;
}","public void test114114() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    strBuilder0.append(0);
    char char0 = '9';
    StrBuilder strBuilder1 = strBuilder0.replaceFirst('9', '9');
    // Undeclared exception!
    try {
        strBuilder1.replace((-884), (-1048), ""7|*=^[pK|s-P58"");
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -884
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Replaces a portion of the string builder with another string.
 * The length of the inserted string does not have to match the removed length.
 *
 * @param startIndex  the start index, inclusive, must be valid
 * @param endIndex  the end index, exclusive, must be valid except
 *  that if too large it is treated as end of string
 * @param replaceStr  the string to replace with, null means delete range
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Appends a separator if the builder is currently non-empty.
 * Appending a null separator will have no effect.
 * The separator is appended using {@link #append(String)}.
 * <p>
 * This method is useful for adding a separator each time around the
 * loop except the first.
 * <pre>
 * for (Iterator it = list.iterator(); it.hasNext(); ) {
 *   appendSeparator("","");
 *   append(it.next());
 * }
 * </pre>
 * Note that for this simple example, you should use
 * {@link #appendWithSeparators(Collection, String)}.
 *
 * @param separator  the separator to use, null means no separator
 * @return this, to enable chaining
 * @since 2.3
 */
public StrBuilder appendSeparator(String separator) {
    if (separator != null && size() > 0) {
        append(separator);
    }
    return this;
}","public void test115115() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""!cw?O'"");
    StrMatcher strMatcher0 = StrMatcher.tabMatcher();
    StrBuilder strBuilder1 = strBuilder0.deleteAll(strMatcher0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""!cw?O'"");
    strBuilder1.append(stringBuffer0, 5, 0);
    StrBuilder strBuilder2 = strBuilder0.deleteAll('2');
    char[] charArray0 = new char[6];
    charArray0[0] = '2';
    charArray0[1] = '2';
    charArray0[2] = '2';
    charArray0[3] = '2';
    charArray0[4] = '`';
    charArray0[5] = '2';
    StrBuilder strBuilder3 = strBuilder2.appendln(charArray0);
    strBuilder2.asReader();
    strBuilder0.appendSeparator("",@T \r *13="", 0);
    strBuilder0.insert(0, 0L);
    StrBuilder strBuilder4 = strBuilder3.replaceFirst('2', '`');
    strBuilder1.minimizeCapacity();
    strBuilder4.appendSeparator("",@T \r *13="");
}",""
"public StrBuilder appendln(StringBuffer str, int startIndex, int length) {
    return append(str, startIndex, length).appendNewLine();
}","public void test116116() throws Throwable {
    String string0 = ""> 2$q @(zkv()&"";
    StrBuilder strBuilder0 = new StrBuilder(""> 2$q @(zkv()&"");
    StrBuilder strBuilder1 = strBuilder0.appendln(0.0F);
    strBuilder1.appendln((-4821L));
    strBuilder1.asTokenizer();
    strBuilder0.appendFixedWidthPadRight(32, 32, '');
    StringBuffer stringBuffer0 = new StringBuffer(""> 2$q @(zkv()&"");
    int int0 = 0;
    int int1 = (-2129);
    // Undeclared exception!
    try {
        strBuilder1.appendln(stringBuffer0, 0, (-2129));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // length must be valid
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends part of a string buffer followed by a new line to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 * @since 2.3
 */"
"public StrBuilder insert(int index, String str) {
    validateIndex(index);
    if (str == null) {
        str = nullText;
    }
    int strLen = (str == null ? 0 : str.length());
    if (strLen > 0) {
        int newSize = size + strLen;
        ensureCapacity(newSize);
        System.arraycopy(buffer, index, buffer, index + strLen, size - index);
        size = newSize;
        str.getChars(0, strLen, buffer, index);
    }
    return this;
}","public void test117117() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""UPjo(AzNrC%:"");
    StrBuilder strBuilder1 = strBuilder0.append(0.0);
    char char0 = 'n';
    strBuilder1.deleteFirst('n');
    strBuilder0.append((-1935.59F));
    int int0 = (-1777);
    // Undeclared exception!
    try {
        strBuilder0.insert((-1777), ""UPjo(AzNrC%:"");
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -1777
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts the string into this builder.
 * Inserting null will use the stored null text value.
 *
 * @param index  the index to add at, must be valid
 * @param str  the string to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder insert(int index, char value) {
    validateIndex(index);
    ensureCapacity(size + 1);
    System.arraycopy(buffer, index, buffer, index + 1, size - index);
    buffer[index] = value;
    size++;
    return this;
}","public void test118118() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    strBuilder0.replace((StrMatcher) null, ""B iI'("", 0, 0, 57);
    int int0 = 26;
    strBuilder0.size = 26;
    StrBuilder strBuilder1 = strBuilder0.deleteFirst('(');
    strBuilder0.append((long) 26);
    strBuilder0.leftString(26);
    strBuilder0.capacity();
    // Undeclared exception!
    try {
        strBuilder1.insert(32, 'O');
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 32
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts the value into this builder.
 *
 * @param index  the index to add at, must be valid
 * @param value  the value to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Replaces the search string with the replace string throughout the builder.
 *
 * @param searchStr  the search string, null causes no action to occur
 * @param replaceStr  the replace string, null is equivalent to an empty string
 * @return this, to enable chaining
 */
public StrBuilder replaceAll(String searchStr, String replaceStr) {
    int searchLen = (searchStr == null ? 0 : searchStr.length());
    if (searchLen > 0) {
        int replaceLen = (replaceStr == null ? 0 : replaceStr.length());
        int index = indexOf(searchStr, 0);
        while (index >= 0) {
            replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);
            index = indexOf(searchStr, index + replaceLen);
        }
    }
    return this;
}","public void test119119() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""OmsjU;A*2A$S"");
    strBuilder0.substring(5);
    StrBuilder strBuilder1 = strBuilder0.deleteAll("";A*2A$S"");
    strBuilder1.deleteAll('H');
    strBuilder0.asTokenizer();
    strBuilder0.replaceAll(""OmsjU;A*2A$S"", ""OmsjU;A*2A$S"");
}",""
"public void getChars(int startIndex, int endIndex, char[] destination, int destinationIndex) {
    if (startIndex < 0) {
        throw new StringIndexOutOfBoundsException(startIndex);
    }
    if (endIndex < 0 || endIndex > length()) {
        throw new StringIndexOutOfBoundsException(endIndex);
    }
    if (startIndex > endIndex) {
        throw new StringIndexOutOfBoundsException(""end < start"");
    }
    System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);
}","public void test120120() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder((-818));
    StrMatcher.splitMatcher();
    char[] charArray0 = new char[2];
    charArray0[0] = 'V';
    strBuilder0.appendNull();
    charArray0[1] = '@';
    // Undeclared exception!
    try {
        strBuilder0.getChars((-818), (-818), charArray0, (-2146));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -818
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Copies the character array into the specified array.
 *
 * @param startIndex  first index to copy, inclusive, must be valid
 * @param endIndex  last index, exclusive, must be valid
 * @param destination  the destination array, must not be null or too small
 * @param destinationIndex  the index to start copying in destination
 * @throws NullPointerException if the array is null
 * @throws IndexOutOfBoundsException if any index is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Appends the new line string to this string builder.
 * <p>
 * The new line string can be altered using {@link #setNewLineText(String)}.
 * This might be used to force the output to always use Unix line endings
 * even when on Windows.
 *
 * @return this, to enable chaining
 */
public StrBuilder appendNewLine() {
    if (newLine == null) {
        append(SystemUtils.LINE_SEPARATOR);
        return this;
    }
    return append(newLine);
}","public void test121121() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""user.language"");
    LinkedList<Integer> linkedList0 = new LinkedList<Integer>();
    linkedList0.remove((Object) ""user.language"");
    strBuilder0.appendAll((Collection) linkedList0);
    strBuilder0.appendNewLine();
}",""
"public StrBuilder appendSeparator(char separator, int loopIndex) {
    if (loopIndex > 0) {
        append(separator);
    }
    return this;
}","public void test122122() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder("">"");
    strBuilder0.appendSeparator('1', 0);
}","/**
 * Appends a separator to the builder if the loop index is greater than zero.
 * The separator is appended using {@link #append(char)}.
 * <p>
 * This method is useful for adding a separator each time around the
 * loop except the first.
 * <pre>
 * for (int i = 0; i < list.size(); i++) {
 *   appendSeparator("","", i);
 *   append(list.get(i));
 * }
 * </pre>
 * Note that for this simple example, you should use
 * {@link #appendWithSeparators(Collection, String)}.
 *
 * @param separator  the separator to use
 * @param loopIndex  the loop index
 * @return this, to enable chaining
 * @since 2.3
 */"
"public StrBuilder appendln(StrBuilder str, int startIndex, int length) {
    return append(str, startIndex, length).appendNewLine();
}","public void test123123() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer();
    strBuilder_StrBuilderTokenizer0.hasNext();
    StrTokenizer strTokenizer0 = strBuilder_StrBuilderTokenizer0.setDelimiterString(""'a_Id_QlqU?qMg?^#%W"");
    StrBuilder strBuilder1 = strBuilder0.appendAll((Iterator) strTokenizer0);
    String string0 = ""Invalid startIndex: "";
    strBuilder0.deleteAll(""Invalid startIndex: "");
    strBuilder1.appendln(0);
    strBuilder0.charAt(0);
    strBuilder0.endsWith(""Invalid startIndex: "");
    strBuilder1.trim();
    strBuilder0.append(0.0);
    StrBuilder strBuilder2 = strBuilder0.ensureCapacity((-968));
    // Undeclared exception!
    try {
        strBuilder2.appendln(strBuilder1, 44, 39);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // startIndex must be valid
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends part of a string builder followed by a new line to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 * @since 2.3
 */"
"public StrBuilder delete(int startIndex, int endIndex) {
    endIndex = validateRange(startIndex, endIndex);
    int len = endIndex - startIndex;
    if (len > 0) {
        deleteImpl(startIndex, endIndex, len);
    }
    return this;
}","public void test125125() throws Throwable {
    String string0 = ""java.vm.info"";
    StrBuilder strBuilder0 = new StrBuilder(""java.vm.info"");
    int int0 = 1647;
    // Undeclared exception!
    try {
        strBuilder0.delete(1647, 1647);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // end < start
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Deletes the characters between the two specified indices.
 *
 * @param startIndex  the start index, inclusive, must be valid
 * @param endIndex  the end index, exclusive, must be valid except
 *  that if too large it is treated as end of string
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder append(char[] chars) {
    if (chars == null) {
        return appendNull();
    }
    int strLen = chars.length;
    if (strLen > 0) {
        int len = length();
        ensureCapacity(len + strLen);
        System.arraycopy(chars, 0, buffer, len, strLen);
        size += strLen;
    }
    return this;
}","public void test126126() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    char[] charArray0 = new char[6];
    charArray0[0] = 'a';
    charArray0[1] = '.';
    charArray0[3] = 'a';
    charArray0[4] = '/';
    charArray0[5] = '[';
    strBuilder0.append(charArray0);
}","/**
 * Appends a char array to the string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param chars  the char array to append
 * @return this, to enable chaining
 */"
"public StrBuilder insert(int index, char[] chars) {
    validateIndex(index);
    if (chars == null) {
        return insert(index, nullText);
    }
    int len = chars.length;
    if (len > 0) {
        ensureCapacity(size + len);
        System.arraycopy(buffer, index, buffer, index + len, size - index);
        System.arraycopy(chars, 0, buffer, index, len);
        size += len;
    }
    return this;
}","public void test127127() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(0);
    StrBuilder strBuilder1 = strBuilder0.deleteAll("""");
    strBuilder1.append(0);
    strBuilder1.replaceFirst("""", ""3($^nL:uM.7pnb]"");
    strBuilder1.indexOf(""java.vm.name"");
    char[] charArray0 = new char[9];
    charArray0[0] = 'm';
    charArray0[1] = '$';
    charArray0[2] = 'G';
    charArray0[3] = 'Y';
    charArray0[4] = '0';
    charArray0[5] = 'Z';
    charArray0[6] = ']';
    charArray0[7] = 't';
    charArray0[8] = 'c';
    strBuilder0.insert(0, charArray0);
}","/**
 * Inserts the character array into this builder.
 * Inserting null will use the stored null text value.
 *
 * @param index  the index to add at, must be valid
 * @param chars  the char array to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder insert(int index, char[] chars, int offset, int length) {
    validateIndex(index);
    if (chars == null) {
        return insert(index, nullText);
    }
    if (offset < 0 || offset > chars.length) {
        throw new StringIndexOutOfBoundsException(""Invalid offset: "" + offset);
    }
    if (length < 0 || offset + length > chars.length) {
        throw new StringIndexOutOfBoundsException(""Invalid length: "" + length);
    }
    if (length > 0) {
        ensureCapacity(size + length);
        System.arraycopy(buffer, index, buffer, index + length, size - index);
        System.arraycopy(chars, offset, buffer, index, length);
        size += length;
    }
    return this;
}","public void test128128() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(0);
    StrMatcher strMatcher0 = StrMatcher.trimMatcher();
    strBuilder0.indexOf(strMatcher0);
    StrBuilder strBuilder1 = new StrBuilder();
    char[] charArray0 = new char[4];
    charArray0[0] = '\""';
    charArray0[1] = '@';
    charArray0[2] = 'F';
    charArray0[3] = ',';
    // Undeclared exception!
    try {
        strBuilder1.insert(0, charArray0, (-1), 0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // Invalid offset: -1
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts part of the character array into this builder.
 * Inserting null will use the stored null text value.
 *
 * @param index  the index to add at, must be valid
 * @param chars  the char array to insert
 * @param offset  the offset into the character array to start at, must be valid
 * @param length  the length of the character array part to copy, must be positive
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if any index is invalid
 */"
"public StrBuilder insert(int index, char[] chars) {
    validateIndex(index);
    if (chars == null) {
        return insert(index, nullText);
    }
    int len = chars.length;
    if (len > 0) {
        ensureCapacity(size + len);
        System.arraycopy(buffer, index, buffer, index + len, size - index);
        System.arraycopy(chars, 0, buffer, index, len);
        size += len;
    }
    return this;
}","public void test129129() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""startIndex must be valid"");
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer();
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer1 = strBuilder0.new StrBuilderTokenizer();
    StrMatcher strMatcher0 = strBuilder_StrBuilderTokenizer1.getQuoteMatcher();
    strBuilder0.appendNull();
    strBuilder_StrBuilderTokenizer0.setTrimmerMatcher(strMatcher0);
    strBuilder_StrBuilderTokenizer0.tokenize((char[]) null, 31, 578);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""startIndex must be valid"");
    stringBuffer0.appendCodePoint(9);
    StrBuilder strBuilder1 = strBuilder0.appendln(stringBuffer0);
    strMatcher0.isMatch((char[]) null, 5, 2553, 9);
    strBuilder0.deleteAll("""");
    strBuilder1.replace(strMatcher0, """", 31, 578, 31);
    strBuilder0.setNewLineText(""HP-UX"");
    strBuilder1.substring(31);
    strBuilder1.append(true);
    char[] charArray0 = new char[3];
    charArray0[0] = '';
    charArray0[1] = 'R';
    charArray0[2] = '\'';
    strBuilder0.insert(0, charArray0);
}","/**
 * Inserts the character array into this builder.
 * Inserting null will use the stored null text value.
 *
 * @param index  the index to add at, must be valid
 * @param chars  the char array to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder appendWithSeparators(Iterator it, String separator) {
    if (it != null) {
        separator = (separator == null ? """" : separator);
        while (it.hasNext()) {
            append(it.next());
            if (it.hasNext()) {
                append(separator);
            }
        }
    }
    return this;
}","public void test130130() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    StringBuffer stringBuffer0 = new StringBuffer();
    StrBuilder strBuilder1 = strBuilder0.append(0L);
    strBuilder1.appendln(0L);
    StrBuilder strBuilder2 = strBuilder0.append(stringBuffer0);
    StrBuilder strBuilder3 = strBuilder0.appendln(stringBuffer0);
    strBuilder3.replace(0, 0, ""qJNt5V[5(A?N}qe"");
    StrBuilder strBuilder4 = strBuilder0.appendSeparator('%');
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder4.new StrBuilderTokenizer();
    StrTokenizer strTokenizer0 = strBuilder_StrBuilderTokenizer0.setIgnoreEmptyTokens(false);
    strBuilder2.appendWithSeparators((Iterator) strTokenizer0, ""org.apache.commons.lang.text.StrBuilder$StrBuilderWriter"");
}","/**
 * Appends an iterator placing separators between each value, but
 * not before the first or after the last.
 * Appending a null iterator will have no effect.
 * Each object is appended using {@link #append(Object)}.
 *
 * @param it  the iterator to append
 * @param separator  the separator to use, null means no separator
 * @return this, to enable chaining
 */"
"public char[] toCharArray(int startIndex, int endIndex) {
    endIndex = validateRange(startIndex, endIndex);
    int len = endIndex - startIndex;
    if (len == 0) {
        return ArrayUtils.EMPTY_CHAR_ARRAY;
    }
    char[] chars = new char[len];
    System.arraycopy(buffer, startIndex, chars, 0, len);
    return chars;
}","public void test132132() throws Throwable {
    String string0 = "" K,ZgkkB4El|e"";
    StrBuilder strBuilder0 = new StrBuilder("" K,ZgkkB4El|e"");
    StrBuilder.StrBuilderWriter strBuilder_StrBuilderWriter0 = strBuilder0.new StrBuilderWriter();
    char char0 = 'L';
    StrBuilder strBuilder1 = strBuilder0.deleteAll('L');
    StrBuilder strBuilder2 = strBuilder1.appendNull();
    strBuilder2.appendln('L');
    int int0 = (-2418);
    // Undeclared exception!
    try {
        strBuilder0.toCharArray((-2418), (-2418));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -2418
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Copies part of the builder's character array into a new character array.
 *
 * @param startIndex  the start index, inclusive, must be valid
 * @param endIndex  the end index, exclusive, must be valid except that
 *  if too large it is treated as end of string
 * @return a new array that holds part of the contents of the builder
 * @throws IndexOutOfBoundsException if startIndex is invalid,
 *  or if endIndex is invalid (but endIndex greater than size is valid)
 */"
"//-----------------------------------------------------------------------
/**
 * Inserts the string representation of an object into this builder.
 * Inserting null will use the stored null text value.
 *
 * @param index  the index to add at, must be valid
 * @param obj  the object to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */
public StrBuilder insert(int index, Object obj) {
    if (obj == null) {
        return insert(index, nullText);
    }
    return insert(index, obj.toString());
}","public void test133133() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(0);
    char[] charArray0 = new char[2];
    charArray0[0] = 'n';
    charArray0[1] = '<';
    StrBuilder strBuilder1 = strBuilder0.append(charArray0);
    StrBuilder strBuilder2 = strBuilder0.append(1412.6066152908295);
    strBuilder2.lastIndexOf(""kkf'V"", 0);
    int int0 = 32;
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder1.new StrBuilderTokenizer();
    Object object0 = strBuilder_StrBuilderTokenizer0.clone();
    // Undeclared exception!
    try {
        strBuilder1.insert(32, object0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 32
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Checks whether this builder starts with the specified string.
 * <p>
 * Note that this method handles null input quietly, unlike String.
 *
 * @param str  the string to search for, null returns false
 * @return true if the builder starts with the string
 */
public boolean startsWith(String str) {
    if (str == null) {
        return false;
    }
    int len = str.length();
    if (len == 0) {
        return true;
    }
    if (len > size) {
        return false;
    }
    for (int i = 0; i < len; i++) {
        if (buffer[i] != str.charAt(i)) {
            return false;
        }
    }
    return true;
}","public void test134134() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""00}nq%<"");
    strBuilder0.indexOf(""m~"");
    strBuilder0.startsWith(""SO]1"");
}",""
"public char[] toCharArray(int startIndex, int endIndex) {
    endIndex = validateRange(startIndex, endIndex);
    int len = endIndex - startIndex;
    if (len == 0) {
        return ArrayUtils.EMPTY_CHAR_ARRAY;
    }
    char[] chars = new char[len];
    System.arraycopy(buffer, startIndex, chars, 0, len);
    return chars;
}","public void test135135() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(39);
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer();
    StrBuilder strBuilder1 = strBuilder0.clear();
    StrMatcher strMatcher0 = strBuilder_StrBuilderTokenizer0.getTrimmerMatcher();
    strBuilder0.indexOf(strMatcher0, 39);
    strBuilder1.appendPadding((-4025), 'n');
    char char0 = 'E';
    strBuilder0.lastIndexOf('E');
    strBuilder1.startsWith("""");
    // Undeclared exception!
    try {
        strBuilder1.toCharArray((-1), (-1));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -1
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Copies part of the builder's character array into a new character array.
 *
 * @param startIndex  the start index, inclusive, must be valid
 * @param endIndex  the end index, exclusive, must be valid except that
 *  if too large it is treated as end of string
 * @return a new array that holds part of the contents of the builder
 * @throws IndexOutOfBoundsException if startIndex is invalid,
 *  or if endIndex is invalid (but endIndex greater than size is valid)
 */"
"public StrBuilder insert(int index, char[] chars, int offset, int length) {
    validateIndex(index);
    if (chars == null) {
        return insert(index, nullText);
    }
    if (offset < 0 || offset > chars.length) {
        throw new StringIndexOutOfBoundsException(""Invalid offset: "" + offset);
    }
    if (length < 0 || offset + length > chars.length) {
        throw new StringIndexOutOfBoundsException(""Invalid length: "" + length);
    }
    if (length > 0) {
        ensureCapacity(size + length);
        System.arraycopy(buffer, index, buffer, index + length, size - index);
        System.arraycopy(chars, offset, buffer, index, length);
        size += length;
    }
    return this;
}","public void test136136() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(0);
    char[] charArray0 = new char[1];
    charArray0[0] = '(';
    char[] charArray1 = strBuilder0.getChars(charArray0);
    strBuilder0.leftString(0);
    StrMatcher.NoMatcher strMatcher_NoMatcher0 = new StrMatcher.NoMatcher();
    StrMatcher.charMatcher('/');
    StrBuilder strBuilder1 = strBuilder0.deleteFirst((StrMatcher) strMatcher_NoMatcher0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) """");
    stringBuffer0.insert(0, (CharSequence) """", 0, 0);
    strBuilder0.append(stringBuffer0);
    StrMatcher strMatcher0 = StrMatcher.commaMatcher();
    stringBuffer0.append(0L);
    strBuilder1.indexOf(strMatcher0);
    strBuilder1.append(""[Iv[? &{"", 0, 0);
    StrMatcher.charSetMatcher(""add() is unsupported"");
    int int0 = 0;
    // Undeclared exception!
    try {
        strBuilder1.insert(4, charArray1, 4, 0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 4
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts part of the character array into this builder.
 * Inserting null will use the stored null text value.
 *
 * @param index  the index to add at, must be valid
 * @param chars  the char array to insert
 * @param offset  the offset into the character array to start at, must be valid
 * @param length  the length of the character array part to copy, must be positive
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if any index is invalid
 */"
"public StrBuilder insert(int index, char[] chars) {
    validateIndex(index);
    if (chars == null) {
        return insert(index, nullText);
    }
    int len = chars.length;
    if (len > 0) {
        ensureCapacity(size + len);
        System.arraycopy(buffer, index, buffer, index + len, size - index);
        System.arraycopy(chars, 0, buffer, index, len);
        size += len;
    }
    return this;
}","public void test138138() throws Throwable {
    int int0 = 1494;
    StrBuilder strBuilder0 = new StrBuilder(1494);
    StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft(1494, 5, 'e');
    String string0 = null;
    StrBuilder strBuilder2 = strBuilder1.append((String) null);
    char[] charArray0 = new char[8];
    charArray0[0] = 'e';
    charArray0[1] = 'e';
    charArray0[2] = 'e';
    charArray0[3] = 'K';
    charArray0[4] = 'e';
    charArray0[5] = 'e';
    charArray0[6] = 'n';
    charArray0[7] = 'e';
    // Undeclared exception!
    try {
        strBuilder2.insert(1494, charArray0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 1494
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts the character array into this builder.
 * Inserting null will use the stored null text value.
 *
 * @param index  the index to add at, must be valid
 * @param chars  the char array to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder replace(int startIndex, int endIndex, String replaceStr) {
    endIndex = validateRange(startIndex, endIndex);
    int insertLen = (replaceStr == null ? 0 : replaceStr.length());
    replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen);
    return this;
}","public void test139139() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    StrBuilder strBuilder1 = strBuilder0.clear();
    strBuilder1.appendSeparator(""g?G"", (-1));
    int int0 = 0;
    String string0 = null;
    StrBuilder strBuilder2 = strBuilder1.appendln((String) null);
    strBuilder2.append((float) 0);
    String string1 = ""=F\\"";
    // Undeclared exception!
    try {
        strBuilder1.replace(501, 0, ""=F"");
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // end < start
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Replaces a portion of the string builder with another string.
 * The length of the inserted string does not have to match the removed length.
 *
 * @param startIndex  the start index, inclusive, must be valid
 * @param endIndex  the end index, exclusive, must be valid except
 *  that if too large it is treated as end of string
 * @param replaceStr  the string to replace with, null means delete range
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Appends the pad character to the builder the specified number of times.
 *
 * @param length  the length to append, negative means no append
 * @param padChar  the character to append
 * @return this, to enable chaining
 */
public StrBuilder appendPadding(int length, char padChar) {
    if (length >= 0) {
        ensureCapacity(size + length);
        for (int i = 0; i < length; i++) {
            buffer[size++] = padChar;
        }
    }
    return this;
}","public void test140140() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(0);
    StrBuilder strBuilder1 = strBuilder0.append((double) 0);
    StrBuilder strBuilder2 = new StrBuilder("" O9'^, B1?:[!Xro._$"");
    StrBuilder strBuilder3 = strBuilder0.appendln(strBuilder2);
    strBuilder3.deleteCharAt(0);
    strBuilder1.appendPadding(0, 'y');
}",""
"public StrBuilder insert(int index, char[] chars) {
    validateIndex(index);
    if (chars == null) {
        return insert(index, nullText);
    }
    int len = chars.length;
    if (len > 0) {
        ensureCapacity(size + len);
        System.arraycopy(buffer, index, buffer, index + len, size - index);
        System.arraycopy(chars, 0, buffer, index, len);
        size += len;
    }
    return this;
}","public void test141141() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(1373);
    strBuilder0.appendFixedWidthPadLeft((Object) ""z?8BI%.?IOfF"", 1373, '@');
    char[] charArray0 = new char[0];
    StrMatcher.CharSetMatcher strMatcher_CharSetMatcher0 = new StrMatcher.CharSetMatcher(charArray0);
    StrMatcher.charSetMatcher("""");
    StrMatcher.charSetMatcher(charArray0);
    strBuilder0.indexOf((StrMatcher) strMatcher_CharSetMatcher0, 1373);
    strBuilder0.asReader();
    StrBuilder strBuilder1 = strBuilder0.insert(3, 1373);
    strBuilder1.insert(1373, charArray0);
}","/**
 * Inserts the character array into this builder.
 * Inserting null will use the stored null text value.
 *
 * @param index  the index to add at, must be valid
 * @param chars  the char array to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder deleteCharAt(int index) {
    if (index < 0 || index >= size) {
        throw new StringIndexOutOfBoundsException(index);
    }
    deleteImpl(index, index + 1, 1);
    return this;
}","public void test143143() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(0);
    StrBuilder strBuilder1 = strBuilder0.insert(0, true);
    StrBuilder strBuilder2 = strBuilder1.appendln(strBuilder0);
    StrMatcher.NoMatcher strMatcher_NoMatcher0 = new StrMatcher.NoMatcher();
    strBuilder0.lastIndexOf((StrMatcher) strMatcher_NoMatcher0, 0);
    StrBuilder strBuilder3 = strBuilder0.setLength(1959);
    strBuilder0.contains((StrMatcher) null);
    StrTokenizer strTokenizer0 = strBuilder0.asTokenizer();
    strBuilder0.endsWith("""");
    StrBuilder strBuilder4 = strBuilder0.appendln((double) 0);
    strBuilder2.equalsIgnoreCase(strBuilder4);
    strBuilder4.substring(0);
    StrBuilder strBuilder5 = strBuilder0.appendAll((Iterator) strTokenizer0);
    strBuilder5.midString(1, 1);
    strBuilder5.asReader();
    strBuilder5.toString();
    strBuilder0.midString(114, 2859);
    strBuilder2.indexOf((StrMatcher) strMatcher_NoMatcher0);
    strBuilder3.insert(989, true);
    strBuilder4.deleteCharAt(114);
}","/**
 * Deletes the character at the specified index.
 *
 * @see #charAt(int)
 * @see #setCharAt(int, char)
 * @param index  the index to delete
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public void getChars(int startIndex, int endIndex, char[] destination, int destinationIndex) {
    if (startIndex < 0) {
        throw new StringIndexOutOfBoundsException(startIndex);
    }
    if (endIndex < 0 || endIndex > length()) {
        throw new StringIndexOutOfBoundsException(endIndex);
    }
    if (startIndex > endIndex) {
        throw new StringIndexOutOfBoundsException(""end < start"");
    }
    System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);
}","public void test144144() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    char[] charArray0 = new char[7];
    charArray0[0] = 'B';
    charArray0[1] = 'E';
    char char0 = 'f';
    int int0 = 57;
    int int1 = 0;
    // Undeclared exception!
    try {
        strBuilder0.getChars(57, 0, charArray0, 0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // end < start
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Copies the character array into the specified array.
 *
 * @param startIndex  first index to copy, inclusive, must be valid
 * @param endIndex  last index, exclusive, must be valid
 * @param destination  the destination array, must not be null or too small
 * @param destinationIndex  the index to start copying in destination
 * @throws NullPointerException if the array is null
 * @throws IndexOutOfBoundsException if any index is invalid
 */"
"public StrBuilder deleteCharAt(int index) {
    if (index < 0 || index >= size) {
        throw new StringIndexOutOfBoundsException(index);
    }
    deleteImpl(index, index + 1, 1);
    return this;
}","public void test145145() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(9);
    strBuilder0.toString();
    // Undeclared exception!
    try {
        strBuilder0.deleteCharAt(53);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 53
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Deletes the character at the specified index.
 *
 * @see #charAt(int)
 * @see #setCharAt(int, char)
 * @param index  the index to delete
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder deleteCharAt(int index) {
    if (index < 0 || index >= size) {
        throw new StringIndexOutOfBoundsException(index);
    }
    deleteImpl(index, index + 1, 1);
    return this;
}","public void test146146() throws Throwable {
    String string0 = ""2P,obrHA.QSc}M"";
    StrBuilder strBuilder0 = new StrBuilder(""2P,obrHA.QSc}M"");
    StrMatcher.StringMatcher strMatcher_StringMatcher0 = new StrMatcher.StringMatcher(""2P,obrHA.QSc}M"");
    char char0 = '\\';
    StrMatcher.charMatcher('\\');
    strBuilder0.indexOf((StrMatcher) strMatcher_StringMatcher0);
    StrBuilder strBuilder1 = strBuilder0.deleteAll((StrMatcher) strMatcher_StringMatcher0);
    strBuilder1.appendNewLine();
    strBuilder1.ensureCapacity((-2706));
    int int0 = 2;
    // Undeclared exception!
    try {
        strBuilder1.deleteCharAt(2);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 2
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Deletes the character at the specified index.
 *
 * @see #charAt(int)
 * @see #setCharAt(int, char)
 * @param index  the index to delete
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public String substring(int startIndex, int endIndex) {
    endIndex = validateRange(startIndex, endIndex);
    return new String(buffer, startIndex, endIndex - startIndex);
}","public void test147147() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder("""");
    int int0 = (-1541);
    // Undeclared exception!
    try {
        strBuilder0.substring((-1541), (-1541));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -1541
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Extracts a portion of this string builder as a string.
 * <p>
 * Note: This method treats an endIndex greater than the length of the
 * builder as equal to the length of the builder, and continues
 * without error, unlike StringBuffer or String.
 *
 * @param startIndex  the start index, inclusive, must be valid
 * @param endIndex  the end index, exclusive, must be valid except
 *  that if too large it is treated as end of string
 * @return the new string
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public String substring(int startIndex, int endIndex) {
    endIndex = validateRange(startIndex, endIndex);
    return new String(buffer, startIndex, endIndex - startIndex);
}","public void test148148() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    char char0 = 'Z';
    StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft((-3023), (-3023), 'k');
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder1.new StrBuilderTokenizer();
    char[] charArray0 = new char[9];
    charArray0[1] = 'y';
    charArray0[2] = 'Z';
    charArray0[3] = 'Z';
    charArray0[4] = 'k';
    charArray0[5] = 'Z';
    charArray0[6] = 'Z';
    charArray0[7] = 'Z';
    charArray0[8] = 'Z';
    StrBuilder strBuilder2 = strBuilder1.appendNewLine();
    StrTokenizer strTokenizer0 = strBuilder_StrBuilderTokenizer0.reset(charArray0);
    strBuilder1.appendAll((Iterator) strTokenizer0);
    strBuilder0.appendSeparator('Z', (int) 'Z');
    StrBuilder strBuilder3 = strBuilder2.appendFixedWidthPadRight(97, (-1606), 'k');
    // Undeclared exception!
    try {
        strBuilder3.substring((int) 'Z', 0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // end < start
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Extracts a portion of this string builder as a string.
 * <p>
 * Note: This method treats an endIndex greater than the length of the
 * builder as equal to the length of the builder, and continues
 * without error, unlike StringBuffer or String.
 *
 * @param startIndex  the start index, inclusive, must be valid
 * @param endIndex  the end index, exclusive, must be valid except
 *  that if too large it is treated as end of string
 * @return the new string
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder insert(int index, char[] chars, int offset, int length) {
    validateIndex(index);
    if (chars == null) {
        return insert(index, nullText);
    }
    if (offset < 0 || offset > chars.length) {
        throw new StringIndexOutOfBoundsException(""Invalid offset: "" + offset);
    }
    if (length < 0 || offset + length > chars.length) {
        throw new StringIndexOutOfBoundsException(""Invalid length: "" + length);
    }
    if (length > 0) {
        ensureCapacity(size + length);
        System.arraycopy(buffer, index, buffer, index + length, size - index);
        System.arraycopy(chars, offset, buffer, index, length);
        size += length;
    }
    return this;
}","public void test149149() throws Throwable {
    int int0 = (-1);
    StrBuilder strBuilder0 = new StrBuilder((-1));
    char[] charArray0 = new char[0];
    strBuilder0.appendln(charArray0);
    StrBuilder strBuilder1 = strBuilder0.append((double) (-1));
    StrBuilder strBuilder2 = strBuilder1.append((-1273));
    int int1 = 0;
    StrBuilder strBuilder3 = strBuilder2.appendln(strBuilder1, 0, 5);
    // Undeclared exception!
    try {
        strBuilder3.insert(0, charArray0, 32, 427);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // Invalid offset: 32
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts part of the character array into this builder.
 * Inserting null will use the stored null text value.
 *
 * @param index  the index to add at, must be valid
 * @param chars  the char array to insert
 * @param offset  the offset into the character array to start at, must be valid
 * @param length  the length of the character array part to copy, must be positive
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if any index is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Searches the string builder to find the first reference to the specified char.
 *
 * @param ch  the character to find
 * @return the first index of the character, or -1 if not found
 */
public int indexOf(char ch) {
    return indexOf(ch, 0);
}","public void test150150() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    StrBuilder strBuilder1 = new StrBuilder();
    StrBuilder strBuilder2 = strBuilder0.append((Object) strBuilder1);
    StrBuilder strBuilder3 = strBuilder2.append(false);
    strBuilder0.startsWith("""");
    StrBuilder strBuilder4 = strBuilder0.replaceAll("""", """");
    strBuilder4.leftString(2255);
    StrMatcher strMatcher0 = StrMatcher.singleQuoteMatcher();
    strBuilder0.lastIndexOf(strMatcher0, 0);
    StrBuilder strBuilder5 = strBuilder1.appendln((double) 0);
    strBuilder1.substring(0, 723);
    strBuilder5.setNewLineText(""\nYt$6%kn"");
    LinkedList<String> linkedList0 = new LinkedList<String>();
    Object[] objectArray0 = new Object[4];
    objectArray0[0] = (Object) ""\nYt$6%kn"";
    objectArray0[1] = (Object) """";
    objectArray0[2] = (Object) """";
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder3.new StrBuilderTokenizer();
    Object object0 = strBuilder_StrBuilderTokenizer0.cloneReset();
    objectArray0[3] = object0;
    strBuilder4.appendAll(objectArray0);
    StrBuilder strBuilder6 = strBuilder4.appendAll((Collection) linkedList0);
    strBuilder6.setNewLineText(""org.apache.commons.lang.text.StrBuilder@0000000002false"");
    strBuilder4.indexOf('+');
}",""
"public StrBuilder append(StrBuilder str, int startIndex, int length) {
    if (str == null) {
        return appendNull();
    }
    if (startIndex < 0 || startIndex > str.length()) {
        throw new StringIndexOutOfBoundsException(""startIndex must be valid"");
    }
    if (length < 0 || (startIndex + length) > str.length()) {
        throw new StringIndexOutOfBoundsException(""length must be valid"");
    }
    if (length > 0) {
        int len = length();
        ensureCapacity(len + length);
        str.getChars(startIndex, startIndex + length, buffer, len);
        size += length;
    }
    return this;
}","public void test151151() throws Throwable {
    String string0 = ""NAUa0Jo/(HK*3"";
    StrBuilder strBuilder0 = new StrBuilder(""NAUa0Jo/(HK*3"");
    strBuilder0.endsWith(""NAUa0Jo/(HK*3"");
    int int0 = 1218;
    char char0 = 'g';
    StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft(1218, 1218, 'g');
    StrBuilder strBuilder2 = strBuilder0.appendln(1.0);
    strBuilder2.clear();
    StrBuilder strBuilder3 = strBuilder2.deleteAll((StrMatcher) null);
    int int1 = 272;
    strBuilder2.midString((-198), 272);
    StrBuilder strBuilder4 = strBuilder1.reverse();
    int int2 = 2089;
    // Undeclared exception!
    try {
        strBuilder3.append(strBuilder4, 0, 2089);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // length must be valid
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends part of a string builder to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 */"
"public Object previous() {
    if (hasPrevious()) {
        return tokens[--tokenPos];
    }
    throw new NoSuchElementException();
}","public void test152152() throws Throwable {
    int int0 = 0;
    StrBuilder strBuilder0 = new StrBuilder(0);
    char char0 = '\\';
    char[] charArray0 = new char[1];
    charArray0[0] = '\\';
    strBuilder0.insert(0, charArray0, 0, 0);
    strBuilder0.indexOf('\\', 5);
    StrBuilder strBuilder1 = new StrBuilder();
    StrMatcher strMatcher0 = StrMatcher.noneMatcher();
    strBuilder0.lastIndexOf(strMatcher0);
    strBuilder0.appendFixedWidthPadLeft(115, (-1), '\\');
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder1.new StrBuilderTokenizer();
    strBuilder0.appendFixedWidthPadRight(5, 0, '%');
    StrTokenizer.getCSVInstance();
    // Undeclared exception!
    try {
        strBuilder_StrBuilderTokenizer0.previous();
        fail(""Expecting exception: NoSuchElementException"");
    } catch (NoSuchElementException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.text.StrTokenizer"", e);
    }
}","/**
 * Gets the token previous to the last returned token.
 *
 * @return the previous token
 */"
"//-----------------------------------------------------------------------
/**
 * Validates parameters defining a range of the builder.
 *
 * @param startIndex  the start index, inclusive, must be valid
 * @param endIndex  the end index, exclusive, must be valid except
 *  that if too large it is treated as end of string
 * @return the new string
 * @throws IndexOutOfBoundsException if the index is invalid
 */
protected int validateRange(int startIndex, int endIndex) {
    if (startIndex < 0) {
        throw new StringIndexOutOfBoundsException(startIndex);
    }
    if (endIndex > size) {
        endIndex = size;
    }
    if (startIndex > endIndex) {
        throw new StringIndexOutOfBoundsException(""end < start"");
    }
    return endIndex;
}","public void test153153() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder("""");
    int int0 = (-1371);
    StrBuilder strBuilder1 = strBuilder0.appendln((String) null, 354, 354);
    StrBuilder strBuilder2 = strBuilder1.setLength(354);
    // Undeclared exception!
    try {
        strBuilder2.validateRange((-1371), 0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -1371
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Gets the character at the specified index.
 *
 * @see #setCharAt(int, char)
 * @see #deleteCharAt(int)
 * @param index  the index to retrieve, must be valid
 * @return the character at the index
 * @throws IndexOutOfBoundsException if the index is invalid
 */
public char charAt(int index) {
    if (index < 0 || index >= length()) {
        throw new StringIndexOutOfBoundsException(index);
    }
    return buffer[index];
}","public void test155155() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""303~["");
    StrMatcher strMatcher0 = StrMatcher.spaceMatcher();
    strBuilder0.indexOf(strMatcher0);
    StrBuilder strBuilder1 = new StrBuilder((-1));
    StrBuilder strBuilder2 = strBuilder0.appendln(strBuilder1);
    strBuilder2.toStringBuffer();
    String string0 = ""x#WClg8&#"";
    int int0 = 108;
    // Undeclared exception!
    try {
        strBuilder1.charAt((-1));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -1
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}",""
"// -----------------------------------------------------------------------
/**
 * Advanced search and replaces within the builder using a matcher.
 * <p>
 * Matchers can be used to perform advanced behaviour.
 * For example you could write a matcher to delete all occurances
 * where the character 'a' is followed by a number.
 *
 * @param matcher  the matcher to use to find the deletion, null causes no action
 * @param replaceStr  the string to replace the match with, null is a delete
 * @param startIndex  the start index, inclusive, must be valid
 * @param endIndex  the end index, exclusive, must be valid except
 *  that if too large it is treated as end of string
 * @param replaceCount  the number of times to replace, -1 for replace all
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if start index is invalid
 */
public StrBuilder replace(StrMatcher matcher, String replaceStr, int startIndex, int endIndex, int replaceCount) {
    endIndex = validateRange(startIndex, endIndex);
    return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);
}","public void test157157() throws Throwable {
    int int0 = 696;
    StrBuilder strBuilder0 = new StrBuilder(696);
    StrBuilder strBuilder1 = strBuilder0.appendAll((Iterator) null);
    StrMatcher strMatcher0 = StrMatcher.quoteMatcher();
    // Undeclared exception!
    try {
        strBuilder1.replace(strMatcher0, ""g2k1pqlL:eQ^"", 5, 5, 696);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // end < start
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}",""
"public StrBuilder appendln(StrBuilder str, int startIndex, int length) {
    return append(str, startIndex, length).appendNewLine();
}","public void test158158() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    strBuilder0.validateIndex(0);
    StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader();
    char[] charArray0 = new char[5];
    charArray0[0] = 'n';
    charArray0[1] = '\""';
    charArray0[2] = 'j';
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    strBuilder_StrBuilderReader0.read(charBuffer0);
    strBuilder_StrBuilderReader0.skip((-785L));
    charArray0[3] = 'Q';
    strBuilder_StrBuilderReader0.read(charArray0);
    charArray0[4] = ';';
    CharBuffer charBuffer1 = CharBuffer.wrap(charArray0, 0, 0);
    strBuilder_StrBuilderReader0.read(charBuffer1);
    strBuilder_StrBuilderReader0.skip((-786L));
    strBuilder0.startsWith(""Z"");
    StrBuilder strBuilder1 = new StrBuilder((-1865));
    strBuilder1.deleteAll(""Z"");
    // Undeclared exception!
    try {
        strBuilder0.appendln(strBuilder1, 0, (-1865));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // length must be valid
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends part of a string builder followed by a new line to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 * @since 2.3
 */"
"public StrBuilder appendln(StringBuffer str, int startIndex, int length) {
    return append(str, startIndex, length).appendNewLine();
}","public void test160160() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""j5\"""");
    strBuilder0.appendSeparator("", Length: "", 0);
    String string0 = """";
    StrBuilder strBuilder1 = strBuilder0.replaceFirst("", Length: "", """");
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    strBuilder1.appendWithSeparators((Collection) linkedList0, "", Length: "");
    StringBuffer stringBuffer0 = new StringBuffer();
    // Undeclared exception!
    try {
        strBuilder0.appendln(stringBuffer0, (-1808), (-970));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // startIndex must be valid
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends part of a string buffer followed by a new line to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 * @since 2.3
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the character at the specified index.
 *
 * @see #setCharAt(int, char)
 * @see #deleteCharAt(int)
 * @param index  the index to retrieve, must be valid
 * @return the character at the index
 * @throws IndexOutOfBoundsException if the index is invalid
 */
public char charAt(int index) {
    if (index < 0 || index >= length()) {
        throw new StringIndexOutOfBoundsException(index);
    }
    return buffer[index];
}","public void test162162() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""org.apache.commons.lang.text.StrBuilder$StrBuilderReader"");
    char[] charArray0 = new char[8];
    charArray0[0] = 'B';
    charArray0[1] = 'm';
    char char0 = '?';
    StrBuilder strBuilder1 = strBuilder0.clear();
    // Undeclared exception!
    try {
        strBuilder1.charAt(0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 0
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}",""
"public StrBuilder setLength(int length) {
    if (length < 0) {
        throw new StringIndexOutOfBoundsException(length);
    }
    if (length < size) {
        size = length;
    } else if (length > size) {
        ensureCapacity(length);
        int oldEnd = size;
        int newEnd = length;
        size = length;
        for (int i = oldEnd; i < newEnd; i++) {
            buffer[i] = '\0';
        }
    }
    return this;
}","public void test163163() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(97);
    StringBuffer stringBuffer0 = new StringBuffer(1);
    StrBuilder strBuilder1 = strBuilder0.append(stringBuffer0);
    StrBuilder strBuilder2 = strBuilder1.appendln((char[]) null);
    StrBuilder strBuilder3 = strBuilder0.appendln((float) 97);
    strBuilder2.contains(""{F=]qq_.^QC"");
    StrBuilder strBuilder4 = strBuilder3.clear();
    StringBuffer stringBuffer1 = new StringBuffer(""{F=]qq_.^QC"");
    StrBuilder strBuilder5 = strBuilder1.appendln(stringBuffer1);
    StrBuilder strBuilder6 = new StrBuilder(1);
    strBuilder5.appendFixedWidthPadLeft((Object) strBuilder6, 1, '-');
    strBuilder4.asTokenizer();
    strBuilder4.appendln((long) 1);
    StrBuilder strBuilder7 = strBuilder0.appendln(""8h"");
    strBuilder7.ensureCapacity(97);
    StrBuilder.StrBuilderWriter strBuilder_StrBuilderWriter0 = strBuilder2.new StrBuilderWriter();
    strBuilder_StrBuilderWriter0.write(97);
    strBuilder0.setLength(0);
}","/**
 * Updates the length of the builder by either dropping the last characters
 * or adding filler of unicode zero.
 *
 * @param length  the length to set to, must be zero or positive
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the length is negative
 */"
"public StrBuilder appendln(boolean value) {
    return append(value).appendNewLine();
}","public void test164164() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    int int0 = (-975);
    strBuilder0.size = (-975);
    strBuilder0.startsWith((String) null);
    // Undeclared exception!
    try {
        strBuilder0.appendln(true);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -975
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends a boolean value followed by a new line to the string builder.
 *
 * @param value  the value to append
 * @return this, to enable chaining
 * @since 2.3
 */"
"public StrBuilder deleteCharAt(int index) {
    if (index < 0 || index >= size) {
        throw new StringIndexOutOfBoundsException(index);
    }
    deleteImpl(index, index + 1, 1);
    return this;
}","public void test165165() throws Throwable {
    String string0 = ""[K"";
    StrBuilder strBuilder0 = new StrBuilder(""[K"");
    // Undeclared exception!
    try {
        strBuilder0.deleteCharAt((-573));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -573
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Deletes the character at the specified index.
 *
 * @see #charAt(int)
 * @see #setCharAt(int, char)
 * @param index  the index to delete
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public boolean equals(Object obj) {
    if (obj instanceof StrBuilder) {
        return equals((StrBuilder) obj);
    }
    return false;
}","public void test167167() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""A#"");
    strBuilder0.rightString((-1832));
    strBuilder0.equals((Object) ""A#"");
}","/**
 * Checks the contents of this builder against another to see if they
 * contain the same character content.
 *
 * @param obj  the object to check, null returns false
 * @return true if the builders contain the same characters in the same order
 */"
"public StrBuilder appendln(char[] chars) {
    return append(chars).appendNewLine();
}","public void test168168() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""]3ph"");
    StrBuilder strBuilder1 = strBuilder0.deleteFirst('w');
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer();
    StrMatcher strMatcher0 = strBuilder_StrBuilderTokenizer0.getTrimmerMatcher();
    strBuilder0.indexOf(strMatcher0, 388);
    strBuilder0.appendNewLine();
    strBuilder1.rightString(0);
    strBuilder0.isEmpty();
    strBuilder1.append(1293);
    char[] charArray0 = new char[8];
    charArray0[0] = 'w';
    charArray0[1] = 'w';
    charArray0[2] = 'w';
    charArray0[3] = 'w';
    charArray0[4] = 'w';
    charArray0[5] = 'w';
    charArray0[6] = 'w';
    charArray0[7] = 'w';
    strBuilder0.appendln(charArray0);
}","/**
 * Appends a char array followed by a new line to the string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param chars  the char array to append
 * @return this, to enable chaining
 * @since 2.3
 */"
"public StrBuilder deleteCharAt(int index) {
    if (index < 0 || index >= size) {
        throw new StringIndexOutOfBoundsException(index);
    }
    deleteImpl(index, index + 1, 1);
    return this;
}","public void test169169() throws Throwable {
    int int0 = (-3693);
    StrBuilder strBuilder0 = new StrBuilder((-3693));
    String string0 = """";
    strBuilder0.setNewLineText("""");
    StrBuilder strBuilder1 = new StrBuilder((-3693));
    StrBuilder strBuilder2 = strBuilder0.append(strBuilder1);
    strBuilder2.appendFixedWidthPadLeft((Object) strBuilder0, (-3693), 'e');
    // Undeclared exception!
    try {
        strBuilder2.deleteCharAt((-3693));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -3693
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Deletes the character at the specified index.
 *
 * @see #charAt(int)
 * @see #setCharAt(int, char)
 * @param index  the index to delete
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public String substring(int startIndex, int endIndex) {
    endIndex = validateRange(startIndex, endIndex);
    return new String(buffer, startIndex, endIndex - startIndex);
}","public void test170170() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    StrBuilder.StrBuilderWriter strBuilder_StrBuilderWriter0 = strBuilder0.new StrBuilderWriter();
    String string0 = ""user.region"";
    strBuilder_StrBuilderWriter0.write(""user.region"");
    // Undeclared exception!
    try {
        strBuilder0.substring(1469, 0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // end < start
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Extracts a portion of this string builder as a string.
 * <p>
 * Note: This method treats an endIndex greater than the length of the
 * builder as equal to the length of the builder, and continues
 * without error, unlike StringBuffer or String.
 *
 * @param startIndex  the start index, inclusive, must be valid
 * @param endIndex  the end index, exclusive, must be valid except
 *  that if too large it is treated as end of string
 * @return the new string
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder setLength(int length) {
    if (length < 0) {
        throw new StringIndexOutOfBoundsException(length);
    }
    if (length < size) {
        size = length;
    } else if (length > size) {
        ensureCapacity(length);
        int oldEnd = size;
        int newEnd = length;
        size = length;
        for (int i = oldEnd; i < newEnd; i++) {
            buffer[i] = '\0';
        }
    }
    return this;
}","public void test171171() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(1581);
    int int0 = (-2769);
    Integer integer0 = new Integer(1581);
    // Undeclared exception!
    try {
        strBuilder0.setLength((-2769));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -2769
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Updates the length of the builder by either dropping the last characters
 * or adding filler of unicode zero.
 *
 * @param length  the length to set to, must be zero or positive
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the length is negative
 */"
"public StrBuilder setLength(int length) {
    if (length < 0) {
        throw new StringIndexOutOfBoundsException(length);
    }
    if (length < size) {
        size = length;
    } else if (length > size) {
        ensureCapacity(length);
        int oldEnd = size;
        int newEnd = length;
        size = length;
        for (int i = oldEnd; i < newEnd; i++) {
            buffer[i] = '\0';
        }
    }
    return this;
}","public void test172172() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder((-4288));
    strBuilder0.getNullText();
    strBuilder0.hashCode();
    StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader();
    strBuilder_StrBuilderReader0.skip(0L);
    strBuilder_StrBuilderReader0.mark((-4288));
    strBuilder_StrBuilderReader0.reset();
    strBuilder_StrBuilderReader0.skip((-3040L));
    strBuilder0.asTokenizer();
    StrBuilder strBuilder1 = new StrBuilder(""4mc1"");
    strBuilder0.equals((Object) strBuilder1);
    // Undeclared exception!
    try {
        strBuilder0.setLength((-4288));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -4288
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Updates the length of the builder by either dropping the last characters
 * or adding filler of unicode zero.
 *
 * @param length  the length to set to, must be zero or positive
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the length is negative
 */"
"//-----------------------------------------------------------------------
/**
 * Gets the length of the string builder.
 * <p>
 * This method is the same as {@link #length()} and is provided to match the
 * API of Collections.
 *
 * @return the length
 */
public int size() {
    return size;
}","public void test173173() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder((-2323));
    StrBuilder.StrBuilderWriter strBuilder_StrBuilderWriter0 = strBuilder0.new StrBuilderWriter();
    char[] charArray0 = new char[6];
    charArray0[0] = 'i';
    charArray0[1] = 'C';
    charArray0[2] = 'M';
    charArray0[3] = 'v';
    charArray0[4] = 'D';
    strBuilder_StrBuilderWriter0.write(""Naq=EJ[a4ZQ"");
    StrBuilder strBuilder1 = strBuilder0.append((-3965.6216974608983));
    StrBuilder strBuilder2 = strBuilder1.appendln('M');
    charArray0[5] = '}';
    strBuilder_StrBuilderWriter0.write(charArray0);
    strBuilder1.appendln((long) (-2323));
    strBuilder1.replaceAll(']', 'C');
    strBuilder2.asWriter();
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer();
    strBuilder_StrBuilderTokenizer0.getContent();
    StrBuilder strBuilder3 = strBuilder1.minimizeCapacity();
    strBuilder3.appendln((float) (-2323));
    StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder2.new StrBuilderReader();
    strBuilder_StrBuilderReader0.mark((-1009));
    strBuilder1.size();
}",""
"public StrBuilder setCharAt(int index, char ch) {
    if (index < 0 || index >= length()) {
        throw new StringIndexOutOfBoundsException(index);
    }
    buffer[index] = ch;
    return this;
}","public void test174174() throws Throwable {
    String string0 = """";
    StrBuilder strBuilder0 = new StrBuilder("""");
    StrMatcher strMatcher0 = StrMatcher.trimMatcher();
    StrMatcher.stringMatcher("""");
    StrBuilder strBuilder1 = strBuilder0.deleteAll(strMatcher0);
    int int0 = 0;
    strBuilder1.replaceAll("""", """");
    char char0 = ':';
    // Undeclared exception!
    try {
        strBuilder1.setCharAt(0, ':');
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 0
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Sets the character at the specified index.
 *
 * @see #charAt(int)
 * @see #deleteCharAt(int)
 * @param index  the index to set
 * @param ch  the new character
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder insert(int index, char[] chars, int offset, int length) {
    validateIndex(index);
    if (chars == null) {
        return insert(index, nullText);
    }
    if (offset < 0 || offset > chars.length) {
        throw new StringIndexOutOfBoundsException(""Invalid offset: "" + offset);
    }
    if (length < 0 || offset + length > chars.length) {
        throw new StringIndexOutOfBoundsException(""Invalid length: "" + length);
    }
    if (length > 0) {
        ensureCapacity(size + length);
        System.arraycopy(buffer, index, buffer, index + length, size - index);
        System.arraycopy(chars, offset, buffer, index, length);
        size += length;
    }
    return this;
}","public void test175175() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(0);
    strBuilder0.appendFixedWidthPadRight((-1106), 0, 'E');
    strBuilder0.lastIndexOf('O', 34);
    StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader();
    StrBuilder strBuilder1 = strBuilder0.trim();
    char[] charArray0 = new char[5];
    charArray0[0] = 'E';
    charArray0[1] = 'O';
    charArray0[2] = 'E';
    charArray0[3] = 'O';
    charArray0[4] = 'E';
    strBuilder_StrBuilderReader0.read();
    // Undeclared exception!
    try {
        strBuilder1.insert((-2892), charArray0, (-54), 0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -2892
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts part of the character array into this builder.
 * Inserting null will use the stored null text value.
 *
 * @param index  the index to add at, must be valid
 * @param chars  the char array to insert
 * @param offset  the offset into the character array to start at, must be valid
 * @param length  the length of the character array part to copy, must be positive
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if any index is invalid
 */"
"public void getChars(int startIndex, int endIndex, char[] destination, int destinationIndex) {
    if (startIndex < 0) {
        throw new StringIndexOutOfBoundsException(startIndex);
    }
    if (endIndex < 0 || endIndex > length()) {
        throw new StringIndexOutOfBoundsException(endIndex);
    }
    if (startIndex > endIndex) {
        throw new StringIndexOutOfBoundsException(""end < start"");
    }
    System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);
}","public void test177177() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""6.0"");
    char[] charArray0 = new char[4];
    charArray0[0] = 'u';
    charArray0[1] = '+';
    charArray0[2] = 'c';
    charArray0[3] = '_';
    StrBuilder strBuilder1 = strBuilder0.appendln(charArray0, 0, 0);
    strBuilder1.lastIndexOf('W');
    // Undeclared exception!
    try {
        strBuilder1.getChars((-1934), (-1934), charArray0, 0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -1934
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Copies the character array into the specified array.
 *
 * @param startIndex  first index to copy, inclusive, must be valid
 * @param endIndex  last index, exclusive, must be valid
 * @param destination  the destination array, must not be null or too small
 * @param destinationIndex  the index to start copying in destination
 * @throws NullPointerException if the array is null
 * @throws IndexOutOfBoundsException if any index is invalid
 */"
"public StrBuilder insert(int index, long value) {
    return insert(index, String.valueOf(value));
}","public void test178178() throws Throwable {
    String string0 = ""xLGvMV>QU@B_}M8pe,x"";
    StrBuilder strBuilder0 = new StrBuilder(""xLGvMV>QU@B_}M8pe,x"");
    StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader();
    int int0 = 224;
    strBuilder_StrBuilderReader0.mark(224);
    StrMatcher.CharMatcher strMatcher_CharMatcher0 = new StrMatcher.CharMatcher('V');
    StrMatcher.charSetMatcher(""xLGvMV>QU@B_}M8pe,x"");
    strBuilder0.lastIndexOf((StrMatcher) strMatcher_CharMatcher0, 224);
    // Undeclared exception!
    try {
        strBuilder0.insert(224, (long) 5);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 224
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts the value into this builder.
 *
 * @param index  the index to add at, must be valid
 * @param value  the value to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public char[] toCharArray(int startIndex, int endIndex) {
    endIndex = validateRange(startIndex, endIndex);
    int len = endIndex - startIndex;
    if (len == 0) {
        return ArrayUtils.EMPTY_CHAR_ARRAY;
    }
    char[] chars = new char[len];
    System.arraycopy(buffer, startIndex, chars, 0, len);
    return chars;
}","public void test179179() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer();
    StrBuilder strBuilder1 = strBuilder0.appendln(0L);
    strBuilder1.setCharAt(0, ':');
    char[] charArray0 = new char[2];
    charArray0[0] = '6';
    charArray0[1] = '!';
    StrBuilder strBuilder2 = strBuilder0.appendln('E');
    strBuilder2.append(0);
    strBuilder_StrBuilderTokenizer0.tokenize(charArray0, 0, 0);
    strBuilder0.indexOf("""", 4);
    strBuilder0.length();
    StrBuilder strBuilder3 = strBuilder0.setNullText("""");
    // Undeclared exception!
    try {
        strBuilder3.toCharArray((-1), 0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -1
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Copies part of the builder's character array into a new character array.
 *
 * @param startIndex  the start index, inclusive, must be valid
 * @param endIndex  the end index, exclusive, must be valid except that
 *  if too large it is treated as end of string
 * @return a new array that holds part of the contents of the builder
 * @throws IndexOutOfBoundsException if startIndex is invalid,
 *  or if endIndex is invalid (but endIndex greater than size is valid)
 */"
"public StrBuilder append(StrBuilder str, int startIndex, int length) {
    if (str == null) {
        return appendNull();
    }
    if (startIndex < 0 || startIndex > str.length()) {
        throw new StringIndexOutOfBoundsException(""startIndex must be valid"");
    }
    if (length < 0 || (startIndex + length) > str.length()) {
        throw new StringIndexOutOfBoundsException(""length must be valid"");
    }
    if (length > 0) {
        int len = length();
        ensureCapacity(len + length);
        str.getChars(startIndex, startIndex + length, buffer, len);
        size += length;
    }
    return this;
}","public void test180180() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder((String) null);
    StrBuilder strBuilder1 = strBuilder0.appendln((-464.78));
    StrBuilder strBuilder2 = strBuilder1.clear();
    strBuilder0.midString((-576), 0);
    strBuilder0.getNewLineText();
    StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder1.new StrBuilderReader();
    strBuilder_StrBuilderReader0.markSupported();
    StrBuilder strBuilder3 = strBuilder0.append((double) (-576));
    strBuilder0.appendFixedWidthPadLeft((Object) """", 117, '>');
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder1.new StrBuilderTokenizer();
    char[] charArray0 = new char[4];
    charArray0[0] = '>';
    charArray0[1] = '>';
    charArray0[2] = '>';
    charArray0[3] = '>';
    StrTokenizer strTokenizer0 = strBuilder_StrBuilderTokenizer0.reset(charArray0);
    strBuilder2.appendWithSeparators((Iterator) strTokenizer0, """");
    strBuilder1.indexOf('*');
    StrBuilder strBuilder4 = strBuilder3.setNewLineText("""");
    Object[] objectArray0 = new Object[0];
    strBuilder4.appendWithSeparators(objectArray0, """");
    // Undeclared exception!
    try {
        strBuilder4.append(strBuilder1, (-2336), Integer.MAX_VALUE);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // startIndex must be valid
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends part of a string builder to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 */"
"public StrBuilder deleteCharAt(int index) {
    if (index < 0 || index >= size) {
        throw new StringIndexOutOfBoundsException(index);
    }
    deleteImpl(index, index + 1, 1);
    return this;
}","public void test181181() throws Throwable {
    int int0 = 0;
    StrBuilder strBuilder0 = new StrBuilder(0);
    int int1 = 0;
    // Undeclared exception!
    try {
        strBuilder0.deleteCharAt(0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 0
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Deletes the character at the specified index.
 *
 * @see #charAt(int)
 * @see #setCharAt(int, char)
 * @param index  the index to delete
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder appendln(char[] chars) {
    return append(chars).appendNewLine();
}","public void test182182() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    strBuilder0.appendNull();
    Object object0 = new Object();
    strBuilder0.appendFixedWidthPadRight(object0, 528, 'Z');
    StrBuilder strBuilder1 = strBuilder0.clear();
    strBuilder1.asReader();
    char[] charArray0 = new char[8];
    charArray0[0] = 'Z';
    charArray0[1] = 'Z';
    charArray0[2] = 'c';
    charArray0[3] = 'Z';
    charArray0[4] = 'V';
    charArray0[5] = 'R';
    charArray0[6] = 'Z';
    charArray0[7] = 'Z';
    StrBuilder strBuilder2 = strBuilder1.append(charArray0);
    strBuilder2.appendln(0.0);
    strBuilder1.appendln((char[]) null);
}","/**
 * Appends a char array followed by a new line to the string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param chars  the char array to append
 * @return this, to enable chaining
 * @since 2.3
 */"
"public StrBuilder append(StringBuffer str, int startIndex, int length) {
    if (str == null) {
        return appendNull();
    }
    if (startIndex < 0 || startIndex > str.length()) {
        throw new StringIndexOutOfBoundsException(""startIndex must be valid"");
    }
    if (length < 0 || (startIndex + length) > str.length()) {
        throw new StringIndexOutOfBoundsException(""length must be valid"");
    }
    if (length > 0) {
        int len = length();
        ensureCapacity(len + length);
        str.getChars(startIndex, startIndex + length, buffer, len);
        size += length;
    }
    return this;
}","public void test183183() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    int int0 = 4035;
    strBuilder0.ensureCapacity(4035);
    int int1 = 0;
    strBuilder0.rightString(0);
    StrBuilder strBuilder1 = strBuilder0.insert(0, false);
    StrBuilder.StrBuilderWriter strBuilder_StrBuilderWriter0 = strBuilder1.new StrBuilderWriter();
    String string0 = """";
    strBuilder_StrBuilderWriter0.write(4035);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) """");
    int int2 = (-1);
    // Undeclared exception!
    try {
        strBuilder1.append(stringBuffer0, 1020, (-1));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // startIndex must be valid
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends part of a string buffer to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 */"
"//-----------------------------------------------------------------------
/**
 * Appends an object to the builder padding on the left to a fixed width.
 * The <code>toString</code> of the object is used.
 * If the object is larger than the length, the left hand side is lost.
 * If the object is null, the null text value is used.
 *
 * @param obj  the object to append, null uses null text
 * @param width  the fixed field width, zero or negative has no effect
 * @param padChar  the pad character to use
 * @return this, to enable chaining
 */
public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {
    if (width > 0) {
        ensureCapacity(size + width);
        String str = (obj == null ? getNullText() : obj.toString());
        int strLen = str.length();
        if (strLen >= width) {
            str.getChars(strLen - width, strLen, buffer, size);
        } else {
            int padLen = width - strLen;
            for (int i = 0; i < padLen; i++) {
                buffer[size + i] = padChar;
            }
            str.getChars(0, strLen, buffer, size + padLen);
        }
        size += width;
    }
    return this;
}","public void test184184() throws Throwable {
    int int0 = 0;
    StrBuilder strBuilder0 = new StrBuilder(0);
    String string0 = null;
    int int1 = (-1);
    char char0 = '^';
    // Undeclared exception!
    try {
        strBuilder0.appendFixedWidthPadLeft((Object) null, 57, '^');
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}",""
"public StrBuilder append(String str, int startIndex, int length) {
    if (str == null) {
        return appendNull();
    }
    if (startIndex < 0 || startIndex > str.length()) {
        throw new StringIndexOutOfBoundsException(""startIndex must be valid"");
    }
    if (length < 0 || (startIndex + length) > str.length()) {
        throw new StringIndexOutOfBoundsException(""length must be valid"");
    }
    if (length > 0) {
        int len = length();
        ensureCapacity(len + length);
        str.getChars(startIndex, startIndex + length, buffer, len);
        size += length;
    }
    return this;
}","public void test185185() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    StrBuilder strBuilder1 = new StrBuilder();
    StrBuilder strBuilder2 = strBuilder0.appendWithSeparators((Collection) null, ""5RIgD:9X"");
    strBuilder2.size = (-416);
    strBuilder0.appendFixedWidthPadRight((Object) strBuilder1, (-416), '[');
    // Undeclared exception!
    try {
        strBuilder0.append("""", (-2537), 0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // startIndex must be valid
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends part of a string to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 */"
"public StrBuilder setLength(int length) {
    if (length < 0) {
        throw new StringIndexOutOfBoundsException(length);
    }
    if (length < size) {
        size = length;
    } else if (length > size) {
        ensureCapacity(length);
        int oldEnd = size;
        int newEnd = length;
        size = length;
        for (int i = oldEnd; i < newEnd; i++) {
            buffer[i] = '\0';
        }
    }
    return this;
}","public void test186186() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    String string0 = ""M.1yKs5~eH|q"";
    StrBuilder strBuilder1 = strBuilder0.appendWithSeparators((Collection) null, ""M.1yKs5~eH|q"");
    int int0 = (-2377);
    // Undeclared exception!
    try {
        strBuilder1.setLength((-2377));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -2377
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Updates the length of the builder by either dropping the last characters
 * or adding filler of unicode zero.
 *
 * @param length  the length to set to, must be zero or positive
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the length is negative
 */"
"//-----------------------------------------------------------------------
/**
 * Extracts a portion of this string builder as a string.
 *
 * @param start  the start index, inclusive, must be valid
 * @return the new string
 * @throws IndexOutOfBoundsException if the index is invalid
 */
public String substring(int start) {
    return substring(start, size);
}","public void test187187() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""w\\.1hrMj"");
    char[] charArray0 = strBuilder0.toCharArray();
    LinkedList<String> linkedList0 = new LinkedList<String>();
    strBuilder0.appendAll((Collection) linkedList0);
    StrMatcher strMatcher0 = StrMatcher.doubleQuoteMatcher();
    strMatcher0.isMatch(charArray0, 2, 2, 2);
    strBuilder0.contains(strMatcher0);
    char char0 = 'J';
    int int0 = 5;
    int int1 = 102;
    // Undeclared exception!
    try {
        strBuilder0.substring(102);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // end < start
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}",""
"protected void validateIndex(int index) {
    if (index < 0 || index > size) {
        throw new StringIndexOutOfBoundsException(index);
    }
}","public void test188188() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    int int0 = 1;
    StrBuilder strBuilder1 = strBuilder0.append(1);
    strBuilder0.asTokenizer();
    StrMatcher strMatcher0 = StrMatcher.stringMatcher(""Invalid startIndex: "");
    strBuilder1.replaceFirst(strMatcher0, ""7r8~8}D`LMEEc`"");
    strBuilder0.rightString(1);
    // Undeclared exception!
    try {
        strBuilder1.validateIndex(775);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 775
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Validates parameters defining a single index in the builder.
 *
 * @param index  the index, must be valid
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder insert(int index, long value) {
    return insert(index, String.valueOf(value));
}","public void test189189() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    char char0 = 'z';
    char char1 = ':';
    strBuilder0.replaceFirst('z', ':');
    StrBuilder strBuilder1 = new StrBuilder("""");
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder1.new StrBuilderTokenizer();
    StrMatcher strMatcher0 = strBuilder_StrBuilderTokenizer0.getQuoteMatcher();
    strBuilder1.append('z');
    strBuilder0.deleteFirst(strMatcher0);
    strBuilder0.toString();
    int int0 = (-1898);
    // Undeclared exception!
    try {
        strBuilder0.insert((-1898), (-3505L));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -1898
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts the value into this builder.
 *
 * @param index  the index to add at, must be valid
 * @param value  the value to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Deletes the string wherever it occurs in the builder.
 *
 * @param str  the string to delete, null causes no action
 * @return this, to enable chaining
 */
public StrBuilder deleteAll(String str) {
    int len = (str == null ? 0 : str.length());
    if (len > 0) {
        int index = indexOf(str, 0);
        while (index >= 0) {
            deleteImpl(index, index + len, len);
            index = indexOf(str, index);
        }
    }
    return this;
}","public void test191191() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(0);
    StrBuilder strBuilder1 = new StrBuilder((String) null);
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder1.new StrBuilderTokenizer();
    Object object0 = strBuilder_StrBuilderTokenizer0.clone();
    strBuilder0.insert(0, """");
    strBuilder_StrBuilderTokenizer0.toString();
    StrBuilder strBuilder2 = strBuilder0.appendln(object0);
    StrBuilder strBuilder3 = strBuilder2.appendln(0.0F);
    StrBuilder strBuilder4 = strBuilder3.appendFixedWidthPadLeft(0, 0, '\\');
    strBuilder4.asTokenizer();
    strBuilder3.deleteAll(""36"");
}",""
"public StrBuilder insert(int index, int value) {
    return insert(index, String.valueOf(value));
}","public void test192192() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    char[] charArray0 = new char[5];
    charArray0[0] = 'D';
    charArray0[1] = 'z';
    charArray0[2] = 'w';
    charArray0[3] = 'w';
    charArray0[4] = '0';
    StrBuilder strBuilder1 = strBuilder0.append(charArray0, 0, 0);
    LinkedList<StrBuilder> linkedList0 = new LinkedList<StrBuilder>();
    StrBuilder strBuilder2 = strBuilder1.appendWithSeparators((Collection) linkedList0, ""2BW?qhEvAf^M"");
    strBuilder1.buffer = charArray0;
    StrMatcher strMatcher0 = StrMatcher.singleQuoteMatcher();
    StrBuilder strBuilder3 = strBuilder1.replaceAll(strMatcher0, ""53r^xfe!*`l@X17Z[."");
    StrBuilder strBuilder4 = strBuilder1.appendSeparator(""6EcMg"", 0);
    strBuilder3.deleteFirst('V');
    strBuilder1.getChars(charArray0);
    StrBuilder strBuilder5 = strBuilder1.insert(0, ""(b&`n\""K&gHsATfMT<"");
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder4.new StrBuilderTokenizer();
    strBuilder_StrBuilderTokenizer0.setIgnoredChar('w');
    StrMatcher strMatcher1 = strBuilder_StrBuilderTokenizer0.getDelimiterMatcher();
    StrBuilder strBuilder6 = strBuilder2.deleteFirst(strMatcher1);
    strBuilder6.lastIndexOf(strMatcher1);
    strBuilder2.appendFixedWidthPadRight(1, (-2479), 'J');
    // Undeclared exception!
    try {
        strBuilder5.insert((-2479), (-215));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -2479
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts the value into this builder.
 *
 * @param index  the index to add at, must be valid
 * @param value  the value to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder append(StringBuffer str, int startIndex, int length) {
    if (str == null) {
        return appendNull();
    }
    if (startIndex < 0 || startIndex > str.length()) {
        throw new StringIndexOutOfBoundsException(""startIndex must be valid"");
    }
    if (length < 0 || (startIndex + length) > str.length()) {
        throw new StringIndexOutOfBoundsException(""length must be valid"");
    }
    if (length > 0) {
        int len = length();
        ensureCapacity(len + length);
        str.getChars(startIndex, startIndex + length, buffer, len);
        size += length;
    }
    return this;
}","public void test193193() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    int int0 = 117;
    StringBuffer stringBuffer0 = new StringBuffer();
    // Undeclared exception!
    try {
        strBuilder0.append(stringBuffer0, (-979), 117);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // startIndex must be valid
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends part of a string buffer to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 */"
"public StrBuilder append(String str, int startIndex, int length) {
    if (str == null) {
        return appendNull();
    }
    if (startIndex < 0 || startIndex > str.length()) {
        throw new StringIndexOutOfBoundsException(""startIndex must be valid"");
    }
    if (length < 0 || (startIndex + length) > str.length()) {
        throw new StringIndexOutOfBoundsException(""length must be valid"");
    }
    if (length > 0) {
        int len = length();
        ensureCapacity(len + length);
        str.getChars(startIndex, startIndex + length, buffer, len);
        size += length;
    }
    return this;
}","public void test195195() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder("":`?w`vm_:"");
    char[] charArray0 = new char[3];
    strBuilder0.append('`');
    charArray0[0] = '>';
    charArray0[1] = 'i';
    charArray0[2] = '6';
    StrBuilder strBuilder1 = strBuilder0.insert(3, charArray0);
    LinkedList<StrBuilder> linkedList0 = new LinkedList<StrBuilder>();
    strBuilder1.setNewLineText("""");
    StrBuilder strBuilder2 = strBuilder0.appendWithSeparators((Collection) linkedList0, "":`?w`vm_:"");
    strBuilder1.equals((Object) strBuilder2);
    strBuilder1.appendNull();
    StrBuilder strBuilder3 = strBuilder0.appendln('<');
    // Undeclared exception!
    try {
        strBuilder3.append("""", 3, 3);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // startIndex must be valid
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends part of a string to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 */"
"public StrBuilder insert(int index, char[] chars, int offset, int length) {
    validateIndex(index);
    if (chars == null) {
        return insert(index, nullText);
    }
    if (offset < 0 || offset > chars.length) {
        throw new StringIndexOutOfBoundsException(""Invalid offset: "" + offset);
    }
    if (length < 0 || offset + length > chars.length) {
        throw new StringIndexOutOfBoundsException(""Invalid length: "" + length);
    }
    if (length > 0) {
        ensureCapacity(size + length);
        System.arraycopy(buffer, index, buffer, index + length, size - index);
        System.arraycopy(chars, offset, buffer, index, length);
        size += length;
    }
    return this;
}","public void test196196() throws Throwable {
    int int0 = (-1);
    StrBuilder strBuilder0 = new StrBuilder((-1));
    char[] charArray0 = new char[0];
    strBuilder0.appendln(charArray0);
    StrBuilder strBuilder1 = new StrBuilder((-1));
    StrBuilder strBuilder2 = strBuilder1.append((-1273));
    int int1 = 0;
    StrBuilder strBuilder3 = strBuilder2.appendln(strBuilder1, 0, 5);
    // Undeclared exception!
    try {
        strBuilder3.insert(0, charArray0, 32, 427);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // Invalid offset: 32
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts part of the character array into this builder.
 * Inserting null will use the stored null text value.
 *
 * @param index  the index to add at, must be valid
 * @param chars  the char array to insert
 * @param offset  the offset into the character array to start at, must be valid
 * @param length  the length of the character array part to copy, must be positive
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if any index is invalid
 */"
"public StrBuilder appendln(StringBuffer str, int startIndex, int length) {
    return append(str, startIndex, length).appendNewLine();
}","public void test197197() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""j5\"""");
    strBuilder0.appendSeparator(""j5\"""", 0);
    String string0 = """";
    strBuilder0.replaceFirst(""j5\"""", """");
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    StringBuffer stringBuffer0 = new StringBuffer();
    // Undeclared exception!
    try {
        strBuilder0.appendln(stringBuffer0, (-1808), (-970));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // startIndex must be valid
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends part of a string buffer followed by a new line to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 * @since 2.3
 */"
"public StrBuilder appendln(String str, int startIndex, int length) {
    return append(str, startIndex, length).appendNewLine();
}","public void test198198() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""Invalid startIndex: "");
    Object[] objectArray0 = new Object[7];
    objectArray0[0] = (Object) strBuilder0;
    objectArray0[1] = (Object) strBuilder0;
    objectArray0[2] = (Object) strBuilder0;
    objectArray0[3] = (Object) strBuilder0;
    objectArray0[4] = (Object) strBuilder0;
    objectArray0[5] = (Object) strBuilder0;
    objectArray0[6] = (Object) ""Invalid startIndex: "";
    strBuilder0.appendAll(objectArray0);
    strBuilder0.appendSeparator(""end < start"");
    strBuilder0.asReader();
    char[] charArray0 = new char[0];
    StrBuilder strBuilder1 = strBuilder0.appendln(charArray0);
    strBuilder1.rightString(102);
    int int0 = 3575;
    // Undeclared exception!
    try {
        strBuilder1.appendln(""FI7z-;T#"", 102, 3575);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // startIndex must be valid
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends part of a string followed by a new line to this string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param str  the string to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 * @since 2.3
 */"
"public void getChars(int startIndex, int endIndex, char[] destination, int destinationIndex) {
    if (startIndex < 0) {
        throw new StringIndexOutOfBoundsException(startIndex);
    }
    if (endIndex < 0 || endIndex > length()) {
        throw new StringIndexOutOfBoundsException(endIndex);
    }
    if (startIndex > endIndex) {
        throw new StringIndexOutOfBoundsException(""end < start"");
    }
    System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);
}","public void test199199() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder("""");
    StrMatcher.quoteMatcher();
    strBuilder0.asWriter();
    StrBuilder strBuilder1 = strBuilder0.setNewLineText("""");
    strBuilder1.appendSeparator('D', 0);
    StrBuilder strBuilder2 = strBuilder0.appendln(""F0IK=S#GdY't,ON/Af1"");
    char[] charArray0 = new char[6];
    charArray0[3] = '<';
    // Undeclared exception!
    try {
        strBuilder2.getChars(39, 39, charArray0, 0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 39
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Copies the character array into the specified array.
 *
 * @param startIndex  first index to copy, inclusive, must be valid
 * @param endIndex  last index, exclusive, must be valid
 * @param destination  the destination array, must not be null or too small
 * @param destinationIndex  the index to start copying in destination
 * @throws NullPointerException if the array is null
 * @throws IndexOutOfBoundsException if any index is invalid
 */"
"public void getChars(int startIndex, int endIndex, char[] destination, int destinationIndex) {
    if (startIndex < 0) {
        throw new StringIndexOutOfBoundsException(startIndex);
    }
    if (endIndex < 0 || endIndex > length()) {
        throw new StringIndexOutOfBoundsException(endIndex);
    }
    if (startIndex > endIndex) {
        throw new StringIndexOutOfBoundsException(""end < start"");
    }
    System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);
}","public void test200200() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder("""");
    StrBuilder strBuilder1 = strBuilder0.appendln('\'');
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""E*}Ew5RVb26|aZ"");
    strBuilder0.append(stringBuffer0, 0, 0);
    StrBuilder strBuilder2 = strBuilder1.appendln(""E*}Ew5RVb26|aZ"");
    StrMatcher strMatcher0 = StrMatcher.quoteMatcher();
    strBuilder2.indexOf(strMatcher0, 0);
    strBuilder0.asWriter();
    StrBuilder strBuilder3 = strBuilder0.setNewLineText("""");
    strBuilder3.appendSeparator('D', 0);
    StrBuilder strBuilder4 = strBuilder0.appendln(""F0IK=S#GdY't,ON/Af1"");
    char[] charArray0 = new char[6];
    charArray0[0] = '\'';
    charArray0[1] = '\'';
    charArray0[2] = '\'';
    charArray0[3] = '<';
    charArray0[4] = '\'';
    charArray0[5] = '\'';
    // Undeclared exception!
    try {
        strBuilder4.getChars((int) '\'', (int) '\'', charArray0, 0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 39
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Copies the character array into the specified array.
 *
 * @param startIndex  first index to copy, inclusive, must be valid
 * @param endIndex  last index, exclusive, must be valid
 * @param destination  the destination array, must not be null or too small
 * @param destinationIndex  the index to start copying in destination
 * @throws NullPointerException if the array is null
 * @throws IndexOutOfBoundsException if any index is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * Deletes the string wherever it occurs in the builder.
 *
 * @param str  the string to delete, null causes no action
 * @return this, to enable chaining
 */
public StrBuilder deleteAll(String str) {
    int len = (str == null ? 0 : str.length());
    if (len > 0) {
        int index = indexOf(str, 0);
        while (index >= 0) {
            deleteImpl(index, index + len, len);
            index = indexOf(str, index);
        }
    }
    return this;
}","public void test201201() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""java.endorsed.dirs"");
    StrMatcher.NoMatcher strMatcher_NoMatcher0 = new StrMatcher.NoMatcher();
    StrBuilder strBuilder1 = strBuilder0.append((Object) strMatcher_NoMatcher0);
    strBuilder1.setLength(1330);
    strBuilder0.contains((StrMatcher) strMatcher_NoMatcher0);
    strBuilder0.deleteAll(""java.endorsed.dirs"");
}",""
"public StrBuilder append(char[] chars) {
    if (chars == null) {
        return appendNull();
    }
    int strLen = chars.length;
    if (strLen > 0) {
        int len = length();
        ensureCapacity(len + strLen);
        System.arraycopy(chars, 0, buffer, len, strLen);
        size += strLen;
    }
    return this;
}","public void test202202() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    char[] charArray0 = new char[6];
    charArray0[0] = 'j';
    StrMatcher strMatcher0 = StrMatcher.stringMatcher(""%Gj;mWhsgtSZ%"");
    strBuilder0.lastIndexOf(strMatcher0, 107);
    charArray0[1] = '3';
    charArray0[2] = 'Q';
    charArray0[3] = 'k';
    charArray0[4] = '/';
    charArray0[5] = '[';
    strBuilder0.append(charArray0);
}","/**
 * Appends a char array to the string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param chars  the char array to append
 * @return this, to enable chaining
 */"
"public StrBuilder insert(int index, boolean value) {
    validateIndex(index);
    if (value) {
        ensureCapacity(size + 4);
        System.arraycopy(buffer, index, buffer, index + 4, size - index);
        buffer[index++] = 't';
        buffer[index++] = 'r';
        buffer[index++] = 'u';
        buffer[index] = 'e';
        size += 4;
    } else {
        ensureCapacity(size + 5);
        System.arraycopy(buffer, index, buffer, index + 5, size - index);
        buffer[index++] = 'f';
        buffer[index++] = 'a';
        buffer[index++] = 'l';
        buffer[index++] = 's';
        buffer[index] = 'e';
        size += 5;
    }
    return this;
}","public void test203203() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    Object object0 = new Object();
    StrBuilder strBuilder1 = strBuilder0.appendln(object0);
    StrMatcher strMatcher0 = StrMatcher.trimMatcher();
    StrMatcher strMatcher1 = StrMatcher.quoteMatcher();
    char[] charArray0 = new char[1];
    charArray0[0] = '0';
    StrMatcher.charSetMatcher(charArray0);
    strBuilder0.appendNull();
    strBuilder1.lastIndexOf(strMatcher1);
    StrBuilder strBuilder2 = strBuilder1.replaceFirst(strMatcher0, """");
    strBuilder0.getNewLineText();
    strBuilder0.appendSeparator((String) null, 31);
    strBuilder1.equals(strBuilder2);
    // Undeclared exception!
    try {
        strBuilder1.insert((-1), true);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -1
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts the value into this builder.
 *
 * @param index  the index to add at, must be valid
 * @param value  the value to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder insert(int index, int value) {
    return insert(index, String.valueOf(value));
}","public void test204204() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder("""");
    StrBuilder strBuilder1 = strBuilder0.appendln((-731.6734F));
    StrBuilder strBuilder2 = strBuilder1.appendNull();
    StrMatcher strMatcher0 = StrMatcher.noneMatcher();
    StrBuilder strBuilder3 = strBuilder2.deleteAll(strMatcher0);
    StrBuilder strBuilder4 = strBuilder2.appendNull();
    strBuilder3.replaceAll(strMatcher0, ""end < start"");
    char[] charArray0 = new char[7];
    charArray0[0] = 'h';
    strBuilder1.lastIndexOf((StrMatcher) null, 22);
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder4.new StrBuilderTokenizer();
    strBuilder2.appendAll((Iterator) strBuilder_StrBuilderTokenizer0);
    StrMatcher.charSetMatcher(charArray0);
    charArray0[1] = 't';
    charArray0[2] = '/';
    charArray0[3] = 'X';
    charArray0[4] = 'f';
    charArray0[5] = 'A';
    charArray0[6] = '|';
    StrBuilder strBuilder5 = strBuilder3.append((Object) strBuilder1);
    strBuilder5.appendln('(');
    // Undeclared exception!
    try {
        strBuilder0.insert((-3058), 1009);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -3058
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts the value into this builder.
 *
 * @param index  the index to add at, must be valid
 * @param value  the value to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder deleteCharAt(int index) {
    if (index < 0 || index >= size) {
        throw new StringIndexOutOfBoundsException(index);
    }
    deleteImpl(index, index + 1, 1);
    return this;
}","public void test205205() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    int int0 = (-1277);
    char char0 = ']';
    strBuilder0.midString((-1120), (-1120));
    // Undeclared exception!
    try {
        strBuilder0.deleteCharAt(0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 0
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Deletes the character at the specified index.
 *
 * @see #charAt(int)
 * @see #setCharAt(int, char)
 * @param index  the index to delete
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public StrBuilder insert(int index, String str) {
    validateIndex(index);
    if (str == null) {
        str = nullText;
    }
    int strLen = (str == null ? 0 : str.length());
    if (strLen > 0) {
        int newSize = size + strLen;
        ensureCapacity(newSize);
        System.arraycopy(buffer, index, buffer, index + strLen, size - index);
        size = newSize;
        str.getChars(0, strLen, buffer, index);
    }
    return this;
}","public void test206206() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder("""");
    strBuilder0.lastIndexOf("""");
    // Undeclared exception!
    try {
        strBuilder0.insert((-1), ""1Q?s;RZ]m."");
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -1
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts the string into this builder.
 * Inserting null will use the stored null text value.
 *
 * @param index  the index to add at, must be valid
 * @param str  the string to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
"public int lastIndexOf(String str) {
    return lastIndexOf(str, size - 1);
}","public void test207207() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(0);
    StrBuilder strBuilder1 = strBuilder0.insert(0, true);
    StrBuilder strBuilder2 = strBuilder1.appendln(strBuilder0);
    StrMatcher.NoMatcher strMatcher_NoMatcher0 = new StrMatcher.NoMatcher();
    strBuilder0.lastIndexOf((StrMatcher) strMatcher_NoMatcher0, 0);
    StrBuilder strBuilder3 = strBuilder0.setLength(1959);
    strBuilder0.contains((StrMatcher) null);
    StrTokenizer strTokenizer0 = strBuilder0.asTokenizer();
    strBuilder0.endsWith("""");
    StrBuilder strBuilder4 = strBuilder0.appendln((double) 0);
    strBuilder2.equalsIgnoreCase(strBuilder4);
    strBuilder4.substring(0);
    StrBuilder strBuilder5 = strBuilder0.appendAll((Iterator) strTokenizer0);
    strBuilder5.midString(1, 1);
    strBuilder5.asReader();
    strBuilder5.toString();
    String string0 = strBuilder0.midString(114, 2859);
    strBuilder2.indexOf((StrMatcher) strMatcher_NoMatcher0);
    int int0 = 989;
    strBuilder3.insert(989, true);
    StrBuilder strBuilder6 = strBuilder4.deleteCharAt(114);
    StrBuilder strBuilder7 = strBuilder6.appendln((-1848));
    // Undeclared exception!
    strBuilder7.lastIndexOf(string0);
}","/**
 * Searches the string builder to find the last reference to the specified string.
 * <p>
 * Note that a null input string will return -1, whereas the JDK throws an exception.
 *
 * @param str  the string to find, null returns -1
 * @return the last index of the string, or -1 if not found
 */"
"public StrBuilder insert(int index, char[] chars, int offset, int length) {
    validateIndex(index);
    if (chars == null) {
        return insert(index, nullText);
    }
    if (offset < 0 || offset > chars.length) {
        throw new StringIndexOutOfBoundsException(""Invalid offset: "" + offset);
    }
    if (length < 0 || offset + length > chars.length) {
        throw new StringIndexOutOfBoundsException(""Invalid length: "" + length);
    }
    if (length > 0) {
        ensureCapacity(size + length);
        System.arraycopy(buffer, index, buffer, index + length, size - index);
        System.arraycopy(chars, offset, buffer, index, length);
        size += length;
    }
    return this;
}","public void test208208() throws Throwable {
    String string0 = ""NAUa0Jo/(HK*3"";
    StrBuilder strBuilder0 = new StrBuilder(""NAUa0Jo/(HK*3"");
    strBuilder0.endsWith(""NAUa0Jo/(HK*3"");
    int int0 = 1218;
    StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadLeft(1218, 1218, 'g');
    StrBuilder strBuilder2 = new StrBuilder();
    strBuilder2.clear();
    strBuilder2.deleteAll((StrMatcher) null);
    strBuilder2.midString((-215), 272);
    strBuilder0.replaceFirst((StrMatcher) null, ""NAUa0Jo/(HK*3"");
    StrBuilder strBuilder3 = strBuilder1.reverse();
    strBuilder0.minimizeCapacity();
    StrBuilder strBuilder4 = new StrBuilder();
    strBuilder4.indexOf((String) null, 2089);
    strBuilder3.isEmpty();
    strBuilder3.appendPadding((-683), 'g');
    StrBuilder strBuilder5 = strBuilder2.append(strBuilder4);
    char[] charArray0 = new char[1];
    charArray0[0] = 'g';
    // Undeclared exception!
    try {
        strBuilder5.insert(32, charArray0, 1218, 272);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: 32
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts part of the character array into this builder.
 * Inserting null will use the stored null text value.
 *
 * @param index  the index to add at, must be valid
 * @param chars  the char array to insert
 * @param offset  the offset into the character array to start at, must be valid
 * @param length  the length of the character array part to copy, must be positive
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if any index is invalid
 */"
"public int lastIndexOf(String str) {
    return lastIndexOf(str, size - 1);
}","public void test209209() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""A#"");
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder0.new StrBuilderTokenizer();
    strBuilder0.appendWithSeparators((Iterator) strBuilder_StrBuilderTokenizer0, ""A#"");
    strBuilder0.rightString((-1832));
    strBuilder0.equals((Object) ""A#"");
    strBuilder0.lastIndexOf((String) null);
}","/**
 * Searches the string builder to find the last reference to the specified string.
 * <p>
 * Note that a null input string will return -1, whereas the JDK throws an exception.
 *
 * @param str  the string to find, null returns -1
 * @return the last index of the string, or -1 if not found
 */"
"public int lastIndexOf(String str, int startIndex) {
    startIndex = (startIndex >= size ? size - 1 : startIndex);
    if (str == null || startIndex < 0) {
        return -1;
    }
    int strLen = str.length();
    if (strLen > 0 && strLen <= size) {
        if (strLen == 1) {
            return lastIndexOf(str.charAt(0), startIndex);
        }
        outer: for (int i = startIndex - strLen + 1; i >= 0; i--) {
            for (int j = 0; j < strLen; j++) {
                if (str.charAt(j) != buffer[i + j]) {
                    continue outer;
                }
            }
            return i;
        }
    } else if (strLen == 0) {
        return startIndex;
    }
    return -1;
}","public void test210210() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder((-552));
    StrBuilder.StrBuilderReader strBuilder_StrBuilderReader0 = strBuilder0.new StrBuilderReader();
    strBuilder_StrBuilderReader0.mark((-552));
    StrBuilder.StrBuilderWriter strBuilder_StrBuilderWriter0 = strBuilder0.new StrBuilderWriter();
    char[] charArray0 = new char[8];
    charArray0[0] = 'f';
    charArray0[1] = 'f';
    charArray0[2] = '{';
    charArray0[3] = 'L';
    charArray0[4] = 'O';
    charArray0[5] = '[';
    charArray0[6] = '+';
    charArray0[7] = 'G';
    strBuilder_StrBuilderWriter0.write(charArray0);
    strBuilder_StrBuilderWriter0.write(4);
    strBuilder_StrBuilderWriter0.flush();
    StrBuilder strBuilder1 = strBuilder0.deleteAll('N');
    strBuilder_StrBuilderReader0.close();
    strBuilder1.replaceAll((String) null, ""!E|@^;:4aA79"");
    strBuilder1.insert(0, ""!E|@^;:4aA79"");
    strBuilder1.lastIndexOf((String) null, 101);
}","/**
 * Searches the string builder to find the last reference to the specified
 * string starting searching from the given index.
 * <p>
 * Note that a null input string will return -1, whereas the JDK throws an exception.
 *
 * @param str  the string to find, null returns -1
 * @param startIndex  the index to start at, invalid index rounded to edge
 * @return the last index of the string, or -1 if not found
 */"
"public StrBuilder appendln(char[] chars, int startIndex, int length) {
    return append(chars, startIndex, length).appendNewLine();
}","public void test211211() throws Throwable {
    String string0 = """";
    StrBuilder strBuilder0 = new StrBuilder("""");
    char char0 = '\'';
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""E*}Ew5RVb26|aZ"");
    int int0 = 0;
    stringBuffer0.append(0);
    strBuilder0.append(stringBuffer0, 0, 0);
    StrBuilder strBuilder1 = strBuilder0.appendln(""E*}Ew5RVb26|aZ"");
    StrMatcher.quoteMatcher();
    char[] charArray0 = new char[7];
    charArray0[0] = '\'';
    charArray0[1] = '\'';
    charArray0[2] = '\'';
    charArray0[3] = '\'';
    charArray0[4] = 'D';
    charArray0[5] = '\'';
    charArray0[6] = '\'';
    // Undeclared exception!
    try {
        strBuilder1.appendln(charArray0, 0, 48);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // Invalid length: 48
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Appends a char array followed by a new line to the string builder.
 * Appending null will call {@link #appendNull()}.
 *
 * @param chars  the char array to append
 * @param startIndex  the start index, inclusive, must be valid
 * @param length  the length to append, must be valid
 * @return this, to enable chaining
 * @since 2.3
 */"
"public boolean contains(String str) {
    return indexOf(str, 0) >= 0;
}","public void test212212() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder(""*{O3bitJLa_# R:2p*"");
    char[] charArray0 = new char[0];
    strBuilder0.append(charArray0);
    strBuilder0.contains(""79m\\M&(8r"");
}","/**
 * Checks if the string builder contains the specified string.
 *
 * @param str  the string to find
 * @return true if the builder contains the string
 */"
"public void getChars(int startIndex, int endIndex, char[] destination, int destinationIndex) {
    if (startIndex < 0) {
        throw new StringIndexOutOfBoundsException(startIndex);
    }
    if (endIndex < 0 || endIndex > length()) {
        throw new StringIndexOutOfBoundsException(endIndex);
    }
    if (startIndex > endIndex) {
        throw new StringIndexOutOfBoundsException(""end < start"");
    }
    System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);
}","public void test213213() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder("""");
    StrBuilder strBuilder1 = strBuilder0.appendFixedWidthPadRight(48, 0, 'q');
    StrMatcher strMatcher0 = StrMatcher.quoteMatcher();
    strBuilder0.indexOf(strMatcher0, 0);
    StrBuilder strBuilder2 = strBuilder1.minimizeCapacity();
    strBuilder0.deleteFirst("""");
    strBuilder2.setNullText(""4.9"");
    char[] charArray0 = new char[6];
    charArray0[0] = 'q';
    charArray0[1] = 'q';
    charArray0[2] = 'q';
    charArray0[3] = 'q';
    charArray0[4] = 'q';
    charArray0[5] = 'q';
    // Undeclared exception!
    try {
        strBuilder1.getChars(9, 0, charArray0, (-3896));
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // end < start
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Copies the character array into the specified array.
 *
 * @param startIndex  first index to copy, inclusive, must be valid
 * @param endIndex  last index, exclusive, must be valid
 * @param destination  the destination array, must not be null or too small
 * @param destinationIndex  the index to start copying in destination
 * @throws NullPointerException if the array is null
 * @throws IndexOutOfBoundsException if any index is invalid
 */"
"public int lastIndexOf(StrMatcher matcher, int startIndex) {
    startIndex = (startIndex >= size ? size - 1 : startIndex);
    if (matcher == null || startIndex < 0) {
        return -1;
    }
    char[] buf = buffer;
    int endIndex = startIndex + 1;
    for (int i = startIndex; i >= 0; i--) {
        if (matcher.isMatch(buf, i, 0, endIndex) > 0) {
            return i;
        }
    }
    return -1;
}","public void test214214() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder("">7fjPzegH2xU&=:qkX"");
    StrBuilder strBuilder1 = new StrBuilder("">7fjPzegH2xU&=:qkX"");
    strBuilder0.appendln(strBuilder1, 4, 4);
    Object[] objectArray0 = new Object[10];
    objectArray0[0] = (Object) strBuilder0;
    objectArray0[4] = (Object) strBuilder0;
    objectArray0[6] = (Object) "">7fjPzegH2xU&=:qkX"";
    strBuilder0.asReader();
    char[] charArray0 = new char[0];
    StrBuilder strBuilder2 = strBuilder0.appendln(charArray0);
    StringBuffer stringBuffer0 = new StringBuffer();
    strBuilder0.appendln(stringBuffer0);
    StrBuilder.StrBuilderTokenizer strBuilder_StrBuilderTokenizer0 = strBuilder2.new StrBuilderTokenizer();
    strBuilder_StrBuilderTokenizer0.tokenize(charArray0, 3575, (-1019));
    strBuilder0.clear();
    StrMatcher strMatcher0 = StrMatcher.stringMatcher("">7fjPzegH2xU&=:qkX"");
    strBuilder1.lastIndexOf(strMatcher0, 97);
}","/**
 * Searches the string builder using the matcher to find the last
 * match searching from the given index.
 * <p>
 * Matchers can be used to perform advanced searching behaviour.
 * For example you could write a matcher to find the character 'a'
 * followed by a number.
 *
 * @param matcher  the matcher to use, null returns -1
 * @param startIndex  the index to start at, invalid index rounded to edge
 * @return the last index matched, or -1 if not found
 */"
"public StrBuilder insert(int index, boolean value) {
    validateIndex(index);
    if (value) {
        ensureCapacity(size + 4);
        System.arraycopy(buffer, index, buffer, index + 4, size - index);
        buffer[index++] = 't';
        buffer[index++] = 'r';
        buffer[index++] = 'u';
        buffer[index] = 'e';
        size += 4;
    } else {
        ensureCapacity(size + 5);
        System.arraycopy(buffer, index, buffer, index + 5, size - index);
        buffer[index++] = 'f';
        buffer[index++] = 'a';
        buffer[index++] = 'l';
        buffer[index++] = 's';
        buffer[index] = 'e';
        size += 5;
    }
    return this;
}","public void test215215() throws Throwable {
    StrBuilder strBuilder0 = new StrBuilder();
    Object object0 = new Object();
    StrBuilder strBuilder1 = strBuilder0.appendln(object0);
    StrMatcher.TrimMatcher strMatcher_TrimMatcher0 = new StrMatcher.TrimMatcher();
    StrMatcher strMatcher0 = StrMatcher.quoteMatcher();
    char[] charArray0 = new char[1];
    charArray0[0] = '0';
    StrMatcher.charSetMatcher(charArray0);
    strBuilder0.appendNull();
    strBuilder1.lastIndexOf(strMatcher0);
    StrBuilder strBuilder2 = new StrBuilder("""");
    strBuilder0.getNewLineText();
    strBuilder0.appendSeparator((String) null, 28);
    strBuilder1.equals(strBuilder2);
    // Undeclared exception!
    try {
        strBuilder1.insert((-1), false);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
        //
        // String index out of range: -1
        //
        verifyException(""org.apache.commons.lang.text.StrBuilder"", e);
    }
}","/**
 * Inserts the value into this builder.
 *
 * @param index  the index to add at, must be valid
 * @param value  the value to insert
 * @return this, to enable chaining
 * @throws IndexOutOfBoundsException if the index is invalid
 */"
