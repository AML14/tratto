focal_method,test_prefix,docstring
"public static String capitalize(String str) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    return new StringBuilder(strLen).append(Character.toTitleCase(str.charAt(0))).append(str.substring(1)).toString();
}","public void test0000() throws Throwable {
    StringUtils.isNumeric((CharSequence) null);
    StringUtils.length((CharSequence) null);
    StringUtils.overlay(""S)ne)L/"", ""?P]})Ye)okq3&4cv"", 0, 1);
    StringUtils.indexOf((CharSequence) null, (-3107));
    StringUtils.isEmpty((CharSequence) null);
    StringUtils.abbreviate(""S)ne)L/"", 1, 17);
    StringUtils.stripEnd(""?P]})Ye)okq3&4cv"", ""S)ne)L/"");
    StringUtils.abbreviateMiddle(""ciX?-maH5XWZ("", ""?P]})Ye)okq3&4cv)ne)L/"", (-1));
    StringUtils.indexOf((CharSequence) null, (CharSequence) ""S)ne)L/"");
    StringUtils.overlay(""?P]})Ye)okq3&4cv)ne)L/"", ""?#H:|Iy>mdGE|hhc)"", 17, 469);
    StringUtils.right(""InvocationTargetException occurred"", (-1));
    StringUtils.isNumeric("""");
    StringUtils.defaultIfBlank(""[Q.GLM$"", ""java.text.Normalizer"");
    char[] charArray0 = new char[3];
    charArray0[0] = 'D';
    charArray0[1] = 'W';
    charArray0[2] = ')';
    StringUtils.containsNone((CharSequence) ""?P]})Ye)okq3&4cv"", charArray0);
    StringUtils.substringBefore(""?P]})Ye)okq3&4cv)?#H:|Iy>mdGE|hhc)"", ""?#H:|Iy>mdGE|hhc)"");
    StringUtils.substringBetween(""ciX?-maH5XWZ("", ""Search and Replace array lengths don't match: _w[IYfF9g^Av33Q6"", ""ciX?-maH5XWZ("");
    StringUtils.capitalize(""org.apache.commons.lang3.ObjectUtils$Null"");
}","/**
 * <p>Capitalizes a String changing the first letter to title case as
 * per {@link Character#toTitleCase(char)}. No other letters are changed.</p>
 *
 * <p>For a word based algorithm, see {@link org.apache.commons.lang3.text.WordUtils#capitalize(String)}.
 * A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.capitalize(null)  = null
 * StringUtils.capitalize("""")    = """"
 * StringUtils.capitalize(""cat"") = ""Cat""
 * StringUtils.capitalize(""cAt"") = ""CAt""
 * </pre>
 *
 * @param str the String to capitalize, may be null
 * @return the capitalized String, {@code null} if null String input
 * @see org.apache.commons.lang3.text.WordUtils#capitalize(String)
 * @see #uncapitalize(String)
 * @since 2.0
 */"
"// IndexOfAnyBut chars
//-----------------------------------------------------------------------
/**
 * <p>Searches a CharSequence to find the first index of any
 * character not in the given set of characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A {@code null} or zero length search array will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAnyBut(null, *)                              = -1
 * StringUtils.indexOfAnyBut("""", *)                                = -1
 * StringUtils.indexOfAnyBut(*, null)                              = -1
 * StringUtils.indexOfAnyBut(*, [])                                = -1
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", new char[] {'z', 'a'} ) = 3
 * StringUtils.indexOfAnyBut(""aba"", new char[] {'z'} )             = 0
 * StringUtils.indexOfAnyBut(""aba"", new char[] {'a', 'b'} )        = -1
 *
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAnyBut(String, char[]) to indexOfAnyBut(CharSequence, char...)
 */
public static int indexOfAnyBut(CharSequence cs, char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int csLen = cs.length();
    int csLast = csLen - 1;
    int searchLen = searchChars.length;
    int searchLast = searchLen - 1;
    outer: for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
                    if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        continue outer;
                    }
                } else {
                    continue outer;
                }
            }
        }
        return i;
    }
    return INDEX_NOT_FOUND;
}","public void test0011() throws Throwable {
    StringUtils.join((Iterator<?>) null, 'm');
    char[] charArray0 = new char[2];
    charArray0[0] = 'm';
    charArray0[1] = 'm';
    StringUtils.containsOnly((CharSequence) null, charArray0);
    StringUtils.countMatches((CharSequence) null, (CharSequence) null);
    StringUtils.rightPad((String) null, 0, 'm');
    StringUtils.lastIndexOf((CharSequence) null, (CharSequence) null);
    StringUtils.chomp((String) null, (String) null);
    StringUtils.substringBefore(""ZiUNmoE6BJE(q\""m$"", ""|`?_p[g"");
    char[] charArray1 = new char[5];
    charArray1[0] = 'm';
    charArray1[1] = 'm';
    charArray1[2] = 'm';
    charArray1[3] = 'm';
    charArray1[4] = 'm';
    StringUtils.indexOfAnyBut((CharSequence) null, charArray1);
}",""
"// Overlay
//-----------------------------------------------------------------------
/**
 * <p>Overlays part of a String with another String.</p>
 *
 * <p>A {@code null} string input returns {@code null}.
 * A negative index is treated as zero.
 * An index greater than the string length is treated as the string length.
 * The start index is always the smaller of the two indices.</p>
 *
 * <pre>
 * StringUtils.overlay(null, *, *, *)            = null
 * StringUtils.overlay("""", ""abc"", 0, 0)          = ""abc""
 * StringUtils.overlay(""abcdef"", null, 2, 4)     = ""abef""
 * StringUtils.overlay(""abcdef"", """", 2, 4)       = ""abef""
 * StringUtils.overlay(""abcdef"", """", 4, 2)       = ""abef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 2, 4)   = ""abzzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 4, 2)   = ""abzzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", -1, 4)  = ""zzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 2, 8)   = ""abzzzz""
 * StringUtils.overlay(""abcdef"", ""zzzz"", -2, -3) = ""zzzzabcdef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 8, 10)  = ""abcdefzzzz""
 * </pre>
 *
 * @param str  the String to do overlaying in, may be null
 * @param overlay  the String to overlay, may be null
 * @param start  the position to start overlaying at
 * @param end  the position to stop overlaying before
 * @return overlayed String, {@code null} if null String input
 * @since 2.0
 */
public static String overlay(String str, String overlay, int start, int end) {
    if (str == null) {
        return null;
    }
    if (overlay == null) {
        overlay = EMPTY;
    }
    int len = str.length();
    if (start < 0) {
        start = 0;
    }
    if (start > len) {
        start = len;
    }
    if (end < 0) {
        end = 0;
    }
    if (end > len) {
        end = len;
    }
    if (start > end) {
        int temp = start;
        start = end;
        end = temp;
    }
    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();
}","public void test0022() throws Throwable {
    StringUtils.leftPad(""ciX?-maH5XWZ("", 510, ""ciX?-maH5XWZ("");
    CharSequence[] charSequenceArray0 = new CharSequence[2];
    charSequenceArray0[0] = (CharSequence) ""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("";
    charSequenceArray0[1] = (CharSequence) ""ciX?-maH5XWZ("";
    StringUtils.endsWithAny(""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("", charSequenceArray0);
    String[] stringArray0 = new String[1];
    stringArray0[0] = ""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("";
    String[] stringArray1 = StringUtils.stripAll(stringArray0);
    StringUtils.abbreviate(""ciX?-maH5XWZ("", 13);
    StringUtils.ordinalIndexOf(""ciX?-maH5XWZ("", charSequenceArray0[0], 13);
    StringUtils.lastIndexOfAny(charSequenceArray0[0], stringArray1);
    StringUtils.stripToNull(""ciX?-maH5XWZ("");
    StringUtils.mid(""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("", 13, 510);
    LinkedHashSet<Locale.FilteringMode> linkedHashSet0 = new LinkedHashSet<Locale.FilteringMode>();
    Iterator<Locale.FilteringMode> iterator0 = linkedHashSet0.iterator();
    Locale.FilteringMode locale_FilteringMode0 = Locale.FilteringMode.REJECT_EXTENDED_RANGES;
    linkedHashSet0.add(locale_FilteringMode0);
    StringUtils.join(iterator0, '}');
    StringUtils.rightPad(""ciX?-maH5XWZ("", 0, ""/x&<_x`RJm/x&<_x`RJm"");
    StringUtils.chomp(""xDTm(m'~h1DlVpMUe"", ""ciX?-maH5XWZ("");
    StringUtils.lastIndexOf((CharSequence) ""xDTm(m'~h1DlVpMe"", (CharSequence) ""xDTm(m'~h1DlVpMUe"");
    StringUtils.overlay(""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("", ""Yr|%/Du0&"", 1814, (-1));
}",""
"// Conversion
//-----------------------------------------------------------------------
// Padding
//-----------------------------------------------------------------------
/**
 * <p>Repeat a String {@code repeat} times to form a
 * new String.</p>
 *
 * <pre>
 * StringUtils.repeat(null, 2) = null
 * StringUtils.repeat("""", 0)   = """"
 * StringUtils.repeat("""", 2)   = """"
 * StringUtils.repeat(""a"", 3)  = ""aaa""
 * StringUtils.repeat(""ab"", 2) = ""abab""
 * StringUtils.repeat(""a"", -2) = """"
 * </pre>
 *
 * @param str  the String to repeat, may be null
 * @param repeat  number of times to repeat str, negative treated as zero
 * @return a new String consisting of the original String repeated,
 *  {@code null} if null String input
 */
public static String repeat(String str, int repeat) {
    // Performance tuned for 2.0 (JDK1.4)
    if (str == null) {
        return null;
    }
    if (repeat <= 0) {
        return EMPTY;
    }
    int inputLength = str.length();
    if (repeat == 1 || inputLength == 0) {
        return str;
    }
    if (inputLength == 1 && repeat <= PAD_LIMIT) {
        return repeat(str.charAt(0), repeat);
    }
    int outputLength = inputLength * repeat;
    switch(inputLength) {
        case 1:
            return repeat(str.charAt(0), repeat);
        case 2:
            char ch0 = str.charAt(0);
            char ch1 = str.charAt(1);
            char[] output2 = new char[outputLength];
            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {
                output2[i] = ch0;
                output2[i + 1] = ch1;
            }
            return new String(output2);
        default:
            StringBuilder buf = new StringBuilder(outputLength);
            for (int i = 0; i < repeat; i++) {
                buf.append(str);
            }
            return buf.toString();
    }
}","public void test0033() throws Throwable {
    // Undeclared exception!
    try {
        StringUtils.repeat(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtilsH#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", Integer.MAX_VALUE);
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.lang.AbstractStringBuilder"", e);
    }
}",""
"public static boolean isAlphanumericSpace(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {
            return false;
        }
    }
    return true;
}","public void test0044() throws Throwable {
    StringUtils.replaceChars(""8bEhDCywIDUxL'YBr"", ""8bEhDCywIDUxL'YBr"", ""8bEhDCywIDUxL'YBr"");
    StringUtils.splitPreserveAllTokens("" iI'(B)EZP7J6;JS@o"", ""8bEhDCywIDUxL'YBr"");
    String[] stringArray0 = StringUtils.splitByCharacterTypeCamelCase(""8bEhDCywIDUxL'YBr"");
    StringUtils.stripAll(stringArray0, "")/r2R?"");
    StringUtils.swapCase(""<{'a_Id_QlqU"");
    StringUtils.split("" iI'(B)EZP7J6;JS@o"");
    char[] charArray0 = new char[2];
    charArray0[0] = 'R';
    charArray0[1] = '8';
    StringUtils.equalsIgnoreCase(""8bEhDCywIDUxL'YBr"", ""8bEhDCywIDUxL'YBr"");
    StringUtils.splitPreserveAllTokens(""8bEhDCywIDUxL'YBr"", '8');
    StringUtils.countMatches(""<{'a_Id_QlqU"", "" iI'(B)EZP7J6;JS@o"");
    StringUtils.substring(""<{'A_iD_qLQu"", Integer.MAX_VALUE);
    StringUtils.abbreviate(""8bEhDCywIDUxL'YBr"", 20, 12);
    StringUtils.right(""8bEhDCywIDUxL'YBr"", 10);
    StringUtils.indexOfIgnoreCase((CharSequence) ""<{'A_iD_qLQu"", (CharSequence) ""8bEhDCywIDUxL'YBr"");
    StringUtils.stripToNull("" iI'(B)EZP7J6;JS@o"");
    StringUtils.isAlphanumericSpace("""");
}","/**
 * <p>Checks if the CharSequence contains only unicode letters, digits
 * or space ({@code ' '}).</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty CharSequence (length()=0) will return {@code true}.</p>
 *
 * <pre>
 * StringUtils.isAlphanumericSpace(null)   = false
 * StringUtils.isAlphanumericSpace("""")     = true
 * StringUtils.isAlphanumericSpace(""  "")   = true
 * StringUtils.isAlphanumericSpace(""abc"")  = true
 * StringUtils.isAlphanumericSpace(""ab c"") = true
 * StringUtils.isAlphanumericSpace(""ab2c"") = true
 * StringUtils.isAlphanumericSpace(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if only contains letters, digits or space,
 *  and is non-null
 * @since 3.0 Changed signature from isAlphanumericSpace(String) to isAlphanumericSpace(CharSequence)
 */"
"public static int indexOfIgnoreCase(CharSequence str, CharSequence searchStr) {
    return indexOfIgnoreCase(str, searchStr, 0);
}","public void test0055() throws Throwable {
    String string0 = StringUtils.repeat(""...org.apache.commons.lang3.CharUtils"", ""p{InCombiningDiacriticalMarks}+AqYCshqa_33l0lal+"", 127);
    CharSequence[] charSequenceArray0 = new CharSequence[4];
    charSequenceArray0[0] = (CharSequence) ""...org.apache.commons.lang3.CharUtils"";
    charSequenceArray0[1] = (CharSequence) string0;
    charSequenceArray0[2] = (CharSequence) ""p{InCombiningDiacriticalMarks}+AqYCshqa_33l0lal+"";
    charSequenceArray0[3] = (CharSequence) ""p{InCombiningDiacriticalMarks}+AqYCshqa_33l0lal+"";
    StringUtils.startsWithAny(string0, charSequenceArray0);
    String[] stringArray0 = new String[9];
    stringArray0[0] = "">H?.]'sg/Yq$WpZ"";
    stringArray0[1] = string0;
    stringArray0[2] = ""...org.apache.commons.lang3.CharUtils"";
    stringArray0[3] = ""p{InCombiningDiacriticalMarks}+AqYCshqa_33l0lal+"";
    stringArray0[4] = ""p{InCombiningDiacriticalMarks}+AqYCshqa_33l0lal+"";
    stringArray0[5] = string0;
    stringArray0[6] = ""...org.apache.commons.lang3.CharUtils"";
    stringArray0[7] = string0;
    stringArray0[8] = string0;
    StringUtils.getCommonPrefix(stringArray0);
    StringUtils.trimToEmpty("">H?.]'sg/Yq$WpZ"");
    StringUtils.countMatches(stringArray0[8], ""...org.apache.commons.lang3.CharUtils"");
    StringUtils.indexOfIgnoreCase((CharSequence) stringArray0[1], (CharSequence) ""p{InCombiningDiacriticalMarks}+AqYCshqa_33l0lal+"");
}","/**
 * <p>Case in-sensitive find of the first index within a CharSequence.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A negative start position is treated as zero.
 * An empty ("""") search CharSequence always matches.
 * A start position greater than the string length only matches
 * an empty search CharSequence.</p>
 *
 * <pre>
 * StringUtils.indexOfIgnoreCase(null, *)          = -1
 * StringUtils.indexOfIgnoreCase(*, null)          = -1
 * StringUtils.indexOfIgnoreCase("""", """")           = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""a"")  = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""b"")  = 2
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""ab"") = 1
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @return the first index of the search CharSequence,
 *  -1 if no match or {@code null} string input
 * @since 2.5
 * @since 3.0 Changed signature from indexOfIgnoreCase(String, String) to indexOfIgnoreCase(CharSequence, CharSequence)
 */"
"public static String leftPad(String str, int size, char padChar) {
    if (str == null) {
        return null;
    }
    int pads = size - str.length();
    if (pads <= 0) {
        // returns original String when possible
        return str;
    }
    if (pads > PAD_LIMIT) {
        return leftPad(str, size, String.valueOf(padChar));
    }
    return repeat(padChar, pads).concat(str);
}","public void test0066() throws Throwable {
    int int0 = 4492;
    StringUtils.repeat("""", 4492);
    StringUtils.containsNone((CharSequence) """", """");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens("""");
    String string0 = ""n"";
    StringUtils.containsNone((CharSequence) """", ""n"");
    String string1 = ""\\u00"";
    StringUtils.stripAll(stringArray0, string1);
    String string2 = StringUtils.repeat('f', 4492);
    String string3 = StringUtils.trimToEmpty(string2);
    String string4 = ""DDb\""N+yvh"";
    StringUtils.leftPad(""DDb\""N+yvh"", 4492, 'f');
    StringUtils.isAllLowerCase("""");
    StringUtils.lastOrdinalIndexOf(string3, """", 'f');
    // Undeclared exception!
    StringUtils.leftPad(string1, 4492, 'f');
}","/**
 * <p>Left pad a String with a specified character.</p>
 *
 * <p>Pad to a size of {@code size}.</p>
 *
 * <pre>
 * StringUtils.leftPad(null, *, *)     = null
 * StringUtils.leftPad("""", 3, 'z')     = ""zzz""
 * StringUtils.leftPad(""bat"", 3, 'z')  = ""bat""
 * StringUtils.leftPad(""bat"", 5, 'z')  = ""zzbat""
 * StringUtils.leftPad(""bat"", 1, 'z')  = ""bat""
 * StringUtils.leftPad(""bat"", -1, 'z') = ""bat""
 * </pre>
 *
 * @param str  the String to pad out, may be null
 * @param size  the size to pad to
 * @param padChar  the character to pad with
 * @return left padded String or original String if no padding is necessary,
 *  {@code null} if null String input
 * @since 2.0
 */"
"// Overlay
//-----------------------------------------------------------------------
/**
 * <p>Overlays part of a String with another String.</p>
 *
 * <p>A {@code null} string input returns {@code null}.
 * A negative index is treated as zero.
 * An index greater than the string length is treated as the string length.
 * The start index is always the smaller of the two indices.</p>
 *
 * <pre>
 * StringUtils.overlay(null, *, *, *)            = null
 * StringUtils.overlay("""", ""abc"", 0, 0)          = ""abc""
 * StringUtils.overlay(""abcdef"", null, 2, 4)     = ""abef""
 * StringUtils.overlay(""abcdef"", """", 2, 4)       = ""abef""
 * StringUtils.overlay(""abcdef"", """", 4, 2)       = ""abef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 2, 4)   = ""abzzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 4, 2)   = ""abzzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", -1, 4)  = ""zzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 2, 8)   = ""abzzzz""
 * StringUtils.overlay(""abcdef"", ""zzzz"", -2, -3) = ""zzzzabcdef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 8, 10)  = ""abcdefzzzz""
 * </pre>
 *
 * @param str  the String to do overlaying in, may be null
 * @param overlay  the String to overlay, may be null
 * @param start  the position to start overlaying at
 * @param end  the position to stop overlaying before
 * @return overlayed String, {@code null} if null String input
 * @since 2.0
 */
public static String overlay(String str, String overlay, int start, int end) {
    if (str == null) {
        return null;
    }
    if (overlay == null) {
        overlay = EMPTY;
    }
    int len = str.length();
    if (start < 0) {
        start = 0;
    }
    if (start > len) {
        start = len;
    }
    if (end < 0) {
        end = 0;
    }
    if (end > len) {
        end = len;
    }
    if (start > end) {
        int temp = start;
        start = end;
        end = temp;
    }
    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();
}","public void test0077() throws Throwable {
    String[] stringArray0 = new String[0];
    StringUtils.getCommonPrefix(stringArray0);
    StringUtils.overlay("""", ""0?j*e Fi*<eDa=3q"", (-3250), 289);
}",""
"public static String join(Object[] array, String separator, int startIndex, int endIndex) {
    if (array == null) {
        return null;
    }
    if (separator == null) {
        separator = EMPTY;
    }
    // endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))
    //           (Assuming that all Strings are roughly equally long)
    int noOfItems = (endIndex - startIndex);
    if (noOfItems <= 0) {
        return EMPTY;
    }
    StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}","public void test0088() throws Throwable {
    StringUtils.upperCase(""sun.text.Normalizer"");
    StringUtils.containsNone((CharSequence) ""SUN.TEXT.NORMALIZER"", ""sun.text.Normalizer"");
    String string0 = StringUtils.leftPad(""FF[zjaSYY>[-=pDMZiIbg"", 1773, '7');
    Object[] objectArray0 = new Object[2];
    objectArray0[0] = (Object) ""SUN.TEXT.NORMALIZER"";
    objectArray0[1] = (Object) ""SUN.TEXT.NORMALIZER"";
    StringUtils.join(objectArray0, ""5_tvFR[)XIiN"", 1773, (-1191));
    StringUtils.leftPad((String) null, (-1191), '~');
    String[] stringArray0 = new String[0];
    String[] stringArray1 = StringUtils.stripAll(stringArray0, ""FF[zjaSYY>[-=pDMZiIbg"");
    StringUtils.removeStart(""FfD` Z/yI1~7u];S[H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", string0);
    StringUtils.isNumeric(""FfD` Z/yI1~7u];S[H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"");
    StringUtils.indexOfDifference((CharSequence) null, (CharSequence) ""FfD` Z/yI1~7u];S[H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"");
    String string1 = StringUtils.rightPad(""FfD` Z/yI1~7u];S[H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", 2136, ""SUN.TEXT.NORMALIZER"");
    StringUtils.indexOf((CharSequence) """", (CharSequence) string0);
    StringUtils.indexOfAny((CharSequence) string0, (CharSequence[]) stringArray1);
    StringUtils.isAlphanumeric(string1);
    StringUtils.join(objectArray0, (String) null, (-1528), (-1885));
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A {@code null} separator is the same as an empty String ("""").
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)                = null
 * StringUtils.join([], *)                  = """"
 * StringUtils.join([null], *)              = """"
 * StringUtils.join([""a"", ""b"", ""c""], ""--"")  = ""a--b--c""
 * StringUtils.join([""a"", ""b"", ""c""], null)  = ""abc""
 * StringUtils.join([""a"", ""b"", ""c""], """")    = ""abc""
 * StringUtils.join([null, """", ""a""], ',')   = "",,a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @param startIndex the first index to start joining from.  It is
 * an error to pass in an end index past the end of the array
 * @param endIndex the index to stop joining from (exclusive). It is
 * an error to pass in an end index past the end of the array
 * @return the joined String, {@code null} if null array input
 */"
"public static int getLevenshteinDistance(CharSequence s, CharSequence t, int threshold) {
    if (s == null || t == null) {
        throw new IllegalArgumentException(""Strings must not be null"");
    }
    if (threshold < 0) {
        throw new IllegalArgumentException(""Threshold must not be negative"");
    }
    /*
        This implementation only computes the distance if it's less than or equal to the
        threshold value, returning -1 if it's greater.  The advantage is performance: unbounded
        distance is O(nm), but a bound of k allows us to reduce it to O(km) time by only 
        computing a diagonal stripe of width 2k + 1 of the cost table.
        It is also possible to use this to compute the unbounded Levenshtein distance by starting
        the threshold at 1 and doubling each time until the distance is found; this is O(dm), where
        d is the distance.
        
        One subtlety comes from needing to ignore entries on the border of our stripe
        eg.
        p[] = |#|#|#|*
        d[] =  *|#|#|#|
        We must ignore the entry to the left of the leftmost member
        We must ignore the entry above the rightmost member
        
        Another subtlety comes from our stripe running off the matrix if the strings aren't
        of the same size.  Since string s is always swapped to be the shorter of the two, 
        the stripe will always run off to the upper right instead of the lower left of the matrix.
        
        As a concrete example, suppose s is of length 5, t is of length 7, and our threshold is 1.
        In this case we're going to walk a stripe of length 3.  The matrix would look like so:
        
           1 2 3 4 5
        1 |#|#| | | |
        2 |#|#|#| | |
        3 | |#|#|#| |
        4 | | |#|#|#|
        5 | | | |#|#|
        6 | | | | |#|
        7 | | | | | |

        Note how the stripe leads off the table as there is no possible way to turn a string of length 5
        into one of length 7 in edit distance of 1.
        
        Additionally, this implementation decreases memory usage by using two 
        single-dimensional arrays and swapping them back and forth instead of allocating
        an entire n by m matrix.  This requires a few minor changes, such as immediately returning 
        when it's detected that the stripe has run off the matrix and initially filling the arrays with
        large values so that entries we don't compute are ignored.

        See Algorithms on Strings, Trees and Sequences by Dan Gusfield for some discussion.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    // if one string is empty, the edit distance is necessarily the length of the other
    if (n == 0) {
        return m <= threshold ? m : -1;
    } else if (m == 0) {
        return n <= threshold ? n : -1;
    }
    if (n > m) {
        // swap the two strings to consume less memory
        CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    // 'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    // placeholder to assist in swapping p and d
    int[] _d;
    // fill in starting table values
    int boundary = Math.min(n, threshold) + 1;
    for (int i = 0; i < boundary; i++) {
        p[i] = i;
    }
    // these fills ensure that the value above the rightmost entry of our
    // stripe will be ignored in following loop iterations
    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);
    Arrays.fill(d, Integer.MAX_VALUE);
    // iterates through t
    for (int j = 1; j <= m; j++) {
        // jth character of t
        char t_j = t.charAt(j - 1);
        d[0] = j;
        // compute stripe indices, constrain to array size
        int min = Math.max(1, j - threshold);
        int max = Math.min(n, j + threshold);
        // the stripe may lead off of the table if s and t are of different sizes
        if (min > max) {
            return -1;
        }
        // ignore entry left of leftmost
        if (min > 1) {
            d[min - 1] = Integer.MAX_VALUE;
        }
        // iterates through [min, max] in s
        for (int i = min; i <= max; i++) {
            if (s.charAt(i - 1) == t_j) {
                // diagonally left and up
                d[i] = p[i - 1];
            } else {
                // 1 + minimum of cell to the left, to the top, diagonally left and up
                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);
            }
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // if p[n] is greater than the threshold, there's no guarantee on it being the correct
    // distance
    if (p[n] <= threshold) {
        return p[n];
    } else {
        return -1;
    }
}","public void test0099() throws Throwable {
    StringUtils.left(""SecurityException occurred"", 41);
    StringUtils.isAsciiPrintable(""SecurityException occurred"");
    StringUtils.substringsBetween(""SecurityException occurred"", ""5]"", ""', is neither of type Map.Entry nor an Array"");
    StringUtils.substringBeforeLast(""D=qka"", ""SecurityException occurred"");
    StringUtils.lastIndexOfIgnoreCase((CharSequence) ""D=qka"", (CharSequence) ""5]"", 47);
    StringUtils.containsNone((CharSequence) ""D=qka"", ""X"");
    StringUtils.equals((CharSequence) ""', is neither of type Map.Entry nor an Array"", (CharSequence) ""D=qka"");
    StringUtils.indexOfDifference((CharSequence) ""X"", (CharSequence) ""D=qka"");
    StringUtils.getLevenshteinDistance((CharSequence) ""5]"", (CharSequence) ""X"", 0);
}","/**
 * <p>Find the Levenshtein distance between two Strings if it's less than or equal to a given
 * threshold.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>This implementation follows from Algorithms on Strings, Trees and Sequences by Dan Gusfield
 * and Chas Emerick's implementation of the Levenshtein distance algorithm from
 * <a href=""http://www.merriampark.com/ld.htm"">http://www.merriampark.com/ld.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, *, -1)               = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("""","""", 0)               = 0
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 8)       = 7
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 7)       = 7
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 6))      = -1
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"", 7) = 7
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"", 6) = -1
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"", 7) = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"", 6) = -1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @param threshold the target threshold, must not be negative
 * @return result distance, or {@code -1} if the distance would be greater than the threshold
 * @throws IllegalArgumentException if either String input {@code null} or negative threshold
 */"
"public static String substringAfterLast(String str, String separator) {
    if (isEmpty(str)) {
        return str;
    }
    if (isEmpty(separator)) {
        return EMPTY;
    }
    int pos = str.lastIndexOf(separator);
    if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) {
        return EMPTY;
    }
    return str.substring(pos + separator.length());
}","public void test01010() throws Throwable {
    StringUtils.replaceChars(""<~|muKv!Sf"", ""The Character must not be null"", (String) null);
    StringUtils.indexOf((CharSequence) ""<~|Kv!Sf"", (CharSequence) ""<~|muKv!Sf"");
    StringUtils.substringAfterLast(""GTjTpD(Oy"", (String) null);
}","/**
 * <p>Gets the substring after the last occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A {@code null} string input will return {@code null}.
 * An empty ("""") string input will return the empty string.
 * An empty or {@code null} separator will return the empty string if
 * the input string is not {@code null}.</p>
 *
 * <p>If nothing is found, the empty string is returned.</p>
 *
 * <pre>
 * StringUtils.substringAfterLast(null, *)      = null
 * StringUtils.substringAfterLast("""", *)        = """"
 * StringUtils.substringAfterLast(*, """")        = """"
 * StringUtils.substringAfterLast(*, null)      = """"
 * StringUtils.substringAfterLast(""abc"", ""a"")   = ""bc""
 * StringUtils.substringAfterLast(""abcba"", ""b"") = ""a""
 * StringUtils.substringAfterLast(""abc"", ""c"")   = """"
 * StringUtils.substringAfterLast(""a"", ""a"")     = """"
 * StringUtils.substringAfterLast(""a"", ""z"")     = """"
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring after the last occurrence of the separator,
 *  {@code null} if null String input
 * @since 2.0
 */"
"public static int indexOfIgnoreCase(CharSequence str, CharSequence searchStr, int startPos) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    if (startPos < 0) {
        startPos = 0;
    }
    int endLimit = (str.length() - searchStr.length()) + 1;
    if (startPos > endLimit) {
        return INDEX_NOT_FOUND;
    }
    if (searchStr.length() == 0) {
        return startPos;
    }
    for (int i = startPos; i < endLimit; i++) {
        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test01111() throws Throwable {
    int int0 = StringUtils.indexOfIgnoreCase((CharSequence) ""x@}:d~k7"", (CharSequence) ""x@}:d~k7"", 256);
    assertEquals((-1), int0);
}","/**
 * <p>Case in-sensitive find of the first index within a CharSequence
 * from the specified position.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A negative start position is treated as zero.
 * An empty ("""") search CharSequence always matches.
 * A start position greater than the string length only matches
 * an empty search CharSequence.</p>
 *
 * <pre>
 * StringUtils.indexOfIgnoreCase(null, *, *)          = -1
 * StringUtils.indexOfIgnoreCase(*, null, *)          = -1
 * StringUtils.indexOfIgnoreCase("""", """", 0)           = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""A"", 0)  = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", 0)  = 2
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""AB"", 0) = 1
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", 3)  = 5
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", 9)  = -1
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", -1) = 2
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", """", 2)   = 2
 * StringUtils.indexOfIgnoreCase(""abc"", """", 9)        = 3
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @param startPos  the start position, negative treated as zero
 * @return the first index of the search CharSequence,
 *  -1 if no match or {@code null} string input
 * @since 2.5
 * @since 3.0 Changed signature from indexOfIgnoreCase(String, String, int) to indexOfIgnoreCase(CharSequence, CharSequence, int)
 */"
"public static boolean startsWithAny(CharSequence string, CharSequence... searchStrings) {
    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {
        return false;
    }
    for (int i = 0; i < searchStrings.length; i++) {
        CharSequence searchString = searchStrings[i];
        if (StringUtils.startsWith(string, searchString)) {
            return true;
        }
    }
    return false;
}","public void test01112() throws Throwable {
    int int0 = StringUtils.indexOfIgnoreCase((CharSequence) ""x@}:d~k7"", (CharSequence) ""x@}:d~k7"", 256);
    CharSequence[] charSequenceArray0 = new CharSequence[2];
    charSequenceArray0[0] = (CharSequence) ""x@}:d~k7"";
    boolean boolean0 = StringUtils.startsWithAny(""x@}:d~k7"", charSequenceArray0);
    assertEquals(2, charSequenceArray0.length);
}","/**
 * <p>Check if a CharSequence starts with any of an array of specified strings.</p>
 *
 * <pre>
 * StringUtils.startsWithAny(null, null)      = false
 * StringUtils.startsWithAny(null, new String[] {""abc""})  = false
 * StringUtils.startsWithAny(""abcxyz"", null)     = false
 * StringUtils.startsWithAny(""abcxyz"", new String[] {""""}) = false
 * StringUtils.startsWithAny(""abcxyz"", new String[] {""abc""}) = true
 * StringUtils.startsWithAny(""abcxyz"", new String[] {null, ""xyz"", ""abc""}) = true
 * </pre>
 *
 * @param string  the CharSequence to check, may be null
 * @param searchStrings the CharSequences to find, may be null or empty
 * @return {@code true} if the CharSequence starts with any of the the prefixes, case insensitive, or
 *  both {@code null}
 * @since 2.5
 * @since 3.0 Changed signature from startsWithAny(String, String[]) to startsWithAny(CharSequence, CharSequence...)
 */"
"public static String repeat(char ch, int repeat) {
    char[] buf = new char[repeat];
    for (int i = repeat - 1; i >= 0; i--) {
        buf[i] = ch;
    }
    return new String(buf);
}","public void test01114() throws Throwable {
    int int0 = StringUtils.indexOfIgnoreCase((CharSequence) ""x@}:d~k7"", (CharSequence) ""x@}:d~k7"", 256);
    CharSequence[] charSequenceArray0 = new CharSequence[2];
    charSequenceArray0[0] = (CharSequence) ""x@}:d~k7"";
    boolean boolean0 = StringUtils.startsWithAny(""x@}:d~k7"", charSequenceArray0);
    String string0 = StringUtils.repeat('W', 4);
    assertNotNull(string0);
}","/**
 * <p>Returns padding using the specified delimiter repeated
 * to a given length.</p>
 *
 * <pre>
 * StringUtils.repeat(0, 'e')  = """"
 * StringUtils.repeat(3, 'e')  = ""eee""
 * StringUtils.repeat(-2, 'e') = """"
 * </pre>
 *
 * <p>Note: this method doesn't not support padding with
 * <a href=""http://www.unicode.org/glossary/#supplementary_character"">Unicode Supplementary Characters</a>
 * as they require a pair of {@code char}s to be represented.
 * If you are needing to support full I18N of your applications
 * consider using {@link #repeat(String, int)} instead.
 * </p>
 *
 * @param ch  character to repeat
 * @param repeat  number of times to repeat char, negative treated as zero
 * @return String with repeated character
 * @see #repeat(String, int)
 */"
"public static String uncapitalize(String str) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    return new StringBuilder(strLen).append(Character.toLowerCase(str.charAt(0))).append(str.substring(1)).toString();
}","public void test01116() throws Throwable {
    int int0 = StringUtils.indexOfIgnoreCase((CharSequence) ""x@}:d~k7"", (CharSequence) ""x@}:d~k7"", 256);
    CharSequence[] charSequenceArray0 = new CharSequence[2];
    charSequenceArray0[0] = (CharSequence) ""x@}:d~k7"";
    boolean boolean0 = StringUtils.startsWithAny(""x@}:d~k7"", charSequenceArray0);
    String string0 = StringUtils.repeat('W', 4);
    String string1 = StringUtils.uncapitalize(""', is neither of type Map.Entry nor an Array', is neither of type Map.Entry nor an Array"");
    assertNotNull(string1);
}","/**
 * <p>Uncapitalizes a String changing the first letter to title case as
 * per {@link Character#toLowerCase(char)}. No other letters are changed.</p>
 *
 * <p>For a word based algorithm, see {@link org.apache.commons.lang3.text.WordUtils#uncapitalize(String)}.
 * A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.uncapitalize(null)  = null
 * StringUtils.uncapitalize("""")    = """"
 * StringUtils.uncapitalize(""Cat"") = ""cat""
 * StringUtils.uncapitalize(""CAT"") = ""cAT""
 * </pre>
 *
 * @param str the String to uncapitalize, may be null
 * @return the uncapitalized String, {@code null} if null String input
 * @see org.apache.commons.lang3.text.WordUtils#uncapitalize(String)
 * @see #capitalize(String)
 * @since 2.0
 */"
"public static String replaceChars(String str, String searchChars, String replaceChars) {
    if (isEmpty(str) || isEmpty(searchChars)) {
        return str;
    }
    if (replaceChars == null) {
        replaceChars = EMPTY;
    }
    boolean modified = false;
    int replaceCharsLength = replaceChars.length();
    int strLength = str.length();
    StringBuilder buf = new StringBuilder(strLength);
    for (int i = 0; i < strLength; i++) {
        char ch = str.charAt(i);
        int index = searchChars.indexOf(ch);
        if (index >= 0) {
            modified = true;
            if (index < replaceCharsLength) {
                buf.append(replaceChars.charAt(index));
            }
        } else {
            buf.append(ch);
        }
    }
    if (modified) {
        return buf.toString();
    }
    return str;
}","public void test01119() throws Throwable {
    int int0 = StringUtils.indexOfIgnoreCase((CharSequence) ""x@}:d~k7"", (CharSequence) ""x@}:d~k7"", 256);
    CharSequence[] charSequenceArray0 = new CharSequence[2];
    charSequenceArray0[0] = (CharSequence) ""x@}:d~k7"";
    boolean boolean0 = StringUtils.startsWithAny(""x@}:d~k7"", charSequenceArray0);
    String string0 = StringUtils.repeat('W', 4);
    String string1 = StringUtils.uncapitalize(""', is neither of type Map.Entry nor an Array', is neither of type Map.Entry nor an Array"");
    String string2 = StringUtils.replaceChars(""WWWW"", ""', is neither of type Map.Entry nor an Array', is neither of type Map.Entry nor an Array"", ""Cloneable type "");
    assertNotNull(string2);
}","/**
 * <p>Replaces multiple characters in a String in one go.
 * This method can also be used to delete characters.</p>
 *
 * <p>For example:<br />
 * <code>replaceChars(&quot;hello&quot;, &quot;ho&quot;, &quot;jy&quot;) = jelly</code>.</p>
 *
 * <p>A {@code null} string input returns {@code null}.
 * An empty ("""") string input returns an empty string.
 * A null or empty set of search characters returns the input string.</p>
 *
 * <p>The length of the search characters should normally equal the length
 * of the replace characters.
 * If the search characters is longer, then the extra search characters
 * are deleted.
 * If the search characters is shorter, then the extra replace characters
 * are ignored.</p>
 *
 * <pre>
 * StringUtils.replaceChars(null, *, *)           = null
 * StringUtils.replaceChars("""", *, *)             = """"
 * StringUtils.replaceChars(""abc"", null, *)       = ""abc""
 * StringUtils.replaceChars(""abc"", """", *)         = ""abc""
 * StringUtils.replaceChars(""abc"", ""b"", null)     = ""ac""
 * StringUtils.replaceChars(""abc"", ""b"", """")       = ""ac""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""yz"")  = ""ayzya""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""y"")   = ""ayya""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""yzx"") = ""ayzya""
 * </pre>
 *
 * @param str  String to replace characters in, may be null
 * @param searchChars  a set of characters to search for, may be null
 * @param replaceChars  a set of characters to replace, may be null
 * @return modified String, {@code null} if null string input
 * @since 2.0
 */"
"public static String rightPad(String str, int size, char padChar) {
    if (str == null) {
        return null;
    }
    int pads = size - str.length();
    if (pads <= 0) {
        // returns original String when possible
        return str;
    }
    if (pads > PAD_LIMIT) {
        return rightPad(str, size, String.valueOf(padChar));
    }
    return str.concat(repeat(padChar, pads));
}","public void test01123() throws Throwable {
    int int0 = StringUtils.indexOfIgnoreCase((CharSequence) ""x@}:d~k7"", (CharSequence) ""x@}:d~k7"", 256);
    CharSequence[] charSequenceArray0 = new CharSequence[2];
    charSequenceArray0[0] = (CharSequence) ""x@}:d~k7"";
    boolean boolean0 = StringUtils.startsWithAny(""x@}:d~k7"", charSequenceArray0);
    String string0 = StringUtils.repeat('W', 4);
    String string1 = StringUtils.uncapitalize(""', is neither of type Map.Entry nor an Array', is neither of type Map.Entry nor an Array"");
    String string2 = StringUtils.replaceChars(""WWWW"", ""', is neither of type Map.Entry nor an Array', is neither of type Map.Entry nor an Array"", ""Cloneable type "");
    String string3 = StringUtils.rightPad((String) null, 127, 'W');
    assertNull(string3);
}","/**
 * <p>Right pad a String with a specified character.</p>
 *
 * <p>The String is padded to the size of {@code size}.</p>
 *
 * <pre>
 * StringUtils.rightPad(null, *, *)     = null
 * StringUtils.rightPad("""", 3, 'z')     = ""zzz""
 * StringUtils.rightPad(""bat"", 3, 'z')  = ""bat""
 * StringUtils.rightPad(""bat"", 5, 'z')  = ""batzz""
 * StringUtils.rightPad(""bat"", 1, 'z')  = ""bat""
 * StringUtils.rightPad(""bat"", -1, 'z') = ""bat""
 * </pre>
 *
 * @param str  the String to pad out, may be null
 * @param size  the size to pad to
 * @param padChar  the character to pad with
 * @return right padded String or original String if no padding is necessary,
 *  {@code null} if null String input
 * @since 2.0
 */"
"public static int indexOfIgnoreCase(CharSequence str, CharSequence searchStr) {
    return indexOfIgnoreCase(str, searchStr, 0);
}","public void test01224() throws Throwable {
    StringUtils.replaceChars(""8bEhDCywIDUxL'YBr"", ""8bEhDCywIDUxL'YBr"", ""8bEhDCywIDUxL'YBr"");
    StringUtils.splitPreserveAllTokens("" iI'(B)EZP7J6;JS@o"", ""8bEhDCywIDUxL'YBr"");
    String[] stringArray0 = StringUtils.splitByCharacterTypeCamelCase(""8bEhDCywIDUxL'YBr"");
    StringUtils.stripAll(stringArray0, "")/r2R?"");
    StringUtils.upperCase(""8bEhDCywIDUxL'YBr"");
    StringUtils.swapCase(""<{'a_Id_QlqU"");
    StringUtils.split("" iI'(B)EZP7J6;JS@o"");
    char[] charArray0 = new char[2];
    charArray0[0] = 'R';
    charArray0[1] = '8';
    StringUtils.containsOnly((CharSequence) ""8BEHDCYWIDUXL'YBR"", charArray0);
    StringUtils.equalsIgnoreCase(""8bEhDCywIDUxL'YBr"", ""8BEHDCYWIDUXL'YBR"");
    String[] stringArray1 = StringUtils.splitPreserveAllTokens(""8bEhDCywIDUxL'YBr"", '\\');
    int int0 = StringUtils.countMatches(""<{'a_Id_QlqU"", "" iI'(B)EZP7J6;JS@o"");
    StringUtils.substring(""<{'A_iD_qLQu"", Integer.MAX_VALUE);
    StringUtils.abbreviate(""8bEhDCywIDUxL'YBr"", 20, 12);
    StringUtils.right(""8bEhDCywIDUxL'YBr"", 10);
    int int1 = StringUtils.indexOfIgnoreCase((CharSequence) ""<{'A_iD_qLQu"", (CharSequence) ""8bEhDCywIDUxL'YBr"");
    assertFalse(int1 == int0);
}","/**
 * <p>Case in-sensitive find of the first index within a CharSequence.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A negative start position is treated as zero.
 * An empty ("""") search CharSequence always matches.
 * A start position greater than the string length only matches
 * an empty search CharSequence.</p>
 *
 * <pre>
 * StringUtils.indexOfIgnoreCase(null, *)          = -1
 * StringUtils.indexOfIgnoreCase(*, null)          = -1
 * StringUtils.indexOfIgnoreCase("""", """")           = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""a"")  = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""b"")  = 2
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""ab"") = 1
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @return the first index of the search CharSequence,
 *  -1 if no match or {@code null} string input
 * @since 2.5
 * @since 3.0 Changed signature from indexOfIgnoreCase(String, String) to indexOfIgnoreCase(CharSequence, CharSequence)
 */"
"public static String chomp(String str, String separator) {
    if (isEmpty(str) || separator == null) {
        return str;
    }
    if (str.endsWith(separator)) {
        return str.substring(0, str.length() - separator.length());
    }
    return str;
}","public void test01325() throws Throwable {
    StringUtils.replaceChars(""8bEhDCywIDUxL'YBr"", ""8bEhDCywIDUxL'YBr"", ""8bEhDCywIDUxL'YBr"");
    StringUtils.splitPreserveAllTokens("" iI'(B)EZP7J6;JS@o"", ""8bEhDCywIDUxL'YBr"");
    String[] stringArray0 = StringUtils.splitByCharacterTypeCamelCase(""8bEhDCywIDUxL'YBr"");
    StringUtils.stripAll(stringArray0, "")/r2R?"");
    StringUtils.upperCase(""8bEhDCywIDUxL'YBr"");
    StringUtils.swapCase(""<{'a_Id_QlqU"");
    StringUtils.split("" iI'(B)EZP7J6;JS@o"");
    char[] charArray0 = new char[2];
    charArray0[0] = 'R';
    charArray0[1] = '8';
    StringUtils.containsOnly((CharSequence) ""8BEHDCYWIDUXL'YBR"", charArray0);
    StringUtils.equalsIgnoreCase(""8bEhDCywIDUxL'YBr"", ""8BEHDCYWIDUXL'YBR"");
    StringUtils.splitPreserveAllTokens(""8bEhDCywIDUxL'YBr"", 'l');
    StringUtils.countMatches(""<{'a_Id_QlqU"", "" iI'(B)EZP7J6;JS@o"");
    StringUtils.substring(""<{'A_iD_qLQu"", Integer.MAX_VALUE);
    StringUtils.abbreviate(""8bEhDCywIDUxL'YBr"", 20, 12);
    StringUtils.right(""8bEhDCywIDUxL'YBr"", (-2098));
    StringUtils.indexOfIgnoreCase((CharSequence) ""<{'A_iD_qLQu"", (CharSequence) ""8bEhDCywIDUxL'YBr"");
    StringUtils.contains((CharSequence) """", 46);
    StringUtils.length(""<{'A_iD_qLQu"");
    StringUtils.chomp((String) null, ""<{'A_iD_qLQu"");
}","/**
 * <p>Removes {@code separator} from the end of
 * {@code str} if it's there, otherwise leave it alone.</p>
 *
 * <p>NOTE: This method changed in version 2.0.
 * It now more closely matches Perl chomp.
 * For the previous behavior, use {@link #substringBeforeLast(String, String)}.
 * This method uses {@link String#endsWith(String)}.</p>
 *
 * <pre>
 * StringUtils.chomp(null, *)         = null
 * StringUtils.chomp("""", *)           = """"
 * StringUtils.chomp(""foobar"", ""bar"") = ""foo""
 * StringUtils.chomp(""foobar"", ""baz"") = ""foobar""
 * StringUtils.chomp(""foo"", ""foo"")    = """"
 * StringUtils.chomp(""foo "", ""foo"")   = ""foo ""
 * StringUtils.chomp("" foo"", ""foo"")   = "" ""
 * StringUtils.chomp(""foo"", ""foooo"")  = ""foo""
 * StringUtils.chomp(""foo"", """")       = ""foo""
 * StringUtils.chomp(""foo"", null)     = ""foo""
 * </pre>
 *
 * @param str  the String to chomp from, may be null
 * @param separator  separator String, may be null
 * @return String without trailing separator, {@code null} if null String input
 */"
"// Misc
//-----------------------------------------------------------------------
/**
 * <p>Find the Levenshtein distance between two Strings.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>The previous implementation of the Levenshtein distance algorithm
 * was from <a href=""http://www.merriampark.com/ld.htm"">http://www.merriampark.com/ld.htm</a></p>
 *
 * <p>Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError
 * which can occur when my Java implementation is used with very large strings.<br>
 * This implementation of the Levenshtein distance algorithm
 * is from <a href=""http://www.merriampark.com/ldjava.htm"">http://www.merriampark.com/ldjava.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("""","""")               = 0
 * StringUtils.getLevenshteinDistance("""",""a"")              = 1
 * StringUtils.getLevenshteinDistance(""aaapppp"", """")       = 7
 * StringUtils.getLevenshteinDistance(""frog"", ""fog"")       = 1
 * StringUtils.getLevenshteinDistance(""fly"", ""ant"")        = 3
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""zzzzzzzz"") = 8
 * StringUtils.getLevenshteinDistance(""hello"", ""hallo"")    = 1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @return result distance
 * @throws IllegalArgumentException if either String input {@code null}
 * @since 3.0 Changed signature from getLevenshteinDistance(String, String) to
 * getLevenshteinDistance(CharSequence, CharSequence)
 */
public static int getLevenshteinDistance(CharSequence s, CharSequence t) {
    if (s == null || t == null) {
        throw new IllegalArgumentException(""Strings must not be null"");
    }
    /*
           The difference between this impl. and the previous is that, rather
           than creating and retaining a matrix of size s.length() + 1 by t.length() + 1,
           we maintain two single-dimensional arrays of length s.length() + 1.  The first, d,
           is the 'current working' distance array that maintains the newest distance cost
           counts as we iterate through the characters of String s.  Each time we increment
           the index of String t we are comparing, d is copied to p, the second int[].  Doing so
           allows us to retain the previous cost counts as required by the algorithm (taking
           the minimum of the cost count to the left, up one, and diagonally up and to the left
           of the current cost count being calculated).  (Note that the arrays aren't really
           copied anymore, just switched...this is clearly much better than cloning an array
           or doing a System.arraycopy() each time  through the outer loop.)

           Effectively, the difference between the two implementations is this one does not
           cause an out of memory condition when calculating the LD over two very large strings.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    if (n == 0) {
        return m;
    } else if (m == 0) {
        return n;
    }
    if (n > m) {
        // swap the input strings to consume less memory
        CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    //'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    //placeholder to assist in swapping p and d
    int[] _d;
    // indexes into strings s and t
    // iterates through s
    int i;
    // iterates through t
    int j;
    // jth character of t
    char t_j;
    // cost
    int cost;
    for (i = 0; i <= n; i++) {
        p[i] = i;
    }
    for (j = 1; j <= m; j++) {
        t_j = t.charAt(j - 1);
        d[0] = j;
        for (i = 1; i <= n; i++) {
            cost = s.charAt(i - 1) == t_j ? 0 : 1;
            // minimum of cell to the left+1, to the top+1, diagonally left and up +cost
            d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost);
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // our last action in the above loop was to switch d and p, so p now
    // actually has the most recent cost counts
    return p[n];
}","public void test01426() throws Throwable {
    StringUtils.substringBetween("" vs "", "" vs "", ""FF[zjaSYY>[-=pDMZiIbg"");
    StringUtils.indexOfAnyBut((CharSequence) "" vs "", (CharSequence) "" vs "");
    StringUtils.stripToNull(""FfD` Z/yI1~7u];S["");
    StringUtils.substringBefore(""FfD` Z/yI1~7u];S["", ""TimeToLive of "");
    StringUtils.substringBeforeLast(""8B<o&y1[X-fL4,6u"", ""FfD` Z/yI1~7u];S["");
    StringUtils.lastIndexOfIgnoreCase((CharSequence) "" vs "", (CharSequence) ""FF[zjaSYY>[-=pDMZiIbg"", (-1));
    StringUtils.overlay(""FfD` Z/yI1~7u];S["", ""FfD` Z/yI1~7u];S["", (-1), (-1));
    StringUtils.indexOfIgnoreCase((CharSequence) ""FfD` Z/yI1~7u];S["", (CharSequence) ""8B<o&y1[X-fL4,6u"");
    StringUtils.isAlphanumeric(""FfD` Z/yI1~7u];S["");
    StringUtils.lastIndexOf((CharSequence) ""8B<o&y1[X-fL4,6u"", (-1));
    StringUtils.isAllLowerCase(""FfD` Z/yI1~7u];S["");
    StringUtils.remove(""8"", ""\""6 O"");
    StringUtils.ordinalIndexOf(""TimeToLive of "", ""8B<o&y1[X-fL4,6u"", 31);
    StringUtils.containsNone((CharSequence) "" vs "", ""FfD` Z/yI1~7u];S[FfD` Z/yI1~7u];S["");
    StringUtils.isAllLowerCase(""8"");
    StringUtils.equals((CharSequence) ""8"", (CharSequence) null);
    StringUtils.indexOf((CharSequence) ""8B<o&y1[X-fL4,6u"", (-1), (-1));
    StringUtils.indexOf((CharSequence) ""FfD` Z/yI1~7u];S["", (CharSequence) ""8B<o&y1[X-fL4,6u"");
    StringUtils.containsNone((CharSequence) "" vs "", "" vs "");
    StringUtils.substringBetween(""FfD` Z/yI1~7u];S["", ""D:?CYJ~uOr;7X"");
    StringUtils.indexOfAny((CharSequence) null, (CharSequence[]) null);
    StringUtils.swapCase(""FF[zjaSYY>[-=pDMZiIbg"");
    StringUtils.lastIndexOf((CharSequence) ""ff[ZJAsyy>[-=PdmzIiBG"", (-1), 10);
    StringUtils.stripStart("":'l"", (String) null);
    // Undeclared exception!
    try {
        StringUtils.getLevenshteinDistance((CharSequence) ""TimeToLive of "", (CharSequence) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Strings must not be null
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}",""
"public static String chomp(String str, String separator) {
    if (isEmpty(str) || separator == null) {
        return str;
    }
    if (str.endsWith(separator)) {
        return str.substring(0, str.length() - separator.length());
    }
    return str;
}","public void test01527() throws Throwable {
    StringUtils.trimToEmpty("""");
    StringUtils.overlay(""/1HOy{4bG`k>"", ""Minimum abbreviation width is 4"", (-639), 3);
    TreeSet<Object> treeSet0 = new TreeSet<Object>();
    Locale.FilteringMode locale_FilteringMode0 = Locale.FilteringMode.EXTENDED_FILTERING;
    Locale.FilteringMode[] locale_FilteringModeArray0 = Locale.FilteringMode.values();
    treeSet0.add(locale_FilteringMode0);
    Iterator<Object> iterator0 = treeSet0.iterator();
    StringUtils.join(iterator0, 'z');
    StringUtils.join((Object[]) locale_FilteringModeArray0, ""Minimum abbreviation width is 4Oy{4bG`k>"", 1939, (-2670));
    StringUtils.isAlpha(""java.util.Locale$FilteringMode@0000000001"");
    StringUtils.substringsBetween((String) null, ""java.util.Locale$FilteringMode@0000000001"", (String) null);
    StringUtils.stripAccents("""");
    StringUtils.rightPad(""FF[zjaSYY>[-=pDMZiIbg"", (-782), ""xDTm(m'~h1DlVpMeThe character must not be null"");
    StringUtils.stripToEmpty(""java.util.Locale$FilteringMode@0000000001"");
    StringUtils.swapCase(""decompose"");
    StringUtils.chomp(""FfD` Z/yI1~7u];S["", ""Minimum abbreviation width is 4"");
}","/**
 * <p>Removes {@code separator} from the end of
 * {@code str} if it's there, otherwise leave it alone.</p>
 *
 * <p>NOTE: This method changed in version 2.0.
 * It now more closely matches Perl chomp.
 * For the previous behavior, use {@link #substringBeforeLast(String, String)}.
 * This method uses {@link String#endsWith(String)}.</p>
 *
 * <pre>
 * StringUtils.chomp(null, *)         = null
 * StringUtils.chomp("""", *)           = """"
 * StringUtils.chomp(""foobar"", ""bar"") = ""foo""
 * StringUtils.chomp(""foobar"", ""baz"") = ""foobar""
 * StringUtils.chomp(""foo"", ""foo"")    = """"
 * StringUtils.chomp(""foo "", ""foo"")   = ""foo ""
 * StringUtils.chomp("" foo"", ""foo"")   = "" ""
 * StringUtils.chomp(""foo"", ""foooo"")  = ""foo""
 * StringUtils.chomp(""foo"", """")       = ""foo""
 * StringUtils.chomp(""foo"", null)     = ""foo""
 * </pre>
 *
 * @param str  the String to chomp from, may be null
 * @param separator  separator String, may be null
 * @return String without trailing separator, {@code null} if null String input
 */"
"public static boolean isWhitespace(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if ((Character.isWhitespace(cs.charAt(i)) == false)) {
            return false;
        }
    }
    return true;
}","public void test01628() throws Throwable {
    StringUtils.capitalize(""|`?_p[g"");
    StringUtils.isAlphaSpace(""|`?_p[g"");
    String[] stringArray0 = new String[5];
    stringArray0[0] = ""|`?_p[g"";
    stringArray0[1] = ""|`?_p[g"";
    stringArray0[2] = ""|`?_p[g"";
    stringArray0[3] = ""|`?_p[g"";
    stringArray0[4] = ""|`?_p[g"";
    StringUtils.getCommonPrefix(stringArray0);
    StringUtils.defaultIfEmpty(""|`?_p[g"", """");
    StringUtils.containsIgnoreCase(""|`?_p[g"", ""|`?_p[g"");
    StringUtils.containsAny((CharSequence) ""Dy_r=Wr2"", (CharSequence) ""|`?_p[g"");
    StringUtils.isAlpha(""|`?_p[g"");
    StringUtils.removeEndIgnoreCase(""|`?_p[g"", ""|`?_p[g"");
    StringUtils.stripAll(stringArray0);
    StringUtils.isNumericSpace(""|`?_p[g"");
    StringUtils.reverseDelimited(""Dy_r=Wr2"", '8');
    StringUtils.endsWithAny(""|`?_p[g"", stringArray0);
    String[] stringArray1 = StringUtils.splitByWholeSeparator(""}@s`E{_"", ""|`?_p[g"");
    StringUtils.substringBefore("""", ""|`?_p[g"");
    StringUtils.join((Object[]) stringArray0, ""|`?_p[g"");
    StringUtils.splitByWholeSeparator(""Dy_r=Wr2"", ""Dy_r=Wr2"", (-379));
    StringUtils.replaceEach("""", stringArray1, stringArray0);
    StringUtils.repeat((String) null, (String) null, (-379));
    StringUtils.replace("""", ""|`?_p[g"", """");
    StringUtils.isWhitespace(""Dy_r=Wr2"");
}","/**
 * <p>Checks if the CharSequence contains only whitespace.</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty CharSequence (length()=0) will return {@code true}.</p>
 *
 * <pre>
 * StringUtils.isWhitespace(null)   = false
 * StringUtils.isWhitespace("""")     = true
 * StringUtils.isWhitespace(""  "")   = true
 * StringUtils.isWhitespace(""abc"")  = false
 * StringUtils.isWhitespace(""ab2c"") = false
 * StringUtils.isWhitespace(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if only contains whitespace, and is non-null
 * @since 2.0
 * @since 3.0 Changed signature from isWhitespace(String) to isWhitespace(CharSequence)
 */"
"// Misc
//-----------------------------------------------------------------------
/**
 * <p>Find the Levenshtein distance between two Strings.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>The previous implementation of the Levenshtein distance algorithm
 * was from <a href=""http://www.merriampark.com/ld.htm"">http://www.merriampark.com/ld.htm</a></p>
 *
 * <p>Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError
 * which can occur when my Java implementation is used with very large strings.<br>
 * This implementation of the Levenshtein distance algorithm
 * is from <a href=""http://www.merriampark.com/ldjava.htm"">http://www.merriampark.com/ldjava.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("""","""")               = 0
 * StringUtils.getLevenshteinDistance("""",""a"")              = 1
 * StringUtils.getLevenshteinDistance(""aaapppp"", """")       = 7
 * StringUtils.getLevenshteinDistance(""frog"", ""fog"")       = 1
 * StringUtils.getLevenshteinDistance(""fly"", ""ant"")        = 3
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""zzzzzzzz"") = 8
 * StringUtils.getLevenshteinDistance(""hello"", ""hallo"")    = 1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @return result distance
 * @throws IllegalArgumentException if either String input {@code null}
 * @since 3.0 Changed signature from getLevenshteinDistance(String, String) to
 * getLevenshteinDistance(CharSequence, CharSequence)
 */
public static int getLevenshteinDistance(CharSequence s, CharSequence t) {
    if (s == null || t == null) {
        throw new IllegalArgumentException(""Strings must not be null"");
    }
    /*
           The difference between this impl. and the previous is that, rather
           than creating and retaining a matrix of size s.length() + 1 by t.length() + 1,
           we maintain two single-dimensional arrays of length s.length() + 1.  The first, d,
           is the 'current working' distance array that maintains the newest distance cost
           counts as we iterate through the characters of String s.  Each time we increment
           the index of String t we are comparing, d is copied to p, the second int[].  Doing so
           allows us to retain the previous cost counts as required by the algorithm (taking
           the minimum of the cost count to the left, up one, and diagonally up and to the left
           of the current cost count being calculated).  (Note that the arrays aren't really
           copied anymore, just switched...this is clearly much better than cloning an array
           or doing a System.arraycopy() each time  through the outer loop.)

           Effectively, the difference between the two implementations is this one does not
           cause an out of memory condition when calculating the LD over two very large strings.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    if (n == 0) {
        return m;
    } else if (m == 0) {
        return n;
    }
    if (n > m) {
        // swap the input strings to consume less memory
        CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    //'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    //placeholder to assist in swapping p and d
    int[] _d;
    // indexes into strings s and t
    // iterates through s
    int i;
    // iterates through t
    int j;
    // jth character of t
    char t_j;
    // cost
    int cost;
    for (i = 0; i <= n; i++) {
        p[i] = i;
    }
    for (j = 1; j <= m; j++) {
        t_j = t.charAt(j - 1);
        d[0] = j;
        for (i = 1; i <= n; i++) {
            cost = s.charAt(i - 1) == t_j ? 0 : 1;
            // minimum of cell to the left+1, to the top+1, diagonally left and up +cost
            d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost);
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // our last action in the above loop was to switch d and p, so p now
    // actually has the most recent cost counts
    return p[n];
}","public void test01729() throws Throwable {
    StringUtils.splitByCharacterType(""#QZ&D \""l"");
    StringUtils.indexOfIgnoreCase((CharSequence) ""#QZ&D \""l"", (CharSequence) ""#QZ&D \""l"");
    StringUtils.abbreviateMiddle((String) null, (String) null, 0);
    StringUtils.stripEnd(""#QZ&D \""l"", ""#QZ&D \""l"");
    StringUtils.rightPad(""#QZ&D \""l"", 43, ""r"");
    StringUtils.stripAccents(""#QZ&D \""l"");
    StringUtils.trimToNull(""#QZ&D \""l"");
    StringUtils.indexOfIgnoreCase((CharSequence) null, (CharSequence) null);
    StringUtils.center(""^%OBe<1l?5a]:LA7I7d"", 19, 'y');
    StringUtils.ordinalIndexOf((CharSequence) null, ""^%OBe<1l?5a]:LA7I7d"", (-1683));
    StringUtils.substring("")D<^x)lb;rM3r"", (-1), (-1));
    StringUtils.contains((CharSequence) ""^%OBe<1l?5a]:LA7I7d"", (CharSequence) ""^%OBe<1l?5a]:LA7I7d"");
    StringUtils.overlay(""The Character must not be null"", ""ntrRV0~NI"", (-1683), 30);
    StringUtils.contains((CharSequence) """", (CharSequence) ""#QZ&D \""l"");
    StringUtils.indexOfIgnoreCase((CharSequence) ""^%OBe<1l?5a]:LA7I7d"", (CharSequence) ""r"", 3415);
    StringUtils.center((String) null, 0, ""rr[Y1jd lPy*oG !J-?7SyC"");
    // Undeclared exception!
    try {
        StringUtils.getLevenshteinDistance((CharSequence) ""^%OBe<1l?5a]:LA7I7d"", (CharSequence) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Strings must not be null
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}",""
"public static String join(Object[] array, String separator, int startIndex, int endIndex) {
    if (array == null) {
        return null;
    }
    if (separator == null) {
        separator = EMPTY;
    }
    // endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))
    //           (Assuming that all Strings are roughly equally long)
    int noOfItems = (endIndex - startIndex);
    if (noOfItems <= 0) {
        return EMPTY;
    }
    StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}","public void test01830() throws Throwable {
    StringUtils.replace(""The character must not be null"", ""The character must not be null"", ""JBk!9Wqn4z(JBk!9Wqn4z("", (-1212));
    StringUtils.equals((CharSequence) ""JBk!9Wqn4z(JBk!9Wqn4z("", (CharSequence) ""The character must not be null"");
    StringUtils.rightPad(""Ibg"", (-1212), ""JBk!9Wqn4z(JBk!9Wqn4z("");
    StringUtils.removeEnd(""FF[zjaSYY>[-=pDMZi"", ""Ibg"");
    StringUtils.removeStart(""\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000B\f\r\u000E\u000F\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001A\u001B\u001C\u001D\u001E\u001F !\""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}~"", "" is less than 0: "");
    StringUtils.remove("""", 'H');
    StringUtils.trimToEmpty(""Ibg"");
    Object[] objectArray0 = new Object[4];
    objectArray0[0] = (Object) "" is less than 0: "";
    objectArray0[1] = (Object) ""Ibg"";
    objectArray0[2] = (Object) ""Ibg"";
    objectArray0[3] = (Object) ""Ibg"";
    StringUtils.join(objectArray0, ""Ibg"", (-1212), (-1212));
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A {@code null} separator is the same as an empty String ("""").
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)                = null
 * StringUtils.join([], *)                  = """"
 * StringUtils.join([null], *)              = """"
 * StringUtils.join([""a"", ""b"", ""c""], ""--"")  = ""a--b--c""
 * StringUtils.join([""a"", ""b"", ""c""], null)  = ""abc""
 * StringUtils.join([""a"", ""b"", ""c""], """")    = ""abc""
 * StringUtils.join([null, """", ""a""], ',')   = "",,a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @param startIndex the first index to start joining from.  It is
 * an error to pass in an end index past the end of the array
 * @param endIndex the index to stop joining from (exclusive). It is
 * an error to pass in an end index past the end of the array
 * @return the joined String, {@code null} if null array input
 */"
"public static boolean isAllLowerCase(CharSequence cs) {
    if (cs == null || isEmpty(cs)) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isLowerCase(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test01931() throws Throwable {
    StringUtils.chomp(""JBk!9Wqn4z("", ""JBk!9Wqn4z("");
    StringUtils.isAsciiPrintable(""JBk!9Wqn4z("");
    StringUtils.defaultIfEmpty((CharBuffer) null, (CharBuffer) null);
    StringUtils.defaultString(""%,F*,8W?<%"");
    Stack<CharBuffer> stack0 = new Stack<CharBuffer>();
    stack0.push((CharBuffer) null);
    stack0.add((CharBuffer) null);
    ListIterator<CharBuffer> listIterator0 = stack0.listIterator();
    StringUtils.join((Iterator<?>) listIterator0, ""JBk!9Wqn4z("");
    StringUtils.isAllLowerCase(""%,F*,8W?<%"");
}","/**
 * <p>Checks if the CharSequence contains only lowercase characters.</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty CharSequence (length()=0) will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.isAllLowerCase(null)   = false
 * StringUtils.isAllLowerCase("""")     = false
 * StringUtils.isAllLowerCase(""  "")   = false
 * StringUtils.isAllLowerCase(""abc"")  = true
 * StringUtils.isAllLowerCase(""abC"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if only contains lowercase characters, and is non-null
 * @since 2.5
 * @since 3.0 Changed signature from isAllLowerCase(String) to isAllLowerCase(CharSequence)
 */"
"public static boolean endsWithAny(CharSequence string, CharSequence... searchStrings) {
    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {
        return false;
    }
    for (int i = 0; i < searchStrings.length; i++) {
        CharSequence searchString = searchStrings[i];
        if (StringUtils.endsWith(string, searchString)) {
            return true;
        }
    }
    return false;
}","public void test02032() throws Throwable {
    StringUtils.chomp("""", """");
    StringUtils.removeStartIgnoreCase(""(Rnu{iF%.J^M#D"", ""(Rnu{iF%.J^M#D"");
    StringUtils.deleteWhitespace(""(Rnu{iF%.J^M#D"");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""(Rnu{iF%.J^M#D"", ""decompose"", 0);
    String string0 = StringUtils.rightPad("""", 1462, ""SecurityException occurred"");
    StringUtils.capitalize(""XOq)"");
    StringUtils.removeStartIgnoreCase("""", ""I9"");
    StringUtils.uncapitalize(""X%#c{u7-q"");
    String string1 = ""\\u00"";
    StringUtils.substringBetween("""", string1, ""I9"");
    StringUtils.indexOfAny((CharSequence) ""decompose"", ""7L4i=QvvR#D"");
    int int0 = new Integer((-1));
    StringUtils.indexOfDifference((CharSequence) """", (CharSequence) ""I9"");
    StringUtils.center(string1, 2328);
    StringUtils.countMatches(""decompose"", string1);
    StringUtils.trimToEmpty(string0);
    StringUtils.endsWithAny(""I9"", stringArray0);
}","/**
 * <p>Check if a CharSequence ends with any of an array of specified strings.</p>
 *
 * <pre>
 * StringUtils.endsWithAny(null, null)      = false
 * StringUtils.endsWithAny(null, new String[] {""abc""})  = false
 * StringUtils.endsWithAny(""abcxyz"", null)     = false
 * StringUtils.endsWithAny(""abcxyz"", new String[] {""""}) = true
 * StringUtils.endsWithAny(""abcxyz"", new String[] {""xyz""}) = true
 * StringUtils.endsWithAny(""abcxyz"", new String[] {null, ""xyz"", ""abc""}) = true
 * </pre>
 *
 * @param string  the CharSequence to check, may be null
 * @param searchStrings the CharSequences to find, may be null or empty
 * @return {@code true} if the CharSequence ends with any of the the prefixes, case insensitive, or
 *  both {@code null}
 * @since 3.0
 */"
"public static int indexOfIgnoreCase(CharSequence str, CharSequence searchStr) {
    return indexOfIgnoreCase(str, searchStr, 0);
}","public void test02133() throws Throwable {
    StringUtils.replaceChars(""8bEhDCywIDUxL'YBr"", ""8bEhDCywIDUxL'YBr"", ""8bEhDCywIDUxL'YBr"");
    StringUtils.splitPreserveAllTokens("" iI'(B)EZP7J6;JS@o"", ""8bEhDCywIDUxL'YBr"");
    String[] stringArray0 = StringUtils.splitByCharacterTypeCamelCase(""8bEhDCywIDUxL'YBr"");
    StringUtils.stripAll(stringArray0, "")/r2R?"");
    StringUtils.upperCase(""8bEhDCywIDUxL'YBr"");
    StringUtils.swapCase(""<{S'x_Id_QlqU"");
    StringUtils.split("" iI'(B)EZP7J6;JS@o"");
    char[] charArray0 = new char[7];
    charArray0[0] = 'R';
    charArray0[1] = '8';
    StringUtils.containsOnly((CharSequence) ""8BEHDCYWIDUXL'YBR"", charArray0);
    StringUtils.equalsIgnoreCase(""8bEhDCywIDUxL'YBr"", ""8BEHDCYWIDUXL'YBR"");
    StringUtils.splitPreserveAllTokens(""8bEhDCywIDUxL'YBr"", '\\');
    StringUtils.countMatches(""<{S'x_Id_QlqU"", "" iI'(B)EZP7J6;JS@o"");
    StringUtils.substring(""<{s'X_iD_qLQu"", 2147483637);
    StringUtils.abbreviate(""8bEhDCywIDUxL'YBr"", 7, 12);
    StringUtils.right(""8bEhDCywIDUxL'YBr"", 10);
    StringUtils.indexOfIgnoreCase((CharSequence) ""<{s'X_iD_qLQu"", (CharSequence) ""8bEhDCywIDUxL'YBr"");
}","/**
 * <p>Case in-sensitive find of the first index within a CharSequence.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A negative start position is treated as zero.
 * An empty ("""") search CharSequence always matches.
 * A start position greater than the string length only matches
 * an empty search CharSequence.</p>
 *
 * <pre>
 * StringUtils.indexOfIgnoreCase(null, *)          = -1
 * StringUtils.indexOfIgnoreCase(*, null)          = -1
 * StringUtils.indexOfIgnoreCase("""", """")           = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""a"")  = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""b"")  = 2
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""ab"") = 1
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @return the first index of the search CharSequence,
 *  -1 if no match or {@code null} string input
 * @since 2.5
 * @since 3.0 Changed signature from indexOfIgnoreCase(String, String) to indexOfIgnoreCase(CharSequence, CharSequence)
 */"
"public static String normalizeSpace(String str) {
    if (str == null) {
        return null;
    }
    return WHITESPACE_BLOCK.matcher(trim(str)).replaceAll("" "");
}","public void test02234() throws Throwable {
    StringUtils.substringsBetween(""Exception cloning Cloneable type "", ""Exception cloning Cloneable type "", ""Exception cloning Cloneable type "");
    StringUtils.stripEnd((String) null, (String) null);
    StringUtils.getCommonPrefix((String[]) null);
    StringUtils.isAlphanumericSpace(""Exception cloning Cloneable type "");
    StringUtils.center((String) null, (-152));
    StringUtils.swapCase((String) null);
    StringUtils.isNumericSpace((CharSequence) null);
    StringUtils.difference((String) null, (String) null);
    StringUtils.lastIndexOf((CharSequence) null, 34, (-152));
    StringUtils.repeat((String) null, 4);
    StringUtils.contains((CharSequence) null, 26);
    StringUtils.countMatches((CharSequence) null, (CharSequence) null);
    StringUtils.defaultString(""[<jH!8Sq#P){o>km"");
    StringUtils.difference((String) null, ""[<jH!8Sq#P){o>km"");
    StringUtils.chop(""[<jH!8Sq#P){o>km"");
    StringUtils.removeStart((String) null, ""l9"");
    StringUtils.removeStart(""[<jH!8Sq#P){o>km"", ""Da=3q"");
    StringUtils.abbreviate((String) null, (-1), (-152));
    StringUtils.isAllUpperCase((CharSequence) null);
    StringUtils.defaultIfBlank((String) null, (String) null);
    StringUtils.countMatches((CharSequence) null, (CharSequence) null);
    StringUtils.normalizeSpace((String) null);
}","/**
 * <p>
 * Similar to <a
 * href=""http://www.w3.org/TR/xpath/#function-normalize-space"">http://www.w3.org/TR/xpath/#function-normalize
 * -space</a>
 * </p>
 * <p>
 * The function returns the argument string with whitespace normalized by using
 * <code>{@link #trim(String)}</code> to remove leading and trailing whitespace
 * and then replacing sequences of whitespace characters by a single space.
 * </p>
 * In XML Whitespace characters are the same as those allowed by the <a
 * href=""http://www.w3.org/TR/REC-xml/#NT-S"">S</a> production, which is S ::= (#x20 | #x9 | #xD | #xA)+
 * <p>
 * Java's regexp pattern \s defines whitespace as [ \t\n\x0B\f\r]
 * <p>
 * For reference:
 * <ul>
 * <li>\x0B = vertical tab</li>
 * <li>\f = #xC = form feed</li>
 * <li>#x20 = space</li>
 * <li>#x9 = \t</li>
 * <li>#xA = \n</li>
 * <li>#xD = \r</li>
 * </ul>
 * </p>
 * <p>
 * The difference is that Java's whitespace includes vertical tab and form feed, which this functional will also
 * normalize. Additonally <code>{@link #trim(String)}</code> removes control characters (char &lt;= 32) from both
 * ends of this String.
 * </p>
 *
 * @see Pattern
 * @see #trim(String)
 * @see <a
 *      href=""http://www.w3.org/TR/xpath/#function-normalize-space"">http://www.w3.org/TR/xpath/#function-normalize-space</a>
 * @param str the source String to normalize whitespaces from, may be null
 * @return the modified string with whitespace normalized, {@code null} if null String input
 *
 * @since 3.0
 */"
"public static String abbreviateMiddle(String str, String middle, int length) {
    if (isEmpty(str) || isEmpty(middle)) {
        return str;
    }
    if (length >= str.length() || length < (middle.length() + 2)) {
        return str;
    }
    int targetSting = length - middle.length();
    int startOffset = targetSting / 2 + targetSting % 2;
    int endOffset = str.length() - targetSting / 2;
    StringBuilder builder = new StringBuilder(length);
    builder.append(str.substring(0, startOffset));
    builder.append(middle);
    builder.append(str.substring(endOffset));
    return builder.toString();
}","public void test02335() throws Throwable {
    StringUtils.stripToNull(""F`J"");
    StringUtils.stripAccents(""org.apache.commons.lang3.ArrayUtils"");
    StringUtils.ordinalIndexOf(""F`J"", ""F`J"", 4);
    StringUtils.chomp(""?9zT[Qj6M"", ""_w[IYfF9g^Av33Q6"");
    StringUtils.isBlank(""_w[IYfF9g^Av33Q6"");
    String[] stringArray0 = new String[2];
    stringArray0[0] = ""org.apache.commons.lang3.ArrayUtils"";
    stringArray0[1] = ""F`J"";
    StringUtils.stripAll(stringArray0, ""F`J"");
    StringUtils.substringBetween(""org.apache.commons.lang3.ArrayUtils"", ""%e"", ""'L*RLDq-xjDcd9L"");
    StringUtils.indexOfAnyBut((CharSequence) ""F`J"", (CharSequence) ""org.apache.commons.lang3.ArrayUtils"");
    StringUtils.swapCase(""%e"");
    char[] charArray0 = new char[4];
    charArray0[0] = 'k';
    charArray0[1] = 'Q';
    charArray0[2] = 'Z';
    charArray0[3] = 'o';
    StringUtils.containsAny((CharSequence) ""?9zT[Qj6M"", charArray0);
    StringUtils.getCommonPrefix(stringArray0);
    StringUtils.abbreviateMiddle(""|`?_p[g"", ""%e"", 4);
}","/**
 * <p>Abbreviates a String to the length passed, replacing the middle characters with the supplied
 * replacement String.</p>
 *
 * <p>This abbreviation only occurs if the following criteria is met:
 * <ul>
 * <li>Neither the String for abbreviation nor the replacement String are null or empty </li>
 * <li>The length to truncate to is less than the length of the supplied String</li>
 * <li>The length to truncate to is greater than 0</li>
 * <li>The abbreviated String will have enough room for the length supplied replacement String
 * and the first and last characters of the supplied String for abbreviation</li>
 * </ul>
 * Otherwise, the returned String will be the same as the supplied String for abbreviation.
 * </p>
 *
 * <pre>
 * StringUtils.abbreviateMiddle(null, null, 0)      = null
 * StringUtils.abbreviateMiddle(""abc"", null, 0)      = ""abc""
 * StringUtils.abbreviateMiddle(""abc"", ""."", 0)      = ""abc""
 * StringUtils.abbreviateMiddle(""abc"", ""."", 3)      = ""abc""
 * StringUtils.abbreviateMiddle(""abcdef"", ""."", 4)     = ""ab.f""
 * </pre>
 *
 * @param str  the String to abbreviate, may be null
 * @param middle the String to replace the middle characters with, may be null
 * @param length the length to abbreviate {@code str} to.
 * @return the abbreviated String if the above criteria is met, or the original String supplied for abbreviation.
 * @since 2.5
 */"
"public static String upperCase(String str, Locale locale) {
    if (str == null) {
        return null;
    }
    return str.toUpperCase(locale);
}","public void test02436() throws Throwable {
    StringUtils.replaceEachRepeatedly(""p{InCombiningDiacriticalMarks}+"", (String[]) null, (String[]) null);
    StringUtils.indexOfAny((CharSequence) ""p{InCombiningDiacriticalMarks}+"", (CharSequence[]) null);
    StringUtils.indexOfAnyBut((CharSequence) ""p{InCombiningDiacriticalMarks}+"", (CharSequence) ""p{InCombiningDiacriticalMarks}+"");
    StringUtils.equalsIgnoreCase(""p{InCombiningDiacriticalMarks}+"", ""p{InCombiningDiacriticalMarks}+"");
    StringUtils.center(""p{InCombiningDiacriticalMarks}+"", (-1), '\""');
    char[] charArray0 = new char[2];
    charArray0[0] = '\""';
    charArray0[1] = '\""';
    StringUtils.containsAny((CharSequence) ""p{InCombiningDiacriticalMarks}+"", charArray0);
    Locale locale0 = Locale.JAPANESE;
    StringUtils.upperCase((String) null, locale0);
}","/**
 * <p>Converts a String to upper case as per {@link String#toUpperCase(Locale)}.</p>
 *
 * <p>A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.upperCase(null, Locale.ENGLISH)  = null
 * StringUtils.upperCase("""", Locale.ENGLISH)    = """"
 * StringUtils.upperCase(""aBc"", Locale.ENGLISH) = ""ABC""
 * </pre>
 *
 * @param str  the String to upper case, may be null
 * @param locale  the locale that defines the case transformation rules, must not be null
 * @return the upper cased String, {@code null} if null String input
 * @since 2.5
 */"
"public static int indexOfDifference(CharSequence... css) {
    if (css == null || css.length <= 1) {
        return INDEX_NOT_FOUND;
    }
    boolean anyStringNull = false;
    boolean allStringsNull = true;
    int arrayLen = css.length;
    int shortestStrLen = Integer.MAX_VALUE;
    int longestStrLen = 0;
    // find the min and max string lengths; this avoids checking to make
    // sure we are not exceeding the length of the string each time through
    // the bottom loop.
    for (int i = 0; i < arrayLen; i++) {
        if (css[i] == null) {
            anyStringNull = true;
            shortestStrLen = 0;
        } else {
            allStringsNull = false;
            shortestStrLen = Math.min(css[i].length(), shortestStrLen);
            longestStrLen = Math.max(css[i].length(), longestStrLen);
        }
    }
    // handle lists containing all nulls or all empty strings
    if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) {
        return INDEX_NOT_FOUND;
    }
    // handle lists containing some nulls or some empty strings
    if (shortestStrLen == 0) {
        return 0;
    }
    // find the position with the first difference across all strings
    int firstDiff = -1;
    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {
        char comparisonChar = css[0].charAt(stringPos);
        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {
            if (css[arrayPos].charAt(stringPos) != comparisonChar) {
                firstDiff = stringPos;
                break;
            }
        }
        if (firstDiff != -1) {
            break;
        }
    }
    if (firstDiff == -1 && shortestStrLen != longestStrLen) {
        // we compared all of the characters up to the length of the
        // shortest string and didn't find a match, but the string lengths
        // vary, so return the length of the shortest string.
        return shortestStrLen;
    }
    return firstDiff;
}","public void test02537() throws Throwable {
    StringUtils.capitalize(""|`?_p[g"");
    StringUtils.isAlphaSpace(""|`?_p[g"");
    String[] stringArray0 = new String[5];
    stringArray0[0] = ""|`?_p[g"";
    stringArray0[1] = ""|`?_p[g"";
    stringArray0[2] = ""|`?_p[g"";
    stringArray0[3] = ""Dy_r=Wr2"";
    stringArray0[4] = ""|`?_p[g"";
    StringUtils.getCommonPrefix(stringArray0);
    StringUtils.defaultIfEmpty(""|`?_p[g"", """");
    StringUtils.containsIgnoreCase(""|`?_p[g"", ""|`?_p[g"");
    StringUtils.containsAny((CharSequence) ""Dy_r=Wr2"", (CharSequence) ""|`?_p[g"");
    StringUtils.isAlpha(""|`?_p[g"");
    StringUtils.rightPad("""", (-379), 'b');
    String[] stringArray1 = StringUtils.stripAll(stringArray0);
    StringUtils.isNumericSpace(""|`?_p[g"");
    StringUtils.reverseDelimited(""Dy_r=Wr2"", '8');
    StringUtils.endsWithAny(""Dy_r=Wr2"", stringArray0);
    String[] stringArray2 = StringUtils.splitByWholeSeparator(""}@s`E{_"", ""Dy_r=Wr2"");
    StringUtils.substringBefore("""", ""Dy_r=Wr2"");
    StringUtils.join((Object[]) stringArray0, """");
    StringUtils.splitByWholeSeparator(""Dy_r=Wr2"", ""Dy_r=Wr2"", (-379));
    StringUtils.replaceEach("""", stringArray2, stringArray0);
    StringUtils.repeat((String) null, (String) null, (-379));
    StringUtils.replace("""", ""Dy_r=Wr2"", """");
    StringUtils.indexOfDifference((CharSequence[]) stringArray1);
}","/**
 * <p>Compares all CharSequences in an array and returns the index at which the
 * CharSequences begin to differ.</p>
 *
 * <p>For example,
 * <code>indexOfDifference(new String[] {""i am a machine"", ""i am a robot""}) -> 7</code></p>
 *
 * <pre>
 * StringUtils.indexOfDifference(null) = -1
 * StringUtils.indexOfDifference(new String[] {}) = -1
 * StringUtils.indexOfDifference(new String[] {""abc""}) = -1
 * StringUtils.indexOfDifference(new String[] {null, null}) = -1
 * StringUtils.indexOfDifference(new String[] {"""", """"}) = -1
 * StringUtils.indexOfDifference(new String[] {"""", null}) = 0
 * StringUtils.indexOfDifference(new String[] {""abc"", null, null}) = 0
 * StringUtils.indexOfDifference(new String[] {null, null, ""abc""}) = 0
 * StringUtils.indexOfDifference(new String[] {"""", ""abc""}) = 0
 * StringUtils.indexOfDifference(new String[] {""abc"", """"}) = 0
 * StringUtils.indexOfDifference(new String[] {""abc"", ""abc""}) = -1
 * StringUtils.indexOfDifference(new String[] {""abc"", ""a""}) = 1
 * StringUtils.indexOfDifference(new String[] {""ab"", ""abxyz""}) = 2
 * StringUtils.indexOfDifference(new String[] {""abcde"", ""abxyz""}) = 2
 * StringUtils.indexOfDifference(new String[] {""abcde"", ""xyz""}) = 0
 * StringUtils.indexOfDifference(new String[] {""xyz"", ""abcde""}) = 0
 * StringUtils.indexOfDifference(new String[] {""i am a machine"", ""i am a robot""}) = 7
 * </pre>
 *
 * @param css  array of CharSequences, entries may be null
 * @return the index where the strings begin to differ; -1 if they are all equal
 * @since 2.4
 * @since 3.0 Changed signature from indexOfDifference(String...) to indexOfDifference(CharSequence...)
 */"
"// IndexOfAny chars
//-----------------------------------------------------------------------
/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A {@code null} String will return {@code -1}.
 * A {@code null} or zero length search array will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)                = -1
 * StringUtils.indexOfAny("""", *)                  = -1
 * StringUtils.indexOfAny(*, null)                = -1
 * StringUtils.indexOfAny(*, [])                  = -1
 * StringUtils.indexOfAny(""zzabyycdxx"",['z','a']) = 0
 * StringUtils.indexOfAny(""zzabyycdxx"",['b','y']) = 3
 * StringUtils.indexOfAny(""aba"", ['z'])           = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAny(String, char[]) to indexOfAny(CharSequence, char...)
 */
public static int indexOfAny(CharSequence cs, char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int csLen = cs.length();
    int csLast = csLen - 1;
    int searchLen = searchChars.length;
    int searchLast = searchLen - 1;
    for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
                    // ch is a supplementary character
                    if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        return i;
                    }
                } else {
                    return i;
                }
            }
        }
    }
    return INDEX_NOT_FOUND;
}","public void test02638() throws Throwable {
    StringUtils.rightPad(""SecurityException occurred"", 732, ""J?(JzYNZQ"");
    StringUtils.endsWithIgnoreCase(""SecurityException occurredJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(J"", ""J?(JzYNZQ"");
    Object[] objectArray0 = new Object[1];
    objectArray0[0] = (Object) ""J?(JzYNZQ"";
    StringUtils.join(objectArray0, '|');
    CharBuffer charBuffer0 = CharBuffer.allocate('|');
    CharBuffer charBuffer1 = StringUtils.defaultIfEmpty(charBuffer0, charBuffer0);
    StringUtils.replace("""", ""J?(JzYNZQ"", "" O"");
    StringUtils.contains((CharSequence) """", (CharSequence) "" O"");
    StringUtils.split(""SecurityException occurred"", 'o');
    StringUtils.split("""", "" O"", (-950));
    StringUtils.isAlphanumericSpace(charBuffer0);
    StringUtils.lastIndexOf((CharSequence) "" O"", (CharSequence) "" O"", 732);
    StringUtils.indexOf((CharSequence) charBuffer0, (CharSequence) charBuffer1);
    StringUtils.substring(""SecurityException occurred"", (-950));
    StringUtils.lowerCase("""");
    StringUtils.isWhitespace(""J?(JzYNZQ"");
    StringUtils.substringBefore(""wz}"", ""SecurityException occurred"");
    StringUtils.deleteWhitespace(""SecurityException occurredJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(J"");
    StringUtils.isAlphanumericSpace(""J?(JzYNZQ"");
    StringUtils.upperCase("""");
    StringUtils.isEmpty("""");
    StringUtils.right("""", 0);
    char[] charArray0 = new char[8];
    charArray0[0] = '|';
    charArray0[1] = 'o';
    charArray0[2] = 'o';
    charArray0[3] = '\""';
    charArray0[4] = '|';
    charArray0[5] = '|';
    charArray0[6] = 'o';
    charArray0[7] = '|';
    StringUtils.indexOfAny((CharSequence) """", charArray0);
}",""
"// IndexOfAny strings
//-----------------------------------------------------------------------
/**
 * <p>Find the first index of any of a set of potential substrings.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A {@code null} or zero length search array will return {@code -1}.
 * A {@code null} search array entry will be ignored, but a search
 * array containing """" will return {@code 0} if {@code str} is not
 * null. This method uses {@link String#indexOf(String)} if possible.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)                     = -1
 * StringUtils.indexOfAny(*, null)                     = -1
 * StringUtils.indexOfAny(*, [])                       = -1
 * StringUtils.indexOfAny(""zzabyycdxx"", [""ab"",""cd""])   = 2
 * StringUtils.indexOfAny(""zzabyycdxx"", [""cd"",""ab""])   = 2
 * StringUtils.indexOfAny(""zzabyycdxx"", [""mn"",""op""])   = -1
 * StringUtils.indexOfAny(""zzabyycdxx"", [""zab"",""aby""]) = 1
 * StringUtils.indexOfAny(""zzabyycdxx"", [""""])          = 0
 * StringUtils.indexOfAny("""", [""""])                    = 0
 * StringUtils.indexOfAny("""", [""a""])                   = -1
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStrs  the CharSequences to search for, may be null
 * @return the first index of any of the searchStrs in str, -1 if no match
 * @since 3.0 Changed signature from indexOfAny(String, String[]) to indexOfAny(CharSequence, CharSequence...)
 */
public static int indexOfAny(CharSequence str, CharSequence... searchStrs) {
    if (str == null || searchStrs == null) {
        return INDEX_NOT_FOUND;
    }
    int sz = searchStrs.length;
    // String's can't have a MAX_VALUEth index.
    int ret = Integer.MAX_VALUE;
    int tmp = 0;
    for (int i = 0; i < sz; i++) {
        CharSequence search = searchStrs[i];
        if (search == null) {
            continue;
        }
        tmp = CharSequenceUtils.indexOf(str, search, 0);
        if (tmp == INDEX_NOT_FOUND) {
            continue;
        }
        if (tmp < ret) {
            ret = tmp;
        }
    }
    return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret;
}","public void test02739() throws Throwable {
    StringUtils.replaceChars(""8bEhDCywIDUxL'YBr"", ""8bEhDCywIDUxL'YBr"", ""8bEhDCywIDUxL'YBr"");
    StringUtils.splitPreserveAllTokens("" iI'(B)EZP7J6;JS@o"", ""8bEhDCywIDUxL'YBr"");
    String[] stringArray0 = StringUtils.splitByCharacterTypeCamelCase(""8bEhDCywIDUxL'YBr"");
    String[] stringArray1 = StringUtils.stripAll(stringArray0, "")/r2R?"");
    StringUtils.swapCase(""<{'a_Id_QlqU"");
    char[] charArray0 = new char[2];
    charArray0[1] = '8';
    StringUtils.containsOnly((CharSequence) ""8bEhDCywIDUxL'YBr"", charArray0);
    StringUtils.equalsIgnoreCase(""8bEhDCywIDUxL'YBr"", ""8bEhDCywIDUxL'YBr"");
    StringUtils.countMatches(""<{'a_Id_QlqU"", "" iI'(B)EZP7J6;JS@o"");
    StringUtils.substring(""<{'A_iD_qLQu"", Integer.MAX_VALUE);
    StringUtils.abbreviate(""8bEhDCywIDUxL'YBr"", 20, 12);
    StringUtils.right(""8bEhDCywIDUxL'YBr"", 10);
    StringUtils.indexOfIgnoreCase((CharSequence) ""<{'A_iD_qLQu"", (CharSequence) ""8bEhDCywIDUxL'YBr"");
    StringUtils.lastIndexOfIgnoreCase((CharSequence) ""<{'a_Id_QlqU"", (CharSequence) ""...IDUxL'YBr"", 0);
    StringUtils.indexOfAny((CharSequence) ""...IDUxL'YBr"", (CharSequence[]) stringArray1);
}",""
"public static int lastIndexOfAny(CharSequence str, CharSequence... searchStrs) {
    if (str == null || searchStrs == null) {
        return INDEX_NOT_FOUND;
    }
    int sz = searchStrs.length;
    int ret = INDEX_NOT_FOUND;
    int tmp = 0;
    for (int i = 0; i < sz; i++) {
        CharSequence search = searchStrs[i];
        if (search == null) {
            continue;
        }
        tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());
        if (tmp > ret) {
            ret = tmp;
        }
    }
    return ret;
}","public void test02840() throws Throwable {
    StringUtils.stripStart(""3V-I1BCfBR"", ""?Z"");
    int int0 = StringUtils.INDEX_NOT_FOUND;
    StringUtils.abbreviate(""rr[1jd lPy*G !J-?7SyC"", (-1), 2060);
    StringUtils.isAlphaSpace(""rr[1jd lPy*G !J-?7SyC"");
    CharSequence[] charSequenceArray0 = new CharSequence[1];
    charSequenceArray0[0] = (CharSequence) ""rr[1jd lPy*G !J-?7SyC"";
    StringUtils.indexOfAny((CharSequence) ""?Z"", charSequenceArray0);
    StringUtils.defaultIfBlank("",F*,8W?<%"", (String) null);
    StringUtils.indexOfAny((CharSequence) null, charSequenceArray0);
    StringUtils.remove("""", ""rr[1jd lPy*G !J-?7SyC"");
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""3V-I1BCfBR"";
    stringArray0[1] = "",F*,8W?<%"";
    stringArray0[2] = ""3V-I1BCfBR"";
    StringUtils.getCommonPrefix(stringArray0);
    StringUtils.lastIndexOfAny(charSequenceArray0[0], stringArray0);
    StringUtils.trimToNull(""3V-I1BCfBR"");
    StringUtils.abbreviateMiddle(""The Array must not be null"", ""3V-I1BCfBR"", (-1));
    StringUtils.normalizeSpace("",F*,8W?<%"");
    StringUtils.splitByWholeSeparator("""", (String) null);
    StringUtils.repeat(""The Array must not be null"", (-1512));
    CharSequence[] charSequenceArray1 = new CharSequence[0];
    StringUtils.startsWithAny("",F*,8W?<%"", charSequenceArray1);
    StringUtils.remove(""{}"", ""(m'~h1DlVpMUe"");
    StringUtils.lastIndexOfAny(""{}"", charSequenceArray0);
}","/**
 * <p>Find the latest index of any of a set of potential substrings.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A {@code null} search array will return {@code -1}.
 * A {@code null} or zero length search array entry will be ignored,
 * but a search array containing """" will return the length of {@code str}
 * if {@code str} is not null. This method uses {@link String#indexOf(String)} if possible</p>
 *
 * <pre>
 * StringUtils.lastIndexOfAny(null, *)                   = -1
 * StringUtils.lastIndexOfAny(*, null)                   = -1
 * StringUtils.lastIndexOfAny(*, [])                     = -1
 * StringUtils.lastIndexOfAny(*, [null])                 = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""ab"",""cd""]) = 6
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""cd"",""ab""]) = 6
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""op""]) = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""op""]) = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""""])   = 10
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStrs  the CharSequences to search for, may be null
 * @return the last index of any of the CharSequences, -1 if no match
 * @since 3.0 Changed signature from lastIndexOfAny(String, String[]) to lastIndexOfAny(CharSequence, CharSequence)
 */"
"public static String substring(String str, int start, int end) {
    if (str == null) {
        return null;
    }
    // handle negatives
    if (end < 0) {
        // remember end is negative
        end = str.length() + end;
    }
    if (start < 0) {
        // remember start is negative
        start = str.length() + start;
    }
    // check length next
    if (end > str.length()) {
        end = str.length();
    }
    // if start is greater than end, return """"
    if (start > end) {
        return EMPTY;
    }
    if (start < 0) {
        start = 0;
    }
    if (end < 0) {
        end = 0;
    }
    return str.substring(start, end);
}","public void test02941() throws Throwable {
    StringUtils.substringBetween("" vs "", "" vs "", ""FF[zjaSYY>[-=pDMZiIbg"");
    StringUtils.stripToNull(""FfD` Z/yI1~7u];S["");
    StringUtils.substringBefore(""FfD` Z/yI1~7u];S["", ""TimeToLive of "");
    StringUtils.substringBeforeLast(""8B<o&y1[X-fL4,6u"", ""FfD` Z/yI1~7u];S["");
    StringUtils.indexOfIgnoreCase((CharSequence) ""FfD` Z/yI1~7u];S["", (CharSequence) ""8B<o&y1[X-fL4,6u"");
    StringUtils.isAlphanumeric(""FfD` Z/yI1~7u];S["");
    StringUtils.lastIndexOf((CharSequence) ""8B<o&y1[X-fL4,6u"", (-1));
    StringUtils.isAllLowerCase(""FfD` Z/yI1~7u];S["");
    StringUtils.remove(""8"", ""\""6 O"");
    StringUtils.ordinalIndexOf(""TimeToLive of "", ""8B<o&y1[X-fL4,6u"", 31);
    StringUtils.isAllLowerCase(""8"");
    StringUtils.equals((CharSequence) ""8"", (CharSequence) null);
    StringUtils.indexOf((CharSequence) ""FfD` Z/yI1~7u];S["", (CharSequence) ""8B<o&y1[X-fL4,6u"");
    StringUtils.containsNone((CharSequence) "" vs "", "" vs "");
    StringUtils.substringBetween(""FfD` Z/yI1~7u];S["", ""D:?CYJ~uOr;7X"");
    StringUtils.indexOfAny((CharSequence) null, (CharSequence[]) null);
    StringUtils.substring(""8"", (-1), (-1));
}","/**
 * <p>Gets a substring from the specified String avoiding exceptions.</p>
 *
 * <p>A negative start position can be used to start/end {@code n}
 * characters from the end of the String.</p>
 *
 * <p>The returned substring starts with the character in the {@code start}
 * position and ends before the {@code end} position. All position counting is
 * zero-based -- i.e., to start at the beginning of the string use
 * {@code start = 0}. Negative start and end positions can be used to
 * specify offsets relative to the end of the String.</p>
 *
 * <p>If {@code start} is not strictly to the left of {@code end}, """"
 * is returned.</p>
 *
 * <pre>
 * StringUtils.substring(null, *, *)    = null
 * StringUtils.substring("""", * ,  *)    = """";
 * StringUtils.substring(""abc"", 0, 2)   = ""ab""
 * StringUtils.substring(""abc"", 2, 0)   = """"
 * StringUtils.substring(""abc"", 2, 4)   = ""c""
 * StringUtils.substring(""abc"", 4, 6)   = """"
 * StringUtils.substring(""abc"", 2, 2)   = """"
 * StringUtils.substring(""abc"", -2, -1) = ""b""
 * StringUtils.substring(""abc"", -4, 2)  = ""ab""
 * </pre>
 *
 * @param str  the String to get the substring from, may be null
 * @param start  the position to start from, negative means
 *  count back from the end of the String by this many characters
 * @param end  the position to end at (exclusive), negative means
 *  count back from the end of the String by this many characters
 * @return substring from start position to end positon,
 *  {@code null} if null String input
 */"
"public static String replace(String text, String searchString, String replacement) {
    return replace(text, searchString, replacement, -1);
}","public void test03042() throws Throwable {
    StringUtils.capitalize(""|`?_p[g"");
    StringUtils.isAlphaSpace(""|`?_p[g"");
    String[] stringArray0 = new String[5];
    stringArray0[1] = ""|`?_p[g"";
    stringArray0[1] = ""|`?_p[g"";
    stringArray0[2] = ""|`?_p[g"";
    stringArray0[4] = ""|`?_p[g"";
    StringUtils.substringBeforeLast(""|`?_p[g"", ""Dy_r=Wr2"");
    StringUtils.defaultIfEmpty(""|`?_p[g"", ""|`?_p[g"");
    StringUtils.containsIgnoreCase(""|`?_p[g"", stringArray0[0]);
    StringUtils.containsAny((CharSequence) ""Dy_r=Wr2"", (CharSequence) ""|`?_p[g"");
    StringUtils.isAlpha(""|`?_p[g"");
    StringUtils.rightPad(""|`?_p[g"", (-379), 'b');
    StringUtils.stripAll(stringArray0);
    StringUtils.isNumericSpace(""|`?_p[g"");
    StringUtils.reverseDelimited(""Dy_r=Wr2"", '8');
    StringUtils.endsWithAny(stringArray0[3], stringArray0);
    String[] stringArray1 = StringUtils.splitByWholeSeparator(""}@s`E{_"", stringArray0[3]);
    StringUtils.substringBefore(""|`?_p[g"", stringArray0[3]);
    StringUtils.join((Object[]) stringArray0, ""|`?_p[g"");
    StringUtils.replaceEach("""", stringArray1, stringArray0);
    String string0 = StringUtils.repeat((String) null, (String) null, (-379));
    StringUtils.replace(""|`?_p[g"", string0, """");
}","/**
 * <p>Replaces all occurrences of a String within another String.</p>
 *
 * <p>A {@code null} reference passed to this method is a no-op.</p>
 *
 * <pre>
 * StringUtils.replace(null, *, *)        = null
 * StringUtils.replace("""", *, *)          = """"
 * StringUtils.replace(""any"", null, *)    = ""any""
 * StringUtils.replace(""any"", *, null)    = ""any""
 * StringUtils.replace(""any"", """", *)      = ""any""
 * StringUtils.replace(""aba"", ""a"", null)  = ""aba""
 * StringUtils.replace(""aba"", ""a"", """")    = ""b""
 * StringUtils.replace(""aba"", ""a"", ""z"")   = ""zbz""
 * </pre>
 *
 * @see #replace(String text, String searchString, String replacement, int max)
 * @param text  text to search and replace in, may be null
 * @param searchString  the String to search for, may be null
 * @param replacement  the String to replace it with, may be null
 * @return the text with any replacements processed,
 *  {@code null} if null String input
 */"
"public static String replace(String text, String searchString, String replacement) {
    return replace(text, searchString, replacement, -1);
}","public void test03143() throws Throwable {
    StringUtils.capitalize(""|`?_p[g"");
    StringUtils.isAlphaSpace(""|`?_p[g"");
    String[] stringArray0 = new String[5];
    stringArray0[1] = ""|`?_p[g"";
    stringArray0[1] = ""|`?_p[g"";
    stringArray0[2] = ""|`?_p[g"";
    stringArray0[4] = ""|`?_p[g"";
    StringUtils.substringBeforeLast(""|`?_p[g"", ""Dy_r=Wr2"");
    StringUtils.defaultIfEmpty(""|`?_p[g"", ""|`?_p[g"");
    StringUtils.containsIgnoreCase(""|`?_p[g"", stringArray0[0]);
    StringUtils.containsAny((CharSequence) ""Dy_r=Wr2"", (CharSequence) ""|`?_p[g"");
    StringUtils.rightPad(""|`?_p[g"", (-379), 'b');
    StringUtils.stripAll(stringArray0);
    StringUtils.isNumericSpace(""|`?_p[g"");
    StringUtils.reverseDelimited(""Dy_r=Wr2"", '8');
    StringUtils.endsWithAny(stringArray0[3], stringArray0);
    String[] stringArray1 = StringUtils.splitByWholeSeparator(""}@s`E{_"", stringArray0[3]);
    StringUtils.substringBefore(""|`?_p[g"", stringArray0[3]);
    StringUtils.replaceEach("""", stringArray1, stringArray0);
    String string0 = StringUtils.repeat((String) null, (String) null, (-379));
    StringUtils.replace(""|`?_p[g"", string0, """");
}","/**
 * <p>Replaces all occurrences of a String within another String.</p>
 *
 * <p>A {@code null} reference passed to this method is a no-op.</p>
 *
 * <pre>
 * StringUtils.replace(null, *, *)        = null
 * StringUtils.replace("""", *, *)          = """"
 * StringUtils.replace(""any"", null, *)    = ""any""
 * StringUtils.replace(""any"", *, null)    = ""any""
 * StringUtils.replace(""any"", """", *)      = ""any""
 * StringUtils.replace(""aba"", ""a"", null)  = ""aba""
 * StringUtils.replace(""aba"", ""a"", """")    = ""b""
 * StringUtils.replace(""aba"", ""a"", ""z"")   = ""zbz""
 * </pre>
 *
 * @see #replace(String text, String searchString, String replacement, int max)
 * @param text  text to search and replace in, may be null
 * @param searchString  the String to search for, may be null
 * @param replacement  the String to replace it with, may be null
 * @return the text with any replacements processed,
 *  {@code null} if null String input
 */"
"// IndexOfAny chars
//-----------------------------------------------------------------------
/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A {@code null} String will return {@code -1}.
 * A {@code null} or zero length search array will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)                = -1
 * StringUtils.indexOfAny("""", *)                  = -1
 * StringUtils.indexOfAny(*, null)                = -1
 * StringUtils.indexOfAny(*, [])                  = -1
 * StringUtils.indexOfAny(""zzabyycdxx"",['z','a']) = 0
 * StringUtils.indexOfAny(""zzabyycdxx"",['b','y']) = 3
 * StringUtils.indexOfAny(""aba"", ['z'])           = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAny(String, char[]) to indexOfAny(CharSequence, char...)
 */
public static int indexOfAny(CharSequence cs, char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int csLen = cs.length();
    int csLast = csLen - 1;
    int searchLen = searchChars.length;
    int searchLast = searchLen - 1;
    for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
                    // ch is a supplementary character
                    if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        return i;
                    }
                } else {
                    return i;
                }
            }
        }
    }
    return INDEX_NOT_FOUND;
}","public void test03244() throws Throwable {
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    Iterator<Object> iterator0 = linkedList0.descendingIterator();
    StringUtils.join(iterator0, ""xDTm(m'~h1DlVpMeThe character must not be null"");
    StringUtils.isAlphaSpace("""");
    Object[] objectArray0 = new Object[1];
    objectArray0[0] = (Object) """";
    StringUtils.join(objectArray0, (String) null, 2520, 2520);
    StringUtils.isAsciiPrintable((CharSequence) null);
    StringUtils.isAlphanumericSpace(""xDTm(m'~h1DlVpMeThe character must not be null"");
    char[] charArray0 = new char[9];
    charArray0[0] = 'p';
    charArray0[1] = 't';
    charArray0[2] = 'D';
    charArray0[3] = 'U';
    charArray0[4] = ')';
    charArray0[5] = '-';
    charArray0[6] = '6';
    charArray0[7] = 'U';
    charArray0[8] = 'n';
    StringUtils.indexOfAny((CharSequence) """", charArray0);
}",""
"// SubStringAfter/SubStringBefore
//-----------------------------------------------------------------------
/**
 * <p>Gets the substring before the first occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A {@code null} string input will return {@code null}.
 * An empty ("""") string input will return the empty string.
 * A {@code null} separator will return the input string.</p>
 *
 * <p>If nothing is found, the string input is returned.</p>
 *
 * <pre>
 * StringUtils.substringBefore(null, *)      = null
 * StringUtils.substringBefore("""", *)        = """"
 * StringUtils.substringBefore(""abc"", ""a"")   = """"
 * StringUtils.substringBefore(""abcba"", ""b"") = ""a""
 * StringUtils.substringBefore(""abc"", ""c"")   = ""ab""
 * StringUtils.substringBefore(""abc"", ""d"")   = ""abc""
 * StringUtils.substringBefore(""abc"", """")    = """"
 * StringUtils.substringBefore(""abc"", null)  = ""abc""
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring before the first occurrence of the separator,
 *  {@code null} if null String input
 * @since 2.0
 */
public static String substringBefore(String str, String separator) {
    if (isEmpty(str) || separator == null) {
        return str;
    }
    if (separator.length() == 0) {
        return EMPTY;
    }
    int pos = str.indexOf(separator);
    if (pos == INDEX_NOT_FOUND) {
        return str;
    }
    return str.substring(0, pos);
}","public void test03446() throws Throwable {
    StringUtils.substringsBetween(""Exception cloning Cloneable type "", ""Exception cloning Cloneable type "", ""Exception cloning Cloneable type "");
    StringUtils.remove((String) null, 'Y');
    StringUtils.getCommonPrefix((String[]) null);
    StringUtils.isAlphanumericSpace(""Exception cloning Cloneable type "");
    StringUtils.center("""", (-180));
    StringUtils.join((Object[]) null, 'Y', (-180), (-180));
    StringUtils.isAlpha(""Exception cloning Cloneable type "");
    StringUtils.isNumericSpace("""");
    StringUtils.difference(""Exception cloning Cloneable type "", (String) null);
    StringUtils.lastIndexOf((CharSequence) null, (-180), (-180));
    StringUtils.repeat((String) null, 4);
    StringUtils.contains((CharSequence) ""Exception cloning Cloneable type "", 26);
    StringUtils.countMatches((CharSequence) null, (CharSequence) null);
    StringUtils.defaultString(""[<jH!18Sq#_P){o>km"");
    StringUtils.difference((String) null, ""[<jH!18Sq#_P){o>km"");
    StringUtils.chop(""[<jH!18Sq#_P){o>km"");
    StringUtils.removeStart((String) null, ""l9"");
    StringUtils.capitalize(""normalize"");
    StringUtils.removeStart(""Normalize"", ""Da=3q"");
    StringUtils.abbreviate((String) null, (-1), (-180));
    StringUtils.isAllUpperCase("""");
    StringUtils.defaultIfBlank((String) null, (String) null);
    StringUtils.abbreviateMiddle(""Normalize"", (String) null, 1419);
    StringUtils.substringBefore(""7uLzstjl<;}6"", ""ZLxgE{[owjcmpz^] #/"");
}",""
"public static String center(String str, int size, String padStr) {
    if (str == null || size <= 0) {
        return str;
    }
    if (isEmpty(padStr)) {
        padStr = "" "";
    }
    int strLen = str.length();
    int pads = size - strLen;
    if (pads <= 0) {
        return str;
    }
    str = leftPad(str, strLen + pads / 2, padStr);
    str = rightPad(str, size, padStr);
    return str;
}","public void test03547() throws Throwable {
    StringUtils.leftPad(""ciX?-maH5XWZ("", 510, ""ciX?-maH5XWZ("");
    String[] stringArray0 = new String[1];
    stringArray0[0] = ""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("";
    StringUtils.stripAll(stringArray0);
    StringUtils.abbreviate(""Exception cloning Cloneable type "", 13);
    StringUtils.ordinalIndexOf(""ciX?-maH5XWZ("", ""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("", 13);
    StringUtils.stripToNull(""Exception ..."");
    StringUtils.mid(""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("", 13, 510);
    LinkedHashSet<Locale.FilteringMode> linkedHashSet0 = new LinkedHashSet<Locale.FilteringMode>();
    Iterator<Locale.FilteringMode> iterator0 = linkedHashSet0.iterator();
    Locale.FilteringMode locale_FilteringMode0 = Locale.FilteringMode.REJECT_EXTENDED_RANGES;
    Locale.FilteringMode locale_FilteringMode1 = Locale.FilteringMode.REJECT_EXTENDED_RANGES;
    linkedHashSet0.add(locale_FilteringMode1);
    linkedHashSet0.add(locale_FilteringMode0);
    StringUtils.join(iterator0, '}');
    StringUtils.rightPad(""ciX?-maH5XWZ("", (-1), ""/x&<_x`RJm/x&<_x`RJm"");
    StringUtils.chomp(""xDTm(m'~h1DlVpMe"", ""The character must not be null"");
    StringUtils.center("",F*,8W?<%"", 13, ""xDTm(m'~h1DlVpMe"");
}","/**
 * <p>Centers a String in a larger String of size {@code size}.
 * Uses a supplied String as the value to pad the String with.</p>
 *
 * <p>If the size is less than the String length, the String is returned.
 * A {@code null} String returns {@code null}.
 * A negative size is treated as zero.</p>
 *
 * <pre>
 * StringUtils.center(null, *, *)     = null
 * StringUtils.center("""", 4, "" "")     = ""    ""
 * StringUtils.center(""ab"", -1, "" "")  = ""ab""
 * StringUtils.center(""ab"", 4, "" "")   = "" ab""
 * StringUtils.center(""abcd"", 2, "" "") = ""abcd""
 * StringUtils.center(""a"", 4, "" "")    = "" a  ""
 * StringUtils.center(""a"", 4, ""yz"")   = ""yayz""
 * StringUtils.center(""abc"", 7, null) = ""  abc  ""
 * StringUtils.center(""abc"", 7, """")   = ""  abc  ""
 * </pre>
 *
 * @param str  the String to center, may be null
 * @param size  the int size of new String, negative treated as zero
 * @param padStr  the String to pad the new String with, must not be null or empty
 * @return centered String, {@code null} if null String input
 * @throws IllegalArgumentException if padStr is {@code null} or empty
 */"
"// Chopping
//-----------------------------------------------------------------------
/**
 * <p>Remove the last character from a String.</p>
 *
 * <p>If the String ends in {@code \r\n}, then remove both
 * of them.</p>
 *
 * <pre>
 * StringUtils.chop(null)          = null
 * StringUtils.chop("""")            = """"
 * StringUtils.chop(""abc \r"")      = ""abc ""
 * StringUtils.chop(""abc\n"")       = ""abc""
 * StringUtils.chop(""abc\r\n"")     = ""abc""
 * StringUtils.chop(""abc"")         = ""ab""
 * StringUtils.chop(""abc\nabc"")    = ""abc\nab""
 * StringUtils.chop(""a"")           = """"
 * StringUtils.chop(""\r"")          = """"
 * StringUtils.chop(""\n"")          = """"
 * StringUtils.chop(""\r\n"")        = """"
 * </pre>
 *
 * @param str  the String to chop last character from, may be null
 * @return String without last character, {@code null} if null String input
 */
public static String chop(String str) {
    if (str == null) {
        return null;
    }
    int strLen = str.length();
    if (strLen < 2) {
        return EMPTY;
    }
    int lastIdx = strLen - 1;
    String ret = str.substring(0, lastIdx);
    char last = str.charAt(lastIdx);
    if (last == CharUtils.LF) {
        if (ret.charAt(lastIdx - 1) == CharUtils.CR) {
            return ret.substring(0, lastIdx - 1);
        }
    }
    return ret;
}","public void test03648() throws Throwable {
    StringUtils.substringAfter(""Cannot clone Cloneable type "", ""Cannot clone Cloneable type "");
    StringUtils.indexOfAnyBut((CharSequence) """", (CharSequence) """");
    StringUtils.removeStart(""Cannot clone Cloneable type "", """");
    StringUtils.ordinalIndexOf(""Cannot clone Cloneable type "", """", (-1));
    StringUtils.trimToEmpty(""Cannot clone Cloneable type "");
    StringUtils.containsOnly((CharSequence) ""Cannot clone Cloneable type"", ""Cannot clone Cloneable type"");
    StringUtils.center(""Cannot clone Cloneable type "", (-1), 'n');
    char[] charArray0 = new char[0];
    StringUtils.containsAny((CharSequence) ""Cannot clone Cloneable type "", charArray0);
    StringUtils.rightPad(""E:\n$`Sb!KB"", 127, ""c-JXi_XW#n9X[eL1"");
    StringUtils.trimToNull(""tS9>"");
    StringUtils.indexOf((CharSequence) ""tS9>"", (CharSequence) """", 127);
    StringUtils.substringAfter(""tS9>"", ""Threshold must not be negative"");
    Object[] objectArray0 = new Object[8];
    objectArray0[0] = (Object) ""Cannot clone Cloneable type"";
    objectArray0[1] = (Object) ""Cannot clone Cloneable type "";
    Object object0 = new Object();
    objectArray0[2] = object0;
    objectArray0[3] = (Object) ""tS9>"";
    objectArray0[4] = (Object) """";
    objectArray0[5] = (Object) ""Cannot clone Cloneable type"";
    objectArray0[6] = (Object) """";
    objectArray0[7] = (Object) ""E:\n$`Sb!KBc-JXi_XW#n9X[eL1c-JXi_XW#n9X[eL1c-JXi_XW#n9X[eL1c-JXi_XW#n9X[eL1c-JXi_XW#n9X[eL1c-JXi_XW#n9X[eL1c-JXi_XW#n9X[eL1c-JX"";
    StringUtils.join(objectArray0, '>', 127, 43);
    StringUtils.isAlphaSpace("""");
    StringUtils.lastIndexOf((CharSequence) ""Cannot clone Cloneable type"", 127);
    StringUtils.chop(""<!"");
}",""
"// Character Tests
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains only unicode letters.</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty CharSequence (length()=0) will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.isAlpha(null)   = false
 * StringUtils.isAlpha("""")     = false
 * StringUtils.isAlpha(""  "")   = false
 * StringUtils.isAlpha(""abc"")  = true
 * StringUtils.isAlpha(""ab2c"") = false
 * StringUtils.isAlpha(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if only contains letters, and is non-null
 * @since 3.0 Changed signature from isAlpha(String) to isAlpha(CharSequence)
 * @since 3.0 Changed """" to return false and not true
 */
public static boolean isAlpha(CharSequence cs) {
    if (cs == null || cs.length() == 0) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isLetter(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test03749() throws Throwable {
    StringUtils.removeStart(""Exception cloning Cloneable type "", ""Exception cloning Cloneable type "");
    StringUtils.removeStart("""", "".KkU1YgR}zN"");
    StringUtils.chomp("""");
    StringUtils.replaceChars("""", """", ""Qhj\""F!dPV6AR3rv"");
    StringUtils.chop(""7k"");
    Object[] objectArray0 = new Object[7];
    objectArray0[0] = (Object) """";
    objectArray0[1] = (Object) ""7k"";
    objectArray0[2] = (Object) """";
    objectArray0[3] = (Object) """";
    objectArray0[4] = (Object) """";
    objectArray0[5] = (Object) ""7k"";
    objectArray0[6] = (Object) ""Exception cloning Cloneable type "";
    StringUtils.join(objectArray0, 'f');
    StringUtils.substringBeforeLast("""", ""4444"");
    StringUtils.containsOnly((CharSequence) """", ""[Ef\""^h"");
    StringUtils.indexOf((CharSequence) ""7k"", 97);
    char[] charArray0 = new char[7];
    charArray0[0] = 'f';
    charArray0[1] = 'f';
    charArray0[2] = 'f';
    charArray0[3] = 'f';
    charArray0[4] = 'f';
    charArray0[5] = 'f';
    charArray0[6] = 'f';
    StringUtils.containsNone((CharSequence) """", charArray0);
    StringUtils.isBlank("""");
    StringUtils.isNumericSpace(""Exception cloning Cloneable type "");
    StringUtils.leftPad(""[Ef\""^h"", 890, """");
    StringUtils.isAlpha(""7"");
}",""
"public static String[] substringsBetween(String str, String open, String close) {
    if (str == null || isEmpty(open) || isEmpty(close)) {
        return null;
    }
    int strLen = str.length();
    if (strLen == 0) {
        return ArrayUtils.EMPTY_STRING_ARRAY;
    }
    int closeLen = close.length();
    int openLen = open.length();
    List<String> list = new ArrayList<String>();
    int pos = 0;
    while (pos < (strLen - closeLen)) {
        int start = str.indexOf(open, pos);
        if (start < 0) {
            break;
        }
        start += openLen;
        int end = str.indexOf(close, start);
        if (end < 0) {
            break;
        }
        list.add(str.substring(start, end));
        pos = end + closeLen;
    }
    if (list.isEmpty()) {
        return null;
    }
    return list.toArray(new String[list.size()]);
}","public void test03850() throws Throwable {
    StringUtils.difference(""8qYkcKHXc*DECOMPOSE8qYkcKHXc*DECOMPOSE8qYkcKHXc*DECOMPOSE8qYkcKHXc*DECOMPOSEDECOMPOSE"", ""8qYkcKHXc*DECOMPOSE8qYkcKHXc*DECOMPOSE8qYkcKHXc*DECOMPOSE8qYkcKHXc*DECOMPOSEDECOMPOSE"");
    char[] charArray0 = new char[4];
    charArray0[0] = 'l';
    charArray0[1] = 'n';
    charArray0[2] = 'L';
    charArray0[3] = '+';
    StringUtils.containsOnly((CharSequence) """", charArray0);
    StringUtils.substringBetween(""8qYkcKHXc*DECOMPOSE8qYkcKHXc*DECOMPOSE8qYkcKHXc*DECOMPOSE8qYkcKHXc*DECOMPOSEDECOMPOSE"", ""KQek?:b;b|"");
    StringUtils.splitByWholeSeparator("""", ""KQek?:b;b|"");
    StringUtils.defaultString((String) null);
    StringUtils.leftPad((String) null, 10, 'h');
    StringUtils.isAllUpperCase("""");
    StringUtils.substringsBetween((String) null, """", ""8qYkcKHXc*DECOMPOSE8qYkcKHXc*DECOMPOSE8qYkcKHXc*DECOMPOSE8qYkcKHXc*DECOMPOSEDECOMPOSE"");
}","/**
 * <p>Searches a String for substrings delimited by a start and end tag,
 * returning all matching substrings in an array.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} open/close returns {@code null} (no match).
 * An empty ("""") open/close returns {@code null} (no match).</p>
 *
 * <pre>
 * StringUtils.substringsBetween(""[a][b][c]"", ""["", ""]"") = [""a"",""b"",""c""]
 * StringUtils.substringsBetween(null, *, *)            = null
 * StringUtils.substringsBetween(*, null, *)            = null
 * StringUtils.substringsBetween(*, *, null)            = null
 * StringUtils.substringsBetween("""", ""["", ""]"")          = []
 * </pre>
 *
 * @param str  the String containing the substrings, null returns null, empty returns empty
 * @param open  the String identifying the start of the substring, empty returns null
 * @param close  the String identifying the end of the substring, empty returns null
 * @return a String Array of substrings, or {@code null} if no match
 * @since 2.3
 */"
"// Misc
//-----------------------------------------------------------------------
/**
 * <p>Find the Levenshtein distance between two Strings.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>The previous implementation of the Levenshtein distance algorithm
 * was from <a href=""http://www.merriampark.com/ld.htm"">http://www.merriampark.com/ld.htm</a></p>
 *
 * <p>Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError
 * which can occur when my Java implementation is used with very large strings.<br>
 * This implementation of the Levenshtein distance algorithm
 * is from <a href=""http://www.merriampark.com/ldjava.htm"">http://www.merriampark.com/ldjava.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("""","""")               = 0
 * StringUtils.getLevenshteinDistance("""",""a"")              = 1
 * StringUtils.getLevenshteinDistance(""aaapppp"", """")       = 7
 * StringUtils.getLevenshteinDistance(""frog"", ""fog"")       = 1
 * StringUtils.getLevenshteinDistance(""fly"", ""ant"")        = 3
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""zzzzzzzz"") = 8
 * StringUtils.getLevenshteinDistance(""hello"", ""hallo"")    = 1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @return result distance
 * @throws IllegalArgumentException if either String input {@code null}
 * @since 3.0 Changed signature from getLevenshteinDistance(String, String) to
 * getLevenshteinDistance(CharSequence, CharSequence)
 */
public static int getLevenshteinDistance(CharSequence s, CharSequence t) {
    if (s == null || t == null) {
        throw new IllegalArgumentException(""Strings must not be null"");
    }
    /*
           The difference between this impl. and the previous is that, rather
           than creating and retaining a matrix of size s.length() + 1 by t.length() + 1,
           we maintain two single-dimensional arrays of length s.length() + 1.  The first, d,
           is the 'current working' distance array that maintains the newest distance cost
           counts as we iterate through the characters of String s.  Each time we increment
           the index of String t we are comparing, d is copied to p, the second int[].  Doing so
           allows us to retain the previous cost counts as required by the algorithm (taking
           the minimum of the cost count to the left, up one, and diagonally up and to the left
           of the current cost count being calculated).  (Note that the arrays aren't really
           copied anymore, just switched...this is clearly much better than cloning an array
           or doing a System.arraycopy() each time  through the outer loop.)

           Effectively, the difference between the two implementations is this one does not
           cause an out of memory condition when calculating the LD over two very large strings.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    if (n == 0) {
        return m;
    } else if (m == 0) {
        return n;
    }
    if (n > m) {
        // swap the input strings to consume less memory
        CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    //'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    //placeholder to assist in swapping p and d
    int[] _d;
    // indexes into strings s and t
    // iterates through s
    int i;
    // iterates through t
    int j;
    // jth character of t
    char t_j;
    // cost
    int cost;
    for (i = 0; i <= n; i++) {
        p[i] = i;
    }
    for (j = 1; j <= m; j++) {
        t_j = t.charAt(j - 1);
        d[0] = j;
        for (i = 1; i <= n; i++) {
            cost = s.charAt(i - 1) == t_j ? 0 : 1;
            // minimum of cell to the left+1, to the top+1, diagonally left and up +cost
            d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost);
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // our last action in the above loop was to switch d and p, so p now
    // actually has the most recent cost counts
    return p[n];
}","public void test04052() throws Throwable {
    StringUtils.splitByCharacterType(""#QZ&D \""l"");
    int int0 = StringUtils.INDEX_NOT_FOUND;
    StringUtils.abbreviateMiddle((String) null, (String) null, (-1));
    StringUtils.stripEnd(""#QZ&D \""l"", ""#QZ&D \""l"");
    StringUtils.rightPad(""#QZ&D \""l"", 43, ""r"");
    StringUtils.chomp(""r"", ""r"");
    StringUtils.trimToNull("""");
    StringUtils.indexOfIgnoreCase((CharSequence) null, (CharSequence) null);
    StringUtils.center(""^%OBe<1l?5a]:LA7I7d"", (-865), 'y');
    StringUtils.ordinalIndexOf((CharSequence) null, ""^%OBe<1l?5a]:LA7I7d"", (-1683));
    StringUtils.substring("")D<^x)lb;rM3r"", (-1), (-1));
    StringUtils.contains((CharSequence) ""^%OBe<1l?5a]:LA7I7d"", (CharSequence) ""^%OBe<1l?5a]:LA7I7d"");
    StringUtils.overlay(""The Character must not be null"", ""ntrRV0~NI"", (-1683), 30);
    StringUtils.contains((CharSequence) """", (CharSequence) null);
    StringUtils.indexOfIgnoreCase((CharSequence) ""^%OBe<1l?5a]:LA7I7d"", (CharSequence) ""r"", 3415);
    StringUtils.center((String) null, 32, ""rr[Y1jd lPy*oG !J-?7SyC"");
    // Undeclared exception!
    try {
        StringUtils.getLevenshteinDistance((CharSequence) ""^%OBe<1l?5a]:LA7I7d"", (CharSequence) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Strings must not be null
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}",""
"public static String removeEnd(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (str.endsWith(remove)) {
        return str.substring(0, str.length() - remove.length());
    }
    return str;
}","public void test04153() throws Throwable {
    StringUtils.abbreviateMiddle(""java.text.Normalizer$Form"", ""java.text.Normalizer$Form"", (-423));
    StringUtils.remove((String) null, ';');
    StringUtils.isBlank(""java.text.Normalizer$Form"");
    StringUtils.chomp(""J#?tm'P{W/MT0\""aO"");
    StringUtils.removeEnd(""xDTm(m'~h1DlVpMeThe character must not be null"", (String) null);
}","/**
 * <p>Removes a substring only if it is at the end of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("""") source string will return the empty string.
 * A {@code null} search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeEnd(null, *)      = null
 * StringUtils.removeEnd("""", *)        = """"
 * StringUtils.removeEnd(*, null)      = *
 * StringUtils.removeEnd(""www.domain.com"", "".com."")  = ""www.domain.com""
 * StringUtils.removeEnd(""www.domain.com"", "".com"")   = ""www.domain""
 * StringUtils.removeEnd(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeEnd(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for and remove, may be null
 * @return the substring with the string removed if found,
 *  {@code null} if null String input
 * @since 2.1
 */"
"// LastIndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the last index within a CharSequence, handling {@code null}.
 * This method uses {@link String#lastIndexOf(int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("""") CharSequence will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.lastIndexOf(null, *)         = -1
 * StringUtils.lastIndexOf("""", *)           = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'a') = 7
 * StringUtils.lastIndexOf(""aabaabaa"", 'b') = 5
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @return the last index of the search character,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from lastIndexOf(String, int) to lastIndexOf(CharSequence, int)
 */
public static int lastIndexOf(CharSequence seq, int searchChar) {
    if (isEmpty(seq)) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.lastIndexOf(seq, searchChar, seq.length());
}","public void test04254() throws Throwable {
    StringUtils.substringAfter(""Cannot clone Cloneable type "", ""Cannot clone Cloneable type "");
    StringUtils.indexOfAnyBut((CharSequence) """", (CharSequence) """");
    StringUtils.removeStart(""Cannot clone Cloneable type "", """");
    StringUtils.ordinalIndexOf(""Cannot clone Cloneable type "", """", (-1));
    StringUtils.trimToEmpty(""Cannot clone Cloneable type "");
    StringUtils.containsOnly((CharSequence) ""Cannot clone Cloneable type"", ""Cannot clone Cloneable type"");
    StringUtils.center(""Cannot clone Cloneable type "", (-1), 'n');
    char[] charArray0 = new char[0];
    StringUtils.containsAny((CharSequence) ""Cannot clone Cloneable type "", charArray0);
    StringUtils.rightPad(""E:\n$`Sb!KB"", 127, ""c-JXi_XW#n9X[eL1"");
    StringUtils.trimToNull(""tS9>"");
    StringUtils.indexOf((CharSequence) ""tS9>"", (CharSequence) """", 127);
    StringUtils.substringAfter(""tS9>"", ""Threshold must not be negative"");
    Object[] objectArray0 = new Object[8];
    objectArray0[0] = (Object) ""Cannot clone Cloneable type"";
    objectArray0[1] = (Object) ""Cannot clone Cloneable type "";
    Object object0 = new Object();
    objectArray0[2] = object0;
    objectArray0[3] = (Object) ""tS9>"";
    objectArray0[4] = (Object) """";
    objectArray0[5] = (Object) """";
    objectArray0[6] = (Object) """";
    objectArray0[7] = (Object) ""E:\n$`Sb!KBc-JXi_XW#n9X[eL1c-JXi_XW#n9X[eL1c-JXi_XW#n9X[eL1c-JXi_XW#n9X[eL1c-JXi_XW#n9X[eL1c-JXi_XW#n9X[eL1c-JXi_XW#n9X[eL1c-JX"";
    StringUtils.join(objectArray0, '>', 127, 43);
    StringUtils.isAlphaSpace("""");
    StringUtils.lastIndexOf((CharSequence) ""Cannot clone Cloneable type"", 127);
}",""
"// ContainsAny
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains any character in the given
 * set of characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.
 * A {@code null} or zero length search array will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)                = false
 * StringUtils.containsAny("""", *)                  = false
 * StringUtils.containsAny(*, null)                = false
 * StringUtils.containsAny(*, [])                  = false
 * StringUtils.containsAny(""zzabyycdxx"",['z','a']) = true
 * StringUtils.containsAny(""zzabyycdxx"",['b','y']) = true
 * StringUtils.containsAny(""aba"", ['z'])           = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the {@code true} if any of the chars are found,
 * {@code false} if no match or null input
 * @since 2.4
 * @since 3.0 Changed signature from containsAny(String, char[]) to containsAny(CharSequence, char...)
 */
public static boolean containsAny(CharSequence cs, char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    int csLast = csLength - 1;
    int searchLast = searchLength - 1;
    for (int i = 0; i < csLength; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == ch) {
                if (Character.isHighSurrogate(ch)) {
                    if (j == searchLast) {
                        // missing low surrogate, fine, like String.indexOf(String)
                        return true;
                    }
                    if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
                        return true;
                    }
                } else {
                    // ch is in the Basic Multilingual Plane
                    return true;
                }
            }
        }
    }
    return false;
}","public void test04355() throws Throwable {
    StringUtils.repeat(""|lI8+Nwyp"", (String) null, 0);
    StringUtils.substringBeforeLast(""6}E#3vZEqES<"", """");
    StringUtils.right(""6}E#3vZEqES<"", 0);
    StringUtils.strip(""_w[IYfF9g^Av33Q6"", ""_w[IYfF9g^Av33Q6"");
    char[] charArray0 = new char[4];
    charArray0[0] = '.';
    charArray0[1] = 'H';
    charArray0[2] = '.';
    charArray0[3] = '.';
    StringUtils.containsAny((CharSequence) ""_w[IYfF9g^Av33Q6"", charArray0);
}",""
"public static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal) {
    return ordinalIndexOf(str, searchStr, ordinal, false);
}","public void test04456() throws Throwable {
    StringUtils.stripAccents(""(m'~h1DlVpMUe"");
    StringUtils.removeEnd(""(m'~h1DlVpMUe"", ""(m'~h1DlVpMUe"");
    StringUtils.containsOnly((CharSequence) ""(m'~h1DlVpMUe"", (char[]) null);
    StringUtils.stripToEmpty("""");
    StringUtils.indexOf((CharSequence) """", (CharSequence) """");
    StringUtils.leftPad("""", 0, """");
    StringUtils.defaultIfEmpty((CharSequence) """", (CharSequence) ""(m'~h1DlVpMUe"");
    StringUtils.ordinalIndexOf(""(m'~h1DlVpMUe"", """", 0);
}","/**
 * <p>Finds the n-th index within a CharSequence, handling {@code null}.
 * This method uses {@link String#indexOf(String)} if possible.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.ordinalIndexOf(null, *, *)          = -1
 * StringUtils.ordinalIndexOf(*, null, *)          = -1
 * StringUtils.ordinalIndexOf("""", """", *)           = 0
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""a"", 1)  = 0
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""a"", 2)  = 1
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""b"", 1)  = 2
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""b"", 2)  = 5
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""ab"", 1) = 1
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""ab"", 2) = 4
 * StringUtils.ordinalIndexOf(""aabaabaa"", """", 1)   = 0
 * StringUtils.ordinalIndexOf(""aabaabaa"", """", 2)   = 0
 * </pre>
 *
 * <p>Note that 'head(CharSequence str, int n)' may be implemented as: </p>
 *
 * <pre>
 *   str.substring(0, lastOrdinalIndexOf(str, ""\n"", n))
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @param ordinal  the n-th {@code searchStr} to find
 * @return the n-th index of the search CharSequence,
 *  {@code -1} ({@code INDEX_NOT_FOUND}) if no match or {@code null} string input
 * @since 2.1
 * @since 3.0 Changed signature from ordinalIndexOf(String, String, int) to ordinalIndexOf(CharSequence, CharSequence, int)
 */"
"public static <T extends CharSequence> T defaultIfBlank(T str, T defaultStr) {
    return StringUtils.isBlank(str) ? defaultStr : str;
}","public void test04557() throws Throwable {
    StringUtils.substringsBetween(""Exception cloning Cloneable type "", ""Exception cloning Cloneable type "", ""Exception cloning Cloneable type "");
    StringUtils.remove((String) null, 'Y');
    StringUtils.getCommonPrefix((String[]) null);
    StringUtils.isAlphanumericSpace(""Exception cloning Cloneable type "");
    StringUtils.center((String) null, (-180));
    StringUtils.join((Object[]) null, 'Y', (-180), 34);
    StringUtils.isAlpha(""Exception cloning Cloneable type "");
    StringUtils.isNumericSpace((CharSequence) null);
    StringUtils.difference((String) null, (String) null);
    StringUtils.lastIndexOf((CharSequence) null, 34, (-180));
    StringUtils.repeat((String) null, 4);
    StringUtils.contains((CharSequence) null, 26);
    StringUtils.countMatches((CharSequence) null, (CharSequence) null);
    StringUtils.defaultString(""[<jH!18Sq#_P){o>km"");
    StringUtils.difference((String) null, ""[<jH!18Sq#_P){o>km"");
    StringUtils.chop(""[<jH!18Sq#_P){o>km"");
    StringUtils.removeStart((String) null, ""l9"");
    StringUtils.capitalize(""normalize"");
    StringUtils.removeStart(""Normalize"", ""Da=3q"");
    StringUtils.abbreviate((String) null, (-1), (-180));
    StringUtils.isAllUpperCase((CharSequence) null);
    StringUtils.defaultIfBlank((String) null, (String) null);
}","/**
 * <p>Returns either the passed in CharSequence, or if the CharSequence is
 * whitespace, empty ("""") or {@code null}, the value of {@code defaultStr}.</p>
 *
 * <pre>
 * StringUtils.defaultIfBlank(null, ""NULL"")  = ""NULL""
 * StringUtils.defaultIfBlank("""", ""NULL"")    = ""NULL""
 * StringUtils.defaultIfBlank("" "", ""NULL"")   = ""NULL""
 * StringUtils.defaultIfBlank(""bat"", ""NULL"") = ""bat""
 * StringUtils.defaultIfBlank("""", null)      = null
 * </pre>
 * @param <T> the specific kind of CharSequence
 * @param str the CharSequence to check, may be null
 * @param defaultStr  the default CharSequence to return
 *  if the input is whitespace, empty ("""") or {@code null}, may be null
 * @return the passed in CharSequence, or the default
 * @see StringUtils#defaultString(String, String)
 */"
"public static String removeEnd(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (str.endsWith(remove)) {
        return str.substring(0, str.length() - remove.length());
    }
    return str;
}","public void test04658() throws Throwable {
    String string0 = StringUtils.removeEnd(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", ""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"");
    assertNotNull(string0);
}","/**
 * <p>Removes a substring only if it is at the end of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("""") source string will return the empty string.
 * A {@code null} search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeEnd(null, *)      = null
 * StringUtils.removeEnd("""", *)        = """"
 * StringUtils.removeEnd(*, null)      = *
 * StringUtils.removeEnd(""www.domain.com"", "".com."")  = ""www.domain.com""
 * StringUtils.removeEnd(""www.domain.com"", "".com"")   = ""www.domain""
 * StringUtils.removeEnd(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeEnd(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for and remove, may be null
 * @return the substring with the string removed if found,
 *  {@code null} if null String input
 * @since 2.1
 */"
"public static String normalizeSpace(String str) {
    if (str == null) {
        return null;
    }
    return WHITESPACE_BLOCK.matcher(trim(str)).replaceAll("" "");
}","public void test04660() throws Throwable {
    String string0 = StringUtils.removeEnd(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", ""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"");
    String string1 = StringUtils.normalizeSpace(""l9,1&/}#+$"");
    assertNotNull(string1);
}","/**
 * <p>
 * Similar to <a
 * href=""http://www.w3.org/TR/xpath/#function-normalize-space"">http://www.w3.org/TR/xpath/#function-normalize
 * -space</a>
 * </p>
 * <p>
 * The function returns the argument string with whitespace normalized by using
 * <code>{@link #trim(String)}</code> to remove leading and trailing whitespace
 * and then replacing sequences of whitespace characters by a single space.
 * </p>
 * In XML Whitespace characters are the same as those allowed by the <a
 * href=""http://www.w3.org/TR/REC-xml/#NT-S"">S</a> production, which is S ::= (#x20 | #x9 | #xD | #xA)+
 * <p>
 * Java's regexp pattern \s defines whitespace as [ \t\n\x0B\f\r]
 * <p>
 * For reference:
 * <ul>
 * <li>\x0B = vertical tab</li>
 * <li>\f = #xC = form feed</li>
 * <li>#x20 = space</li>
 * <li>#x9 = \t</li>
 * <li>#xA = \n</li>
 * <li>#xD = \r</li>
 * </ul>
 * </p>
 * <p>
 * The difference is that Java's whitespace includes vertical tab and form feed, which this functional will also
 * normalize. Additonally <code>{@link #trim(String)}</code> removes control characters (char &lt;= 32) from both
 * ends of this String.
 * </p>
 *
 * @see Pattern
 * @see #trim(String)
 * @see <a
 *      href=""http://www.w3.org/TR/xpath/#function-normalize-space"">http://www.w3.org/TR/xpath/#function-normalize-space</a>
 * @param str the source String to normalize whitespaces from, may be null
 * @return the modified string with whitespace normalized, {@code null} if null String input
 *
 * @since 3.0
 */"
"// Conversion
//-----------------------------------------------------------------------
// Padding
//-----------------------------------------------------------------------
/**
 * <p>Repeat a String {@code repeat} times to form a
 * new String.</p>
 *
 * <pre>
 * StringUtils.repeat(null, 2) = null
 * StringUtils.repeat("""", 0)   = """"
 * StringUtils.repeat("""", 2)   = """"
 * StringUtils.repeat(""a"", 3)  = ""aaa""
 * StringUtils.repeat(""ab"", 2) = ""abab""
 * StringUtils.repeat(""a"", -2) = """"
 * </pre>
 *
 * @param str  the String to repeat, may be null
 * @param repeat  number of times to repeat str, negative treated as zero
 * @return a new String consisting of the original String repeated,
 *  {@code null} if null String input
 */
public static String repeat(String str, int repeat) {
    // Performance tuned for 2.0 (JDK1.4)
    if (str == null) {
        return null;
    }
    if (repeat <= 0) {
        return EMPTY;
    }
    int inputLength = str.length();
    if (repeat == 1 || inputLength == 0) {
        return str;
    }
    if (inputLength == 1 && repeat <= PAD_LIMIT) {
        return repeat(str.charAt(0), repeat);
    }
    int outputLength = inputLength * repeat;
    switch(inputLength) {
        case 1:
            return repeat(str.charAt(0), repeat);
        case 2:
            char ch0 = str.charAt(0);
            char ch1 = str.charAt(1);
            char[] output2 = new char[outputLength];
            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {
                output2[i] = ch0;
                output2[i + 1] = ch1;
            }
            return new String(output2);
        default:
            StringBuilder buf = new StringBuilder(outputLength);
            for (int i = 0; i < repeat; i++) {
                buf.append(str);
            }
            return buf.toString();
    }
}","public void test04663() throws Throwable {
    String string0 = StringUtils.removeEnd(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", ""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"");
    String string1 = StringUtils.normalizeSpace(""l9,1&/}#+$"");
    String string2 = StringUtils.repeat(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", 4480);
    assertNotNull(string2);
}",""
"public static String center(String str, int size, char padChar) {
    if (str == null || size <= 0) {
        return str;
    }
    int strLen = str.length();
    int pads = size - strLen;
    if (pads <= 0) {
        return str;
    }
    str = leftPad(str, strLen + pads / 2, padChar);
    str = rightPad(str, size, padChar);
    return str;
}","public void test04666() throws Throwable {
    String string0 = StringUtils.removeEnd(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", ""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"");
    String string1 = StringUtils.normalizeSpace(""l9,1&/}#+$"");
    String string2 = StringUtils.repeat(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", 4480);
    String string3 = StringUtils.center(string2, (-1841), 'l');
    assertNotNull(string3);
}","/**
 * <p>Centers a String in a larger String of size {@code size}.
 * Uses a supplied character as the value to pad the String with.</p>
 *
 * <p>If the size is less than the String length, the String is returned.
 * A {@code null} String returns {@code null}.
 * A negative size is treated as zero.</p>
 *
 * <pre>
 * StringUtils.center(null, *, *)     = null
 * StringUtils.center("""", 4, ' ')     = ""    ""
 * StringUtils.center(""ab"", -1, ' ')  = ""ab""
 * StringUtils.center(""ab"", 4, ' ')   = "" ab""
 * StringUtils.center(""abcd"", 2, ' ') = ""abcd""
 * StringUtils.center(""a"", 4, ' ')    = "" a  ""
 * StringUtils.center(""a"", 4, 'y')    = ""yayy""
 * </pre>
 *
 * @param str  the String to center, may be null
 * @param size  the int size of new String, negative treated as zero
 * @param padChar  the character to pad the new String with
 * @return centered String, {@code null} if null String input
 * @since 2.0
 */"
"public static int indexOfAnyBut(CharSequence seq, CharSequence searchChars) {
    if (isEmpty(seq) || isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int strLen = seq.length();
    for (int i = 0; i < strLen; i++) {
        char ch = seq.charAt(i);
        boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0;
        if (i + 1 < strLen && Character.isHighSurrogate(ch)) {
            char ch2 = seq.charAt(i + 1);
            if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) {
                return i;
            }
        } else {
            if (!chFound) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}","public void test04671() throws Throwable {
    String string0 = StringUtils.removeEnd(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", ""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"");
    String string1 = StringUtils.normalizeSpace(""l9,1&/}#+$"");
    String string2 = StringUtils.repeat(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", 4480);
    String string3 = StringUtils.center(string2, (-1841), 'l');
    int int0 = StringUtils.indexOfAnyBut((CharSequence) ""l9,1&/}#+$"", (CharSequence) string3);
    assertEquals(1, int0);
}","/**
 * <p>Search a CharSequence to find the first index of any
 * character not in the given set of characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A {@code null} or empty search string will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAnyBut(null, *)            = -1
 * StringUtils.indexOfAnyBut("""", *)              = -1
 * StringUtils.indexOfAnyBut(*, null)            = -1
 * StringUtils.indexOfAnyBut(*, """")              = -1
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", ""za"") = 3
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", """")   = -1
 * StringUtils.indexOfAnyBut(""aba"",""ab"")         = -1
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAnyBut(String, String) to indexOfAnyBut(CharSequence, CharSequence)
 */"
"public static String remove(String str, char remove) {
    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {
        return str;
    }
    char[] chars = str.toCharArray();
    int pos = 0;
    for (int i = 0; i < chars.length; i++) {
        if (chars[i] != remove) {
            chars[pos++] = chars[i];
        }
    }
    return new String(chars, 0, pos);
}","public void test04676() throws Throwable {
    String string0 = StringUtils.removeEnd(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", ""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"");
    String string1 = StringUtils.normalizeSpace(""l9,1&/}#+$"");
    String string2 = StringUtils.repeat(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", 4480);
    String string3 = StringUtils.center(string2, (-1841), 'l');
    int int0 = StringUtils.indexOfAnyBut((CharSequence) ""l9,1&/}#+$"", (CharSequence) string3);
    String string4 = StringUtils.remove(""normalize"", 'l');
    assertNotNull(string4);
}","/**
 * <p>Removes all occurrences of a character from within the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("""") source string will return the empty string.</p>
 *
 * <pre>
 * StringUtils.remove(null, *)       = null
 * StringUtils.remove("""", *)         = """"
 * StringUtils.remove(""queued"", 'u') = ""qeed""
 * StringUtils.remove(""queued"", 'z') = ""queued""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the char to search for and remove, may be null
 * @return the substring with the char removed if found,
 *  {@code null} if null String input
 * @since 2.1
 */"
"public static int indexOfIgnoreCase(CharSequence str, CharSequence searchStr, int startPos) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    if (startPos < 0) {
        startPos = 0;
    }
    int endLimit = (str.length() - searchStr.length()) + 1;
    if (startPos > endLimit) {
        return INDEX_NOT_FOUND;
    }
    if (searchStr.length() == 0) {
        return startPos;
    }
    for (int i = startPos; i < endLimit; i++) {
        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test04682() throws Throwable {
    String string0 = StringUtils.removeEnd(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", ""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"");
    String string1 = StringUtils.normalizeSpace(""l9,1&/}#+$"");
    String string2 = StringUtils.repeat(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", 4480);
    String string3 = StringUtils.center(string2, (-1841), 'l');
    int int0 = StringUtils.indexOfAnyBut((CharSequence) ""l9,1&/}#+$"", (CharSequence) string3);
    String string4 = StringUtils.remove(""normalize"", 'l');
    int int1 = StringUtils.indexOfIgnoreCase((CharSequence) ""l9,1&/}#+$"", (CharSequence) ""normaize"", (-570));
    assertEquals((-1), int1);
}","/**
 * <p>Case in-sensitive find of the first index within a CharSequence
 * from the specified position.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A negative start position is treated as zero.
 * An empty ("""") search CharSequence always matches.
 * A start position greater than the string length only matches
 * an empty search CharSequence.</p>
 *
 * <pre>
 * StringUtils.indexOfIgnoreCase(null, *, *)          = -1
 * StringUtils.indexOfIgnoreCase(*, null, *)          = -1
 * StringUtils.indexOfIgnoreCase("""", """", 0)           = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""A"", 0)  = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", 0)  = 2
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""AB"", 0) = 1
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", 3)  = 5
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", 9)  = -1
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", -1) = 2
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", """", 2)   = 2
 * StringUtils.indexOfIgnoreCase(""abc"", """", 9)        = 3
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @param startPos  the start position, negative treated as zero
 * @return the first index of the search CharSequence,
 *  -1 if no match or {@code null} string input
 * @since 2.5
 * @since 3.0 Changed signature from indexOfIgnoreCase(String, String, int) to indexOfIgnoreCase(CharSequence, CharSequence, int)
 */"
"// Count matches
//-----------------------------------------------------------------------
/**
 * <p>Counts how many times the substring appears in the larger string.</p>
 *
 * <p>A {@code null} or empty ("""") String input returns {@code 0}.</p>
 *
 * <pre>
 * StringUtils.countMatches(null, *)       = 0
 * StringUtils.countMatches("""", *)         = 0
 * StringUtils.countMatches(""abba"", null)  = 0
 * StringUtils.countMatches(""abba"", """")    = 0
 * StringUtils.countMatches(""abba"", ""a"")   = 2
 * StringUtils.countMatches(""abba"", ""ab"")  = 1
 * StringUtils.countMatches(""abba"", ""xxx"") = 0
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param sub  the substring to count, may be null
 * @return the number of occurrences, 0 if either CharSequence is {@code null}
 * @since 3.0 Changed signature from countMatches(String, String) to countMatches(CharSequence, CharSequence)
 */
public static int countMatches(CharSequence str, CharSequence sub) {
    if (isEmpty(str) || isEmpty(sub)) {
        return 0;
    }
    int count = 0;
    int idx = 0;
    while ((idx = CharSequenceUtils.indexOf(str, sub, idx)) != INDEX_NOT_FOUND) {
        count++;
        idx += sub.length();
    }
    return count;
}","public void test04684() throws Throwable {
    String string0 = StringUtils.removeEnd(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", ""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"");
    String string1 = StringUtils.normalizeSpace(""l9,1&/}#+$"");
    String string2 = StringUtils.repeat(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", 4480);
    String string3 = StringUtils.center(string2, (-1841), 'l');
    int int0 = StringUtils.indexOfAnyBut((CharSequence) ""l9,1&/}#+$"", (CharSequence) string3);
    String string4 = StringUtils.remove(""normalize"", 'l');
    int int1 = StringUtils.indexOfIgnoreCase((CharSequence) ""l9,1&/}#+$"", (CharSequence) ""normaize"", (-570));
    int int2 = StringUtils.countMatches(""normaize"", """");
    assertEquals(0, int2);
}",""
"public static String rightPad(String str, int size, String padStr) {
    if (str == null) {
        return null;
    }
    if (isEmpty(padStr)) {
        padStr = "" "";
    }
    int padLen = padStr.length();
    int strLen = str.length();
    int pads = size - strLen;
    if (pads <= 0) {
        // returns original String when possible
        return str;
    }
    if (padLen == 1 && pads <= PAD_LIMIT) {
        return rightPad(str, size, padStr.charAt(0));
    }
    if (pads == padLen) {
        return str.concat(padStr);
    } else if (pads < padLen) {
        return str.concat(padStr.substring(0, pads));
    } else {
        char[] padding = new char[pads];
        char[] padChars = padStr.toCharArray();
        for (int i = 0; i < pads; i++) {
            padding[i] = padChars[i % padLen];
        }
        return str.concat(new String(padding));
    }
}","public void test04687() throws Throwable {
    String string0 = StringUtils.removeEnd(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", ""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"");
    String string1 = StringUtils.normalizeSpace(""l9,1&/}#+$"");
    String string2 = StringUtils.repeat(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", 4480);
    String string3 = StringUtils.center(string2, (-1841), 'l');
    int int0 = StringUtils.indexOfAnyBut((CharSequence) ""l9,1&/}#+$"", (CharSequence) string3);
    String string4 = StringUtils.remove(""normalize"", 'l');
    int int1 = StringUtils.indexOfIgnoreCase((CharSequence) ""l9,1&/}#+$"", (CharSequence) ""normaize"", (-570));
    int int2 = StringUtils.countMatches(""normaize"", """");
    String string5 = StringUtils.rightPad(string2, 4480, """");
    assertNotNull(string5);
}","/**
 * <p>Right pad a String with a specified String.</p>
 *
 * <p>The String is padded to the size of {@code size}.</p>
 *
 * <pre>
 * StringUtils.rightPad(null, *, *)      = null
 * StringUtils.rightPad("""", 3, ""z"")      = ""zzz""
 * StringUtils.rightPad(""bat"", 3, ""yz"")  = ""bat""
 * StringUtils.rightPad(""bat"", 5, ""yz"")  = ""batyz""
 * StringUtils.rightPad(""bat"", 8, ""yz"")  = ""batyzyzy""
 * StringUtils.rightPad(""bat"", 1, ""yz"")  = ""bat""
 * StringUtils.rightPad(""bat"", -1, ""yz"") = ""bat""
 * StringUtils.rightPad(""bat"", 5, null)  = ""bat  ""
 * StringUtils.rightPad(""bat"", 5, """")    = ""bat  ""
 * </pre>
 *
 * @param str  the String to pad out, may be null
 * @param size  the size to pad to
 * @param padStr  the String to pad with, null or empty treated as single space
 * @return right padded String or original String if no padding is necessary,
 *  {@code null} if null String input
 */"
"public static String stripToEmpty(String str) {
    return str == null ? EMPTY : strip(str, null);
}","public void test04694() throws Throwable {
    String string0 = StringUtils.removeEnd(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", ""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"");
    String string1 = StringUtils.normalizeSpace(""l9,1&/}#+$"");
    String string2 = StringUtils.repeat(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", 4480);
    String string3 = StringUtils.center(string2, (-1841), 'l');
    int int0 = StringUtils.indexOfAnyBut((CharSequence) ""l9,1&/}#+$"", (CharSequence) string3);
    String string4 = StringUtils.remove(""normalize"", 'l');
    int int1 = StringUtils.indexOfIgnoreCase((CharSequence) ""l9,1&/}#+$"", (CharSequence) ""normaize"", (-570));
    int int2 = StringUtils.countMatches(""normaize"", """");
    String string5 = StringUtils.rightPad(string2, 4480, """");
    String string6 = StringUtils.stripToEmpty(""SecurityException occurredSI(cgK)kzU/SeOe"");
    assertNotNull(string6);
}","/**
 * <p>Strips whitespace from the start and end of a String  returning
 * an empty String if {@code null} input.</p>
 *
 * <p>This is similar to {@link #trimToEmpty(String)} but removes whitespace.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripToEmpty(null)     = """"
 * StringUtils.stripToEmpty("""")       = """"
 * StringUtils.stripToEmpty(""   "")    = """"
 * StringUtils.stripToEmpty(""abc"")    = ""abc""
 * StringUtils.stripToEmpty(""  abc"")  = ""abc""
 * StringUtils.stripToEmpty(""abc  "")  = ""abc""
 * StringUtils.stripToEmpty("" abc "")  = ""abc""
 * StringUtils.stripToEmpty("" ab c "") = ""ab c""
 * </pre>
 *
 * @param str  the String to be stripped, may be null
 * @return the trimmed String, or an empty String if {@code null} input
 * @since 2.0
 */"
"public static String removeEnd(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (str.endsWith(remove)) {
        return str.substring(0, str.length() - remove.length());
    }
    return str;
}","public void test046102() throws Throwable {
    String string0 = StringUtils.removeEnd(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", ""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"");
    String string1 = StringUtils.normalizeSpace(""l9,1&/}#+$"");
    String string2 = StringUtils.repeat(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", 4480);
    String string3 = StringUtils.center(string2, (-1841), 'l');
    int int0 = StringUtils.indexOfAnyBut((CharSequence) ""l9,1&/}#+$"", (CharSequence) string3);
    String string4 = StringUtils.remove(""normalize"", 'l');
    int int1 = StringUtils.indexOfIgnoreCase((CharSequence) ""l9,1&/}#+$"", (CharSequence) ""normaize"", (-570));
    int int2 = StringUtils.countMatches(""normaize"", """");
    String string5 = StringUtils.rightPad(string2, 4480, """");
    String string6 = StringUtils.stripToEmpty(""SecurityException occurredSI(cgK)kzU/SeOe"");
    String string7 = StringUtils.removeEnd(""FfD` Z/yI1~7u];S["", ""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"");
    assertNotNull(string7);
}","/**
 * <p>Removes a substring only if it is at the end of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("""") source string will return the empty string.
 * A {@code null} search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeEnd(null, *)      = null
 * StringUtils.removeEnd("""", *)        = """"
 * StringUtils.removeEnd(*, null)      = *
 * StringUtils.removeEnd(""www.domain.com"", "".com."")  = ""www.domain.com""
 * StringUtils.removeEnd(""www.domain.com"", "".com"")   = ""www.domain""
 * StringUtils.removeEnd(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeEnd(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for and remove, may be null
 * @return the substring with the string removed if found,
 *  {@code null} if null String input
 * @since 2.1
 */"
"public static <T extends CharSequence> T defaultIfBlank(T str, T defaultStr) {
    return StringUtils.isBlank(str) ? defaultStr : str;
}","public void test046111() throws Throwable {
    String string0 = StringUtils.removeEnd(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", ""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"");
    String string1 = StringUtils.normalizeSpace(""l9,1&/}#+$"");
    String string2 = StringUtils.repeat(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", 4480);
    String string3 = StringUtils.center(string2, (-1841), 'l');
    int int0 = StringUtils.indexOfAnyBut((CharSequence) ""l9,1&/}#+$"", (CharSequence) string3);
    String string4 = StringUtils.remove(""normalize"", 'l');
    int int1 = StringUtils.indexOfIgnoreCase((CharSequence) ""l9,1&/}#+$"", (CharSequence) ""normaize"", (-570));
    int int2 = StringUtils.countMatches(""normaize"", """");
    String string5 = StringUtils.rightPad(string2, 4480, """");
    String string6 = StringUtils.stripToEmpty(""SecurityException occurredSI(cgK)kzU/SeOe"");
    String string7 = StringUtils.removeEnd(""FfD` Z/yI1~7u];S["", ""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"");
    String string8 = StringUtils.defaultIfBlank(""java.text.Normalizer"", ""Exception cloning Clo-eable typ& Exception cloning Clo-eable typ& "");
    assertNotNull(string8);
}","/**
 * <p>Returns either the passed in CharSequence, or if the CharSequence is
 * whitespace, empty ("""") or {@code null}, the value of {@code defaultStr}.</p>
 *
 * <pre>
 * StringUtils.defaultIfBlank(null, ""NULL"")  = ""NULL""
 * StringUtils.defaultIfBlank("""", ""NULL"")    = ""NULL""
 * StringUtils.defaultIfBlank("" "", ""NULL"")   = ""NULL""
 * StringUtils.defaultIfBlank(""bat"", ""NULL"") = ""bat""
 * StringUtils.defaultIfBlank("""", null)      = null
 * </pre>
 * @param <T> the specific kind of CharSequence
 * @param str the CharSequence to check, may be null
 * @param defaultStr  the default CharSequence to return
 *  if the input is whitespace, empty ("""") or {@code null}, may be null
 * @return the passed in CharSequence, or the default
 * @see StringUtils#defaultString(String, String)
 */"
"// Chomping
//-----------------------------------------------------------------------
/**
 * <p>Removes one newline from end of a String if it's there,
 * otherwise leave it alone.  A newline is &quot;{@code \n}&quot;,
 * &quot;{@code \r}&quot;, or &quot;{@code \r\n}&quot;.</p>
 *
 * <p>NOTE: This method changed in 2.0.
 * It now more closely matches Perl chomp.</p>
 *
 * <pre>
 * StringUtils.chomp(null)          = null
 * StringUtils.chomp("""")            = """"
 * StringUtils.chomp(""abc \r"")      = ""abc ""
 * StringUtils.chomp(""abc\n"")       = ""abc""
 * StringUtils.chomp(""abc\r\n"")     = ""abc""
 * StringUtils.chomp(""abc\r\n\r\n"") = ""abc\r\n""
 * StringUtils.chomp(""abc\n\r"")     = ""abc\n""
 * StringUtils.chomp(""abc\n\rabc"")  = ""abc\n\rabc""
 * StringUtils.chomp(""\r"")          = """"
 * StringUtils.chomp(""\n"")          = """"
 * StringUtils.chomp(""\r\n"")        = """"
 * </pre>
 *
 * @param str  the String to chomp a newline from, may be null
 * @return String without newline, {@code null} if null String input
 */
public static String chomp(String str) {
    if (isEmpty(str)) {
        return str;
    }
    if (str.length() == 1) {
        char ch = str.charAt(0);
        if (ch == CharUtils.CR || ch == CharUtils.LF) {
            return EMPTY;
        }
        return str;
    }
    int lastIdx = str.length() - 1;
    char last = str.charAt(lastIdx);
    if (last == CharUtils.LF) {
        if (str.charAt(lastIdx - 1) == CharUtils.CR) {
            lastIdx--;
        }
    } else if (last != CharUtils.CR) {
        lastIdx++;
    }
    return str.substring(0, lastIdx);
}","public void test046121() throws Throwable {
    String string0 = StringUtils.removeEnd(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", ""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"");
    String string1 = StringUtils.normalizeSpace(""l9,1&/}#+$"");
    String string2 = StringUtils.repeat(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", 4480);
    String string3 = StringUtils.center(string2, (-1841), 'l');
    int int0 = StringUtils.indexOfAnyBut((CharSequence) ""l9,1&/}#+$"", (CharSequence) string3);
    String string4 = StringUtils.remove(""normalize"", 'l');
    int int1 = StringUtils.indexOfIgnoreCase((CharSequence) ""l9,1&/}#+$"", (CharSequence) ""normaize"", (-570));
    int int2 = StringUtils.countMatches(""normaize"", """");
    String string5 = StringUtils.rightPad(string2, 4480, """");
    String string6 = StringUtils.stripToEmpty(""SecurityException occurredSI(cgK)kzU/SeOe"");
    String string7 = StringUtils.removeEnd(""FfD` Z/yI1~7u];S["", ""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"");
    String string8 = StringUtils.defaultIfBlank(""java.text.Normalizer"", ""Exception cloning Clo-eable typ& Exception cloning Clo-eable typ& "");
    String string9 = StringUtils.chomp(""8bEhDCywIDUxL'YBrclone"");
    assertNotNull(string9);
}",""
"// Substring
//-----------------------------------------------------------------------
/**
 * <p>Gets a substring from the specified String avoiding exceptions.</p>
 *
 * <p>A negative start position can be used to start {@code n}
 * characters from the end of the String.</p>
 *
 * <p>A {@code null} String will return {@code null}.
 * An empty ("""") String will return """".</p>
 *
 * <pre>
 * StringUtils.substring(null, *)   = null
 * StringUtils.substring("""", *)     = """"
 * StringUtils.substring(""abc"", 0)  = ""abc""
 * StringUtils.substring(""abc"", 2)  = ""c""
 * StringUtils.substring(""abc"", 4)  = """"
 * StringUtils.substring(""abc"", -2) = ""bc""
 * StringUtils.substring(""abc"", -4) = ""abc""
 * </pre>
 *
 * @param str  the String to get the substring from, may be null
 * @param start  the position to start from, negative means
 *  count back from the end of the String by this many characters
 * @return substring from start position, {@code null} if null String input
 */
public static String substring(String str, int start) {
    if (str == null) {
        return null;
    }
    // handle negatives, which means last n characters
    if (start < 0) {
        // remember start is negative
        start = str.length() + start;
    }
    if (start < 0) {
        start = 0;
    }
    if (start > str.length()) {
        return EMPTY;
    }
    return str.substring(start);
}","public void test047132() throws Throwable {
    String[] stringArray0 = StringUtils.splitByCharacterTypeCamelCase(""8bEhDCywIDUxL'YBr"");
    StringUtils.stripAll(stringArray0, "")/r2R?"");
    StringUtils.substringBeforeLast(""8bEhDCywIDUxL'YBr"", "" iI'(B)EZP7J6;JS@o"");
    StringUtils.swapCase(""<{'a_Id_QlqU"");
    StringUtils.split("" iI'(B)EZP7J6;JS@o"");
    char[] charArray0 = new char[2];
    charArray0[0] = 'R';
    charArray0[1] = '8';
    StringUtils.containsOnly((CharSequence) ""8bEhDCywIDUxL'YBr"", charArray0);
    StringUtils.equalsIgnoreCase(""8bEhDCywIDUxL'YBr"", ""8bEhDCywIDUxL'YBr"");
    StringUtils.splitPreserveAllTokens(""8bEhDCywIDUxL'YBr"", '\\');
    StringUtils.countMatches(""<{'a_Id_QlqU"", "" iI'(B)EZP7J6;JS@o"");
    StringUtils.substring(""<{'A_iD_qLQu"", Integer.MAX_VALUE);
}",""
"public static boolean isBlank(CharSequence cs) {
    int strLen;
    if (cs == null || (strLen = cs.length()) == 0) {
        return true;
    }
    for (int i = 0; i < strLen; i++) {
        if ((Character.isWhitespace(cs.charAt(i)) == false)) {
            return false;
        }
    }
    return true;
}","public void test048133() throws Throwable {
    String[] stringArray0 = new String[1];
    stringArray0[0] = ""p{InCombiningDiacriticalMarks}+"";
    StringUtils.getCommonPrefix(stringArray0);
    StringUtils.isAlphaSpace(""p{InCombiningDiacriticalMarks}+"");
    char[] charArray0 = new char[0];
    StringUtils.indexOfAny((CharSequence) ""p{InCombiningDiacriticalMarks}+"", charArray0);
    StringUtils.startsWithAny(""p{InCombiningDiacriticalMarks}+"", stringArray0);
    StringUtils.isBlank(""p{InCombiningDiacriticalMarks}+"");
}","/**
 * <p>Checks if a CharSequence is whitespace, empty ("""") or null.</p>
 *
 * <pre>
 * StringUtils.isBlank(null)      = true
 * StringUtils.isBlank("""")        = true
 * StringUtils.isBlank("" "")       = true
 * StringUtils.isBlank(""bob"")     = false
 * StringUtils.isBlank(""  bob  "") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if the CharSequence is null, empty or whitespace
 * @since 2.0
 * @since 3.0 Changed signature from isBlank(String) to isBlank(CharSequence)
 */"
"public static int getLevenshteinDistance(CharSequence s, CharSequence t, int threshold) {
    if (s == null || t == null) {
        throw new IllegalArgumentException(""Strings must not be null"");
    }
    if (threshold < 0) {
        throw new IllegalArgumentException(""Threshold must not be negative"");
    }
    /*
        This implementation only computes the distance if it's less than or equal to the
        threshold value, returning -1 if it's greater.  The advantage is performance: unbounded
        distance is O(nm), but a bound of k allows us to reduce it to O(km) time by only 
        computing a diagonal stripe of width 2k + 1 of the cost table.
        It is also possible to use this to compute the unbounded Levenshtein distance by starting
        the threshold at 1 and doubling each time until the distance is found; this is O(dm), where
        d is the distance.
        
        One subtlety comes from needing to ignore entries on the border of our stripe
        eg.
        p[] = |#|#|#|*
        d[] =  *|#|#|#|
        We must ignore the entry to the left of the leftmost member
        We must ignore the entry above the rightmost member
        
        Another subtlety comes from our stripe running off the matrix if the strings aren't
        of the same size.  Since string s is always swapped to be the shorter of the two, 
        the stripe will always run off to the upper right instead of the lower left of the matrix.
        
        As a concrete example, suppose s is of length 5, t is of length 7, and our threshold is 1.
        In this case we're going to walk a stripe of length 3.  The matrix would look like so:
        
           1 2 3 4 5
        1 |#|#| | | |
        2 |#|#|#| | |
        3 | |#|#|#| |
        4 | | |#|#|#|
        5 | | | |#|#|
        6 | | | | |#|
        7 | | | | | |

        Note how the stripe leads off the table as there is no possible way to turn a string of length 5
        into one of length 7 in edit distance of 1.
        
        Additionally, this implementation decreases memory usage by using two 
        single-dimensional arrays and swapping them back and forth instead of allocating
        an entire n by m matrix.  This requires a few minor changes, such as immediately returning 
        when it's detected that the stripe has run off the matrix and initially filling the arrays with
        large values so that entries we don't compute are ignored.

        See Algorithms on Strings, Trees and Sequences by Dan Gusfield for some discussion.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    // if one string is empty, the edit distance is necessarily the length of the other
    if (n == 0) {
        return m <= threshold ? m : -1;
    } else if (m == 0) {
        return n <= threshold ? n : -1;
    }
    if (n > m) {
        // swap the two strings to consume less memory
        CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    // 'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    // placeholder to assist in swapping p and d
    int[] _d;
    // fill in starting table values
    int boundary = Math.min(n, threshold) + 1;
    for (int i = 0; i < boundary; i++) {
        p[i] = i;
    }
    // these fills ensure that the value above the rightmost entry of our
    // stripe will be ignored in following loop iterations
    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);
    Arrays.fill(d, Integer.MAX_VALUE);
    // iterates through t
    for (int j = 1; j <= m; j++) {
        // jth character of t
        char t_j = t.charAt(j - 1);
        d[0] = j;
        // compute stripe indices, constrain to array size
        int min = Math.max(1, j - threshold);
        int max = Math.min(n, j + threshold);
        // the stripe may lead off of the table if s and t are of different sizes
        if (min > max) {
            return -1;
        }
        // ignore entry left of leftmost
        if (min > 1) {
            d[min - 1] = Integer.MAX_VALUE;
        }
        // iterates through [min, max] in s
        for (int i = min; i <= max; i++) {
            if (s.charAt(i - 1) == t_j) {
                // diagonally left and up
                d[i] = p[i - 1];
            } else {
                // 1 + minimum of cell to the left, to the top, diagonally left and up
                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);
            }
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // if p[n] is greater than the threshold, there's no guarantee on it being the correct
    // distance
    if (p[n] <= threshold) {
        return p[n];
    } else {
        return -1;
    }
}","public void test049134() throws Throwable {
    StringUtils.defaultIfEmpty((String) null, ""Minimum abbreviation width is 4"");
    int int0 = 128;
    StringUtils.splitByWholeSeparator(""Minimum abbreviation width is 4"", "",F*,8W?<%"", 128);
    StringUtils.capitalize((String) null);
    StringUtils.isBlank("",F*,8W?<%"");
    String string0 = ""vDPx(Q6BG~~,K:+rbc"";
    StringUtils.replace("",F*,8W?<%"", "",F*,8W?<%"", ""vDPx(Q6BG~~,K:+rbc"");
    // Undeclared exception!
    try {
        StringUtils.getLevenshteinDistance((CharSequence) ""Minimum abbreviation width is 4"", (CharSequence) null, 128);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Strings must not be null
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}","/**
 * <p>Find the Levenshtein distance between two Strings if it's less than or equal to a given
 * threshold.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>This implementation follows from Algorithms on Strings, Trees and Sequences by Dan Gusfield
 * and Chas Emerick's implementation of the Levenshtein distance algorithm from
 * <a href=""http://www.merriampark.com/ld.htm"">http://www.merriampark.com/ld.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, *, -1)               = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("""","""", 0)               = 0
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 8)       = 7
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 7)       = 7
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 6))      = -1
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"", 7) = 7
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"", 6) = -1
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"", 7) = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"", 6) = -1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @param threshold the target threshold, must not be negative
 * @return result distance, or {@code -1} if the distance would be greater than the threshold
 * @throws IllegalArgumentException if either String input {@code null} or negative threshold
 */"
"public static String substring(String str, int start, int end) {
    if (str == null) {
        return null;
    }
    // handle negatives
    if (end < 0) {
        // remember end is negative
        end = str.length() + end;
    }
    if (start < 0) {
        // remember start is negative
        start = str.length() + start;
    }
    // check length next
    if (end > str.length()) {
        end = str.length();
    }
    // if start is greater than end, return """"
    if (start > end) {
        return EMPTY;
    }
    if (start < 0) {
        start = 0;
    }
    if (end < 0) {
        end = 0;
    }
    return str.substring(start, end);
}","public void test050135() throws Throwable {
    StringUtils.uncapitalize("""");
    StringUtils.replace("""", (String) null, ""org.apache.commons.lang3.ArrayUtils"");
    StringUtils.length("""");
    Object[] objectArray0 = new Object[3];
    objectArray0[0] = (Object) """";
    objectArray0[1] = (Object) ""org.apache.commons.lang3.ArrayUtils"";
    objectArray0[2] = (Object) """";
    StringUtils.join(objectArray0, '-', 0, 0);
    StringUtils.join((Iterable<?>) null, (String) null);
    String string0 = ""\\u000"";
    StringUtils.rightPad((String) null, 0, string0);
    StringUtils.splitByCharacterTypeCamelCase((String) null);
    StringUtils.substringsBetween(""#0=A,~N]C"", string0, (String) null);
    StringUtils.uncapitalize((String) null);
    StringUtils.join((Object[]) null, '3');
    StringUtils.stripAll((String[]) null, """");
    StringUtils.isAlphaSpace(string0);
    StringUtils.indexOf((CharSequence) ""org.apache.commons.lang3.ArrayUtils"", (-1223), (-1223));
    StringUtils.lastIndexOf((CharSequence) string0, 2594, 31);
    StringUtils.abbreviateMiddle((String) null, ""OiP(sh"", 0);
    StringUtils.getCommonPrefix((String[]) null);
    StringUtils.isAlphaSpace(""org.apache.commons.lang3.ArrayUtils"");
    StringUtils.lastIndexOf((CharSequence) ""OiP(sh"", 2594, 0);
    StringUtils.lastIndexOf((CharSequence) null, (CharSequence) null);
    StringUtils.substring(""m(m'~h1DlVpMe"", (-1), 31);
}","/**
 * <p>Gets a substring from the specified String avoiding exceptions.</p>
 *
 * <p>A negative start position can be used to start/end {@code n}
 * characters from the end of the String.</p>
 *
 * <p>The returned substring starts with the character in the {@code start}
 * position and ends before the {@code end} position. All position counting is
 * zero-based -- i.e., to start at the beginning of the string use
 * {@code start = 0}. Negative start and end positions can be used to
 * specify offsets relative to the end of the String.</p>
 *
 * <p>If {@code start} is not strictly to the left of {@code end}, """"
 * is returned.</p>
 *
 * <pre>
 * StringUtils.substring(null, *, *)    = null
 * StringUtils.substring("""", * ,  *)    = """";
 * StringUtils.substring(""abc"", 0, 2)   = ""ab""
 * StringUtils.substring(""abc"", 2, 0)   = """"
 * StringUtils.substring(""abc"", 2, 4)   = ""c""
 * StringUtils.substring(""abc"", 4, 6)   = """"
 * StringUtils.substring(""abc"", 2, 2)   = """"
 * StringUtils.substring(""abc"", -2, -1) = ""b""
 * StringUtils.substring(""abc"", -4, 2)  = ""ab""
 * </pre>
 *
 * @param str  the String to get the substring from, may be null
 * @param start  the position to start from, negative means
 *  count back from the end of the String by this many characters
 * @param end  the position to end at (exclusive), negative means
 *  count back from the end of the String by this many characters
 * @return substring from start position to end positon,
 *  {@code null} if null String input
 */"
"public static int getLevenshteinDistance(CharSequence s, CharSequence t, int threshold) {
    if (s == null || t == null) {
        throw new IllegalArgumentException(""Strings must not be null"");
    }
    if (threshold < 0) {
        throw new IllegalArgumentException(""Threshold must not be negative"");
    }
    /*
        This implementation only computes the distance if it's less than or equal to the
        threshold value, returning -1 if it's greater.  The advantage is performance: unbounded
        distance is O(nm), but a bound of k allows us to reduce it to O(km) time by only 
        computing a diagonal stripe of width 2k + 1 of the cost table.
        It is also possible to use this to compute the unbounded Levenshtein distance by starting
        the threshold at 1 and doubling each time until the distance is found; this is O(dm), where
        d is the distance.
        
        One subtlety comes from needing to ignore entries on the border of our stripe
        eg.
        p[] = |#|#|#|*
        d[] =  *|#|#|#|
        We must ignore the entry to the left of the leftmost member
        We must ignore the entry above the rightmost member
        
        Another subtlety comes from our stripe running off the matrix if the strings aren't
        of the same size.  Since string s is always swapped to be the shorter of the two, 
        the stripe will always run off to the upper right instead of the lower left of the matrix.
        
        As a concrete example, suppose s is of length 5, t is of length 7, and our threshold is 1.
        In this case we're going to walk a stripe of length 3.  The matrix would look like so:
        
           1 2 3 4 5
        1 |#|#| | | |
        2 |#|#|#| | |
        3 | |#|#|#| |
        4 | | |#|#|#|
        5 | | | |#|#|
        6 | | | | |#|
        7 | | | | | |

        Note how the stripe leads off the table as there is no possible way to turn a string of length 5
        into one of length 7 in edit distance of 1.
        
        Additionally, this implementation decreases memory usage by using two 
        single-dimensional arrays and swapping them back and forth instead of allocating
        an entire n by m matrix.  This requires a few minor changes, such as immediately returning 
        when it's detected that the stripe has run off the matrix and initially filling the arrays with
        large values so that entries we don't compute are ignored.

        See Algorithms on Strings, Trees and Sequences by Dan Gusfield for some discussion.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    // if one string is empty, the edit distance is necessarily the length of the other
    if (n == 0) {
        return m <= threshold ? m : -1;
    } else if (m == 0) {
        return n <= threshold ? n : -1;
    }
    if (n > m) {
        // swap the two strings to consume less memory
        CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    // 'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    // placeholder to assist in swapping p and d
    int[] _d;
    // fill in starting table values
    int boundary = Math.min(n, threshold) + 1;
    for (int i = 0; i < boundary; i++) {
        p[i] = i;
    }
    // these fills ensure that the value above the rightmost entry of our
    // stripe will be ignored in following loop iterations
    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);
    Arrays.fill(d, Integer.MAX_VALUE);
    // iterates through t
    for (int j = 1; j <= m; j++) {
        // jth character of t
        char t_j = t.charAt(j - 1);
        d[0] = j;
        // compute stripe indices, constrain to array size
        int min = Math.max(1, j - threshold);
        int max = Math.min(n, j + threshold);
        // the stripe may lead off of the table if s and t are of different sizes
        if (min > max) {
            return -1;
        }
        // ignore entry left of leftmost
        if (min > 1) {
            d[min - 1] = Integer.MAX_VALUE;
        }
        // iterates through [min, max] in s
        for (int i = min; i <= max; i++) {
            if (s.charAt(i - 1) == t_j) {
                // diagonally left and up
                d[i] = p[i - 1];
            } else {
                // 1 + minimum of cell to the left, to the top, diagonally left and up
                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);
            }
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // if p[n] is greater than the threshold, there's no guarantee on it being the correct
    // distance
    if (p[n] <= threshold) {
        return p[n];
    } else {
        return -1;
    }
}","public void test051136() throws Throwable {
    StringUtils.stripAccents(""java.text.Normalizer"");
    StringUtils.indexOf((CharSequence) ""java.text.Normalizer"", (-1285));
    StringUtils.isAllUpperCase(""java.text.Normalizer"");
    StringUtils.indexOfAnyBut((CharSequence) ""java.text.Normalizer"", (CharSequence) ""java.text.Normalizer"");
    StringUtils.getLevenshteinDistance((CharSequence) ""java.text.Normalizer"", (CharSequence) ""java.text.Normalizer"");
    StringUtils.center(""java.text.Normalizer"", (-1));
    String string0 = ""AqJ"";
    StringUtils.normalizeSpace(""AqJ"");
    StringUtils.lastIndexOfAny(""AqJ"", (CharSequence[]) null);
    StringUtils.getLevenshteinDistance((CharSequence) ""java.text.Normalizer"", (CharSequence) ""java.text.Normalizer"");
    String string1 = ""Minimum abbreviation width is 4"";
    StringUtils.chop(""Minimum abbreviation width is 4"");
    StringUtils.join((Object[]) null, '%', (-1), 0);
    // Undeclared exception!
    try {
        StringUtils.getLevenshteinDistance((CharSequence) null, (CharSequence) null, (-185));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Strings must not be null
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}","/**
 * <p>Find the Levenshtein distance between two Strings if it's less than or equal to a given
 * threshold.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>This implementation follows from Algorithms on Strings, Trees and Sequences by Dan Gusfield
 * and Chas Emerick's implementation of the Levenshtein distance algorithm from
 * <a href=""http://www.merriampark.com/ld.htm"">http://www.merriampark.com/ld.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, *, -1)               = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("""","""", 0)               = 0
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 8)       = 7
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 7)       = 7
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 6))      = -1
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"", 7) = 7
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"", 6) = -1
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"", 7) = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"", 6) = -1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @param threshold the target threshold, must not be negative
 * @return result distance, or {@code -1} if the distance would be greater than the threshold
 * @throws IllegalArgumentException if either String input {@code null} or negative threshold
 */"
"// IndexOfAnyBut chars
//-----------------------------------------------------------------------
/**
 * <p>Searches a CharSequence to find the first index of any
 * character not in the given set of characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A {@code null} or zero length search array will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAnyBut(null, *)                              = -1
 * StringUtils.indexOfAnyBut("""", *)                                = -1
 * StringUtils.indexOfAnyBut(*, null)                              = -1
 * StringUtils.indexOfAnyBut(*, [])                                = -1
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", new char[] {'z', 'a'} ) = 3
 * StringUtils.indexOfAnyBut(""aba"", new char[] {'z'} )             = 0
 * StringUtils.indexOfAnyBut(""aba"", new char[] {'a', 'b'} )        = -1
 *
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAnyBut(String, char[]) to indexOfAnyBut(CharSequence, char...)
 */
public static int indexOfAnyBut(CharSequence cs, char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int csLen = cs.length();
    int csLast = csLen - 1;
    int searchLen = searchChars.length;
    int searchLast = searchLen - 1;
    outer: for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
                    if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        continue outer;
                    }
                } else {
                    continue outer;
                }
            }
        }
        return i;
    }
    return INDEX_NOT_FOUND;
}","public void test052137() throws Throwable {
    StringUtils.replaceEachRepeatedly(""p{InCombiningDiacriticalMarks}+"", (String[]) null, (String[]) null);
    StringUtils.indexOfAny((CharSequence) ""p{InCombiningDiacriticalMarks}+"", (CharSequence[]) null);
    StringUtils.indexOfAnyBut((CharSequence) ""p{InCombiningDiacriticalMarks}+"", (CharSequence) ""p{InCombiningDiacriticalMarks}+"");
    StringUtils.equalsIgnoreCase(""p{InCombiningDiacriticalMarks}+"", ""p{InCombiningDiacriticalMarks}+"");
    StringUtils.center(""p{InCombiningDiacriticalMarks}+"", (-1), '\""');
    char[] charArray0 = new char[2];
    charArray0[0] = '\""';
    charArray0[1] = '\""';
    StringUtils.containsAny((CharSequence) ""p{InCombiningDiacriticalMarks}+"", charArray0);
    StringUtils.leftPad("")S"", 64, ""x$|yO&F"");
    StringUtils.lastIndexOfAny(""x$|yO&Fx$|yO&Fx$|yO&Fx$|yO&Fx$|yO&Fx$|yO&Fx$|yO&Fx$|yO&Fx$|yO&)S"", (CharSequence[]) null);
    StringUtils.indexOfAnyBut((CharSequence) ""x$|yO&Fx$|yO&Fx$|yO&Fx$|yO&Fx$|yO&Fx$|yO&Fx$|yO&Fx$|yO&Fx$|yO&)S"", charArray0);
}",""
"public static <T extends CharSequence> T defaultIfBlank(T str, T defaultStr) {
    return StringUtils.isBlank(str) ? defaultStr : str;
}","public void test053138() throws Throwable {
    StringUtils.replaceEachRepeatedly(""p{InCombiningDiacriticalMarks}+"", (String[]) null, (String[]) null);
    StringUtils.indexOfAny((CharSequence) ""p{InCombiningDiacriticalMarks}+"", (CharSequence[]) null);
    StringUtils.indexOfAnyBut((CharSequence) ""p{InCombiningDiacriticalMarks}+"", (CharSequence) ""p{InCombiningDiacriticalMarks}+"");
    StringUtils.equalsIgnoreCase(""p{InCombiningDiacriticalMarks}+"", ""p{InCombiningDiacriticalMarks}+"");
    StringUtils.center(""p{InCombiningDiacriticalMarks}+"", (-1), '\""');
    char[] charArray0 = new char[2];
    charArray0[0] = '\""';
    charArray0[1] = '\""';
    StringUtils.containsAny((CharSequence) ""p{InCombiningDiacriticalMarks}+"", charArray0);
    StringUtils.splitByCharacterType((String) null);
    StringUtils.defaultIfBlank(""p{InCombiningDiacriticalMarks}+"", (String) null);
}","/**
 * <p>Returns either the passed in CharSequence, or if the CharSequence is
 * whitespace, empty ("""") or {@code null}, the value of {@code defaultStr}.</p>
 *
 * <pre>
 * StringUtils.defaultIfBlank(null, ""NULL"")  = ""NULL""
 * StringUtils.defaultIfBlank("""", ""NULL"")    = ""NULL""
 * StringUtils.defaultIfBlank("" "", ""NULL"")   = ""NULL""
 * StringUtils.defaultIfBlank(""bat"", ""NULL"") = ""bat""
 * StringUtils.defaultIfBlank("""", null)      = null
 * </pre>
 * @param <T> the specific kind of CharSequence
 * @param str the CharSequence to check, may be null
 * @param defaultStr  the default CharSequence to return
 *  if the input is whitespace, empty ("""") or {@code null}, may be null
 * @return the passed in CharSequence, or the default
 * @see StringUtils#defaultString(String, String)
 */"
"public static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr, int startPos) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    if (startPos > (str.length() - searchStr.length())) {
        startPos = str.length() - searchStr.length();
    }
    if (startPos < 0) {
        return INDEX_NOT_FOUND;
    }
    if (searchStr.length() == 0) {
        return startPos;
    }
    for (int i = startPos; i >= 0; i--) {
        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test054139() throws Throwable {
    StringUtils.defaultString(""qOhURx"");
    StringUtils.countMatches(""qOhURx"", ""qOhURx"");
    StringUtils.split(""J7OjkYg<"", ""qOhURx"");
    StringUtils.chop(""#Ckx<IqyS(g)f0"");
    StringUtils.rightPad(""IllegalAccessException occurred"", 1, ""#Ckx<IqyS(g)f0"");
    StringUtils.defaultIfBlank(""IllegalAccessException occurred"", ""w~nKs"");
    StringUtils.replaceChars(""IllegalAccessException occurred"", ""w~nKs"", ""#Ckx<IqyS(g)f"");
    StringUtils.defaultString(""IllegalAccessException occurred"", ""}xm,UE(tshE5f*#-yuX"");
    Stack<String> stack0 = new Stack<String>();
    Iterator<String> iterator0 = stack0.iterator();
    StringUtils.join(iterator0, 'D');
    StringUtils.equals((CharSequence) ""IllegalAccessException occurred"", (CharSequence) ""IllegalAccessException occurred"");
    StringUtils.lastIndexOfIgnoreCase((CharSequence) null, (CharSequence) ""}xm,UE(tshE5f*#-yuX"", 3244);
}","/**
 * <p>Case in-sensitive find of the last index within a CharSequence
 * from the specified position.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A negative start position returns {@code -1}.
 * An empty ("""") search CharSequence always matches unless the start position is negative.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOfIgnoreCase(null, *, *)          = -1
 * StringUtils.lastIndexOfIgnoreCase(*, null, *)          = -1
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""A"", 8)  = 7
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"", 8)  = 5
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""AB"", 8) = 4
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"", 9)  = 5
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"", -1) = -1
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""A"", 0)  = 0
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"", 0)  = -1
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @param startPos  the start position
 * @return the first index of the search CharSequence,
 *  -1 if no match or {@code null} input
 * @since 2.5
 * @since 3.0 Changed signature from lastIndexOfIgnoreCase(String, String, int) to lastIndexOfIgnoreCase(CharSequence, CharSequence, int)
 */"
"// IndexOfAny chars
//-----------------------------------------------------------------------
/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A {@code null} String will return {@code -1}.
 * A {@code null} or zero length search array will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)                = -1
 * StringUtils.indexOfAny("""", *)                  = -1
 * StringUtils.indexOfAny(*, null)                = -1
 * StringUtils.indexOfAny(*, [])                  = -1
 * StringUtils.indexOfAny(""zzabyycdxx"",['z','a']) = 0
 * StringUtils.indexOfAny(""zzabyycdxx"",['b','y']) = 3
 * StringUtils.indexOfAny(""aba"", ['z'])           = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAny(String, char[]) to indexOfAny(CharSequence, char...)
 */
public static int indexOfAny(CharSequence cs, char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int csLen = cs.length();
    int csLast = csLen - 1;
    int searchLen = searchChars.length;
    int searchLast = searchLen - 1;
    for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
                    // ch is a supplementary character
                    if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        return i;
                    }
                } else {
                    return i;
                }
            }
        }
    }
    return INDEX_NOT_FOUND;
}","public void test055140() throws Throwable {
    StringUtils.rightPad(""SecurityException occurred"", 732, ""J?(JzYNZQ"");
    StringUtils.endsWithIgnoreCase(""SecurityException occurredJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(J"", ""J?(JzYNZQ"");
    Object[] objectArray0 = new Object[1];
    objectArray0[0] = (Object) ""J?(JzYNZQ"";
    StringUtils.join(objectArray0, '|');
    CharBuffer charBuffer0 = CharBuffer.wrap((CharSequence) ""J?(JzYNZQ"");
    CharBuffer charBuffer1 = StringUtils.defaultIfEmpty(charBuffer0, charBuffer0);
    StringUtils.replace("""", ""J?(JzYNZQ"", "" O"");
    StringUtils.contains((CharSequence) """", (CharSequence) "" O"");
    StringUtils.split(""SecurityException occurred"", 'o');
    StringUtils.split("""", "" O"", (-950));
    StringUtils.isAlphanumericSpace(charBuffer0);
    StringUtils.lastIndexOf((CharSequence) "" O"", (CharSequence) "" O"", 732);
    StringUtils.indexOf((CharSequence) charBuffer0, (CharSequence) charBuffer1);
    StringUtils.substring(""SecurityException occurred"", (-950));
    StringUtils.lowerCase("""");
    StringUtils.isWhitespace(""J?(JzYNZQ"");
    StringUtils.substringBefore(""wz}"", ""SecurityException occurred"");
    StringUtils.deleteWhitespace(""SecurityException occurredJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(JzYNZQJ?(J"");
    StringUtils.isAlphanumericSpace(""J?(JzYNZQ"");
    StringUtils.upperCase("""");
    StringUtils.isEmpty("""");
    StringUtils.right("""", 0);
    char[] charArray0 = new char[8];
    charArray0[0] = '|';
    charArray0[1] = 'o';
    charArray0[2] = 'o';
    charArray0[3] = '\""';
    charArray0[4] = '|';
    charArray0[5] = '|';
    charArray0[6] = 'o';
    charArray0[7] = '|';
    StringUtils.indexOfAny((CharSequence) """", charArray0);
}",""
"public static String replace(String text, String searchString, String replacement) {
    return replace(text, searchString, replacement, -1);
}","public void test057142() throws Throwable {
    StringUtils.capitalize(""|`?_p[g"");
    StringUtils.isAlphaSpace(""|`?_p[g"");
    String[] stringArray0 = new String[5];
    stringArray0[0] = ""|`?_p[g"";
    stringArray0[1] = ""|`?_p[g"";
    stringArray0[2] = ""|`?_p[g"";
    stringArray0[3] = ""Dy_r=Wr2"";
    stringArray0[4] = ""|`?_p[g"";
    StringUtils.getCommonPrefix(stringArray0);
    StringUtils.defaultIfEmpty(""|`?_p[g"", """");
    StringUtils.containsIgnoreCase(""|`?_p[g"", ""|`?_p[g"");
    StringUtils.containsAny((CharSequence) ""Dy_r=Wr2"", (CharSequence) ""|`?_p[g"");
    StringUtils.isAlpha(""|`?_p[g"");
    StringUtils.rightPad("""", (-379), 'b');
    StringUtils.stripAll(stringArray0);
    StringUtils.isNumericSpace(""|`?_p[g"");
    StringUtils.reverseDelimited(""Dy_r=Wr2"", '8');
    StringUtils.endsWithAny(""Dy_r=Wr2"", stringArray0);
    StringUtils.substringsBetween(""|`?_p[g"", ""|`?_p[g"", ""|`?_p[g"");
    StringUtils.substringBefore("""", ""Dy_r=Wr2"");
    StringUtils.join((Object[]) stringArray0, """");
    StringUtils.splitByWholeSeparator(""Dy_r=Wr2"", ""Dy_r=Wr2"", (-379));
    StringUtils.replaceEach("""", (String[]) null, stringArray0);
    StringUtils.repeat((String) null, (String) null, (-379));
    StringUtils.replace("""", ""Dy_r=Wr2"", """");
}","/**
 * <p>Replaces all occurrences of a String within another String.</p>
 *
 * <p>A {@code null} reference passed to this method is a no-op.</p>
 *
 * <pre>
 * StringUtils.replace(null, *, *)        = null
 * StringUtils.replace("""", *, *)          = """"
 * StringUtils.replace(""any"", null, *)    = ""any""
 * StringUtils.replace(""any"", *, null)    = ""any""
 * StringUtils.replace(""any"", """", *)      = ""any""
 * StringUtils.replace(""aba"", ""a"", null)  = ""aba""
 * StringUtils.replace(""aba"", ""a"", """")    = ""b""
 * StringUtils.replace(""aba"", ""a"", ""z"")   = ""zbz""
 * </pre>
 *
 * @see #replace(String text, String searchString, String replacement, int max)
 * @param text  text to search and replace in, may be null
 * @param searchString  the String to search for, may be null
 * @param replacement  the String to replace it with, may be null
 * @return the text with any replacements processed,
 *  {@code null} if null String input
 */"
"public static String join(Object[] array, String separator, int startIndex, int endIndex) {
    if (array == null) {
        return null;
    }
    if (separator == null) {
        separator = EMPTY;
    }
    // endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))
    //           (Assuming that all Strings are roughly equally long)
    int noOfItems = (endIndex - startIndex);
    if (noOfItems <= 0) {
        return EMPTY;
    }
    StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}","public void test058143() throws Throwable {
    StringUtils.substringBefore((String) null, ""@azBm88c()P"");
    StringUtils.substringAfterLast(""[WSgCB Kue.?/.]'9"", ""@azBm88c()P"");
    StringUtils.lastOrdinalIndexOf((CharSequence) null, ""[WSgCB Kue.?/.]'9"", (-1644));
    StringUtils.replace((String) null, ""2cU"", ""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"", (-1644));
    StringUtils.isAlphanumeric(""@azBm88c()P"");
    StringUtils.mid(""o$pWu`0q"", (-1488), 0);
    StringUtils.defaultIfBlank((CharSequence) """", (CharSequence) """");
    StringUtils.countMatches("""", """");
    StringUtils.indexOfIgnoreCase((CharSequence) null, (CharSequence) null, (-1));
    StringUtils.split((String) null);
    StringUtils.leftPad(""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"", 57, ""[WSgCB Kue.?/.]'9"");
    StringUtils.join((Object[]) null, ""@azBm88c()P"", (-1262), 0);
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A {@code null} separator is the same as an empty String ("""").
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)                = null
 * StringUtils.join([], *)                  = """"
 * StringUtils.join([null], *)              = """"
 * StringUtils.join([""a"", ""b"", ""c""], ""--"")  = ""a--b--c""
 * StringUtils.join([""a"", ""b"", ""c""], null)  = ""abc""
 * StringUtils.join([""a"", ""b"", ""c""], """")    = ""abc""
 * StringUtils.join([null, """", ""a""], ',')   = "",,a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @param startIndex the first index to start joining from.  It is
 * an error to pass in an end index past the end of the array
 * @param endIndex the index to stop joining from (exclusive). It is
 * an error to pass in an end index past the end of the array
 * @return the joined String, {@code null} if null array input
 */"
"public static String replaceChars(String str, String searchChars, String replaceChars) {
    if (isEmpty(str) || isEmpty(searchChars)) {
        return str;
    }
    if (replaceChars == null) {
        replaceChars = EMPTY;
    }
    boolean modified = false;
    int replaceCharsLength = replaceChars.length();
    int strLength = str.length();
    StringBuilder buf = new StringBuilder(strLength);
    for (int i = 0; i < strLength; i++) {
        char ch = str.charAt(i);
        int index = searchChars.indexOf(ch);
        if (index >= 0) {
            modified = true;
            if (index < replaceCharsLength) {
                buf.append(replaceChars.charAt(index));
            }
        } else {
            buf.append(ch);
        }
    }
    if (modified) {
        return buf.toString();
    }
    return str;
}","public void test059144() throws Throwable {
    StringUtils.chomp("""", """");
    StringUtils.removeStartIgnoreCase(""(Rnu{iF%.J^M#D"", ""(Rnu{iF%.J^M#D"");
    StringUtils.deleteWhitespace(""(Rnu{iF%.J^M#D"");
    StringUtils.splitPreserveAllTokens(""(Rnu{iF%.J^M#D"", ""decompose"", 0);
    StringUtils.rightPad("""", 0, ""SecurityException occurred"");
    StringUtils.capitalize(""XOq)"");
    StringUtils.removeStartIgnoreCase("""", ""I9"");
    StringUtils.uncapitalize(""Xw%#c{@u7-q"");
    String string0 = ""\\u00"";
    StringUtils.substringBetween("""", string0, ""I9"");
    StringUtils.indexOfAny((CharSequence) ""decompose"", ""7L4i=QvvR#D"");
    StringUtils.lastIndexOf((CharSequence) ""xw%#c{@u7-q"", (CharSequence) ""7L4i=QvvR#D"", 0);
    StringUtils.indexOfDifference((CharSequence) """", (CharSequence) ""I9"");
    StringUtils.center(string0, 2328);
    StringUtils.countMatches(""decompose"", string0);
    StringUtils.substringBeforeLast("""", ""7L4i=QvvR#D"");
    StringUtils.replaceChars(""XOq)"", ""& 1$3lnxT$Tmjn"", ""9isxGzoSMl(mpfWUSA"");
}","/**
 * <p>Replaces multiple characters in a String in one go.
 * This method can also be used to delete characters.</p>
 *
 * <p>For example:<br />
 * <code>replaceChars(&quot;hello&quot;, &quot;ho&quot;, &quot;jy&quot;) = jelly</code>.</p>
 *
 * <p>A {@code null} string input returns {@code null}.
 * An empty ("""") string input returns an empty string.
 * A null or empty set of search characters returns the input string.</p>
 *
 * <p>The length of the search characters should normally equal the length
 * of the replace characters.
 * If the search characters is longer, then the extra search characters
 * are deleted.
 * If the search characters is shorter, then the extra replace characters
 * are ignored.</p>
 *
 * <pre>
 * StringUtils.replaceChars(null, *, *)           = null
 * StringUtils.replaceChars("""", *, *)             = """"
 * StringUtils.replaceChars(""abc"", null, *)       = ""abc""
 * StringUtils.replaceChars(""abc"", """", *)         = ""abc""
 * StringUtils.replaceChars(""abc"", ""b"", null)     = ""ac""
 * StringUtils.replaceChars(""abc"", ""b"", """")       = ""ac""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""yz"")  = ""ayzya""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""y"")   = ""ayya""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""yzx"") = ""ayzya""
 * </pre>
 *
 * @param str  String to replace characters in, may be null
 * @param searchChars  a set of characters to search for, may be null
 * @param replaceChars  a set of characters to replace, may be null
 * @return modified String, {@code null} if null string input
 * @since 2.0
 */"
"// Overlay
//-----------------------------------------------------------------------
/**
 * <p>Overlays part of a String with another String.</p>
 *
 * <p>A {@code null} string input returns {@code null}.
 * A negative index is treated as zero.
 * An index greater than the string length is treated as the string length.
 * The start index is always the smaller of the two indices.</p>
 *
 * <pre>
 * StringUtils.overlay(null, *, *, *)            = null
 * StringUtils.overlay("""", ""abc"", 0, 0)          = ""abc""
 * StringUtils.overlay(""abcdef"", null, 2, 4)     = ""abef""
 * StringUtils.overlay(""abcdef"", """", 2, 4)       = ""abef""
 * StringUtils.overlay(""abcdef"", """", 4, 2)       = ""abef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 2, 4)   = ""abzzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 4, 2)   = ""abzzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", -1, 4)  = ""zzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 2, 8)   = ""abzzzz""
 * StringUtils.overlay(""abcdef"", ""zzzz"", -2, -3) = ""zzzzabcdef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 8, 10)  = ""abcdefzzzz""
 * </pre>
 *
 * @param str  the String to do overlaying in, may be null
 * @param overlay  the String to overlay, may be null
 * @param start  the position to start overlaying at
 * @param end  the position to stop overlaying before
 * @return overlayed String, {@code null} if null String input
 * @since 2.0
 */
public static String overlay(String str, String overlay, int start, int end) {
    if (str == null) {
        return null;
    }
    if (overlay == null) {
        overlay = EMPTY;
    }
    int len = str.length();
    if (start < 0) {
        start = 0;
    }
    if (start > len) {
        start = len;
    }
    if (end < 0) {
        end = 0;
    }
    if (end > len) {
        end = len;
    }
    if (start > end) {
        int temp = start;
        start = end;
        end = temp;
    }
    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();
}","public void test060145() throws Throwable {
    StringUtils.trimToEmpty(""org.apache.<ommons.lang3.EharUtils"");
    StringUtils.remove(""org.apache.<ommons.lang3.EharUtils"", ""org.apache.<ommons.lang3.EharUtils"");
    StringUtils.abbreviate((String) null, 3);
    StringUtils.indexOf((CharSequence) ""org.apache.<ommons.lang3.EharUtils"", (CharSequence) ""org.apache.<ommons.lang3.EharUtils"");
    StringUtils.substringBeforeLast(""org.apache.<ommons.lang3.EharUtils"", ""org.apache.<ommons.lang3.EharUtils"");
    CharSequence[] charSequenceArray0 = new CharSequence[8];
    charSequenceArray0[0] = (CharSequence) """";
    charSequenceArray0[1] = (CharSequence) """";
    charSequenceArray0[2] = (CharSequence) null;
    charSequenceArray0[3] = (CharSequence) """";
    charSequenceArray0[4] = (CharSequence) ""org.apache.<ommons.lang3.EharUtils"";
    charSequenceArray0[5] = (CharSequence) null;
    charSequenceArray0[6] = (CharSequence) """";
    charSequenceArray0[7] = (CharSequence) ""org.apache.<ommons.lang3.EharUtils"";
    StringUtils.lastIndexOfAny((CharSequence) null, charSequenceArray0);
    StringUtils.defaultString((String) null);
    StringUtils.lastIndexOfAny((CharSequence) null, charSequenceArray0);
    StringUtils.isAlphaSpace("""");
    StringUtils.isAlphaSpace(charSequenceArray0[6]);
    StringUtils.overlay((String) null, ""TUIkegA{IKa6&:_1"", 21, 21);
}",""
"// ContainsOnly
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains only certain characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.
 * A {@code null} valid character array will return {@code false}.
 * An empty CharSequence (length()=0) always returns {@code true}.</p>
 *
 * <pre>
 * StringUtils.containsOnly(null, *)       = false
 * StringUtils.containsOnly(*, null)       = false
 * StringUtils.containsOnly("""", *)         = true
 * StringUtils.containsOnly(""ab"", '')      = false
 * StringUtils.containsOnly(""abab"", 'abc') = true
 * StringUtils.containsOnly(""ab1"", 'abc')  = false
 * StringUtils.containsOnly(""abz"", 'abc')  = false
 * </pre>
 *
 * @param cs  the String to check, may be null
 * @param valid  an array of valid chars, may be null
 * @return true if it only contains valid chars and is non-null
 * @since 3.0 Changed signature from containsOnly(String, char[]) to containsOnly(CharSequence, char...)
 */
public static boolean containsOnly(CharSequence cs, char... valid) {
    // All these pre-checks are to maintain API with an older version
    if (valid == null || cs == null) {
        return false;
    }
    if (cs.length() == 0) {
        return true;
    }
    if (valid.length == 0) {
        return false;
    }
    return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND;
}","public void test061146() throws Throwable {
    StringUtils.swapCase(""decompose"");
    StringUtils.substringBeforeLast(""U6gS#r;rA-=Q}jS\""f"", ""U6gS#r;rA-=Q}jS\""f"");
    StringUtils.chomp(""DECOMPOSE"", (String) null);
    StringUtils.leftPad(""decompose"", 17, 'S');
    StringUtils.repeat(""DECOMPOSE"", ""decompose"", 17);
    StringUtils.trimToEmpty(""c-JXi_XW#n9X[eL1"");
    StringUtils.containsNone((CharSequence) ""decompose"", ""c-JXi_XW#n9X[eL1"");
    String[] stringArray0 = new String[0];
    StringUtils.stripAll(stringArray0);
    StringUtils.chop((String) null);
    StringUtils.repeat(""8qYkcKHXc*"", ""DECOMPOSE"", 4);
    StringUtils.chomp(""qOhURx"", ""c-JXi_XW#n9X[eL1"");
    char[] charArray0 = new char[8];
    charArray0[0] = 'S';
    charArray0[1] = 'S';
    charArray0[2] = 'S';
    charArray0[3] = 'S';
    charArray0[4] = 'S';
    charArray0[5] = 'S';
    charArray0[6] = 'S';
    charArray0[7] = 'S';
    StringUtils.containsOnly((CharSequence) ""decompose"", charArray0);
}",""
"public static String substringBetween(String str, String open, String close) {
    if (str == null || open == null || close == null) {
        return null;
    }
    int start = str.indexOf(open);
    if (start != INDEX_NOT_FOUND) {
        int end = str.indexOf(close, start + open.length());
        if (end != INDEX_NOT_FOUND) {
            return str.substring(start + open.length(), end);
        }
    }
    return null;
}","public void test062147() throws Throwable {
    StringUtils.replaceEachRepeatedly(""p{InCombiningDiacriticalMarks}+"", (String[]) null, (String[]) null);
    StringUtils.indexOfAny((CharSequence) ""p{InCombiningDiacriticalMarks}+"", (CharSequence[]) null);
    StringUtils.indexOfAnyBut((CharSequence) ""p{InCombiningDiacriticalMarks}+"", (CharSequence) ""p{InCombiningDiacriticalMarks}+"");
    StringUtils.equalsIgnoreCase(""p{InCombiningDiacriticalMarks}+"", ""p{InCombiningDiacriticalMarks}+"");
    StringUtils.center(""p{InCombiningDiacriticalMarks}+"", (-1), '\""');
    char[] charArray0 = new char[2];
    charArray0[0] = '\""';
    charArray0[1] = '\""';
    StringUtils.containsAny((CharSequence) ""p{InCombiningDiacriticalMarks}+"", charArray0);
    StringUtils.substringBetween("""", (String) null, ""TimeToLive of "");
}","/**
 * <p>Gets the String that is nested in between two Strings.
 * Only the first match is returned.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} open/close returns {@code null} (no match).
 * An empty ("""") open and close returns an empty string.</p>
 *
 * <pre>
 * StringUtils.substringBetween(""wx[b]yz"", ""["", ""]"") = ""b""
 * StringUtils.substringBetween(null, *, *)          = null
 * StringUtils.substringBetween(*, null, *)          = null
 * StringUtils.substringBetween(*, *, null)          = null
 * StringUtils.substringBetween("""", """", """")          = """"
 * StringUtils.substringBetween("""", """", ""]"")         = null
 * StringUtils.substringBetween("""", ""["", ""]"")        = null
 * StringUtils.substringBetween(""yabcz"", """", """")     = """"
 * StringUtils.substringBetween(""yabcz"", ""y"", ""z"")   = ""abc""
 * StringUtils.substringBetween(""yabczyabcz"", ""y"", ""z"")   = ""abc""
 * </pre>
 *
 * @param str  the String containing the substring, may be null
 * @param open  the String before the substring, may be null
 * @param close  the String after the substring, may be null
 * @return the substring, {@code null} if no match
 * @since 2.0
 */"
"public static String rightPad(String str, int size, String padStr) {
    if (str == null) {
        return null;
    }
    if (isEmpty(padStr)) {
        padStr = "" "";
    }
    int padLen = padStr.length();
    int strLen = str.length();
    int pads = size - strLen;
    if (pads <= 0) {
        // returns original String when possible
        return str;
    }
    if (padLen == 1 && pads <= PAD_LIMIT) {
        return rightPad(str, size, padStr.charAt(0));
    }
    if (pads == padLen) {
        return str.concat(padStr);
    } else if (pads < padLen) {
        return str.concat(padStr.substring(0, pads));
    } else {
        char[] padding = new char[pads];
        char[] padChars = padStr.toCharArray();
        for (int i = 0; i < pads; i++) {
            padding[i] = padChars[i % padLen];
        }
        return str.concat(new String(padding));
    }
}","public void test063148() throws Throwable {
    StringUtils.removeEnd("""", """");
    StringUtils.indexOfAny((CharSequence) """", """");
    StringUtils.removeEnd("""", """");
    StringUtils.substringsBetween((String) null, """", """");
    StringUtils.overlay((String) null, ""HF9:..GW9bxT9,)A\""m5"", (-1), (-1));
    StringUtils.replace(""', is neither of type Map.Entry nor an Array"", (String) null, (String) null, (-1));
    StringUtils.difference((String) null, ""Zby: ?e#V"");
    StringUtils.indexOfAnyBut((CharSequence) ""', is neither of type Map.Entry nor an Array"", (CharSequence) ""', is neither of type Map.Entry nor an Array"");
    StringUtils.left(""^qRmUGl$p"", 0);
    StringUtils.lastIndexOf((CharSequence) ""', is neither of type Map.Entry nor an Array"", (CharSequence) ""', is neither of type Map.Entry nor an Array"", 296);
    StringUtils.indexOfDifference((CharSequence) """", (CharSequence) """");
    StringUtils.splitByCharacterTypeCamelCase(""HF9:..GW9bxT9,)A\""m5"");
    StringUtils.lastIndexOf((CharSequence) null, (CharSequence) """", 10);
    Locale locale0 = Locale.ROOT;
    StringUtils.lowerCase((String) null, locale0);
    StringUtils.lowerCase(""Ot=:HKA:tU*$S$|"", locale0);
    StringUtils.right(""{}"", 0);
    StringUtils.lastIndexOf((CharSequence) ""', is neither of type Map.Entry nor an Array"", (-1));
    StringUtils.replaceChars((String) null, """", """");
    StringUtils.substringBefore(""java.text.Normalizer is not available"", """");
    StringUtils.leftPad((String) null, 105);
    StringUtils.rightPad("";[(D][|_#9xrF7OD<"", 57, ""quLuQcV/"");
}","/**
 * <p>Right pad a String with a specified String.</p>
 *
 * <p>The String is padded to the size of {@code size}.</p>
 *
 * <pre>
 * StringUtils.rightPad(null, *, *)      = null
 * StringUtils.rightPad("""", 3, ""z"")      = ""zzz""
 * StringUtils.rightPad(""bat"", 3, ""yz"")  = ""bat""
 * StringUtils.rightPad(""bat"", 5, ""yz"")  = ""batyz""
 * StringUtils.rightPad(""bat"", 8, ""yz"")  = ""batyzyzy""
 * StringUtils.rightPad(""bat"", 1, ""yz"")  = ""bat""
 * StringUtils.rightPad(""bat"", -1, ""yz"") = ""bat""
 * StringUtils.rightPad(""bat"", 5, null)  = ""bat  ""
 * StringUtils.rightPad(""bat"", 5, """")    = ""bat  ""
 * </pre>
 *
 * @param str  the String to pad out, may be null
 * @param size  the size to pad to
 * @param padStr  the String to pad with, null or empty treated as single space
 * @return right padded String or original String if no padding is necessary,
 *  {@code null} if null String input
 */"
"public static int indexOfDifference(CharSequence cs1, CharSequence cs2) {
    if (cs1 == cs2) {
        return INDEX_NOT_FOUND;
    }
    if (cs1 == null || cs2 == null) {
        return 0;
    }
    int i;
    for (i = 0; i < cs1.length() && i < cs2.length(); ++i) {
        if (cs1.charAt(i) != cs2.charAt(i)) {
            break;
        }
    }
    if (i < cs2.length() || i < cs1.length()) {
        return i;
    }
    return INDEX_NOT_FOUND;
}","public void test064149() throws Throwable {
    StringUtils.remove(""IllegalAccessException occurred"", '*');
    StringUtils.containsOnly((CharSequence) ""IllegalAccessException occurred"", ""'xO0|s8i0X{idY(Ky"");
    StringUtils.contains((CharSequence) ""IllegalAccessException occurred"", (CharSequence) ""'xO0|s8i0X{idY(Ky"");
    StringUtils.isAlphanumericSpace(""IllegalAccessException occurred"");
    StringUtils.deleteWhitespace(""Rv/K`JUJO5)q"");
    StringUtils.containsWhitespace(""Rv/K`JUJO5)q"");
    StringUtils.isAllLowerCase(""Rv/K`JUJO5)q"");
    String string0 = ""\\u0"";
    StringUtils.substringBetween(""Rv/K`JUJO5)q"", string0, string0);
    StringUtils.countMatches(""IllegalAccessException occurred"", ""IllegalAccessException occurred"");
    CharSequence[] charSequenceArray0 = new CharSequence[9];
    charSequenceArray0[0] = (CharSequence) ""IllegalAccessException occurred"";
    charSequenceArray0[1] = (CharSequence) ""'xO0|s8i0X{idY(Ky"";
    charSequenceArray0[2] = (CharSequence) ""IllegalAccessException occurred"";
    charSequenceArray0[3] = (CharSequence) ""Rv/K`JUJO5)q"";
    charSequenceArray0[4] = (CharSequence) ""'xO0|s8i0X{idY(Ky"";
    charSequenceArray0[5] = (CharSequence) ""IllegalAccessException occurred"";
    charSequenceArray0[6] = (CharSequence) string0;
    charSequenceArray0[7] = (CharSequence) ""IllegalAccessException occurred"";
    charSequenceArray0[8] = (CharSequence) string0;
    StringUtils.endsWithAny(""Rv/K`JUJO5)q"", charSequenceArray0);
    StringUtils.isAllUpperCase(charSequenceArray0[7]);
    String[] stringArray0 = new String[4];
    stringArray0[0] = ""IllegalAccessException occurred"";
    stringArray0[1] = ""IllegalAccessException occurred"";
    stringArray0[2] = ""IllegalAccessException occurred"";
    stringArray0[3] = null;
    StringUtils.getCommonPrefix(stringArray0);
    StringUtils.indexOfDifference(charSequenceArray0[7], (CharSequence) """");
}","/**
 * <p>Compares two CharSequences, and returns the index at which the
 * CharSequences begin to differ.</p>
 *
 * <p>For example,
 * {@code indexOfDifference(""i am a machine"", ""i am a robot"") -> 7}</p>
 *
 * <pre>
 * StringUtils.indexOfDifference(null, null) = -1
 * StringUtils.indexOfDifference("""", """") = -1
 * StringUtils.indexOfDifference("""", ""abc"") = 0
 * StringUtils.indexOfDifference(""abc"", """") = 0
 * StringUtils.indexOfDifference(""abc"", ""abc"") = -1
 * StringUtils.indexOfDifference(""ab"", ""abxyz"") = 2
 * StringUtils.indexOfDifference(""abcde"", ""abxyz"") = 2
 * StringUtils.indexOfDifference(""abcde"", ""xyz"") = 0
 * </pre>
 *
 * @param cs1  the first CharSequence, may be null
 * @param cs2  the second CharSequence, may be null
 * @return the index where cs1 and cs2 begin to differ; -1 if they are equal
 * @since 2.0
 * @since 3.0 Changed signature from indexOfDifference(String, String) to
 * indexOfDifference(CharSequence, CharSequence)
 */"
"public static String repeat(char ch, int repeat) {
    char[] buf = new char[repeat];
    for (int i = repeat - 1; i >= 0; i--) {
        buf[i] = ch;
    }
    return new String(buf);
}","public void test065150() throws Throwable {
    StringUtils.center(""java.text.Normalizer$Form"", 225, """");
    StringUtils.splitByCharacterTypeCamelCase("""");
    StringUtils.equalsIgnoreCase("""", ""java.text.Normalizer$Form"");
    StringUtils.contains((CharSequence) ""                                                                                                    java.text.Normalizer$Form                                                                                                    "", (CharSequence) ""java.text.Normalizer$Form"");
    StringUtils.endsWith(""java.text.Normalizer$Form"", ""                                                                                                    java.text.Normalizer$Form                                                                                                    "");
    char[] charArray0 = new char[8];
    charArray0[0] = '0';
    charArray0[1] = '\\';
    charArray0[2] = '8';
    charArray0[3] = '7';
    charArray0[4] = 'U';
    charArray0[5] = 'H';
    charArray0[6] = '8';
    charArray0[7] = '<';
    StringUtils.containsAny((CharSequence) """", charArray0);
    StringUtils.deleteWhitespace("""");
    String string0 = ""\\u0"";
    String[] stringArray0 = StringUtils.splitByWholeSeparatorPreserveAllTokens(string0, ""96NF:'d)CA5[~Wm"", 225);
    String string1 = StringUtils.substringAfter(string0, """");
    StringUtils.indexOfAny((CharSequence) ""96NF:'d)CA5[~Wm"", ""                                                                                                    java.text.Normalizer$Form                                                                                                    "");
    StringUtils.indexOfAny((CharSequence) string0, (CharSequence[]) stringArray0);
    String string2 = StringUtils.substringBeforeLast(string1, ""X"");
    StringUtils.indexOfAny((CharSequence) string2, charArray0);
    StringUtils.repeat('U', 2);
}","/**
 * <p>Returns padding using the specified delimiter repeated
 * to a given length.</p>
 *
 * <pre>
 * StringUtils.repeat(0, 'e')  = """"
 * StringUtils.repeat(3, 'e')  = ""eee""
 * StringUtils.repeat(-2, 'e') = """"
 * </pre>
 *
 * <p>Note: this method doesn't not support padding with
 * <a href=""http://www.unicode.org/glossary/#supplementary_character"">Unicode Supplementary Characters</a>
 * as they require a pair of {@code char}s to be represented.
 * If you are needing to support full I18N of your applications
 * consider using {@link #repeat(String, int)} instead.
 * </p>
 *
 * @param ch  character to repeat
 * @param repeat  number of times to repeat char, negative treated as zero
 * @return String with repeated character
 * @see #repeat(String, int)
 */"
"public static int getLevenshteinDistance(CharSequence s, CharSequence t, int threshold) {
    if (s == null || t == null) {
        throw new IllegalArgumentException(""Strings must not be null"");
    }
    if (threshold < 0) {
        throw new IllegalArgumentException(""Threshold must not be negative"");
    }
    /*
        This implementation only computes the distance if it's less than or equal to the
        threshold value, returning -1 if it's greater.  The advantage is performance: unbounded
        distance is O(nm), but a bound of k allows us to reduce it to O(km) time by only 
        computing a diagonal stripe of width 2k + 1 of the cost table.
        It is also possible to use this to compute the unbounded Levenshtein distance by starting
        the threshold at 1 and doubling each time until the distance is found; this is O(dm), where
        d is the distance.
        
        One subtlety comes from needing to ignore entries on the border of our stripe
        eg.
        p[] = |#|#|#|*
        d[] =  *|#|#|#|
        We must ignore the entry to the left of the leftmost member
        We must ignore the entry above the rightmost member
        
        Another subtlety comes from our stripe running off the matrix if the strings aren't
        of the same size.  Since string s is always swapped to be the shorter of the two, 
        the stripe will always run off to the upper right instead of the lower left of the matrix.
        
        As a concrete example, suppose s is of length 5, t is of length 7, and our threshold is 1.
        In this case we're going to walk a stripe of length 3.  The matrix would look like so:
        
           1 2 3 4 5
        1 |#|#| | | |
        2 |#|#|#| | |
        3 | |#|#|#| |
        4 | | |#|#|#|
        5 | | | |#|#|
        6 | | | | |#|
        7 | | | | | |

        Note how the stripe leads off the table as there is no possible way to turn a string of length 5
        into one of length 7 in edit distance of 1.
        
        Additionally, this implementation decreases memory usage by using two 
        single-dimensional arrays and swapping them back and forth instead of allocating
        an entire n by m matrix.  This requires a few minor changes, such as immediately returning 
        when it's detected that the stripe has run off the matrix and initially filling the arrays with
        large values so that entries we don't compute are ignored.

        See Algorithms on Strings, Trees and Sequences by Dan Gusfield for some discussion.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    // if one string is empty, the edit distance is necessarily the length of the other
    if (n == 0) {
        return m <= threshold ? m : -1;
    } else if (m == 0) {
        return n <= threshold ? n : -1;
    }
    if (n > m) {
        // swap the two strings to consume less memory
        CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    // 'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    // placeholder to assist in swapping p and d
    int[] _d;
    // fill in starting table values
    int boundary = Math.min(n, threshold) + 1;
    for (int i = 0; i < boundary; i++) {
        p[i] = i;
    }
    // these fills ensure that the value above the rightmost entry of our
    // stripe will be ignored in following loop iterations
    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);
    Arrays.fill(d, Integer.MAX_VALUE);
    // iterates through t
    for (int j = 1; j <= m; j++) {
        // jth character of t
        char t_j = t.charAt(j - 1);
        d[0] = j;
        // compute stripe indices, constrain to array size
        int min = Math.max(1, j - threshold);
        int max = Math.min(n, j + threshold);
        // the stripe may lead off of the table if s and t are of different sizes
        if (min > max) {
            return -1;
        }
        // ignore entry left of leftmost
        if (min > 1) {
            d[min - 1] = Integer.MAX_VALUE;
        }
        // iterates through [min, max] in s
        for (int i = min; i <= max; i++) {
            if (s.charAt(i - 1) == t_j) {
                // diagonally left and up
                d[i] = p[i - 1];
            } else {
                // 1 + minimum of cell to the left, to the top, diagonally left and up
                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);
            }
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // if p[n] is greater than the threshold, there's no guarantee on it being the correct
    // distance
    if (p[n] <= threshold) {
        return p[n];
    } else {
        return -1;
    }
}","public void test066151() throws Throwable {
    StringUtils.defaultIfEmpty((String) null, (String) null);
    StringUtils.splitByWholeSeparator((String) null, "",F*,8W?<%"", 128);
    String string0 = ""vDPx(Q6BG~~,K:+rbc"";
    StringUtils.replace("""", "",F*,8W?<%"", ""vDPx(Q6BG~~,K:+rbc"");
    // Undeclared exception!
    try {
        StringUtils.getLevenshteinDistance((CharSequence) null, (CharSequence) null, 128);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Strings must not be null
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}","/**
 * <p>Find the Levenshtein distance between two Strings if it's less than or equal to a given
 * threshold.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>This implementation follows from Algorithms on Strings, Trees and Sequences by Dan Gusfield
 * and Chas Emerick's implementation of the Levenshtein distance algorithm from
 * <a href=""http://www.merriampark.com/ld.htm"">http://www.merriampark.com/ld.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, *, -1)               = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("""","""", 0)               = 0
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 8)       = 7
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 7)       = 7
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 6))      = -1
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"", 7) = 7
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"", 6) = -1
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"", 7) = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"", 6) = -1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @param threshold the target threshold, must not be negative
 * @return result distance, or {@code -1} if the distance would be greater than the threshold
 * @throws IllegalArgumentException if either String input {@code null} or negative threshold
 */"
"public static String replaceEach(String text, String[] searchList, String[] replacementList) {
    return replaceEach(text, searchList, replacementList, false, 0);
}","public void test067152() throws Throwable {
    StringUtils.capitalize(""|`?_p[g"");
    StringUtils.isAlphaSpace(""|`?_p[g"");
    String[] stringArray0 = new String[5];
    stringArray0[0] = ""|`?_p[g"";
    stringArray0[1] = ""|`?_p[g"";
    stringArray0[2] = ""|`?_p[g"";
    stringArray0[3] = ""Dy_r=Wr2"";
    stringArray0[4] = ""|`?_p[g"";
    StringUtils.getCommonPrefix(stringArray0);
    StringUtils.defaultIfEmpty(""|`?_p[g"", """");
    StringUtils.containsIgnoreCase(""|`?_p[g"", ""|`?_p[g"");
    StringUtils.containsAny((CharSequence) ""Dy_r=Wr2"", (CharSequence) ""|`?_p[g"");
    StringUtils.isAlpha(""|`?_p[g"");
    int int0 = (-379);
    StringUtils.rightPad("""", (-379), 'b');
    StringUtils.stripAll(stringArray0);
    StringUtils.isNumericSpace(""|`?_p[g"");
    StringUtils.reverseDelimited(""Dy_r=Wr2"", '8');
    StringUtils.endsWithAny(""Dy_r=Wr2"", stringArray0);
    String[] stringArray1 = StringUtils.splitByWholeSeparator(""}@s`E{_"", ""Dy_r=Wr2"");
    StringUtils.substringBefore("""", ""Dy_r=Wr2"");
    StringUtils.join((Object[]) stringArray0, """");
    StringUtils.splitByWholeSeparator(""Dy_r=Wr2"", ""Dy_r=Wr2"", (-379));
    // Undeclared exception!
    try {
        StringUtils.replaceEach(""Dy_r=Wr2"", stringArray1, stringArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Search and Replace array lengths don't match: 1 vs 5
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}","/**
 * <p>
 * Replaces all occurrences of Strings within another String.
 * </p>
 *
 * <p>
 * A {@code null} reference passed to this method is a no-op, or if
 * any ""search string"" or ""string to replace"" is null, that replace will be
 * ignored. This will not repeat. For repeating replaces, call the
 * overloaded method.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *)        = null
 *  StringUtils.replaceEach("""", *, *)          = """"
 *  StringUtils.replaceEach(""aba"", null, null) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[0], null) = ""aba""
 *  StringUtils.replaceEach(""aba"", null, new String[0]) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, null)  = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""})  = ""b""
 *  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""})  = ""aba""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""})  = ""wcte""
 *  (example of how it does not repeat)
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""})  = ""dcte""
 * </pre>
 *
 * @param text
 *            text to search and replace in, no-op if null
 * @param searchList
 *            the Strings to search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @return the text with any replacements processed, {@code null} if
 *         null String input
 * @throws IndexOutOfBoundsException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */"
"public static boolean containsOnly(CharSequence cs, String validChars) {
    if (cs == null || validChars == null) {
        return false;
    }
    return containsOnly(cs, validChars.toCharArray());
}","public void test068153() throws Throwable {
    StringUtils.substringBefore((String) null, ""@HazBm8c()P"");
    StringUtils.substringAfterLast(""[WSgCB Kue.?/.]'9"", ""@HazBm8c()P"");
    StringUtils.lastOrdinalIndexOf((CharSequence) null, ""[WSgCB Kue.?/.]'9"", (-1644));
    StringUtils.defaultIfEmpty(""2cU"", ""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"");
    StringUtils.isAlphanumeric(""@HazBm8c()P"");
    StringUtils.mid(""o$pWu`0q"", (-1488), 0);
    StringUtils.defaultIfBlank((CharSequence) """", (CharSequence) """");
    StringUtils.countMatches("""", """");
    StringUtils.indexOfIgnoreCase((CharSequence) ""2cU"", (CharSequence) ""2cU"", (-225));
    StringUtils.split((String) null);
    StringUtils.leftPad(""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"", 57, ""L"");
    CharSequence[] charSequenceArray0 = new CharSequence[4];
    charSequenceArray0[0] = (CharSequence) ""L"";
    charSequenceArray0[1] = (CharSequence) ""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"";
    charSequenceArray0[2] = (CharSequence) null;
    charSequenceArray0[3] = (CharSequence) ""2cU"";
    StringUtils.indexOfAny((CharSequence) ""2cU"", charSequenceArray0);
    StringUtils.isAllLowerCase(""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"");
    StringUtils.indexOf((CharSequence) ""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"", (CharSequence) """", (-655907931));
    StringUtils.containsOnly((CharSequence) ""2cU"", ""...org.apache.commons.lang3.CharUtils"");
}","/**
 * <p>Checks if the CharSequence contains only certain characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.
 * A {@code null} valid character String will return {@code false}.
 * An empty String (length()=0) always returns {@code true}.</p>
 *
 * <pre>
 * StringUtils.containsOnly(null, *)       = false
 * StringUtils.containsOnly(*, null)       = false
 * StringUtils.containsOnly("""", *)         = true
 * StringUtils.containsOnly(""ab"", """")      = false
 * StringUtils.containsOnly(""abab"", ""abc"") = true
 * StringUtils.containsOnly(""ab1"", ""abc"")  = false
 * StringUtils.containsOnly(""abz"", ""abc"")  = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param validChars  a String of valid chars, may be null
 * @return true if it only contains valid chars and is non-null
 * @since 2.0
 * @since 3.0 Changed signature from containsOnly(String, String) to containsOnly(CharSequence, String)
 */"
"// Misc
//-----------------------------------------------------------------------
/**
 * <p>Find the Levenshtein distance between two Strings.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>The previous implementation of the Levenshtein distance algorithm
 * was from <a href=""http://www.merriampark.com/ld.htm"">http://www.merriampark.com/ld.htm</a></p>
 *
 * <p>Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError
 * which can occur when my Java implementation is used with very large strings.<br>
 * This implementation of the Levenshtein distance algorithm
 * is from <a href=""http://www.merriampark.com/ldjava.htm"">http://www.merriampark.com/ldjava.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("""","""")               = 0
 * StringUtils.getLevenshteinDistance("""",""a"")              = 1
 * StringUtils.getLevenshteinDistance(""aaapppp"", """")       = 7
 * StringUtils.getLevenshteinDistance(""frog"", ""fog"")       = 1
 * StringUtils.getLevenshteinDistance(""fly"", ""ant"")        = 3
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""zzzzzzzz"") = 8
 * StringUtils.getLevenshteinDistance(""hello"", ""hallo"")    = 1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @return result distance
 * @throws IllegalArgumentException if either String input {@code null}
 * @since 3.0 Changed signature from getLevenshteinDistance(String, String) to
 * getLevenshteinDistance(CharSequence, CharSequence)
 */
public static int getLevenshteinDistance(CharSequence s, CharSequence t) {
    if (s == null || t == null) {
        throw new IllegalArgumentException(""Strings must not be null"");
    }
    /*
           The difference between this impl. and the previous is that, rather
           than creating and retaining a matrix of size s.length() + 1 by t.length() + 1,
           we maintain two single-dimensional arrays of length s.length() + 1.  The first, d,
           is the 'current working' distance array that maintains the newest distance cost
           counts as we iterate through the characters of String s.  Each time we increment
           the index of String t we are comparing, d is copied to p, the second int[].  Doing so
           allows us to retain the previous cost counts as required by the algorithm (taking
           the minimum of the cost count to the left, up one, and diagonally up and to the left
           of the current cost count being calculated).  (Note that the arrays aren't really
           copied anymore, just switched...this is clearly much better than cloning an array
           or doing a System.arraycopy() each time  through the outer loop.)

           Effectively, the difference between the two implementations is this one does not
           cause an out of memory condition when calculating the LD over two very large strings.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    if (n == 0) {
        return m;
    } else if (m == 0) {
        return n;
    }
    if (n > m) {
        // swap the input strings to consume less memory
        CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    //'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    //placeholder to assist in swapping p and d
    int[] _d;
    // indexes into strings s and t
    // iterates through s
    int i;
    // iterates through t
    int j;
    // jth character of t
    char t_j;
    // cost
    int cost;
    for (i = 0; i <= n; i++) {
        p[i] = i;
    }
    for (j = 1; j <= m; j++) {
        t_j = t.charAt(j - 1);
        d[0] = j;
        for (i = 1; i <= n; i++) {
            cost = s.charAt(i - 1) == t_j ? 0 : 1;
            // minimum of cell to the left+1, to the top+1, diagonally left and up +cost
            d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost);
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // our last action in the above loop was to switch d and p, so p now
    // actually has the most recent cost counts
    return p[n];
}","public void test069154() throws Throwable {
    String string0 = ""sun.text.Normalizere|`3S336`Aet#0vk"";
    StringUtils.replace(""sun.text.Normalizere|`3S336`Aet#0vk"", ""FfD` Z/yI1~7u];S["", ""xcpPnt+whk:~I-RAbE"", 24);
    StringUtils.splitByWholeSeparator(""xcpPnt+whk:~I-RAbE"", ""sun.text.Normalizere|`3S336`Aet#0vk"");
    String string1 = "" has no clone method"";
    String string2 = null;
    StringUtils.stripEnd("" has no clone method"", (String) null);
    StringUtils.getLevenshteinDistance((CharSequence) ""FfD` Z/yI1~7u];S["", (CharSequence) "" has no clone method"", 4240);
    StringUtils.indexOfDifference((CharSequence) ""FfD` Z/yI1~7u];S["", (CharSequence) ""FfD` Z/yI1~7u];S["");
    StringUtils.removeEnd(""xcpPnt+whk:~I-RAbE"", ""FfD` Z/yI1~7u];S["");
    StringUtils.chomp(""Minimum abbreviation width with offset is 7"");
    StringUtils.lastIndexOf((CharSequence) "" has no clone method"", 41, (-1049));
    Iterator<Object> iterator0 = null;
    String string3 = ""T[d;u7n]{e\\u"";
    StringUtils.join((Iterator<?>) null, string3);
    // Undeclared exception!
    try {
        StringUtils.getLevenshteinDistance((CharSequence) null, (CharSequence) ""Minimum abbreviation width with offset is 7"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Strings must not be null
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}",""
"public static String join(Object[] array, String separator, int startIndex, int endIndex) {
    if (array == null) {
        return null;
    }
    if (separator == null) {
        separator = EMPTY;
    }
    // endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))
    //           (Assuming that all Strings are roughly equally long)
    int noOfItems = (endIndex - startIndex);
    if (noOfItems <= 0) {
        return EMPTY;
    }
    StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}","public void test070155() throws Throwable {
    Class<CharBuffer> class0 = CharBuffer.class;
    ServiceLoader<CharBuffer> serviceLoader0 = ServiceLoader.loadInstalled(class0);
    serviceLoader0.iterator();
    Class<Object> class1 = Object.class;
    ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
    classLoader0.clearAssertionStatus();
    classLoader0.getParent();
    classLoader0.setPackageAssertionStatus(""\""#LD5YQt@yi y5dL!"", true);
    Consumer<CharBuffer> consumer0 = (Consumer<CharBuffer>) mock(Consumer.class, new ViolatedAssumptionAnswer());
    serviceLoader0.forEach(consumer0);
    classLoader0.setClassAssertionStatus(""\""#LD5YQt@yi y5dL!"", false);
    ServiceLoader.load(class1, classLoader0);
    StringUtils.join((Iterable<?>) serviceLoader0, ""|M!]pMVd;"");
    StringUtils.isAlphanumericSpace(""|M!]pMVd;"");
    StringUtils.isBlank(""\""#LD5YQt@yi y5dL!"");
    StringUtils.stripEnd(""m6$LVY.;'}YcI^"", ""\""#LD5YQt@yi y5dL!"");
    StringUtils.substring(""m6$LVY.;'}YcI^"", 10, 4096);
    StringUtils.center(""YcI^"", 10, ')');
    StringUtils.right(""_w[IYfF9g^Av33Q6"", 4096);
    Object[] objectArray0 = new Object[4];
    objectArray0[0] = (Object) ""\""#LD5YQt@yi y5dL!"";
    Object object0 = new Object();
    objectArray0[1] = object0;
    objectArray0[2] = (Object) ""|M!]pMVd;"";
    Object object1 = new Object();
    objectArray0[3] = object1;
    // Undeclared exception!
    try {
        StringUtils.join(objectArray0, ""The character must not be null"", 132, 4096);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 132
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A {@code null} separator is the same as an empty String ("""").
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)                = null
 * StringUtils.join([], *)                  = """"
 * StringUtils.join([null], *)              = """"
 * StringUtils.join([""a"", ""b"", ""c""], ""--"")  = ""a--b--c""
 * StringUtils.join([""a"", ""b"", ""c""], null)  = ""abc""
 * StringUtils.join([""a"", ""b"", ""c""], """")    = ""abc""
 * StringUtils.join([null, """", ""a""], ',')   = "",,a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @param startIndex the first index to start joining from.  It is
 * an error to pass in an end index past the end of the array
 * @param endIndex the index to stop joining from (exclusive). It is
 * an error to pass in an end index past the end of the array
 * @return the joined String, {@code null} if null array input
 */"
"public static boolean containsOnly(CharSequence cs, String validChars) {
    if (cs == null || validChars == null) {
        return false;
    }
    return containsOnly(cs, validChars.toCharArray());
}","public void test071156() throws Throwable {
    StringUtils.chomp(""qo(Can{3]"");
    StringUtils.containsOnly((CharSequence) ""qo(Can{3]"", ""F*,#?<%"");
    StringUtils.indexOfIgnoreCase((CharSequence) ""qo(Can{3]"", (CharSequence) ""F*,#?<%"");
    StringUtils.isAlphanumericSpace(""F*,#?<%"");
    CharSequence[] charSequenceArray0 = new CharSequence[3];
    StringUtils.rightPad(""qo(Can{3]"", (-1205));
    charSequenceArray0[0] = (CharSequence) ""qo(Can{3]"";
    charSequenceArray0[1] = (CharSequence) ""F*,#?<%"";
    charSequenceArray0[2] = (CharSequence) ""F*,#?<%"";
    StringUtils.lastIndexOfAny(""qo(Can{3]"", charSequenceArray0);
    StringUtils.right(""Exception cloning Cloneable type "", (-2742));
    StringUtils.indexOfAny(charSequenceArray0[2], charSequenceArray0);
    StringUtils.center(""qo(Can{3]"", (-2742), ""pQ%r(NLSheF/B+Wp%"");
    StringUtils.containsOnly((CharSequence) ""qo(Can{3]"", ""qo(Can{3]"");
    StringUtils.splitByCharacterType(""qo(Can{3]"");
    StringUtils.containsOnly((CharSequence) """", "">TA;;l42/mC^T',"");
}","/**
 * <p>Checks if the CharSequence contains only certain characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.
 * A {@code null} valid character String will return {@code false}.
 * An empty String (length()=0) always returns {@code true}.</p>
 *
 * <pre>
 * StringUtils.containsOnly(null, *)       = false
 * StringUtils.containsOnly(*, null)       = false
 * StringUtils.containsOnly("""", *)         = true
 * StringUtils.containsOnly(""ab"", """")      = false
 * StringUtils.containsOnly(""abab"", ""abc"") = true
 * StringUtils.containsOnly(""ab1"", ""abc"")  = false
 * StringUtils.containsOnly(""abz"", ""abc"")  = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param validChars  a String of valid chars, may be null
 * @return true if it only contains valid chars and is non-null
 * @since 2.0
 * @since 3.0 Changed signature from containsOnly(String, String) to containsOnly(CharSequence, String)
 */"
"public static String[] substringsBetween(String str, String open, String close) {
    if (str == null || isEmpty(open) || isEmpty(close)) {
        return null;
    }
    int strLen = str.length();
    if (strLen == 0) {
        return ArrayUtils.EMPTY_STRING_ARRAY;
    }
    int closeLen = close.length();
    int openLen = open.length();
    List<String> list = new ArrayList<String>();
    int pos = 0;
    while (pos < (strLen - closeLen)) {
        int start = str.indexOf(open, pos);
        if (start < 0) {
            break;
        }
        start += openLen;
        int end = str.indexOf(close, start);
        if (end < 0) {
            break;
        }
        list.add(str.substring(start, end));
        pos = end + closeLen;
    }
    if (list.isEmpty()) {
        return null;
    }
    return list.toArray(new String[list.size()]);
}","public void test072157() throws Throwable {
    String[] stringArray0 = StringUtils.splitByCharacterType(""B{H`jw"");
    StringUtils.contains((CharSequence) ""B{H`jw"", 16);
    StringUtils.containsWhitespace(""B{H`jw"");
    StringUtils.repeat(""B{H`jw"", "", Length: 0"", (-292));
    StringUtils.stripToEmpty(""n.ohVOm3ZA=qq2Ko5w"");
    StringUtils.repeat(""B{H`jw"", 1696);
    String string0 = ""\\u0"";
    StringUtils.replaceChars(string0, """", ""2qT+]g]C is less than 0: "");
    StringUtils.stripAll(stringArray0, ""7FM'"");
    StringUtils.stripToEmpty(""u_){0G660ileVm<dzT,"");
    Class<Object> class0 = Object.class;
    ServiceLoader<Object> serviceLoader0 = ServiceLoader.load(class0);
    Iterator<Object> iterator0 = serviceLoader0.iterator();
    StringUtils.join(iterator0, "".text.Normalizer"");
    StringUtils.substringsBetween(""2"", ""#kuZ)?_Xo4#{+w5z}"", ""NFD"");
}","/**
 * <p>Searches a String for substrings delimited by a start and end tag,
 * returning all matching substrings in an array.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} open/close returns {@code null} (no match).
 * An empty ("""") open/close returns {@code null} (no match).</p>
 *
 * <pre>
 * StringUtils.substringsBetween(""[a][b][c]"", ""["", ""]"") = [""a"",""b"",""c""]
 * StringUtils.substringsBetween(null, *, *)            = null
 * StringUtils.substringsBetween(*, null, *)            = null
 * StringUtils.substringsBetween(*, *, null)            = null
 * StringUtils.substringsBetween("""", ""["", ""]"")          = []
 * </pre>
 *
 * @param str  the String containing the substrings, null returns null, empty returns empty
 * @param open  the String identifying the start of the substring, empty returns null
 * @param close  the String identifying the end of the substring, empty returns null
 * @return a String Array of substrings, or {@code null} if no match
 * @since 2.3
 */"
"public static String replaceChars(String str, String searchChars, String replaceChars) {
    if (isEmpty(str) || isEmpty(searchChars)) {
        return str;
    }
    if (replaceChars == null) {
        replaceChars = EMPTY;
    }
    boolean modified = false;
    int replaceCharsLength = replaceChars.length();
    int strLength = str.length();
    StringBuilder buf = new StringBuilder(strLength);
    for (int i = 0; i < strLength; i++) {
        char ch = str.charAt(i);
        int index = searchChars.indexOf(ch);
        if (index >= 0) {
            modified = true;
            if (index < replaceCharsLength) {
                buf.append(replaceChars.charAt(index));
            }
        } else {
            buf.append(ch);
        }
    }
    if (modified) {
        return buf.toString();
    }
    return str;
}","public void test073158() throws Throwable {
    StringUtils.upperCase(""r"");
    StringUtils.chomp(""r"");
    StringUtils.replaceChars((String) null, ""r"", ""r"");
}","/**
 * <p>Replaces multiple characters in a String in one go.
 * This method can also be used to delete characters.</p>
 *
 * <p>For example:<br />
 * <code>replaceChars(&quot;hello&quot;, &quot;ho&quot;, &quot;jy&quot;) = jelly</code>.</p>
 *
 * <p>A {@code null} string input returns {@code null}.
 * An empty ("""") string input returns an empty string.
 * A null or empty set of search characters returns the input string.</p>
 *
 * <p>The length of the search characters should normally equal the length
 * of the replace characters.
 * If the search characters is longer, then the extra search characters
 * are deleted.
 * If the search characters is shorter, then the extra replace characters
 * are ignored.</p>
 *
 * <pre>
 * StringUtils.replaceChars(null, *, *)           = null
 * StringUtils.replaceChars("""", *, *)             = """"
 * StringUtils.replaceChars(""abc"", null, *)       = ""abc""
 * StringUtils.replaceChars(""abc"", """", *)         = ""abc""
 * StringUtils.replaceChars(""abc"", ""b"", null)     = ""ac""
 * StringUtils.replaceChars(""abc"", ""b"", """")       = ""ac""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""yz"")  = ""ayzya""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""y"")   = ""ayya""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""yzx"") = ""ayzya""
 * </pre>
 *
 * @param str  String to replace characters in, may be null
 * @param searchChars  a set of characters to search for, may be null
 * @param replaceChars  a set of characters to replace, may be null
 * @return modified String, {@code null} if null string input
 * @since 2.0
 */"
"public static String replaceEach(String text, String[] searchList, String[] replacementList) {
    return replaceEach(text, searchList, replacementList, false, 0);
}","public void test074159() throws Throwable {
    String string0 = StringUtils.leftPad(""hq4"", 2869, ""hq4"");
    StringUtils.replace(""*"", ""hq4"", (String) null);
    StringUtils.mid(""#[[.GF^=wNZA*uldh# "", 2565, 198);
    String string1 = StringUtils.rightPad(""*"", 2565, (String) null);
    StringUtils.abbreviate("""", 198, 2869);
    StringUtils.abbreviate(""#[[.GF^=wNZA*uldh# "", 2869);
    String[] stringArray0 = new String[9];
    stringArray0[6] = ""\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000B\f\r\u000E\u000F\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001A\u001B\u001C\u001D\u001E\u001F !\""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}~"";
    stringArray0[1] = string0;
    stringArray0[2] = """";
    stringArray0[3] = """";
    stringArray0[4] = """";
    stringArray0[5] = ""Array and element cannot both be null"";
    stringArray0[6] = string1;
    stringArray0[7] = ""*"";
    stringArray0[8] = ""*"";
    StringUtils.replaceEach(string1, stringArray0, stringArray0);
}","/**
 * <p>
 * Replaces all occurrences of Strings within another String.
 * </p>
 *
 * <p>
 * A {@code null} reference passed to this method is a no-op, or if
 * any ""search string"" or ""string to replace"" is null, that replace will be
 * ignored. This will not repeat. For repeating replaces, call the
 * overloaded method.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *)        = null
 *  StringUtils.replaceEach("""", *, *)          = """"
 *  StringUtils.replaceEach(""aba"", null, null) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[0], null) = ""aba""
 *  StringUtils.replaceEach(""aba"", null, new String[0]) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, null)  = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""})  = ""b""
 *  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""})  = ""aba""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""})  = ""wcte""
 *  (example of how it does not repeat)
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""})  = ""dcte""
 * </pre>
 *
 * @param text
 *            text to search and replace in, no-op if null
 * @param searchList
 *            the Strings to search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @return the text with any replacements processed, {@code null} if
 *         null String input
 * @throws IndexOutOfBoundsException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */"
"public static int indexOf(CharSequence seq, int searchChar, int startPos) {
    if (isEmpty(seq)) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.indexOf(seq, searchChar, startPos);
}","public void test075160() throws Throwable {
    StringUtils.right(""=EYOsiWJH!+$"", 25);
    StringUtils.isAlpha(""=EYOsiWJH!+$"");
    StringUtils.endsWith(""=EYOsiWJH!+$"", (CharSequence) null);
    StringUtils.repeat("".=}*p8Q|L}s"", """", 25);
    StringUtils.chomp(""=EYOsiWJH!+$"", ""NFD"");
    StringUtils.replaceChars("".=}*p8Q|L}s"", '`', 'g');
    StringUtils.repeat(""NFD"", 25);
    StringUtils.replaceChars((String) null, ""0u[CgnQa8"", (String) null);
    StringUtils.splitPreserveAllTokens((String) null);
    StringUtils.lowerCase((String) null);
    StringUtils.isBlank((CharSequence) null);
    StringUtils.indexOf((CharSequence) """", 25, 1937);
}","/**
 * <p>Finds the first index within a CharSequence from a start position,
 * handling {@code null}.
 * This method uses {@link String#indexOf(int, int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("""") CharSequence will return {@code (INDEX_NOT_FOUND) -1}.
 * A negative start position is treated as zero.
 * A start position greater than the string length returns {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOf(null, *, *)          = -1
 * StringUtils.indexOf("""", *, *)            = -1
 * StringUtils.indexOf(""aabaabaa"", 'b', 0)  = 2
 * StringUtils.indexOf(""aabaabaa"", 'b', 3)  = 5
 * StringUtils.indexOf(""aabaabaa"", 'b', 9)  = -1
 * StringUtils.indexOf(""aabaabaa"", 'b', -1) = 2
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @param startPos  the start position, negative treated as zero
 * @return the first index of the search character,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from indexOf(String, int, int) to indexOf(CharSequence, int, int)
 */"
"public static int lastIndexOf(CharSequence seq, CharSequence searchSeq) {
    if (seq == null || searchSeq == null) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.lastIndexOf(seq, searchSeq, seq.length());
}","public void test076161() throws Throwable {
    StringUtils.defaultString(""o$gd)&(s["");
    StringUtils.containsIgnoreCase(""o$gd)&(s["", ""o$gd)&(s["");
    StringUtils.center("":D2)5-@=:H1/$HoD"", 32, 'r');
    StringUtils.strip(""o$gd)&(s["", ""o$gd)&(s["");
    StringUtils.lastIndexOf((CharSequence) ""o$gd)&(s["", (CharSequence) "":D2)5-@=:H1/$HoD"", 137);
    StringUtils.getLevenshteinDistance((CharSequence) ""rrrrrrrr:D2)5-@=:H1/$HoDrrrrrrrr"", (CharSequence) ""o$gd)&(s["", 137);
    StringUtils.defaultIfEmpty(""rrrrrrrr:D2)5-@=:H1/$HoDrrrrrrrr"", (String) null);
    StringUtils.lastIndexOf((CharSequence) ""rrrrrrrr:D2)5-@=:H1/$HoDrrrrrrrr"", (CharSequence) ""rrrrrrrr:D2)5-@=:H1/$HoDrrrrrrrr"");
}","/**
 * <p>Finds the last index within a CharSequence, handling {@code null}.
 * This method uses {@link String#lastIndexOf(String)} if possible.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.lastIndexOf(null, *)          = -1
 * StringUtils.lastIndexOf(*, null)          = -1
 * StringUtils.lastIndexOf("""", """")           = 0
 * StringUtils.lastIndexOf(""aabaabaa"", ""a"")  = 7
 * StringUtils.lastIndexOf(""aabaabaa"", ""b"")  = 5
 * StringUtils.lastIndexOf(""aabaabaa"", ""ab"") = 4
 * StringUtils.lastIndexOf(""aabaabaa"", """")   = 8
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchSeq  the CharSequence to find, may be null
 * @return the last index of the search String,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from lastIndexOf(String, String) to lastIndexOf(CharSequence, CharSequence)
 */"
"public static String removeEnd(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (str.endsWith(remove)) {
        return str.substring(0, str.length() - remove.length());
    }
    return str;
}","public void test077162() throws Throwable {
    StringUtils.upperCase(""r"");
    StringUtils.startsWith(""r"", ""R"");
    StringUtils.removeEnd(""R"", ""r"");
}","/**
 * <p>Removes a substring only if it is at the end of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("""") source string will return the empty string.
 * A {@code null} search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeEnd(null, *)      = null
 * StringUtils.removeEnd("""", *)        = """"
 * StringUtils.removeEnd(*, null)      = *
 * StringUtils.removeEnd(""www.domain.com"", "".com."")  = ""www.domain.com""
 * StringUtils.removeEnd(""www.domain.com"", "".com"")   = ""www.domain""
 * StringUtils.removeEnd(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeEnd(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for and remove, may be null
 * @return the substring with the string removed if found,
 *  {@code null} if null String input
 * @since 2.1
 */"
"public static String replace(String text, String searchString, String replacement, int max) {
    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {
        return text;
    }
    int start = 0;
    int end = text.indexOf(searchString, start);
    if (end == INDEX_NOT_FOUND) {
        return text;
    }
    int replLength = searchString.length();
    int increase = replacement.length() - replLength;
    increase = (increase < 0 ? 0 : increase);
    increase *= (max < 0 ? 16 : (max > 64 ? 64 : max));
    StringBuilder buf = new StringBuilder(text.length() + increase);
    while (end != INDEX_NOT_FOUND) {
        buf.append(text.substring(start, end)).append(replacement);
        start = end + replLength;
        if (--max == 0) {
            break;
        }
        end = text.indexOf(searchString, start);
    }
    buf.append(text.substring(start));
    return buf.toString();
}","public void test078163() throws Throwable {
    StringUtils.rightPad("", '"", (-1000), "", '"");
    StringUtils.ordinalIndexOf("", '"", "", '"", 10);
    StringUtils.splitByCharacterType(""VHbX:9ODYCgl(*^AF"");
    StringUtils.leftPad(""]"", 10, '}');
    StringUtils.replace("", '"", ""RP"", ""sun.text.Normalizere|`3S336`Aet#0vk"", Integer.MAX_VALUE);
}","/**
 * <p>Replaces a String with another String inside a larger String,
 * for the first {@code max} values of the search String.</p>
 *
 * <p>A {@code null} reference passed to this method is a no-op.</p>
 *
 * <pre>
 * StringUtils.replace(null, *, *, *)         = null
 * StringUtils.replace("""", *, *, *)           = """"
 * StringUtils.replace(""any"", null, *, *)     = ""any""
 * StringUtils.replace(""any"", *, null, *)     = ""any""
 * StringUtils.replace(""any"", """", *, *)       = ""any""
 * StringUtils.replace(""any"", *, *, 0)        = ""any""
 * StringUtils.replace(""abaa"", ""a"", null, -1) = ""abaa""
 * StringUtils.replace(""abaa"", ""a"", """", -1)   = ""b""
 * StringUtils.replace(""abaa"", ""a"", ""z"", 0)   = ""abaa""
 * StringUtils.replace(""abaa"", ""a"", ""z"", 1)   = ""zbaa""
 * StringUtils.replace(""abaa"", ""a"", ""z"", 2)   = ""zbza""
 * StringUtils.replace(""abaa"", ""a"", ""z"", -1)  = ""zbzz""
 * </pre>
 *
 * @param text  text to search and replace in, may be null
 * @param searchString  the String to search for, may be null
 * @param replacement  the String to replace it with, may be null
 * @param max  maximum number of values to replace, or {@code -1} if no maximum
 * @return the text with any replacements processed,
 *  {@code null} if null String input
 */"
"public static String join(Iterator<?> iterator, char separator) {
    // handle null, zero and one elements before building a buffer
    if (iterator == null) {
        return null;
    }
    if (!iterator.hasNext()) {
        return EMPTY;
    }
    Object first = iterator.next();
    if (!iterator.hasNext()) {
        return ObjectUtils.toString(first);
    }
    // two or more elements
    // Java default is 16, probably too small
    StringBuilder buf = new StringBuilder(256);
    if (first != null) {
        buf.append(first);
    }
    while (iterator.hasNext()) {
        buf.append(separator);
        Object obj = iterator.next();
        if (obj != null) {
            buf.append(obj);
        }
    }
    return buf.toString();
}","public void test079164() throws Throwable {
    StringUtils.join((Object[]) null, ""[CRf]nwH"", (-3384), 13);
    StringUtils.lastIndexOf((CharSequence) null, (CharSequence) null);
    StringUtils.defaultIfBlank((String) null, ""[CRf]nwH"");
    StringUtils.rightPad(""[CRf]nwH"", 57, 'D');
    StringUtils.containsIgnoreCase((CharSequence) null, ""[CRf]nwHDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD"");
    StringUtils.endsWithIgnoreCase(""[CRf]nwHDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD"", (CharSequence) null);
    String string0 = null;
    StringUtils.stripStart((String) null, (String) null);
    PriorityQueue<String> priorityQueue0 = new PriorityQueue<String>();
    Iterator<String> iterator0 = priorityQueue0.iterator();
    priorityQueue0.add(""hLBoye!%la/4Q"");
    // Undeclared exception!
    try {
        StringUtils.join(iterator0, 'j');
        fail(""Expecting exception: ConcurrentModificationException"");
    } catch (ConcurrentModificationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.PriorityQueue$Itr"", e);
    }
}","/**
 * <p>Joins the elements of the provided {@code Iterator} into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list. Null objects or empty
 * strings within the iteration are represented by empty strings.</p>
 *
 * <p>See the examples here: {@link #join(Object[],char)}. </p>
 *
 * @param iterator  the {@code Iterator} of values to join together, may be null
 * @param separator  the separator character to use
 * @return the joined String, {@code null} if null iterator input
 * @since 2.0
 */"
"public static boolean endsWithAny(CharSequence string, CharSequence... searchStrings) {
    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {
        return false;
    }
    for (int i = 0; i < searchStrings.length; i++) {
        CharSequence searchString = searchStrings[i];
        if (StringUtils.endsWith(string, searchString)) {
            return true;
        }
    }
    return false;
}","public void test080165() throws Throwable {
    String[] stringArray0 = new String[1];
    stringArray0[0] = ""nt4nt4"";
    StringUtils.stripAll(stringArray0, ""nt4nt4"");
    StringUtils.isAlphanumericSpace(""nt4nt4"");
    StringUtils.indexOf((CharSequence) ""nt4nt4"", (CharSequence) ""nt4nt4"", 0);
    StringUtils.abbreviateMiddle(""sun.text.Normalizer"", ""nt4nt4"", 0);
    StringUtils.overlay(""sun.text.Normalizer"", ""IllegalArgumentException occurred"", 13, 90);
    StringUtils.startsWithAny(""sun.text.NormIllegalArgumentException occurred"", stringArray0);
    StringUtils.isAllLowerCase(""nt4nt4"");
    StringUtils.contains((CharSequence) ""sun.text.Normalizer"", 0);
    StringUtils.leftPad(""IllegalArgumentException occurred"", 13, ""sun.text.Normalizer"");
    String string0 = StringUtils.repeat(""sun.text.Normalizer"", ""hwfx.{Qax?[{ND8"", 90);
    StringUtils.overlay(string0, ""nt4nt4"", 0, 0);
    StringUtils.chomp(""f|lNgo2\u0005^,[<mg"", ""H#SP\""<<\""O6D3V"");
    StringUtils.abbreviate(""5Ez(Sfj4dVm!u"", 90);
    StringUtils.rightPad(""hwfx.{Qax?[{ND8"", 109, """");
    CharSequence[] charSequenceArray0 = new CharSequence[7];
    charSequenceArray0[0] = (CharSequence) ""sun.text.NormIllegalArgumentException occurred"";
    charSequenceArray0[1] = (CharSequence) ""nt4nt4"";
    charSequenceArray0[2] = (CharSequence) ""f|lNgo2\u0005^,[<mg"";
    charSequenceArray0[3] = (CharSequence) ""sun.text.NormIllegalArgumentException occurred"";
    charSequenceArray0[4] = (CharSequence) ""f|lNgo2\u0005^,[<mg"";
    StringUtils.substringBetween("""", "" is less than 0: "", ""IllegalArgumentException occurred"");
    charSequenceArray0[5] = (CharSequence) null;
    charSequenceArray0[6] = (CharSequence) ""hwfx.{Qax?[{ND8"";
    StringUtils.endsWithAny(""nt4nt4"", charSequenceArray0);
}","/**
 * <p>Check if a CharSequence ends with any of an array of specified strings.</p>
 *
 * <pre>
 * StringUtils.endsWithAny(null, null)      = false
 * StringUtils.endsWithAny(null, new String[] {""abc""})  = false
 * StringUtils.endsWithAny(""abcxyz"", null)     = false
 * StringUtils.endsWithAny(""abcxyz"", new String[] {""""}) = true
 * StringUtils.endsWithAny(""abcxyz"", new String[] {""xyz""}) = true
 * StringUtils.endsWithAny(""abcxyz"", new String[] {null, ""xyz"", ""abc""}) = true
 * </pre>
 *
 * @param string  the CharSequence to check, may be null
 * @param searchStrings the CharSequences to find, may be null or empty
 * @return {@code true} if the CharSequence ends with any of the the prefixes, case insensitive, or
 *  both {@code null}
 * @since 3.0
 */"
"public static String[] stripAll(String[] strs, String stripChars) {
    int strsLen;
    if (strs == null || (strsLen = strs.length) == 0) {
        return strs;
    }
    String[] newArr = new String[strsLen];
    for (int i = 0; i < strsLen; i++) {
        newArr[i] = strip(strs[i], stripChars);
    }
    return newArr;
}","public void test081166() throws Throwable {
    StringUtils.join((Object[]) null, ""[CRf]nwH"", (-3384), 13);
    StringUtils.lastIndexOf((CharSequence) null, (CharSequence) null);
    StringUtils.rightPad((String) null, 57, 'D');
    StringUtils.containsIgnoreCase((CharSequence) null, (CharSequence) null);
    StringUtils.endsWithIgnoreCase((CharSequence) null, (CharSequence) null);
    StringUtils.stripStart((String) null, (String) null);
    PriorityQueue<String> priorityQueue0 = new PriorityQueue<String>();
    Iterator<String> iterator0 = priorityQueue0.iterator();
    StringUtils.join(iterator0, 'j');
    Locale locale0 = Locale.FRENCH;
    StringUtils.lowerCase(""z?zU%7>st9[Gk^A|'"", locale0);
    StringUtils.substringBefore((String) null, ""z?zU%7>st9[Gk^A|'"");
    StringUtils.removeEndIgnoreCase(""_@"", ""fZ))ZZi24e!K,wLtK<I"");
    StringUtils.stripAll((String[]) null, (String) null);
}","/**
 * <p>Strips any of a set of characters from the start and end of every
 * String in an array.</p>
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <p>A new array is returned each time, except for length zero.
 * A {@code null} array will return {@code null}.
 * An empty array will return itself.
 * A {@code null} array entry will be ignored.
 * A {@code null} stripChars will strip whitespace as defined by
 * {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripAll(null, *)                = null
 * StringUtils.stripAll([], *)                  = []
 * StringUtils.stripAll([""abc"", ""  abc""], null) = [""abc"", ""abc""]
 * StringUtils.stripAll([""abc  "", null], null)  = [""abc"", null]
 * StringUtils.stripAll([""abc  "", null], ""yz"")  = [""abc  "", null]
 * StringUtils.stripAll([""yabcz"", null], ""yz"")  = [""abc"", null]
 * </pre>
 *
 * @param strs  the array to remove characters from, may be null
 * @param stripChars  the characters to remove, null treated as whitespace
 * @return the stripped Strings, {@code null} if null array input
 */"
"public static String abbreviateMiddle(String str, String middle, int length) {
    if (isEmpty(str) || isEmpty(middle)) {
        return str;
    }
    if (length >= str.length() || length < (middle.length() + 2)) {
        return str;
    }
    int targetSting = length - middle.length();
    int startOffset = targetSting / 2 + targetSting % 2;
    int endOffset = str.length() - targetSting / 2;
    StringBuilder builder = new StringBuilder(length);
    builder.append(str.substring(0, startOffset));
    builder.append(middle);
    builder.append(str.substring(endOffset));
    return builder.toString();
}","public void test082167() throws Throwable {
    Locale locale0 = Locale.ITALIAN;
    StringUtils.upperCase(""PGU;]L',eY&PQ"", locale0);
    Locale.Category locale_Category0 = Locale.Category.DISPLAY;
    Locale.setDefault(locale_Category0, locale0);
    StringUtils.containsWhitespace(""PGU;]L',EY&PQ"");
    StringUtils.lastIndexOf((CharSequence) ""PGU;]L',EY&PQ"", (-2747), 2564);
    StringUtils.rightPad(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"", 2, ""r*?sf1e;]"");
    char[] charArray0 = new char[1];
    charArray0[0] = 'J';
    StringUtils.containsAny((CharSequence) ""PGU;]L',eY&PQ"", charArray0);
    StringUtils.indexOfAnyBut((CharSequence) ""r*?sf1e;]"", charArray0);
    StringUtils.isAlphaSpace(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"");
    StringUtils.swapCase(""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"");
    StringUtils.defaultString(""I(8 _.]syF"");
    StringUtils.isAlphaSpace(""I(8 _.]syF"");
    StringUtils.substringAfterLast(""r*?sf1e;]"", "" vs "");
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    linkedList0.add((Object) locale0);
    Iterator<Object> iterator0 = linkedList0.descendingIterator();
    StringUtils.join(iterator0, ""*UFZTl^Pvp>5"");
    StringUtils.isAllLowerCase(""java.util.Locale@0000000001"");
    StringUtils.abbreviateMiddle(""Yr|%/Du0&"", """", 888);
}","/**
 * <p>Abbreviates a String to the length passed, replacing the middle characters with the supplied
 * replacement String.</p>
 *
 * <p>This abbreviation only occurs if the following criteria is met:
 * <ul>
 * <li>Neither the String for abbreviation nor the replacement String are null or empty </li>
 * <li>The length to truncate to is less than the length of the supplied String</li>
 * <li>The length to truncate to is greater than 0</li>
 * <li>The abbreviated String will have enough room for the length supplied replacement String
 * and the first and last characters of the supplied String for abbreviation</li>
 * </ul>
 * Otherwise, the returned String will be the same as the supplied String for abbreviation.
 * </p>
 *
 * <pre>
 * StringUtils.abbreviateMiddle(null, null, 0)      = null
 * StringUtils.abbreviateMiddle(""abc"", null, 0)      = ""abc""
 * StringUtils.abbreviateMiddle(""abc"", ""."", 0)      = ""abc""
 * StringUtils.abbreviateMiddle(""abc"", ""."", 3)      = ""abc""
 * StringUtils.abbreviateMiddle(""abcdef"", ""."", 4)     = ""ab.f""
 * </pre>
 *
 * @param str  the String to abbreviate, may be null
 * @param middle the String to replace the middle characters with, may be null
 * @param length the length to abbreviate {@code str} to.
 * @return the abbreviated String if the above criteria is met, or the original String supplied for abbreviation.
 * @since 2.5
 */"
"// ContainsOnly
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains only certain characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.
 * A {@code null} valid character array will return {@code false}.
 * An empty CharSequence (length()=0) always returns {@code true}.</p>
 *
 * <pre>
 * StringUtils.containsOnly(null, *)       = false
 * StringUtils.containsOnly(*, null)       = false
 * StringUtils.containsOnly("""", *)         = true
 * StringUtils.containsOnly(""ab"", '')      = false
 * StringUtils.containsOnly(""abab"", 'abc') = true
 * StringUtils.containsOnly(""ab1"", 'abc')  = false
 * StringUtils.containsOnly(""abz"", 'abc')  = false
 * </pre>
 *
 * @param cs  the String to check, may be null
 * @param valid  an array of valid chars, may be null
 * @return true if it only contains valid chars and is non-null
 * @since 3.0 Changed signature from containsOnly(String, char[]) to containsOnly(CharSequence, char...)
 */
public static boolean containsOnly(CharSequence cs, char... valid) {
    // All these pre-checks are to maintain API with an older version
    if (valid == null || cs == null) {
        return false;
    }
    if (cs.length() == 0) {
        return true;
    }
    if (valid.length == 0) {
        return false;
    }
    return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND;
}","public void test083168() throws Throwable {
    StringUtils.substringBetween(""IllegalArgumentException occurred"", ""IllegalArgumentException occurred"", (String) null);
    StringUtils.leftPad(""IllegalArgumentException occurred"", 104);
    StringUtils.substringBeforeLast(""H#SP\""<<\""O6D3V"", (String) null);
    StringUtils.substringBefore((String) null, ""H#SP\""<<\""O6D3Vorg.apache.commons.lang3.CharUtils"");
    StringUtils.isAsciiPrintable(""                                                                       IllegalArgumentException occurred"");
    StringUtils.center((String) null, 3, ',');
    StringUtils.removeStart((String) null, ""?7SyC"");
    StringUtils.abbreviateMiddle(""b$2F8ouCk3\"""", ""IllegalArgumentException occurred"", (-4343));
    StringUtils.substringBeforeLast(""b$2F8ouCk3\"""", (String) null);
    StringUtils.substringAfterLast((String) null, (String) null);
    StringUtils.substring(""..."", 116, (-4343));
    StringUtils.difference((String) null, ""The String must not be empty"");
    StringUtils.isAlphaSpace(""H#SP\""<<\""O6D3V"");
    StringUtils.defaultIfEmpty(""Wv25._0uK(:+bQd)k3"", ""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVMThe stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"");
    char[] charArray0 = new char[0];
    StringUtils.containsOnly((CharSequence) ""b$2F8ouCk3\"""", charArray0);
}",""
"// IndexOfAny chars
//-----------------------------------------------------------------------
/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A {@code null} String will return {@code -1}.
 * A {@code null} or zero length search array will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)                = -1
 * StringUtils.indexOfAny("""", *)                  = -1
 * StringUtils.indexOfAny(*, null)                = -1
 * StringUtils.indexOfAny(*, [])                  = -1
 * StringUtils.indexOfAny(""zzabyycdxx"",['z','a']) = 0
 * StringUtils.indexOfAny(""zzabyycdxx"",['b','y']) = 3
 * StringUtils.indexOfAny(""aba"", ['z'])           = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAny(String, char[]) to indexOfAny(CharSequence, char...)
 */
public static int indexOfAny(CharSequence cs, char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int csLen = cs.length();
    int csLast = csLen - 1;
    int searchLen = searchChars.length;
    int searchLast = searchLen - 1;
    for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
                    // ch is a supplementary character
                    if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        return i;
                    }
                } else {
                    return i;
                }
            }
        }
    }
    return INDEX_NOT_FOUND;
}","public void test084169() throws Throwable {
    StringUtils.abbreviateMiddle(""Search and Replace array lengths don't match: "", ""5gy'|gJN?VHD[?Vnd"", 383);
    StringUtils.defaultIfBlank(""sun.text.Normalizere|`3S336`Aet#0vk"", ""sun.text.Normalizere|`3S336`Aet#0vk"");
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    CharBuffer charBuffer0 = CharBuffer.wrap((CharSequence) ""sun.text.Normalizere|`3S336`Aet#0vk"");
    linkedList0.add((Object) charBuffer0);
    Iterator<Object> iterator0 = linkedList0.iterator();
    StringUtils.join(iterator0, ""Search and Replace array lengths don't match: "");
    StringUtils.stripToNull(""sun.text.Normalizere|`3S336`Aet#0vk"");
    StringUtils.lowerCase(""sun.text.Normalizere|`3S336`Aet#0vk"");
    StringUtils.leftPad(""java.nio.StringCharBuffer@0000000001"", 383, ""[Z(y=KG"");
    StringUtils.indexOfDifference((CharSequence) ""sun.text.Normalizere|`3S336`Aet#0vk"", (CharSequence) ""[Z(y=KG"");
    StringUtils.trimToEmpty(""java.lang.String@0000000002"");
    StringUtils.chop(""H#SP\""<<\""O6D3V"");
    StringUtils.equals((CharSequence) ""H#SP\""<<\""O6D3"", (CharSequence) ""java.lang.String@0000000002"");
    StringUtils.remove("" has no clone method"", ""sun.text.Normalizere|`3S336`Aet#0vk"");
    StringUtils.join((Object[]) null, '8', 383, 4);
    StringUtils.substringBeforeLast(""Search and Replace array lengths don't match: "", ""sun.text.Normalizer is not available"");
    StringUtils.removeStartIgnoreCase((String) null, ""Search and Replace array lengths don't match: "");
    StringUtils.center(""sun.text.Normalizere|`3S336`Aet#0vk"", 383, 'D');
    char[] charArray0 = new char[7];
    charArray0[0] = 'D';
    charArray0[1] = 'D';
    charArray0[2] = ';';
    charArray0[3] = 'D';
    charArray0[4] = 'D';
    charArray0[5] = '8';
    charArray0[6] = '8';
    StringUtils.indexOfAny((CharSequence) ""Search and Replace array lengths don't match: "", charArray0);
}",""
"// IndexOfAny chars
//-----------------------------------------------------------------------
/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A {@code null} String will return {@code -1}.
 * A {@code null} or zero length search array will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)                = -1
 * StringUtils.indexOfAny("""", *)                  = -1
 * StringUtils.indexOfAny(*, null)                = -1
 * StringUtils.indexOfAny(*, [])                  = -1
 * StringUtils.indexOfAny(""zzabyycdxx"",['z','a']) = 0
 * StringUtils.indexOfAny(""zzabyycdxx"",['b','y']) = 3
 * StringUtils.indexOfAny(""aba"", ['z'])           = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAny(String, char[]) to indexOfAny(CharSequence, char...)
 */
public static int indexOfAny(CharSequence cs, char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int csLen = cs.length();
    int csLast = csLen - 1;
    int searchLen = searchChars.length;
    int searchLast = searchLen - 1;
    for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
                    // ch is a supplementary character
                    if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        return i;
                    }
                } else {
                    return i;
                }
            }
        }
    }
    return INDEX_NOT_FOUND;
}","public void test085170() throws Throwable {
    StringUtils.stripToNull("">U>m-~N^Q< 9Threshold must not be negative>U>m-~N^Q< 9Threshold must not be negative>U>m-~N^Q< 9Threshold must not be negativeThreshold must not be negative"");
    char[] charArray0 = new char[7];
    charArray0[0] = 'g';
    charArray0[1] = 'r';
    charArray0[2] = 'H';
    charArray0[3] = 'x';
    charArray0[4] = 'P';
    charArray0[5] = 'z';
    charArray0[6] = '0';
    StringUtils.indexOfAny((CharSequence) "">U>m-~N^Q< 9Threshold must not be negative>U>m-~N^Q< 9Threshold must not be negative>U>m-~N^Q< 9Threshold must not be negativeThreshold must not be negative"", charArray0);
}",""
"public static int indexOfDifference(CharSequence cs1, CharSequence cs2) {
    if (cs1 == cs2) {
        return INDEX_NOT_FOUND;
    }
    if (cs1 == null || cs2 == null) {
        return 0;
    }
    int i;
    for (i = 0; i < cs1.length() && i < cs2.length(); ++i) {
        if (cs1.charAt(i) != cs2.charAt(i)) {
            break;
        }
    }
    if (i < cs2.length() || i < cs1.length()) {
        return i;
    }
    return INDEX_NOT_FOUND;
}","public void test086171() throws Throwable {
    StringUtils.chop(""cK K`1]xbsQ8;"");
    StringUtils.isAlphaSpace(""cK K`1]xbsQ8"");
    String[] stringArray0 = new String[8];
    stringArray0[1] = ""cK K`1]xbsQ8;"";
    stringArray0[2] = ""cK K`1]xbsQ8;"";
    stringArray0[3] = ""cK K`1]xbsQ8;"";
    stringArray0[4] = ""cK K`1]xbsQ8"";
    stringArray0[5] = ""cK K`1]xbsQ8"";
    stringArray0[6] = ""cK K`1]xbsQ8"";
    stringArray0[7] = ""cK K`1]xbsQ8;"";
    StringUtils.stripAll(stringArray0);
    StringUtils.indexOfDifference((CharSequence) ""cK K`1]xbsQ8"", (CharSequence) ""cK K`1]xbsQ8;"");
}","/**
 * <p>Compares two CharSequences, and returns the index at which the
 * CharSequences begin to differ.</p>
 *
 * <p>For example,
 * {@code indexOfDifference(""i am a machine"", ""i am a robot"") -> 7}</p>
 *
 * <pre>
 * StringUtils.indexOfDifference(null, null) = -1
 * StringUtils.indexOfDifference("""", """") = -1
 * StringUtils.indexOfDifference("""", ""abc"") = 0
 * StringUtils.indexOfDifference(""abc"", """") = 0
 * StringUtils.indexOfDifference(""abc"", ""abc"") = -1
 * StringUtils.indexOfDifference(""ab"", ""abxyz"") = 2
 * StringUtils.indexOfDifference(""abcde"", ""abxyz"") = 2
 * StringUtils.indexOfDifference(""abcde"", ""xyz"") = 0
 * </pre>
 *
 * @param cs1  the first CharSequence, may be null
 * @param cs2  the second CharSequence, may be null
 * @return the index where cs1 and cs2 begin to differ; -1 if they are equal
 * @since 2.0
 * @since 3.0 Changed signature from indexOfDifference(String, String) to
 * indexOfDifference(CharSequence, CharSequence)
 */"
"public static String chomp(String str, String separator) {
    if (isEmpty(str) || separator == null) {
        return str;
    }
    if (str.endsWith(separator)) {
        return str.substring(0, str.length() - separator.length());
    }
    return str;
}","public void test087172() throws Throwable {
    StringUtils.leftPad(""ciX?-maH5XWZ("", 510, ""ciX?-maH5XWZ("");
    CharSequence[] charSequenceArray0 = new CharSequence[2];
    charSequenceArray0[0] = (CharSequence) ""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("";
    charSequenceArray0[1] = (CharSequence) ""ciX?-maH5XWZ("";
    StringUtils.endsWithAny(""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("", charSequenceArray0);
    String[] stringArray0 = new String[1];
    stringArray0[0] = ""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("";
    String[] stringArray1 = StringUtils.stripAll(stringArray0);
    StringUtils.abbreviate(""Exception cloning Cloneable type "", 13);
    StringUtils.ordinalIndexOf(""ciX?-maH5XWZ("", charSequenceArray0[0], 13);
    StringUtils.lastIndexOfAny(charSequenceArray0[0], stringArray1);
    StringUtils.stripToNull(""Exception ..."");
    StringUtils.mid(""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("", 13, 510);
    LinkedHashSet<Locale.FilteringMode> linkedHashSet0 = new LinkedHashSet<Locale.FilteringMode>();
    Iterator<Locale.FilteringMode> iterator0 = linkedHashSet0.iterator();
    Locale.FilteringMode locale_FilteringMode0 = Locale.FilteringMode.REJECT_EXTENDED_RANGES;
    Locale.FilteringMode locale_FilteringMode1 = Locale.FilteringMode.REJECT_EXTENDED_RANGES;
    linkedHashSet0.add(locale_FilteringMode1);
    linkedHashSet0.add(locale_FilteringMode0);
    StringUtils.join(iterator0, '}');
    StringUtils.rightPad(""ciX?-maH5XWZ("", 0, ""/x&<_x`RJm/x&<_x`RJm"");
    StringUtils.chomp(""xDTm(m'~h1DlVpMe"", ""The character must not be null"");
}","/**
 * <p>Removes {@code separator} from the end of
 * {@code str} if it's there, otherwise leave it alone.</p>
 *
 * <p>NOTE: This method changed in version 2.0.
 * It now more closely matches Perl chomp.
 * For the previous behavior, use {@link #substringBeforeLast(String, String)}.
 * This method uses {@link String#endsWith(String)}.</p>
 *
 * <pre>
 * StringUtils.chomp(null, *)         = null
 * StringUtils.chomp("""", *)           = """"
 * StringUtils.chomp(""foobar"", ""bar"") = ""foo""
 * StringUtils.chomp(""foobar"", ""baz"") = ""foobar""
 * StringUtils.chomp(""foo"", ""foo"")    = """"
 * StringUtils.chomp(""foo "", ""foo"")   = ""foo ""
 * StringUtils.chomp("" foo"", ""foo"")   = "" ""
 * StringUtils.chomp(""foo"", ""foooo"")  = ""foo""
 * StringUtils.chomp(""foo"", """")       = ""foo""
 * StringUtils.chomp(""foo"", null)     = ""foo""
 * </pre>
 *
 * @param str  the String to chomp from, may be null
 * @param separator  separator String, may be null
 * @return String without trailing separator, {@code null} if null String input
 */"
"public static String substringAfterLast(String str, String separator) {
    if (isEmpty(str)) {
        return str;
    }
    if (isEmpty(separator)) {
        return EMPTY;
    }
    int pos = str.lastIndexOf(separator);
    if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) {
        return EMPTY;
    }
    return str.substring(pos + separator.length());
}","public void test088173() throws Throwable {
    StringUtils.substringBeforeLast("""", """");
    StringUtils.indexOfIgnoreCase((CharSequence) """", (CharSequence) """", 1123);
    StringUtils.chop("""");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens("""", (String) null);
    StringUtils.startsWithAny((CharSequence) null, stringArray0);
    StringUtils.stripEnd("""", """");
    StringUtils.rightPad("""", 10, """");
    StringUtils.startsWithAny((CharSequence) null, stringArray0);
    StringUtils.substringAfterLast("""", """");
}","/**
 * <p>Gets the substring after the last occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A {@code null} string input will return {@code null}.
 * An empty ("""") string input will return the empty string.
 * An empty or {@code null} separator will return the empty string if
 * the input string is not {@code null}.</p>
 *
 * <p>If nothing is found, the empty string is returned.</p>
 *
 * <pre>
 * StringUtils.substringAfterLast(null, *)      = null
 * StringUtils.substringAfterLast("""", *)        = """"
 * StringUtils.substringAfterLast(*, """")        = """"
 * StringUtils.substringAfterLast(*, null)      = """"
 * StringUtils.substringAfterLast(""abc"", ""a"")   = ""bc""
 * StringUtils.substringAfterLast(""abcba"", ""b"") = ""a""
 * StringUtils.substringAfterLast(""abc"", ""c"")   = """"
 * StringUtils.substringAfterLast(""a"", ""a"")     = """"
 * StringUtils.substringAfterLast(""a"", ""z"")     = """"
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring after the last occurrence of the separator,
 *  {@code null} if null String input
 * @since 2.0
 */"
"public static String substringAfterLast(String str, String separator) {
    if (isEmpty(str)) {
        return str;
    }
    if (isEmpty(separator)) {
        return EMPTY;
    }
    int pos = str.lastIndexOf(separator);
    if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) {
        return EMPTY;
    }
    return str.substring(pos + separator.length());
}","public void test089174() throws Throwable {
    StringUtils.replaceEachRepeatedly(""p{InCombiningDiacriticalMarks}+"", (String[]) null, (String[]) null);
    StringUtils.indexOfAny((CharSequence) ""p{InCombiningDiacriticalMarks}+"", (CharSequence[]) null);
    StringUtils.indexOfAnyBut((CharSequence) ""p{InCombiningDiacriticalMarks}+"", (CharSequence) ""p{InCombiningDiacriticalMarks}+"");
    StringUtils.equalsIgnoreCase(""p{InCombiningDiacriticalMarks}+"", ""p{InCombiningDiacriticalMarks}+"");
    StringUtils.center(""p{InCombiningDiacriticalMarks}+"", (-1), '\""');
    char[] charArray0 = new char[2];
    charArray0[0] = '\""';
    charArray0[1] = '\""';
    StringUtils.containsAny((CharSequence) ""p{InCombiningDiacriticalMarks}+"", charArray0);
    StringUtils.getLevenshteinDistance((CharSequence) ""p{InCombiningDiacriticalMarks}+"", (CharSequence) ""p{InCombiningDiacriticalMarks}+"");
    StringUtils.abbreviateMiddle(""p{InCombiningDiacriticalMarks}+"", ""5Ez("", 0);
    StringUtils.substringAfterLast(""p{InCombiningDiacriticalMarks}+"", ""p{InCombiningDiacriticalMarks}+"");
}","/**
 * <p>Gets the substring after the last occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A {@code null} string input will return {@code null}.
 * An empty ("""") string input will return the empty string.
 * An empty or {@code null} separator will return the empty string if
 * the input string is not {@code null}.</p>
 *
 * <p>If nothing is found, the empty string is returned.</p>
 *
 * <pre>
 * StringUtils.substringAfterLast(null, *)      = null
 * StringUtils.substringAfterLast("""", *)        = """"
 * StringUtils.substringAfterLast(*, """")        = """"
 * StringUtils.substringAfterLast(*, null)      = """"
 * StringUtils.substringAfterLast(""abc"", ""a"")   = ""bc""
 * StringUtils.substringAfterLast(""abcba"", ""b"") = ""a""
 * StringUtils.substringAfterLast(""abc"", ""c"")   = """"
 * StringUtils.substringAfterLast(""a"", ""a"")     = """"
 * StringUtils.substringAfterLast(""a"", ""z"")     = """"
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring after the last occurrence of the separator,
 *  {@code null} if null String input
 * @since 2.0
 */"
"public static String[] split(String str, String separatorChars) {
    return splitWorker(str, separatorChars, -1, false);
}","public void test090175() throws Throwable {
    StringUtils.splitByCharacterTypeCamelCase(""..."");
    String[] stringArray0 = StringUtils.splitByCharacterType(""..."");
    StringUtils.chomp(""..."", ""org.apache.commons.lang3.CharUtils"");
    StringUtils.indexOfAnyBut((CharSequence) ""org.apache.commons.lang3.CharUtils"", (CharSequence) ""..."");
    StringUtils.indexOfIgnoreCase((CharSequence) ""..."", (CharSequence) ""..."");
    Locale locale0 = Locale.CHINESE;
    locale0.getDisplayScript();
    locale0.hasExtensions();
    locale0.stripExtensions();
    StringUtils.upperCase(""org.apache.commons.lang3.CharUtils"", locale0);
    StringUtils.repeat(""..."", 0);
    StringUtils.leftPad("">7,olS%}CBA}@"", 0, ""$e:#s9xV"");
    StringUtils.removeEnd((String) null, ""hz[im+[x;wcK@"");
    StringUtils.indexOfAny((CharSequence) ""..."", (CharSequence[]) stringArray0);
    StringUtils.defaultString("""");
    StringUtils.uncapitalize(""u(;$x"");
    StringUtils.split(""org.apache.commons.lang3.CharUtils"", ""IllegalAccessException occurred"");
}","/**
 * <p>Splits the provided text into an array, separators specified.
 * This is an alternative to using StringTokenizer.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as one separator.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} separatorChars splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.split(null, *)         = null
 * StringUtils.split("""", *)           = []
 * StringUtils.split(""abc def"", null) = [""abc"", ""def""]
 * StringUtils.split(""abc def"", "" "")  = [""abc"", ""def""]
 * StringUtils.split(""abc  def"", "" "") = [""abc"", ""def""]
 * StringUtils.split(""ab:cd:ef"", "":"") = [""ab"", ""cd"", ""ef""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @param separatorChars  the characters used as the delimiters,
 *  {@code null} splits on whitespace
 * @return an array of parsed Strings, {@code null} if null String input
 */"
"public static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    return lastIndexOfIgnoreCase(str, searchStr, str.length());
}","public void test091176() throws Throwable {
    StringUtils.substringBeforeLast(""@qx4r"", ""@qx4r"");
    StringUtils.replaceChars("""", ""@qx4r"", ""@qx4r"");
    StringUtils.center(""H#SP\""<<\""O6D3V"", (-1907), 'P');
    StringUtils.stripStart(""Qhj\""F!dPV6AR3rv"", ""H#SP\""<<\""O6D3V"");
    StringUtils.overlay(""Qhj\""F!dPV6AR3rv"", ""Qhj\""F!dPV6AR3rv"", (-1907), (-1907));
    Object[] objectArray0 = new Object[7];
    Object object0 = new Object();
    objectArray0[0] = object0;
    objectArray0[1] = (Object) ""Qhj\""F!dPV6AR3rv"";
    objectArray0[2] = (Object) ""H#SP\""<<\""O6D3V"";
    objectArray0[3] = (Object) ""Qhj\""F!dPV6AR3rvQhj\""F!dPV6AR3rv"";
    Object object1 = new Object();
    objectArray0[4] = object1;
    objectArray0[5] = (Object) """";
    Object object2 = new Object();
    objectArray0[6] = object2;
    StringUtils.join(objectArray0, ""Cannot get the toString of a null identity"", (-1907), (-1907));
    StringUtils.lastIndexOfIgnoreCase((CharSequence) ""Qhj\""F!dPV6AR3rv"", (CharSequence) """");
}","/**
 * <p>Case in-sensitive find of the last index within a CharSequence.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A negative start position returns {@code -1}.
 * An empty ("""") search CharSequence always matches unless the start position is negative.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOfIgnoreCase(null, *)          = -1
 * StringUtils.lastIndexOfIgnoreCase(*, null)          = -1
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""A"")  = 7
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"")  = 5
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""AB"") = 4
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @return the first index of the search CharSequence,
 *  -1 if no match or {@code null} string input
 * @since 2.5
 * @since 3.0 Changed signature from lastIndexOfIgnoreCase(String, String) to lastIndexOfIgnoreCase(CharSequence, CharSequence)
 */"
"public static String stripToNull(String str) {
    if (str == null) {
        return null;
    }
    str = strip(str, null);
    return str.length() == 0 ? null : str;
}","public void test092177() throws Throwable {
    StringUtils.substringBeforeLast("""", """");
    StringUtils.indexOfIgnoreCase((CharSequence) """", (CharSequence) """", 1123);
    StringUtils.chop("""");
    String[] stringArray0 = StringUtils.splitByCharacterTypeCamelCase("""");
    StringUtils.startsWithAny((CharSequence) null, stringArray0);
    StringUtils.stripEnd(""ZH"", ""}"");
    StringUtils.rightPad("""", 10, """");
    StringUtils.lastIndexOfAny((CharSequence) null, stringArray0);
    StringUtils.stripToNull((String) null);
}","/**
 * <p>Strips whitespace from the start and end of a String  returning
 * {@code null} if the String is empty ("""") after the strip.</p>
 *
 * <p>This is similar to {@link #trimToNull(String)} but removes whitespace.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripToNull(null)     = null
 * StringUtils.stripToNull("""")       = null
 * StringUtils.stripToNull(""   "")    = null
 * StringUtils.stripToNull(""abc"")    = ""abc""
 * StringUtils.stripToNull(""  abc"")  = ""abc""
 * StringUtils.stripToNull(""abc  "")  = ""abc""
 * StringUtils.stripToNull("" abc "")  = ""abc""
 * StringUtils.stripToNull("" ab c "") = ""ab c""
 * </pre>
 *
 * @param str  the String to be stripped, may be null
 * @return the stripped String,
 *  {@code null} if whitespace, empty or null String input
 * @since 2.0
 */"
"// Empty checks
//-----------------------------------------------------------------------
/**
 * <p>Checks if a CharSequence is empty ("""") or null.</p>
 *
 * <pre>
 * StringUtils.isEmpty(null)      = true
 * StringUtils.isEmpty("""")        = true
 * StringUtils.isEmpty("" "")       = false
 * StringUtils.isEmpty(""bob"")     = false
 * StringUtils.isEmpty(""  bob  "") = false
 * </pre>
 *
 * <p>NOTE: This method changed in Lang version 2.0.
 * It no longer trims the CharSequence.
 * That functionality is available in isBlank().</p>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if the CharSequence is empty or null
 * @since 3.0 Changed signature from isEmpty(String) to isEmpty(CharSequence)
 */
public static boolean isEmpty(CharSequence cs) {
    return cs == null || cs.length() == 0;
}","public void test093178() throws Throwable {
    StringUtils.rightPad(""SecurityException occurred"", 732, ""SecurityException occurred"");
    StringUtils.endsWithIgnoreCase(""SecurityException occurredSecurityException occurredSecurityException occurredSecurityException occurredSecurityException occurredSecurityException occurredSecurityException occurredSecurityException occurredSecurityException occurredSecurityException occurredSecurityException occurredSecurityException occurredSecurityException occurredSecurityException occurredSecurityException occurredSecurityException occurredSecurityException occurredSecurityException occurredSecurityException occurredSecurityException occurredSecurityException occurredSecurityException occurredSecurityException occurredSecurityException occurredSecurityException occurredSecurityException occurredSecurityException occurredSecurityException occurredSecu"", ""SecurityException occurred"");
    Object[] objectArray0 = new Object[1];
    objectArray0[0] = (Object) ""SecurityException occurred"";
    StringUtils.join(objectArray0, '|');
    CharBuffer charBuffer0 = CharBuffer.wrap((CharSequence) ""SecurityException occurred"");
    CharBuffer charBuffer1 = StringUtils.defaultIfEmpty(charBuffer0, charBuffer0);
    StringUtils.replace("""", ""SecurityException occurred"", "" O"");
    StringUtils.contains((CharSequence) """", (CharSequence) "" O"");
    StringUtils.split(""SecurityException occurred"", 'o');
    StringUtils.isAlphanumericSpace(charBuffer0);
    StringUtils.lastIndexOf((CharSequence) "" O"", (CharSequence) "" O"", 732);
    StringUtils.indexOf((CharSequence) charBuffer0, (CharSequence) charBuffer1);
    StringUtils.substring(""SecurityException occurred"", (-950));
    StringUtils.lowerCase("""");
    StringUtils.isWhitespace(""SecurityException occurred"");
    StringUtils.substringBefore(""wz}"", ""SecurityException occurred"");
    StringUtils.isAlphanumericSpace(""SecurityException occurred"");
    StringUtils.upperCase("""");
    StringUtils.isEmpty("""");
}",""
"// StripAll
//-----------------------------------------------------------------------
/**
 * <p>Strips whitespace from the start and end of every String in an array.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <p>A new array is returned each time, except for length zero.
 * A {@code null} array will return {@code null}.
 * An empty array will return itself.
 * A {@code null} array entry will be ignored.</p>
 *
 * <pre>
 * StringUtils.stripAll(null)             = null
 * StringUtils.stripAll([])               = []
 * StringUtils.stripAll([""abc"", ""  abc""]) = [""abc"", ""abc""]
 * StringUtils.stripAll([""abc  "", null])  = [""abc"", null]
 * </pre>
 *
 * @param strs  the array to remove whitespace from, may be null
 * @return the stripped Strings, {@code null} if null array input
 */
public static String[] stripAll(String... strs) {
    return stripAll(strs, null);
}","public void test094179() throws Throwable {
    StringUtils.abbreviateMiddle("".text.Normalizer"", "".text.Normalizer"", 569);
    char[] charArray0 = new char[6];
    charArray0[0] = '.';
    charArray0[1] = '2';
    charArray0[2] = '~';
    charArray0[3] = ':';
    charArray0[4] = 'v';
    charArray0[5] = '|';
    StringUtils.indexOfAnyBut((CharSequence) "".text.Normalizer"", charArray0);
    StringUtils.center(""444444444444444444"", 569, ""&C=FWE"");
    StringUtils.center(""&C=FWE"", (-100), 'v');
    StringUtils.stripAll((String[]) null);
}",""
"public static String upperCase(String str, Locale locale) {
    if (str == null) {
        return null;
    }
    return str.toUpperCase(locale);
}","public void test095180() throws Throwable {
    StringUtils.substring(""r="", (-396), (-396));
    StringUtils.lastIndexOfIgnoreCase((CharSequence) """", (CharSequence) """", 1339);
    String string0 = StringUtils.center(""5x3II"", 1339);
    StringUtils.repeat(""C"", (-396));
    CharSequence[] charSequenceArray0 = new CharSequence[3];
    charSequenceArray0[0] = (CharSequence) """";
    charSequenceArray0[1] = (CharSequence) ""5x3II"";
    charSequenceArray0[2] = (CharSequence) ""r="";
    StringUtils.startsWithAny(""C"", charSequenceArray0);
    StringUtils.remove(""2=Ve`hs62J"", 'M');
    StringUtils.defaultString(""NFD"", ""2`.ld{S:SW24d+!"");
    StringUtils.center(""rr[Y1jd lPy*oG !J-"", (-396), 'M');
    String string1 = ""\\u0"";
    StringUtils.chop(string1);
    StringUtils.length(""2=Ve`hs62J"");
    String[] stringArray0 = StringUtils.splitByCharacterType(string0);
    StringUtils.overlay(""96NF:'d)CA5[~Wm"", ""rr[Y1jd lPy*oG !J-"", (-396), 0);
    StringUtils.getCommonPrefix(stringArray0);
    StringUtils.center(""org.apache.commons.lang3.StringUtils"", 10, 'M');
    HashSet<Locale.FilteringMode> hashSet0 = new HashSet<Locale.FilteringMode>();
    Iterator<Locale.FilteringMode> iterator0 = hashSet0.iterator();
    StringUtils.join(iterator0, 'M');
    StringUtils.splitByCharacterType(""rr[Y1jd lPy*oG !J-"");
    Locale locale0 = Locale.KOREAN;
    StringUtils.upperCase(""5x3II"", locale0);
}","/**
 * <p>Converts a String to upper case as per {@link String#toUpperCase(Locale)}.</p>
 *
 * <p>A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.upperCase(null, Locale.ENGLISH)  = null
 * StringUtils.upperCase("""", Locale.ENGLISH)    = """"
 * StringUtils.upperCase(""aBc"", Locale.ENGLISH) = ""ABC""
 * </pre>
 *
 * @param str  the String to upper case, may be null
 * @param locale  the locale that defines the case transformation rules, must not be null
 * @return the upper cased String, {@code null} if null String input
 * @since 2.5
 */"
"// LastIndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the last index within a CharSequence, handling {@code null}.
 * This method uses {@link String#lastIndexOf(int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("""") CharSequence will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.lastIndexOf(null, *)         = -1
 * StringUtils.lastIndexOf("""", *)           = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'a') = 7
 * StringUtils.lastIndexOf(""aabaabaa"", 'b') = 5
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @return the last index of the search character,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from lastIndexOf(String, int) to lastIndexOf(CharSequence, int)
 */
public static int lastIndexOf(CharSequence seq, int searchChar) {
    if (isEmpty(seq)) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.lastIndexOf(seq, searchChar, seq.length());
}","public void test096181() throws Throwable {
    StringUtils.substringBetween(""j/N"", ""j/N"", ""j/N"");
    StringUtils.isBlank((CharSequence) null);
    StringUtils.isAlphanumeric((CharSequence) null);
    StringUtils.substringBetween((String) null, ""o@Y{XTWFk9nQ%;`~}G#"");
    StringUtils.defaultString((String) null, ""*6*?LyY~g'!2A"");
    StringUtils.contains((CharSequence) null, 0);
    CharSequence[] charSequenceArray0 = new CharSequence[5];
    charSequenceArray0[0] = (CharSequence) ""grpthJx"";
    charSequenceArray0[1] = (CharSequence) ""j/N"";
    charSequenceArray0[2] = (CharSequence) ""o@Y{XTWFk9nQ%;`~}G#"";
    charSequenceArray0[3] = (CharSequence) ""*6*?LyY~g'!2A"";
    charSequenceArray0[4] = (CharSequence) null;
    StringUtils.indexOfDifference(charSequenceArray0);
    StringUtils.lastIndexOf((CharSequence) null, 0);
}",""
"public static String[] splitPreserveAllTokens(String str, String separatorChars) {
    return splitWorker(str, separatorChars, -1, true);
}","public void test097182() throws Throwable {
    StringUtils.replace((String) null, ""zqv"", ""zqv"", (-1641));
    StringUtils.leftPad("""", 815, """");
    StringUtils.splitPreserveAllTokens(""QD.yyS"", """");
}","/**
 * <p>Splits the provided text into an array, separators specified,
 * preserving all tokens, including empty tokens created by adjacent
 * separators. This is an alternative to using StringTokenizer.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as separators for empty tokens.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} separatorChars splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.splitPreserveAllTokens(null, *)           = null
 * StringUtils.splitPreserveAllTokens("""", *)             = []
 * StringUtils.splitPreserveAllTokens(""abc def"", null)   = [""abc"", ""def""]
 * StringUtils.splitPreserveAllTokens(""abc def"", "" "")    = [""abc"", ""def""]
 * StringUtils.splitPreserveAllTokens(""abc  def"", "" "")   = [""abc"", """", def""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef"", "":"")   = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef:"", "":"")  = [""ab"", ""cd"", ""ef"", """"]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef::"", "":"") = [""ab"", ""cd"", ""ef"", """", """"]
 * StringUtils.splitPreserveAllTokens(""ab::cd:ef"", "":"")  = [""ab"", """", cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens("":cd:ef"", "":"")     = ["""", cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""::cd:ef"", "":"")    = ["""", """", cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens("":cd:ef:"", "":"")    = ["""", cd"", ""ef"", """"]
 * </pre>
 *
 * @param str  the String to parse, may be {@code null}
 * @param separatorChars  the characters used as the delimiters,
 *  {@code null} splits on whitespace
 * @return an array of parsed Strings, {@code null} if null String input
 * @since 2.1
 */"
"// Remove
//-----------------------------------------------------------------------
/**
 * <p>Removes a substring only if it is at the begining of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("""") source string will return the empty string.
 * A {@code null} search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeStart(null, *)      = null
 * StringUtils.removeStart("""", *)        = """"
 * StringUtils.removeStart(*, null)      = *
 * StringUtils.removeStart(""www.domain.com"", ""www."")   = ""domain.com""
 * StringUtils.removeStart(""domain.com"", ""www."")       = ""domain.com""
 * StringUtils.removeStart(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeStart(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for and remove, may be null
 * @return the substring with the string removed if found,
 *  {@code null} if null String input
 * @since 2.1
 */
public static String removeStart(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (str.startsWith(remove)) {
        return str.substring(remove.length());
    }
    return str;
}","public void test098183() throws Throwable {
    String string0 = StringUtils.repeat('4', 1956);
    StringUtils.isWhitespace(string0);
    String string1 = StringUtils.removeStart(string0, ""{o>Z"");
    StringUtils.indexOfAnyBut((CharSequence) ""{o>Z"", (CharSequence) ""{o>Z"");
    String[] stringArray0 = StringUtils.splitByWholeSeparator(string1, string1);
    StringUtils.stripAll(stringArray0);
    String string2 = StringUtils.mid(string1, (-1), 1935);
    StringUtils.indexOfAnyBut((CharSequence) string0, (CharSequence) string2);
    StringUtils.abbreviateMiddle(""{o>Z"", ""SAk;M9~a{E5Br"", (-1));
    StringUtils.lastIndexOfIgnoreCase((CharSequence) ""{o>Z"", (CharSequence) string2);
    StringUtils.mid(""V(hY=65j)W`FlX'"", (-1130), (-1));
    StringUtils.getCommonPrefix(stringArray0);
    StringUtils.capitalize(""The Array must not be null"");
    StringUtils.join((Object[]) stringArray0, string0);
    String string3 = StringUtils.chop(string0);
    StringUtils.isAlphanumeric(""SAk;M9~a{E5Br"");
    StringUtils.stripEnd("""", ""{o>Z"");
    StringUtils.indexOfDifference((CharSequence) """", (CharSequence) string1);
    StringUtils.stripToEmpty("".DJOw,l7|Ag7W"");
    StringUtils.removeStartIgnoreCase(""sun.text.Normalizer is not available"", """");
    StringUtils.leftPad("""", 1, 'g');
    StringUtils.center(""g"", (-1), ' ');
    StringUtils.removeStart(string3, ""?F0IK=S#GdY't,ON/A"");
}",""
"// SubStringAfter/SubStringBefore
//-----------------------------------------------------------------------
/**
 * <p>Gets the substring before the first occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A {@code null} string input will return {@code null}.
 * An empty ("""") string input will return the empty string.
 * A {@code null} separator will return the input string.</p>
 *
 * <p>If nothing is found, the string input is returned.</p>
 *
 * <pre>
 * StringUtils.substringBefore(null, *)      = null
 * StringUtils.substringBefore("""", *)        = """"
 * StringUtils.substringBefore(""abc"", ""a"")   = """"
 * StringUtils.substringBefore(""abcba"", ""b"") = ""a""
 * StringUtils.substringBefore(""abc"", ""c"")   = ""ab""
 * StringUtils.substringBefore(""abc"", ""d"")   = ""abc""
 * StringUtils.substringBefore(""abc"", """")    = """"
 * StringUtils.substringBefore(""abc"", null)  = ""abc""
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring before the first occurrence of the separator,
 *  {@code null} if null String input
 * @since 2.0
 */
public static String substringBefore(String str, String separator) {
    if (isEmpty(str) || separator == null) {
        return str;
    }
    if (separator.length() == 0) {
        return EMPTY;
    }
    int pos = str.indexOf(separator);
    if (pos == INDEX_NOT_FOUND) {
        return str;
    }
    return str.substring(0, pos);
}","public void test099184() throws Throwable {
    StringUtils.replace(""&OK%lO@%Rp"", ""&OK%lO@%Rp"", ""&OK%lO@%Rp"");
    StringUtils.countMatches(""&OK%lO@%Rp"", ""&OK%lO@%Rp"");
    StringUtils.abbreviateMiddle(""&OK%lO@%Rp"", """", 1);
    StringUtils.endsWithIgnoreCase(""&OK%lO@%Rp"", """");
    StringUtils.startsWithIgnoreCase("""", ""&OK%lO@%Rp"");
    CharSequence[] charSequenceArray0 = new CharSequence[6];
    charSequenceArray0[0] = (CharSequence) """";
    charSequenceArray0[1] = (CharSequence) ""&OK%lO@%Rp"";
    charSequenceArray0[2] = (CharSequence) ""&OK%lO@%Rp"";
    charSequenceArray0[3] = (CharSequence) ""&OK%lO@%Rp"";
    StringUtils.rightPad("")->lf?z1% sH:jREt"", 1);
    charSequenceArray0[4] = (CharSequence) "")->lf?z1% sH:jREt"";
    charSequenceArray0[5] = (CharSequence) ""&OK%lO@%Rp"";
    StringUtils.endsWithAny(""&OK%lO@%Rp"", charSequenceArray0);
    StringUtils.leftPad(""a='<@]7\""SL)mnnj5"", 0);
    StringUtils.isAlpha(charSequenceArray0[0]);
    StringUtils.replace(""0sr$z5YcO{Qh!-"", ""}Hm%r0rXZ8h.m7{au("", ""n[K<x<t(FQREdV%aa$l"", 0);
    StringUtils.stripEnd(""~2\""aj"", ""decompose"");
    StringUtils.rightPad(""0sr$z5YcO{Qh!-"", 1, 'q');
    StringUtils.indexOfAnyBut((CharSequence) ""a='<@]7\""SL)mnnj5"", (CharSequence) ""n[K<x<t(FQREdV%aa$l"");
    StringUtils.mid(""0sr$z5YcO{Qh!-"", 1, 1);
    StringUtils.chomp(""'+d+{mVQlW"");
    StringUtils.isAlphaSpace(charSequenceArray0[3]);
    String[] stringArray0 = StringUtils.split(""d>-wRj[~]yZPH"");
    StringUtils.getCommonPrefix(stringArray0);
    StringUtils.substringBefore(""decompose"", ""d>-wRj[~]yZPH"");
}",""
"// From org.springframework.util.StringUtils, under Apache License 2.0
public static boolean containsWhitespace(CharSequence seq) {
    if (isEmpty(seq)) {
        return false;
    }
    int strLen = seq.length();
    for (int i = 0; i < strLen; i++) {
        if (Character.isWhitespace(seq.charAt(i))) {
            return true;
        }
    }
    return false;
}","public void test100185() throws Throwable {
    StringUtils.center(""The String must not be empty"", 0, """");
    StringUtils.splitPreserveAllTokens(""The String must not be empty"", """", 0);
    StringUtils.ordinalIndexOf("""", """", 0);
    StringUtils.substringBetween(""The String must not be empty"", """", ""The String must not be empty"");
    StringUtils.reverseDelimited("":8S]U@1X4-0G-A!x"", 'l');
    StringUtils.rightPad("""", 0, '!');
    StringUtils.containsWhitespace("""");
}","/**
 * Check whether the given CharSequence contains any whitespace characters.
 * @param seq the CharSequence to check (may be {@code null})
 * @return {@code true} if the CharSequence is not empty and
 * contains at least 1 whitespace character
 * @see java.lang.Character#isWhitespace
 * @since 3.0
 */"
"public static boolean equalsIgnoreCase(CharSequence str1, CharSequence str2) {
    if (str1 == null || str2 == null) {
        return str1 == str2;
    } else {
        return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, Math.max(str1.length(), str2.length()));
    }
}","public void test101186() throws Throwable {
    StringUtils.abbreviateMiddle((String) null, "" in an array of "", (-1911));
    StringUtils.equalsIgnoreCase((CharSequence) null, (CharSequence) null);
}","/**
 * <p>Compares two CharSequences, returning {@code true} if they are equal ignoring
 * the case.</p>
 *
 * <p>{@code null}s are handled without exceptions. Two {@code null}
 * references are considered equal. Comparison is case insensitive.</p>
 *
 * <pre>
 * StringUtils.equalsIgnoreCase(null, null)   = true
 * StringUtils.equalsIgnoreCase(null, ""abc"")  = false
 * StringUtils.equalsIgnoreCase(""abc"", null)  = false
 * StringUtils.equalsIgnoreCase(""abc"", ""abc"") = true
 * StringUtils.equalsIgnoreCase(""abc"", ""ABC"") = true
 * </pre>
 *
 * @param str1  the first CharSequence, may be null
 * @param str2  the second CharSequence, may be null
 * @return {@code true} if the CharSequence are equal, case insensitive, or
 *  both {@code null}
 * @since 3.0 Changed signature from equalsIgnoreCase(String, String) to equalsIgnoreCase(CharSequence, CharSequence)
 */"
"public static int lastIndexOf(CharSequence seq, CharSequence searchSeq, int startPos) {
    if (seq == null || searchSeq == null) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.lastIndexOf(seq, searchSeq, startPos);
}","public void test102187() throws Throwable {
    StringUtils.trim((String) null);
    Object[] objectArray0 = new Object[6];
    Object object0 = new Object();
    objectArray0[0] = object0;
    Object object1 = new Object();
    objectArray0[1] = object1;
    objectArray0[2] = (Object) null;
    objectArray0[3] = (Object) null;
    objectArray0[4] = (Object) null;
    objectArray0[5] = (Object) null;
    StringUtils.join(objectArray0, (String) null, (-98), (-98));
    StringUtils.lastIndexOf((CharSequence) """", (CharSequence) null, (-2461));
    StringUtils.remove((String) null, 'T');
    StringUtils.center((String) null, 128, 'T');
    char[] charArray0 = new char[4];
    charArray0[0] = 'T';
    charArray0[1] = 's';
    charArray0[2] = 'T';
    charArray0[3] = 'T';
    StringUtils.containsNone((CharSequence) null, charArray0);
    StringUtils.leftPad((String) null, (-1951), ""!s`"");
    StringUtils.removeEndIgnoreCase("""", ""!s`"");
    StringUtils.lastIndexOf((CharSequence) null, (CharSequence) """", 128);
}","/**
 * <p>Finds the first index within a CharSequence, handling {@code null}.
 * This method uses {@link String#lastIndexOf(String, int)} if possible.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A negative start position returns {@code -1}.
 * An empty ("""") search CharSequence always matches unless the start position is negative.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOf(null, *, *)          = -1
 * StringUtils.lastIndexOf(*, null, *)          = -1
 * StringUtils.lastIndexOf(""aabaabaa"", ""a"", 8)  = 7
 * StringUtils.lastIndexOf(""aabaabaa"", ""b"", 8)  = 5
 * StringUtils.lastIndexOf(""aabaabaa"", ""ab"", 8) = 4
 * StringUtils.lastIndexOf(""aabaabaa"", ""b"", 9)  = 5
 * StringUtils.lastIndexOf(""aabaabaa"", ""b"", -1) = -1
 * StringUtils.lastIndexOf(""aabaabaa"", ""a"", 0)  = 0
 * StringUtils.lastIndexOf(""aabaabaa"", ""b"", 0)  = -1
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchSeq  the CharSequence to find, may be null
 * @param startPos  the start position, negative treated as zero
 * @return the first index of the search CharSequence,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from lastIndexOf(String, String, int) to lastIndexOf(CharSequence, CharSequence, int)
 */"
"// ContainsAny
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains any character in the given
 * set of characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.
 * A {@code null} or zero length search array will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)                = false
 * StringUtils.containsAny("""", *)                  = false
 * StringUtils.containsAny(*, null)                = false
 * StringUtils.containsAny(*, [])                  = false
 * StringUtils.containsAny(""zzabyycdxx"",['z','a']) = true
 * StringUtils.containsAny(""zzabyycdxx"",['b','y']) = true
 * StringUtils.containsAny(""aba"", ['z'])           = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the {@code true} if any of the chars are found,
 * {@code false} if no match or null input
 * @since 2.4
 * @since 3.0 Changed signature from containsAny(String, char[]) to containsAny(CharSequence, char...)
 */
public static boolean containsAny(CharSequence cs, char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    int csLast = csLength - 1;
    int searchLast = searchLength - 1;
    for (int i = 0; i < csLength; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == ch) {
                if (Character.isHighSurrogate(ch)) {
                    if (j == searchLast) {
                        // missing low surrogate, fine, like String.indexOf(String)
                        return true;
                    }
                    if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
                        return true;
                    }
                } else {
                    // ch is in the Basic Multilingual Plane
                    return true;
                }
            }
        }
    }
    return false;
}","public void test103188() throws Throwable {
    StringUtils.replaceEachRepeatedly(""p{InCombiningDiacriticalMarks}+"", (String[]) null, (String[]) null);
    StringUtils.indexOfAny((CharSequence) ""p{InCombiningDiacriticalMarks}+"", (CharSequence[]) null);
    StringUtils.indexOfAnyBut((CharSequence) ""p{InCombiningDiacriticalMarks}+"", (CharSequence) ""p{InCombiningDiacriticalMarks}+"");
    StringUtils.equalsIgnoreCase(""p{InCombiningDiacriticalMarks}+"", ""p{InCombiningDiacriticalMarks}+"");
    StringUtils.center((String) null, (-1), '\""');
    char[] charArray0 = new char[2];
    charArray0[0] = '\""';
    charArray0[1] = '\""';
    StringUtils.containsAny((CharSequence) null, charArray0);
}",""
"// LastIndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the last index within a CharSequence, handling {@code null}.
 * This method uses {@link String#lastIndexOf(int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("""") CharSequence will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.lastIndexOf(null, *)         = -1
 * StringUtils.lastIndexOf("""", *)           = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'a') = 7
 * StringUtils.lastIndexOf(""aabaabaa"", 'b') = 5
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @return the last index of the search character,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from lastIndexOf(String, int) to lastIndexOf(CharSequence, int)
 */
public static int lastIndexOf(CharSequence seq, int searchChar) {
    if (isEmpty(seq)) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.lastIndexOf(seq, searchChar, seq.length());
}","public void test104189() throws Throwable {
    StringUtils.defaultIfEmpty(""C.lPGbKT]TJ4_s:"", ""C$si~8V4a&[^{z"");
    StringUtils.replaceOnce(""C.lPGbKT]TJ4_s:"", ""C.lPGbKT]TJ4_s:"", ""C.lPGbKT]TJ4_s:"");
    String[] stringArray0 = new String[6];
    stringArray0[0] = ""C$si~8V4a&[^{z"";
    stringArray0[1] = ""C.lPGbKT]TJ4_s:"";
    stringArray0[2] = ""C.lPGbKT]TJ4_s:"";
    stringArray0[3] = ""C$si~8V4a&[^{z"";
    stringArray0[4] = """";
    stringArray0[5] = ""C.lPGbKT]TJ4_s:"";
    StringUtils.stripAll(stringArray0, "")3&S[43&"");
    StringUtils.lowerCase(""#`7-rbuUvyvXW\""]F7"");
    StringUtils.join((Object[]) stringArray0, ""C.lPGbKT]TJ4_s:"");
    StringUtils.deleteWhitespace((String) null);
    StringUtils.replace("""", """", ""C$si~8V4a&[^{zC.lPGbKT]TJ4_s:C.lPGbKT]TJ4_s:C.lPGbKT]TJ4_s:C.lPGbKT]TJ4_s:C.lPGbKT]TJ4_s:C$si~8V4a&[^{zC.lPGbKT]TJ4_s:C.lPGbKT]TJ4_s:C.lPGbKT]TJ4_s:"", 3);
    StringUtils.isNotBlank(""C$si~8V4a&[^{z"");
    StringUtils.lastIndexOf((CharSequence) ""C$si~8V4a&[^{zC.lPGbKT]TJ4_s:C.lPGbKT]TJ4_s:C.lPGbKT]TJ4_s:C.lPGbKT]TJ4_s:C.lPGbKT]TJ4_s:C$si~8V4a&[^{zC.lPGbKT]TJ4_s:C.lPGbKT]TJ4_s:C.lPGbKT]TJ4_s:"", 3);
}",""
"public static String join(Iterator<?> iterator, String separator) {
    // handle null, zero and one elements before building a buffer
    if (iterator == null) {
        return null;
    }
    if (!iterator.hasNext()) {
        return EMPTY;
    }
    Object first = iterator.next();
    if (!iterator.hasNext()) {
        return ObjectUtils.toString(first);
    }
    // two or more elements
    // Java default is 16, probably too small
    StringBuilder buf = new StringBuilder(256);
    if (first != null) {
        buf.append(first);
    }
    while (iterator.hasNext()) {
        if (separator != null) {
            buf.append(separator);
        }
        Object obj = iterator.next();
        if (obj != null) {
            buf.append(obj);
        }
    }
    return buf.toString();
}","public void test105190() throws Throwable {
    StringUtils.removeStartIgnoreCase(""!sgUHcd,oq)aD/-g_"", ""java.text.Normalizer"");
    StringUtils.isNotBlank(""java.text.Normalizer"");
    StringUtils.endsWithIgnoreCase(""!sgUHcd,oq)aD/-g_"", ""!sgUHcd,oq)aD/-g_"");
    StringUtils.splitPreserveAllTokens((String) null, ""m/Fby#QZC/nFa.Hvj_"", 8192);
    StringUtils.removeStartIgnoreCase(""m/Fby#QZC/nFa.Hvj_"", (String) null);
    StringUtils.join((Object[]) null, ""!sgUHcd,oq)aD/-g_"", 8192, (-994));
    StringUtils.isAlphanumericSpace(""!sgUHcd,oq)aD/-g_"");
    Locale locale0 = Locale.CHINA;
    StringUtils.lowerCase("""", locale0);
    StringUtils.stripStart((String) null, (String) null);
    StringUtils.splitPreserveAllTokens((String) null, 'r');
    StringUtils.join((Object[]) null, ""java.text.Normalizer"");
    StringUtils.substring(""$rjbJdy3{SPa"", 128, 1569);
    StringUtils.isNumeric(""m/Fby#QZC/nFa.Hvj_"");
    Class<Integer> class0 = Integer.class;
    ServiceLoader<Integer> serviceLoader0 = ServiceLoader.load(class0);
    Iterator<Integer> iterator0 = serviceLoader0.iterator();
    StringUtils.join(iterator0, (String) null);
}","/**
 * <p>Joins the elements of the provided {@code Iterator} into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A {@code null} separator is the same as an empty String ("""").</p>
 *
 * <p>See the examples here: {@link #join(Object[],String)}. </p>
 *
 * @param iterator  the {@code Iterator} of values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @return the joined String, {@code null} if null iterator input
 */"
"// ContainsNone
//-----------------------------------------------------------------------
/**
 * <p>Checks that the CharSequence does not contain certain characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code true}.
 * A {@code null} invalid character array will return {@code true}.
 * An empty CharSequence (length()=0) always returns true.</p>
 *
 * <pre>
 * StringUtils.containsNone(null, *)       = true
 * StringUtils.containsNone(*, null)       = true
 * StringUtils.containsNone("""", *)         = true
 * StringUtils.containsNone(""ab"", '')      = true
 * StringUtils.containsNone(""abab"", 'xyz') = true
 * StringUtils.containsNone(""ab1"", 'xyz')  = true
 * StringUtils.containsNone(""abz"", 'xyz')  = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  an array of invalid chars, may be null
 * @return true if it contains none of the invalid chars, or is null
 * @since 2.0
 * @since 3.0 Changed signature from containsNone(String, char[]) to containsNone(CharSequence, char...)
 */
public static boolean containsNone(CharSequence cs, char... searchChars) {
    if (cs == null || searchChars == null) {
        return true;
    }
    int csLen = cs.length();
    int csLast = csLen - 1;
    int searchLen = searchChars.length;
    int searchLast = searchLen - 1;
    for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (Character.isHighSurrogate(ch)) {
                    if (j == searchLast) {
                        // missing low surrogate, fine, like String.indexOf(String)
                        return false;
                    }
                    if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
                        return false;
                    }
                } else {
                    // ch is in the Basic Multilingual Plane
                    return false;
                }
            }
        }
    }
    return true;
}","public void test106191() throws Throwable {
    String[] stringArray0 = new String[5];
    stringArray0[0] = ""6{,+H'!dx&S7\u000E<?"";
    stringArray0[1] = """";
    stringArray0[2] = """";
    stringArray0[3] = ""[T~cHB,n\""|}7}KB)A2"";
    stringArray0[4] = "" is not in the range '0' - '9'"";
    StringUtils.stripAll(stringArray0);
    StringUtils.getLevenshteinDistance((CharSequence) "" is not in the range '0' - '9'"", (CharSequence) ""[T~cHB,n\""|}7}KB)A2"", 7);
    StringUtils.overlay(""6{,+H'!dx&S7\u000E<?"", """", 7, (-1));
    char[] charArray0 = new char[8];
    charArray0[0] = 'M';
    charArray0[1] = 'G';
    charArray0[2] = 'V';
    charArray0[3] = 'N';
    charArray0[4] = '[';
    charArray0[5] = '\'';
    charArray0[6] = 'd';
    charArray0[7] = 'p';
    StringUtils.containsNone((CharSequence) ""[T~cHB,n\""|}7}KB)A2"", charArray0);
}",""
"// ContainsAny
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains any character in the given
 * set of characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.
 * A {@code null} or zero length search array will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)                = false
 * StringUtils.containsAny("""", *)                  = false
 * StringUtils.containsAny(*, null)                = false
 * StringUtils.containsAny(*, [])                  = false
 * StringUtils.containsAny(""zzabyycdxx"",['z','a']) = true
 * StringUtils.containsAny(""zzabyycdxx"",['b','y']) = true
 * StringUtils.containsAny(""aba"", ['z'])           = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the {@code true} if any of the chars are found,
 * {@code false} if no match or null input
 * @since 2.4
 * @since 3.0 Changed signature from containsAny(String, char[]) to containsAny(CharSequence, char...)
 */
public static boolean containsAny(CharSequence cs, char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    int csLast = csLength - 1;
    int searchLast = searchLength - 1;
    for (int i = 0; i < csLength; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == ch) {
                if (Character.isHighSurrogate(ch)) {
                    if (j == searchLast) {
                        // missing low surrogate, fine, like String.indexOf(String)
                        return true;
                    }
                    if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
                        return true;
                    }
                } else {
                    // ch is in the Basic Multilingual Plane
                    return true;
                }
            }
        }
    }
    return false;
}","public void test107192() throws Throwable {
    String[] stringArray0 = new String[1];
    stringArray0[0] = ""> >a4^Est#\u0002#J5"";
    StringUtils.getCommonPrefix(stringArray0);
    char[] charArray0 = new char[5];
    charArray0[0] = 'n';
    charArray0[1] = 'P';
    charArray0[2] = '}';
    charArray0[3] = 'R';
    charArray0[4] = 'P';
    StringUtils.containsAny((CharSequence) ""> >a4^Est#\u0002#J5"", charArray0);
}",""
"public static String repeat(char ch, int repeat) {
    char[] buf = new char[repeat];
    for (int i = repeat - 1; i >= 0; i--) {
        buf[i] = ch;
    }
    return new String(buf);
}","public void test108193() throws Throwable {
    // Undeclared exception!
    try {
        StringUtils.repeat('0', (-402));
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}","/**
 * <p>Returns padding using the specified delimiter repeated
 * to a given length.</p>
 *
 * <pre>
 * StringUtils.repeat(0, 'e')  = """"
 * StringUtils.repeat(3, 'e')  = ""eee""
 * StringUtils.repeat(-2, 'e') = """"
 * </pre>
 *
 * <p>Note: this method doesn't not support padding with
 * <a href=""http://www.unicode.org/glossary/#supplementary_character"">Unicode Supplementary Characters</a>
 * as they require a pair of {@code char}s to be represented.
 * If you are needing to support full I18N of your applications
 * consider using {@link #repeat(String, int)} instead.
 * </p>
 *
 * @param ch  character to repeat
 * @param repeat  number of times to repeat char, negative treated as zero
 * @return String with repeated character
 * @see #repeat(String, int)
 */"
"// IndexOfAnyBut chars
//-----------------------------------------------------------------------
/**
 * <p>Searches a CharSequence to find the first index of any
 * character not in the given set of characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A {@code null} or zero length search array will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAnyBut(null, *)                              = -1
 * StringUtils.indexOfAnyBut("""", *)                                = -1
 * StringUtils.indexOfAnyBut(*, null)                              = -1
 * StringUtils.indexOfAnyBut(*, [])                                = -1
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", new char[] {'z', 'a'} ) = 3
 * StringUtils.indexOfAnyBut(""aba"", new char[] {'z'} )             = 0
 * StringUtils.indexOfAnyBut(""aba"", new char[] {'a', 'b'} )        = -1
 *
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAnyBut(String, char[]) to indexOfAnyBut(CharSequence, char...)
 */
public static int indexOfAnyBut(CharSequence cs, char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int csLen = cs.length();
    int csLast = csLen - 1;
    int searchLen = searchChars.length;
    int searchLast = searchLen - 1;
    outer: for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
                    if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        continue outer;
                    }
                } else {
                    continue outer;
                }
            }
        }
        return i;
    }
    return INDEX_NOT_FOUND;
}","public void test109194() throws Throwable {
    StringUtils.splitPreserveAllTokens("";DI>"", "";DI>"", 1209);
    StringUtils.isAlphanumeric("";DI>"");
    StringUtils.isAllUpperCase("";DI>"");
    String string0 = StringUtils.repeat(')', 1209);
    StringUtils.abbreviateMiddle("";DI>"", string0, 97);
    StringUtils.right(string0, 4);
    StringUtils.indexOf((CharSequence) "";DI>"", 4, 1209);
    StringUtils.lastIndexOfIgnoreCase((CharSequence) "";DI>"", (CharSequence) string0, (-1638));
    StringUtils.left("";DI>"", (-1));
    StringUtils.substring("";DI>"", (-428));
    StringUtils.ordinalIndexOf(string0, "";DI>"", 1209);
    StringUtils.swapCase(""yvUERxoF_)eZN"");
    StringUtils.left("";DI>"", 97);
    StringUtils.reverse(""VkS0k[m/DDf;C;o"");
    StringUtils.removeEndIgnoreCase((String) null, ""uG+&Rze7.B"");
    StringUtils.lastIndexOf((CharSequence) "";DI>"", (CharSequence) "";DI>"");
    char[] charArray0 = new char[3];
    charArray0[0] = 'U';
    charArray0[1] = ')';
    charArray0[2] = 'R';
    StringUtils.indexOfAnyBut((CharSequence) string0, charArray0);
}",""
"// IndexOfAny chars
//-----------------------------------------------------------------------
/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A {@code null} String will return {@code -1}.
 * A {@code null} or zero length search array will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)                = -1
 * StringUtils.indexOfAny("""", *)                  = -1
 * StringUtils.indexOfAny(*, null)                = -1
 * StringUtils.indexOfAny(*, [])                  = -1
 * StringUtils.indexOfAny(""zzabyycdxx"",['z','a']) = 0
 * StringUtils.indexOfAny(""zzabyycdxx"",['b','y']) = 3
 * StringUtils.indexOfAny(""aba"", ['z'])           = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAny(String, char[]) to indexOfAny(CharSequence, char...)
 */
public static int indexOfAny(CharSequence cs, char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int csLen = cs.length();
    int csLast = csLen - 1;
    int searchLen = searchChars.length;
    int searchLast = searchLen - 1;
    for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
                    // ch is a supplementary character
                    if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        return i;
                    }
                } else {
                    return i;
                }
            }
        }
    }
    return INDEX_NOT_FOUND;
}","public void test110195() throws Throwable {
    StringUtils.indexOf((CharSequence) null, 420, 420);
    StringUtils.substringBetween("""", "" is not in the range '0' - '9'"");
    StringUtils.difference((String) null, ""U~L5Ngwo]E_.K,"");
    StringUtils.replaceOnce(""U~L5Ngwo]E_.K,"", ""G'(7FHXiaAKe-"", """");
    StringUtils.isAllLowerCase((CharSequence) null);
    StringUtils.trimToEmpty(""U~L5Ngwo]E_.K,"");
    char[] charArray0 = new char[7];
    charArray0[0] = 'i';
    charArray0[1] = '}';
    charArray0[2] = '+';
    charArray0[3] = '!';
    charArray0[4] = '>';
    charArray0[5] = ')';
    charArray0[6] = 'D';
    StringUtils.indexOfAny((CharSequence) ""U~L5Ngwo]E_.K,"", charArray0);
}",""
"public static String join(Object[] array, char separator) {
    if (array == null) {
        return null;
    }
    return join(array, separator, 0, array.length);
}","public void test111196() throws Throwable {
    StringUtils.chop(""7k"");
    Object[] objectArray0 = new Object[7];
    objectArray0[1] = (Object) ""7k"";
    StringUtils.join(objectArray0, 'f');
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)               = null
 * StringUtils.join([], *)                 = """"
 * StringUtils.join([null], *)             = """"
 * StringUtils.join([""a"", ""b"", ""c""], ';')  = ""a;b;c""
 * StringUtils.join([""a"", ""b"", ""c""], null) = ""abc""
 * StringUtils.join([null, """", ""a""], ';')  = "";;a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use
 * @return the joined String, {@code null} if null array input
 * @since 2.0
 */"
"// IndexOfAnyBut chars
//-----------------------------------------------------------------------
/**
 * <p>Searches a CharSequence to find the first index of any
 * character not in the given set of characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A {@code null} or zero length search array will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAnyBut(null, *)                              = -1
 * StringUtils.indexOfAnyBut("""", *)                                = -1
 * StringUtils.indexOfAnyBut(*, null)                              = -1
 * StringUtils.indexOfAnyBut(*, [])                                = -1
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", new char[] {'z', 'a'} ) = 3
 * StringUtils.indexOfAnyBut(""aba"", new char[] {'z'} )             = 0
 * StringUtils.indexOfAnyBut(""aba"", new char[] {'a', 'b'} )        = -1
 *
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAnyBut(String, char[]) to indexOfAnyBut(CharSequence, char...)
 */
public static int indexOfAnyBut(CharSequence cs, char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int csLen = cs.length();
    int csLast = csLen - 1;
    int searchLen = searchChars.length;
    int searchLast = searchLen - 1;
    outer: for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
                    if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        continue outer;
                    }
                } else {
                    continue outer;
                }
            }
        }
        return i;
    }
    return INDEX_NOT_FOUND;
}","public void test112197() throws Throwable {
    StringUtils.join((String[]) null);
    StringUtils.splitPreserveAllTokens((String) null, (String) null);
    StringUtils.containsNone((CharSequence) null, (String) null);
    StringUtils.endsWith((CharSequence) null, (CharSequence) null);
    StringUtils.swapCase((String) null);
    StringUtils.lastIndexOfIgnoreCase((CharSequence) null, (CharSequence) null);
    StringUtils.lastOrdinalIndexOf((CharSequence) null, (CharSequence) null, 127);
    char[] charArray0 = new char[8];
    charArray0[0] = 'G';
    charArray0[1] = '3';
    charArray0[2] = 'g';
    charArray0[3] = 'w';
    charArray0[4] = 'E';
    charArray0[5] = 'e';
    charArray0[6] = '1';
    charArray0[7] = 'A';
    StringUtils.indexOfAnyBut((CharSequence) null, charArray0);
}",""
"public static String substringAfterLast(String str, String separator) {
    if (isEmpty(str)) {
        return str;
    }
    if (isEmpty(separator)) {
        return EMPTY;
    }
    int pos = str.lastIndexOf(separator);
    if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) {
        return EMPTY;
    }
    return str.substring(pos + separator.length());
}","public void test113198() throws Throwable {
    StringUtils.upperCase(""~#"");
    StringUtils.isAlphanumericSpace(""~#"");
    StringUtils stringUtils0 = new StringUtils();
    StringUtils.abbreviateMiddle("""", (String) null, 0);
    StringUtils.lowerCase(""LA7X}qlQ"");
    StringUtils.isNotBlank(""~#"");
    StringUtils.contains((CharSequence) ""~#"", (CharSequence) ""LA7X}qlQ"");
    StringUtils.indexOf((CharSequence) ""~#"", 0, (-1));
    ArrayDeque<Object> arrayDeque0 = new ArrayDeque<Object>();
    arrayDeque0.add(""la7x}qlq"");
    StringUtils.join((Iterable<?>) arrayDeque0, '-');
    StringUtils.splitByWholeSeparatorPreserveAllTokens(""la7x}qlq"", ""java.lang.String@0000000002"", (-1));
    StringUtils.indexOfAnyBut((CharSequence) ""java.lang.String@0000000002"", (CharSequence) """");
    StringUtils.join((Iterable<?>) arrayDeque0, ""LA7X}qlQ"");
    arrayDeque0.pop();
    StringUtils.isAlphanumeric((CharSequence) null);
    StringUtils.lastIndexOfIgnoreCase((CharSequence) ""java.lang.String@0000000002"", (CharSequence) null);
    StringUtils.containsIgnoreCase(""java.lang.String@0000000002"", """");
    StringUtils.substringAfterLast(""java.lang.String@0000000002"", ""o/sM- /4"");
}","/**
 * <p>Gets the substring after the last occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A {@code null} string input will return {@code null}.
 * An empty ("""") string input will return the empty string.
 * An empty or {@code null} separator will return the empty string if
 * the input string is not {@code null}.</p>
 *
 * <p>If nothing is found, the empty string is returned.</p>
 *
 * <pre>
 * StringUtils.substringAfterLast(null, *)      = null
 * StringUtils.substringAfterLast("""", *)        = """"
 * StringUtils.substringAfterLast(*, """")        = """"
 * StringUtils.substringAfterLast(*, null)      = """"
 * StringUtils.substringAfterLast(""abc"", ""a"")   = ""bc""
 * StringUtils.substringAfterLast(""abcba"", ""b"") = ""a""
 * StringUtils.substringAfterLast(""abc"", ""c"")   = """"
 * StringUtils.substringAfterLast(""a"", ""a"")     = """"
 * StringUtils.substringAfterLast(""a"", ""z"")     = """"
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring after the last occurrence of the separator,
 *  {@code null} if null String input
 * @since 2.0
 */"
"public static String removeEndIgnoreCase(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (endsWithIgnoreCase(str, remove)) {
        return str.substring(0, str.length() - remove.length());
    }
    return str;
}","public void test114199() throws Throwable {
    StringUtils.repeat(""LCeD+AXt;Wl#ckO"", 0);
    StringUtils.difference(""LCeD+AXt;Wl#ckO"", """");
    StringUtils.getLevenshteinDistance((CharSequence) """", (CharSequence) """");
    LinkedList<Integer> linkedList0 = new LinkedList<Integer>();
    Iterator<Integer> iterator0 = linkedList0.iterator();
    StringUtils.join(iterator0, 'm');
    StringUtils.indexOfAny((CharSequence) ""LCeD+AXt;Wl#ckO"", """");
    StringUtils.isAllUpperCase("""");
    StringUtils.lastIndexOfIgnoreCase((CharSequence) """", (CharSequence) """", 0);
    CharSequence[] charSequenceArray0 = new CharSequence[7];
    charSequenceArray0[0] = (CharSequence) """";
    charSequenceArray0[1] = (CharSequence) """";
    charSequenceArray0[2] = (CharSequence) """";
    charSequenceArray0[3] = (CharSequence) ""LCeD+AXt;Wl#ckO"";
    charSequenceArray0[4] = (CharSequence) ""LCeD+AXt;Wl#ckO"";
    charSequenceArray0[5] = (CharSequence) ""LCeD+AXt;Wl#ckO"";
    charSequenceArray0[6] = (CharSequence) ""LCeD+AXt;Wl#ckO"";
    StringUtils.indexOfAny((CharSequence) """", charSequenceArray0);
    StringUtils.join(iterator0, 'm');
    StringUtils.substringBeforeLast(""_?9\""HSgP"", """");
    StringUtils.countMatches(""_?9\""HSgP"", """");
    StringUtils.join(iterator0, ""_?9\""HSgP"");
    StringUtils.length(charSequenceArray0[5]);
    StringUtils.lastIndexOf((CharSequence) ""LCeD+AXt;Wl#ckO"", charSequenceArray0[3], 2676);
    StringUtils.indexOf((CharSequence) """", (CharSequence) """");
    StringUtils.removeEndIgnoreCase("""", ""GCD7T:b"");
}","/**
 * <p>Case insensitive removal of a substring if it is at the end of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("""") source string will return the empty string.
 * A {@code null} search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeEndIgnoreCase(null, *)      = null
 * StringUtils.removeEndIgnoreCase("""", *)        = """"
 * StringUtils.removeEndIgnoreCase(*, null)      = *
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", "".com."")  = ""www.domain.com""
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", "".com"")   = ""www.domain""
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeEndIgnoreCase(""abc"", """")    = ""abc""
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", "".COM"") = ""www.domain"")
 * StringUtils.removeEndIgnoreCase(""www.domain.COM"", "".com"") = ""www.domain"")
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for (case insensitive) and remove, may be null
 * @return the substring with the string removed if found,
 *  {@code null} if null String input
 * @since 2.4
 */"
"// Misc
//-----------------------------------------------------------------------
/**
 * <p>Find the Levenshtein distance between two Strings.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>The previous implementation of the Levenshtein distance algorithm
 * was from <a href=""http://www.merriampark.com/ld.htm"">http://www.merriampark.com/ld.htm</a></p>
 *
 * <p>Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError
 * which can occur when my Java implementation is used with very large strings.<br>
 * This implementation of the Levenshtein distance algorithm
 * is from <a href=""http://www.merriampark.com/ldjava.htm"">http://www.merriampark.com/ldjava.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("""","""")               = 0
 * StringUtils.getLevenshteinDistance("""",""a"")              = 1
 * StringUtils.getLevenshteinDistance(""aaapppp"", """")       = 7
 * StringUtils.getLevenshteinDistance(""frog"", ""fog"")       = 1
 * StringUtils.getLevenshteinDistance(""fly"", ""ant"")        = 3
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""zzzzzzzz"") = 8
 * StringUtils.getLevenshteinDistance(""hello"", ""hallo"")    = 1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @return result distance
 * @throws IllegalArgumentException if either String input {@code null}
 * @since 3.0 Changed signature from getLevenshteinDistance(String, String) to
 * getLevenshteinDistance(CharSequence, CharSequence)
 */
public static int getLevenshteinDistance(CharSequence s, CharSequence t) {
    if (s == null || t == null) {
        throw new IllegalArgumentException(""Strings must not be null"");
    }
    /*
           The difference between this impl. and the previous is that, rather
           than creating and retaining a matrix of size s.length() + 1 by t.length() + 1,
           we maintain two single-dimensional arrays of length s.length() + 1.  The first, d,
           is the 'current working' distance array that maintains the newest distance cost
           counts as we iterate through the characters of String s.  Each time we increment
           the index of String t we are comparing, d is copied to p, the second int[].  Doing so
           allows us to retain the previous cost counts as required by the algorithm (taking
           the minimum of the cost count to the left, up one, and diagonally up and to the left
           of the current cost count being calculated).  (Note that the arrays aren't really
           copied anymore, just switched...this is clearly much better than cloning an array
           or doing a System.arraycopy() each time  through the outer loop.)

           Effectively, the difference between the two implementations is this one does not
           cause an out of memory condition when calculating the LD over two very large strings.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    if (n == 0) {
        return m;
    } else if (m == 0) {
        return n;
    }
    if (n > m) {
        // swap the input strings to consume less memory
        CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    //'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    //placeholder to assist in swapping p and d
    int[] _d;
    // indexes into strings s and t
    // iterates through s
    int i;
    // iterates through t
    int j;
    // jth character of t
    char t_j;
    // cost
    int cost;
    for (i = 0; i <= n; i++) {
        p[i] = i;
    }
    for (j = 1; j <= m; j++) {
        t_j = t.charAt(j - 1);
        d[0] = j;
        for (i = 1; i <= n; i++) {
            cost = s.charAt(i - 1) == t_j ? 0 : 1;
            // minimum of cell to the left+1, to the top+1, diagonally left and up +cost
            d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost);
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // our last action in the above loop was to switch d and p, so p now
    // actually has the most recent cost counts
    return p[n];
}","public void test115200() throws Throwable {
    StringUtils.trimToNull((String) null);
    String string0 = """";
    StringUtils.abbreviateMiddle("""", """", 0);
    CharSequence[] charSequenceArray0 = new CharSequence[2];
    charSequenceArray0[0] = (CharSequence) null;
    charSequenceArray0[1] = (CharSequence) """";
    StringUtils.startsWithAny("""", charSequenceArray0);
    StringUtils.upperCase((String) null);
    StringUtils.countMatches("""", (CharSequence) null);
    StringUtils.splitPreserveAllTokens("""", 'd');
    int int0 = 3077;
    StringUtils.split(""z?8BI%.?IOfF"", ""z?8BI%.?IOfF"", 3077);
    StringUtils.indexOf((CharSequence) """", 0);
    StringUtils.stripEnd("""", (String) null);
    StringUtils.splitByWholeSeparator("""", """", (-752));
    // Undeclared exception!
    try {
        StringUtils.getLevenshteinDistance((CharSequence) null, (CharSequence) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Strings must not be null
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}",""
"public static String abbreviate(String str, int offset, int maxWidth) {
    if (str == null) {
        return null;
    }
    if (maxWidth < 4) {
        throw new IllegalArgumentException(""Minimum abbreviation width is 4"");
    }
    if (str.length() <= maxWidth) {
        return str;
    }
    if (offset > str.length()) {
        offset = str.length();
    }
    if ((str.length() - offset) < (maxWidth - 3)) {
        offset = str.length() - (maxWidth - 3);
    }
    final String abrevMarker = ""..."";
    if (offset <= 4) {
        return str.substring(0, maxWidth - 3) + abrevMarker;
    }
    if (maxWidth < 7) {
        throw new IllegalArgumentException(""Minimum abbreviation width with offset is 7"");
    }
    if ((offset + (maxWidth - 3)) < str.length()) {
        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);
    }
    return abrevMarker + str.substring(str.length() - (maxWidth - 3));
}","public void test116201() throws Throwable {
    StringUtils.strip((String) null, (String) null);
    StringUtils.isNotBlank((CharSequence) null);
    StringUtils.chop(""zlsIcTn(Hb=-|z,sh"");
    StringUtils.isAlphaSpace(""zlsIcTn(Hb=-|z,sh"");
    StringUtils.difference(""OBI8Y^dqsK|/,yy"", """");
    StringUtils.lowerCase(""NFD"");
    StringUtils.center("""", 0, ""zlsIcTn(Hb=-|z,sh"");
    StringUtils.containsAny((CharSequence) """", (CharSequence) """");
    StringUtils.isAlphanumeric(""nfd"");
    StringUtils.repeat('<', 7);
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""OBI8Y^dqsK|/,yy"";
    stringArray0[1] = ""NFD"";
    stringArray0[2] = """";
    StringUtils.replaceEachRepeatedly("""", stringArray0, stringArray0);
    StringUtils.ordinalIndexOf(""nfd"", (CharSequence) null, 0);
    StringUtils.split("""");
    StringUtils.strip("""", ""..."");
    StringUtils.isWhitespace("""");
    StringUtils.stripAccents(""OBI8Y^dqsK|/,yy"");
    StringUtils.removeStart(""ciX?-maH5XWZ("", ""The Array must not be null"");
    StringUtils.join((Object[]) stringArray0);
    StringUtils.substringBetween(""zlsIcTn(Hb=-|z,sh"", """", ""w{@?n"");
    StringUtils.abbreviate((String) null, 128, 65);
}","/**
 * <p>Abbreviates a String using ellipses. This will turn
 * ""Now is the time for all good men"" into ""...is the time for...""</p>
 *
 * <p>Works like {@code abbreviate(String, int)}, but allows you to specify
 * a ""left edge"" offset.  Note that this left edge is not necessarily going to
 * be the leftmost character in the result, or the first character following the
 * ellipses, but it will appear somewhere in the result.
 *
 * <p>In no case will it return a String of length greater than
 * {@code maxWidth}.</p>
 *
 * <pre>
 * StringUtils.abbreviate(null, *, *)                = null
 * StringUtils.abbreviate("""", 0, 4)                  = """"
 * StringUtils.abbreviate(""abcdefghijklmno"", -1, 10) = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 0, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 1, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 4, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 5, 10)  = ""...fghi...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 6, 10)  = ""...ghij...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 8, 10)  = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghijklmno"", 10, 10) = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghijklmno"", 12, 10) = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghij"", 0, 3)        = IllegalArgumentException
 * StringUtils.abbreviate(""abcdefghij"", 5, 6)        = IllegalArgumentException
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param offset  left edge of source String
 * @param maxWidth  maximum length of result String, must be at least 4
 * @return abbreviated String, {@code null} if null String input
 * @throws IllegalArgumentException if the width is too small
 * @since 2.0
 */"
"// Left/Right/Mid
//-----------------------------------------------------------------------
/**
 * <p>Gets the leftmost {@code len} characters of a String.</p>
 *
 * <p>If {@code len} characters are not available, or the
 * String is {@code null}, the String will be returned without
 * an exception. An empty String is returned if len is negative.</p>
 *
 * <pre>
 * StringUtils.left(null, *)    = null
 * StringUtils.left(*, -ve)     = """"
 * StringUtils.left("""", *)      = """"
 * StringUtils.left(""abc"", 0)   = """"
 * StringUtils.left(""abc"", 2)   = ""ab""
 * StringUtils.left(""abc"", 4)   = ""abc""
 * </pre>
 *
 * @param str  the String to get the leftmost characters from, may be null
 * @param len  the length of the required String
 * @return the leftmost characters, {@code null} if null String input
 */
public static String left(String str, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0) {
        return EMPTY;
    }
    if (str.length() <= len) {
        return str;
    }
    return str.substring(0, len);
}","public void test117202() throws Throwable {
    String[] stringArray0 = StringUtils.splitByCharacterType(""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"");
    StringUtils.left(""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"", 7);
    StringUtils.capitalize(""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"");
    StringUtils.left(""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"", 7);
    StringUtils.rightPad(""&@}p"", 1, 'z');
    StringUtils.removeEndIgnoreCase(""The str"", ""The str"");
    StringUtils.isAlphanumeric(""&@}p"");
    StringUtils.swapCase("""");
    StringUtils.lastIndexOfIgnoreCase((CharSequence) """", (CharSequence) ""The str"", 65);
    StringUtils.lastIndexOfAny(""&@}p"", stringArray0);
    StringUtils.stripStart(""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"", ""3P|h!ACHt,oP!Mwvrg"");
    StringUtils.rightPad("" "", (-569));
    StringUtils.reverse(""+8(S!XW8lr5DR>yl"");
    StringUtils.chomp(""The character "");
    StringUtils.isNotBlank("" "");
    StringUtils.removeStart(""&@}p"", (String) null);
    StringUtils.center("""", (-1), ""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"");
    StringUtils.replaceOnce(""&@}p"", ""ly>RD5rl8WX!S(8+"", "" "");
    StringUtils.overlay(""mLGE1%D"", ""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"", (-1213), 2346);
    StringUtils.splitByWholeSeparatorPreserveAllTokens("" "", """");
    StringUtils.left("" "", (-1));
}",""
"public static boolean endsWithAny(CharSequence string, CharSequence... searchStrings) {
    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {
        return false;
    }
    for (int i = 0; i < searchStrings.length; i++) {
        CharSequence searchString = searchStrings[i];
        if (StringUtils.endsWith(string, searchString)) {
            return true;
        }
    }
    return false;
}","public void test118203() throws Throwable {
    StringUtils.abbreviate("""", 2643);
    StringUtils.isAlphaSpace("""");
    StringUtils.defaultIfEmpty("""", (String) null);
    CharSequence[] charSequenceArray0 = new CharSequence[8];
    charSequenceArray0[0] = (CharSequence) null;
    charSequenceArray0[1] = (CharSequence) """";
    charSequenceArray0[2] = (CharSequence) """";
    charSequenceArray0[3] = (CharSequence) """";
    charSequenceArray0[4] = (CharSequence) null;
    charSequenceArray0[5] = (CharSequence) null;
    charSequenceArray0[6] = (CharSequence) """";
    charSequenceArray0[7] = (CharSequence) null;
    StringUtils.endsWithAny((CharSequence) null, charSequenceArray0);
}","/**
 * <p>Check if a CharSequence ends with any of an array of specified strings.</p>
 *
 * <pre>
 * StringUtils.endsWithAny(null, null)      = false
 * StringUtils.endsWithAny(null, new String[] {""abc""})  = false
 * StringUtils.endsWithAny(""abcxyz"", null)     = false
 * StringUtils.endsWithAny(""abcxyz"", new String[] {""""}) = true
 * StringUtils.endsWithAny(""abcxyz"", new String[] {""xyz""}) = true
 * StringUtils.endsWithAny(""abcxyz"", new String[] {null, ""xyz"", ""abc""}) = true
 * </pre>
 *
 * @param string  the CharSequence to check, may be null
 * @param searchStrings the CharSequences to find, may be null or empty
 * @return {@code true} if the CharSequence ends with any of the the prefixes, case insensitive, or
 *  both {@code null}
 * @since 3.0
 */"
"public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {
    // timeToLive should be 0 if not used or nothing to replace, else it's
    // the length of the replace array
    int timeToLive = searchList == null ? 0 : searchList.length;
    return replaceEach(text, searchList, replacementList, true, timeToLive);
}","public void test119204() throws Throwable {
    StringUtils.strip(""IllegalAccessException occurred"", ""IllegalAccessException occurred"");
    StringUtils.indexOf((CharSequence) """", 805);
    StringUtils.isEmpty("""");
    StringUtils.stripStart("", Length: 0"", ""0J2[+H"");
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    StringUtils.lowerCase("""", locale0);
    String[] stringArray0 = new String[6];
    stringArray0[0] = "", Length: 0"";
    stringArray0[1] = """";
    stringArray0[2] = ""IllegalAccessException occurred"";
    stringArray0[3] = "", Length: 0"";
    stringArray0[4] = """";
    stringArray0[5] = ""0J2[+H"";
    StringUtils.stripAll(stringArray0);
    String[] stringArray1 = new String[2];
    stringArray1[0] = ""IllegalAccessException occurred"";
    stringArray1[1] = """";
    String[] stringArray2 = new String[8];
    stringArray2[0] = """";
    stringArray2[1] = "", Length: 0"";
    stringArray2[2] = ""IllegalAccessException occurred"";
    stringArray2[3] = """";
    stringArray2[4] = """";
    stringArray2[5] = "", Length: 0"";
    stringArray2[6] = """";
    stringArray2[7] = "", Length: 0"";
    // Undeclared exception!
    try {
        StringUtils.replaceEachRepeatedly("", Length: 0"", stringArray1, stringArray2);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Search and Replace array lengths don't match: 2 vs 8
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}","/**
 * <p>
 * Replaces all occurrences of Strings within another String.
 * </p>
 *
 * <p>
 * A {@code null} reference passed to this method is a no-op, or if
 * any ""search string"" or ""string to replace"" is null, that replace will be
 * ignored. This will not repeat. For repeating replaces, call the
 * overloaded method.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *, *) = null
 *  StringUtils.replaceEach("""", *, *, *) = """"
 *  StringUtils.replaceEach(""aba"", null, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[0], null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", null, new String[0], *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""}, *) = ""b""
 *  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""}, *) = ""aba""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""}, *) = ""wcte""
 *  (example of how it repeats)
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, false) = ""dcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, true) = ""tcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, true) = IllegalArgumentException
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, false) = ""dcabe""
 * </pre>
 *
 * @param text
 *            text to search and replace in, no-op if null
 * @param searchList
 *            the Strings to search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @return the text with any replacements processed, {@code null} if
 *         null String input
 * @throws IllegalArgumentException
 *             if the search is repeating and there is an endless loop due
 *             to outputs of one being inputs to another
 * @throws IndexOutOfBoundsException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */"
"public static String center(String str, int size, String padStr) {
    if (str == null || size <= 0) {
        return str;
    }
    if (isEmpty(padStr)) {
        padStr = "" "";
    }
    int strLen = str.length();
    int pads = size - strLen;
    if (pads <= 0) {
        return str;
    }
    str = leftPad(str, strLen + pads / 2, padStr);
    str = rightPad(str, size, padStr);
    return str;
}","public void test121206() throws Throwable {
    StringUtils.center(""rU1-EQ:+\""ti!L3bRU&F"", 1962, """");
}","/**
 * <p>Centers a String in a larger String of size {@code size}.
 * Uses a supplied String as the value to pad the String with.</p>
 *
 * <p>If the size is less than the String length, the String is returned.
 * A {@code null} String returns {@code null}.
 * A negative size is treated as zero.</p>
 *
 * <pre>
 * StringUtils.center(null, *, *)     = null
 * StringUtils.center("""", 4, "" "")     = ""    ""
 * StringUtils.center(""ab"", -1, "" "")  = ""ab""
 * StringUtils.center(""ab"", 4, "" "")   = "" ab""
 * StringUtils.center(""abcd"", 2, "" "") = ""abcd""
 * StringUtils.center(""a"", 4, "" "")    = "" a  ""
 * StringUtils.center(""a"", 4, ""yz"")   = ""yayz""
 * StringUtils.center(""abc"", 7, null) = ""  abc  ""
 * StringUtils.center(""abc"", 7, """")   = ""  abc  ""
 * </pre>
 *
 * @param str  the String to center, may be null
 * @param size  the int size of new String, negative treated as zero
 * @param padStr  the String to pad the new String with, must not be null or empty
 * @return centered String, {@code null} if null String input
 * @throws IllegalArgumentException if padStr is {@code null} or empty
 */"
"public static String removeEndIgnoreCase(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (endsWithIgnoreCase(str, remove)) {
        return str.substring(0, str.length() - remove.length());
    }
    return str;
}","public void test122207() throws Throwable {
    StringUtils.right((String) null, 1);
    StringUtils.lastIndexOf((CharSequence) null, (CharSequence) null, (-1028));
    StringUtils.abbreviateMiddle(""normalize"", """", (-794));
    StringUtils.isAllUpperCase(""normalize"");
    StringUtils.indexOf((CharSequence) null, (-300));
    StringUtils.getLevenshteinDistance((CharSequence) ""normalize"", (CharSequence) """");
    StringUtils.strip((String) null, """");
    StringUtils.isAlpha("""");
    StringUtils.isNumericSpace("""");
    StringUtils.splitByWholeSeparatorPreserveAllTokens((String) null, """");
    StringUtils.isNotBlank((CharSequence) null);
    StringUtils.containsIgnoreCase(""normalize"", (CharSequence) null);
    StringUtils.trim((String) null);
    StringUtils.containsWhitespace(""normalize"");
    StringUtils.difference(""normalize"", ""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"");
    StringUtils.endsWith(""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"", (CharSequence) null);
    char[] charArray0 = new char[0];
    StringUtils.containsNone((CharSequence) ""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"", charArray0);
    StringUtils.isNotEmpty("""");
    StringUtils.trimToEmpty(""6t63A"");
    StringUtils.chop("""");
    StringUtils.removeEnd(""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"", ""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"");
    StringUtils.removeEndIgnoreCase(""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"", ""c&5~&  bx&v1}"");
}","/**
 * <p>Case insensitive removal of a substring if it is at the end of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("""") source string will return the empty string.
 * A {@code null} search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeEndIgnoreCase(null, *)      = null
 * StringUtils.removeEndIgnoreCase("""", *)        = """"
 * StringUtils.removeEndIgnoreCase(*, null)      = *
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", "".com."")  = ""www.domain.com""
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", "".com"")   = ""www.domain""
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeEndIgnoreCase(""abc"", """")    = ""abc""
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", "".COM"") = ""www.domain"")
 * StringUtils.removeEndIgnoreCase(""www.domain.COM"", "".com"") = ""www.domain"")
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for (case insensitive) and remove, may be null
 * @return the substring with the string removed if found,
 *  {@code null} if null String input
 * @since 2.4
 */"
"public static String join(Iterator<?> iterator, char separator) {
    // handle null, zero and one elements before building a buffer
    if (iterator == null) {
        return null;
    }
    if (!iterator.hasNext()) {
        return EMPTY;
    }
    Object first = iterator.next();
    if (!iterator.hasNext()) {
        return ObjectUtils.toString(first);
    }
    // two or more elements
    // Java default is 16, probably too small
    StringBuilder buf = new StringBuilder(256);
    if (first != null) {
        buf.append(first);
    }
    while (iterator.hasNext()) {
        buf.append(separator);
        Object obj = iterator.next();
        if (obj != null) {
            buf.append(obj);
        }
    }
    return buf.toString();
}","public void test123208() throws Throwable {
    StringUtils.indexOf((CharSequence) null, (-2881));
    StringUtils.chop((String) null);
    StringUtils.substring((String) null, 3);
    StringUtils.equalsIgnoreCase((CharSequence) null, (CharSequence) null);
    ArrayDeque<String> arrayDeque0 = new ArrayDeque<String>();
    Iterator<String> iterator0 = arrayDeque0.iterator();
    StringUtils.join(iterator0, 'A');
}","/**
 * <p>Joins the elements of the provided {@code Iterator} into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list. Null objects or empty
 * strings within the iteration are represented by empty strings.</p>
 *
 * <p>See the examples here: {@link #join(Object[],char)}. </p>
 *
 * @param iterator  the {@code Iterator} of values to join together, may be null
 * @param separator  the separator character to use
 * @return the joined String, {@code null} if null iterator input
 * @since 2.0
 */"
"// Replacing
//-----------------------------------------------------------------------
/**
 * <p>Replaces a String with another String inside a larger String, once.</p>
 *
 * <p>A {@code null} reference passed to this method is a no-op.</p>
 *
 * <pre>
 * StringUtils.replaceOnce(null, *, *)        = null
 * StringUtils.replaceOnce("""", *, *)          = """"
 * StringUtils.replaceOnce(""any"", null, *)    = ""any""
 * StringUtils.replaceOnce(""any"", *, null)    = ""any""
 * StringUtils.replaceOnce(""any"", """", *)      = ""any""
 * StringUtils.replaceOnce(""aba"", ""a"", null)  = ""aba""
 * StringUtils.replaceOnce(""aba"", ""a"", """")    = ""ba""
 * StringUtils.replaceOnce(""aba"", ""a"", ""z"")   = ""zba""
 * </pre>
 *
 * @see #replace(String text, String searchString, String replacement, int max)
 * @param text  text to search and replace in, may be null
 * @param searchString  the String to search for, may be null
 * @param replacement  the String to replace with, may be null
 * @return the text with any replacements processed,
 *  {@code null} if null String input
 */
public static String replaceOnce(String text, String searchString, String replacement) {
    return replace(text, searchString, replacement, 1);
}","public void test124209() throws Throwable {
    StringUtils.remove(""=8,))}b`:-"", '@');
    StringUtils.containsOnly((CharSequence) ""=8,))}b`:-"", """");
    StringUtils.replaceChars("""", """", ""sun.text.Normalizer is not available"");
    StringUtils.lastOrdinalIndexOf("""", ""=8,))}b`:-"", (-1436));
    StringUtils.indexOf((CharSequence) ""=8,))}b`:-"", (CharSequence) ""=8,))}b`:-"", 0);
    StringUtils.reverseDelimited("""", '@');
    StringUtils.indexOf((CharSequence) """", (CharSequence) """", (-974));
    StringUtils.removeStart(""Arguments cannot both be null"", """");
    StringUtils.lastIndexOfIgnoreCase((CharSequence) """", (CharSequence) """");
    StringUtils.replaceOnce("""", """", (String) null);
}",""
"public static boolean isNotBlank(CharSequence cs) {
    return !StringUtils.isBlank(cs);
}","public void test125210() throws Throwable {
    StringUtils.leftPad((String) null, (-2), '^');
    StringUtils.defaultIfEmpty((CharSequence) null, (CharSequence) null);
    StringUtils.isNumericSpace((CharSequence) null);
    StringUtils.splitByCharacterTypeCamelCase((String) null);
    StringUtils.indexOf((CharSequence) null, (CharSequence) null);
    StringUtils.mid((String) null, (-2), 10);
    StringUtils.defaultString((String) null);
    StringUtils.stripStart(""normalize"", """");
    StringUtils.ordinalIndexOf(""normalize"", (CharSequence) null, (-1));
    StringUtils.contains((CharSequence) null, 0);
    StringUtils.remove("""", '?');
    StringUtils.isNotBlank("""");
}","/**
 * <p>Checks if a CharSequence is not empty (""""), not null and not whitespace only.</p>
 *
 * <pre>
 * StringUtils.isNotBlank(null)      = false
 * StringUtils.isNotBlank("""")        = false
 * StringUtils.isNotBlank("" "")       = false
 * StringUtils.isNotBlank(""bob"")     = true
 * StringUtils.isNotBlank(""  bob  "") = true
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if the CharSequence is
 *  not empty and not null and not whitespace
 * @since 2.0
 * @since 3.0 Changed signature from isNotBlank(String) to isNotBlank(CharSequence)
 */"
"// IndexOfAny chars
//-----------------------------------------------------------------------
/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A {@code null} String will return {@code -1}.
 * A {@code null} or zero length search array will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)                = -1
 * StringUtils.indexOfAny("""", *)                  = -1
 * StringUtils.indexOfAny(*, null)                = -1
 * StringUtils.indexOfAny(*, [])                  = -1
 * StringUtils.indexOfAny(""zzabyycdxx"",['z','a']) = 0
 * StringUtils.indexOfAny(""zzabyycdxx"",['b','y']) = 3
 * StringUtils.indexOfAny(""aba"", ['z'])           = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAny(String, char[]) to indexOfAny(CharSequence, char...)
 */
public static int indexOfAny(CharSequence cs, char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int csLen = cs.length();
    int csLast = csLen - 1;
    int searchLen = searchChars.length;
    int searchLast = searchLen - 1;
    for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
                    // ch is a supplementary character
                    if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        return i;
                    }
                } else {
                    return i;
                }
            }
        }
    }
    return INDEX_NOT_FOUND;
}","public void test126211() throws Throwable {
    StringUtils.substringBetween(""VqZ~<pJ7"", """");
    StringUtils.substringBetween("""", """");
    StringUtils.defaultString("",:^bIz%"");
    StringUtils.chomp("""", """");
    StringUtils.isEmpty("""");
    StringUtils.containsWhitespace((CharSequence) null);
    StringUtils.splitPreserveAllTokens("""", "", Length: 0"");
    StringUtils.startsWithIgnoreCase("""", """");
    StringUtils.leftPad(""VqZ~<pJ7"", (-397));
    StringUtils.substring(""x`(A8"", (-3070), 2143);
    char[] charArray0 = new char[1];
    charArray0[0] = 'q';
    StringUtils.indexOfAny((CharSequence) """", charArray0);
}",""
"public static int getLevenshteinDistance(CharSequence s, CharSequence t, int threshold) {
    if (s == null || t == null) {
        throw new IllegalArgumentException(""Strings must not be null"");
    }
    if (threshold < 0) {
        throw new IllegalArgumentException(""Threshold must not be negative"");
    }
    /*
        This implementation only computes the distance if it's less than or equal to the
        threshold value, returning -1 if it's greater.  The advantage is performance: unbounded
        distance is O(nm), but a bound of k allows us to reduce it to O(km) time by only 
        computing a diagonal stripe of width 2k + 1 of the cost table.
        It is also possible to use this to compute the unbounded Levenshtein distance by starting
        the threshold at 1 and doubling each time until the distance is found; this is O(dm), where
        d is the distance.
        
        One subtlety comes from needing to ignore entries on the border of our stripe
        eg.
        p[] = |#|#|#|*
        d[] =  *|#|#|#|
        We must ignore the entry to the left of the leftmost member
        We must ignore the entry above the rightmost member
        
        Another subtlety comes from our stripe running off the matrix if the strings aren't
        of the same size.  Since string s is always swapped to be the shorter of the two, 
        the stripe will always run off to the upper right instead of the lower left of the matrix.
        
        As a concrete example, suppose s is of length 5, t is of length 7, and our threshold is 1.
        In this case we're going to walk a stripe of length 3.  The matrix would look like so:
        
           1 2 3 4 5
        1 |#|#| | | |
        2 |#|#|#| | |
        3 | |#|#|#| |
        4 | | |#|#|#|
        5 | | | |#|#|
        6 | | | | |#|
        7 | | | | | |

        Note how the stripe leads off the table as there is no possible way to turn a string of length 5
        into one of length 7 in edit distance of 1.
        
        Additionally, this implementation decreases memory usage by using two 
        single-dimensional arrays and swapping them back and forth instead of allocating
        an entire n by m matrix.  This requires a few minor changes, such as immediately returning 
        when it's detected that the stripe has run off the matrix and initially filling the arrays with
        large values so that entries we don't compute are ignored.

        See Algorithms on Strings, Trees and Sequences by Dan Gusfield for some discussion.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    // if one string is empty, the edit distance is necessarily the length of the other
    if (n == 0) {
        return m <= threshold ? m : -1;
    } else if (m == 0) {
        return n <= threshold ? n : -1;
    }
    if (n > m) {
        // swap the two strings to consume less memory
        CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    // 'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    // placeholder to assist in swapping p and d
    int[] _d;
    // fill in starting table values
    int boundary = Math.min(n, threshold) + 1;
    for (int i = 0; i < boundary; i++) {
        p[i] = i;
    }
    // these fills ensure that the value above the rightmost entry of our
    // stripe will be ignored in following loop iterations
    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);
    Arrays.fill(d, Integer.MAX_VALUE);
    // iterates through t
    for (int j = 1; j <= m; j++) {
        // jth character of t
        char t_j = t.charAt(j - 1);
        d[0] = j;
        // compute stripe indices, constrain to array size
        int min = Math.max(1, j - threshold);
        int max = Math.min(n, j + threshold);
        // the stripe may lead off of the table if s and t are of different sizes
        if (min > max) {
            return -1;
        }
        // ignore entry left of leftmost
        if (min > 1) {
            d[min - 1] = Integer.MAX_VALUE;
        }
        // iterates through [min, max] in s
        for (int i = min; i <= max; i++) {
            if (s.charAt(i - 1) == t_j) {
                // diagonally left and up
                d[i] = p[i - 1];
            } else {
                // 1 + minimum of cell to the left, to the top, diagonally left and up
                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);
            }
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // if p[n] is greater than the threshold, there's no guarantee on it being the correct
    // distance
    if (p[n] <= threshold) {
        return p[n];
    } else {
        return -1;
    }
}","public void test127212() throws Throwable {
    char char0 = '.';
    StringUtils.replaceChars(""}B6Rn9"", '.', 'U');
    char[] charArray0 = new char[6];
    charArray0[0] = 'U';
    charArray0[1] = '.';
    charArray0[2] = '.';
    charArray0[3] = '.';
    charArray0[4] = '.';
    charArray0[5] = '.';
    StringUtils.containsNone((CharSequence) ""}B6Rn9"", charArray0);
    String string0 = "" in an array of "";
    StringUtils.chop("" in an array of "");
    String string1 = null;
    StringUtils.rightPad((String) null, 5, (String) null);
    StringUtils.defaultIfBlank((CharSequence) null, (CharSequence) "" in an array of "");
    // Undeclared exception!
    try {
        StringUtils.getLevenshteinDistance((CharSequence) null, (CharSequence) "" in an array of "", 1869);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Strings must not be null
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}","/**
 * <p>Find the Levenshtein distance between two Strings if it's less than or equal to a given
 * threshold.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>This implementation follows from Algorithms on Strings, Trees and Sequences by Dan Gusfield
 * and Chas Emerick's implementation of the Levenshtein distance algorithm from
 * <a href=""http://www.merriampark.com/ld.htm"">http://www.merriampark.com/ld.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, *, -1)               = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("""","""", 0)               = 0
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 8)       = 7
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 7)       = 7
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 6))      = -1
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"", 7) = 7
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"", 6) = -1
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"", 7) = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"", 6) = -1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @param threshold the target threshold, must not be negative
 * @return result distance, or {@code -1} if the distance would be greater than the threshold
 * @throws IllegalArgumentException if either String input {@code null} or negative threshold
 */"
"public static String join(Object[] array, char separator, int startIndex, int endIndex) {
    if (array == null) {
        return null;
    }
    int noOfItems = (endIndex - startIndex);
    if (noOfItems <= 0) {
        return EMPTY;
    }
    StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}","public void test128213() throws Throwable {
    String[] stringArray0 = new String[8];
    stringArray0[0] = """";
    stringArray0[1] = """";
    stringArray0[2] = ""SDX/9L@R&B$~j"";
    stringArray0[3] = ""moook*d\""9"";
    stringArray0[4] = ""..."";
    stringArray0[5] = ""tU"";
    stringArray0[6] = """";
    stringArray0[7] = """";
    StringUtils.getCommonPrefix(stringArray0);
    StringUtils.removeEndIgnoreCase(""xp6RMp2*n]O+oA+Rk*"", """");
    Object[] objectArray0 = new Object[3];
    objectArray0[0] = (Object) ""..."";
    objectArray0[1] = (Object) ""moook*d\""9"";
    objectArray0[2] = (Object) ""xp6RMp2*n]O+oA+Rk*"";
    StringUtils.join(objectArray0, '8', 3056, 128);
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)               = null
 * StringUtils.join([], *)                 = """"
 * StringUtils.join([null], *)             = """"
 * StringUtils.join([""a"", ""b"", ""c""], ';')  = ""a;b;c""
 * StringUtils.join([""a"", ""b"", ""c""], null) = ""abc""
 * StringUtils.join([null, """", ""a""], ';')  = "";;a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use
 * @param startIndex the first index to start joining from.  It is
 * an error to pass in an end index past the end of the array
 * @param endIndex the index to stop joining from (exclusive). It is
 * an error to pass in an end index past the end of the array
 * @return the joined String, {@code null} if null array input
 * @since 2.0
 */"
"// ContainsAny
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains any character in the given
 * set of characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.
 * A {@code null} or zero length search array will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)                = false
 * StringUtils.containsAny("""", *)                  = false
 * StringUtils.containsAny(*, null)                = false
 * StringUtils.containsAny(*, [])                  = false
 * StringUtils.containsAny(""zzabyycdxx"",['z','a']) = true
 * StringUtils.containsAny(""zzabyycdxx"",['b','y']) = true
 * StringUtils.containsAny(""aba"", ['z'])           = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the {@code true} if any of the chars are found,
 * {@code false} if no match or null input
 * @since 2.4
 * @since 3.0 Changed signature from containsAny(String, char[]) to containsAny(CharSequence, char...)
 */
public static boolean containsAny(CharSequence cs, char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    int csLast = csLength - 1;
    int searchLast = searchLength - 1;
    for (int i = 0; i < csLength; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == ch) {
                if (Character.isHighSurrogate(ch)) {
                    if (j == searchLast) {
                        // missing low surrogate, fine, like String.indexOf(String)
                        return true;
                    }
                    if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
                        return true;
                    }
                } else {
                    // ch is in the Basic Multilingual Plane
                    return true;
                }
            }
        }
    }
    return false;
}","public void test129214() throws Throwable {
    StringUtils.splitByCharacterTypeCamelCase("""");
    StringUtils.contains((CharSequence) """", 751);
    Locale.FilteringMode locale_FilteringMode0 = Locale.FilteringMode.EXTENDED_FILTERING;
    Locale.FilteringMode locale_FilteringMode1 = Locale.FilteringMode.MAP_EXTENDED_RANGES;
    EnumSet<Locale.FilteringMode> enumSet0 = EnumSet.range(locale_FilteringMode0, locale_FilteringMode1);
    enumSet0.add(locale_FilteringMode1);
    Iterator<Locale.FilteringMode> iterator0 = enumSet0.iterator();
    StringUtils.join(iterator0, """");
    StringUtils.abbreviate("")vQk9T<"", 751);
    StringUtils.capitalize(""EXTENDED_FILTERINGIGNORE_EXTENDED_RANGESMAP_EXTENDED_RANGES"");
    StringUtils.lowerCase(""EXTENDED_FILTERINGIGNORE_EXTENDED_RANGESMAP_EXTENDED_RANGES"");
    StringUtils.stripAccents("""");
    char[] charArray0 = new char[4];
    charArray0[0] = '_';
    charArray0[1] = 'M';
    charArray0[2] = 'W';
    charArray0[3] = '{';
    StringUtils.containsAny((CharSequence) ""EXTENDED_FILTERINGIGNORE_EXTENDED_RANGESMAP_EXTENDED_RANGES"", charArray0);
}",""
"public static String abbreviate(String str, int offset, int maxWidth) {
    if (str == null) {
        return null;
    }
    if (maxWidth < 4) {
        throw new IllegalArgumentException(""Minimum abbreviation width is 4"");
    }
    if (str.length() <= maxWidth) {
        return str;
    }
    if (offset > str.length()) {
        offset = str.length();
    }
    if ((str.length() - offset) < (maxWidth - 3)) {
        offset = str.length() - (maxWidth - 3);
    }
    final String abrevMarker = ""..."";
    if (offset <= 4) {
        return str.substring(0, maxWidth - 3) + abrevMarker;
    }
    if (maxWidth < 7) {
        throw new IllegalArgumentException(""Minimum abbreviation width with offset is 7"");
    }
    if ((offset + (maxWidth - 3)) < str.length()) {
        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);
    }
    return abrevMarker + str.substring(str.length() - (maxWidth - 3));
}","public void test130215() throws Throwable {
    StringUtils.removeEnd("""", ""N"");
    StringUtils.isAllUpperCase("""");
    StringUtils.upperCase("""");
    StringUtils.indexOfDifference((CharSequence) """", (CharSequence) """");
    String string0 = ""{}"";
    StringUtils.removeStart("""", ""{}"");
    StringUtils.deleteWhitespace("""");
    StringUtils.strip("""");
    StringUtils.isEmpty("""");
    StringUtils.removeStart(""nt4"", ""nt4"");
    StringUtils.reverse(""&6bQw}PTA'<2A%-\""`"");
    String string1 = ""\\u0"";
    StringUtils.split("""", string1);
    String string2 = ""java.text.Normalizer"";
    int int0 = 0;
    // Undeclared exception!
    try {
        StringUtils.abbreviate(""java.text.Normalizer"", (-1), 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Minimum abbreviation width is 4
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}","/**
 * <p>Abbreviates a String using ellipses. This will turn
 * ""Now is the time for all good men"" into ""...is the time for...""</p>
 *
 * <p>Works like {@code abbreviate(String, int)}, but allows you to specify
 * a ""left edge"" offset.  Note that this left edge is not necessarily going to
 * be the leftmost character in the result, or the first character following the
 * ellipses, but it will appear somewhere in the result.
 *
 * <p>In no case will it return a String of length greater than
 * {@code maxWidth}.</p>
 *
 * <pre>
 * StringUtils.abbreviate(null, *, *)                = null
 * StringUtils.abbreviate("""", 0, 4)                  = """"
 * StringUtils.abbreviate(""abcdefghijklmno"", -1, 10) = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 0, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 1, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 4, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 5, 10)  = ""...fghi...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 6, 10)  = ""...ghij...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 8, 10)  = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghijklmno"", 10, 10) = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghijklmno"", 12, 10) = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghij"", 0, 3)        = IllegalArgumentException
 * StringUtils.abbreviate(""abcdefghij"", 5, 6)        = IllegalArgumentException
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param offset  left edge of source String
 * @param maxWidth  maximum length of result String, must be at least 4
 * @return abbreviated String, {@code null} if null String input
 * @throws IllegalArgumentException if the width is too small
 * @since 2.0
 */"
"public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {
    return splitWorker(str, separatorChars, max, true);
}","public void test131216() throws Throwable {
    String[] stringArray0 = StringUtils.split(""<EGhp;v"", (String) null);
    StringUtils.abbreviate((String) null, 3646, (-1315));
    StringUtils.isAllUpperCase((CharSequence) null);
    StringUtils.split(""<EGhp;v"");
    StringUtils.join((Object[]) stringArray0, '8');
    String string0 = ""\\u000"";
    StringUtils.mid(string0, 0, (-1315));
    StringUtils.left((String) null, (-1082));
    Object[] objectArray0 = new Object[2];
    objectArray0[0] = (Object) null;
    Object object0 = new Object();
    objectArray0[1] = object0;
    StringUtils.join(objectArray0);
    StringUtils.substringBeforeLast("" vs "", ""<EGhp;v"");
    StringUtils.isBlank((CharSequence) null);
    StringUtils.splitPreserveAllTokens("" vs "", """", 80);
}","/**
 * <p>Splits the provided text into an array with a maximum length,
 * separators specified, preserving all tokens, including empty tokens
 * created by adjacent separators.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as separators for empty tokens.
 * Adjacent separators are treated as one separator.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} separatorChars splits on whitespace.</p>
 *
 * <p>If more than {@code max} delimited substrings are found, the last
 * returned string includes all characters after the first {@code max - 1}
 * returned strings (including separator characters).</p>
 *
 * <pre>
 * StringUtils.splitPreserveAllTokens(null, *, *)            = null
 * StringUtils.splitPreserveAllTokens("""", *, *)              = []
 * StringUtils.splitPreserveAllTokens(""ab de fg"", null, 0)   = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 0) = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef"", "":"", 0)    = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef"", "":"", 2)    = [""ab"", ""cd:ef""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 2) = [""ab"", ""  de fg""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 3) = [""ab"", """", "" de fg""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 4) = [""ab"", """", """", ""de fg""]
 * </pre>
 *
 * @param str  the String to parse, may be {@code null}
 * @param separatorChars  the characters used as the delimiters,
 *  {@code null} splits on whitespace
 * @param max  the maximum number of elements to include in the
 *  array. A zero or negative value implies no limit
 * @return an array of parsed Strings, {@code null} if null String input
 * @since 2.1
 */"
"// ContainsAny
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains any character in the given
 * set of characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.
 * A {@code null} or zero length search array will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)                = false
 * StringUtils.containsAny("""", *)                  = false
 * StringUtils.containsAny(*, null)                = false
 * StringUtils.containsAny(*, [])                  = false
 * StringUtils.containsAny(""zzabyycdxx"",['z','a']) = true
 * StringUtils.containsAny(""zzabyycdxx"",['b','y']) = true
 * StringUtils.containsAny(""aba"", ['z'])           = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the {@code true} if any of the chars are found,
 * {@code false} if no match or null input
 * @since 2.4
 * @since 3.0 Changed signature from containsAny(String, char[]) to containsAny(CharSequence, char...)
 */
public static boolean containsAny(CharSequence cs, char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    int csLast = csLength - 1;
    int searchLast = searchLength - 1;
    for (int i = 0; i < csLength; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == ch) {
                if (Character.isHighSurrogate(ch)) {
                    if (j == searchLast) {
                        // missing low surrogate, fine, like String.indexOf(String)
                        return true;
                    }
                    if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
                        return true;
                    }
                } else {
                    // ch is in the Basic Multilingual Plane
                    return true;
                }
            }
        }
    }
    return false;
}","public void test132217() throws Throwable {
    ArrayDeque<String> arrayDeque0 = new ArrayDeque<String>();
    Iterator<String> iterator0 = arrayDeque0.iterator();
    StringUtils.join(iterator0, '%');
    StringUtils.join((Iterable<?>) arrayDeque0, '$');
    StringUtils.getLevenshteinDistance((CharSequence) """", (CharSequence) """", 1110);
    char[] charArray0 = new char[9];
    charArray0[0] = '$';
    charArray0[1] = '=';
    charArray0[2] = '$';
    charArray0[3] = '$';
    charArray0[4] = '$';
    charArray0[5] = '%';
    charArray0[6] = '%';
    charArray0[7] = '%';
    charArray0[8] = '$';
    StringUtils.containsAny((CharSequence) """", charArray0);
}",""
"public static String join(Object[] array, String separator, int startIndex, int endIndex) {
    if (array == null) {
        return null;
    }
    if (separator == null) {
        separator = EMPTY;
    }
    // endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))
    //           (Assuming that all Strings are roughly equally long)
    int noOfItems = (endIndex - startIndex);
    if (noOfItems <= 0) {
        return EMPTY;
    }
    StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}","public void test133218() throws Throwable {
    StringUtils stringUtils0 = new StringUtils();
    StringUtils.lastIndexOf((CharSequence) """", (CharSequence) """");
    StringUtils.getLevenshteinDistance((CharSequence) """", (CharSequence) """");
    CharSequence[] charSequenceArray0 = new CharSequence[2];
    String string0 = StringUtils.EMPTY;
    charSequenceArray0[0] = (CharSequence) """";
    charSequenceArray0[1] = (CharSequence) """";
    StringUtils.indexOfAny((CharSequence) """", charSequenceArray0);
    StringUtils.getLevenshteinDistance(charSequenceArray0[1], charSequenceArray0[0]);
    // Undeclared exception!
    try {
        StringUtils.join((Object[]) charSequenceArray0, """", 0, Integer.MAX_VALUE);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 2
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A {@code null} separator is the same as an empty String ("""").
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)                = null
 * StringUtils.join([], *)                  = """"
 * StringUtils.join([null], *)              = """"
 * StringUtils.join([""a"", ""b"", ""c""], ""--"")  = ""a--b--c""
 * StringUtils.join([""a"", ""b"", ""c""], null)  = ""abc""
 * StringUtils.join([""a"", ""b"", ""c""], """")    = ""abc""
 * StringUtils.join([null, """", ""a""], ',')   = "",,a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @param startIndex the first index to start joining from.  It is
 * an error to pass in an end index past the end of the array
 * @param endIndex the index to stop joining from (exclusive). It is
 * an error to pass in an end index past the end of the array
 * @return the joined String, {@code null} if null array input
 */"
"public static boolean isAlphanumericSpace(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {
            return false;
        }
    }
    return true;
}","public void test134219() throws Throwable {
    StringUtils.substringBetween(""18K{Eu?>*GR?7iA"", ""NfpaXq6vRyz*mn;Z\""Up"", ""18K{Eu?>*GR?7iA"");
    StringUtils.isAlphanumericSpace((CharSequence) null);
}","/**
 * <p>Checks if the CharSequence contains only unicode letters, digits
 * or space ({@code ' '}).</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty CharSequence (length()=0) will return {@code true}.</p>
 *
 * <pre>
 * StringUtils.isAlphanumericSpace(null)   = false
 * StringUtils.isAlphanumericSpace("""")     = true
 * StringUtils.isAlphanumericSpace(""  "")   = true
 * StringUtils.isAlphanumericSpace(""abc"")  = true
 * StringUtils.isAlphanumericSpace(""ab c"") = true
 * StringUtils.isAlphanumericSpace(""ab2c"") = true
 * StringUtils.isAlphanumericSpace(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if only contains letters, digits or space,
 *  and is non-null
 * @since 3.0 Changed signature from isAlphanumericSpace(String) to isAlphanumericSpace(CharSequence)
 */"
"public static String join(Iterable<?> iterable, String separator) {
    if (iterable == null) {
        return null;
    }
    return join(iterable.iterator(), separator);
}","public void test135220() throws Throwable {
    StringUtils.abbreviateMiddle("""", """", 1);
    StringUtils.lastOrdinalIndexOf("""", """", 1);
    CharSequence[] charSequenceArray0 = new CharSequence[5];
    charSequenceArray0[0] = (CharSequence) """";
    charSequenceArray0[1] = (CharSequence) """";
    StringUtils.leftPad(""sw"", 0, 'm');
    charSequenceArray0[2] = (CharSequence) ""sw"";
    StringUtils.leftPad("""", (-1189), ""Minimum abbreviation width with offset is 7"");
    charSequenceArray0[3] = (CharSequence) """";
    charSequenceArray0[4] = (CharSequence) """";
    StringUtils.endsWithAny("""", charSequenceArray0);
    StringUtils.lastIndexOf(charSequenceArray0[0], charSequenceArray0[4]);
    StringUtils.replace("""", ""6KHD.,HZm"", ""s+"", 13);
    ArrayDeque<Locale.FilteringMode> arrayDeque0 = new ArrayDeque<Locale.FilteringMode>();
    ArrayDeque<Object> arrayDeque1 = new ArrayDeque<Object>(arrayDeque0);
    StringUtils.join((Iterable<?>) arrayDeque1, """");
}","/**
 * <p>Joins the elements of the provided {@code Iterable} into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A {@code null} separator is the same as an empty String ("""").</p>
 *
 * <p>See the examples here: {@link #join(Object[],String)}. </p>
 *
 * @param iterable  the {@code Iterable} providing the values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @return the joined String, {@code null} if null iterator input
 * @since 2.3
 */"
"public static int indexOf(CharSequence seq, CharSequence searchSeq, int startPos) {
    if (seq == null || searchSeq == null) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.indexOf(seq, searchSeq, startPos);
}","public void test136221() throws Throwable {
    StringUtils.center(""-];fP>%Q\""wi`},tQ(\"""", (-65));
    StringUtils.ordinalIndexOf(""-];fP>%Q\""wi`},tQ(\"""", ""-];fP>%Q\""wi`},tQ(\"""", (-2048));
    StringUtils.strip(""-];fP>%Q\""wi`},tQ(\"""", """");
    StringUtils.removeEnd("""", (String) null);
    StringUtils.lastIndexOfIgnoreCase((CharSequence) ""-];fP>%Q\""wi`},tQ(\"""", (CharSequence) """", 403);
    StringUtils.removeStart(""?7SyC"", ""rr[Y1jd lPy*oG !J-"");
    StringUtils.abbreviate((String) null, (-65), 0);
    StringUtils.rightPad(""0pbsJ!|@NBj"", 2, 'G');
    StringUtils.stripAccents(""?7SyC"");
    StringUtils.abbreviateMiddle("""", ""9C|)EX9==:<8p"", (-1194));
    StringUtils.isNumeric("""");
    StringUtils.rightPad("".3v\\\""!W>9oSuWt4.E\"""", 2);
    StringUtils.leftPad(""nJ,{a~-Y*_MZj0_bZ"", 16, """");
    StringUtils.indexOf((CharSequence) "".3v\\\""!W>9oSuWt4.E\"""", (CharSequence) ""nJ,{a~-Y*_MZj0_bZ"", (-65));
}","/**
 * <p>Finds the first index within a CharSequence, handling {@code null}.
 * This method uses {@link String#indexOf(String, int)} if possible.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A negative start position is treated as zero.
 * An empty ("""") search CharSequence always matches.
 * A start position greater than the string length only matches
 * an empty search CharSequence.</p>
 *
 * <pre>
 * StringUtils.indexOf(null, *, *)          = -1
 * StringUtils.indexOf(*, null, *)          = -1
 * StringUtils.indexOf("""", """", 0)           = 0
 * StringUtils.indexOf("""", *, 0)            = -1 (except when * = """")
 * StringUtils.indexOf(""aabaabaa"", ""a"", 0)  = 0
 * StringUtils.indexOf(""aabaabaa"", ""b"", 0)  = 2
 * StringUtils.indexOf(""aabaabaa"", ""ab"", 0) = 1
 * StringUtils.indexOf(""aabaabaa"", ""b"", 3)  = 5
 * StringUtils.indexOf(""aabaabaa"", ""b"", 9)  = -1
 * StringUtils.indexOf(""aabaabaa"", ""b"", -1) = 2
 * StringUtils.indexOf(""aabaabaa"", """", 2)   = 2
 * StringUtils.indexOf(""abc"", """", 9)        = 3
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchSeq  the CharSequence to find, may be null
 * @param startPos  the start position, negative treated as zero
 * @return the first index of the search CharSequence,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from indexOf(String, String, int) to indexOf(CharSequence, CharSequence, int)
 */"
"public static int lastIndexOf(CharSequence seq, int searchChar, int startPos) {
    if (isEmpty(seq)) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.lastIndexOf(seq, searchChar, startPos);
}","public void test137222() throws Throwable {
    StringUtils.defaultString("""");
    StringUtils.lastOrdinalIndexOf("""", """", 2465);
    StringUtils.isAsciiPrintable("""");
    StringUtils.repeat("""", 761);
    StringUtils.containsAny((CharSequence) """", (CharSequence) """");
    StringUtils.substringsBetween("""", ""|E%+8\""&BOe,Oc7N1"", """");
    StringUtils.normalizeSpace("" :"");
    StringUtils.splitPreserveAllTokens(""]cM[6O\""0"");
    StringUtils.indexOf((CharSequence) """", (CharSequence) "" :"");
    StringUtils.substringAfter("""", ""T*bzu`"");
    String string0 = StringUtils.rightPad("""", 2465, '\""');
    StringUtils.lastOrdinalIndexOf("""", string0, 2);
    StringUtils.isEmpty("""");
    StringUtils.repeat("""", ""GP$9z=eX{)"", 2);
    StringUtils.defaultString("""");
    StringUtils.lastIndexOfIgnoreCase((CharSequence) """", (CharSequence) ""]cM[6O\""0"", 0);
    StringUtils.normalizeSpace("""");
    StringUtils.isNumeric("""");
    StringUtils.splitByWholeSeparatorPreserveAllTokens("")`CW}\""`XV+fY@nl)"", ""Arguments cannot both be null"");
    StringUtils.removeEndIgnoreCase(""org.apache.commons.lang3.ArrayUtils"", "")`CW}\""`XV+fY@nl)"");
    StringUtils.lastIndexOf((CharSequence) ""|E%+8\""&BOe,Oc7N1"", (-1), (-1));
}","/**
 * <p>Finds the last index within a CharSequence from a start position,
 * handling {@code null}.
 * This method uses {@link String#lastIndexOf(int, int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("""") CharSequence will return {@code -1}.
 * A negative start position returns {@code -1}.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOf(null, *, *)          = -1
 * StringUtils.lastIndexOf("""", *,  *)           = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 8)  = 5
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 4)  = 2
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 0)  = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 9)  = 5
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', -1) = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'a', 0)  = 0
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @param startPos  the start position
 * @return the last index of the search character,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from lastIndexOf(String, int, int) to lastIndexOf(CharSequence, int, int)
 */"
"public static String stripEnd(String str, String stripChars) {
    int end;
    if (str == null || (end = str.length()) == 0) {
        return str;
    }
    if (stripChars == null) {
        while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) {
            end--;
        }
    } else if (stripChars.length() == 0) {
        return str;
    } else {
        while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) {
            end--;
        }
    }
    return str.substring(0, end);
}","public void test138223() throws Throwable {
    StringUtils.leftPad("""", 0, '*');
    StringUtils.equalsIgnoreCase("""", """");
    StringUtils.substringBefore("""", """");
    StringUtils.stripEnd("""", """");
}","/**
 * <p>Strips any of a set of characters from the end of a String.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * An empty string ("""") input returns the empty string.</p>
 *
 * <p>If the stripChars String is {@code null}, whitespace is
 * stripped as defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripEnd(null, *)          = null
 * StringUtils.stripEnd("""", *)            = """"
 * StringUtils.stripEnd(""abc"", """")        = ""abc""
 * StringUtils.stripEnd(""abc"", null)      = ""abc""
 * StringUtils.stripEnd(""  abc"", null)    = ""  abc""
 * StringUtils.stripEnd(""abc  "", null)    = ""abc""
 * StringUtils.stripEnd("" abc "", null)    = "" abc""
 * StringUtils.stripEnd(""  abcyx"", ""xyz"") = ""  abc""
 * StringUtils.stripEnd(""120.00"", "".0"")   = ""12""
 * </pre>
 *
 * @param str  the String to remove characters from, may be null
 * @param stripChars  the set of characters to remove, null treated as whitespace
 * @return the stripped String, {@code null} if null String input
 */"
"public static String join(Iterator<?> iterator, String separator) {
    // handle null, zero and one elements before building a buffer
    if (iterator == null) {
        return null;
    }
    if (!iterator.hasNext()) {
        return EMPTY;
    }
    Object first = iterator.next();
    if (!iterator.hasNext()) {
        return ObjectUtils.toString(first);
    }
    // two or more elements
    // Java default is 16, probably too small
    StringBuilder buf = new StringBuilder(256);
    if (first != null) {
        buf.append(first);
    }
    while (iterator.hasNext()) {
        if (separator != null) {
            buf.append(separator);
        }
        Object obj = iterator.next();
        if (obj != null) {
            buf.append(obj);
        }
    }
    return buf.toString();
}","public void test139224() throws Throwable {
    StringUtils.stripToNull(""k]BJ^]"");
    StringUtils.indexOf((CharSequence) ""k]BJ^]"", (CharSequence) ""k]BJ^]"");
    StringUtils.containsIgnoreCase(""k]BJ^]"", ""k]BJ^]"");
    StringUtils.difference("""", ""Threshold must not be negative"");
    StringUtils.trimToEmpty(""Threshold must not be negative"");
    StringUtils.indexOfIgnoreCase((CharSequence) """", (CharSequence) ""k]BJ^]"", 0);
    StringUtils.isEmpty(""k]BJ^]"");
    StringUtils.lastIndexOfIgnoreCase((CharSequence) ""k]BJ^]"", (CharSequence) ""Threshold must not be negative"", 0);
    CharSequence[] charSequenceArray0 = new CharSequence[8];
    charSequenceArray0[0] = (CharSequence) ""Threshold must not be negative"";
    charSequenceArray0[1] = (CharSequence) ""Threshold must not be negative"";
    charSequenceArray0[2] = (CharSequence) """";
    charSequenceArray0[3] = (CharSequence) ""Threshold must not be negative"";
    charSequenceArray0[4] = (CharSequence) ""Threshold must not be negative"";
    charSequenceArray0[5] = (CharSequence) ""k]BJ^]"";
    charSequenceArray0[6] = (CharSequence) ""k]BJ^]"";
    charSequenceArray0[7] = (CharSequence) ""Threshold must not be negative"";
    StringUtils.lastIndexOfAny(""k]BJ^]"", charSequenceArray0);
    StringUtils.isNumeric(charSequenceArray0[7]);
    LinkedList<Integer> linkedList0 = new LinkedList<Integer>();
    Iterator<Integer> iterator0 = linkedList0.iterator();
    StringUtils.join(iterator0, ""java.text.Normalizer$Form"");
}","/**
 * <p>Joins the elements of the provided {@code Iterator} into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A {@code null} separator is the same as an empty String ("""").</p>
 *
 * <p>See the examples here: {@link #join(Object[],String)}. </p>
 *
 * @param iterator  the {@code Iterator} of values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @return the joined String, {@code null} if null iterator input
 */"
"public static String[] splitByCharacterType(String str) {
    return splitByCharacterType(str, false);
}","public void test140225() throws Throwable {
    StringUtils.substringBeforeLast("""", """");
    char[] charArray0 = new char[8];
    charArray0[0] = 'C';
    charArray0[1] = '7';
    charArray0[2] = 'f';
    charArray0[3] = '>';
    charArray0[4] = '(';
    charArray0[5] = 'i';
    charArray0[6] = 'D';
    charArray0[7] = 'w';
    StringUtils.containsOnly((CharSequence) """", charArray0);
    StringUtils.substring("""", (-1897));
    StringUtils.splitByCharacterType(""&@6vCImMkmCJ9H5y"");
}","/**
 * <p>Splits a String by Character type as returned by
 * {@code java.lang.Character.getType(char)}. Groups of contiguous
 * characters of the same type are returned as complete tokens.
 * <pre>
 * StringUtils.splitByCharacterType(null)         = null
 * StringUtils.splitByCharacterType("""")           = []
 * StringUtils.splitByCharacterType(""ab de fg"")   = [""ab"", "" "", ""de"", "" "", ""fg""]
 * StringUtils.splitByCharacterType(""ab   de fg"") = [""ab"", ""   "", ""de"", "" "", ""fg""]
 * StringUtils.splitByCharacterType(""ab:cd:ef"")   = [""ab"", "":"", ""cd"", "":"", ""ef""]
 * StringUtils.splitByCharacterType(""number5"")    = [""number"", ""5""]
 * StringUtils.splitByCharacterType(""fooBar"")     = [""foo"", ""B"", ""ar""]
 * StringUtils.splitByCharacterType(""foo200Bar"")  = [""foo"", ""200"", ""B"", ""ar""]
 * StringUtils.splitByCharacterType(""ASFRules"")   = [""ASFR"", ""ules""]
 * </pre>
 * @param str the String to split, may be {@code null}
 * @return an array of parsed Strings, {@code null} if null String input
 * @since 2.4
 */"
"public static String[] stripAll(String[] strs, String stripChars) {
    int strsLen;
    if (strs == null || (strsLen = strs.length) == 0) {
        return strs;
    }
    String[] newArr = new String[strsLen];
    for (int i = 0; i < strsLen; i++) {
        newArr[i] = strip(strs[i], stripChars);
    }
    return newArr;
}","public void test142227() throws Throwable {
    StringUtils.join((Object[]) null, ""[CRf]nwH"", (-3384), 13);
    StringUtils.lastIndexOf((CharSequence) null, (CharSequence) null);
    StringUtils.defaultIfBlank((String) null, ""[CRf]nwH"");
    StringUtils.rightPad(""[CRf]nwH"", 57, 'D');
    StringUtils.containsIgnoreCase((CharSequence) null, ""[CRf]nwHDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD"");
    StringUtils.endsWithIgnoreCase(""[CRf]nwHDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD"", (CharSequence) null);
    StringUtils.stripStart((String) null, (String) null);
    PriorityQueue<String> priorityQueue0 = new PriorityQueue<String>();
    Iterator<String> iterator0 = priorityQueue0.iterator();
    StringUtils.join(iterator0, 'j');
    Locale locale0 = Locale.FRENCH;
    StringUtils.lowerCase(""z?zU%7>st9[Gk^A|'"", locale0);
    StringUtils.substringBefore((String) null, ""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"");
    StringUtils.removeEndIgnoreCase(""_@"", ""fZ))ZZi24e!K,wLtK<I"");
    StringUtils.stripAll((String[]) null, ""7^4?[zbfro[(BZ7[J@="");
}","/**
 * <p>Strips any of a set of characters from the start and end of every
 * String in an array.</p>
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <p>A new array is returned each time, except for length zero.
 * A {@code null} array will return {@code null}.
 * An empty array will return itself.
 * A {@code null} array entry will be ignored.
 * A {@code null} stripChars will strip whitespace as defined by
 * {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripAll(null, *)                = null
 * StringUtils.stripAll([], *)                  = []
 * StringUtils.stripAll([""abc"", ""  abc""], null) = [""abc"", ""abc""]
 * StringUtils.stripAll([""abc  "", null], null)  = [""abc"", null]
 * StringUtils.stripAll([""abc  "", null], ""yz"")  = [""abc  "", null]
 * StringUtils.stripAll([""yabcz"", null], ""yz"")  = [""abc"", null]
 * </pre>
 *
 * @param strs  the array to remove characters from, may be null
 * @param stripChars  the characters to remove, null treated as whitespace
 * @return the stripped Strings, {@code null} if null array input
 */"
"public static boolean contains(CharSequence seq, CharSequence searchSeq) {
    if (seq == null || searchSeq == null) {
        return false;
    }
    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;
}","public void test143228() throws Throwable {
    StringUtils.removeEndIgnoreCase(""ixc)q*qbxxm"", ""ixc)q*qbxxm"");
    StringUtils.contains((CharSequence) """", (CharSequence) ""ixc)q*qbxxm"");
}","/**
 * <p>Checks if CharSequence contains a search CharSequence, handling {@code null}.
 * This method uses {@link String#indexOf(String)} if possible.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.contains(null, *)     = false
 * StringUtils.contains(*, null)     = false
 * StringUtils.contains("""", """")      = true
 * StringUtils.contains(""abc"", """")   = true
 * StringUtils.contains(""abc"", ""a"")  = true
 * StringUtils.contains(""abc"", ""z"")  = false
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchSeq  the CharSequence to find, may be null
 * @return true if the CharSequence contains the search CharSequence,
 *  false if not or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from contains(String, String) to contains(CharSequence, CharSequence)
 */"
"public static String abbreviate(String str, int offset, int maxWidth) {
    if (str == null) {
        return null;
    }
    if (maxWidth < 4) {
        throw new IllegalArgumentException(""Minimum abbreviation width is 4"");
    }
    if (str.length() <= maxWidth) {
        return str;
    }
    if (offset > str.length()) {
        offset = str.length();
    }
    if ((str.length() - offset) < (maxWidth - 3)) {
        offset = str.length() - (maxWidth - 3);
    }
    final String abrevMarker = ""..."";
    if (offset <= 4) {
        return str.substring(0, maxWidth - 3) + abrevMarker;
    }
    if (maxWidth < 7) {
        throw new IllegalArgumentException(""Minimum abbreviation width with offset is 7"");
    }
    if ((offset + (maxWidth - 3)) < str.length()) {
        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);
    }
    return abrevMarker + str.substring(str.length() - (maxWidth - 3));
}","public void test144229() throws Throwable {
    String string0 = ""nhHYnbZ]a0&$2C"";
    StringUtils.splitPreserveAllTokens(""nhHYnbZ]a0&$2C"", ""nhHYnbZ]a0&$2C"", 122);
    StringUtils.right((String) null, 122);
    String string1 = ""CYl\\6d"";
    StringUtils.leftPad(""CYl\u0006d"", 122);
    // Undeclared exception!
    try {
        StringUtils.abbreviate(""nhHYnbZ]a0&$2C"", 122, 5);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Minimum abbreviation width with offset is 7
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}","/**
 * <p>Abbreviates a String using ellipses. This will turn
 * ""Now is the time for all good men"" into ""...is the time for...""</p>
 *
 * <p>Works like {@code abbreviate(String, int)}, but allows you to specify
 * a ""left edge"" offset.  Note that this left edge is not necessarily going to
 * be the leftmost character in the result, or the first character following the
 * ellipses, but it will appear somewhere in the result.
 *
 * <p>In no case will it return a String of length greater than
 * {@code maxWidth}.</p>
 *
 * <pre>
 * StringUtils.abbreviate(null, *, *)                = null
 * StringUtils.abbreviate("""", 0, 4)                  = """"
 * StringUtils.abbreviate(""abcdefghijklmno"", -1, 10) = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 0, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 1, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 4, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 5, 10)  = ""...fghi...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 6, 10)  = ""...ghij...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 8, 10)  = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghijklmno"", 10, 10) = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghijklmno"", 12, 10) = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghij"", 0, 3)        = IllegalArgumentException
 * StringUtils.abbreviate(""abcdefghij"", 5, 6)        = IllegalArgumentException
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param offset  left edge of source String
 * @param maxWidth  maximum length of result String, must be at least 4
 * @return abbreviated String, {@code null} if null String input
 * @throws IllegalArgumentException if the width is too small
 * @since 2.0
 */"
"// -----------------------------------------------------------------------
/**
 * <p>Splits the provided text into an array, using whitespace as the
 * separator, preserving all tokens, including empty tokens created by
 * adjacent separators. This is an alternative to using StringTokenizer.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as separators for empty tokens.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.splitPreserveAllTokens(null)       = null
 * StringUtils.splitPreserveAllTokens("""")         = []
 * StringUtils.splitPreserveAllTokens(""abc def"")  = [""abc"", ""def""]
 * StringUtils.splitPreserveAllTokens(""abc  def"") = [""abc"", """", ""def""]
 * StringUtils.splitPreserveAllTokens("" abc "")    = ["""", ""abc"", """"]
 * </pre>
 *
 * @param str  the String to parse, may be {@code null}
 * @return an array of parsed Strings, {@code null} if null String input
 * @since 2.1
 */
public static String[] splitPreserveAllTokens(String str) {
    return splitWorker(str, null, -1, true);
}","public void test145230() throws Throwable {
    StringUtils.right(""=EYOsiWJH!+$"", 25);
    StringUtils.isAlpha(""=EYOsiWJH!+$"");
    StringUtils.chomp((String) null);
    StringUtils.endsWith((CharSequence) null, (CharSequence) null);
    StringUtils.repeat("".=}*p8Q|L}s"", """", 25);
    StringUtils.chomp(""=EYOsiWJH!+$"", ""NFD"");
    StringUtils.replaceChars("".=}*p8Q|L}s"", '`', 'g');
    StringUtils.endsWithAny("".=}*p8Q|L}s.=}*p8Q|L}s.=}*p8Q|L}s.=}*p8Q|L}s.=}*p8Q|L}s.=}*p8Q|L}s.=}*p8Q|L}s.=}*p8Q|L}s.=}*p8Q|L}s.=}*p8Q|L}s.=}*p8Q|L}s.=}*p8Q|L}s.=}*p8Q|L}s.=}*p8Q|L}s.=}*p8Q|L}s.=}*p8Q|L}s.=}*p8Q|L}s.=}*p8Q|L}s.=}*p8Q|L}s.=}*p8Q|L}s.=}*p8Q|L}s.=}*p8Q|L}s.=}*p8Q|L}s.=}*p8Q|L}s.=}*p8Q|L}s"", (CharSequence[]) null);
    StringUtils.repeat(""NFD"", 25);
    StringUtils.replaceChars((String) null, ""0u[CgnQa8"", (String) null);
    StringUtils.splitPreserveAllTokens((String) null);
}",""
"public static int indexOfDifference(CharSequence cs1, CharSequence cs2) {
    if (cs1 == cs2) {
        return INDEX_NOT_FOUND;
    }
    if (cs1 == null || cs2 == null) {
        return 0;
    }
    int i;
    for (i = 0; i < cs1.length() && i < cs2.length(); ++i) {
        if (cs1.charAt(i) != cs2.charAt(i)) {
            break;
        }
    }
    if (i < cs2.length() || i < cs1.length()) {
        return i;
    }
    return INDEX_NOT_FOUND;
}","public void test146231() throws Throwable {
    Locale locale0 = Locale.forLanguageTag(""\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000B\f\r\u000E\u000F\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001A\u001B\u001C\u001D\u001E\u001F !\""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}~"");
    locale0.getDisplayLanguage();
    ArrayList<Locale.LanguageRange> arrayList0 = new ArrayList<Locale.LanguageRange>();
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    ArrayList<Locale> arrayList1 = new ArrayList<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) arrayList1);
    Locale.filter((List<Locale.LanguageRange>) arrayList0, (Collection<Locale>) list0);
    StringUtils.lowerCase(""\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000B\f\r\u000E\u000F\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001A\u001B\u001C\u001D\u001E\u001F !\""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}~"", locale0);
    StringUtils.indexOfDifference((CharSequence) ""\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000B\f\r\u000E\u000F\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001A\u001B\u001C\u001D\u001E\u001F !\""#$%&'()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[]^_`abcdefghijklmnopqrstuvwxyz{|}~"", (CharSequence) ""\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000B\f\r\u000E\u000F\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001A\u001B\u001C\u001D\u001E\u001F !\""#$%&'()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[]^_`abcdefghijklmnopqrstuvwxyz{|}~"");
    StringUtils.stripStart(""-b2P,obr"", ""Mb@9WZhldeAMN"");
    StringUtils.left(""G*ZRtmsqI"", 97);
    String[] stringArray0 = new String[0];
    StringUtils.replaceEachRepeatedly((String) null, stringArray0, stringArray0);
    StringUtils.indexOfDifference((CharSequence) ""Mb@9WZhldeAMN"", (CharSequence) null);
}","/**
 * <p>Compares two CharSequences, and returns the index at which the
 * CharSequences begin to differ.</p>
 *
 * <p>For example,
 * {@code indexOfDifference(""i am a machine"", ""i am a robot"") -> 7}</p>
 *
 * <pre>
 * StringUtils.indexOfDifference(null, null) = -1
 * StringUtils.indexOfDifference("""", """") = -1
 * StringUtils.indexOfDifference("""", ""abc"") = 0
 * StringUtils.indexOfDifference(""abc"", """") = 0
 * StringUtils.indexOfDifference(""abc"", ""abc"") = -1
 * StringUtils.indexOfDifference(""ab"", ""abxyz"") = 2
 * StringUtils.indexOfDifference(""abcde"", ""abxyz"") = 2
 * StringUtils.indexOfDifference(""abcde"", ""xyz"") = 0
 * </pre>
 *
 * @param cs1  the first CharSequence, may be null
 * @param cs2  the second CharSequence, may be null
 * @return the index where cs1 and cs2 begin to differ; -1 if they are equal
 * @since 2.0
 * @since 3.0 Changed signature from indexOfDifference(String, String) to
 * indexOfDifference(CharSequence, CharSequence)
 */"
"public static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr, int startPos) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    if (startPos > (str.length() - searchStr.length())) {
        startPos = str.length() - searchStr.length();
    }
    if (startPos < 0) {
        return INDEX_NOT_FOUND;
    }
    if (searchStr.length() == 0) {
        return startPos;
    }
    for (int i = startPos; i >= 0; i--) {
        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test147232() throws Throwable {
    StringUtils.stripEnd((String) null, ""XH:g:50>"");
    StringUtils.contains((CharSequence) null, (CharSequence) ""XH:g:50>"");
    StringUtils.indexOfAnyBut((CharSequence) null, (CharSequence) null);
    CharSequence[] charSequenceArray0 = new CharSequence[9];
    charSequenceArray0[0] = (CharSequence) null;
    StringUtils.mid((String) null, (-1), 0);
    charSequenceArray0[1] = (CharSequence) null;
    charSequenceArray0[2] = (CharSequence) null;
    ArrayDeque<String> arrayDeque0 = new ArrayDeque<String>(0);
    StringUtils.join((Iterable<?>) arrayDeque0, '?');
    charSequenceArray0[3] = (CharSequence) """";
    StringUtils.defaultIfBlank((CharSequence) """", (CharSequence) ""XH:g:50>"");
    charSequenceArray0[4] = (CharSequence) ""XH:g:50>"";
    charSequenceArray0[5] = (CharSequence) ""XH:g:50>"";
    charSequenceArray0[6] = (CharSequence) ""XH:g:50>"";
    charSequenceArray0[7] = (CharSequence) ""XH:g:50>"";
    charSequenceArray0[8] = (CharSequence) ""XH:g:50>"";
    StringUtils.endsWithAny((CharSequence) null, charSequenceArray0);
    StringUtils.lastIndexOfIgnoreCase((CharSequence) """", charSequenceArray0[4], (-1509));
}","/**
 * <p>Case in-sensitive find of the last index within a CharSequence
 * from the specified position.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A negative start position returns {@code -1}.
 * An empty ("""") search CharSequence always matches unless the start position is negative.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOfIgnoreCase(null, *, *)          = -1
 * StringUtils.lastIndexOfIgnoreCase(*, null, *)          = -1
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""A"", 8)  = 7
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"", 8)  = 5
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""AB"", 8) = 4
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"", 9)  = 5
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"", -1) = -1
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""A"", 0)  = 0
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"", 0)  = -1
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @param startPos  the start position
 * @return the first index of the search CharSequence,
 *  -1 if no match or {@code null} input
 * @since 2.5
 * @since 3.0 Changed signature from lastIndexOfIgnoreCase(String, String, int) to lastIndexOfIgnoreCase(CharSequence, CharSequence, int)
 */"
"public static String replace(String text, String searchString, String replacement) {
    return replace(text, searchString, replacement, -1);
}","public void test148233() throws Throwable {
    StringUtils.left("""", (-902));
    StringUtils.lastIndexOf((CharSequence) """", (CharSequence) """");
    StringUtils.substring("""", (-1056));
    StringUtils.replaceChars(""#\""3?[$zY"", 'Z', 'F');
    StringUtils.splitPreserveAllTokens(""eD^]z-_`pqy>k-&"", 'F');
    StringUtils.replace((String) null, """", """");
}","/**
 * <p>Replaces all occurrences of a String within another String.</p>
 *
 * <p>A {@code null} reference passed to this method is a no-op.</p>
 *
 * <pre>
 * StringUtils.replace(null, *, *)        = null
 * StringUtils.replace("""", *, *)          = """"
 * StringUtils.replace(""any"", null, *)    = ""any""
 * StringUtils.replace(""any"", *, null)    = ""any""
 * StringUtils.replace(""any"", """", *)      = ""any""
 * StringUtils.replace(""aba"", ""a"", null)  = ""aba""
 * StringUtils.replace(""aba"", ""a"", """")    = ""b""
 * StringUtils.replace(""aba"", ""a"", ""z"")   = ""zbz""
 * </pre>
 *
 * @see #replace(String text, String searchString, String replacement, int max)
 * @param text  text to search and replace in, may be null
 * @param searchString  the String to search for, may be null
 * @param replacement  the String to replace it with, may be null
 * @return the text with any replacements processed,
 *  {@code null} if null String input
 */"
"public static String uncapitalize(String str) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    return new StringBuilder(strLen).append(Character.toLowerCase(str.charAt(0))).append(str.substring(1)).toString();
}","public void test149234() throws Throwable {
    Locale locale0 = Locale.ITALIAN;
    StringUtils.upperCase(""Array element "", locale0);
    locale0.getDisplayScript();
    CharBuffer charBuffer0 = CharBuffer.wrap((CharSequence) ""ARRAY ELEMENT "");
    StringUtils.indexOfIgnoreCase((CharSequence) charBuffer0, (CharSequence) ""Array element "");
    charBuffer0.asReadOnlyBuffer();
    locale0.getDisplayLanguage();
    StringUtils.indexOfIgnoreCase((CharSequence) charBuffer0, (CharSequence) ""ARRAY ELEMENT "", 10);
    StringUtils.uncapitalize(""ARRAY ELEMENT "");
}","/**
 * <p>Uncapitalizes a String changing the first letter to title case as
 * per {@link Character#toLowerCase(char)}. No other letters are changed.</p>
 *
 * <p>For a word based algorithm, see {@link org.apache.commons.lang3.text.WordUtils#uncapitalize(String)}.
 * A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.uncapitalize(null)  = null
 * StringUtils.uncapitalize("""")    = """"
 * StringUtils.uncapitalize(""Cat"") = ""cat""
 * StringUtils.uncapitalize(""CAT"") = ""cAT""
 * </pre>
 *
 * @param str the String to uncapitalize, may be null
 * @return the uncapitalized String, {@code null} if null String input
 * @see org.apache.commons.lang3.text.WordUtils#uncapitalize(String)
 * @see #capitalize(String)
 * @since 2.0
 */"
"// Abbreviating
//-----------------------------------------------------------------------
/**
 * <p>Abbreviates a String using ellipses. This will turn
 * ""Now is the time for all good men"" into ""Now is the time for...""</p>
 *
 * <p>Specifically:
 * <ul>
 *   <li>If {@code str} is less than {@code maxWidth} characters
 *       long, return it.</li>
 *   <li>Else abbreviate it to {@code (substring(str, 0, max-3) + ""..."")}.</li>
 *   <li>If {@code maxWidth} is less than {@code 4}, throw an
 *       {@code IllegalArgumentException}.</li>
 *   <li>In no case will it return a String of length greater than
 *       {@code maxWidth}.</li>
 * </ul>
 * </p>
 *
 * <pre>
 * StringUtils.abbreviate(null, *)      = null
 * StringUtils.abbreviate("""", 4)        = """"
 * StringUtils.abbreviate(""abcdefg"", 6) = ""abc...""
 * StringUtils.abbreviate(""abcdefg"", 7) = ""abcdefg""
 * StringUtils.abbreviate(""abcdefg"", 8) = ""abcdefg""
 * StringUtils.abbreviate(""abcdefg"", 4) = ""a...""
 * StringUtils.abbreviate(""abcdefg"", 3) = IllegalArgumentException
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param maxWidth  maximum length of result String, must be at least 4
 * @return abbreviated String, {@code null} if null String input
 * @throws IllegalArgumentException if the width is too small
 * @since 2.0
 */
public static String abbreviate(String str, int maxWidth) {
    return abbreviate(str, 0, maxWidth);
}","public void test150235() throws Throwable {
    StringUtils.removeEnd("""", """");
    StringUtils.getLevenshteinDistance((CharSequence) """", (CharSequence) """");
    StringUtils.lastIndexOf((CharSequence) """", (CharSequence) """");
    StringUtils.contains((CharSequence) """", (CharSequence) """");
    Stack<Integer> stack0 = new Stack<Integer>();
    ListIterator<Integer> listIterator0 = stack0.listIterator();
    StringUtils.join((Iterator<?>) listIterator0, """");
    StringUtils.contains((CharSequence) """", (CharSequence) """");
    stack0.remove((Object) """");
    StringUtils.substringBeforeLast(""qR(\""\""xJ[{-\""WNmYS($&"", ""qR(\""\""xJ[{-\""WNmYS($&"");
    StringUtils.defaultIfEmpty(""@yW"", """");
    String[] stringArray0 = StringUtils.split("""", 'd');
    StringUtils.removeEnd("""", ""BCh38!/"");
    Object[] objectArray0 = new Object[4];
    objectArray0[0] = (Object) ""qR(\""\""xJ[{-\""WNmYS($&"";
    objectArray0[1] = (Object) """";
    objectArray0[2] = (Object) ""@yW"";
    objectArray0[3] = (Object) listIterator0;
    StringUtils.join(objectArray0, 'd');
    StringUtils.substringsBetween("""", ""@yW"", (String) null);
    StringUtils.chop(""BCh38!/"");
    StringUtils.splitByWholeSeparator(""lG_>58Z/gY{c"", "") "", 0);
    StringUtils.right((String) null, 1755);
    StringUtils.getCommonPrefix(stringArray0);
    StringUtils.isAlpha(""@yW"");
    // Undeclared exception!
    try {
        StringUtils.abbreviate(""9(GQMW*:PsQsP|6F"", (-507));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Minimum abbreviation width is 4
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}",""
"// Abbreviating
//-----------------------------------------------------------------------
/**
 * <p>Abbreviates a String using ellipses. This will turn
 * ""Now is the time for all good men"" into ""Now is the time for...""</p>
 *
 * <p>Specifically:
 * <ul>
 *   <li>If {@code str} is less than {@code maxWidth} characters
 *       long, return it.</li>
 *   <li>Else abbreviate it to {@code (substring(str, 0, max-3) + ""..."")}.</li>
 *   <li>If {@code maxWidth} is less than {@code 4}, throw an
 *       {@code IllegalArgumentException}.</li>
 *   <li>In no case will it return a String of length greater than
 *       {@code maxWidth}.</li>
 * </ul>
 * </p>
 *
 * <pre>
 * StringUtils.abbreviate(null, *)      = null
 * StringUtils.abbreviate("""", 4)        = """"
 * StringUtils.abbreviate(""abcdefg"", 6) = ""abc...""
 * StringUtils.abbreviate(""abcdefg"", 7) = ""abcdefg""
 * StringUtils.abbreviate(""abcdefg"", 8) = ""abcdefg""
 * StringUtils.abbreviate(""abcdefg"", 4) = ""a...""
 * StringUtils.abbreviate(""abcdefg"", 3) = IllegalArgumentException
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param maxWidth  maximum length of result String, must be at least 4
 * @return abbreviated String, {@code null} if null String input
 * @throws IllegalArgumentException if the width is too small
 * @since 2.0
 */
public static String abbreviate(String str, int maxWidth) {
    return abbreviate(str, 0, maxWidth);
}","public void test151236() throws Throwable {
    String string0 = "").[{ZNK<um?WiQ[D=n"";
    StringUtils.substringBeforeLast("").[{ZNK<um?WiQ[D=n"", "").[{ZNK<um?WiQ[D=n"");
    String string1 = ""aT|;,(1Z"";
    int int0 = 0;
    StringUtils.splitByWholeSeparator(""aT|;,(1Z"", """", 0);
    // Undeclared exception!
    try {
        StringUtils.abbreviate("").[{ZNK<um?WiQ[D=n"", 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Minimum abbreviation width is 4
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}",""
"// IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the first index within a CharSequence, handling {@code null}.
 * This method uses {@link String#indexOf(int, int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("""") CharSequence will return {@code INDEX_NOT_FOUND (-1)}.</p>
 *
 * <pre>
 * StringUtils.indexOf(null, *)         = -1
 * StringUtils.indexOf("""", *)           = -1
 * StringUtils.indexOf(""aabaabaa"", 'a') = 0
 * StringUtils.indexOf(""aabaabaa"", 'b') = 2
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @return the first index of the search character,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from indexOf(String, int) to indexOf(CharSequence, int)
 */
public static int indexOf(CharSequence seq, int searchChar) {
    if (isEmpty(seq)) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.indexOf(seq, searchChar, 0);
}","public void test152237() throws Throwable {
    StringUtils.reverseDelimited(""{}"", '`');
    StringUtils.chomp(""{}"", ""{}"");
    StringUtils.substringBeforeLast(""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"", ""{}"");
    StringUtils.upperCase(""org.apache.commons.lang3.CharUtils"");
    StringUtils.isWhitespace(""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"");
    StringUtils.indexOf((CharSequence) ""ORG.APACHE.COMMONS.LANG3.CHARUTILS"", 0);
}",""
"public static int lastIndexOfAny(CharSequence str, CharSequence... searchStrs) {
    if (str == null || searchStrs == null) {
        return INDEX_NOT_FOUND;
    }
    int sz = searchStrs.length;
    int ret = INDEX_NOT_FOUND;
    int tmp = 0;
    for (int i = 0; i < sz; i++) {
        CharSequence search = searchStrs[i];
        if (search == null) {
            continue;
        }
        tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());
        if (tmp > ret) {
            ret = tmp;
        }
    }
    return ret;
}","public void test153238() throws Throwable {
    StringUtils.chomp("""");
    StringUtils.isAlphanumericSpace("""");
    StringUtils stringUtils0 = new StringUtils();
    StringUtils.lastIndexOf((CharSequence) """", 128);
    StringUtils.leftPad("""", 0, 'd');
    StringUtils.capitalize("""");
    StringUtils.stripAccents((String) null);
    StringUtils.repeat("""", (-1));
    StringUtils.isWhitespace("""");
    String[] stringArray0 = new String[8];
    stringArray0[0] = """";
    stringArray0[1] = null;
    stringArray0[2] = """";
    stringArray0[3] = null;
    StringUtils.lastOrdinalIndexOf("""", """", (-1));
    stringArray0[4] = """";
    stringArray0[5] = """";
    stringArray0[6] = null;
    stringArray0[7] = ""Arguments cannot both be null"";
    StringUtils.getCommonPrefix(stringArray0);
    StringUtils.stripStart(""org.apache.commons.lang3.StringUtils"", """");
    StringUtils.stripEnd(""org.apache.commons.lang3.StringUtils"", ""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"");
    StringUtils.lastIndexOfAny("""", stringArray0);
}","/**
 * <p>Find the latest index of any of a set of potential substrings.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A {@code null} search array will return {@code -1}.
 * A {@code null} or zero length search array entry will be ignored,
 * but a search array containing """" will return the length of {@code str}
 * if {@code str} is not null. This method uses {@link String#indexOf(String)} if possible</p>
 *
 * <pre>
 * StringUtils.lastIndexOfAny(null, *)                   = -1
 * StringUtils.lastIndexOfAny(*, null)                   = -1
 * StringUtils.lastIndexOfAny(*, [])                     = -1
 * StringUtils.lastIndexOfAny(*, [null])                 = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""ab"",""cd""]) = 6
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""cd"",""ab""]) = 6
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""op""]) = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""op""]) = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""""])   = 10
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStrs  the CharSequences to search for, may be null
 * @return the last index of any of the CharSequences, -1 if no match
 * @since 3.0 Changed signature from lastIndexOfAny(String, String[]) to lastIndexOfAny(CharSequence, CharSequence)
 */"
"public static String join(Iterator<?> iterator, String separator) {
    // handle null, zero and one elements before building a buffer
    if (iterator == null) {
        return null;
    }
    if (!iterator.hasNext()) {
        return EMPTY;
    }
    Object first = iterator.next();
    if (!iterator.hasNext()) {
        return ObjectUtils.toString(first);
    }
    // two or more elements
    // Java default is 16, probably too small
    StringBuilder buf = new StringBuilder(256);
    if (first != null) {
        buf.append(first);
    }
    while (iterator.hasNext()) {
        if (separator != null) {
            buf.append(separator);
        }
        Object obj = iterator.next();
        if (obj != null) {
            buf.append(obj);
        }
    }
    return buf.toString();
}","public void test154239() throws Throwable {
    ArrayList<Object> arrayList0 = new ArrayList<Object>();
    Iterator<Object> iterator0 = arrayList0.iterator();
    Integer integer0 = new Integer((-1067));
    arrayList0.add((Object) integer0);
    // Undeclared exception!
    try {
        StringUtils.join(iterator0, ""', has a length less than 2"");
        fail(""Expecting exception: ConcurrentModificationException"");
    } catch (ConcurrentModificationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.ArrayList$Itr"", e);
    }
}","/**
 * <p>Joins the elements of the provided {@code Iterator} into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A {@code null} separator is the same as an empty String ("""").</p>
 *
 * <p>See the examples here: {@link #join(Object[],String)}. </p>
 *
 * @param iterator  the {@code Iterator} of values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @return the joined String, {@code null} if null iterator input
 */"
"// Left/Right/Mid
//-----------------------------------------------------------------------
/**
 * <p>Gets the leftmost {@code len} characters of a String.</p>
 *
 * <p>If {@code len} characters are not available, or the
 * String is {@code null}, the String will be returned without
 * an exception. An empty String is returned if len is negative.</p>
 *
 * <pre>
 * StringUtils.left(null, *)    = null
 * StringUtils.left(*, -ve)     = """"
 * StringUtils.left("""", *)      = """"
 * StringUtils.left(""abc"", 0)   = """"
 * StringUtils.left(""abc"", 2)   = ""ab""
 * StringUtils.left(""abc"", 4)   = ""abc""
 * </pre>
 *
 * @param str  the String to get the leftmost characters from, may be null
 * @param len  the length of the required String
 * @return the leftmost characters, {@code null} if null String input
 */
public static String left(String str, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0) {
        return EMPTY;
    }
    if (str.length() <= len) {
        return str;
    }
    return str.substring(0, len);
}","public void test155240() throws Throwable {
    String string0 = StringUtils.center("""", 2673);
    StringUtils.lastIndexOf((CharSequence) string0, (CharSequence) """");
    StringUtils.upperCase("""");
    StringUtils.leftPad((String) null, 2673, ""The String must not be empty"");
    StringUtils.indexOfDifference((CharSequence) """", (CharSequence) """");
    char[] charArray0 = new char[2];
    charArray0[0] = '[';
    charArray0[1] = 'c';
    StringUtils.containsOnly((CharSequence) null, charArray0);
    StringUtils.lastIndexOf((CharSequence) """", 0, (-1));
    StringUtils.indexOf((CharSequence) """", (CharSequence) null, (-1));
    StringUtils.left("""", 1183);
}",""
"public static boolean endsWithIgnoreCase(CharSequence str, CharSequence suffix) {
    return endsWith(str, suffix, true);
}","public void test157242() throws Throwable {
    StringUtils.splitByCharacterTypeCamelCase("""");
    StringUtils.repeat("""", (-1573));
    StringUtils.leftPad(""', is neither of type Map.Entry nor an Array"", (-1573), ""s+"");
    StringUtils.trim(""', is neither of type Map.Entry nor an Array"");
    StringUtils.split(""{yi:-5s'("", ""HW-"");
    StringUtils.lastIndexOf((CharSequence) ""', is neither of type Map.Entry nor an Array"", (CharSequence) ""s+"");
    StringUtils.endsWithIgnoreCase((CharSequence) null, ""{yi:-5s'("");
}","/**
 * <p>Case insensitive check if a CharSequence ends with a specified suffix.</p>
 *
 * <p>{@code null}s are handled without exceptions. Two {@code null}
 * references are considered to be equal. The comparison is case insensitive.</p>
 *
 * <pre>
 * StringUtils.endsWithIgnoreCase(null, null)      = true
 * StringUtils.endsWithIgnoreCase(null, ""def"")     = false
 * StringUtils.endsWithIgnoreCase(""abcdef"", null)  = false
 * StringUtils.endsWithIgnoreCase(""abcdef"", ""def"") = true
 * StringUtils.endsWithIgnoreCase(""ABCDEF"", ""def"") = true
 * StringUtils.endsWithIgnoreCase(""ABCDEF"", ""cde"") = false
 * </pre>
 *
 * @see java.lang.String#endsWith(String)
 * @param str  the CharSequence to check, may be null
 * @param suffix the suffix to find, may be null
 * @return {@code true} if the CharSequence ends with the suffix, case insensitive, or
 *  both {@code null}
 * @since 2.4
 * @since 3.0 Changed signature from endsWithIgnoreCase(String, String) to endsWithIgnoreCase(CharSequence, CharSequence)
 */"
"public static boolean contains(CharSequence seq, CharSequence searchSeq) {
    if (seq == null || searchSeq == null) {
        return false;
    }
    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;
}","public void test158243() throws Throwable {
    StringUtils.substring(""2`.ld{S:SW24d+!"", 0);
    StringUtils.defaultString(""2`.ld{S:SW24d+!"", "" is not in the range '0' - '9'"");
    StringUtils.reverseDelimited(""2`.ld{S:SW24d+!"", 'N');
    StringUtils.lastIndexOf((CharSequence) ""2`.ld{S:SW24d+!"", (CharSequence) ""2`.ld{S:SW24d+!"", 0);
    StringUtils.normalizeSpace("""");
    Object object0 = new Object();
    String[] stringArray0 = StringUtils.split(""2`.ld{S:SW24d+!"", 'N');
    String[] stringArray1 = StringUtils.splitByWholeSeparator("""", """", 0);
    String[] stringArray2 = StringUtils.splitByWholeSeparator(""2`.ld{S:SW24d+!"", ""2`.ld{S:SW24d+!"", 0);
    StringUtils.isNumeric(""2`.ld{S:SW24d+!"");
    StringUtils.normalizeSpace(""!;mvFXBBE*jjl[oJ94w"");
    StringUtils.indexOfAny((CharSequence) """", (CharSequence[]) stringArray1);
    StringUtils.replaceEachRepeatedly(""?S5rhV{"", stringArray0, stringArray2);
    StringUtils.startsWith(""2`.ld{S:SW24d+!"", ""2`.ld{S:SW24d+!"");
    StringUtils.swapCase("""");
    StringUtils.lastIndexOf((CharSequence) ""2`.ld{S:SW24d+!"", (CharSequence) ""2`.ld{S:SW24d+!"");
    StringUtils.contains((CharSequence) """", (CharSequence) ""?S5rhV{"");
}","/**
 * <p>Checks if CharSequence contains a search CharSequence, handling {@code null}.
 * This method uses {@link String#indexOf(String)} if possible.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.contains(null, *)     = false
 * StringUtils.contains(*, null)     = false
 * StringUtils.contains("""", """")      = true
 * StringUtils.contains(""abc"", """")   = true
 * StringUtils.contains(""abc"", ""a"")  = true
 * StringUtils.contains(""abc"", ""z"")  = false
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchSeq  the CharSequence to find, may be null
 * @return true if the CharSequence contains the search CharSequence,
 *  false if not or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from contains(String, String) to contains(CharSequence, CharSequence)
 */"
"public static int indexOf(CharSequence seq, CharSequence searchSeq) {
    if (seq == null || searchSeq == null) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.indexOf(seq, searchSeq, 0);
}","public void test159244() throws Throwable {
    StringUtils.replaceEachRepeatedly(""p{InCombiningDiacriticalMarks}+"", (String[]) null, (String[]) null);
    StringUtils.indexOfAny((CharSequence) ""p{InCombiningDiacriticalMarks}+"", (CharSequence[]) null);
    StringUtils.indexOfAnyBut((CharSequence) ""p{InCombiningDiacriticalMarks}+"", (CharSequence) ""p{InCombiningDiacriticalMarks}+"");
    StringUtils.center(""p{InCombiningDiacriticalMarks}+"", (-1), '\""');
    char[] charArray0 = new char[2];
    charArray0[0] = '\""';
    StringUtils.containsAny((CharSequence) ""p{InCombiningDiacriticalMarks}+"", charArray0);
    StringUtils.defaultString(""p{InCombiningDiacriticalMarks}+"");
    StringUtils.removeStart(""AqYCshqa_33l0lal+"", ""p{InCombiningDiacriticalMarks}+"");
    StringUtils.overlay(""N/Mb{;nVj9ZTqSB!"", ""FfD` Z/yI1~7u];S["", (-2484), 1);
    StringUtils.chop(""1I[N2S?gKeE>0"");
    StringUtils.isNumeric(""1I[N2S?gKeE>0"");
    StringUtils.indexOf((CharSequence) ""p{InCombiningDiacriticalMarks}+"", (CharSequence) ""1I[N2S?gKeE>0"");
}","/**
 * <p>Finds the first index within a CharSequence, handling {@code null}.
 * This method uses {@link String#indexOf(String, int)} if possible.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOf(null, *)          = -1
 * StringUtils.indexOf(*, null)          = -1
 * StringUtils.indexOf("""", """")           = 0
 * StringUtils.indexOf("""", *)            = -1 (except when * = """")
 * StringUtils.indexOf(""aabaabaa"", ""a"")  = 0
 * StringUtils.indexOf(""aabaabaa"", ""b"")  = 2
 * StringUtils.indexOf(""aabaabaa"", ""ab"") = 1
 * StringUtils.indexOf(""aabaabaa"", """")   = 0
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchSeq  the CharSequence to find, may be null
 * @return the first index of the search CharSequence,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from indexOf(String, String) to indexOf(CharSequence, CharSequence)
 */"
"public static String replaceEach(String text, String[] searchList, String[] replacementList) {
    return replaceEach(text, searchList, replacementList, false, 0);
}","public void test160245() throws Throwable {
    String string0 = StringUtils.leftPad(""hq4"", 2869, ""hq4"");
    StringUtils.replace(""*"", ""hq4"", (String) null);
    StringUtils.mid(""#[[.GF^=wNZA*uldh# "", 2565, 198);
    String string1 = StringUtils.rightPad(""*"", 2565, (String) null);
    StringUtils.abbreviate("""", 198, 2869);
    StringUtils.abbreviate("""", 16);
    String[] stringArray0 = new String[9];
    stringArray0[0] = ""\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000B\f\r\u000E\u000F\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001A\u001B\u001C\u001D\u001E\u001F !\""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}~"";
    stringArray0[1] = string0;
    stringArray0[2] = """";
    stringArray0[3] = """";
    stringArray0[4] = """";
    stringArray0[5] = ""Strings must not be null"";
    stringArray0[6] = string1;
    stringArray0[7] = ""*"";
    stringArray0[8] = ""*"";
    StringUtils.replaceEach(string1, stringArray0, stringArray0);
}","/**
 * <p>
 * Replaces all occurrences of Strings within another String.
 * </p>
 *
 * <p>
 * A {@code null} reference passed to this method is a no-op, or if
 * any ""search string"" or ""string to replace"" is null, that replace will be
 * ignored. This will not repeat. For repeating replaces, call the
 * overloaded method.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *)        = null
 *  StringUtils.replaceEach("""", *, *)          = """"
 *  StringUtils.replaceEach(""aba"", null, null) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[0], null) = ""aba""
 *  StringUtils.replaceEach(""aba"", null, new String[0]) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, null)  = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""})  = ""b""
 *  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""})  = ""aba""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""})  = ""wcte""
 *  (example of how it does not repeat)
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""})  = ""dcte""
 * </pre>
 *
 * @param text
 *            text to search and replace in, no-op if null
 * @param searchList
 *            the Strings to search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @return the text with any replacements processed, {@code null} if
 *         null String input
 * @throws IndexOutOfBoundsException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */"
"public static String join(Object[] array, String separator, int startIndex, int endIndex) {
    if (array == null) {
        return null;
    }
    if (separator == null) {
        separator = EMPTY;
    }
    // endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))
    //           (Assuming that all Strings are roughly equally long)
    int noOfItems = (endIndex - startIndex);
    if (noOfItems <= 0) {
        return EMPTY;
    }
    StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}","public void test161246() throws Throwable {
    StringUtils.deleteWhitespace(""The String must not be empty"");
    Stack<Integer> stack0 = new Stack<Integer>();
    Integer integer0 = new Integer(1814);
    stack0.add(integer0);
    Integer integer1 = new Integer(1814);
    stack0.add(integer1);
    StringUtils.join((Iterable<?>) stack0, ' ');
    StringUtils.substring(""YkbWt_IH22J"", 1814);
    StringUtils.isAllLowerCase(""TheStringmustnotbeempty"");
    Object[] objectArray0 = new Object[8];
    objectArray0[0] = (Object) integer0;
    objectArray0[1] = (Object) stack0;
    objectArray0[2] = (Object) stack0;
    objectArray0[3] = (Object) ""1814 1814"";
    objectArray0[4] = (Object) stack0;
    objectArray0[5] = (Object) integer0;
    objectArray0[6] = (Object) ""TheStringmustnotbeempty"";
    objectArray0[7] = (Object) ""The String must not be empty"";
    StringUtils.join(objectArray0, (String) null, 4998, 1814);
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A {@code null} separator is the same as an empty String ("""").
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)                = null
 * StringUtils.join([], *)                  = """"
 * StringUtils.join([null], *)              = """"
 * StringUtils.join([""a"", ""b"", ""c""], ""--"")  = ""a--b--c""
 * StringUtils.join([""a"", ""b"", ""c""], null)  = ""abc""
 * StringUtils.join([""a"", ""b"", ""c""], """")    = ""abc""
 * StringUtils.join([null, """", ""a""], ',')   = "",,a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @param startIndex the first index to start joining from.  It is
 * an error to pass in an end index past the end of the array
 * @param endIndex the index to stop joining from (exclusive). It is
 * an error to pass in an end index past the end of the array
 * @return the joined String, {@code null} if null array input
 */"
"public static String join(Object[] array, String separator) {
    if (array == null) {
        return null;
    }
    return join(array, separator, 0, array.length);
}","public void test162247() throws Throwable {
    StringUtils.stripToEmpty(""|K=5&]01dt47w O;kv"");
    StringUtils.leftPad(""`jwlwb'"", 0, 'm');
    StringUtils.abbreviateMiddle(""|K=5&]01dt47w O;kv"", ""`jwlwb'"", 64);
    StringUtils.replaceChars(""`jwlwb'"", """", ""|K=5&]01dt47w O;kv"");
    Object[] objectArray0 = new Object[3];
    objectArray0[0] = (Object) """";
    objectArray0[1] = (Object) """";
    objectArray0[2] = (Object) ""`jwlwb'"";
    StringUtils.join(objectArray0, ""F@tr"");
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A {@code null} separator is the same as an empty String ("""").
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)                = null
 * StringUtils.join([], *)                  = """"
 * StringUtils.join([null], *)              = """"
 * StringUtils.join([""a"", ""b"", ""c""], ""--"")  = ""a--b--c""
 * StringUtils.join([""a"", ""b"", ""c""], null)  = ""abc""
 * StringUtils.join([""a"", ""b"", ""c""], """")    = ""abc""
 * StringUtils.join([null, """", ""a""], ',')   = "",,a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @return the joined String, {@code null} if null array input
 */"
"public static String[] substringsBetween(String str, String open, String close) {
    if (str == null || isEmpty(open) || isEmpty(close)) {
        return null;
    }
    int strLen = str.length();
    if (strLen == 0) {
        return ArrayUtils.EMPTY_STRING_ARRAY;
    }
    int closeLen = close.length();
    int openLen = open.length();
    List<String> list = new ArrayList<String>();
    int pos = 0;
    while (pos < (strLen - closeLen)) {
        int start = str.indexOf(open, pos);
        if (start < 0) {
            break;
        }
        start += openLen;
        int end = str.indexOf(close, start);
        if (end < 0) {
            break;
        }
        list.add(str.substring(start, end));
        pos = end + closeLen;
    }
    if (list.isEmpty()) {
        return null;
    }
    return list.toArray(new String[list.size()]);
}","public void test163248() throws Throwable {
    StringUtils.swapCase(""p5`I"");
    StringUtils.isNumeric(""P5`i"");
    StringUtils.abbreviateMiddle(""rr[Y1jd lPy*oG !J-?7SyC"", ""p5`I"", 57);
    StringUtils.normalizeSpace(""?7SyC"");
    StringUtils.stripToEmpty(""|`?_p[g"");
    StringUtils.substringsBetween(""L="", ""4);"", ""|`?_p[g"");
}","/**
 * <p>Searches a String for substrings delimited by a start and end tag,
 * returning all matching substrings in an array.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} open/close returns {@code null} (no match).
 * An empty ("""") open/close returns {@code null} (no match).</p>
 *
 * <pre>
 * StringUtils.substringsBetween(""[a][b][c]"", ""["", ""]"") = [""a"",""b"",""c""]
 * StringUtils.substringsBetween(null, *, *)            = null
 * StringUtils.substringsBetween(*, null, *)            = null
 * StringUtils.substringsBetween(*, *, null)            = null
 * StringUtils.substringsBetween("""", ""["", ""]"")          = []
 * </pre>
 *
 * @param str  the String containing the substrings, null returns null, empty returns empty
 * @param open  the String identifying the start of the substring, empty returns null
 * @param close  the String identifying the end of the substring, empty returns null
 * @return a String Array of substrings, or {@code null} if no match
 * @since 2.3
 */"
"public static String substring(String str, int start, int end) {
    if (str == null) {
        return null;
    }
    // handle negatives
    if (end < 0) {
        // remember end is negative
        end = str.length() + end;
    }
    if (start < 0) {
        // remember start is negative
        start = str.length() + start;
    }
    // check length next
    if (end > str.length()) {
        end = str.length();
    }
    // if start is greater than end, return """"
    if (start > end) {
        return EMPTY;
    }
    if (start < 0) {
        start = 0;
    }
    if (end < 0) {
        end = 0;
    }
    return str.substring(start, end);
}","public void test164249() throws Throwable {
    StringUtils.substring(""!cKI+| >S2,wSPL1]%"", 2717);
    StringUtils.indexOf((CharSequence) ""!cKI+| >S2,wSPL1]%"", 1136);
    StringUtils.upperCase("""");
    StringUtils.indexOfAnyBut((CharSequence) """", (CharSequence) """");
    StringUtils.stripToEmpty(""8^*%yD=;z5(LW"");
    ArrayDeque<String> arrayDeque0 = new ArrayDeque<String>();
    arrayDeque0.add(""8^*%yD=;z5(LW"");
    StringUtils.join((Iterable<?>) arrayDeque0, ""!cKI+| >S2,wSPL1]%"");
    StringUtils.substringBefore("""", ""java.lang.String@0000000001"");
    StringUtils.strip(""Arguments cannot both be null"", """");
    StringUtils.lowerCase(""TimeToLive of "");
    StringUtils.center(""Arguments cannot both be null"", 256);
    StringUtils.indexOf((CharSequence) """", (CharSequence) ""!cKI+| >S2,wSPL1]%"", Integer.MAX_VALUE);
    StringUtils.substring("""", 0, 0);
}","/**
 * <p>Gets a substring from the specified String avoiding exceptions.</p>
 *
 * <p>A negative start position can be used to start/end {@code n}
 * characters from the end of the String.</p>
 *
 * <p>The returned substring starts with the character in the {@code start}
 * position and ends before the {@code end} position. All position counting is
 * zero-based -- i.e., to start at the beginning of the string use
 * {@code start = 0}. Negative start and end positions can be used to
 * specify offsets relative to the end of the String.</p>
 *
 * <p>If {@code start} is not strictly to the left of {@code end}, """"
 * is returned.</p>
 *
 * <pre>
 * StringUtils.substring(null, *, *)    = null
 * StringUtils.substring("""", * ,  *)    = """";
 * StringUtils.substring(""abc"", 0, 2)   = ""ab""
 * StringUtils.substring(""abc"", 2, 0)   = """"
 * StringUtils.substring(""abc"", 2, 4)   = ""c""
 * StringUtils.substring(""abc"", 4, 6)   = """"
 * StringUtils.substring(""abc"", 2, 2)   = """"
 * StringUtils.substring(""abc"", -2, -1) = ""b""
 * StringUtils.substring(""abc"", -4, 2)  = ""ab""
 * </pre>
 *
 * @param str  the String to get the substring from, may be null
 * @param start  the position to start from, negative means
 *  count back from the end of the String by this many characters
 * @param end  the position to end at (exclusive), negative means
 *  count back from the end of the String by this many characters
 * @return substring from start position to end positon,
 *  {@code null} if null String input
 */"
"public static String[] splitByWholeSeparator(String str, String separator, int max) {
    return splitByWholeSeparatorWorker(str, separator, max, false);
}","public void test165250() throws Throwable {
    StringUtils.remove(""The Character must not be null"", '<');
    String string0 = ""\\u00"";
    String string1 = StringUtils.normalizeSpace(string0);
    StringUtils.getLevenshteinDistance((CharSequence) string0, (CharSequence) ""The Character must not be null"");
    StringUtils.left(string0, 0);
    StringUtils.isAlphanumeric("""");
    StringUtils.isAlphaSpace(""The Character must not be null"");
    StringUtils.repeat('<', 0);
    StringUtils.normalizeSpace(string1);
    CharSequence[] charSequenceArray0 = new CharSequence[6];
    charSequenceArray0[0] = (CharSequence) ""The Character must not be null"";
    charSequenceArray0[1] = (CharSequence) ""The Character must not be null"";
    charSequenceArray0[2] = (CharSequence) string1;
    charSequenceArray0[3] = (CharSequence) ""The Character must not be null"";
    charSequenceArray0[4] = (CharSequence) ""The Character must not be null"";
    charSequenceArray0[5] = (CharSequence) """";
    StringUtils.indexOfDifference(charSequenceArray0);
    Locale locale0 = Locale.GERMANY;
    Locale.getISOLanguages();
    StringUtils.lowerCase((String) null, locale0);
    StringUtils.reverse(""FUe`{~FZWdI!/"");
    StringUtils.lastIndexOf((CharSequence) string1, 0, (-1661));
    StringUtils.splitByWholeSeparator("""", ""Arguments cannot both be null"", 0);
}","/**
 * <p>Splits the provided text into an array, separator string specified.
 * Returns a maximum of {@code max} substrings.</p>
 *
 * <p>The separator(s) will not be included in the returned String array.
 * Adjacent separators are treated as one separator.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} separator splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.splitByWholeSeparator(null, *, *)               = null
 * StringUtils.splitByWholeSeparator("""", *, *)                 = []
 * StringUtils.splitByWholeSeparator(""ab de fg"", null, 0)      = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparator(""ab   de fg"", null, 0)    = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparator(""ab:cd:ef"", "":"", 2)       = [""ab"", ""cd:ef""]
 * StringUtils.splitByWholeSeparator(""ab-!-cd-!-ef"", ""-!-"", 5) = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitByWholeSeparator(""ab-!-cd-!-ef"", ""-!-"", 2) = [""ab"", ""cd-!-ef""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @param separator  String containing the String to be used as a delimiter,
 *  {@code null} splits on whitespace
 * @param max  the maximum number of elements to include in the returned
 *  array. A zero or negative value implies no limit.
 * @return an array of parsed Strings, {@code null} if null String was input
 */"
"// Joining
//-----------------------------------------------------------------------
/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No separator is added to the joined String.
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null)            = null
 * StringUtils.join([])              = """"
 * StringUtils.join([null])          = """"
 * StringUtils.join([""a"", ""b"", ""c""]) = ""abc""
 * StringUtils.join([null, """", ""a""]) = ""a""
 * </pre>
 *
 * @param <T> the specific type of values to join together
 * @param elements  the values to join together, may be null
 * @return the joined String, {@code null} if null array input
 * @since 2.0
 * @since 3.0 Changed signature to use varargs
 */
public static <T> String join(T... elements) {
    return join(elements, null);
}","public void test166251() throws Throwable {
    Integer[] integerArray0 = new Integer[8];
    Integer integer0 = new Integer(Integer.MAX_VALUE);
    integerArray0[0] = integer0;
    Integer integer1 = new Integer((-542));
    integerArray0[1] = integer1;
    Integer integer2 = new Integer((int) integerArray0[1]);
    integerArray0[2] = integer2;
    int int0 = 13;
    Integer integer3 = new Integer(13);
    integerArray0[3] = integer3;
    Integer integer4 = new Integer(int0);
    integerArray0[4] = integer4;
    Integer integer5 = new Integer(int0);
    integerArray0[5] = integer5;
    Integer integer6 = new Integer(0);
    integerArray0[6] = integer6;
    Integer integer7 = new Integer(int0);
    integerArray0[7] = integer7;
    StringUtils.join(integerArray0);
}",""
"public static int indexOf(CharSequence seq, CharSequence searchSeq) {
    if (seq == null || searchSeq == null) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.indexOf(seq, searchSeq, 0);
}","public void test168253() throws Throwable {
    StringUtils.upperCase("", '"");
    StringUtils.lastOrdinalIndexOf("", '"", "", '"", (-1147));
    StringUtils.chop(""VA*L&A"");
    String[] stringArray0 = StringUtils.splitByWholeSeparatorPreserveAllTokens("""", """", (-1147));
    StringUtils.mid("", '"", 0, 0);
    StringUtils.isAllUpperCase(""VA*L&A"");
    StringUtils.join((Object[]) stringArray0);
    StringUtils.isAllUpperCase("", '"");
    String[] stringArray1 = new String[7];
    stringArray1[0] = """";
    stringArray1[1] = ""VA*L&"";
    stringArray1[2] = """";
    stringArray1[3] = ""VA*L&"";
    stringArray1[4] = "", '"";
    stringArray1[5] = """";
    stringArray1[6] = ""VA*L&A"";
    StringUtils.getCommonPrefix(stringArray1);
    StringUtils.defaultString(""VA*L&"", ""VA*L&"");
    StringUtils.removeStart("""", ""UPjo(AzNrC%:"");
    StringUtils.substringBefore(""VA*L&"", """");
    StringUtils.trim("""");
    StringUtils.isAllLowerCase("""");
    StringUtils.difference("" is not in the range '0' - '9'"", ""VA*L&"");
    StringUtils.getCommonPrefix(stringArray1);
    StringUtils.splitByWholeSeparatorPreserveAllTokens("""", """");
    StringUtils.reverse(""sP`u+I ,=U*"");
    StringUtils.isNotBlank(""VA*L&"");
    StringUtils.contains((CharSequence) """", 0);
    StringUtils.indexOf((CharSequence) ""VA*L&"", (CharSequence) ""VA*L&A"");
}","/**
 * <p>Finds the first index within a CharSequence, handling {@code null}.
 * This method uses {@link String#indexOf(String, int)} if possible.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOf(null, *)          = -1
 * StringUtils.indexOf(*, null)          = -1
 * StringUtils.indexOf("""", """")           = 0
 * StringUtils.indexOf("""", *)            = -1 (except when * = """")
 * StringUtils.indexOf(""aabaabaa"", ""a"")  = 0
 * StringUtils.indexOf(""aabaabaa"", ""b"")  = 2
 * StringUtils.indexOf(""aabaabaa"", ""ab"") = 1
 * StringUtils.indexOf(""aabaabaa"", """")   = 0
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchSeq  the CharSequence to find, may be null
 * @return the first index of the search CharSequence,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from indexOf(String, String) to indexOf(CharSequence, CharSequence)
 */"
"// Left/Right/Mid
//-----------------------------------------------------------------------
/**
 * <p>Gets the leftmost {@code len} characters of a String.</p>
 *
 * <p>If {@code len} characters are not available, or the
 * String is {@code null}, the String will be returned without
 * an exception. An empty String is returned if len is negative.</p>
 *
 * <pre>
 * StringUtils.left(null, *)    = null
 * StringUtils.left(*, -ve)     = """"
 * StringUtils.left("""", *)      = """"
 * StringUtils.left(""abc"", 0)   = """"
 * StringUtils.left(""abc"", 2)   = ""ab""
 * StringUtils.left(""abc"", 4)   = ""abc""
 * </pre>
 *
 * @param str  the String to get the leftmost characters from, may be null
 * @param len  the length of the required String
 * @return the leftmost characters, {@code null} if null String input
 */
public static String left(String str, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0) {
        return EMPTY;
    }
    if (str.length() <= len) {
        return str;
    }
    return str.substring(0, len);
}","public void test169254() throws Throwable {
    StringUtils.center("", Length: "", 0);
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>(0);
    linkedHashSet0.add("", Length: "");
    Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
    linkedHashSet0.forEach(consumer0);
    StringUtils.join((Iterable<?>) linkedHashSet0, 'B');
    StringUtils.left("""", 0);
}",""
"public static String join(Object[] array, char separator, int startIndex, int endIndex) {
    if (array == null) {
        return null;
    }
    int noOfItems = (endIndex - startIndex);
    if (noOfItems <= 0) {
        return EMPTY;
    }
    StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}","public void test170255() throws Throwable {
    StringUtils.rightPad(""The Character must not be null"", 0);
    String[] stringArray0 = StringUtils.split(""The Character must not be null"", '8');
    StringUtils.equalsIgnoreCase(""The Character must not be null"", ""The Character must not be null"");
    StringUtils.substringBetween("""", ""Cannot store "");
    StringUtils.containsNone((CharSequence) ""The Character must not be null"", ""0`H[$u/)ik=evj=I"");
    StringUtils.isAllUpperCase(""Cannot store "");
    String string0 = ""\\u000"";
    StringUtils.trimToNull(string0);
    StringUtils.length((CharSequence) null);
    StringUtils.indexOfAnyBut((CharSequence) string0, (CharSequence) """");
    StringUtils.join((Object[]) stringArray0, (String) null);
    StringUtils.containsIgnoreCase((CharSequence) null, (CharSequence) null);
    StringUtils.containsNone((CharSequence) null, (char[]) null);
    StringUtils.indexOfAnyBut((CharSequence) ""The Character must not be null"", (CharSequence) null);
    StringUtils.substringBetween(""The Character must not be null"", string0, string0);
    StringUtils.containsOnly((CharSequence) """", (char[]) null);
    StringUtils.join((Object[]) stringArray0, '_', (-2198), (-2198));
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)               = null
 * StringUtils.join([], *)                 = """"
 * StringUtils.join([null], *)             = """"
 * StringUtils.join([""a"", ""b"", ""c""], ';')  = ""a;b;c""
 * StringUtils.join([""a"", ""b"", ""c""], null) = ""abc""
 * StringUtils.join([null, """", ""a""], ';')  = "";;a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use
 * @param startIndex the first index to start joining from.  It is
 * an error to pass in an end index past the end of the array
 * @param endIndex the index to stop joining from (exclusive). It is
 * an error to pass in an end index past the end of the array
 * @return the joined String, {@code null} if null array input
 * @since 2.0
 */"
"public static boolean isAlphanumeric(CharSequence cs) {
    if (cs == null || cs.length() == 0) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isLetterOrDigit(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test171256() throws Throwable {
    char[] charArray0 = new char[3];
    charArray0[0] = 's';
    charArray0[1] = 'H';
    charArray0[2] = 'a';
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0, 0, 0);
    StringUtils.isAlphanumeric(charBuffer0);
}","/**
 * <p>Checks if the CharSequence contains only unicode letters or digits.</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty CharSequence (length()=0) will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.isAlphanumeric(null)   = false
 * StringUtils.isAlphanumeric("""")     = false
 * StringUtils.isAlphanumeric(""  "")   = false
 * StringUtils.isAlphanumeric(""abc"")  = true
 * StringUtils.isAlphanumeric(""ab c"") = false
 * StringUtils.isAlphanumeric(""ab2c"") = true
 * StringUtils.isAlphanumeric(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if only contains letters or digits,
 *  and is non-null
 * @since 3.0 Changed signature from isAlphanumeric(String) to isAlphanumeric(CharSequence)
 * @since 3.0 Changed """" to return false and not true
 */"
"public static String abbreviate(String str, int offset, int maxWidth) {
    if (str == null) {
        return null;
    }
    if (maxWidth < 4) {
        throw new IllegalArgumentException(""Minimum abbreviation width is 4"");
    }
    if (str.length() <= maxWidth) {
        return str;
    }
    if (offset > str.length()) {
        offset = str.length();
    }
    if ((str.length() - offset) < (maxWidth - 3)) {
        offset = str.length() - (maxWidth - 3);
    }
    final String abrevMarker = ""..."";
    if (offset <= 4) {
        return str.substring(0, maxWidth - 3) + abrevMarker;
    }
    if (maxWidth < 7) {
        throw new IllegalArgumentException(""Minimum abbreviation width with offset is 7"");
    }
    if ((offset + (maxWidth - 3)) < str.length()) {
        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);
    }
    return abrevMarker + str.substring(str.length() - (maxWidth - 3));
}","public void test172257() throws Throwable {
    char char0 = 'q';
    StringUtils.replaceChars(""The character "", 'q', 'q');
    CharSequence[] charSequenceArray0 = new CharSequence[6];
    charSequenceArray0[0] = (CharSequence) ""The character "";
    charSequenceArray0[1] = (CharSequence) ""The character "";
    charSequenceArray0[2] = (CharSequence) ""The character "";
    charSequenceArray0[3] = (CharSequence) ""The character "";
    charSequenceArray0[4] = (CharSequence) ""The character "";
    charSequenceArray0[5] = (CharSequence) ""The character "";
    StringUtils.startsWithAny(""The character "", charSequenceArray0);
    String string0 = """";
    StringUtils.chop("""");
    StringUtils.indexOf((CharSequence) """", (CharSequence) ""The character "", 147);
    String[] stringArray0 = StringUtils.splitPreserveAllTokens("""", 'q');
    StringUtils.startsWith(""The character "", charSequenceArray0[5]);
    char char1 = 't';
    StringUtils.join((Object[]) charSequenceArray0, 't');
    StringUtils.strip((String) null);
    StringUtils.equalsIgnoreCase(""The character "", (CharSequence) null);
    StringUtils.startsWithAny("""", stringArray0);
    // Undeclared exception!
    try {
        StringUtils.abbreviate("""", 3, 3);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Minimum abbreviation width is 4
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}","/**
 * <p>Abbreviates a String using ellipses. This will turn
 * ""Now is the time for all good men"" into ""...is the time for...""</p>
 *
 * <p>Works like {@code abbreviate(String, int)}, but allows you to specify
 * a ""left edge"" offset.  Note that this left edge is not necessarily going to
 * be the leftmost character in the result, or the first character following the
 * ellipses, but it will appear somewhere in the result.
 *
 * <p>In no case will it return a String of length greater than
 * {@code maxWidth}.</p>
 *
 * <pre>
 * StringUtils.abbreviate(null, *, *)                = null
 * StringUtils.abbreviate("""", 0, 4)                  = """"
 * StringUtils.abbreviate(""abcdefghijklmno"", -1, 10) = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 0, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 1, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 4, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 5, 10)  = ""...fghi...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 6, 10)  = ""...ghij...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 8, 10)  = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghijklmno"", 10, 10) = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghijklmno"", 12, 10) = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghij"", 0, 3)        = IllegalArgumentException
 * StringUtils.abbreviate(""abcdefghij"", 5, 6)        = IllegalArgumentException
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param offset  left edge of source String
 * @param maxWidth  maximum length of result String, must be at least 4
 * @return abbreviated String, {@code null} if null String input
 * @throws IllegalArgumentException if the width is too small
 * @since 2.0
 */"
"// IndexOfAnyBut chars
//-----------------------------------------------------------------------
/**
 * <p>Searches a CharSequence to find the first index of any
 * character not in the given set of characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A {@code null} or zero length search array will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAnyBut(null, *)                              = -1
 * StringUtils.indexOfAnyBut("""", *)                                = -1
 * StringUtils.indexOfAnyBut(*, null)                              = -1
 * StringUtils.indexOfAnyBut(*, [])                                = -1
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", new char[] {'z', 'a'} ) = 3
 * StringUtils.indexOfAnyBut(""aba"", new char[] {'z'} )             = 0
 * StringUtils.indexOfAnyBut(""aba"", new char[] {'a', 'b'} )        = -1
 *
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAnyBut(String, char[]) to indexOfAnyBut(CharSequence, char...)
 */
public static int indexOfAnyBut(CharSequence cs, char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int csLen = cs.length();
    int csLast = csLen - 1;
    int searchLen = searchChars.length;
    int searchLast = searchLen - 1;
    outer: for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
                    if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        continue outer;
                    }
                } else {
                    continue outer;
                }
            }
        }
        return i;
    }
    return INDEX_NOT_FOUND;
}","public void test173258() throws Throwable {
    StringUtils.removeEnd("""", """");
    String string0 = StringUtils.center(""The Character must not be null"", 1783, 'X');
    StringUtils.lastIndexOf((CharSequence) string0, 0);
    char[] charArray0 = new char[0];
    StringUtils.indexOfAnyBut((CharSequence) ""The Character must not be null"", charArray0);
}",""
"public static String trimToNull(String str) {
    String ts = trim(str);
    return isEmpty(ts) ? null : ts;
}","public void test174259() throws Throwable {
    StringUtils.right(""#_"", 0);
    StringUtils.strip(""_w[IYfF9g^Av33Q6"", ""_w[IYfF9g^Av33Q6"");
    StringUtils.lastIndexOf((CharSequence) """", (CharSequence) ""_w[IYfF9g^Av33Q6"");
    char[] charArray0 = new char[4];
    charArray0[0] = '.';
    charArray0[1] = 'H';
    charArray0[2] = '.';
    charArray0[3] = '.';
    StringUtils.containsAny((CharSequence) ""_w[IYfF9g^Av33Q6"", charArray0);
    String[] stringArray0 = new String[5];
    stringArray0[0] = ""5G^_e"";
    stringArray0[1] = ""5G^_e"";
    stringArray0[2] = ""_w[IYfF9g^Av33Q6"";
    stringArray0[3] = """";
    stringArray0[4] = """";
    StringUtils.getCommonPrefix(stringArray0);
    StringUtils.isAlphaSpace("""");
    StringUtils.stripStart("""", ""5G^_e"");
    StringUtils.trimToNull("""");
}","/**
 * <p>Removes control characters (char &lt;= 32) from both
 * ends of this String returning {@code null} if the String is
 * empty ("""") after the trim or if it is {@code null}.
 *
 * <p>The String is trimmed using {@link String#trim()}.
 * Trim removes start and end characters &lt;= 32.
 * To strip whitespace use {@link #stripToNull(String)}.</p>
 *
 * <pre>
 * StringUtils.trimToNull(null)          = null
 * StringUtils.trimToNull("""")            = null
 * StringUtils.trimToNull(""     "")       = null
 * StringUtils.trimToNull(""abc"")         = ""abc""
 * StringUtils.trimToNull(""    abc    "") = ""abc""
 * </pre>
 *
 * @param str  the String to be trimmed, may be null
 * @return the trimmed String,
 *  {@code null} if only chars &lt;= 32, empty or null String input
 * @since 2.0
 */"
"// Difference
//-----------------------------------------------------------------------
/**
 * <p>Compares two Strings, and returns the portion where they differ.
 * (More precisely, return the remainder of the second String,
 * starting from where it's different from the first.)</p>
 *
 * <p>For example,
 * {@code difference(""i am a machine"", ""i am a robot"") -> ""robot""}.</p>
 *
 * <pre>
 * StringUtils.difference(null, null) = null
 * StringUtils.difference("""", """") = """"
 * StringUtils.difference("""", ""abc"") = ""abc""
 * StringUtils.difference(""abc"", """") = """"
 * StringUtils.difference(""abc"", ""abc"") = """"
 * StringUtils.difference(""ab"", ""abxyz"") = ""xyz""
 * StringUtils.difference(""abcde"", ""abxyz"") = ""xyz""
 * StringUtils.difference(""abcde"", ""xyz"") = ""xyz""
 * </pre>
 *
 * @param str1  the first String, may be null
 * @param str2  the second String, may be null
 * @return the portion of str2 where it differs from str1; returns the
 * empty String if they are equal
 * @since 2.0
 */
public static String difference(String str1, String str2) {
    if (str1 == null) {
        return str2;
    }
    if (str2 == null) {
        return str1;
    }
    int at = indexOfDifference(str1, str2);
    if (at == INDEX_NOT_FOUND) {
        return EMPTY;
    }
    return str2.substring(at);
}","public void test175260() throws Throwable {
    StringUtils.swapCase("":6P1A[85_Mk*z_"");
    StringUtils.isAllUpperCase("":6p1a[85_mK*Z_"");
    StringUtils.difference("":6p1a[85_mK*Z_"", """");
}",""
"public static String join(Object[] array, String separator, int startIndex, int endIndex) {
    if (array == null) {
        return null;
    }
    if (separator == null) {
        separator = EMPTY;
    }
    // endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))
    //           (Assuming that all Strings are roughly equally long)
    int noOfItems = (endIndex - startIndex);
    if (noOfItems <= 0) {
        return EMPTY;
    }
    StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}","public void test176261() throws Throwable {
    StringUtils.upperCase("""");
    StringUtils.contains((CharSequence) """", (CharSequence) """");
    StringUtils.substringAfter("""", """");
    StringUtils.rightPad("""", 0, '\\');
    StringUtils.substring("""", 1803, 0);
    ArrayDeque<String> arrayDeque0 = new ArrayDeque<String>(0);
    ArrayDeque<String> arrayDeque1 = new ArrayDeque<String>(arrayDeque0);
    StringUtils.join((Iterable<?>) arrayDeque1, '\\');
    StringUtils.trimToEmpty("""");
    Object[] objectArray0 = new Object[5];
    objectArray0[0] = (Object) """";
    objectArray0[1] = (Object) """";
    objectArray0[2] = (Object) """";
    objectArray0[3] = (Object) """";
    objectArray0[4] = (Object) """";
    StringUtils.join(objectArray0, """", 0, 0);
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A {@code null} separator is the same as an empty String ("""").
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)                = null
 * StringUtils.join([], *)                  = """"
 * StringUtils.join([null], *)              = """"
 * StringUtils.join([""a"", ""b"", ""c""], ""--"")  = ""a--b--c""
 * StringUtils.join([""a"", ""b"", ""c""], null)  = ""abc""
 * StringUtils.join([""a"", ""b"", ""c""], """")    = ""abc""
 * StringUtils.join([null, """", ""a""], ',')   = "",,a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @param startIndex the first index to start joining from.  It is
 * an error to pass in an end index past the end of the array
 * @param endIndex the index to stop joining from (exclusive). It is
 * an error to pass in an end index past the end of the array
 * @return the joined String, {@code null} if null array input
 */"
"// Difference
//-----------------------------------------------------------------------
/**
 * <p>Compares two Strings, and returns the portion where they differ.
 * (More precisely, return the remainder of the second String,
 * starting from where it's different from the first.)</p>
 *
 * <p>For example,
 * {@code difference(""i am a machine"", ""i am a robot"") -> ""robot""}.</p>
 *
 * <pre>
 * StringUtils.difference(null, null) = null
 * StringUtils.difference("""", """") = """"
 * StringUtils.difference("""", ""abc"") = ""abc""
 * StringUtils.difference(""abc"", """") = """"
 * StringUtils.difference(""abc"", ""abc"") = """"
 * StringUtils.difference(""ab"", ""abxyz"") = ""xyz""
 * StringUtils.difference(""abcde"", ""abxyz"") = ""xyz""
 * StringUtils.difference(""abcde"", ""xyz"") = ""xyz""
 * </pre>
 *
 * @param str1  the first String, may be null
 * @param str2  the second String, may be null
 * @return the portion of str2 where it differs from str1; returns the
 * empty String if they are equal
 * @since 2.0
 */
public static String difference(String str1, String str2) {
    if (str1 == null) {
        return str2;
    }
    if (str2 == null) {
        return str1;
    }
    int at = indexOfDifference(str1, str2);
    if (at == INDEX_NOT_FOUND) {
        return EMPTY;
    }
    return str2.substring(at);
}","public void test177262() throws Throwable {
    StringUtils.substringBefore(""The Character must not be null"", """");
    StringUtils.isAlphanumeric(""The Character must not be null"");
    StringUtils.mid("""", 0, 0);
    StringUtils.difference("""", """");
}",""
"public static <T extends CharSequence> T defaultIfBlank(T str, T defaultStr) {
    return StringUtils.isBlank(str) ? defaultStr : str;
}","public void test178263() throws Throwable {
    StringUtils.deleteWhitespace(""Z1IE@%j)"");
    StringUtils.containsAny((CharSequence) ""Z1IE@%j)"", (CharSequence) ""Z1IE@%j)"");
    StringUtils.stripAccents(""Z1IE@%j)"");
    StringUtils.substringBetween(""Z1IE@%j)"", ""Z1IE@%j)"");
    String[] stringArray0 = StringUtils.split(""6,FWe48IGtmGTkXj<"", ""Z1IE@%j)"", (-1098));
    StringUtils.abbreviateMiddle(""Arguments cannot both be null"", ""dyWCM"", (-1098));
    StringUtils.stripToNull((String) null);
    StringUtils.containsOnly((CharSequence) ""Arguments cannot both be null"", "":_"");
    StringUtils.substringAfter(""Arguments cannot both be null"", ""{}"");
    StringUtils.capitalize(""Arguments cannot both be null"");
    StringUtils.mid((String) null, 1958, (-1098));
    StringUtils.join((Object[]) stringArray0, '0');
    StringUtils.defaultIfBlank("""", ""IllegalAccessException occurred"");
}","/**
 * <p>Returns either the passed in CharSequence, or if the CharSequence is
 * whitespace, empty ("""") or {@code null}, the value of {@code defaultStr}.</p>
 *
 * <pre>
 * StringUtils.defaultIfBlank(null, ""NULL"")  = ""NULL""
 * StringUtils.defaultIfBlank("""", ""NULL"")    = ""NULL""
 * StringUtils.defaultIfBlank("" "", ""NULL"")   = ""NULL""
 * StringUtils.defaultIfBlank(""bat"", ""NULL"") = ""bat""
 * StringUtils.defaultIfBlank("""", null)      = null
 * </pre>
 * @param <T> the specific kind of CharSequence
 * @param str the CharSequence to check, may be null
 * @param defaultStr  the default CharSequence to return
 *  if the input is whitespace, empty ("""") or {@code null}, may be null
 * @return the passed in CharSequence, or the default
 * @see StringUtils#defaultString(String, String)
 */"
"public static int length(CharSequence cs) {
    return cs == null ? 0 : cs.length();
}","public void test179264() throws Throwable {
    StringUtils.swapCase(""(s%Bi"");
    StringUtils.lastIndexOfIgnoreCase((CharSequence) ""(S%bI"", (CharSequence) ""(S%bI"", 0);
    StringUtils.containsOnly((CharSequence) ""(S%bI"", ""#QZ&D \""l"");
    StringUtils.isAlphaSpace(""(S%bI"");
    StringUtils.isEmpty(""(s%Bi"");
    Vector<Locale.FilteringMode> vector0 = new Vector<Locale.FilteringMode>(0);
    UnaryOperator<Locale.FilteringMode> unaryOperator0 = UnaryOperator.identity();
    vector0.replaceAll(unaryOperator0);
    StringUtils.join((Iterable<?>) vector0, '9');
    Locale.FilteringMode locale_FilteringMode0 = Locale.FilteringMode.EXTENDED_FILTERING;
    vector0.add(locale_FilteringMode0);
    String[] stringArray0 = StringUtils.splitByCharacterTypeCamelCase("":}#d/4rDB`-o]]Ec"");
    StringUtils.endsWith("":}#d/4rDB`-o]]Ec"", """");
    StringUtils.join((Object[]) stringArray0, '9');
    StringUtils.equals((CharSequence) ""#QZ&D \""l"", (CharSequence) ""(S%bI"");
    StringUtils.trimToEmpty("":9}9#9d9/949r9DB9`9-9o9]]9Ec"");
    StringUtils.chomp(""#QZ&D \""l"");
    int int0 = StringUtils.length("":9}9#9d9/949r9DB9`9-9o9]]9Ec"");
    assertEquals(28, int0);
}","/**
 * Gets a CharSequence length or {@code 0} if the CharSequence is
 * {@code null}.
 *
 * @param cs
 *            a CharSequence or {@code null}
 * @return CharSequence length or {@code 0} if the CharSequence is
 *         {@code null}.
 * @since 2.4
 * @since 3.0 Changed signature from length(String) to length(CharSequence)
 */"
"public static String join(Object[] array, String separator) {
    if (array == null) {
        return null;
    }
    return join(array, separator, 0, array.length);
}","public void test180265() throws Throwable {
    StringUtils.reverseDelimited(""b$QI8?\""y2T"", ']');
    Class<String> class0 = String.class;
    ServiceLoader<String> serviceLoader0 = ServiceLoader.loadInstalled(class0);
    StringUtils.join((Iterable<?>) serviceLoader0, ']');
    StringUtils.join((Object[]) null, ""b$QI8?\""y2T"");
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A {@code null} separator is the same as an empty String ("""").
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)                = null
 * StringUtils.join([], *)                  = """"
 * StringUtils.join([null], *)              = """"
 * StringUtils.join([""a"", ""b"", ""c""], ""--"")  = ""a--b--c""
 * StringUtils.join([""a"", ""b"", ""c""], null)  = ""abc""
 * StringUtils.join([""a"", ""b"", ""c""], """")    = ""abc""
 * StringUtils.join([null, """", ""a""], ',')   = "",,a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @return the joined String, {@code null} if null array input
 */"
"public static String normalizeSpace(String str) {
    if (str == null) {
        return null;
    }
    return WHITESPACE_BLOCK.matcher(trim(str)).replaceAll("" "");
}","public void test181266() throws Throwable {
    Object[] objectArray0 = new Object[6];
    Object object0 = new Object();
    objectArray0[0] = object0;
    Object object1 = new Object();
    objectArray0[1] = object1;
    Object object2 = new Object();
    objectArray0[2] = object2;
    Object object3 = new Object();
    objectArray0[3] = object3;
    Object object4 = new Object();
    objectArray0[4] = object4;
    Object object5 = new Object();
    objectArray0[5] = object5;
    StringUtils.join(objectArray0, 'i', (-1542), (-1542));
    StringUtils.containsNone((CharSequence) """", ""yFy|otf"");
    StringUtils.stripToNull("""");
    StringUtils.repeat(""Or+T|w,3Mt"", (-1542));
    StringUtils.rightPad("""", 0, """");
    StringUtils.normalizeSpace("""");
}","/**
 * <p>
 * Similar to <a
 * href=""http://www.w3.org/TR/xpath/#function-normalize-space"">http://www.w3.org/TR/xpath/#function-normalize
 * -space</a>
 * </p>
 * <p>
 * The function returns the argument string with whitespace normalized by using
 * <code>{@link #trim(String)}</code> to remove leading and trailing whitespace
 * and then replacing sequences of whitespace characters by a single space.
 * </p>
 * In XML Whitespace characters are the same as those allowed by the <a
 * href=""http://www.w3.org/TR/REC-xml/#NT-S"">S</a> production, which is S ::= (#x20 | #x9 | #xD | #xA)+
 * <p>
 * Java's regexp pattern \s defines whitespace as [ \t\n\x0B\f\r]
 * <p>
 * For reference:
 * <ul>
 * <li>\x0B = vertical tab</li>
 * <li>\f = #xC = form feed</li>
 * <li>#x20 = space</li>
 * <li>#x9 = \t</li>
 * <li>#xA = \n</li>
 * <li>#xD = \r</li>
 * </ul>
 * </p>
 * <p>
 * The difference is that Java's whitespace includes vertical tab and form feed, which this functional will also
 * normalize. Additonally <code>{@link #trim(String)}</code> removes control characters (char &lt;= 32) from both
 * ends of this String.
 * </p>
 *
 * @see Pattern
 * @see #trim(String)
 * @see <a
 *      href=""http://www.w3.org/TR/xpath/#function-normalize-space"">http://www.w3.org/TR/xpath/#function-normalize-space</a>
 * @param str the source String to normalize whitespaces from, may be null
 * @return the modified string with whitespace normalized, {@code null} if null String input
 *
 * @since 3.0
 */"
"public static String join(Object[] array, String separator, int startIndex, int endIndex) {
    if (array == null) {
        return null;
    }
    if (separator == null) {
        separator = EMPTY;
    }
    // endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))
    //           (Assuming that all Strings are roughly equally long)
    int noOfItems = (endIndex - startIndex);
    if (noOfItems <= 0) {
        return EMPTY;
    }
    StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}","public void test182267() throws Throwable {
    StringUtils.chomp("""", """");
    Object[] objectArray0 = new Object[4];
    objectArray0[0] = (Object) """";
    objectArray0[1] = (Object) """";
    objectArray0[2] = (Object) """";
    objectArray0[3] = (Object) """";
    String string0 = ""D9s$A}i#&3r|Wg*K"";
    int int0 = (-856);
    int int1 = 0;
    // Undeclared exception!
    try {
        StringUtils.join(objectArray0, ""D9s$A}i#&3r|Wg*K"", (-856), 0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -856
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A {@code null} separator is the same as an empty String ("""").
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)                = null
 * StringUtils.join([], *)                  = """"
 * StringUtils.join([null], *)              = """"
 * StringUtils.join([""a"", ""b"", ""c""], ""--"")  = ""a--b--c""
 * StringUtils.join([""a"", ""b"", ""c""], null)  = ""abc""
 * StringUtils.join([""a"", ""b"", ""c""], """")    = ""abc""
 * StringUtils.join([null, """", ""a""], ',')   = "",,a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @param startIndex the first index to start joining from.  It is
 * an error to pass in an end index past the end of the array
 * @param endIndex the index to stop joining from (exclusive). It is
 * an error to pass in an end index past the end of the array
 * @return the joined String, {@code null} if null array input
 */"
"// ContainsAny
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains any character in the given
 * set of characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.
 * A {@code null} or zero length search array will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)                = false
 * StringUtils.containsAny("""", *)                  = false
 * StringUtils.containsAny(*, null)                = false
 * StringUtils.containsAny(*, [])                  = false
 * StringUtils.containsAny(""zzabyycdxx"",['z','a']) = true
 * StringUtils.containsAny(""zzabyycdxx"",['b','y']) = true
 * StringUtils.containsAny(""aba"", ['z'])           = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the {@code true} if any of the chars are found,
 * {@code false} if no match or null input
 * @since 2.4
 * @since 3.0 Changed signature from containsAny(String, char[]) to containsAny(CharSequence, char...)
 */
public static boolean containsAny(CharSequence cs, char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    int csLast = csLength - 1;
    int searchLast = searchLength - 1;
    for (int i = 0; i < csLength; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == ch) {
                if (Character.isHighSurrogate(ch)) {
                    if (j == searchLast) {
                        // missing low surrogate, fine, like String.indexOf(String)
                        return true;
                    }
                    if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
                        return true;
                    }
                } else {
                    // ch is in the Basic Multilingual Plane
                    return true;
                }
            }
        }
    }
    return false;
}","public void test183268() throws Throwable {
    StringUtils.removeStartIgnoreCase(""Qhj\""F!dPV6AR3rv"", ""Qhj\""F!dPV6AR3rv"");
    StringUtils.repeat('o', 0);
    String string0 = StringUtils.center(""Qhj\""F!dPV6AR3rv"", 2581, 'u');
    StringUtils.length(""Qhj\""F!dPV6AR3rv"");
    StringUtils.isAlphaSpace(""Qhj\""F!dPV6AR3rv"");
    StringUtils.length("""");
    StringUtils.splitByWholeSeparatorPreserveAllTokens(string0, ""Qhj\""F!dPV6AR3rv"", 5);
    StringUtils.contains((CharSequence) """", 5);
    StringUtils.equalsIgnoreCase("""", """");
    char[] charArray0 = new char[4];
    charArray0[0] = 'u';
    charArray0[1] = 'u';
    charArray0[2] = 'o';
    charArray0[3] = 'o';
    StringUtils.containsAny((CharSequence) ""Qhj\""F!dPV6AR3rv"", charArray0);
}",""
"// Conversion
//-----------------------------------------------------------------------
// Padding
//-----------------------------------------------------------------------
/**
 * <p>Repeat a String {@code repeat} times to form a
 * new String.</p>
 *
 * <pre>
 * StringUtils.repeat(null, 2) = null
 * StringUtils.repeat("""", 0)   = """"
 * StringUtils.repeat("""", 2)   = """"
 * StringUtils.repeat(""a"", 3)  = ""aaa""
 * StringUtils.repeat(""ab"", 2) = ""abab""
 * StringUtils.repeat(""a"", -2) = """"
 * </pre>
 *
 * @param str  the String to repeat, may be null
 * @param repeat  number of times to repeat str, negative treated as zero
 * @return a new String consisting of the original String repeated,
 *  {@code null} if null String input
 */
public static String repeat(String str, int repeat) {
    // Performance tuned for 2.0 (JDK1.4)
    if (str == null) {
        return null;
    }
    if (repeat <= 0) {
        return EMPTY;
    }
    int inputLength = str.length();
    if (repeat == 1 || inputLength == 0) {
        return str;
    }
    if (inputLength == 1 && repeat <= PAD_LIMIT) {
        return repeat(str.charAt(0), repeat);
    }
    int outputLength = inputLength * repeat;
    switch(inputLength) {
        case 1:
            return repeat(str.charAt(0), repeat);
        case 2:
            char ch0 = str.charAt(0);
            char ch1 = str.charAt(1);
            char[] output2 = new char[outputLength];
            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {
                output2[i] = ch0;
                output2[i + 1] = ch1;
            }
            return new String(output2);
        default:
            StringBuilder buf = new StringBuilder(outputLength);
            for (int i = 0; i < repeat; i++) {
                buf.append(str);
            }
            return buf.toString();
    }
}","public void test184269() throws Throwable {
    StringUtils.repeat((String) null, 10);
}",""
"// ContainsAny
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains any character in the given
 * set of characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.
 * A {@code null} or zero length search array will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)                = false
 * StringUtils.containsAny("""", *)                  = false
 * StringUtils.containsAny(*, null)                = false
 * StringUtils.containsAny(*, [])                  = false
 * StringUtils.containsAny(""zzabyycdxx"",['z','a']) = true
 * StringUtils.containsAny(""zzabyycdxx"",['b','y']) = true
 * StringUtils.containsAny(""aba"", ['z'])           = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the {@code true} if any of the chars are found,
 * {@code false} if no match or null input
 * @since 2.4
 * @since 3.0 Changed signature from containsAny(String, char[]) to containsAny(CharSequence, char...)
 */
public static boolean containsAny(CharSequence cs, char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    int csLast = csLength - 1;
    int searchLast = searchLength - 1;
    for (int i = 0; i < csLength; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == ch) {
                if (Character.isHighSurrogate(ch)) {
                    if (j == searchLast) {
                        // missing low surrogate, fine, like String.indexOf(String)
                        return true;
                    }
                    if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
                        return true;
                    }
                } else {
                    // ch is in the Basic Multilingual Plane
                    return true;
                }
            }
        }
    }
    return false;
}","public void test185270() throws Throwable {
    Locale locale0 = Locale.FRENCH;
    locale0.getDisplayName();
    locale0.toLanguageTag();
    StringUtils.upperCase(""K+A\""=1tR*E&"", locale0);
    Vector<Locale.LanguageRange> vector0 = new Vector<Locale.LanguageRange>();
    Stack<String> stack0 = new Stack<String>();
    stack0.push(""\""#[1w^^+,k'!"");
    Locale.lookupTag(vector0, stack0);
    StringUtils.strip(""K+A\""=1TR*E&"", ""K+A\""=1tR*E&"");
    StringUtils.equals((CharSequence) ""K+A\""=1tR*E&"", (CharSequence) ""T"");
    StringUtils.length(""T"");
    StringUtils.replaceEachRepeatedly(""fr"", (String[]) null, (String[]) null);
    Locale.Category locale_Category0 = Locale.Category.FORMAT;
    Locale.setDefault(locale_Category0, locale0);
    StringUtils.splitByCharacterType(""fr"");
    StringUtils.substringAfterLast(""K+A\""=1tR*E&"", ""T"");
    StringUtils.isAlpha(""fr"");
    StringUtils.leftPad(""DAC-ekb8WG,FA+}o]]"", 1);
    StringUtils.containsIgnoreCase(""fr"", ""DAC-ekb8WG,FA+}o]]"");
    StringUtils.replaceChars(""DAC-ekb8WG,FA+}o]]"", ""K+A\""=1TR*E&"", ""K+A\""=1TR*E&"");
    StringUtils.split("""", 'b');
    StringUtils.repeat('b', 1);
    StringUtils.remove(""+1xx$"", ""Strings must not be null"");
    StringUtils.leftPad(""bY9!MMj+93d?}aW`"", 1, 'j');
    char[] charArray0 = new char[5];
    charArray0[0] = 'b';
    charArray0[1] = '(';
    charArray0[2] = 'b';
    charArray0[3] = 'b';
    charArray0[4] = 'j';
    StringUtils.containsAny((CharSequence) ""\""#[1w^^+,k'!"", charArray0);
}",""
"// Contains
//-----------------------------------------------------------------------
/**
 * <p>Checks if CharSequence contains a search character, handling {@code null}.
 * This method uses {@link String#indexOf(int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("""") CharSequence will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.contains(null, *)    = false
 * StringUtils.contains("""", *)      = false
 * StringUtils.contains(""abc"", 'a') = true
 * StringUtils.contains(""abc"", 'z') = false
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @return true if the CharSequence contains the search character,
 *  false if not or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from contains(String, int) to contains(CharSequence, int)
 */
public static boolean contains(CharSequence seq, int searchChar) {
    if (isEmpty(seq)) {
        return false;
    }
    return CharSequenceUtils.indexOf(seq, searchChar, 0) >= 0;
}","public void test186271() throws Throwable {
    StringUtils.substringBetween(""j/N"", ""j/N"", ""j/N"");
    StringUtils.isBlank((CharSequence) null);
    StringUtils.isAlphanumeric((CharSequence) null);
    StringUtils.substringAfterLast(""grpthJx"", ""o@Y{XTWFk9nQ%;`~}G#"");
    StringUtils.defaultString((String) null, ""*6*?LyY~g'!2A"");
    StringUtils.leftPad(""grpthJx"", 32, ""j/N"");
    StringUtils.contains((CharSequence) """", 0);
}",""
"public static int indexOf(CharSequence seq, CharSequence searchSeq) {
    if (seq == null || searchSeq == null) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.indexOf(seq, searchSeq, 0);
}","public void test187272() throws Throwable {
    StringUtils.substringAfterLast("", Length: 0"", (String) null);
    StringUtils.abbreviateMiddle("", Length: 0"", ""Vct(=6"", (-517));
    StringUtils.defaultIfEmpty(""J~XD'tM!v9S3V1f&z"", "", Length: 0"");
    StringUtils.indexOf((CharSequence) ""J~XD'tM!v9S3V1f&z"", (CharSequence) "", Length: 0"");
}","/**
 * <p>Finds the first index within a CharSequence, handling {@code null}.
 * This method uses {@link String#indexOf(String, int)} if possible.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOf(null, *)          = -1
 * StringUtils.indexOf(*, null)          = -1
 * StringUtils.indexOf("""", """")           = 0
 * StringUtils.indexOf("""", *)            = -1 (except when * = """")
 * StringUtils.indexOf(""aabaabaa"", ""a"")  = 0
 * StringUtils.indexOf(""aabaabaa"", ""b"")  = 2
 * StringUtils.indexOf(""aabaabaa"", ""ab"") = 1
 * StringUtils.indexOf(""aabaabaa"", """")   = 0
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchSeq  the CharSequence to find, may be null
 * @return the first index of the search CharSequence,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from indexOf(String, String) to indexOf(CharSequence, CharSequence)
 */"
"public static int lastIndexOf(CharSequence seq, int searchChar, int startPos) {
    if (isEmpty(seq)) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.lastIndexOf(seq, searchChar, startPos);
}","public void test188273() throws Throwable {
    String[] stringArray0 = StringUtils.split(""-xr'3"");
    StringUtils.join((Object[]) stringArray0, 'V', 65, 64);
    StringUtils.ordinalIndexOf("""", ""-xr'3"", 4920);
    Locale locale0 = Locale.CHINESE;
    Locale locale1 = Locale.JAPANESE;
    locale0.getDisplayVariant(locale1);
    StringUtils.lowerCase("""", locale0);
    StringUtils.substringAfter("""", ""The character must not be null"");
    StringUtils.repeat("""", ""UjZfDTY!n5h{_X"", (-1));
    StringUtils.lastIndexOf((CharSequence) """", (-1), Integer.MAX_VALUE);
}","/**
 * <p>Finds the last index within a CharSequence from a start position,
 * handling {@code null}.
 * This method uses {@link String#lastIndexOf(int, int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("""") CharSequence will return {@code -1}.
 * A negative start position returns {@code -1}.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOf(null, *, *)          = -1
 * StringUtils.lastIndexOf("""", *,  *)           = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 8)  = 5
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 4)  = 2
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 0)  = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 9)  = 5
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', -1) = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'a', 0)  = 0
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @param startPos  the start position
 * @return the last index of the search character,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from lastIndexOf(String, int, int) to lastIndexOf(CharSequence, int, int)
 */"
"public static String replaceEach(String text, String[] searchList, String[] replacementList) {
    return replaceEach(text, searchList, replacementList, false, 0);
}","public void test189274() throws Throwable {
    String[] stringArray0 = new String[9];
    stringArray0[0] = "".K0"";
    stringArray0[1] = """";
    stringArray0[2] = """";
    stringArray0[3] = """";
    stringArray0[4] = ""org.apache.commons.lang3.CharUtils"";
    stringArray0[5] = ""IllegalAccessException occurred"";
    stringArray0[6] = ""java.text.Normalizer"";
    stringArray0[7] = """";
    stringArray0[8] = ""Arguments cannot both be null"";
    String[] stringArray1 = StringUtils.stripAll(stringArray0);
    Locale locale0 = Locale.UK;
    locale0.getUnicodeLocaleKeys();
    Locale locale1 = Locale.CANADA_FRENCH;
    locale0.getDisplayLanguage(locale1);
    Locale.setDefault(locale0);
    StringUtils.upperCase("""", locale0);
    StringUtils.isNotBlank("""");
    StringUtils.lastIndexOfAny(""org.apache.commons.lang3.CharUtils"", stringArray1);
    StringUtils.removeStart(""7J>'"", "".K0"");
    StringUtils.substringBetween(""anglais"", """", (String) null);
    StringUtils.isAlphanumericSpace(""7J>'"");
    StringUtils.replaceEach((String) null, stringArray1, stringArray0);
}","/**
 * <p>
 * Replaces all occurrences of Strings within another String.
 * </p>
 *
 * <p>
 * A {@code null} reference passed to this method is a no-op, or if
 * any ""search string"" or ""string to replace"" is null, that replace will be
 * ignored. This will not repeat. For repeating replaces, call the
 * overloaded method.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *)        = null
 *  StringUtils.replaceEach("""", *, *)          = """"
 *  StringUtils.replaceEach(""aba"", null, null) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[0], null) = ""aba""
 *  StringUtils.replaceEach(""aba"", null, new String[0]) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, null)  = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""})  = ""b""
 *  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""})  = ""aba""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""})  = ""wcte""
 *  (example of how it does not repeat)
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""})  = ""dcte""
 * </pre>
 *
 * @param text
 *            text to search and replace in, no-op if null
 * @param searchList
 *            the Strings to search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @return the text with any replacements processed, {@code null} if
 *         null String input
 * @throws IndexOutOfBoundsException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */"
"public static int lastIndexOfAny(CharSequence str, CharSequence... searchStrs) {
    if (str == null || searchStrs == null) {
        return INDEX_NOT_FOUND;
    }
    int sz = searchStrs.length;
    int ret = INDEX_NOT_FOUND;
    int tmp = 0;
    for (int i = 0; i < sz; i++) {
        CharSequence search = searchStrs[i];
        if (search == null) {
            continue;
        }
        tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());
        if (tmp > ret) {
            ret = tmp;
        }
    }
    return ret;
}","public void test190275() throws Throwable {
    String string0 = StringUtils.leftPad(""org.apache.commons.lang3.CharUtils"", 1374, ""Kg"");
    StringUtils.isBlank(""org.apache.commons.lang3.CharUtils"");
    CharSequence[] charSequenceArray0 = new CharSequence[9];
    charSequenceArray0[0] = (CharSequence) ""org.apache.commons.lang3.CharUtils"";
    StringUtils.chomp(""H#SP\""<<\""O6D3V"", ""org.apache.commons.lang3.CharUtils"");
    charSequenceArray0[1] = (CharSequence) ""H#SP\""<<\""O6D3V"";
    charSequenceArray0[2] = (CharSequence) ""Kg"";
    charSequenceArray0[3] = (CharSequence) ""Kg"";
    charSequenceArray0[4] = (CharSequence) string0;
    charSequenceArray0[5] = (CharSequence) ""Kg"";
    charSequenceArray0[6] = (CharSequence) ""Kg"";
    charSequenceArray0[7] = (CharSequence) string0;
    charSequenceArray0[8] = (CharSequence) ""Kg"";
    StringUtils.lastIndexOfAny(""org.apache.commons.lang3.CharUtils"", charSequenceArray0);
}","/**
 * <p>Find the latest index of any of a set of potential substrings.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A {@code null} search array will return {@code -1}.
 * A {@code null} or zero length search array entry will be ignored,
 * but a search array containing """" will return the length of {@code str}
 * if {@code str} is not null. This method uses {@link String#indexOf(String)} if possible</p>
 *
 * <pre>
 * StringUtils.lastIndexOfAny(null, *)                   = -1
 * StringUtils.lastIndexOfAny(*, null)                   = -1
 * StringUtils.lastIndexOfAny(*, [])                     = -1
 * StringUtils.lastIndexOfAny(*, [null])                 = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""ab"",""cd""]) = 6
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""cd"",""ab""]) = 6
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""op""]) = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""op""]) = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""""])   = 10
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStrs  the CharSequences to search for, may be null
 * @return the last index of any of the CharSequences, -1 if no match
 * @since 3.0 Changed signature from lastIndexOfAny(String, String[]) to lastIndexOfAny(CharSequence, CharSequence)
 */"
"public static int indexOfIgnoreCase(CharSequence str, CharSequence searchStr, int startPos) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    if (startPos < 0) {
        startPos = 0;
    }
    int endLimit = (str.length() - searchStr.length()) + 1;
    if (startPos > endLimit) {
        return INDEX_NOT_FOUND;
    }
    if (searchStr.length() == 0) {
        return startPos;
    }
    for (int i = startPos; i < endLimit; i++) {
        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test191276() throws Throwable {
    StringUtils.leftPad(""{}"", 2, 'F');
    StringUtils.isAlphaSpace(""{}"");
    StringUtils.length(""{}"");
    StringUtils.isAsciiPrintable(""{}"");
    StringUtils.trimToEmpty(""{}"");
    StringUtils.chomp(""gd`C/N^cpZ7TG"");
    StringUtils.abbreviate(""y<$'"", 1074);
    StringUtils.isBlank(""y<$'"");
    String[] stringArray0 = StringUtils.splitByWholeSeparator(""h*WTr2VvSxUyL+j"", ""\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000B\f\r\u000E\u000F\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001A\u001B\u001C\u001D\u001E\u001F !\""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}~"");
    StringUtils.lastIndexOfAny(""\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000B\f\r\u000E\u000F\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001A\u001B\u001C\u001D\u001E\u001F !\""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}~"", stringArray0);
    StringUtils.isNumeric(""h*WTr2VvSxUyL+j"");
    StringUtils.join(stringArray0);
    StringUtils.replaceOnce((String) null, ""zxt#O6PZC"", ""\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000B\f\r\u000E\u000F\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001A\u001B\u001C\u001D\u001E\u001F !\""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}~"");
    StringUtils.isAlpha(""\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000B\f\r\u000E\u000F\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001A\u001B\u001C\u001D\u001E\u001F !\""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}~"");
    StringUtils.indexOfIgnoreCase((CharSequence) ""{}"", (CharSequence) null, 172);
}","/**
 * <p>Case in-sensitive find of the first index within a CharSequence
 * from the specified position.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A negative start position is treated as zero.
 * An empty ("""") search CharSequence always matches.
 * A start position greater than the string length only matches
 * an empty search CharSequence.</p>
 *
 * <pre>
 * StringUtils.indexOfIgnoreCase(null, *, *)          = -1
 * StringUtils.indexOfIgnoreCase(*, null, *)          = -1
 * StringUtils.indexOfIgnoreCase("""", """", 0)           = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""A"", 0)  = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", 0)  = 2
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""AB"", 0) = 1
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", 3)  = 5
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", 9)  = -1
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", -1) = 2
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", """", 2)   = 2
 * StringUtils.indexOfIgnoreCase(""abc"", """", 9)        = 3
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @param startPos  the start position, negative treated as zero
 * @return the first index of the search CharSequence,
 *  -1 if no match or {@code null} string input
 * @since 2.5
 * @since 3.0 Changed signature from indexOfIgnoreCase(String, String, int) to indexOfIgnoreCase(CharSequence, CharSequence, int)
 */"
"// IndexOfAny strings
//-----------------------------------------------------------------------
/**
 * <p>Find the first index of any of a set of potential substrings.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A {@code null} or zero length search array will return {@code -1}.
 * A {@code null} search array entry will be ignored, but a search
 * array containing """" will return {@code 0} if {@code str} is not
 * null. This method uses {@link String#indexOf(String)} if possible.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)                     = -1
 * StringUtils.indexOfAny(*, null)                     = -1
 * StringUtils.indexOfAny(*, [])                       = -1
 * StringUtils.indexOfAny(""zzabyycdxx"", [""ab"",""cd""])   = 2
 * StringUtils.indexOfAny(""zzabyycdxx"", [""cd"",""ab""])   = 2
 * StringUtils.indexOfAny(""zzabyycdxx"", [""mn"",""op""])   = -1
 * StringUtils.indexOfAny(""zzabyycdxx"", [""zab"",""aby""]) = 1
 * StringUtils.indexOfAny(""zzabyycdxx"", [""""])          = 0
 * StringUtils.indexOfAny("""", [""""])                    = 0
 * StringUtils.indexOfAny("""", [""a""])                   = -1
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStrs  the CharSequences to search for, may be null
 * @return the first index of any of the searchStrs in str, -1 if no match
 * @since 3.0 Changed signature from indexOfAny(String, String[]) to indexOfAny(CharSequence, CharSequence...)
 */
public static int indexOfAny(CharSequence str, CharSequence... searchStrs) {
    if (str == null || searchStrs == null) {
        return INDEX_NOT_FOUND;
    }
    int sz = searchStrs.length;
    // String's can't have a MAX_VALUEth index.
    int ret = Integer.MAX_VALUE;
    int tmp = 0;
    for (int i = 0; i < sz; i++) {
        CharSequence search = searchStrs[i];
        if (search == null) {
            continue;
        }
        tmp = CharSequenceUtils.indexOf(str, search, 0);
        if (tmp == INDEX_NOT_FOUND) {
            continue;
        }
        if (tmp < ret) {
            ret = tmp;
        }
    }
    return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret;
}","public void test192277() throws Throwable {
    StringUtils.leftPad(""The Array must not be null"", 32, """");
    StringUtils.substringBefore(""The Array must not be null"", ""      The Array must not be null"");
    StringUtils.swapCase("""");
    StringUtils.isAlpha(""The Array must not be null"");
    StringUtils.leftPad("" ENlz#w5Z"", 5);
    StringUtils.containsIgnoreCase("""", ""      The Array must not be null"");
    StringUtils.reverse("""");
    StringUtils.substring(""org.apache.commons.lang3.StringUtils"", 5);
    StringUtils.rightPad(""TimeToLive of "", 5, ""The Array must not be null"");
    StringUtils.equals((CharSequence) """", (CharSequence) ""TimeToLive of "");
    StringUtils.isAsciiPrintable("" ENlz#w5Z"");
    CharSequence[] charSequenceArray0 = new CharSequence[2];
    charSequenceArray0[0] = (CharSequence) ""org.apache.commons.lang3.StringUtils"";
    charSequenceArray0[1] = (CharSequence) ""pache.commons.lang3.StringUtils"";
    StringUtils.indexOfAny((CharSequence) ""TimeToLive of "", charSequenceArray0);
}",""
"public static String trimToNull(String str) {
    String ts = trim(str);
    return isEmpty(ts) ? null : ts;
}","public void test193278() throws Throwable {
    StringUtils.trimToEmpty(""IllegalAccessException occurred"");
    StringUtils.isAlpha(""IllegalAccessException occurred"");
    StringUtils.defaultIfBlank(""IllegalAccessException occurred"", ""IllegalAccessException occurred"");
    StringUtils.trimToNull(""`8W1c"");
}","/**
 * <p>Removes control characters (char &lt;= 32) from both
 * ends of this String returning {@code null} if the String is
 * empty ("""") after the trim or if it is {@code null}.
 *
 * <p>The String is trimmed using {@link String#trim()}.
 * Trim removes start and end characters &lt;= 32.
 * To strip whitespace use {@link #stripToNull(String)}.</p>
 *
 * <pre>
 * StringUtils.trimToNull(null)          = null
 * StringUtils.trimToNull("""")            = null
 * StringUtils.trimToNull(""     "")       = null
 * StringUtils.trimToNull(""abc"")         = ""abc""
 * StringUtils.trimToNull(""    abc    "") = ""abc""
 * </pre>
 *
 * @param str  the String to be trimmed, may be null
 * @return the trimmed String,
 *  {@code null} if only chars &lt;= 32, empty or null String input
 * @since 2.0
 */"
"public static int lastIndexOfAny(CharSequence str, CharSequence... searchStrs) {
    if (str == null || searchStrs == null) {
        return INDEX_NOT_FOUND;
    }
    int sz = searchStrs.length;
    int ret = INDEX_NOT_FOUND;
    int tmp = 0;
    for (int i = 0; i < sz; i++) {
        CharSequence search = searchStrs[i];
        if (search == null) {
            continue;
        }
        tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());
        if (tmp > ret) {
            ret = tmp;
        }
    }
    return ret;
}","public void test194279() throws Throwable {
    String string0 = ""\\u0"";
    StringUtils.substringAfterLast(string0, string0);
    StringUtils.indexOf((CharSequence) """", 13, 115);
    StringUtils.center("""", 121);
    String[] stringArray0 = StringUtils.splitByWholeSeparator(string0, """", (-3059));
    StringUtils.lastIndexOfAny(""                                                                                                                         "", stringArray0);
}","/**
 * <p>Find the latest index of any of a set of potential substrings.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A {@code null} search array will return {@code -1}.
 * A {@code null} or zero length search array entry will be ignored,
 * but a search array containing """" will return the length of {@code str}
 * if {@code str} is not null. This method uses {@link String#indexOf(String)} if possible</p>
 *
 * <pre>
 * StringUtils.lastIndexOfAny(null, *)                   = -1
 * StringUtils.lastIndexOfAny(*, null)                   = -1
 * StringUtils.lastIndexOfAny(*, [])                     = -1
 * StringUtils.lastIndexOfAny(*, [null])                 = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""ab"",""cd""]) = 6
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""cd"",""ab""]) = 6
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""op""]) = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""op""]) = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""""])   = 10
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStrs  the CharSequences to search for, may be null
 * @return the last index of any of the CharSequences, -1 if no match
 * @since 3.0 Changed signature from lastIndexOfAny(String, String[]) to lastIndexOfAny(CharSequence, CharSequence)
 */"
"public static String leftPad(String str, int size, String padStr) {
    if (str == null) {
        return null;
    }
    if (isEmpty(padStr)) {
        padStr = "" "";
    }
    int padLen = padStr.length();
    int strLen = str.length();
    int pads = size - strLen;
    if (pads <= 0) {
        // returns original String when possible
        return str;
    }
    if (padLen == 1 && pads <= PAD_LIMIT) {
        return leftPad(str, size, padStr.charAt(0));
    }
    if (pads == padLen) {
        return padStr.concat(str);
    } else if (pads < padLen) {
        return padStr.substring(0, pads).concat(str);
    } else {
        char[] padding = new char[pads];
        char[] padChars = padStr.toCharArray();
        for (int i = 0; i < pads; i++) {
            padding[i] = padChars[i % padLen];
        }
        return new String(padding).concat(str);
    }
}","public void test196281() throws Throwable {
    StringUtils.leftPad("""", 10, """");
}","/**
 * <p>Left pad a String with a specified String.</p>
 *
 * <p>Pad to a size of {@code size}.</p>
 *
 * <pre>
 * StringUtils.leftPad(null, *, *)      = null
 * StringUtils.leftPad("""", 3, ""z"")      = ""zzz""
 * StringUtils.leftPad(""bat"", 3, ""yz"")  = ""bat""
 * StringUtils.leftPad(""bat"", 5, ""yz"")  = ""yzbat""
 * StringUtils.leftPad(""bat"", 8, ""yz"")  = ""yzyzybat""
 * StringUtils.leftPad(""bat"", 1, ""yz"")  = ""bat""
 * StringUtils.leftPad(""bat"", -1, ""yz"") = ""bat""
 * StringUtils.leftPad(""bat"", 5, null)  = ""  bat""
 * StringUtils.leftPad(""bat"", 5, """")    = ""  bat""
 * </pre>
 *
 * @param str  the String to pad out, may be null
 * @param size  the size to pad to
 * @param padStr  the String to pad with, null or empty treated as single space
 * @return left padded String or original String if no padding is necessary,
 *  {@code null} if null String input
 */"
"public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {
    return splitWorker(str, separatorChars, max, true);
}","public void test197282() throws Throwable {
    StringUtils.rightPad(""LBMrr9v,V^?& 5+{ "", (-532));
    StringUtils.defaultString(""LBMrr9v,V^?& 5+{ "", ""LBMrr9v,V^?& 5+{ "");
    StringUtils.remove(""LBMrr9v,V^?& 5+{ "", 'w');
    StringUtils.stripAccents(""LBMrr9v,V^?& 5+{ "");
    StringUtils.substringsBetween("""", (String) null, ""', is neither of type Map.Entry nor an Array"");
    StringUtils.startsWith(""LBMrr9v,V^?& 5+{ "", ""LBMrr9v,V^?& 5+{ "");
    StringUtils.lastOrdinalIndexOf((CharSequence) null, ""LBMrr9v,V^?& 5+{ "", (-532));
    StringUtils.capitalize(""The String must not be empty"");
    StringUtils.stripAll((String[]) null);
    StringUtils.indexOfDifference((CharSequence[]) null);
    StringUtils.equals((CharSequence) ""The String must not be empty"", (CharSequence) ""LBMrr9v,V^?& 5+{ "");
    StringUtils.splitPreserveAllTokens("""", ""Mq/|@510"", (-532));
}","/**
 * <p>Splits the provided text into an array with a maximum length,
 * separators specified, preserving all tokens, including empty tokens
 * created by adjacent separators.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as separators for empty tokens.
 * Adjacent separators are treated as one separator.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} separatorChars splits on whitespace.</p>
 *
 * <p>If more than {@code max} delimited substrings are found, the last
 * returned string includes all characters after the first {@code max - 1}
 * returned strings (including separator characters).</p>
 *
 * <pre>
 * StringUtils.splitPreserveAllTokens(null, *, *)            = null
 * StringUtils.splitPreserveAllTokens("""", *, *)              = []
 * StringUtils.splitPreserveAllTokens(""ab de fg"", null, 0)   = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 0) = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef"", "":"", 0)    = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef"", "":"", 2)    = [""ab"", ""cd:ef""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 2) = [""ab"", ""  de fg""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 3) = [""ab"", """", "" de fg""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 4) = [""ab"", """", """", ""de fg""]
 * </pre>
 *
 * @param str  the String to parse, may be {@code null}
 * @param separatorChars  the characters used as the delimiters,
 *  {@code null} splits on whitespace
 * @param max  the maximum number of elements to include in the
 *  array. A zero or negative value implies no limit
 * @return an array of parsed Strings, {@code null} if null String input
 * @since 2.1
 */"
"// LastIndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the last index within a CharSequence, handling {@code null}.
 * This method uses {@link String#lastIndexOf(int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("""") CharSequence will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.lastIndexOf(null, *)         = -1
 * StringUtils.lastIndexOf("""", *)           = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'a') = 7
 * StringUtils.lastIndexOf(""aabaabaa"", 'b') = 5
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @return the last index of the search character,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from lastIndexOf(String, int) to lastIndexOf(CharSequence, int)
 */
public static int lastIndexOf(CharSequence seq, int searchChar) {
    if (isEmpty(seq)) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.lastIndexOf(seq, searchChar, seq.length());
}","public void test198283() throws Throwable {
    StringWriter stringWriter0 = new StringWriter(3193);
    char[] charArray0 = new char[9];
    charArray0[0] = 'V';
    charArray0[1] = 'j';
    charArray0[2] = 'j';
    charArray0[3] = '5';
    charArray0[4] = '7';
    charArray0[5] = '`';
    charArray0[6] = '<';
    charArray0[7] = 'G';
    charArray0[8] = '&';
    stringWriter0.write(charArray0);
    String string0 = StringUtils.repeat("""", ""pb"", 3193);
    StringWriter stringWriter1 = stringWriter0.append((CharSequence) string0);
    StringWriter stringWriter2 = stringWriter1.append(' ');
    StringBuffer stringBuffer0 = stringWriter2.getBuffer();
    StringUtils.lastIndexOf((CharSequence) stringBuffer0, 3193);
}",""
"public static String upperCase(String str, Locale locale) {
    if (str == null) {
        return null;
    }
    return str.toUpperCase(locale);
}","public void test200285() throws Throwable {
    String string0 = """";
    StringUtils.rightPad("""", (-643), """");
    StringUtils.repeat("""", 0);
    // Undeclared exception!
    try {
        StringUtils.upperCase("""", (Locale) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
    }
}","/**
 * <p>Converts a String to upper case as per {@link String#toUpperCase(Locale)}.</p>
 *
 * <p>A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.upperCase(null, Locale.ENGLISH)  = null
 * StringUtils.upperCase("""", Locale.ENGLISH)    = """"
 * StringUtils.upperCase(""aBc"", Locale.ENGLISH) = ""ABC""
 * </pre>
 *
 * @param str  the String to upper case, may be null
 * @param locale  the locale that defines the case transformation rules, must not be null
 * @return the upper cased String, {@code null} if null String input
 * @since 2.5
 */"
"// IndexOfAny chars
//-----------------------------------------------------------------------
/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A {@code null} String will return {@code -1}.
 * A {@code null} or zero length search array will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)                = -1
 * StringUtils.indexOfAny("""", *)                  = -1
 * StringUtils.indexOfAny(*, null)                = -1
 * StringUtils.indexOfAny(*, [])                  = -1
 * StringUtils.indexOfAny(""zzabyycdxx"",['z','a']) = 0
 * StringUtils.indexOfAny(""zzabyycdxx"",['b','y']) = 3
 * StringUtils.indexOfAny(""aba"", ['z'])           = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAny(String, char[]) to indexOfAny(CharSequence, char...)
 */
public static int indexOfAny(CharSequence cs, char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int csLen = cs.length();
    int csLast = csLen - 1;
    int searchLen = searchChars.length;
    int searchLast = searchLen - 1;
    for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
                    // ch is a supplementary character
                    if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        return i;
                    }
                } else {
                    return i;
                }
            }
        }
    }
    return INDEX_NOT_FOUND;
}","public void test201286() throws Throwable {
    StringUtils.normalizeSpace(""D[J=DRd5=:Uh"");
    StringUtils.removeStart(""_sU4ZY\""mO$_]o[3"", ""decompose"");
    StringUtils.defaultString(""_sU4ZY\""mO$_]o[3"");
    char[] charArray0 = new char[5];
    charArray0[0] = '7';
    charArray0[1] = ')';
    charArray0[2] = ';';
    charArray0[3] = 'O';
    charArray0[4] = 'C';
    StringUtils.indexOfAny((CharSequence) ""D[J=DRd5=:Uh"", charArray0);
}",""
"public static String[] substringsBetween(String str, String open, String close) {
    if (str == null || isEmpty(open) || isEmpty(close)) {
        return null;
    }
    int strLen = str.length();
    if (strLen == 0) {
        return ArrayUtils.EMPTY_STRING_ARRAY;
    }
    int closeLen = close.length();
    int openLen = open.length();
    List<String> list = new ArrayList<String>();
    int pos = 0;
    while (pos < (strLen - closeLen)) {
        int start = str.indexOf(open, pos);
        if (start < 0) {
            break;
        }
        start += openLen;
        int end = str.indexOf(close, start);
        if (end < 0) {
            break;
        }
        list.add(str.substring(start, end));
        pos = end + closeLen;
    }
    if (list.isEmpty()) {
        return null;
    }
    return list.toArray(new String[list.size()]);
}","public void test202287() throws Throwable {
    StringUtils.replaceChars(""s`5k"", ""s`5k"", ""s`5k"");
    StringUtils.difference(""U"", ""IllegalAccessException occurred"");
    CharSequence[] charSequenceArray0 = new CharSequence[0];
    StringUtils.startsWithAny(""IllegalAccessException occurred"", charSequenceArray0);
    String[] stringArray0 = StringUtils.splitByWholeSeparatorPreserveAllTokens(""IllegalAccessException occurred"", (String) null);
    String string0 = StringUtils.leftPad(""s`5k"", 1960);
    String string1 = StringUtils.strip(string0, """");
    char[] charArray0 = new char[0];
    StringUtils.containsNone((CharSequence) string0, charArray0);
    StringUtils.chop("""");
    StringUtils.stripEnd(""s`5k"", (String) null);
    StringUtils.lastOrdinalIndexOf(""U"", ""s`5k"", (-1743));
    StringUtils.indexOfIgnoreCase((CharSequence) string1, (CharSequence) ""U"");
    StringUtils.lastIndexOf((CharSequence) ""s`5k"", (CharSequence) """", 1960);
    StringUtils.normalizeSpace(""s`5k"");
    StringUtils.ordinalIndexOf("""", """", 1);
    StringUtils.replaceChars("""", """", "" is less than 0: "");
    StringUtils.startsWithIgnoreCase(""s`5k"", """");
    StringUtils.contains((CharSequence) string0, 0);
    StringUtils.left("" is less than 0: "", 4035);
    StringUtils.replaceEachRepeatedly("""", stringArray0, stringArray0);
    StringUtils.startsWithAny("""", stringArray0);
    StringUtils.rightPad("""", (-1743));
    StringUtils.substringsBetween("""", ""', is neither of type Map.Entry nor an Array"", ""java.text.Normalizer"");
}","/**
 * <p>Searches a String for substrings delimited by a start and end tag,
 * returning all matching substrings in an array.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} open/close returns {@code null} (no match).
 * An empty ("""") open/close returns {@code null} (no match).</p>
 *
 * <pre>
 * StringUtils.substringsBetween(""[a][b][c]"", ""["", ""]"") = [""a"",""b"",""c""]
 * StringUtils.substringsBetween(null, *, *)            = null
 * StringUtils.substringsBetween(*, null, *)            = null
 * StringUtils.substringsBetween(*, *, null)            = null
 * StringUtils.substringsBetween("""", ""["", ""]"")          = []
 * </pre>
 *
 * @param str  the String containing the substrings, null returns null, empty returns empty
 * @param open  the String identifying the start of the substring, empty returns null
 * @param close  the String identifying the end of the substring, empty returns null
 * @return a String Array of substrings, or {@code null} if no match
 * @since 2.3
 */"
"public static String[] substringsBetween(String str, String open, String close) {
    if (str == null || isEmpty(open) || isEmpty(close)) {
        return null;
    }
    int strLen = str.length();
    if (strLen == 0) {
        return ArrayUtils.EMPTY_STRING_ARRAY;
    }
    int closeLen = close.length();
    int openLen = open.length();
    List<String> list = new ArrayList<String>();
    int pos = 0;
    while (pos < (strLen - closeLen)) {
        int start = str.indexOf(open, pos);
        if (start < 0) {
            break;
        }
        start += openLen;
        int end = str.indexOf(close, start);
        if (end < 0) {
            break;
        }
        list.add(str.substring(start, end));
        pos = end + closeLen;
    }
    if (list.isEmpty()) {
        return null;
    }
    return list.toArray(new String[list.size()]);
}","public void test203288() throws Throwable {
    StringUtils.replaceChars(""s`5k"", ""s`5k"", ""s`5k"");
    StringUtils.difference(""U"", ""IllegalAccessException occurred"");
    CharSequence[] charSequenceArray0 = new CharSequence[0];
    StringUtils.startsWithAny(""IllegalAccessException occurred"", charSequenceArray0);
    String[] stringArray0 = StringUtils.splitByWholeSeparatorPreserveAllTokens(""IllegalAccessException occurred"", (String) null);
    String string0 = StringUtils.leftPad(""s`5k"", 1960);
    String string1 = StringUtils.strip(string0, """");
    char[] charArray0 = new char[0];
    StringUtils.containsNone((CharSequence) string0, charArray0);
    StringUtils.chop("""");
    StringUtils.stripEnd(""s`5k"", (String) null);
    StringUtils.lastOrdinalIndexOf(""U"", ""s`5k"", (-1743));
    StringUtils.indexOfIgnoreCase((CharSequence) string1, (CharSequence) ""U"");
    StringUtils.lastIndexOf((CharSequence) ""s`5k"", (CharSequence) """", 1960);
    String string2 = StringUtils.replaceChars(string0, """", "" is less than 0: "");
    StringUtils.startsWithIgnoreCase(""s`5k"", """");
    StringUtils.contains((CharSequence) string0, 0);
    StringUtils.left("" is less than 0: "", 4035);
    StringUtils.replaceEachRepeatedly("""", stringArray0, stringArray0);
    StringUtils.startsWithAny("""", stringArray0);
    StringUtils.rightPad("""", (-1743));
    StringUtils.substringsBetween(string2, ""', is neither of type Map.Entry nor an Array"", ""java.text.Normalizer"");
}","/**
 * <p>Searches a String for substrings delimited by a start and end tag,
 * returning all matching substrings in an array.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} open/close returns {@code null} (no match).
 * An empty ("""") open/close returns {@code null} (no match).</p>
 *
 * <pre>
 * StringUtils.substringsBetween(""[a][b][c]"", ""["", ""]"") = [""a"",""b"",""c""]
 * StringUtils.substringsBetween(null, *, *)            = null
 * StringUtils.substringsBetween(*, null, *)            = null
 * StringUtils.substringsBetween(*, *, null)            = null
 * StringUtils.substringsBetween("""", ""["", ""]"")          = []
 * </pre>
 *
 * @param str  the String containing the substrings, null returns null, empty returns empty
 * @param open  the String identifying the start of the substring, empty returns null
 * @param close  the String identifying the end of the substring, empty returns null
 * @return a String Array of substrings, or {@code null} if no match
 * @since 2.3
 */"
"public static String join(Object[] array, char separator, int startIndex, int endIndex) {
    if (array == null) {
        return null;
    }
    int noOfItems = (endIndex - startIndex);
    if (noOfItems <= 0) {
        return EMPTY;
    }
    StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}","public void test204289() throws Throwable {
    StringUtils.indexOfDifference((CharSequence[]) null);
    StringUtils.indexOfDifference((CharSequence[]) null);
    PriorityQueue<Locale.FilteringMode> priorityQueue0 = new PriorityQueue<Locale.FilteringMode>();
    Iterator<Locale.FilteringMode> iterator0 = priorityQueue0.iterator();
    StringUtils.join(iterator0, ""L@$!Ft!bp "");
    StringUtils.lastIndexOf((CharSequence) """", 64);
    StringUtils.stripEnd(""L@$!Ft!bp "", ""L@$!Ft!bp "");
    StringUtils.indexOf((CharSequence) """", (CharSequence) """", 0);
    StringUtils.rightPad(""L@$!Ft!bp "", (-1));
    Locale.FilteringMode locale_FilteringMode0 = Locale.FilteringMode.REJECT_EXTENDED_RANGES;
    priorityQueue0.add(locale_FilteringMode0);
    StringUtils.replaceChars(""L@$!Ft!bp "", 'k', 'I');
    StringUtils.mid("""", (-1), (-1));
    StringUtils.isAlphanumericSpace(""L@$!Ft!bp "");
    StringUtils.defaultString(""sh [P#W6*\""H%0y-"");
    StringUtils.difference("""", ""L@$!Ft!bp "");
    StringUtils.stripToEmpty("""");
    String[] stringArray0 = StringUtils.split("".rI+YP"", 'I');
    StringUtils.endsWith("""", "".rI+YP"");
    StringUtils.containsOnly((CharSequence) ""sh [P#W6*\""H%0y-"", "".rI+YP"");
    StringUtils.replaceEachRepeatedly(""<WdedVE/eE5ip!"", stringArray0, stringArray0);
    StringUtils.isEmpty(""sh [P#W6*\""H%0y-"");
    // Undeclared exception!
    try {
        StringUtils.join((Object[]) stringArray0, 'I', 0, 64);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 2
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)               = null
 * StringUtils.join([], *)                 = """"
 * StringUtils.join([null], *)             = """"
 * StringUtils.join([""a"", ""b"", ""c""], ';')  = ""a;b;c""
 * StringUtils.join([""a"", ""b"", ""c""], null) = ""abc""
 * StringUtils.join([null, """", ""a""], ';')  = "";;a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use
 * @param startIndex the first index to start joining from.  It is
 * an error to pass in an end index past the end of the array
 * @param endIndex the index to stop joining from (exclusive). It is
 * an error to pass in an end index past the end of the array
 * @return the joined String, {@code null} if null array input
 * @since 2.0
 */"
"// StripAll
//-----------------------------------------------------------------------
/**
 * <p>Strips whitespace from the start and end of every String in an array.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <p>A new array is returned each time, except for length zero.
 * A {@code null} array will return {@code null}.
 * An empty array will return itself.
 * A {@code null} array entry will be ignored.</p>
 *
 * <pre>
 * StringUtils.stripAll(null)             = null
 * StringUtils.stripAll([])               = []
 * StringUtils.stripAll([""abc"", ""  abc""]) = [""abc"", ""abc""]
 * StringUtils.stripAll([""abc  "", null])  = [""abc"", null]
 * </pre>
 *
 * @param strs  the array to remove whitespace from, may be null
 * @return the stripped Strings, {@code null} if null array input
 */
public static String[] stripAll(String... strs) {
    return stripAll(strs, null);
}","public void test205290() throws Throwable {
    StringUtils.replaceChars("""", ""6Ms,Y@"", ""6Ms,Y@"");
    StringUtils.indexOfDifference((CharSequence) """", (CharSequence) ""6Ms,Y@"");
    StringUtils.trimToNull(""IllegalAccessException occurred"");
    StringUtils.replaceOnce("", Length: "", """", """");
    String[] stringArray0 = new String[4];
    stringArray0[0] = ""IllegalAccessException occurred"";
    stringArray0[1] = "", Length: "";
    stringArray0[2] = "", Length: "";
    stringArray0[3] = ""6Ms,Y@"";
    StringUtils.stripAll(stringArray0);
}",""
"public static int indexOfAnyBut(CharSequence seq, CharSequence searchChars) {
    if (isEmpty(seq) || isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int strLen = seq.length();
    for (int i = 0; i < strLen; i++) {
        char ch = seq.charAt(i);
        boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0;
        if (i + 1 < strLen && Character.isHighSurrogate(ch)) {
            char ch2 = seq.charAt(i + 1);
            if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) {
                return i;
            }
        } else {
            if (!chFound) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}","public void test206291() throws Throwable {
    StringUtils.replaceEachRepeatedly(""p{InCombiningDiacriticalMarks}+"", (String[]) null, (String[]) null);
    StringUtils.indexOfAny((CharSequence) ""p{InCombiningDiacriticalMarks}+"", (CharSequence[]) null);
    StringUtils.indexOfAnyBut((CharSequence) ""p{InCombiningDiacriticalMarks}+"", (CharSequence) ""p{InCombiningDiacriticalMarks}+"");
    StringUtils.equalsIgnoreCase(""p{InCombiningDiacriticalMarks}+"", ""p{InCombiningDiacriticalMarks}+"");
    StringUtils.center(""p{InCombiningDiacriticalMarks}+"", (-1), '\""');
    char[] charArray0 = new char[2];
    charArray0[0] = '\""';
    charArray0[1] = '\""';
    StringUtils.containsAny((CharSequence) ""p{InCombiningDiacriticalMarks}+"", charArray0);
    StringUtils.swapCase(""p{InCombiningDiacriticalMarks}+"");
    StringUtils.indexOfDifference((CharSequence[]) null);
    StringUtils.isNumericSpace(""P{iNcOMBININGdIACRITICALmARKS}+"");
    StringUtils.indexOfAnyBut((CharSequence) null, (CharSequence) ""p{InCombiningDiacriticalMarks}+"");
}","/**
 * <p>Search a CharSequence to find the first index of any
 * character not in the given set of characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A {@code null} or empty search string will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAnyBut(null, *)            = -1
 * StringUtils.indexOfAnyBut("""", *)              = -1
 * StringUtils.indexOfAnyBut(*, null)            = -1
 * StringUtils.indexOfAnyBut(*, """")              = -1
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", ""za"") = 3
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", """")   = -1
 * StringUtils.indexOfAnyBut(""aba"",""ab"")         = -1
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAnyBut(String, String) to indexOfAnyBut(CharSequence, CharSequence)
 */"
"public static boolean containsIgnoreCase(CharSequence str, CharSequence searchStr) {
    if (str == null || searchStr == null) {
        return false;
    }
    int len = searchStr.length();
    int max = str.length() - len;
    for (int i = 0; i <= max; i++) {
        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) {
            return true;
        }
    }
    return false;
}","public void test207292() throws Throwable {
    StringUtils.substringBefore(""sun.text.Normalizer"", ""BBfd~=8mQGb3A"");
    StringUtils.strip(""BBfd~=8mQGb3A"", ""sun.text.Normalizer"");
    String[] stringArray0 = StringUtils.splitByWholeSeparator(""BBfd~=8mQGb3A"", ""sun.text.Normalizer"");
    StringUtils.remove(""BBfd~=8mQGb3A"", '8');
    StringUtils.trimToNull(""p{InCombiningDiacriticalMarks}+"");
    StringUtils.substring(""BBfd~=mQGb3A"", (-2134));
    StringUtils.join((Object[]) stringArray0, (String) null);
    StringUtils.containsIgnoreCase(""sun.text.Normalizer"", ""p{InCombiningDiacriticalMarks}+"");
}","/**
 * <p>Checks if CharSequence contains a search CharSequence irrespective of case,
 * handling {@code null}. Case-insensitivity is defined as by
 * {@link String#equalsIgnoreCase(String)}.
 *
 * <p>A {@code null} CharSequence will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.contains(null, *) = false
 * StringUtils.contains(*, null) = false
 * StringUtils.contains("""", """") = true
 * StringUtils.contains(""abc"", """") = true
 * StringUtils.contains(""abc"", ""a"") = true
 * StringUtils.contains(""abc"", ""z"") = false
 * StringUtils.contains(""abc"", ""A"") = true
 * StringUtils.contains(""abc"", ""Z"") = false
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @return true if the CharSequence contains the search CharSequence irrespective of
 * case or false if not or {@code null} string input
 * @since 3.0 Changed signature from containsIgnoreCase(String, String) to containsIgnoreCase(CharSequence, CharSequence)
 */"
"public static String remove(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    return replace(str, remove, EMPTY, -1);
}","public void test208293() throws Throwable {
    StringUtils.substringBefore("" vs "", "" vs "");
    char[] charArray0 = new char[5];
    charArray0[0] = 'n';
    charArray0[1] = '}';
    charArray0[2] = 't';
    charArray0[3] = '3';
    charArray0[4] = 'o';
    StringUtils.indexOfAny((CharSequence) """", charArray0);
    StringUtils.startsWith("" vs "", """");
    StringUtils.containsWhitespace("" vs "");
    CharSequence[] charSequenceArray0 = new CharSequence[0];
    StringUtils.startsWithAny("""", charSequenceArray0);
    StringUtils.stripToEmpty("""");
    StringUtils.substringBetween(""<dXp"", """", ""5HM>QGNI:>qN"");
    StringUtils.substring("""", 4);
    StringUtils.remove("""", '$');
    StringUtils.equalsIgnoreCase(""5HM>QGNI:>qN"", """");
    StringUtils.deleteWhitespace("""");
    StringUtils.remove(""<dXp"", """");
}","/**
 * <p>Removes all occurrences of a substring from within the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("""") source string will return the empty string.
 * A {@code null} remove string will return the source string.
 * An empty ("""") remove string will return the source string.</p>
 *
 * <pre>
 * StringUtils.remove(null, *)        = null
 * StringUtils.remove("""", *)          = """"
 * StringUtils.remove(*, null)        = *
 * StringUtils.remove(*, """")          = *
 * StringUtils.remove(""queued"", ""ue"") = ""qd""
 * StringUtils.remove(""queued"", ""zz"") = ""queued""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for and remove, may be null
 * @return the substring with the string removed if found,
 *  {@code null} if null String input
 * @since 2.1
 */"
"// Delete
//-----------------------------------------------------------------------
/**
 * <p>Deletes all whitespaces from a String as defined by
 * {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.deleteWhitespace(null)         = null
 * StringUtils.deleteWhitespace("""")           = """"
 * StringUtils.deleteWhitespace(""abc"")        = ""abc""
 * StringUtils.deleteWhitespace(""   ab  c  "") = ""abc""
 * </pre>
 *
 * @param str  the String to delete whitespace from, may be null
 * @return the String without whitespaces, {@code null} if null String input
 */
public static String deleteWhitespace(String str) {
    if (isEmpty(str)) {
        return str;
    }
    int sz = str.length();
    char[] chs = new char[sz];
    int count = 0;
    for (int i = 0; i < sz; i++) {
        if (!Character.isWhitespace(str.charAt(i))) {
            chs[count++] = str.charAt(i);
        }
    }
    if (count == sz) {
        return str;
    }
    return new String(chs, 0, count);
}","public void test209294() throws Throwable {
    StringUtils stringUtils0 = new StringUtils();
    StringUtils.endsWith(""4T\""t0^@xkxA."", """");
    PriorityQueue<String> priorityQueue0 = new PriorityQueue<String>();
    Iterator<String> iterator0 = priorityQueue0.iterator();
    StringUtils.join(iterator0, 'Q');
    StringUtils.overlay(""UVwya%hoOyL"", (String) null, (-1), (-1));
    StringUtils.center(""4T\""t0^@xkxA."", (-1), 'P');
    StringUtils.startsWith("""", """");
    StringUtils.isAlphaSpace(""4T\""t0^@xkxA."");
    StringUtils.contains((CharSequence) null, (-1));
    StringUtils.leftPad(""UVwya%hoOyL"", 2340, '`');
    StringUtils.deleteWhitespace("""");
    StringUtils.deleteWhitespace(""{}"");
}",""
"public static boolean equalsIgnoreCase(CharSequence str1, CharSequence str2) {
    if (str1 == null || str2 == null) {
        return str1 == str2;
    } else {
        return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, Math.max(str1.length(), str2.length()));
    }
}","public void test210295() throws Throwable {
    StringUtils.deleteWhitespace(""{}"");
    StringUtils.equalsIgnoreCase(""{}"", ""{}"");
}","/**
 * <p>Compares two CharSequences, returning {@code true} if they are equal ignoring
 * the case.</p>
 *
 * <p>{@code null}s are handled without exceptions. Two {@code null}
 * references are considered equal. Comparison is case insensitive.</p>
 *
 * <pre>
 * StringUtils.equalsIgnoreCase(null, null)   = true
 * StringUtils.equalsIgnoreCase(null, ""abc"")  = false
 * StringUtils.equalsIgnoreCase(""abc"", null)  = false
 * StringUtils.equalsIgnoreCase(""abc"", ""abc"") = true
 * StringUtils.equalsIgnoreCase(""abc"", ""ABC"") = true
 * </pre>
 *
 * @param str1  the first CharSequence, may be null
 * @param str2  the second CharSequence, may be null
 * @return {@code true} if the CharSequence are equal, case insensitive, or
 *  both {@code null}
 * @since 3.0 Changed signature from equalsIgnoreCase(String, String) to equalsIgnoreCase(CharSequence, CharSequence)
 */"
"public static String join(Iterable<?> iterable, char separator) {
    if (iterable == null) {
        return null;
    }
    return join(iterable.iterator(), separator);
}","public void test211296() throws Throwable {
    StringUtils.substringAfter("" "", "" "");
    StringUtils.split((String) null, 'K');
    char[] charArray0 = new char[1];
    charArray0[0] = 'K';
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    StringUtils.reverseDelimited(""xt"", 'J');
    charBuffer0.append((CharSequence) ""xt"", 0, 0);
    StringUtils.defaultIfBlank(charBuffer0, charBuffer0);
    StringUtils.splitPreserveAllTokens("" "", (String) null, 0);
    String[] stringArray0 = new String[7];
    stringArray0[0] = "" "";
    stringArray0[1] = "" "";
    stringArray0[2] = ""sun.text.Normalizer"";
    stringArray0[3] = ""xt"";
    stringArray0[4] = ""xt"";
    stringArray0[5] = ""sun.text.Normalizer"";
    stringArray0[6] = ""xt"";
    StringUtils.replaceEach(""sun.text.Normalizer"", stringArray0, (String[]) null);
    StringUtils.containsWhitespace("" "");
    StringUtils.join((Iterable<?>) null, 'K');
}","/**
 * <p>Joins the elements of the provided {@code Iterable} into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list. Null objects or empty
 * strings within the iteration are represented by empty strings.</p>
 *
 * <p>See the examples here: {@link #join(Object[],char)}. </p>
 *
 * @param iterable  the {@code Iterable} providing the values to join together, may be null
 * @param separator  the separator character to use
 * @return the joined String, {@code null} if null iterator input
 * @since 2.3
 */"
"// ContainsOnly
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains only certain characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.
 * A {@code null} valid character array will return {@code false}.
 * An empty CharSequence (length()=0) always returns {@code true}.</p>
 *
 * <pre>
 * StringUtils.containsOnly(null, *)       = false
 * StringUtils.containsOnly(*, null)       = false
 * StringUtils.containsOnly("""", *)         = true
 * StringUtils.containsOnly(""ab"", '')      = false
 * StringUtils.containsOnly(""abab"", 'abc') = true
 * StringUtils.containsOnly(""ab1"", 'abc')  = false
 * StringUtils.containsOnly(""abz"", 'abc')  = false
 * </pre>
 *
 * @param cs  the String to check, may be null
 * @param valid  an array of valid chars, may be null
 * @return true if it only contains valid chars and is non-null
 * @since 3.0 Changed signature from containsOnly(String, char[]) to containsOnly(CharSequence, char...)
 */
public static boolean containsOnly(CharSequence cs, char... valid) {
    // All these pre-checks are to maintain API with an older version
    if (valid == null || cs == null) {
        return false;
    }
    if (cs.length() == 0) {
        return true;
    }
    if (valid.length == 0) {
        return false;
    }
    return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND;
}","public void test212297() throws Throwable {
    StringUtils.reverse((String) null);
    StringUtils.replaceOnce((String) null, (String) null, (String) null);
    StringUtils.lastIndexOf((CharSequence) null, 1135);
    StringUtils.isAlpha((CharSequence) null);
    String[] stringArray0 = new String[1];
    stringArray0[0] = null;
    StringUtils.replaceEach((String) null, stringArray0, stringArray0);
    StringUtils.isBlank((CharSequence) null);
    StringUtils.rightPad(""'-6Zz^j "", 128);
    StringUtils.containsIgnoreCase((CharSequence) null, (CharSequence) null);
    StringUtils.startsWithAny(""'-6Zz^j                                                                                                                         "", stringArray0);
    String string0 = StringUtils.EMPTY;
    StringUtils.containsNone((CharSequence) """", ""|hac:cA74j"");
    char[] charArray0 = new char[8];
    charArray0[0] = '+';
    charArray0[1] = '';
    charArray0[2] = 'O';
    charArray0[3] = '_';
    charArray0[4] = 'j';
    charArray0[5] = '{';
    charArray0[6] = 'l';
    charArray0[7] = 'D';
    StringUtils.containsOnly((CharSequence) null, charArray0);
}",""
"// Abbreviating
//-----------------------------------------------------------------------
/**
 * <p>Abbreviates a String using ellipses. This will turn
 * ""Now is the time for all good men"" into ""Now is the time for...""</p>
 *
 * <p>Specifically:
 * <ul>
 *   <li>If {@code str} is less than {@code maxWidth} characters
 *       long, return it.</li>
 *   <li>Else abbreviate it to {@code (substring(str, 0, max-3) + ""..."")}.</li>
 *   <li>If {@code maxWidth} is less than {@code 4}, throw an
 *       {@code IllegalArgumentException}.</li>
 *   <li>In no case will it return a String of length greater than
 *       {@code maxWidth}.</li>
 * </ul>
 * </p>
 *
 * <pre>
 * StringUtils.abbreviate(null, *)      = null
 * StringUtils.abbreviate("""", 4)        = """"
 * StringUtils.abbreviate(""abcdefg"", 6) = ""abc...""
 * StringUtils.abbreviate(""abcdefg"", 7) = ""abcdefg""
 * StringUtils.abbreviate(""abcdefg"", 8) = ""abcdefg""
 * StringUtils.abbreviate(""abcdefg"", 4) = ""a...""
 * StringUtils.abbreviate(""abcdefg"", 3) = IllegalArgumentException
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param maxWidth  maximum length of result String, must be at least 4
 * @return abbreviated String, {@code null} if null String input
 * @throws IllegalArgumentException if the width is too small
 * @since 2.0
 */
public static String abbreviate(String str, int maxWidth) {
    return abbreviate(str, 0, maxWidth);
}","public void test213298() throws Throwable {
    StringUtils.reverse((String) null);
    StringUtils.center(""org.apache.commons.lang3.StringUtils"", 13, (String) null);
    StringUtils.indexOf((CharSequence) null, (CharSequence) ""org.apache.commons.lang3.StringUtils"", 13);
    StringUtils.indexOfDifference((CharSequence) ""org.apache.commons.lang3.StringUtils"", (CharSequence) null);
    StringUtils.replaceChars(""org.apache.commons.lang3.StringUtils"", ""org.apache.commons.lang3.StringUtils"", ""{}"");
    StringUtils.remove(""normalize"", 'A');
    StringUtils.isAlphaSpace((CharSequence) null);
    StringUtils.indexOfIgnoreCase((CharSequence) ""org.apache.commons.lang3.StringUtils"", (CharSequence) ""org.apache.commons.lang3.StringUtils"");
    StringUtils.indexOf((CharSequence) ""{}"", (CharSequence) ""normalize"", 0);
    StringUtils.containsAny((CharSequence) null, (CharSequence) null);
    StringUtils.lastIndexOf((CharSequence) ""{}{{}"", (CharSequence) ""org.apache.commons.lang3.StringUtils"");
    StringUtils.rightPad("""", (-1), 'A');
    StringUtils.normalizeSpace(""SecurityException occurred"");
    StringUtils.equalsIgnoreCase((CharSequence) null, ""{}{{}"");
    StringUtils.indexOf((CharSequence) ""org.apache.commons.lang3.StringUtils"", (CharSequence) """");
    StringUtils.split(""{}"");
    // Undeclared exception!
    try {
        StringUtils.abbreviate(""normalize"", (-181));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Minimum abbreviation width is 4
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}",""
"public static String replace(String text, String searchString, String replacement, int max) {
    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {
        return text;
    }
    int start = 0;
    int end = text.indexOf(searchString, start);
    if (end == INDEX_NOT_FOUND) {
        return text;
    }
    int replLength = searchString.length();
    int increase = replacement.length() - replLength;
    increase = (increase < 0 ? 0 : increase);
    increase *= (max < 0 ? 16 : (max > 64 ? 64 : max));
    StringBuilder buf = new StringBuilder(text.length() + increase);
    while (end != INDEX_NOT_FOUND) {
        buf.append(text.substring(start, end)).append(replacement);
        start = end + replLength;
        if (--max == 0) {
            break;
        }
        end = text.indexOf(searchString, start);
    }
    buf.append(text.substring(start));
    return buf.toString();
}","public void test214299() throws Throwable {
    StringUtils.stripEnd("" LU~)n)q"", "" LU~)n)q"");
    StringUtils.indexOfAny((CharSequence) """", ""h+$PA 'vC\""uL"");
    Stack<Integer> stack0 = new Stack<Integer>();
    ListIterator<Integer> listIterator0 = stack0.listIterator();
    StringUtils.join((Iterator<?>) listIterator0, '1');
    StringUtils.join((Iterator<?>) listIterator0, 'f');
    String[] stringArray0 = StringUtils.split("""", "" LU~)n)q"");
    StringUtils.normalizeSpace("""");
    StringUtils.containsOnly((CharSequence) """", (String) null);
    StringUtils.normalizeSpace("""");
    StringUtils.replaceEach(""!F%"", stringArray0, stringArray0);
    String string0 = ""\\u000"";
    StringUtils.replace(string0, """", ""b'"", (-909));
}","/**
 * <p>Replaces a String with another String inside a larger String,
 * for the first {@code max} values of the search String.</p>
 *
 * <p>A {@code null} reference passed to this method is a no-op.</p>
 *
 * <pre>
 * StringUtils.replace(null, *, *, *)         = null
 * StringUtils.replace("""", *, *, *)           = """"
 * StringUtils.replace(""any"", null, *, *)     = ""any""
 * StringUtils.replace(""any"", *, null, *)     = ""any""
 * StringUtils.replace(""any"", """", *, *)       = ""any""
 * StringUtils.replace(""any"", *, *, 0)        = ""any""
 * StringUtils.replace(""abaa"", ""a"", null, -1) = ""abaa""
 * StringUtils.replace(""abaa"", ""a"", """", -1)   = ""b""
 * StringUtils.replace(""abaa"", ""a"", ""z"", 0)   = ""abaa""
 * StringUtils.replace(""abaa"", ""a"", ""z"", 1)   = ""zbaa""
 * StringUtils.replace(""abaa"", ""a"", ""z"", 2)   = ""zbza""
 * StringUtils.replace(""abaa"", ""a"", ""z"", -1)  = ""zbzz""
 * </pre>
 *
 * @param text  text to search and replace in, may be null
 * @param searchString  the String to search for, may be null
 * @param replacement  the String to replace it with, may be null
 * @param max  maximum number of values to replace, or {@code -1} if no maximum
 * @return the text with any replacements processed,
 *  {@code null} if null String input
 */"
"// ContainsOnly
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains only certain characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.
 * A {@code null} valid character array will return {@code false}.
 * An empty CharSequence (length()=0) always returns {@code true}.</p>
 *
 * <pre>
 * StringUtils.containsOnly(null, *)       = false
 * StringUtils.containsOnly(*, null)       = false
 * StringUtils.containsOnly("""", *)         = true
 * StringUtils.containsOnly(""ab"", '')      = false
 * StringUtils.containsOnly(""abab"", 'abc') = true
 * StringUtils.containsOnly(""ab1"", 'abc')  = false
 * StringUtils.containsOnly(""abz"", 'abc')  = false
 * </pre>
 *
 * @param cs  the String to check, may be null
 * @param valid  an array of valid chars, may be null
 * @return true if it only contains valid chars and is non-null
 * @since 3.0 Changed signature from containsOnly(String, char[]) to containsOnly(CharSequence, char...)
 */
public static boolean containsOnly(CharSequence cs, char... valid) {
    // All these pre-checks are to maintain API with an older version
    if (valid == null || cs == null) {
        return false;
    }
    if (cs.length() == 0) {
        return true;
    }
    if (valid.length == 0) {
        return false;
    }
    return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND;
}","public void test215300() throws Throwable {
    StringUtils.stripAccents(""Nr^(1xOB~2p?'BUBaY:"");
    StringUtils.difference(""Nr^(1xOB~2p?'BUBaY:"", ""Nr^(1xOB~2p?'BUBaY:"");
    StringUtils.replace(""l9LX?r]"", """", ""Nr^(1xOB~2p?'BUBaY:"");
    StringUtils.containsAny((CharSequence) ""l9LX?r]"", (char[]) null);
    StringUtils.splitByWholeSeparatorPreserveAllTokens("""", ""Nr^(1xOB~2p?'BUBaY:"");
    StringUtils.center(""l9LX?r]"", 0, ""Hkb@,M#"");
    StringUtils.replace(""Nr^(1xOB~2p?'BUBaY:"", ""Hkb@,M#"", ""-*,As4,pZrJ"");
    StringUtils.containsOnly((CharSequence) ""Nr^(1xOB~2p?'BUBaY:"", (char[]) null);
}",""
"// Contains
//-----------------------------------------------------------------------
/**
 * <p>Checks if CharSequence contains a search character, handling {@code null}.
 * This method uses {@link String#indexOf(int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("""") CharSequence will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.contains(null, *)    = false
 * StringUtils.contains("""", *)      = false
 * StringUtils.contains(""abc"", 'a') = true
 * StringUtils.contains(""abc"", 'z') = false
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @return true if the CharSequence contains the search character,
 *  false if not or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from contains(String, int) to contains(CharSequence, int)
 */
public static boolean contains(CharSequence seq, int searchChar) {
    if (isEmpty(seq)) {
        return false;
    }
    return CharSequenceUtils.indexOf(seq, searchChar, 0) >= 0;
}","public void test216301() throws Throwable {
    StringUtils.indexOfAnyBut((CharSequence) null, (CharSequence) null);
    StringUtils stringUtils0 = new StringUtils();
    char[] charArray0 = new char[2];
    charArray0[0] = '4';
    charArray0[1] = 'v';
    StringUtils.containsAny((CharSequence) """", charArray0);
    StringUtils.containsIgnoreCase((CharSequence) null, """");
    StringUtils.contains((CharSequence) null, 0);
}",""
"public static String[] splitByCharacterType(String str) {
    return splitByCharacterType(str, false);
}","public void test217302() throws Throwable {
    StringUtils.substringBefore(""R"", ""R"");
    StringUtils.lastIndexOf((CharSequence) """", 256);
    StringUtils.isEmpty("""");
    StringUtils.isNotEmpty("""");
    StringUtils.remove(""R"", "" vs "");
    StringUtils.isNotEmpty("" vs "");
    StringUtils.splitByCharacterType("""");
}","/**
 * <p>Splits a String by Character type as returned by
 * {@code java.lang.Character.getType(char)}. Groups of contiguous
 * characters of the same type are returned as complete tokens.
 * <pre>
 * StringUtils.splitByCharacterType(null)         = null
 * StringUtils.splitByCharacterType("""")           = []
 * StringUtils.splitByCharacterType(""ab de fg"")   = [""ab"", "" "", ""de"", "" "", ""fg""]
 * StringUtils.splitByCharacterType(""ab   de fg"") = [""ab"", ""   "", ""de"", "" "", ""fg""]
 * StringUtils.splitByCharacterType(""ab:cd:ef"")   = [""ab"", "":"", ""cd"", "":"", ""ef""]
 * StringUtils.splitByCharacterType(""number5"")    = [""number"", ""5""]
 * StringUtils.splitByCharacterType(""fooBar"")     = [""foo"", ""B"", ""ar""]
 * StringUtils.splitByCharacterType(""foo200Bar"")  = [""foo"", ""200"", ""B"", ""ar""]
 * StringUtils.splitByCharacterType(""ASFRules"")   = [""ASFR"", ""ules""]
 * </pre>
 * @param str the String to split, may be {@code null}
 * @return an array of parsed Strings, {@code null} if null String input
 * @since 2.4
 */"
"// Centering
//-----------------------------------------------------------------------
/**
 * <p>Centers a String in a larger String of size {@code size}
 * using the space character (' ').<p>
 *
 * <p>If the size is less than the String length, the String is returned.
 * A {@code null} String returns {@code null}.
 * A negative size is treated as zero.</p>
 *
 * <p>Equivalent to {@code center(str, size, "" "")}.</p>
 *
 * <pre>
 * StringUtils.center(null, *)   = null
 * StringUtils.center("""", 4)     = ""    ""
 * StringUtils.center(""ab"", -1)  = ""ab""
 * StringUtils.center(""ab"", 4)   = "" ab ""
 * StringUtils.center(""abcd"", 2) = ""abcd""
 * StringUtils.center(""a"", 4)    = "" a  ""
 * </pre>
 *
 * @param str  the String to center, may be null
 * @param size  the int size of new String, negative treated as zero
 * @return centered String, {@code null} if null String input
 */
public static String center(String str, int size) {
    return center(str, size, ' ');
}","public void test218303() throws Throwable {
    StringUtils.replace("""", """", """");
    StringUtils.isAsciiPrintable("""");
    StringUtils.center("""", (-682), """");
    StringUtils.endsWithIgnoreCase("""", """");
    StringUtils.stripToNull("" 2l9!"");
    StringUtils.removeStart("""", "" 2l9!"");
    StringUtils.isNotBlank("""");
    StringUtils.lowerCase("""");
    Locale locale0 = Locale.GERMAN;
    StringUtils.lowerCase("" 2l9!"", locale0);
    StringUtils.repeat('6', 32);
    StringUtils.center(""Index: "", (-1));
}",""
"// Nested extraction
//-----------------------------------------------------------------------
// Splitting
//-----------------------------------------------------------------------
/**
 * <p>Splits the provided text into an array, using whitespace as the
 * separator.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as one separator.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.split(null)       = null
 * StringUtils.split("""")         = []
 * StringUtils.split(""abc def"")  = [""abc"", ""def""]
 * StringUtils.split(""abc  def"") = [""abc"", ""def""]
 * StringUtils.split("" abc "")    = [""abc""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @return an array of parsed Strings, {@code null} if null String input
 */
public static String[] split(String str) {
    return split(str, null, -1);
}","public void test219304() throws Throwable {
    StringUtils.replace(""&OK%lO@%Rp"", ""&OK%lO@%Rp"", ""&OK%lO@%Rp"");
    StringUtils.countMatches(""&OK%lO@%Rp"", ""&OK%lO@%Rp"");
    StringUtils.abbreviateMiddle(""&OK%lO@%Rp"", """", 1);
    StringUtils.endsWithIgnoreCase(""&OK%lO@%Rp"", """");
    StringUtils.startsWithIgnoreCase("""", ""&OK%lO@%Rp"");
    CharSequence[] charSequenceArray0 = new CharSequence[6];
    charSequenceArray0[0] = (CharSequence) """";
    charSequenceArray0[1] = (CharSequence) ""&OK%lO@%Rp"";
    charSequenceArray0[2] = (CharSequence) ""&OK%lO@%Rp"";
    charSequenceArray0[3] = (CharSequence) ""&OK%lO@%Rp"";
    StringUtils.rightPad("")->lf?z1% sH:jREt"", 1);
    charSequenceArray0[4] = (CharSequence) "")->lf?z1% sH:jREt"";
    charSequenceArray0[5] = (CharSequence) ""&OK%lO@%Rp"";
    StringUtils.endsWithAny(""&OK%lO@%Rp"", charSequenceArray0);
    StringUtils.leftPad(""a='<@]7\""SL)mnnj5"", 0);
    StringUtils.isAlpha(charSequenceArray0[0]);
    StringUtils.replace(""0sr$z5YcO{Qh!-"", ""}Hm%r0rXZ8h.m7{au("", ""n[K<x<t(FQREdV%aa$l"", 0);
    StringUtils.stripEnd(""~2\""aj"", ""decompose"");
    StringUtils.rightPad(""0sr$z5YcO{Qh!-"", 1, 'q');
    StringUtils.indexOfAnyBut((CharSequence) ""a='<@]7\""SL)mnnj5"", (CharSequence) ""n[K<x<t(FQREdV%aa$l"");
    StringUtils.uncapitalize(""ZZhL,Zvc~."");
    StringUtils.chomp(""'+d+{mVQlW"");
    StringUtils.isAlphaSpace(charSequenceArray0[3]);
    StringUtils.split(""d>-wRj[~]yZPH"");
}",""
"// LastIndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the last index within a CharSequence, handling {@code null}.
 * This method uses {@link String#lastIndexOf(int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("""") CharSequence will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.lastIndexOf(null, *)         = -1
 * StringUtils.lastIndexOf("""", *)           = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'a') = 7
 * StringUtils.lastIndexOf(""aabaabaa"", 'b') = 5
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @return the last index of the search character,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from lastIndexOf(String, int) to lastIndexOf(CharSequence, int)
 */
public static int lastIndexOf(CharSequence seq, int searchChar) {
    if (isEmpty(seq)) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.lastIndexOf(seq, searchChar, seq.length());
}","public void test220305() throws Throwable {
    StringUtils.splitByWholeSeparator(""YQp;IDCa&*"", ""{eZ\"" A#&`"", 1823);
    StringUtils.countMatches(""YQp;IDCa&*"", ""{eZ\"" A#&`"");
    StringUtils.replaceChars(""{eZ\"" A#&`"", 'E', 'W');
    StringUtils.left(""YQp;IDCa&*"", 1823);
    StringUtils.replace(""..."", ""YQp;IDCa&*"", ""..."", 1503);
    String string0 = StringUtils.repeat("""", ""The String must not be empty"", 65);
    StringUtils.isAllLowerCase(""..."");
    StringUtils.endsWithIgnoreCase(""..."", ""{eZ\"" A#&`"");
    StringUtils.lastIndexOf((CharSequence) string0, 0);
}",""
"public static String removeEnd(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (str.endsWith(remove)) {
        return str.substring(0, str.length() - remove.length());
    }
    return str;
}","public void test221306() throws Throwable {
    StringUtils.leftPad("""", 0);
    StringUtils.center("""", 0, 'L');
    StringUtils.removeEnd("""", """");
}","/**
 * <p>Removes a substring only if it is at the end of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("""") source string will return the empty string.
 * A {@code null} search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeEnd(null, *)      = null
 * StringUtils.removeEnd("""", *)        = """"
 * StringUtils.removeEnd(*, null)      = *
 * StringUtils.removeEnd(""www.domain.com"", "".com."")  = ""www.domain.com""
 * StringUtils.removeEnd(""www.domain.com"", "".com"")   = ""www.domain""
 * StringUtils.removeEnd(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeEnd(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for and remove, may be null
 * @return the substring with the string removed if found,
 *  {@code null} if null String input
 * @since 2.1
 */"
"// Misc
//-----------------------------------------------------------------------
/**
 * <p>Find the Levenshtein distance between two Strings.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>The previous implementation of the Levenshtein distance algorithm
 * was from <a href=""http://www.merriampark.com/ld.htm"">http://www.merriampark.com/ld.htm</a></p>
 *
 * <p>Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError
 * which can occur when my Java implementation is used with very large strings.<br>
 * This implementation of the Levenshtein distance algorithm
 * is from <a href=""http://www.merriampark.com/ldjava.htm"">http://www.merriampark.com/ldjava.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("""","""")               = 0
 * StringUtils.getLevenshteinDistance("""",""a"")              = 1
 * StringUtils.getLevenshteinDistance(""aaapppp"", """")       = 7
 * StringUtils.getLevenshteinDistance(""frog"", ""fog"")       = 1
 * StringUtils.getLevenshteinDistance(""fly"", ""ant"")        = 3
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""zzzzzzzz"") = 8
 * StringUtils.getLevenshteinDistance(""hello"", ""hallo"")    = 1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @return result distance
 * @throws IllegalArgumentException if either String input {@code null}
 * @since 3.0 Changed signature from getLevenshteinDistance(String, String) to
 * getLevenshteinDistance(CharSequence, CharSequence)
 */
public static int getLevenshteinDistance(CharSequence s, CharSequence t) {
    if (s == null || t == null) {
        throw new IllegalArgumentException(""Strings must not be null"");
    }
    /*
           The difference between this impl. and the previous is that, rather
           than creating and retaining a matrix of size s.length() + 1 by t.length() + 1,
           we maintain two single-dimensional arrays of length s.length() + 1.  The first, d,
           is the 'current working' distance array that maintains the newest distance cost
           counts as we iterate through the characters of String s.  Each time we increment
           the index of String t we are comparing, d is copied to p, the second int[].  Doing so
           allows us to retain the previous cost counts as required by the algorithm (taking
           the minimum of the cost count to the left, up one, and diagonally up and to the left
           of the current cost count being calculated).  (Note that the arrays aren't really
           copied anymore, just switched...this is clearly much better than cloning an array
           or doing a System.arraycopy() each time  through the outer loop.)

           Effectively, the difference between the two implementations is this one does not
           cause an out of memory condition when calculating the LD over two very large strings.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    if (n == 0) {
        return m;
    } else if (m == 0) {
        return n;
    }
    if (n > m) {
        // swap the input strings to consume less memory
        CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    //'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    //placeholder to assist in swapping p and d
    int[] _d;
    // indexes into strings s and t
    // iterates through s
    int i;
    // iterates through t
    int j;
    // jth character of t
    char t_j;
    // cost
    int cost;
    for (i = 0; i <= n; i++) {
        p[i] = i;
    }
    for (j = 1; j <= m; j++) {
        t_j = t.charAt(j - 1);
        d[0] = j;
        for (i = 1; i <= n; i++) {
            cost = s.charAt(i - 1) == t_j ? 0 : 1;
            // minimum of cell to the left+1, to the top+1, diagonally left and up +cost
            d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost);
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // our last action in the above loop was to switch d and p, so p now
    // actually has the most recent cost counts
    return p[n];
}","public void test222307() throws Throwable {
    StringUtils.remove(""Minimum abbreviation width with offset is 7"", ""Minimum abbreviation width with offset is 7"");
    StringUtils.isNotEmpty("""");
    StringUtils.indexOf((CharSequence) ""Minimum abbreviation width with offset is 7"", (CharSequence) """");
    char[] charArray0 = new char[0];
    StringUtils.containsAny((CharSequence) ""Minimum abbreviation width with offset is 7"", charArray0);
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    linkedHashSet0.add(""Minimum abbreviation width with offset is 7"");
    StringUtils.join((Iterable<?>) linkedHashSet0, 'b');
    StringUtils.abbreviate(""Minimum abbreviation width with offset is 7"", 57, 1872);
    StringUtils.defaultString("""", """");
    StringUtils.getLevenshteinDistance((CharSequence) ""Minimum abbreviation width with offset is 7"", (CharSequence) """");
}",""
"public static String repeat(char ch, int repeat) {
    char[] buf = new char[repeat];
    for (int i = repeat - 1; i >= 0; i--) {
        buf[i] = ch;
    }
    return new String(buf);
}","public void test223308() throws Throwable {
    String string0 = ""u0<R|@'"";
    int int0 = 0;
    StringUtils.center(""u0<R|@'"", 0, ""u0<R|@'"");
    String string1 = ""Cannot get the toString of a null identity"";
    StringUtils.substring(""Cannot get the toString of a null identity"", 0, 0);
    StringUtils.substringBetween(""Cannot get the toString of a null identity"", ""rr[Y1jd lPy*oG !J-?7SyC"", ""e >KyxW]tL^gwMXm8n/"");
    String[] stringArray0 = new String[6];
    stringArray0[0] = ""rr[Y1jd lPy*oG !J-?7SyC"";
    stringArray0[1] = ""u0<R|@'"";
    stringArray0[2] = ""x<_}S z)&g_9.80"";
    stringArray0[3] = null;
    stringArray0[4] = ""e >KyxW]tL^gwMXm8n/"";
    stringArray0[5] = ""e >KyxW]tL^gwMXm8n/"";
    String string2 = ""q1H8|SwM*"";
    StringUtils.stripAll(stringArray0, ""q1H8|SwM*"");
    StringUtils.leftPad("">"", 0, ']');
    StringUtils.splitByWholeSeparator(""rr[Y1jd lPy*oG !J-?7SyC"", """", (-1));
    StringUtils.stripToEmpty(""Qhj\""F!dPV6AR3rv"");
    StringUtils.indexOfAnyBut((CharSequence) ""q1H8|SwM*"", (CharSequence) "">"");
    // Undeclared exception!
    try {
        StringUtils.repeat(']', (-5553));
        fail(""Expecting exception: NegativeArraySizeException"");
    } catch (NegativeArraySizeException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}","/**
 * <p>Returns padding using the specified delimiter repeated
 * to a given length.</p>
 *
 * <pre>
 * StringUtils.repeat(0, 'e')  = """"
 * StringUtils.repeat(3, 'e')  = ""eee""
 * StringUtils.repeat(-2, 'e') = """"
 * </pre>
 *
 * <p>Note: this method doesn't not support padding with
 * <a href=""http://www.unicode.org/glossary/#supplementary_character"">Unicode Supplementary Characters</a>
 * as they require a pair of {@code char}s to be represented.
 * If you are needing to support full I18N of your applications
 * consider using {@link #repeat(String, int)} instead.
 * </p>
 *
 * @param ch  character to repeat
 * @param repeat  number of times to repeat char, negative treated as zero
 * @return String with repeated character
 * @see #repeat(String, int)
 */"
"// Overlay
//-----------------------------------------------------------------------
/**
 * <p>Overlays part of a String with another String.</p>
 *
 * <p>A {@code null} string input returns {@code null}.
 * A negative index is treated as zero.
 * An index greater than the string length is treated as the string length.
 * The start index is always the smaller of the two indices.</p>
 *
 * <pre>
 * StringUtils.overlay(null, *, *, *)            = null
 * StringUtils.overlay("""", ""abc"", 0, 0)          = ""abc""
 * StringUtils.overlay(""abcdef"", null, 2, 4)     = ""abef""
 * StringUtils.overlay(""abcdef"", """", 2, 4)       = ""abef""
 * StringUtils.overlay(""abcdef"", """", 4, 2)       = ""abef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 2, 4)   = ""abzzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 4, 2)   = ""abzzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", -1, 4)  = ""zzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 2, 8)   = ""abzzzz""
 * StringUtils.overlay(""abcdef"", ""zzzz"", -2, -3) = ""zzzzabcdef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 8, 10)  = ""abcdefzzzz""
 * </pre>
 *
 * @param str  the String to do overlaying in, may be null
 * @param overlay  the String to overlay, may be null
 * @param start  the position to start overlaying at
 * @param end  the position to stop overlaying before
 * @return overlayed String, {@code null} if null String input
 * @since 2.0
 */
public static String overlay(String str, String overlay, int start, int end) {
    if (str == null) {
        return null;
    }
    if (overlay == null) {
        overlay = EMPTY;
    }
    int len = str.length();
    if (start < 0) {
        start = 0;
    }
    if (start > len) {
        start = len;
    }
    if (end < 0) {
        end = 0;
    }
    if (end > len) {
        end = len;
    }
    if (start > end) {
        int temp = start;
        start = end;
        end = temp;
    }
    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();
}","public void test224309() throws Throwable {
    StringUtils.ordinalIndexOf((CharSequence) null, (CharSequence) null, 0);
    CharSequence[] charSequenceArray0 = new CharSequence[5];
    StringUtils.removeStartIgnoreCase("""", """");
    charSequenceArray0[0] = (CharSequence) """";
    charSequenceArray0[1] = null;
    charSequenceArray0[2] = null;
    charSequenceArray0[3] = null;
    charSequenceArray0[4] = null;
    StringUtils.endsWithAny((CharSequence) null, charSequenceArray0);
    Stack<String> stack0 = new Stack<String>();
    Iterator<String> iterator0 = stack0.iterator();
    StringUtils.join(iterator0, '6');
    StringUtils.uncapitalize("""");
    StringUtils.overlay("":a#%yP V$"", """", (-1), 1318);
}",""
"// From org.springframework.util.StringUtils, under Apache License 2.0
public static boolean containsWhitespace(CharSequence seq) {
    if (isEmpty(seq)) {
        return false;
    }
    int strLen = seq.length();
    for (int i = 0; i < strLen; i++) {
        if (Character.isWhitespace(seq.charAt(i))) {
            return true;
        }
    }
    return false;
}","public void test225310() throws Throwable {
    StringUtils.remove(""3.{(bV7!\t\""0g@:b(6"", ""!NjVE\"":o:'^od||M"");
    StringUtils.isAlphanumericSpace(""!NjVE\"":o:'^od||M"");
    StringUtils.isAlphanumeric(""3.{(bV7!\t\""0g@:b(6"");
    StringUtils.getLevenshteinDistance((CharSequence) ""3.{(bV7!\t\""0g@:b(6"", (CharSequence) ""3.{(bV7!\t\""0g@:b(6"", 2);
    StringUtils.leftPad(""3.{(bV7!\t\""0g@:b(6"", 0, '7');
    StringUtils.abbreviate((String) null, 0, 7);
    StringUtils.splitByWholeSeparator(""3.{(bV7!\t\""0g@:b(6"", """");
    StringUtils.contains((CharSequence) ""3.{(bV7!\t\""0g@:b(6"", 2);
    StringUtils.normalizeSpace(""rJ$e@BZ];s2;$V/D8"");
    StringUtils.overlay((String) null, """", 2, 2);
    ArrayList<Locale.LanguageRange> arrayList0 = new ArrayList<Locale.LanguageRange>();
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    List<String> list0 = Locale.filterTags((List<Locale.LanguageRange>) arrayList0, (Collection<String>) linkedHashSet0);
    LinkedList<String> linkedList0 = new LinkedList<String>(list0);
    ListIterator<String> listIterator0 = linkedList0.listIterator();
    StringUtils.join((Iterator<?>) listIterator0, 'K');
    StringUtils.trim("""");
    StringUtils.containsWhitespace("""");
}","/**
 * Check whether the given CharSequence contains any whitespace characters.
 * @param seq the CharSequence to check (may be {@code null})
 * @return {@code true} if the CharSequence is not empty and
 * contains at least 1 whitespace character
 * @see java.lang.Character#isWhitespace
 * @since 3.0
 */"
"public static int indexOfDifference(CharSequence cs1, CharSequence cs2) {
    if (cs1 == cs2) {
        return INDEX_NOT_FOUND;
    }
    if (cs1 == null || cs2 == null) {
        return 0;
    }
    int i;
    for (i = 0; i < cs1.length() && i < cs2.length(); ++i) {
        if (cs1.charAt(i) != cs2.charAt(i)) {
            break;
        }
    }
    if (i < cs2.length() || i < cs1.length()) {
        return i;
    }
    return INDEX_NOT_FOUND;
}","public void test226311() throws Throwable {
    StringUtils.remove(""org.apache.commons.lang3.CharUtils"", ""The String must not be empty"");
    StringUtils.isEmpty(""org.apache.commons.lang3.CharUtils"");
    StringUtils.indexOfDifference((CharSequence) ""org.apache.commons.lang3.CharUtils"", (CharSequence) ""The String must not be empty"");
}","/**
 * <p>Compares two CharSequences, and returns the index at which the
 * CharSequences begin to differ.</p>
 *
 * <p>For example,
 * {@code indexOfDifference(""i am a machine"", ""i am a robot"") -> 7}</p>
 *
 * <pre>
 * StringUtils.indexOfDifference(null, null) = -1
 * StringUtils.indexOfDifference("""", """") = -1
 * StringUtils.indexOfDifference("""", ""abc"") = 0
 * StringUtils.indexOfDifference(""abc"", """") = 0
 * StringUtils.indexOfDifference(""abc"", ""abc"") = -1
 * StringUtils.indexOfDifference(""ab"", ""abxyz"") = 2
 * StringUtils.indexOfDifference(""abcde"", ""abxyz"") = 2
 * StringUtils.indexOfDifference(""abcde"", ""xyz"") = 0
 * </pre>
 *
 * @param cs1  the first CharSequence, may be null
 * @param cs2  the second CharSequence, may be null
 * @return the index where cs1 and cs2 begin to differ; -1 if they are equal
 * @since 2.0
 * @since 3.0 Changed signature from indexOfDifference(String, String) to
 * indexOfDifference(CharSequence, CharSequence)
 */"
"public static String[] splitByWholeSeparator(String str, String separator, int max) {
    return splitByWholeSeparatorWorker(str, separator, max, false);
}","public void test227312() throws Throwable {
    StringUtils.defaultString(""*#2**{CEL%UK#:"");
    StringUtils.isAlphaSpace(""*#2**{CEL%UK#:"");
    StringUtils.isNumericSpace((CharSequence) null);
    StringUtils.split(""Threshold must not be negative"", 'A');
    StringUtils.indexOfIgnoreCase((CharSequence) ""*#2**{CEL%UK#:"", (CharSequence) ""Threshold must not be negative"");
    StringUtils.splitByWholeSeparator(""Threshold must not be negative"", """", 3877);
}","/**
 * <p>Splits the provided text into an array, separator string specified.
 * Returns a maximum of {@code max} substrings.</p>
 *
 * <p>The separator(s) will not be included in the returned String array.
 * Adjacent separators are treated as one separator.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} separator splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.splitByWholeSeparator(null, *, *)               = null
 * StringUtils.splitByWholeSeparator("""", *, *)                 = []
 * StringUtils.splitByWholeSeparator(""ab de fg"", null, 0)      = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparator(""ab   de fg"", null, 0)    = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparator(""ab:cd:ef"", "":"", 2)       = [""ab"", ""cd:ef""]
 * StringUtils.splitByWholeSeparator(""ab-!-cd-!-ef"", ""-!-"", 5) = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitByWholeSeparator(""ab-!-cd-!-ef"", ""-!-"", 2) = [""ab"", ""cd-!-ef""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @param separator  String containing the String to be used as a delimiter,
 *  {@code null} splits on whitespace
 * @param max  the maximum number of elements to include in the returned
 *  array. A zero or negative value implies no limit.
 * @return an array of parsed Strings, {@code null} if null String was input
 */"
"public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) {
    return StringUtils.isEmpty(str) ? defaultStr : str;
}","public void test228313() throws Throwable {
    StringUtils.containsWhitespace((CharSequence) null);
    String string0 = ""\\u000"";
    StringUtils.defaultIfEmpty(string0, ""tR6IA[g?Gz];(j"");
}","/**
 * <p>Returns either the passed in CharSequence, or if the CharSequence is
 * empty or {@code null}, the value of {@code defaultStr}.</p>
 *
 * <pre>
 * StringUtils.defaultIfEmpty(null, ""NULL"")  = ""NULL""
 * StringUtils.defaultIfEmpty("""", ""NULL"")    = ""NULL""
 * StringUtils.defaultIfEmpty(""bat"", ""NULL"") = ""bat""
 * StringUtils.defaultIfEmpty("""", null)      = null
 * </pre>
 * @param <T> the specific kind of CharSequence
 * @param str  the CharSequence to check, may be null
 * @param defaultStr  the default CharSequence to return
 *  if the input is empty ("""") or {@code null}, may be null
 * @return the passed in CharSequence, or the default
 * @see StringUtils#defaultString(String, String)
 */"
"public static boolean startsWithAny(CharSequence string, CharSequence... searchStrings) {
    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {
        return false;
    }
    for (int i = 0; i < searchStrings.length; i++) {
        CharSequence searchString = searchStrings[i];
        if (StringUtils.startsWith(string, searchString)) {
            return true;
        }
    }
    return false;
}","public void test229314() throws Throwable {
    StringUtils.stripEnd(""Minimum abbreviation width is 4"", """");
    StringUtils.containsAny((CharSequence) ""Minimum abbreviation width is 4"", (CharSequence) """");
    StringUtils.stripEnd(""Minimum abbreviation width is 4"", """");
    StringUtils.indexOfIgnoreCase((CharSequence) ""Minimum abbreviation width is 4"", (CharSequence) """");
    StringUtils.trim(""Minimum abbreviation width is 4"");
    Object[] objectArray0 = new Object[1];
    objectArray0[0] = (Object) """";
    StringUtils.join(objectArray0, 'g');
    StringUtils.uncapitalize(""Search and Replace array lengths don't match: "");
    StringUtils.right(""Search and Replace array lengths don't match: "", 0);
    CharSequence[] charSequenceArray0 = new CharSequence[7];
    charSequenceArray0[0] = (CharSequence) """";
    charSequenceArray0[1] = (CharSequence) """";
    charSequenceArray0[2] = (CharSequence) ""Minimum abbreviation width is 4"";
    charSequenceArray0[3] = (CharSequence) ""Search and Replace array lengths don't match: "";
    charSequenceArray0[4] = (CharSequence) ""Search and Replace array lengths don't match: "";
    charSequenceArray0[5] = (CharSequence) """";
    charSequenceArray0[6] = (CharSequence) ""Minimum abbreviation width is 4"";
    StringUtils.startsWithAny("""", charSequenceArray0);
}","/**
 * <p>Check if a CharSequence starts with any of an array of specified strings.</p>
 *
 * <pre>
 * StringUtils.startsWithAny(null, null)      = false
 * StringUtils.startsWithAny(null, new String[] {""abc""})  = false
 * StringUtils.startsWithAny(""abcxyz"", null)     = false
 * StringUtils.startsWithAny(""abcxyz"", new String[] {""""}) = false
 * StringUtils.startsWithAny(""abcxyz"", new String[] {""abc""}) = true
 * StringUtils.startsWithAny(""abcxyz"", new String[] {null, ""xyz"", ""abc""}) = true
 * </pre>
 *
 * @param string  the CharSequence to check, may be null
 * @param searchStrings the CharSequences to find, may be null or empty
 * @return {@code true} if the CharSequence starts with any of the the prefixes, case insensitive, or
 *  both {@code null}
 * @since 2.5
 * @since 3.0 Changed signature from startsWithAny(String, String[]) to startsWithAny(CharSequence, CharSequence...)
 */"
"public static String join(Iterator<?> iterator, String separator) {
    // handle null, zero and one elements before building a buffer
    if (iterator == null) {
        return null;
    }
    if (!iterator.hasNext()) {
        return EMPTY;
    }
    Object first = iterator.next();
    if (!iterator.hasNext()) {
        return ObjectUtils.toString(first);
    }
    // two or more elements
    // Java default is 16, probably too small
    StringBuilder buf = new StringBuilder(256);
    if (first != null) {
        buf.append(first);
    }
    while (iterator.hasNext()) {
        if (separator != null) {
            buf.append(separator);
        }
        Object obj = iterator.next();
        if (obj != null) {
            buf.append(obj);
        }
    }
    return buf.toString();
}","public void test230315() throws Throwable {
    StringUtils.substringBetween(""hItIVC=~!{Lx-"", ""{Y\r"", (String) null);
    StringUtils.stripStart(""l\""mZJ!:+~\""y|k\""vv&"", """");
    StringUtils.containsAny((CharSequence) null, (CharSequence) ""l\""mZJ!:+~\""y|k\""vv&"");
    StringUtils.substringBetween(""TimeToLive of "", ""bWjGI8'A_c*"", (String) null);
    StringUtils.lastIndexOfIgnoreCase((CharSequence) ""l\""mZJ!:+~\""y|k\""vv&"", (CharSequence) ""bWjGI8'A_c*"", 4);
    PriorityQueue<String> priorityQueue0 = new PriorityQueue<String>();
    Iterator<String> iterator0 = priorityQueue0.iterator();
    StringUtils.join(iterator0, ""The Array must not be null"");
}","/**
 * <p>Joins the elements of the provided {@code Iterator} into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A {@code null} separator is the same as an empty String ("""").</p>
 *
 * <p>See the examples here: {@link #join(Object[],String)}. </p>
 *
 * @param iterator  the {@code Iterator} of values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @return the joined String, {@code null} if null iterator input
 */"
"public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) {
    return StringUtils.isEmpty(str) ? defaultStr : str;
}","public void test231316() throws Throwable {
    StringUtils.rightPad(""uhsZfnd<-{UF+THH#@n"", (-507), ';');
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""uhsZfnd<-{UF+THH#@n"", """", (-507));
    StringUtils.left("""", (-4577));
    StringUtils.lastIndexOfAny(""uhsZfnd<-{UF+THH#@n"", stringArray0);
    char[] charArray0 = new char[7];
    charArray0[0] = ';';
    charArray0[1] = ';';
    charArray0[2] = ';';
    charArray0[3] = ';';
    charArray0[4] = ';';
    charArray0[5] = ';';
    charArray0[6] = ';';
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    StringUtils.defaultIfEmpty(charBuffer0, charBuffer0);
}","/**
 * <p>Returns either the passed in CharSequence, or if the CharSequence is
 * empty or {@code null}, the value of {@code defaultStr}.</p>
 *
 * <pre>
 * StringUtils.defaultIfEmpty(null, ""NULL"")  = ""NULL""
 * StringUtils.defaultIfEmpty("""", ""NULL"")    = ""NULL""
 * StringUtils.defaultIfEmpty(""bat"", ""NULL"") = ""bat""
 * StringUtils.defaultIfEmpty("""", null)      = null
 * </pre>
 * @param <T> the specific kind of CharSequence
 * @param str  the CharSequence to check, may be null
 * @param defaultStr  the default CharSequence to return
 *  if the input is empty ("""") or {@code null}, may be null
 * @return the passed in CharSequence, or the default
 * @see StringUtils#defaultString(String, String)
 */"
"public static String rightPad(String str, int size, char padChar) {
    if (str == null) {
        return null;
    }
    int pads = size - str.length();
    if (pads <= 0) {
        // returns original String when possible
        return str;
    }
    if (pads > PAD_LIMIT) {
        return rightPad(str, size, String.valueOf(padChar));
    }
    return str.concat(repeat(padChar, pads));
}","public void test232317() throws Throwable {
    StringUtils.splitPreserveAllTokens("""");
    StringUtils.trimToEmpty("""");
    StringUtils.removeEndIgnoreCase("""", """");
    StringUtils.replaceChars("""", '^', '^');
    StringUtils.chomp("""");
    StringUtils.splitByWholeSeparatorPreserveAllTokens(""`6!UM8#/n+Xz"", ""b~VyHhTa"", 12);
    StringUtils.rightPad("""", 12, '^');
}","/**
 * <p>Right pad a String with a specified character.</p>
 *
 * <p>The String is padded to the size of {@code size}.</p>
 *
 * <pre>
 * StringUtils.rightPad(null, *, *)     = null
 * StringUtils.rightPad("""", 3, 'z')     = ""zzz""
 * StringUtils.rightPad(""bat"", 3, 'z')  = ""bat""
 * StringUtils.rightPad(""bat"", 5, 'z')  = ""batzz""
 * StringUtils.rightPad(""bat"", 1, 'z')  = ""bat""
 * StringUtils.rightPad(""bat"", -1, 'z') = ""bat""
 * </pre>
 *
 * @param str  the String to pad out, may be null
 * @param size  the size to pad to
 * @param padChar  the character to pad with
 * @return right padded String or original String if no padding is necessary,
 *  {@code null} if null String input
 * @since 2.0
 */"
"public static String substring(String str, int start, int end) {
    if (str == null) {
        return null;
    }
    // handle negatives
    if (end < 0) {
        // remember end is negative
        end = str.length() + end;
    }
    if (start < 0) {
        // remember start is negative
        start = str.length() + start;
    }
    // check length next
    if (end > str.length()) {
        end = str.length();
    }
    // if start is greater than end, return """"
    if (start > end) {
        return EMPTY;
    }
    if (start < 0) {
        start = 0;
    }
    if (end < 0) {
        end = 0;
    }
    return str.substring(start, end);
}","public void test233318() throws Throwable {
    StringUtils.uncapitalize(""IllegalAccessException occurred"");
    StringUtils.ordinalIndexOf(""IllegalAccessException occurred"", ""illegalAccessException occurred"", (-1505));
    StringUtils.containsIgnoreCase(""IllegalAccessException occurred"", ""illegalAccessException occurred"");
    StringUtils.capitalize(""IllegalAccessException occurred"");
    StringUtils.splitByWholeSeparator(""0"", ""x<_}S z)&g_9.80"", (-1505));
    StringUtils.substring(""org.apache.commons.lang3.ArrayUtils"", 483, (-570));
}","/**
 * <p>Gets a substring from the specified String avoiding exceptions.</p>
 *
 * <p>A negative start position can be used to start/end {@code n}
 * characters from the end of the String.</p>
 *
 * <p>The returned substring starts with the character in the {@code start}
 * position and ends before the {@code end} position. All position counting is
 * zero-based -- i.e., to start at the beginning of the string use
 * {@code start = 0}. Negative start and end positions can be used to
 * specify offsets relative to the end of the String.</p>
 *
 * <p>If {@code start} is not strictly to the left of {@code end}, """"
 * is returned.</p>
 *
 * <pre>
 * StringUtils.substring(null, *, *)    = null
 * StringUtils.substring("""", * ,  *)    = """";
 * StringUtils.substring(""abc"", 0, 2)   = ""ab""
 * StringUtils.substring(""abc"", 2, 0)   = """"
 * StringUtils.substring(""abc"", 2, 4)   = ""c""
 * StringUtils.substring(""abc"", 4, 6)   = """"
 * StringUtils.substring(""abc"", 2, 2)   = """"
 * StringUtils.substring(""abc"", -2, -1) = ""b""
 * StringUtils.substring(""abc"", -4, 2)  = ""ab""
 * </pre>
 *
 * @param str  the String to get the substring from, may be null
 * @param start  the position to start from, negative means
 *  count back from the end of the String by this many characters
 * @param end  the position to end at (exclusive), negative means
 *  count back from the end of the String by this many characters
 * @return substring from start position to end positon,
 *  {@code null} if null String input
 */"
"public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {
    // timeToLive should be 0 if not used or nothing to replace, else it's
    // the length of the replace array
    int timeToLive = searchList == null ? 0 : searchList.length;
    return replaceEach(text, searchList, replacementList, true, timeToLive);
}","public void test234319() throws Throwable {
    StringUtils.strip(""}=rvj9:"");
    StringUtils.stripStart("""", ""}=rvj9:"");
    char[] charArray0 = new char[3];
    charArray0[0] = '%';
    charArray0[1] = '9';
    charArray0[2] = '~';
    StringUtils.containsOnly((CharSequence) ""}=rvj9:"", charArray0);
    StringUtils.chop("""");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""}=rvj9:"");
    StringUtils.lowerCase(""> FNW0uFPtx!%"");
    StringUtils.overlay(""w}?TDcHSVa_C\u0000]"", """", 0, 0);
    String string0 = ""xs{\\*:,"";
    StringUtils.uncapitalize(""xs{*:,"");
    StringUtils.defaultString(""Index: "");
    String string1 = ""The character "";
    String[] stringArray1 = StringUtils.splitByCharacterTypeCamelCase(""The character "");
    StringUtils.indexOfDifference((CharSequence[]) stringArray0);
    // Undeclared exception!
    try {
        StringUtils.replaceEachRepeatedly(""> fnw0ufptx!%"", stringArray1, stringArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Search and Replace array lengths don't match: 4 vs 1
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}","/**
 * <p>
 * Replaces all occurrences of Strings within another String.
 * </p>
 *
 * <p>
 * A {@code null} reference passed to this method is a no-op, or if
 * any ""search string"" or ""string to replace"" is null, that replace will be
 * ignored. This will not repeat. For repeating replaces, call the
 * overloaded method.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *, *) = null
 *  StringUtils.replaceEach("""", *, *, *) = """"
 *  StringUtils.replaceEach(""aba"", null, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[0], null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", null, new String[0], *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""}, *) = ""b""
 *  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""}, *) = ""aba""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""}, *) = ""wcte""
 *  (example of how it repeats)
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, false) = ""dcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, true) = ""tcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, true) = IllegalArgumentException
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, false) = ""dcabe""
 * </pre>
 *
 * @param text
 *            text to search and replace in, no-op if null
 * @param searchList
 *            the Strings to search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @return the text with any replacements processed, {@code null} if
 *         null String input
 * @throws IllegalArgumentException
 *             if the search is repeating and there is an endless loop due
 *             to outputs of one being inputs to another
 * @throws IndexOutOfBoundsException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */"
"public static String lowerCase(String str) {
    if (str == null) {
        return null;
    }
    return str.toLowerCase();
}","public void test235320() throws Throwable {
    StringUtils.lowerCase(""^Ap%N_"");
}","/**
 * <p>Converts a String to lower case as per {@link String#toLowerCase()}.</p>
 *
 * <p>A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.lowerCase(null)  = null
 * StringUtils.lowerCase("""")    = """"
 * StringUtils.lowerCase(""aBc"") = ""abc""
 * </pre>
 *
 * <p><strong>Note:</strong> As described in the documentation for {@link String#toLowerCase()},
 * the result of this method is affected by the current locale.
 * For platform-independent case transformations, the method {@link #lowerCase(String, Locale)}
 * should be used with a specific locale (e.g. {@link Locale#ENGLISH}).</p>
 *
 * @param str  the String to lower case, may be null
 * @return the lower cased String, {@code null} if null String input
 */"
"// Conversion
//-----------------------------------------------------------------------
// Padding
//-----------------------------------------------------------------------
/**
 * <p>Repeat a String {@code repeat} times to form a
 * new String.</p>
 *
 * <pre>
 * StringUtils.repeat(null, 2) = null
 * StringUtils.repeat("""", 0)   = """"
 * StringUtils.repeat("""", 2)   = """"
 * StringUtils.repeat(""a"", 3)  = ""aaa""
 * StringUtils.repeat(""ab"", 2) = ""abab""
 * StringUtils.repeat(""a"", -2) = """"
 * </pre>
 *
 * @param str  the String to repeat, may be null
 * @param repeat  number of times to repeat str, negative treated as zero
 * @return a new String consisting of the original String repeated,
 *  {@code null} if null String input
 */
public static String repeat(String str, int repeat) {
    // Performance tuned for 2.0 (JDK1.4)
    if (str == null) {
        return null;
    }
    if (repeat <= 0) {
        return EMPTY;
    }
    int inputLength = str.length();
    if (repeat == 1 || inputLength == 0) {
        return str;
    }
    if (inputLength == 1 && repeat <= PAD_LIMIT) {
        return repeat(str.charAt(0), repeat);
    }
    int outputLength = inputLength * repeat;
    switch(inputLength) {
        case 1:
            return repeat(str.charAt(0), repeat);
        case 2:
            char ch0 = str.charAt(0);
            char ch1 = str.charAt(1);
            char[] output2 = new char[outputLength];
            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {
                output2[i] = ch0;
                output2[i + 1] = ch1;
            }
            return new String(output2);
        default:
            StringBuilder buf = new StringBuilder(outputLength);
            for (int i = 0; i < repeat; i++) {
                buf.append(str);
            }
            return buf.toString();
    }
}","public void test236321() throws Throwable {
    StringUtils.substringBefore(""sun.text.Normalizer"", ""BBfd~=8mQGb3A"");
    StringUtils.strip(""BBfd~=8mQGb3A"", ""sun.text.Normalizer"");
    String[] stringArray0 = StringUtils.splitByWholeSeparator(""BBfd~=8mQGb3A"", ""sun.text.Normalizer"");
    StringUtils.join((Object[]) stringArray0, (String) null);
    StringUtils.containsIgnoreCase(""sun.text.Normalizer"", ""BBfd~=8mQGb3A"");
    StringUtils.removeEnd(""sun.text.Normalizer"", ""e|`3S336`Aet#0vk"");
    StringUtils.overlay("".W4jm+=!5F "", "".W4jm+=!5F "", (-2134), 604);
    StringUtils.repeat(""Array element "", 604);
}",""
"public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {
    // timeToLive should be 0 if not used or nothing to replace, else it's
    // the length of the replace array
    int timeToLive = searchList == null ? 0 : searchList.length;
    return replaceEach(text, searchList, replacementList, true, timeToLive);
}","public void test237322() throws Throwable {
    StringUtils.abbreviate(""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"", 127);
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"";
    stringArray0[1] = ""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"";
    stringArray0[2] = ""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"";
    stringArray0[3] = ""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"";
    stringArray0[4] = ""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"";
    stringArray0[5] = ""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"";
    stringArray0[6] = ""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"";
    stringArray0[7] = ""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"";
    String[] stringArray1 = new String[1];
    stringArray1[0] = ""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"";
    // Undeclared exception!
    try {
        StringUtils.replaceEachRepeatedly(""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"", stringArray0, stringArray1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Search and Replace array lengths don't match: 8 vs 1
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}","/**
 * <p>
 * Replaces all occurrences of Strings within another String.
 * </p>
 *
 * <p>
 * A {@code null} reference passed to this method is a no-op, or if
 * any ""search string"" or ""string to replace"" is null, that replace will be
 * ignored. This will not repeat. For repeating replaces, call the
 * overloaded method.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *, *) = null
 *  StringUtils.replaceEach("""", *, *, *) = """"
 *  StringUtils.replaceEach(""aba"", null, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[0], null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", null, new String[0], *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""}, *) = ""b""
 *  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""}, *) = ""aba""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""}, *) = ""wcte""
 *  (example of how it repeats)
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, false) = ""dcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, true) = ""tcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, true) = IllegalArgumentException
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, false) = ""dcabe""
 * </pre>
 *
 * @param text
 *            text to search and replace in, no-op if null
 * @param searchList
 *            the Strings to search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @return the text with any replacements processed, {@code null} if
 *         null String input
 * @throws IllegalArgumentException
 *             if the search is repeating and there is an endless loop due
 *             to outputs of one being inputs to another
 * @throws IndexOutOfBoundsException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */"
"// Character Tests
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains only unicode letters.</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty CharSequence (length()=0) will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.isAlpha(null)   = false
 * StringUtils.isAlpha("""")     = false
 * StringUtils.isAlpha(""  "")   = false
 * StringUtils.isAlpha(""abc"")  = true
 * StringUtils.isAlpha(""ab2c"") = false
 * StringUtils.isAlpha(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if only contains letters, and is non-null
 * @since 3.0 Changed signature from isAlpha(String) to isAlpha(CharSequence)
 * @since 3.0 Changed """" to return false and not true
 */
public static boolean isAlpha(CharSequence cs) {
    if (cs == null || cs.length() == 0) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isLetter(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test238323() throws Throwable {
    String string0 = ""\\u"";
    String[] stringArray0 = StringUtils.split(string0, '\\');
    StringUtils.chomp(""e"", ""e"");
    StringUtils.stripAccents(""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"");
    StringUtils.replaceEachRepeatedly(""kwC/'G|ItgL7&BPR"", stringArray0, stringArray0);
    StringUtils.isAsciiPrintable(""e"");
    StringUtils.lastIndexOfIgnoreCase((CharSequence) ""kwC/'G|ItgL7&BPR"", (CharSequence) ""kwC/'G|ItgL7&BPR"", (-2289));
    StringUtils.strip(""java.text.Normalizer$Form"", ""'-vzzmc{,/A}*yW,KUm"");
    StringUtils.isAlpha(""'-vzzmc{,/A}*yW,KUm"");
}",""
"public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {
    // timeToLive should be 0 if not used or nothing to replace, else it's
    // the length of the replace array
    int timeToLive = searchList == null ? 0 : searchList.length;
    return replaceEach(text, searchList, replacementList, true, timeToLive);
}","public void test239324() throws Throwable {
    String[] stringArray0 = new String[2];
    stringArray0[0] = """";
    stringArray0[1] = """";
    StringUtils.replaceEachRepeatedly("""", stringArray0, stringArray0);
}","/**
 * <p>
 * Replaces all occurrences of Strings within another String.
 * </p>
 *
 * <p>
 * A {@code null} reference passed to this method is a no-op, or if
 * any ""search string"" or ""string to replace"" is null, that replace will be
 * ignored. This will not repeat. For repeating replaces, call the
 * overloaded method.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *, *) = null
 *  StringUtils.replaceEach("""", *, *, *) = """"
 *  StringUtils.replaceEach(""aba"", null, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[0], null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", null, new String[0], *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""}, *) = ""b""
 *  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""}, *) = ""aba""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""}, *) = ""wcte""
 *  (example of how it repeats)
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, false) = ""dcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, true) = ""tcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, true) = IllegalArgumentException
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, false) = ""dcabe""
 * </pre>
 *
 * @param text
 *            text to search and replace in, no-op if null
 * @param searchList
 *            the Strings to search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @return the text with any replacements processed, {@code null} if
 *         null String input
 * @throws IllegalArgumentException
 *             if the search is repeating and there is an endless loop due
 *             to outputs of one being inputs to another
 * @throws IndexOutOfBoundsException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */"
"public static String uncapitalize(String str) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    return new StringBuilder(strLen).append(Character.toLowerCase(str.charAt(0))).append(str.substring(1)).toString();
}","public void test240325() throws Throwable {
    StringUtils.splitByCharacterTypeCamelCase(""%bzBc u1~rSlbs+,W"");
    StringUtils.strip(""%bzBc u1~rSlbs+,W"", ""%bzBc u1~rSlbs+,W"");
    StringUtils.uncapitalize((String) null);
}","/**
 * <p>Uncapitalizes a String changing the first letter to title case as
 * per {@link Character#toLowerCase(char)}. No other letters are changed.</p>
 *
 * <p>For a word based algorithm, see {@link org.apache.commons.lang3.text.WordUtils#uncapitalize(String)}.
 * A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.uncapitalize(null)  = null
 * StringUtils.uncapitalize("""")    = """"
 * StringUtils.uncapitalize(""Cat"") = ""cat""
 * StringUtils.uncapitalize(""CAT"") = ""cAT""
 * </pre>
 *
 * @param str the String to uncapitalize, may be null
 * @return the uncapitalized String, {@code null} if null String input
 * @see org.apache.commons.lang3.text.WordUtils#uncapitalize(String)
 * @see #capitalize(String)
 * @since 2.0
 */"
"public static boolean isNotBlank(CharSequence cs) {
    return !StringUtils.isBlank(cs);
}","public void test241326() throws Throwable {
    StringUtils.split(""jY#`lkd61$="");
    StringUtils.substringBetween(""jY#`lkd61$="", ""jY#`lkd61$="", "" is less than 0: "");
    StringUtils.remove((String) null, 'e');
    StringUtils.endsWithIgnoreCase((CharSequence) null, "" is less than 0: "");
    StringUtils.stripAccents(""{}"");
    char[] charArray0 = new char[5];
    charArray0[0] = 'e';
    charArray0[1] = 'e';
    charArray0[2] = 'h';
    charArray0[3] = 'e';
    charArray0[4] = 'e';
    StringUtils.containsNone((CharSequence) ""jY#`lkd61$="", charArray0);
    StringUtils.lastIndexOfIgnoreCase((CharSequence) null, (CharSequence) ""{}"");
    StringUtils.indexOf((CharSequence) "" is less than 0: "", (-1), 0);
    StringUtils.indexOfAnyBut((CharSequence) ""jY#`lkd61$="", charArray0);
    StringUtils.isNotBlank(""{}"");
}","/**
 * <p>Checks if a CharSequence is not empty (""""), not null and not whitespace only.</p>
 *
 * <pre>
 * StringUtils.isNotBlank(null)      = false
 * StringUtils.isNotBlank("""")        = false
 * StringUtils.isNotBlank("" "")       = false
 * StringUtils.isNotBlank(""bob"")     = true
 * StringUtils.isNotBlank(""  bob  "") = true
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if the CharSequence is
 *  not empty and not null and not whitespace
 * @since 2.0
 * @since 3.0 Changed signature from isNotBlank(String) to isNotBlank(CharSequence)
 */"
"public static String removeEndIgnoreCase(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (endsWithIgnoreCase(str, remove)) {
        return str.substring(0, str.length() - remove.length());
    }
    return str;
}","public void test242327() throws Throwable {
    String string0 = StringUtils.removeEndIgnoreCase("""", """");
    assertNotNull(string0);
}","/**
 * <p>Case insensitive removal of a substring if it is at the end of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("""") source string will return the empty string.
 * A {@code null} search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeEndIgnoreCase(null, *)      = null
 * StringUtils.removeEndIgnoreCase("""", *)        = """"
 * StringUtils.removeEndIgnoreCase(*, null)      = *
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", "".com."")  = ""www.domain.com""
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", "".com"")   = ""www.domain""
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeEndIgnoreCase(""abc"", """")    = ""abc""
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", "".COM"") = ""www.domain"")
 * StringUtils.removeEndIgnoreCase(""www.domain.COM"", "".com"") = ""www.domain"")
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for (case insensitive) and remove, may be null
 * @return the substring with the string removed if found,
 *  {@code null} if null String input
 * @since 2.4
 */"
"public static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr, int startPos) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    if (startPos > (str.length() - searchStr.length())) {
        startPos = str.length() - searchStr.length();
    }
    if (startPos < 0) {
        return INDEX_NOT_FOUND;
    }
    if (searchStr.length() == 0) {
        return startPos;
    }
    for (int i = startPos; i >= 0; i--) {
        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test242329() throws Throwable {
    String string0 = StringUtils.removeEndIgnoreCase("""", """");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) """", (CharSequence) """", 0);
    assertEquals(0, int0);
}","/**
 * <p>Case in-sensitive find of the last index within a CharSequence
 * from the specified position.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A negative start position returns {@code -1}.
 * An empty ("""") search CharSequence always matches unless the start position is negative.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOfIgnoreCase(null, *, *)          = -1
 * StringUtils.lastIndexOfIgnoreCase(*, null, *)          = -1
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""A"", 8)  = 7
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"", 8)  = 5
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""AB"", 8) = 4
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"", 9)  = 5
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"", -1) = -1
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""A"", 0)  = 0
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"", 0)  = -1
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @param startPos  the start position
 * @return the first index of the search CharSequence,
 *  -1 if no match or {@code null} input
 * @since 2.5
 * @since 3.0 Changed signature from lastIndexOfIgnoreCase(String, String, int) to lastIndexOfIgnoreCase(CharSequence, CharSequence, int)
 */"
"public static String[] split(String str, String separatorChars, int max) {
    return splitWorker(str, separatorChars, max, false);
}","public void test242330() throws Throwable {
    String string0 = StringUtils.removeEndIgnoreCase("""", """");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) """", (CharSequence) """", 0);
    String[] stringArray0 = StringUtils.split(""N856"", (String) null, 0);
    assertEquals(1, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array with a maximum length,
 * separators specified.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as one separator.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} separatorChars splits on whitespace.</p>
 *
 * <p>If more than {@code max} delimited substrings are found, the last
 * returned string includes all characters after the first {@code max - 1}
 * returned strings (including separator characters).</p>
 *
 * <pre>
 * StringUtils.split(null, *, *)            = null
 * StringUtils.split("""", *, *)              = []
 * StringUtils.split(""ab de fg"", null, 0)   = [""ab"", ""cd"", ""ef""]
 * StringUtils.split(""ab   de fg"", null, 0) = [""ab"", ""cd"", ""ef""]
 * StringUtils.split(""ab:cd:ef"", "":"", 0)    = [""ab"", ""cd"", ""ef""]
 * StringUtils.split(""ab:cd:ef"", "":"", 2)    = [""ab"", ""cd:ef""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @param separatorChars  the characters used as the delimiters,
 *  {@code null} splits on whitespace
 * @param max  the maximum number of elements to include in the
 *  array. A zero or negative value implies no limit
 * @return an array of parsed Strings, {@code null} if null String input
 */"
"// Stripping
//-----------------------------------------------------------------------
/**
 * <p>Strips whitespace from the start and end of a String.</p>
 *
 * <p>This is similar to {@link #trim(String)} but removes whitespace.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <p>A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.strip(null)     = null
 * StringUtils.strip("""")       = """"
 * StringUtils.strip(""   "")    = """"
 * StringUtils.strip(""abc"")    = ""abc""
 * StringUtils.strip(""  abc"")  = ""abc""
 * StringUtils.strip(""abc  "")  = ""abc""
 * StringUtils.strip("" abc "")  = ""abc""
 * StringUtils.strip("" ab c "") = ""ab c""
 * </pre>
 *
 * @param str  the String to remove whitespace from, may be null
 * @return the stripped String, {@code null} if null String input
 */
public static String strip(String str) {
    return strip(str, null);
}","public void test242332() throws Throwable {
    String string0 = StringUtils.removeEndIgnoreCase("""", """");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) """", (CharSequence) """", 0);
    String[] stringArray0 = StringUtils.split(""N856"", (String) null, 0);
    String string1 = StringUtils.strip("", Length: 0"");
    assertNotNull(string1);
}",""
"public static String swapCase(String str) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    StringBuilder buffer = new StringBuilder(strLen);
    char ch = 0;
    for (int i = 0; i < strLen; i++) {
        ch = str.charAt(i);
        if (Character.isUpperCase(ch)) {
            ch = Character.toLowerCase(ch);
        } else if (Character.isTitleCase(ch)) {
            ch = Character.toLowerCase(ch);
        } else if (Character.isLowerCase(ch)) {
            ch = Character.toUpperCase(ch);
        }
        buffer.append(ch);
    }
    return buffer.toString();
}","public void test242335() throws Throwable {
    String string0 = StringUtils.removeEndIgnoreCase("""", """");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) """", (CharSequence) """", 0);
    String[] stringArray0 = StringUtils.split(""N856"", (String) null, 0);
    String string1 = StringUtils.strip("", Length: 0"");
    String string2 = StringUtils.swapCase("", Length: 0"");
    assertNotNull(string2);
}","/**
 * <p>Swaps the case of a String changing upper and title case to
 * lower case, and lower case to upper case.</p>
 *
 * <ul>
 *  <li>Upper case character converts to Lower case</li>
 *  <li>Title case character converts to Lower case</li>
 *  <li>Lower case character converts to Upper case</li>
 * </ul>
 *
 * <p>For a word based algorithm, see {@link org.apache.commons.lang3.text.WordUtils#swapCase(String)}.
 * A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.swapCase(null)                 = null
 * StringUtils.swapCase("""")                   = """"
 * StringUtils.swapCase(""The dog has a BONE"") = ""tHE DOG HAS A bone""
 * </pre>
 *
 * <p>NOTE: This method changed in Lang version 2.0.
 * It no longer performs a word based algorithm.
 * If you only use ASCII, you will notice no change.
 * That functionality is available in org.apache.commons.lang3.text.WordUtils.</p>
 *
 * @param str  the String to swap case, may be null
 * @return the changed String, {@code null} if null String input
 */"
"// Replace, character based
//-----------------------------------------------------------------------
/**
 * <p>Replaces all occurrences of a character in a String with another.
 * This is a null-safe version of {@link String#replace(char, char)}.</p>
 *
 * <p>A {@code null} string input returns {@code null}.
 * An empty ("""") string input returns an empty string.</p>
 *
 * <pre>
 * StringUtils.replaceChars(null, *, *)        = null
 * StringUtils.replaceChars("""", *, *)          = """"
 * StringUtils.replaceChars(""abcba"", 'b', 'y') = ""aycya""
 * StringUtils.replaceChars(""abcba"", 'z', 'y') = ""abcba""
 * </pre>
 *
 * @param str  String to replace characters in, may be null
 * @param searchChar  the character to search for, may be null
 * @param replaceChar  the character to replace, may be null
 * @return modified String, {@code null} if null string input
 * @since 2.0
 */
public static String replaceChars(String str, char searchChar, char replaceChar) {
    if (str == null) {
        return null;
    }
    return str.replace(searchChar, replaceChar);
}","public void test242339() throws Throwable {
    String string0 = StringUtils.removeEndIgnoreCase("""", """");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) """", (CharSequence) """", 0);
    String[] stringArray0 = StringUtils.split(""N856"", (String) null, 0);
    String string1 = StringUtils.strip("", Length: 0"");
    String string2 = StringUtils.swapCase("", Length: 0"");
    String string3 = StringUtils.replaceChars((String) null, 'e', '*');
    assertNull(string3);
}",""
"public static String reverseDelimited(String str, char separatorChar) {
    if (str == null) {
        return null;
    }
    // could implement manually, but simple way is to reuse other,
    // probably slower, methods.
    String[] strs = split(str, separatorChar);
    ArrayUtils.reverse(strs);
    return join(strs, separatorChar);
}","public void test242340() throws Throwable {
    String string0 = StringUtils.removeEndIgnoreCase("""", """");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) """", (CharSequence) """", 0);
    String[] stringArray0 = StringUtils.split(""N856"", (String) null, 0);
    String string1 = StringUtils.strip("", Length: 0"");
    String string2 = StringUtils.swapCase("", Length: 0"");
    String string3 = StringUtils.replaceChars((String) null, 'e', '*');
    String string4 = StringUtils.reverseDelimited("""", 'p');
    assertNotNull(string4);
}","/**
 * <p>Reverses a String that is delimited by a specific character.</p>
 *
 * <p>The Strings between the delimiters are not reversed.
 * Thus java.lang.String becomes String.lang.java (if the delimiter
 * is {@code '.'}).</p>
 *
 * <pre>
 * StringUtils.reverseDelimited(null, *)      = null
 * StringUtils.reverseDelimited("""", *)        = """"
 * StringUtils.reverseDelimited(""a.b.c"", 'x') = ""a.b.c""
 * StringUtils.reverseDelimited(""a.b.c"", ""."") = ""c.b.a""
 * </pre>
 *
 * @param str  the String to reverse, may be null
 * @param separatorChar  the separator character to use
 * @return the reversed String, {@code null} if null String input
 * @since 2.0
 */"
"public static String join(Iterator<?> iterator, char separator) {
    // handle null, zero and one elements before building a buffer
    if (iterator == null) {
        return null;
    }
    if (!iterator.hasNext()) {
        return EMPTY;
    }
    Object first = iterator.next();
    if (!iterator.hasNext()) {
        return ObjectUtils.toString(first);
    }
    // two or more elements
    // Java default is 16, probably too small
    StringBuilder buf = new StringBuilder(256);
    if (first != null) {
        buf.append(first);
    }
    while (iterator.hasNext()) {
        buf.append(separator);
        Object obj = iterator.next();
        if (obj != null) {
            buf.append(obj);
        }
    }
    return buf.toString();
}","public void test242353() throws Throwable {
    String string0 = StringUtils.removeEndIgnoreCase("""", """");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) """", (CharSequence) """", 0);
    String[] stringArray0 = StringUtils.split(""N856"", (String) null, 0);
    String string1 = StringUtils.strip("", Length: 0"");
    String string2 = StringUtils.swapCase("", Length: 0"");
    String string3 = StringUtils.replaceChars((String) null, 'e', '*');
    String string4 = StringUtils.reverseDelimited("""", 'p');
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    Iterator<Object> iterator0 = linkedList0.descendingIterator();
    String string5 = StringUtils.join(iterator0, 'p');
    assertNotNull(string5);
}","/**
 * <p>Joins the elements of the provided {@code Iterator} into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list. Null objects or empty
 * strings within the iteration are represented by empty strings.</p>
 *
 * <p>See the examples here: {@link #join(Object[],char)}. </p>
 *
 * @param iterator  the {@code Iterator} of values to join together, may be null
 * @param separator  the separator character to use
 * @return the joined String, {@code null} if null iterator input
 * @since 2.0
 */"
"public static String substringAfter(String str, String separator) {
    if (isEmpty(str)) {
        return str;
    }
    if (separator == null) {
        return EMPTY;
    }
    int pos = str.indexOf(separator);
    if (pos == INDEX_NOT_FOUND) {
        return EMPTY;
    }
    return str.substring(pos + separator.length());
}","public void test242358() throws Throwable {
    String string0 = StringUtils.removeEndIgnoreCase("""", """");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) """", (CharSequence) """", 0);
    String[] stringArray0 = StringUtils.split(""N856"", (String) null, 0);
    String string1 = StringUtils.strip("", Length: 0"");
    String string2 = StringUtils.swapCase("", Length: 0"");
    String string3 = StringUtils.replaceChars((String) null, 'e', '*');
    String string4 = StringUtils.reverseDelimited("""", 'p');
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    Iterator<Object> iterator0 = linkedList0.descendingIterator();
    String string5 = StringUtils.join(iterator0, 'p');
    String string6 = StringUtils.substringAfter(""F7z%4T+JL+Qy33.hx "", (String) null);
    assertNotNull(string6);
}","/**
 * <p>Gets the substring after the first occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A {@code null} string input will return {@code null}.
 * An empty ("""") string input will return the empty string.
 * A {@code null} separator will return the empty string if the
 * input string is not {@code null}.</p>
 *
 * <p>If nothing is found, the empty string is returned.</p>
 *
 * <pre>
 * StringUtils.substringAfter(null, *)      = null
 * StringUtils.substringAfter("""", *)        = """"
 * StringUtils.substringAfter(*, null)      = """"
 * StringUtils.substringAfter(""abc"", ""a"")   = ""bc""
 * StringUtils.substringAfter(""abcba"", ""b"") = ""cba""
 * StringUtils.substringAfter(""abc"", ""c"")   = """"
 * StringUtils.substringAfter(""abc"", ""d"")   = """"
 * StringUtils.substringAfter(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring after the first occurrence of the separator,
 *  {@code null} if null String input
 * @since 2.0
 */"
"public static String trimToEmpty(String str) {
    return str == null ? EMPTY : str.trim();
}","public void test242363() throws Throwable {
    String string0 = StringUtils.removeEndIgnoreCase("""", """");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) """", (CharSequence) """", 0);
    String[] stringArray0 = StringUtils.split(""N856"", (String) null, 0);
    String string1 = StringUtils.strip("", Length: 0"");
    String string2 = StringUtils.swapCase("", Length: 0"");
    String string3 = StringUtils.replaceChars((String) null, 'e', '*');
    String string4 = StringUtils.reverseDelimited("""", 'p');
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    Iterator<Object> iterator0 = linkedList0.descendingIterator();
    String string5 = StringUtils.join(iterator0, 'p');
    String string6 = StringUtils.substringAfter(""F7z%4T+JL+Qy33.hx "", (String) null);
    String string7 = StringUtils.trimToEmpty("""");
    assertNotNull(string7);
}","/**
 * <p>Removes control characters (char &lt;= 32) from both
 * ends of this String returning an empty String ("""") if the String
 * is empty ("""") after the trim or if it is {@code null}.
 *
 * <p>The String is trimmed using {@link String#trim()}.
 * Trim removes start and end characters &lt;= 32.
 * To strip whitespace use {@link #stripToEmpty(String)}.</p>
 *
 * <pre>
 * StringUtils.trimToEmpty(null)          = """"
 * StringUtils.trimToEmpty("""")            = """"
 * StringUtils.trimToEmpty(""     "")       = """"
 * StringUtils.trimToEmpty(""abc"")         = ""abc""
 * StringUtils.trimToEmpty(""    abc    "") = ""abc""
 * </pre>
 *
 * @param str  the String to be trimmed, may be null
 * @return the trimmed String, or an empty String if {@code null} input
 * @since 2.0
 */"
"public static String replace(String text, String searchString, String replacement, int max) {
    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {
        return text;
    }
    int start = 0;
    int end = text.indexOf(searchString, start);
    if (end == INDEX_NOT_FOUND) {
        return text;
    }
    int replLength = searchString.length();
    int increase = replacement.length() - replLength;
    increase = (increase < 0 ? 0 : increase);
    increase *= (max < 0 ? 16 : (max > 64 ? 64 : max));
    StringBuilder buf = new StringBuilder(text.length() + increase);
    while (end != INDEX_NOT_FOUND) {
        buf.append(text.substring(start, end)).append(replacement);
        start = end + replLength;
        if (--max == 0) {
            break;
        }
        end = text.indexOf(searchString, start);
    }
    buf.append(text.substring(start));
    return buf.toString();
}","public void test242371() throws Throwable {
    String string0 = StringUtils.removeEndIgnoreCase("""", """");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) """", (CharSequence) """", 0);
    String[] stringArray0 = StringUtils.split(""N856"", (String) null, 0);
    String string1 = StringUtils.strip("", Length: 0"");
    String string2 = StringUtils.swapCase("", Length: 0"");
    String string3 = StringUtils.replaceChars((String) null, 'e', '*');
    String string4 = StringUtils.reverseDelimited("""", 'p');
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    Iterator<Object> iterator0 = linkedList0.descendingIterator();
    String string5 = StringUtils.join(iterator0, 'p');
    String string6 = StringUtils.substringAfter(""F7z%4T+JL+Qy33.hx "", (String) null);
    String string7 = StringUtils.trimToEmpty("""");
    String string8 = StringUtils.replace(""', is neither of type Map.Entry nor an Array"", ""', is neither of type Map.Entry nor an Array"", (String) null, 2711);
    assertNotNull(string8);
}","/**
 * <p>Replaces a String with another String inside a larger String,
 * for the first {@code max} values of the search String.</p>
 *
 * <p>A {@code null} reference passed to this method is a no-op.</p>
 *
 * <pre>
 * StringUtils.replace(null, *, *, *)         = null
 * StringUtils.replace("""", *, *, *)           = """"
 * StringUtils.replace(""any"", null, *, *)     = ""any""
 * StringUtils.replace(""any"", *, null, *)     = ""any""
 * StringUtils.replace(""any"", """", *, *)       = ""any""
 * StringUtils.replace(""any"", *, *, 0)        = ""any""
 * StringUtils.replace(""abaa"", ""a"", null, -1) = ""abaa""
 * StringUtils.replace(""abaa"", ""a"", """", -1)   = ""b""
 * StringUtils.replace(""abaa"", ""a"", ""z"", 0)   = ""abaa""
 * StringUtils.replace(""abaa"", ""a"", ""z"", 1)   = ""zbaa""
 * StringUtils.replace(""abaa"", ""a"", ""z"", 2)   = ""zbza""
 * StringUtils.replace(""abaa"", ""a"", ""z"", -1)  = ""zbzz""
 * </pre>
 *
 * @param text  text to search and replace in, may be null
 * @param searchString  the String to search for, may be null
 * @param replacement  the String to replace it with, may be null
 * @param max  maximum number of values to replace, or {@code -1} if no maximum
 * @return the text with any replacements processed,
 *  {@code null} if null String input
 */"
"public static String center(String str, int size, String padStr) {
    if (str == null || size <= 0) {
        return str;
    }
    if (isEmpty(padStr)) {
        padStr = "" "";
    }
    int strLen = str.length();
    int pads = size - strLen;
    if (pads <= 0) {
        return str;
    }
    str = leftPad(str, strLen + pads / 2, padStr);
    str = rightPad(str, size, padStr);
    return str;
}","public void test242380() throws Throwable {
    String string0 = StringUtils.removeEndIgnoreCase("""", """");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) """", (CharSequence) """", 0);
    String[] stringArray0 = StringUtils.split(""N856"", (String) null, 0);
    String string1 = StringUtils.strip("", Length: 0"");
    String string2 = StringUtils.swapCase("", Length: 0"");
    String string3 = StringUtils.replaceChars((String) null, 'e', '*');
    String string4 = StringUtils.reverseDelimited("""", 'p');
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    Iterator<Object> iterator0 = linkedList0.descendingIterator();
    String string5 = StringUtils.join(iterator0, 'p');
    String string6 = StringUtils.substringAfter(""F7z%4T+JL+Qy33.hx "", (String) null);
    String string7 = StringUtils.trimToEmpty("""");
    String string8 = StringUtils.replace(""', is neither of type Map.Entry nor an Array"", ""', is neither of type Map.Entry nor an Array"", (String) null, 2711);
    String string9 = StringUtils.center("""", 0, ""N856"");
    assertNotNull(string9);
}","/**
 * <p>Centers a String in a larger String of size {@code size}.
 * Uses a supplied String as the value to pad the String with.</p>
 *
 * <p>If the size is less than the String length, the String is returned.
 * A {@code null} String returns {@code null}.
 * A negative size is treated as zero.</p>
 *
 * <pre>
 * StringUtils.center(null, *, *)     = null
 * StringUtils.center("""", 4, "" "")     = ""    ""
 * StringUtils.center(""ab"", -1, "" "")  = ""ab""
 * StringUtils.center(""ab"", 4, "" "")   = "" ab""
 * StringUtils.center(""abcd"", 2, "" "") = ""abcd""
 * StringUtils.center(""a"", 4, "" "")    = "" a  ""
 * StringUtils.center(""a"", 4, ""yz"")   = ""yayz""
 * StringUtils.center(""abc"", 7, null) = ""  abc  ""
 * StringUtils.center(""abc"", 7, """")   = ""  abc  ""
 * </pre>
 *
 * @param str  the String to center, may be null
 * @param size  the int size of new String, negative treated as zero
 * @param padStr  the String to pad the new String with, must not be null or empty
 * @return centered String, {@code null} if null String input
 * @throws IllegalArgumentException if padStr is {@code null} or empty
 */"
"// Replace, character based
//-----------------------------------------------------------------------
/**
 * <p>Replaces all occurrences of a character in a String with another.
 * This is a null-safe version of {@link String#replace(char, char)}.</p>
 *
 * <p>A {@code null} string input returns {@code null}.
 * An empty ("""") string input returns an empty string.</p>
 *
 * <pre>
 * StringUtils.replaceChars(null, *, *)        = null
 * StringUtils.replaceChars("""", *, *)          = """"
 * StringUtils.replaceChars(""abcba"", 'b', 'y') = ""aycya""
 * StringUtils.replaceChars(""abcba"", 'z', 'y') = ""abcba""
 * </pre>
 *
 * @param str  String to replace characters in, may be null
 * @param searchChar  the character to search for, may be null
 * @param replaceChar  the character to replace, may be null
 * @return modified String, {@code null} if null string input
 * @since 2.0
 */
public static String replaceChars(String str, char searchChar, char replaceChar) {
    if (str == null) {
        return null;
    }
    return str.replace(searchChar, replaceChar);
}","public void test243390() throws Throwable {
    String string0 = StringUtils.replaceChars(""vQ-VN{ ujU/"", '*', 'Z');
    assertNotNull(string0);
}",""
"public static int lastIndexOfAny(CharSequence str, CharSequence... searchStrs) {
    if (str == null || searchStrs == null) {
        return INDEX_NOT_FOUND;
    }
    int sz = searchStrs.length;
    int ret = INDEX_NOT_FOUND;
    int tmp = 0;
    for (int i = 0; i < sz; i++) {
        CharSequence search = searchStrs[i];
        if (search == null) {
            continue;
        }
        tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());
        if (tmp > ret) {
            ret = tmp;
        }
    }
    return ret;
}","public void test243392() throws Throwable {
    String string0 = StringUtils.replaceChars(""vQ-VN{ ujU/"", '*', 'Z');
    CharSequence[] charSequenceArray0 = new CharSequence[1];
    charSequenceArray0[0] = (CharSequence) ""vQ-VN{ ujU/"";
    int int0 = StringUtils.lastIndexOfAny(""vQ-VN{ ujU/"", charSequenceArray0);
    assertEquals(1, charSequenceArray0.length);
}","/**
 * <p>Find the latest index of any of a set of potential substrings.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A {@code null} search array will return {@code -1}.
 * A {@code null} or zero length search array entry will be ignored,
 * but a search array containing """" will return the length of {@code str}
 * if {@code str} is not null. This method uses {@link String#indexOf(String)} if possible</p>
 *
 * <pre>
 * StringUtils.lastIndexOfAny(null, *)                   = -1
 * StringUtils.lastIndexOfAny(*, null)                   = -1
 * StringUtils.lastIndexOfAny(*, [])                     = -1
 * StringUtils.lastIndexOfAny(*, [null])                 = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""ab"",""cd""]) = 6
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""cd"",""ab""]) = 6
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""op""]) = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""op""]) = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""""])   = 10
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStrs  the CharSequences to search for, may be null
 * @return the last index of any of the CharSequences, -1 if no match
 * @since 3.0 Changed signature from lastIndexOfAny(String, String[]) to lastIndexOfAny(CharSequence, CharSequence)
 */"
"public static String substringAfter(String str, String separator) {
    if (isEmpty(str)) {
        return str;
    }
    if (separator == null) {
        return EMPTY;
    }
    int pos = str.indexOf(separator);
    if (pos == INDEX_NOT_FOUND) {
        return EMPTY;
    }
    return str.substring(pos + separator.length());
}","public void test243394() throws Throwable {
    String string0 = StringUtils.replaceChars(""vQ-VN{ ujU/"", '*', 'Z');
    CharSequence[] charSequenceArray0 = new CharSequence[1];
    charSequenceArray0[0] = (CharSequence) ""vQ-VN{ ujU/"";
    int int0 = StringUtils.lastIndexOfAny(""vQ-VN{ ujU/"", charSequenceArray0);
    String string1 = StringUtils.substringAfter(""**&lY&Mh"", """");
    assertNotNull(string1);
}","/**
 * <p>Gets the substring after the first occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A {@code null} string input will return {@code null}.
 * An empty ("""") string input will return the empty string.
 * A {@code null} separator will return the empty string if the
 * input string is not {@code null}.</p>
 *
 * <p>If nothing is found, the empty string is returned.</p>
 *
 * <pre>
 * StringUtils.substringAfter(null, *)      = null
 * StringUtils.substringAfter("""", *)        = """"
 * StringUtils.substringAfter(*, null)      = """"
 * StringUtils.substringAfter(""abc"", ""a"")   = ""bc""
 * StringUtils.substringAfter(""abcba"", ""b"") = ""cba""
 * StringUtils.substringAfter(""abc"", ""c"")   = """"
 * StringUtils.substringAfter(""abc"", ""d"")   = """"
 * StringUtils.substringAfter(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring after the first occurrence of the separator,
 *  {@code null} if null String input
 * @since 2.0
 */"
"public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) {
    return splitByWholeSeparatorWorker(str, separator, -1, true);
}","public void test243397() throws Throwable {
    String string0 = StringUtils.replaceChars(""vQ-VN{ ujU/"", '*', 'Z');
    CharSequence[] charSequenceArray0 = new CharSequence[1];
    charSequenceArray0[0] = (CharSequence) ""vQ-VN{ ujU/"";
    int int0 = StringUtils.lastIndexOfAny(""vQ-VN{ ujU/"", charSequenceArray0);
    String string1 = StringUtils.substringAfter(""**&lY&Mh"", """");
    String[] stringArray0 = StringUtils.splitByWholeSeparatorPreserveAllTokens(""vQ-VN{ ujU/"", ""**&lY&Mh"");
    assertEquals(1, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array, separator string specified. </p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as separators for empty tokens.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} separator splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *)               = null
 * StringUtils.splitByWholeSeparatorPreserveAllTokens("""", *)                 = []
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(""ab de fg"", null)      = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(""ab   de fg"", null)    = [""ab"", """", """", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(""ab:cd:ef"", "":"")       = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(""ab-!-cd-!-ef"", ""-!-"") = [""ab"", ""cd"", ""ef""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @param separator  String containing the String to be used as a delimiter,
 *  {@code null} splits on whitespace
 * @return an array of parsed Strings, {@code null} if null String was input
 * @since 2.4
 */"
"public static String join(Object[] array, char separator, int startIndex, int endIndex) {
    if (array == null) {
        return null;
    }
    int noOfItems = (endIndex - startIndex);
    if (noOfItems <= 0) {
        return EMPTY;
    }
    StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}","public void test243399() throws Throwable {
    String string0 = StringUtils.replaceChars(""vQ-VN{ ujU/"", '*', 'Z');
    CharSequence[] charSequenceArray0 = new CharSequence[1];
    charSequenceArray0[0] = (CharSequence) ""vQ-VN{ ujU/"";
    int int0 = StringUtils.lastIndexOfAny(""vQ-VN{ ujU/"", charSequenceArray0);
    String string1 = StringUtils.substringAfter(""**&lY&Mh"", """");
    String[] stringArray0 = StringUtils.splitByWholeSeparatorPreserveAllTokens(""vQ-VN{ ujU/"", ""**&lY&Mh"");
    String string2 = StringUtils.join((Object[]) stringArray0, 'Z', 1811, 1811);
    assertEquals(1, stringArray0.length);
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)               = null
 * StringUtils.join([], *)                 = """"
 * StringUtils.join([null], *)             = """"
 * StringUtils.join([""a"", ""b"", ""c""], ';')  = ""a;b;c""
 * StringUtils.join([""a"", ""b"", ""c""], null) = ""abc""
 * StringUtils.join([null, """", ""a""], ';')  = "";;a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use
 * @param startIndex the first index to start joining from.  It is
 * an error to pass in an end index past the end of the array
 * @param endIndex the index to stop joining from (exclusive). It is
 * an error to pass in an end index past the end of the array
 * @return the joined String, {@code null} if null array input
 * @since 2.0
 */"
"public static boolean equalsIgnoreCase(CharSequence str1, CharSequence str2) {
    if (str1 == null || str2 == null) {
        return str1 == str2;
    } else {
        return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, Math.max(str1.length(), str2.length()));
    }
}","public void test243404() throws Throwable {
    String string0 = StringUtils.replaceChars(""vQ-VN{ ujU/"", '*', 'Z');
    CharSequence[] charSequenceArray0 = new CharSequence[1];
    charSequenceArray0[0] = (CharSequence) ""vQ-VN{ ujU/"";
    int int0 = StringUtils.lastIndexOfAny(""vQ-VN{ ujU/"", charSequenceArray0);
    String string1 = StringUtils.substringAfter(""**&lY&Mh"", """");
    String[] stringArray0 = StringUtils.splitByWholeSeparatorPreserveAllTokens(""vQ-VN{ ujU/"", ""**&lY&Mh"");
    String string2 = StringUtils.join((Object[]) stringArray0, 'Z', 1811, 1811);
    boolean boolean0 = StringUtils.equalsIgnoreCase("""", ""vQ-VN{ ujU/"");
    assertFalse(boolean0);
}","/**
 * <p>Compares two CharSequences, returning {@code true} if they are equal ignoring
 * the case.</p>
 *
 * <p>{@code null}s are handled without exceptions. Two {@code null}
 * references are considered equal. Comparison is case insensitive.</p>
 *
 * <pre>
 * StringUtils.equalsIgnoreCase(null, null)   = true
 * StringUtils.equalsIgnoreCase(null, ""abc"")  = false
 * StringUtils.equalsIgnoreCase(""abc"", null)  = false
 * StringUtils.equalsIgnoreCase(""abc"", ""abc"") = true
 * StringUtils.equalsIgnoreCase(""abc"", ""ABC"") = true
 * </pre>
 *
 * @param str1  the first CharSequence, may be null
 * @param str2  the second CharSequence, may be null
 * @return {@code true} if the CharSequence are equal, case insensitive, or
 *  both {@code null}
 * @since 3.0 Changed signature from equalsIgnoreCase(String, String) to equalsIgnoreCase(CharSequence, CharSequence)
 */"
"// Conversion
//-----------------------------------------------------------------------
// Padding
//-----------------------------------------------------------------------
/**
 * <p>Repeat a String {@code repeat} times to form a
 * new String.</p>
 *
 * <pre>
 * StringUtils.repeat(null, 2) = null
 * StringUtils.repeat("""", 0)   = """"
 * StringUtils.repeat("""", 2)   = """"
 * StringUtils.repeat(""a"", 3)  = ""aaa""
 * StringUtils.repeat(""ab"", 2) = ""abab""
 * StringUtils.repeat(""a"", -2) = """"
 * </pre>
 *
 * @param str  the String to repeat, may be null
 * @param repeat  number of times to repeat str, negative treated as zero
 * @return a new String consisting of the original String repeated,
 *  {@code null} if null String input
 */
public static String repeat(String str, int repeat) {
    // Performance tuned for 2.0 (JDK1.4)
    if (str == null) {
        return null;
    }
    if (repeat <= 0) {
        return EMPTY;
    }
    int inputLength = str.length();
    if (repeat == 1 || inputLength == 0) {
        return str;
    }
    if (inputLength == 1 && repeat <= PAD_LIMIT) {
        return repeat(str.charAt(0), repeat);
    }
    int outputLength = inputLength * repeat;
    switch(inputLength) {
        case 1:
            return repeat(str.charAt(0), repeat);
        case 2:
            char ch0 = str.charAt(0);
            char ch1 = str.charAt(1);
            char[] output2 = new char[outputLength];
            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {
                output2[i] = ch0;
                output2[i + 1] = ch1;
            }
            return new String(output2);
        default:
            StringBuilder buf = new StringBuilder(outputLength);
            for (int i = 0; i < repeat; i++) {
                buf.append(str);
            }
            return buf.toString();
    }
}","public void test243405() throws Throwable {
    String string0 = StringUtils.replaceChars(""vQ-VN{ ujU/"", '*', 'Z');
    CharSequence[] charSequenceArray0 = new CharSequence[1];
    charSequenceArray0[0] = (CharSequence) ""vQ-VN{ ujU/"";
    int int0 = StringUtils.lastIndexOfAny(""vQ-VN{ ujU/"", charSequenceArray0);
    String string1 = StringUtils.substringAfter(""**&lY&Mh"", """");
    String[] stringArray0 = StringUtils.splitByWholeSeparatorPreserveAllTokens(""vQ-VN{ ujU/"", ""**&lY&Mh"");
    String string2 = StringUtils.join((Object[]) stringArray0, 'Z', 1811, 1811);
    boolean boolean0 = StringUtils.equalsIgnoreCase("""", ""vQ-VN{ ujU/"");
    String string3 = StringUtils.repeat(""vQ-VN{ ujU/"", 512);
    assertNotNull(string3);
}",""
"public static String[] splitByCharacterType(String str) {
    return splitByCharacterType(str, false);
}","public void test243409() throws Throwable {
    String string0 = StringUtils.replaceChars(""vQ-VN{ ujU/"", '*', 'Z');
    CharSequence[] charSequenceArray0 = new CharSequence[1];
    charSequenceArray0[0] = (CharSequence) ""vQ-VN{ ujU/"";
    int int0 = StringUtils.lastIndexOfAny(""vQ-VN{ ujU/"", charSequenceArray0);
    String string1 = StringUtils.substringAfter(""**&lY&Mh"", """");
    String[] stringArray0 = StringUtils.splitByWholeSeparatorPreserveAllTokens(""vQ-VN{ ujU/"", ""**&lY&Mh"");
    String string2 = StringUtils.join((Object[]) stringArray0, 'Z', 1811, 1811);
    boolean boolean0 = StringUtils.equalsIgnoreCase("""", ""vQ-VN{ ujU/"");
    String string3 = StringUtils.repeat(""vQ-VN{ ujU/"", 512);
    String[] stringArray1 = StringUtils.splitByCharacterType(""`KsY!8?_u"");
    assertNotSame(stringArray1, stringArray0);
}","/**
 * <p>Splits a String by Character type as returned by
 * {@code java.lang.Character.getType(char)}. Groups of contiguous
 * characters of the same type are returned as complete tokens.
 * <pre>
 * StringUtils.splitByCharacterType(null)         = null
 * StringUtils.splitByCharacterType("""")           = []
 * StringUtils.splitByCharacterType(""ab de fg"")   = [""ab"", "" "", ""de"", "" "", ""fg""]
 * StringUtils.splitByCharacterType(""ab   de fg"") = [""ab"", ""   "", ""de"", "" "", ""fg""]
 * StringUtils.splitByCharacterType(""ab:cd:ef"")   = [""ab"", "":"", ""cd"", "":"", ""ef""]
 * StringUtils.splitByCharacterType(""number5"")    = [""number"", ""5""]
 * StringUtils.splitByCharacterType(""fooBar"")     = [""foo"", ""B"", ""ar""]
 * StringUtils.splitByCharacterType(""foo200Bar"")  = [""foo"", ""200"", ""B"", ""ar""]
 * StringUtils.splitByCharacterType(""ASFRules"")   = [""ASFR"", ""ules""]
 * </pre>
 * @param str the String to split, may be {@code null}
 * @return an array of parsed Strings, {@code null} if null String input
 * @since 2.4
 */"
"// Defaults
//-----------------------------------------------------------------------
/**
 * <p>Returns either the passed in String,
 * or if the String is {@code null}, an empty String ("""").</p>
 *
 * <pre>
 * StringUtils.defaultString(null)  = """"
 * StringUtils.defaultString("""")    = """"
 * StringUtils.defaultString(""bat"") = ""bat""
 * </pre>
 *
 * @see ObjectUtils#toString(Object)
 * @see String#valueOf(Object)
 * @param str  the String to check, may be null
 * @return the passed in String, or the empty String if it
 *  was {@code null}
 */
public static String defaultString(String str) {
    return str == null ? EMPTY : str;
}","public void test244413() throws Throwable {
    String string0 = StringUtils.defaultString("" vs "");
    assertNotNull(string0);
}",""
"public static int lastIndexOf(CharSequence seq, int searchChar, int startPos) {
    if (isEmpty(seq)) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.lastIndexOf(seq, searchChar, startPos);
}","public void test244415() throws Throwable {
    String string0 = StringUtils.defaultString("" vs "");
    int int0 = StringUtils.lastIndexOf((CharSequence) "" vs "", 2363, 2100);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index within a CharSequence from a start position,
 * handling {@code null}.
 * This method uses {@link String#lastIndexOf(int, int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("""") CharSequence will return {@code -1}.
 * A negative start position returns {@code -1}.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOf(null, *, *)          = -1
 * StringUtils.lastIndexOf("""", *,  *)           = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 8)  = 5
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 4)  = 2
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 0)  = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 9)  = 5
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', -1) = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'a', 0)  = 0
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @param startPos  the start position
 * @return the last index of the search character,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from lastIndexOf(String, int, int) to lastIndexOf(CharSequence, int, int)
 */"
"// Contains
//-----------------------------------------------------------------------
/**
 * <p>Checks if CharSequence contains a search character, handling {@code null}.
 * This method uses {@link String#indexOf(int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("""") CharSequence will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.contains(null, *)    = false
 * StringUtils.contains("""", *)      = false
 * StringUtils.contains(""abc"", 'a') = true
 * StringUtils.contains(""abc"", 'z') = false
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @return true if the CharSequence contains the search character,
 *  false if not or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from contains(String, int) to contains(CharSequence, int)
 */
public static boolean contains(CharSequence seq, int searchChar) {
    if (isEmpty(seq)) {
        return false;
    }
    return CharSequenceUtils.indexOf(seq, searchChar, 0) >= 0;
}","public void test244416() throws Throwable {
    String string0 = StringUtils.defaultString("" vs "");
    int int0 = StringUtils.lastIndexOf((CharSequence) "" vs "", 2363, 2100);
    boolean boolean0 = StringUtils.contains((CharSequence) "" vs "", (-1));
    assertFalse(boolean0);
}",""
"public static String substringAfter(String str, String separator) {
    if (isEmpty(str)) {
        return str;
    }
    if (separator == null) {
        return EMPTY;
    }
    int pos = str.indexOf(separator);
    if (pos == INDEX_NOT_FOUND) {
        return EMPTY;
    }
    return str.substring(pos + separator.length());
}","public void test244417() throws Throwable {
    String string0 = StringUtils.defaultString("" vs "");
    int int0 = StringUtils.lastIndexOf((CharSequence) "" vs "", 2363, 2100);
    boolean boolean0 = StringUtils.contains((CharSequence) "" vs "", (-1));
    String string1 = StringUtils.substringAfter("""", ""X5A[>%C8Kn=k]-REf"");
    assertNotNull(string1);
}","/**
 * <p>Gets the substring after the first occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A {@code null} string input will return {@code null}.
 * An empty ("""") string input will return the empty string.
 * A {@code null} separator will return the empty string if the
 * input string is not {@code null}.</p>
 *
 * <p>If nothing is found, the empty string is returned.</p>
 *
 * <pre>
 * StringUtils.substringAfter(null, *)      = null
 * StringUtils.substringAfter("""", *)        = """"
 * StringUtils.substringAfter(*, null)      = """"
 * StringUtils.substringAfter(""abc"", ""a"")   = ""bc""
 * StringUtils.substringAfter(""abcba"", ""b"") = ""cba""
 * StringUtils.substringAfter(""abc"", ""c"")   = """"
 * StringUtils.substringAfter(""abc"", ""d"")   = """"
 * StringUtils.substringAfter(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring after the first occurrence of the separator,
 *  {@code null} if null String input
 * @since 2.0
 */"
"public static String remove(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    return replace(str, remove, EMPTY, -1);
}","public void test244420() throws Throwable {
    String string0 = StringUtils.defaultString("" vs "");
    int int0 = StringUtils.lastIndexOf((CharSequence) "" vs "", 2363, 2100);
    boolean boolean0 = StringUtils.contains((CharSequence) "" vs "", (-1));
    String string1 = StringUtils.substringAfter("""", ""X5A[>%C8Kn=k]-REf"");
    String string2 = StringUtils.remove(""X5A[>%C8Kn=k]-REf"", """");
    assertNotNull(string2);
}","/**
 * <p>Removes all occurrences of a substring from within the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("""") source string will return the empty string.
 * A {@code null} remove string will return the source string.
 * An empty ("""") remove string will return the source string.</p>
 *
 * <pre>
 * StringUtils.remove(null, *)        = null
 * StringUtils.remove("""", *)          = """"
 * StringUtils.remove(*, null)        = *
 * StringUtils.remove(*, """")          = *
 * StringUtils.remove(""queued"", ""ue"") = ""qd""
 * StringUtils.remove(""queued"", ""zz"") = ""queued""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for and remove, may be null
 * @return the substring with the string removed if found,
 *  {@code null} if null String input
 * @since 2.1
 */"
"public static String defaultString(String str, String defaultStr) {
    return str == null ? defaultStr : str;
}","public void test245424() throws Throwable {
    String string0 = StringUtils.defaultString(""F1}$>CNgUA3WZ"", ""F1}$>CNgUA3WZ"");
    assertNotNull(string0);
}","/**
 * <p>Returns either the passed in String, or if the String is
 * {@code null}, the value of {@code defaultStr}.</p>
 *
 * <pre>
 * StringUtils.defaultString(null, ""NULL"")  = ""NULL""
 * StringUtils.defaultString("""", ""NULL"")    = """"
 * StringUtils.defaultString(""bat"", ""NULL"") = ""bat""
 * </pre>
 *
 * @see ObjectUtils#toString(Object,String)
 * @see String#valueOf(Object)
 * @param str  the String to check, may be null
 * @param defaultStr  the default String to return
 *  if the input is {@code null}, may be null
 * @return the passed in String, or the default if it was {@code null}
 */"
"public static String abbreviateMiddle(String str, String middle, int length) {
    if (isEmpty(str) || isEmpty(middle)) {
        return str;
    }
    if (length >= str.length() || length < (middle.length() + 2)) {
        return str;
    }
    int targetSting = length - middle.length();
    int startOffset = targetSting / 2 + targetSting % 2;
    int endOffset = str.length() - targetSting / 2;
    StringBuilder builder = new StringBuilder(length);
    builder.append(str.substring(0, startOffset));
    builder.append(middle);
    builder.append(str.substring(endOffset));
    return builder.toString();
}","public void test245426() throws Throwable {
    String string0 = StringUtils.defaultString(""F1}$>CNgUA3WZ"", ""F1}$>CNgUA3WZ"");
    String string1 = StringUtils.abbreviateMiddle(""F1}$>CNgUA3WZ"", ""F1}$>CNgUA3WZ"", (-2147));
    assertNotNull(string1);
}","/**
 * <p>Abbreviates a String to the length passed, replacing the middle characters with the supplied
 * replacement String.</p>
 *
 * <p>This abbreviation only occurs if the following criteria is met:
 * <ul>
 * <li>Neither the String for abbreviation nor the replacement String are null or empty </li>
 * <li>The length to truncate to is less than the length of the supplied String</li>
 * <li>The length to truncate to is greater than 0</li>
 * <li>The abbreviated String will have enough room for the length supplied replacement String
 * and the first and last characters of the supplied String for abbreviation</li>
 * </ul>
 * Otherwise, the returned String will be the same as the supplied String for abbreviation.
 * </p>
 *
 * <pre>
 * StringUtils.abbreviateMiddle(null, null, 0)      = null
 * StringUtils.abbreviateMiddle(""abc"", null, 0)      = ""abc""
 * StringUtils.abbreviateMiddle(""abc"", ""."", 0)      = ""abc""
 * StringUtils.abbreviateMiddle(""abc"", ""."", 3)      = ""abc""
 * StringUtils.abbreviateMiddle(""abcdef"", ""."", 4)     = ""ab.f""
 * </pre>
 *
 * @param str  the String to abbreviate, may be null
 * @param middle the String to replace the middle characters with, may be null
 * @param length the length to abbreviate {@code str} to.
 * @return the abbreviated String if the above criteria is met, or the original String supplied for abbreviation.
 * @since 2.5
 */"
"public static int indexOfDifference(CharSequence cs1, CharSequence cs2) {
    if (cs1 == cs2) {
        return INDEX_NOT_FOUND;
    }
    if (cs1 == null || cs2 == null) {
        return 0;
    }
    int i;
    for (i = 0; i < cs1.length() && i < cs2.length(); ++i) {
        if (cs1.charAt(i) != cs2.charAt(i)) {
            break;
        }
    }
    if (i < cs2.length() || i < cs1.length()) {
        return i;
    }
    return INDEX_NOT_FOUND;
}","public void test245429() throws Throwable {
    String string0 = StringUtils.defaultString(""F1}$>CNgUA3WZ"", ""F1}$>CNgUA3WZ"");
    String string1 = StringUtils.abbreviateMiddle(""F1}$>CNgUA3WZ"", ""F1}$>CNgUA3WZ"", (-2147));
    int int0 = StringUtils.indexOfDifference((CharSequence) ""F1}$>CNgUA3WZ"", (CharSequence) ""F1}$>CNgUA3WZ"");
    assertEquals((-1), int0);
}","/**
 * <p>Compares two CharSequences, and returns the index at which the
 * CharSequences begin to differ.</p>
 *
 * <p>For example,
 * {@code indexOfDifference(""i am a machine"", ""i am a robot"") -> 7}</p>
 *
 * <pre>
 * StringUtils.indexOfDifference(null, null) = -1
 * StringUtils.indexOfDifference("""", """") = -1
 * StringUtils.indexOfDifference("""", ""abc"") = 0
 * StringUtils.indexOfDifference(""abc"", """") = 0
 * StringUtils.indexOfDifference(""abc"", ""abc"") = -1
 * StringUtils.indexOfDifference(""ab"", ""abxyz"") = 2
 * StringUtils.indexOfDifference(""abcde"", ""abxyz"") = 2
 * StringUtils.indexOfDifference(""abcde"", ""xyz"") = 0
 * </pre>
 *
 * @param cs1  the first CharSequence, may be null
 * @param cs2  the second CharSequence, may be null
 * @return the index where cs1 and cs2 begin to differ; -1 if they are equal
 * @since 2.0
 * @since 3.0 Changed signature from indexOfDifference(String, String) to
 * indexOfDifference(CharSequence, CharSequence)
 */"
"// Reversing
//-----------------------------------------------------------------------
/**
 * <p>Reverses a String as per {@link StringBuilder#reverse()}.</p>
 *
 * <p>A {@code null} String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.reverse(null)  = null
 * StringUtils.reverse("""")    = """"
 * StringUtils.reverse(""bat"") = ""tab""
 * </pre>
 *
 * @param str  the String to reverse, may be null
 * @return the reversed String, {@code null} if null String input
 */
public static String reverse(String str) {
    if (str == null) {
        return null;
    }
    return new StringBuilder(str).reverse().toString();
}","public void test245430() throws Throwable {
    String string0 = StringUtils.defaultString(""F1}$>CNgUA3WZ"", ""F1}$>CNgUA3WZ"");
    String string1 = StringUtils.abbreviateMiddle(""F1}$>CNgUA3WZ"", ""F1}$>CNgUA3WZ"", (-2147));
    int int0 = StringUtils.indexOfDifference((CharSequence) ""F1}$>CNgUA3WZ"", (CharSequence) ""F1}$>CNgUA3WZ"");
    String string2 = StringUtils.reverse(""F1}$>CNgUA3WZ"");
    assertNotNull(string2);
}",""
"public static String substring(String str, int start, int end) {
    if (str == null) {
        return null;
    }
    // handle negatives
    if (end < 0) {
        // remember end is negative
        end = str.length() + end;
    }
    if (start < 0) {
        // remember start is negative
        start = str.length() + start;
    }
    // check length next
    if (end > str.length()) {
        end = str.length();
    }
    // if start is greater than end, return """"
    if (start > end) {
        return EMPTY;
    }
    if (start < 0) {
        start = 0;
    }
    if (end < 0) {
        end = 0;
    }
    return str.substring(start, end);
}","public void test245434() throws Throwable {
    String string0 = StringUtils.defaultString(""F1}$>CNgUA3WZ"", ""F1}$>CNgUA3WZ"");
    String string1 = StringUtils.abbreviateMiddle(""F1}$>CNgUA3WZ"", ""F1}$>CNgUA3WZ"", (-2147));
    int int0 = StringUtils.indexOfDifference((CharSequence) ""F1}$>CNgUA3WZ"", (CharSequence) ""F1}$>CNgUA3WZ"");
    String string2 = StringUtils.reverse(""F1}$>CNgUA3WZ"");
    String string3 = StringUtils.substring(""_"", (-1), 0);
    assertNotNull(string3);
}","/**
 * <p>Gets a substring from the specified String avoiding exceptions.</p>
 *
 * <p>A negative start position can be used to start/end {@code n}
 * characters from the end of the String.</p>
 *
 * <p>The returned substring starts with the character in the {@code start}
 * position and ends before the {@code end} position. All position counting is
 * zero-based -- i.e., to start at the beginning of the string use
 * {@code start = 0}. Negative start and end positions can be used to
 * specify offsets relative to the end of the String.</p>
 *
 * <p>If {@code start} is not strictly to the left of {@code end}, """"
 * is returned.</p>
 *
 * <pre>
 * StringUtils.substring(null, *, *)    = null
 * StringUtils.substring("""", * ,  *)    = """";
 * StringUtils.substring(""abc"", 0, 2)   = ""ab""
 * StringUtils.substring(""abc"", 2, 0)   = """"
 * StringUtils.substring(""abc"", 2, 4)   = ""c""
 * StringUtils.substring(""abc"", 4, 6)   = """"
 * StringUtils.substring(""abc"", 2, 2)   = """"
 * StringUtils.substring(""abc"", -2, -1) = ""b""
 * StringUtils.substring(""abc"", -4, 2)  = ""ab""
 * </pre>
 *
 * @param str  the String to get the substring from, may be null
 * @param start  the position to start from, negative means
 *  count back from the end of the String by this many characters
 * @param end  the position to end at (exclusive), negative means
 *  count back from the end of the String by this many characters
 * @return substring from start position to end positon,
 *  {@code null} if null String input
 */"
"public static String join(Object[] array, char separator, int startIndex, int endIndex) {
    if (array == null) {
        return null;
    }
    int noOfItems = (endIndex - startIndex);
    if (noOfItems <= 0) {
        return EMPTY;
    }
    StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}","public void test245439() throws Throwable {
    String string0 = StringUtils.defaultString(""F1}$>CNgUA3WZ"", ""F1}$>CNgUA3WZ"");
    String string1 = StringUtils.abbreviateMiddle(""F1}$>CNgUA3WZ"", ""F1}$>CNgUA3WZ"", (-2147));
    int int0 = StringUtils.indexOfDifference((CharSequence) ""F1}$>CNgUA3WZ"", (CharSequence) ""F1}$>CNgUA3WZ"");
    String string2 = StringUtils.reverse(""F1}$>CNgUA3WZ"");
    String string3 = StringUtils.substring(""_"", (-1), 0);
    Object[] objectArray0 = new Object[9];
    objectArray0[0] = (Object) ""_"";
    objectArray0[1] = (Object) """";
    objectArray0[2] = (Object) """";
    objectArray0[3] = (Object) ""F1}$>CNgUA3WZ"";
    objectArray0[4] = (Object) ""_"";
    objectArray0[5] = (Object) ""ZW3AUgNC>$}1F"";
    objectArray0[6] = (Object) ""ZW3AUgNC>$}1F"";
    objectArray0[7] = (Object) ""F1}$>CNgUA3WZ"";
    objectArray0[8] = (Object) ""_"";
    String string4 = StringUtils.join(objectArray0, 'Q', (-1), (-2147));
    assertEquals(9, objectArray0.length);
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)               = null
 * StringUtils.join([], *)                 = """"
 * StringUtils.join([null], *)             = """"
 * StringUtils.join([""a"", ""b"", ""c""], ';')  = ""a;b;c""
 * StringUtils.join([""a"", ""b"", ""c""], null) = ""abc""
 * StringUtils.join([null, """", ""a""], ';')  = "";;a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use
 * @param startIndex the first index to start joining from.  It is
 * an error to pass in an end index past the end of the array
 * @param endIndex the index to stop joining from (exclusive). It is
 * an error to pass in an end index past the end of the array
 * @return the joined String, {@code null} if null array input
 * @since 2.0
 */"
"public static String stripStart(String str, String stripChars) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    int start = 0;
    if (stripChars == null) {
        while ((start != strLen) && Character.isWhitespace(str.charAt(start))) {
            start++;
        }
    } else if (stripChars.length() == 0) {
        return str;
    } else {
        while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) {
            start++;
        }
    }
    return str.substring(start);
}","public void test246446() throws Throwable {
    String string0 = StringUtils.stripStart("""", """");
    assertNotNull(string0);
}","/**
 * <p>Strips any of a set of characters from the start of a String.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * An empty string ("""") input returns the empty string.</p>
 *
 * <p>If the stripChars String is {@code null}, whitespace is
 * stripped as defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripStart(null, *)          = null
 * StringUtils.stripStart("""", *)            = """"
 * StringUtils.stripStart(""abc"", """")        = ""abc""
 * StringUtils.stripStart(""abc"", null)      = ""abc""
 * StringUtils.stripStart(""  abc"", null)    = ""abc""
 * StringUtils.stripStart(""abc  "", null)    = ""abc  ""
 * StringUtils.stripStart("" abc "", null)    = ""abc ""
 * StringUtils.stripStart(""yxabc  "", ""xyz"") = ""abc  ""
 * </pre>
 *
 * @param str  the String to remove characters from, may be null
 * @param stripChars  the characters to remove, null treated as whitespace
 * @return the stripped String, {@code null} if null String input
 */"
"public static String mid(String str, int pos, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0 || pos > str.length()) {
        return EMPTY;
    }
    if (pos < 0) {
        pos = 0;
    }
    if (str.length() <= (pos + len)) {
        return str.substring(pos);
    }
    return str.substring(pos, pos + len);
}","public void test246448() throws Throwable {
    String string0 = StringUtils.stripStart("""", """");
    String string1 = StringUtils.mid("""", 168, (-3817));
    assertNotNull(string1);
}","/**
 * <p>Gets {@code len} characters from the middle of a String.</p>
 *
 * <p>If {@code len} characters are not available, the remainder
 * of the String will be returned without an exception. If the
 * String is {@code null}, {@code null} will be returned.
 * An empty String is returned if len is negative or exceeds the
 * length of {@code str}.</p>
 *
 * <pre>
 * StringUtils.mid(null, *, *)    = null
 * StringUtils.mid(*, *, -ve)     = """"
 * StringUtils.mid("""", 0, *)      = """"
 * StringUtils.mid(""abc"", 0, 2)   = ""ab""
 * StringUtils.mid(""abc"", 0, 4)   = ""abc""
 * StringUtils.mid(""abc"", 2, 4)   = ""c""
 * StringUtils.mid(""abc"", 4, 2)   = """"
 * StringUtils.mid(""abc"", -2, 2)  = ""ab""
 * </pre>
 *
 * @param str  the String to get the characters from, may be null
 * @param pos  the position to start from, negative treated as zero
 * @param len  the length of the required String
 * @return the middle characters, {@code null} if null String input
 */"
"public static String join(Object[] array, String separator) {
    if (array == null) {
        return null;
    }
    return join(array, separator, 0, array.length);
}","public void test246452() throws Throwable {
    String string0 = StringUtils.stripStart("""", """");
    String string1 = StringUtils.mid("""", 168, (-3817));
    Object[] objectArray0 = new Object[2];
    Object object0 = new Object();
    objectArray0[0] = object0;
    objectArray0[1] = (Object) """";
    String string2 = StringUtils.join(objectArray0, """");
    assertEquals(2, objectArray0.length);
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A {@code null} separator is the same as an empty String ("""").
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)                = null
 * StringUtils.join([], *)                  = """"
 * StringUtils.join([null], *)              = """"
 * StringUtils.join([""a"", ""b"", ""c""], ""--"")  = ""a--b--c""
 * StringUtils.join([""a"", ""b"", ""c""], null)  = ""abc""
 * StringUtils.join([""a"", ""b"", ""c""], """")    = ""abc""
 * StringUtils.join([null, """", ""a""], ',')   = "",,a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @return the joined String, {@code null} if null array input
 */"
"// StripAll
//-----------------------------------------------------------------------
/**
 * <p>Strips whitespace from the start and end of every String in an array.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <p>A new array is returned each time, except for length zero.
 * A {@code null} array will return {@code null}.
 * An empty array will return itself.
 * A {@code null} array entry will be ignored.</p>
 *
 * <pre>
 * StringUtils.stripAll(null)             = null
 * StringUtils.stripAll([])               = []
 * StringUtils.stripAll([""abc"", ""  abc""]) = [""abc"", ""abc""]
 * StringUtils.stripAll([""abc  "", null])  = [""abc"", null]
 * </pre>
 *
 * @param strs  the array to remove whitespace from, may be null
 * @return the stripped Strings, {@code null} if null array input
 */
public static String[] stripAll(String... strs) {
    return stripAll(strs, null);
}","public void test246456() throws Throwable {
    String string0 = StringUtils.stripStart("""", """");
    String string1 = StringUtils.mid("""", 168, (-3817));
    Object[] objectArray0 = new Object[2];
    Object object0 = new Object();
    objectArray0[0] = object0;
    objectArray0[1] = (Object) """";
    String string2 = StringUtils.join(objectArray0, """");
    String[] stringArray0 = new String[5];
    stringArray0[0] = ""java.lang.Object@13b2fd54"";
    stringArray0[1] = """";
    stringArray0[2] = """";
    stringArray0[3] = ""java.lang.Object@13b2fd54"";
    stringArray0[4] = """";
    String[] stringArray1 = StringUtils.stripAll(stringArray0);
    assertNotSame(stringArray0, stringArray1);
}",""
"public static String[] split(String str, String separatorChars, int max) {
    return splitWorker(str, separatorChars, max, false);
}","public void test246462() throws Throwable {
    String string0 = StringUtils.stripStart("""", """");
    String string1 = StringUtils.mid("""", 168, (-3817));
    Object[] objectArray0 = new Object[2];
    Object object0 = new Object();
    objectArray0[0] = object0;
    objectArray0[1] = (Object) """";
    String string2 = StringUtils.join(objectArray0, """");
    String[] stringArray0 = new String[5];
    stringArray0[0] = ""java.lang.Object@13b2fd54"";
    stringArray0[1] = """";
    stringArray0[2] = """";
    stringArray0[3] = ""java.lang.Object@13b2fd54"";
    stringArray0[4] = """";
    String[] stringArray1 = StringUtils.stripAll(stringArray0);
    String[] stringArray2 = StringUtils.split(""java.text.Normalizer$Form"", ""c"", 168);
    assertNotSame(stringArray2, stringArray0);
}","/**
 * <p>Splits the provided text into an array with a maximum length,
 * separators specified.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as one separator.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} separatorChars splits on whitespace.</p>
 *
 * <p>If more than {@code max} delimited substrings are found, the last
 * returned string includes all characters after the first {@code max - 1}
 * returned strings (including separator characters).</p>
 *
 * <pre>
 * StringUtils.split(null, *, *)            = null
 * StringUtils.split("""", *, *)              = []
 * StringUtils.split(""ab de fg"", null, 0)   = [""ab"", ""cd"", ""ef""]
 * StringUtils.split(""ab   de fg"", null, 0) = [""ab"", ""cd"", ""ef""]
 * StringUtils.split(""ab:cd:ef"", "":"", 0)    = [""ab"", ""cd"", ""ef""]
 * StringUtils.split(""ab:cd:ef"", "":"", 2)    = [""ab"", ""cd:ef""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @param separatorChars  the characters used as the delimiters,
 *  {@code null} splits on whitespace
 * @param max  the maximum number of elements to include in the
 *  array. A zero or negative value implies no limit
 * @return an array of parsed Strings, {@code null} if null String input
 */"
"public static String center(String str, int size, char padChar) {
    if (str == null || size <= 0) {
        return str;
    }
    int strLen = str.length();
    int pads = size - strLen;
    if (pads <= 0) {
        return str;
    }
    str = leftPad(str, strLen + pads / 2, padChar);
    str = rightPad(str, size, padChar);
    return str;
}","public void test247468() throws Throwable {
    String string0 = StringUtils.center(""Ozi3g)V?;ag*[m^D,IV"", (-4377), 'C');
    assertNotNull(string0);
}","/**
 * <p>Centers a String in a larger String of size {@code size}.
 * Uses a supplied character as the value to pad the String with.</p>
 *
 * <p>If the size is less than the String length, the String is returned.
 * A {@code null} String returns {@code null}.
 * A negative size is treated as zero.</p>
 *
 * <pre>
 * StringUtils.center(null, *, *)     = null
 * StringUtils.center("""", 4, ' ')     = ""    ""
 * StringUtils.center(""ab"", -1, ' ')  = ""ab""
 * StringUtils.center(""ab"", 4, ' ')   = "" ab""
 * StringUtils.center(""abcd"", 2, ' ') = ""abcd""
 * StringUtils.center(""a"", 4, ' ')    = "" a  ""
 * StringUtils.center(""a"", 4, 'y')    = ""yayy""
 * </pre>
 *
 * @param str  the String to center, may be null
 * @param size  the int size of new String, negative treated as zero
 * @param padChar  the character to pad the new String with
 * @return centered String, {@code null} if null String input
 * @since 2.0
 */"
"public static String repeat(char ch, int repeat) {
    char[] buf = new char[repeat];
    for (int i = repeat - 1; i >= 0; i--) {
        buf[i] = ch;
    }
    return new String(buf);
}","public void test247470() throws Throwable {
    String string0 = StringUtils.center(""Ozi3g)V?;ag*[m^D,IV"", (-4377), 'C');
    CharSequence[] charSequenceArray0 = new CharSequence[1];
    String string1 = StringUtils.repeat('h', 0);
    assertNotNull(string1);
}","/**
 * <p>Returns padding using the specified delimiter repeated
 * to a given length.</p>
 *
 * <pre>
 * StringUtils.repeat(0, 'e')  = """"
 * StringUtils.repeat(3, 'e')  = ""eee""
 * StringUtils.repeat(-2, 'e') = """"
 * </pre>
 *
 * <p>Note: this method doesn't not support padding with
 * <a href=""http://www.unicode.org/glossary/#supplementary_character"">Unicode Supplementary Characters</a>
 * as they require a pair of {@code char}s to be represented.
 * If you are needing to support full I18N of your applications
 * consider using {@link #repeat(String, int)} instead.
 * </p>
 *
 * @param ch  character to repeat
 * @param repeat  number of times to repeat char, negative treated as zero
 * @return String with repeated character
 * @see #repeat(String, int)
 */"
"public static int lastIndexOfAny(CharSequence str, CharSequence... searchStrs) {
    if (str == null || searchStrs == null) {
        return INDEX_NOT_FOUND;
    }
    int sz = searchStrs.length;
    int ret = INDEX_NOT_FOUND;
    int tmp = 0;
    for (int i = 0; i < sz; i++) {
        CharSequence search = searchStrs[i];
        if (search == null) {
            continue;
        }
        tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());
        if (tmp > ret) {
            ret = tmp;
        }
    }
    return ret;
}","public void test247473() throws Throwable {
    String string0 = StringUtils.center(""Ozi3g)V?;ag*[m^D,IV"", (-4377), 'C');
    CharSequence[] charSequenceArray0 = new CharSequence[1];
    String string1 = StringUtils.repeat('h', 0);
    charSequenceArray0[0] = (CharSequence) """";
    int int0 = StringUtils.lastIndexOfAny(""Ozi3g)V?;ag*[m^D,IV"", charSequenceArray0);
    assertEquals(1, charSequenceArray0.length);
}","/**
 * <p>Find the latest index of any of a set of potential substrings.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A {@code null} search array will return {@code -1}.
 * A {@code null} or zero length search array entry will be ignored,
 * but a search array containing """" will return the length of {@code str}
 * if {@code str} is not null. This method uses {@link String#indexOf(String)} if possible</p>
 *
 * <pre>
 * StringUtils.lastIndexOfAny(null, *)                   = -1
 * StringUtils.lastIndexOfAny(*, null)                   = -1
 * StringUtils.lastIndexOfAny(*, [])                     = -1
 * StringUtils.lastIndexOfAny(*, [null])                 = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""ab"",""cd""]) = 6
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""cd"",""ab""]) = 6
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""op""]) = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""op""]) = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""""])   = 10
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStrs  the CharSequences to search for, may be null
 * @return the last index of any of the CharSequences, -1 if no match
 * @since 3.0 Changed signature from lastIndexOfAny(String, String[]) to lastIndexOfAny(CharSequence, CharSequence)
 */"
"public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) {
    return StringUtils.isEmpty(str) ? defaultStr : str;
}","public void test247475() throws Throwable {
    String string0 = StringUtils.center(""Ozi3g)V?;ag*[m^D,IV"", (-4377), 'C');
    CharSequence[] charSequenceArray0 = new CharSequence[1];
    String string1 = StringUtils.repeat('h', 0);
    charSequenceArray0[0] = (CharSequence) """";
    int int0 = StringUtils.lastIndexOfAny(""Ozi3g)V?;ag*[m^D,IV"", charSequenceArray0);
    String string2 = StringUtils.defaultIfEmpty("""", ""Ozi3g)V?;ag*[m^D,IV"");
    assertNotNull(string2);
}","/**
 * <p>Returns either the passed in CharSequence, or if the CharSequence is
 * empty or {@code null}, the value of {@code defaultStr}.</p>
 *
 * <pre>
 * StringUtils.defaultIfEmpty(null, ""NULL"")  = ""NULL""
 * StringUtils.defaultIfEmpty("""", ""NULL"")    = ""NULL""
 * StringUtils.defaultIfEmpty(""bat"", ""NULL"") = ""bat""
 * StringUtils.defaultIfEmpty("""", null)      = null
 * </pre>
 * @param <T> the specific kind of CharSequence
 * @param str  the CharSequence to check, may be null
 * @param defaultStr  the default CharSequence to return
 *  if the input is empty ("""") or {@code null}, may be null
 * @return the passed in CharSequence, or the default
 * @see StringUtils#defaultString(String, String)
 */"
"public static boolean isAsciiPrintable(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test247479() throws Throwable {
    String string0 = StringUtils.center(""Ozi3g)V?;ag*[m^D,IV"", (-4377), 'C');
    CharSequence[] charSequenceArray0 = new CharSequence[1];
    String string1 = StringUtils.repeat('h', 0);
    charSequenceArray0[0] = (CharSequence) """";
    int int0 = StringUtils.lastIndexOfAny(""Ozi3g)V?;ag*[m^D,IV"", charSequenceArray0);
    String string2 = StringUtils.defaultIfEmpty("""", ""Ozi3g)V?;ag*[m^D,IV"");
    boolean boolean0 = StringUtils.isAsciiPrintable(charSequenceArray0[0]);
    assertEquals(1, charSequenceArray0.length);
}","/**
 * <p>Checks if the CharSequence contains only ASCII printable characters.</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty CharSequence (length()=0) will return {@code true}.</p>
 *
 * <pre>
 * StringUtils.isAsciiPrintable(null)     = false
 * StringUtils.isAsciiPrintable("""")       = true
 * StringUtils.isAsciiPrintable("" "")      = true
 * StringUtils.isAsciiPrintable(""Ceki"")   = true
 * StringUtils.isAsciiPrintable(""ab2c"")   = true
 * StringUtils.isAsciiPrintable(""!ab-c~"") = true
 * StringUtils.isAsciiPrintable(""\u0020"") = true
 * StringUtils.isAsciiPrintable(""\u0021"") = true
 * StringUtils.isAsciiPrintable(""\u007e"") = true
 * StringUtils.isAsciiPrintable(""\u007f"") = false
 * StringUtils.isAsciiPrintable(""Ceki G\u00fclc\u00fc"") = false
 * </pre>
 *
 * @param cs the CharSequence to check, may be null
 * @return {@code true} if every character is in the range
 *  32 thru 126
 * @since 2.1
 * @since 3.0 Changed signature from isAsciiPrintable(String) to isAsciiPrintable(CharSequence)
 */"
"public static String substring(String str, int start, int end) {
    if (str == null) {
        return null;
    }
    // handle negatives
    if (end < 0) {
        // remember end is negative
        end = str.length() + end;
    }
    if (start < 0) {
        // remember start is negative
        start = str.length() + start;
    }
    // check length next
    if (end > str.length()) {
        end = str.length();
    }
    // if start is greater than end, return """"
    if (start > end) {
        return EMPTY;
    }
    if (start < 0) {
        start = 0;
    }
    if (end < 0) {
        end = 0;
    }
    return str.substring(start, end);
}","public void test247481() throws Throwable {
    String string0 = StringUtils.center(""Ozi3g)V?;ag*[m^D,IV"", (-4377), 'C');
    CharSequence[] charSequenceArray0 = new CharSequence[1];
    String string1 = StringUtils.repeat('h', 0);
    charSequenceArray0[0] = (CharSequence) """";
    int int0 = StringUtils.lastIndexOfAny(""Ozi3g)V?;ag*[m^D,IV"", charSequenceArray0);
    String string2 = StringUtils.defaultIfEmpty("""", ""Ozi3g)V?;ag*[m^D,IV"");
    boolean boolean0 = StringUtils.isAsciiPrintable(charSequenceArray0[0]);
    String string3 = StringUtils.substring("""", 3085, 19);
    assertNotNull(string3);
}","/**
 * <p>Gets a substring from the specified String avoiding exceptions.</p>
 *
 * <p>A negative start position can be used to start/end {@code n}
 * characters from the end of the String.</p>
 *
 * <p>The returned substring starts with the character in the {@code start}
 * position and ends before the {@code end} position. All position counting is
 * zero-based -- i.e., to start at the beginning of the string use
 * {@code start = 0}. Negative start and end positions can be used to
 * specify offsets relative to the end of the String.</p>
 *
 * <p>If {@code start} is not strictly to the left of {@code end}, """"
 * is returned.</p>
 *
 * <pre>
 * StringUtils.substring(null, *, *)    = null
 * StringUtils.substring("""", * ,  *)    = """";
 * StringUtils.substring(""abc"", 0, 2)   = ""ab""
 * StringUtils.substring(""abc"", 2, 0)   = """"
 * StringUtils.substring(""abc"", 2, 4)   = ""c""
 * StringUtils.substring(""abc"", 4, 6)   = """"
 * StringUtils.substring(""abc"", 2, 2)   = """"
 * StringUtils.substring(""abc"", -2, -1) = ""b""
 * StringUtils.substring(""abc"", -4, 2)  = ""ab""
 * </pre>
 *
 * @param str  the String to get the substring from, may be null
 * @param start  the position to start from, negative means
 *  count back from the end of the String by this many characters
 * @param end  the position to end at (exclusive), negative means
 *  count back from the end of the String by this many characters
 * @return substring from start position to end positon,
 *  {@code null} if null String input
 */"
"public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {
    return splitWorker(str, separatorChars, max, true);
}","public void test247486() throws Throwable {
    String string0 = StringUtils.center(""Ozi3g)V?;ag*[m^D,IV"", (-4377), 'C');
    CharSequence[] charSequenceArray0 = new CharSequence[1];
    String string1 = StringUtils.repeat('h', 0);
    charSequenceArray0[0] = (CharSequence) """";
    int int0 = StringUtils.lastIndexOfAny(""Ozi3g)V?;ag*[m^D,IV"", charSequenceArray0);
    String string2 = StringUtils.defaultIfEmpty("""", ""Ozi3g)V?;ag*[m^D,IV"");
    boolean boolean0 = StringUtils.isAsciiPrintable(charSequenceArray0[0]);
    String string3 = StringUtils.substring("""", 3085, 19);
    String[] stringArray0 = StringUtils.splitPreserveAllTokens("""", """", 433);
    assertEquals(0, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array with a maximum length,
 * separators specified, preserving all tokens, including empty tokens
 * created by adjacent separators.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as separators for empty tokens.
 * Adjacent separators are treated as one separator.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} separatorChars splits on whitespace.</p>
 *
 * <p>If more than {@code max} delimited substrings are found, the last
 * returned string includes all characters after the first {@code max - 1}
 * returned strings (including separator characters).</p>
 *
 * <pre>
 * StringUtils.splitPreserveAllTokens(null, *, *)            = null
 * StringUtils.splitPreserveAllTokens("""", *, *)              = []
 * StringUtils.splitPreserveAllTokens(""ab de fg"", null, 0)   = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 0) = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef"", "":"", 0)    = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef"", "":"", 2)    = [""ab"", ""cd:ef""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 2) = [""ab"", ""  de fg""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 3) = [""ab"", """", "" de fg""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 4) = [""ab"", """", """", ""de fg""]
 * </pre>
 *
 * @param str  the String to parse, may be {@code null}
 * @param separatorChars  the characters used as the delimiters,
 *  {@code null} splits on whitespace
 * @param max  the maximum number of elements to include in the
 *  array. A zero or negative value implies no limit
 * @return an array of parsed Strings, {@code null} if null String input
 * @since 2.1
 */"
"public static boolean isWhitespace(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if ((Character.isWhitespace(cs.charAt(i)) == false)) {
            return false;
        }
    }
    return true;
}","public void test247488() throws Throwable {
    String string0 = StringUtils.center(""Ozi3g)V?;ag*[m^D,IV"", (-4377), 'C');
    CharSequence[] charSequenceArray0 = new CharSequence[1];
    String string1 = StringUtils.repeat('h', 0);
    charSequenceArray0[0] = (CharSequence) """";
    int int0 = StringUtils.lastIndexOfAny(""Ozi3g)V?;ag*[m^D,IV"", charSequenceArray0);
    String string2 = StringUtils.defaultIfEmpty("""", ""Ozi3g)V?;ag*[m^D,IV"");
    boolean boolean0 = StringUtils.isAsciiPrintable(charSequenceArray0[0]);
    String string3 = StringUtils.substring("""", 3085, 19);
    String[] stringArray0 = StringUtils.splitPreserveAllTokens("""", """", 433);
    boolean boolean1 = StringUtils.isWhitespace(""Ozi3g)V?;ag*[m^D,IV"");
    assertFalse(boolean1);
}","/**
 * <p>Checks if the CharSequence contains only whitespace.</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty CharSequence (length()=0) will return {@code true}.</p>
 *
 * <pre>
 * StringUtils.isWhitespace(null)   = false
 * StringUtils.isWhitespace("""")     = true
 * StringUtils.isWhitespace(""  "")   = true
 * StringUtils.isWhitespace(""abc"")  = false
 * StringUtils.isWhitespace(""ab2c"") = false
 * StringUtils.isWhitespace(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if only contains whitespace, and is non-null
 * @since 2.0
 * @since 3.0 Changed signature from isWhitespace(String) to isWhitespace(CharSequence)
 */"
"public static String replaceChars(String str, String searchChars, String replaceChars) {
    if (isEmpty(str) || isEmpty(searchChars)) {
        return str;
    }
    if (replaceChars == null) {
        replaceChars = EMPTY;
    }
    boolean modified = false;
    int replaceCharsLength = replaceChars.length();
    int strLength = str.length();
    StringBuilder buf = new StringBuilder(strLength);
    for (int i = 0; i < strLength; i++) {
        char ch = str.charAt(i);
        int index = searchChars.indexOf(ch);
        if (index >= 0) {
            modified = true;
            if (index < replaceCharsLength) {
                buf.append(replaceChars.charAt(index));
            }
        } else {
            buf.append(ch);
        }
    }
    if (modified) {
        return buf.toString();
    }
    return str;
}","public void test247490() throws Throwable {
    String string0 = StringUtils.center(""Ozi3g)V?;ag*[m^D,IV"", (-4377), 'C');
    CharSequence[] charSequenceArray0 = new CharSequence[1];
    String string1 = StringUtils.repeat('h', 0);
    charSequenceArray0[0] = (CharSequence) """";
    int int0 = StringUtils.lastIndexOfAny(""Ozi3g)V?;ag*[m^D,IV"", charSequenceArray0);
    String string2 = StringUtils.defaultIfEmpty("""", ""Ozi3g)V?;ag*[m^D,IV"");
    boolean boolean0 = StringUtils.isAsciiPrintable(charSequenceArray0[0]);
    String string3 = StringUtils.substring("""", 3085, 19);
    String[] stringArray0 = StringUtils.splitPreserveAllTokens("""", """", 433);
    boolean boolean1 = StringUtils.isWhitespace(""Ozi3g)V?;ag*[m^D,IV"");
    String string4 = StringUtils.replaceChars("""", ""Ozi3g)V?;ag*[m^D,IV"", """");
    assertNotNull(string4);
}","/**
 * <p>Replaces multiple characters in a String in one go.
 * This method can also be used to delete characters.</p>
 *
 * <p>For example:<br />
 * <code>replaceChars(&quot;hello&quot;, &quot;ho&quot;, &quot;jy&quot;) = jelly</code>.</p>
 *
 * <p>A {@code null} string input returns {@code null}.
 * An empty ("""") string input returns an empty string.
 * A null or empty set of search characters returns the input string.</p>
 *
 * <p>The length of the search characters should normally equal the length
 * of the replace characters.
 * If the search characters is longer, then the extra search characters
 * are deleted.
 * If the search characters is shorter, then the extra replace characters
 * are ignored.</p>
 *
 * <pre>
 * StringUtils.replaceChars(null, *, *)           = null
 * StringUtils.replaceChars("""", *, *)             = """"
 * StringUtils.replaceChars(""abc"", null, *)       = ""abc""
 * StringUtils.replaceChars(""abc"", """", *)         = ""abc""
 * StringUtils.replaceChars(""abc"", ""b"", null)     = ""ac""
 * StringUtils.replaceChars(""abc"", ""b"", """")       = ""ac""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""yz"")  = ""ayzya""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""y"")   = ""ayya""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""yzx"") = ""ayzya""
 * </pre>
 *
 * @param str  String to replace characters in, may be null
 * @param searchChars  a set of characters to search for, may be null
 * @param replaceChars  a set of characters to replace, may be null
 * @return modified String, {@code null} if null string input
 * @since 2.0
 */"
"public static String leftPad(String str, int size, char padChar) {
    if (str == null) {
        return null;
    }
    int pads = size - str.length();
    if (pads <= 0) {
        // returns original String when possible
        return str;
    }
    if (pads > PAD_LIMIT) {
        return leftPad(str, size, String.valueOf(padChar));
    }
    return repeat(padChar, pads).concat(str);
}","public void test247496() throws Throwable {
    String string0 = StringUtils.center(""Ozi3g)V?;ag*[m^D,IV"", (-4377), 'C');
    CharSequence[] charSequenceArray0 = new CharSequence[1];
    String string1 = StringUtils.repeat('h', 0);
    charSequenceArray0[0] = (CharSequence) """";
    int int0 = StringUtils.lastIndexOfAny(""Ozi3g)V?;ag*[m^D,IV"", charSequenceArray0);
    String string2 = StringUtils.defaultIfEmpty("""", ""Ozi3g)V?;ag*[m^D,IV"");
    boolean boolean0 = StringUtils.isAsciiPrintable(charSequenceArray0[0]);
    String string3 = StringUtils.substring("""", 3085, 19);
    String[] stringArray0 = StringUtils.splitPreserveAllTokens("""", """", 433);
    boolean boolean1 = StringUtils.isWhitespace(""Ozi3g)V?;ag*[m^D,IV"");
    String string4 = StringUtils.replaceChars("""", ""Ozi3g)V?;ag*[m^D,IV"", """");
    String string5 = StringUtils.leftPad("", '"", 0, 'C');
    assertNotNull(string5);
}","/**
 * <p>Left pad a String with a specified character.</p>
 *
 * <p>Pad to a size of {@code size}.</p>
 *
 * <pre>
 * StringUtils.leftPad(null, *, *)     = null
 * StringUtils.leftPad("""", 3, 'z')     = ""zzz""
 * StringUtils.leftPad(""bat"", 3, 'z')  = ""bat""
 * StringUtils.leftPad(""bat"", 5, 'z')  = ""zzbat""
 * StringUtils.leftPad(""bat"", 1, 'z')  = ""bat""
 * StringUtils.leftPad(""bat"", -1, 'z') = ""bat""
 * </pre>
 *
 * @param str  the String to pad out, may be null
 * @param size  the size to pad to
 * @param padChar  the character to pad with
 * @return left padded String or original String if no padding is necessary,
 *  {@code null} if null String input
 * @since 2.0
 */"
"public static int getLevenshteinDistance(CharSequence s, CharSequence t, int threshold) {
    if (s == null || t == null) {
        throw new IllegalArgumentException(""Strings must not be null"");
    }
    if (threshold < 0) {
        throw new IllegalArgumentException(""Threshold must not be negative"");
    }
    /*
        This implementation only computes the distance if it's less than or equal to the
        threshold value, returning -1 if it's greater.  The advantage is performance: unbounded
        distance is O(nm), but a bound of k allows us to reduce it to O(km) time by only 
        computing a diagonal stripe of width 2k + 1 of the cost table.
        It is also possible to use this to compute the unbounded Levenshtein distance by starting
        the threshold at 1 and doubling each time until the distance is found; this is O(dm), where
        d is the distance.
        
        One subtlety comes from needing to ignore entries on the border of our stripe
        eg.
        p[] = |#|#|#|*
        d[] =  *|#|#|#|
        We must ignore the entry to the left of the leftmost member
        We must ignore the entry above the rightmost member
        
        Another subtlety comes from our stripe running off the matrix if the strings aren't
        of the same size.  Since string s is always swapped to be the shorter of the two, 
        the stripe will always run off to the upper right instead of the lower left of the matrix.
        
        As a concrete example, suppose s is of length 5, t is of length 7, and our threshold is 1.
        In this case we're going to walk a stripe of length 3.  The matrix would look like so:
        
           1 2 3 4 5
        1 |#|#| | | |
        2 |#|#|#| | |
        3 | |#|#|#| |
        4 | | |#|#|#|
        5 | | | |#|#|
        6 | | | | |#|
        7 | | | | | |

        Note how the stripe leads off the table as there is no possible way to turn a string of length 5
        into one of length 7 in edit distance of 1.
        
        Additionally, this implementation decreases memory usage by using two 
        single-dimensional arrays and swapping them back and forth instead of allocating
        an entire n by m matrix.  This requires a few minor changes, such as immediately returning 
        when it's detected that the stripe has run off the matrix and initially filling the arrays with
        large values so that entries we don't compute are ignored.

        See Algorithms on Strings, Trees and Sequences by Dan Gusfield for some discussion.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    // if one string is empty, the edit distance is necessarily the length of the other
    if (n == 0) {
        return m <= threshold ? m : -1;
    } else if (m == 0) {
        return n <= threshold ? n : -1;
    }
    if (n > m) {
        // swap the two strings to consume less memory
        CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    // 'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    // placeholder to assist in swapping p and d
    int[] _d;
    // fill in starting table values
    int boundary = Math.min(n, threshold) + 1;
    for (int i = 0; i < boundary; i++) {
        p[i] = i;
    }
    // these fills ensure that the value above the rightmost entry of our
    // stripe will be ignored in following loop iterations
    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);
    Arrays.fill(d, Integer.MAX_VALUE);
    // iterates through t
    for (int j = 1; j <= m; j++) {
        // jth character of t
        char t_j = t.charAt(j - 1);
        d[0] = j;
        // compute stripe indices, constrain to array size
        int min = Math.max(1, j - threshold);
        int max = Math.min(n, j + threshold);
        // the stripe may lead off of the table if s and t are of different sizes
        if (min > max) {
            return -1;
        }
        // ignore entry left of leftmost
        if (min > 1) {
            d[min - 1] = Integer.MAX_VALUE;
        }
        // iterates through [min, max] in s
        for (int i = min; i <= max; i++) {
            if (s.charAt(i - 1) == t_j) {
                // diagonally left and up
                d[i] = p[i - 1];
            } else {
                // 1 + minimum of cell to the left, to the top, diagonally left and up
                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);
            }
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // if p[n] is greater than the threshold, there's no guarantee on it being the correct
    // distance
    if (p[n] <= threshold) {
        return p[n];
    } else {
        return -1;
    }
}","public void test247503() throws Throwable {
    String string0 = StringUtils.center(""Ozi3g)V?;ag*[m^D,IV"", (-4377), 'C');
    CharSequence[] charSequenceArray0 = new CharSequence[1];
    String string1 = StringUtils.repeat('h', 0);
    charSequenceArray0[0] = (CharSequence) """";
    int int0 = StringUtils.lastIndexOfAny(""Ozi3g)V?;ag*[m^D,IV"", charSequenceArray0);
    String string2 = StringUtils.defaultIfEmpty("""", ""Ozi3g)V?;ag*[m^D,IV"");
    boolean boolean0 = StringUtils.isAsciiPrintable(charSequenceArray0[0]);
    String string3 = StringUtils.substring("""", 3085, 19);
    String[] stringArray0 = StringUtils.splitPreserveAllTokens("""", """", 433);
    boolean boolean1 = StringUtils.isWhitespace(""Ozi3g)V?;ag*[m^D,IV"");
    String string4 = StringUtils.replaceChars("""", ""Ozi3g)V?;ag*[m^D,IV"", """");
    String string5 = StringUtils.leftPad("", '"", 0, 'C');
    // Undeclared exception!
    try {
        StringUtils.getLevenshteinDistance((CharSequence) """", (CharSequence) "", '"", (-4377));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Threshold must not be negative
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}","/**
 * <p>Find the Levenshtein distance between two Strings if it's less than or equal to a given
 * threshold.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>This implementation follows from Algorithms on Strings, Trees and Sequences by Dan Gusfield
 * and Chas Emerick's implementation of the Levenshtein distance algorithm from
 * <a href=""http://www.merriampark.com/ld.htm"">http://www.merriampark.com/ld.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, *, -1)               = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("""","""", 0)               = 0
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 8)       = 7
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 7)       = 7
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 6))      = -1
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"", 7) = 7
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"", 6) = -1
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"", 7) = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"", 6) = -1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @param threshold the target threshold, must not be negative
 * @return result distance, or {@code -1} if the distance would be greater than the threshold
 * @throws IllegalArgumentException if either String input {@code null} or negative threshold
 */"
"public static String[] splitPreserveAllTokens(String str, char separatorChar) {
    return splitWorker(str, separatorChar, true);
}","public void test248504() throws Throwable {
    char char0 = ':';
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""Xs*@5EX"", ':');
    assertEquals(1, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array, separator specified,
 * preserving all tokens, including empty tokens created by adjacent
 * separators. This is an alternative to using StringTokenizer.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as separators for empty tokens.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.splitPreserveAllTokens(null, *)         = null
 * StringUtils.splitPreserveAllTokens("""", *)           = []
 * StringUtils.splitPreserveAllTokens(""a.b.c"", '.')    = [""a"", ""b"", ""c""]
 * StringUtils.splitPreserveAllTokens(""a..b.c"", '.')   = [""a"", """", ""b"", ""c""]
 * StringUtils.splitPreserveAllTokens(""a:b:c"", '.')    = [""a:b:c""]
 * StringUtils.splitPreserveAllTokens(""a\tb\nc"", null) = [""a"", ""b"", ""c""]
 * StringUtils.splitPreserveAllTokens(""a b c"", ' ')    = [""a"", ""b"", ""c""]
 * StringUtils.splitPreserveAllTokens(""a b c "", ' ')   = [""a"", ""b"", ""c"", """"]
 * StringUtils.splitPreserveAllTokens(""a b c  "", ' ')   = [""a"", ""b"", ""c"", """", """"]
 * StringUtils.splitPreserveAllTokens("" a b c"", ' ')   = ["""", a"", ""b"", ""c""]
 * StringUtils.splitPreserveAllTokens(""  a b c"", ' ')  = ["""", """", a"", ""b"", ""c""]
 * StringUtils.splitPreserveAllTokens("" a b c "", ' ')  = ["""", a"", ""b"", ""c"", """"]
 * </pre>
 *
 * @param str  the String to parse, may be {@code null}
 * @param separatorChar  the character used as the delimiter,
 *  {@code null} splits on whitespace
 * @return an array of parsed Strings, {@code null} if null String input
 * @since 2.1
 */"
"public static String leftPad(String str, int size, char padChar) {
    if (str == null) {
        return null;
    }
    int pads = size - str.length();
    if (pads <= 0) {
        // returns original String when possible
        return str;
    }
    if (pads > PAD_LIMIT) {
        return leftPad(str, size, String.valueOf(padChar));
    }
    return repeat(padChar, pads).concat(str);
}","public void test248506() throws Throwable {
    char char0 = ':';
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""Xs*@5EX"", ':');
    String string0 = StringUtils.leftPad(""zI`2E`"", 2002, '?');
    assertNotNull(string0);
}","/**
 * <p>Left pad a String with a specified character.</p>
 *
 * <p>Pad to a size of {@code size}.</p>
 *
 * <pre>
 * StringUtils.leftPad(null, *, *)     = null
 * StringUtils.leftPad("""", 3, 'z')     = ""zzz""
 * StringUtils.leftPad(""bat"", 3, 'z')  = ""bat""
 * StringUtils.leftPad(""bat"", 5, 'z')  = ""zzbat""
 * StringUtils.leftPad(""bat"", 1, 'z')  = ""bat""
 * StringUtils.leftPad(""bat"", -1, 'z') = ""bat""
 * </pre>
 *
 * @param str  the String to pad out, may be null
 * @param size  the size to pad to
 * @param padChar  the character to pad with
 * @return left padded String or original String if no padding is necessary,
 *  {@code null} if null String input
 * @since 2.0
 */"
"public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {
    return splitWorker(str, separatorChars, max, true);
}","public void test248507() throws Throwable {
    char char0 = ':';
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""Xs*@5EX"", ':');
    String string0 = StringUtils.leftPad(""zI`2E`"", 2002, '?');
    String[] stringArray1 = StringUtils.splitPreserveAllTokens(""zI`2E`"", string0, 232);
    assertNotSame(stringArray1, stringArray0);
}","/**
 * <p>Splits the provided text into an array with a maximum length,
 * separators specified, preserving all tokens, including empty tokens
 * created by adjacent separators.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as separators for empty tokens.
 * Adjacent separators are treated as one separator.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} separatorChars splits on whitespace.</p>
 *
 * <p>If more than {@code max} delimited substrings are found, the last
 * returned string includes all characters after the first {@code max - 1}
 * returned strings (including separator characters).</p>
 *
 * <pre>
 * StringUtils.splitPreserveAllTokens(null, *, *)            = null
 * StringUtils.splitPreserveAllTokens("""", *, *)              = []
 * StringUtils.splitPreserveAllTokens(""ab de fg"", null, 0)   = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 0) = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef"", "":"", 0)    = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef"", "":"", 2)    = [""ab"", ""cd:ef""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 2) = [""ab"", ""  de fg""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 3) = [""ab"", """", "" de fg""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 4) = [""ab"", """", """", ""de fg""]
 * </pre>
 *
 * @param str  the String to parse, may be {@code null}
 * @param separatorChars  the characters used as the delimiters,
 *  {@code null} splits on whitespace
 * @param max  the maximum number of elements to include in the
 *  array. A zero or negative value implies no limit
 * @return an array of parsed Strings, {@code null} if null String input
 * @since 2.1
 */"
"public static String stripStart(String str, String stripChars) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    int start = 0;
    if (stripChars == null) {
        while ((start != strLen) && Character.isWhitespace(str.charAt(start))) {
            start++;
        }
    } else if (stripChars.length() == 0) {
        return str;
    } else {
        while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) {
            start++;
        }
    }
    return str.substring(start);
}","public void test248511() throws Throwable {
    char char0 = ':';
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""Xs*@5EX"", ':');
    String string0 = StringUtils.leftPad(""zI`2E`"", 2002, '?');
    String[] stringArray1 = StringUtils.splitPreserveAllTokens(""zI`2E`"", string0, 232);
    String string1 = StringUtils.stripStart("""", ""Xs*@5EX"");
    assertNotNull(string1);
}","/**
 * <p>Strips any of a set of characters from the start of a String.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * An empty string ("""") input returns the empty string.</p>
 *
 * <p>If the stripChars String is {@code null}, whitespace is
 * stripped as defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripStart(null, *)          = null
 * StringUtils.stripStart("""", *)            = """"
 * StringUtils.stripStart(""abc"", """")        = ""abc""
 * StringUtils.stripStart(""abc"", null)      = ""abc""
 * StringUtils.stripStart(""  abc"", null)    = ""abc""
 * StringUtils.stripStart(""abc  "", null)    = ""abc  ""
 * StringUtils.stripStart("" abc "", null)    = ""abc ""
 * StringUtils.stripStart(""yxabc  "", ""xyz"") = ""abc  ""
 * </pre>
 *
 * @param str  the String to remove characters from, may be null
 * @param stripChars  the characters to remove, null treated as whitespace
 * @return the stripped String, {@code null} if null String input
 */"
"// Conversion
//-----------------------------------------------------------------------
// Padding
//-----------------------------------------------------------------------
/**
 * <p>Repeat a String {@code repeat} times to form a
 * new String.</p>
 *
 * <pre>
 * StringUtils.repeat(null, 2) = null
 * StringUtils.repeat("""", 0)   = """"
 * StringUtils.repeat("""", 2)   = """"
 * StringUtils.repeat(""a"", 3)  = ""aaa""
 * StringUtils.repeat(""ab"", 2) = ""abab""
 * StringUtils.repeat(""a"", -2) = """"
 * </pre>
 *
 * @param str  the String to repeat, may be null
 * @param repeat  number of times to repeat str, negative treated as zero
 * @return a new String consisting of the original String repeated,
 *  {@code null} if null String input
 */
public static String repeat(String str, int repeat) {
    // Performance tuned for 2.0 (JDK1.4)
    if (str == null) {
        return null;
    }
    if (repeat <= 0) {
        return EMPTY;
    }
    int inputLength = str.length();
    if (repeat == 1 || inputLength == 0) {
        return str;
    }
    if (inputLength == 1 && repeat <= PAD_LIMIT) {
        return repeat(str.charAt(0), repeat);
    }
    int outputLength = inputLength * repeat;
    switch(inputLength) {
        case 1:
            return repeat(str.charAt(0), repeat);
        case 2:
            char ch0 = str.charAt(0);
            char ch1 = str.charAt(1);
            char[] output2 = new char[outputLength];
            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {
                output2[i] = ch0;
                output2[i + 1] = ch1;
            }
            return new String(output2);
        default:
            StringBuilder buf = new StringBuilder(outputLength);
            for (int i = 0; i < repeat; i++) {
                buf.append(str);
            }
            return buf.toString();
    }
}","public void test249514() throws Throwable {
    int int0 = 4492;
    String string0 = StringUtils.repeat("""", 4492);
    assertNotNull(string0);
}",""
"public static boolean containsNone(CharSequence cs, String invalidChars) {
    if (cs == null || invalidChars == null) {
        return true;
    }
    return containsNone(cs, invalidChars.toCharArray());
}","public void test249516() throws Throwable {
    int int0 = 4492;
    String string0 = StringUtils.repeat("""", 4492);
    boolean boolean0 = StringUtils.containsNone((CharSequence) """", """");
    assertTrue(boolean0);
}","/**
 * <p>Checks that the CharSequence does not contain certain characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code true}.
 * A {@code null} invalid character array will return {@code true}.
 * An empty String ("""") always returns true.</p>
 *
 * <pre>
 * StringUtils.containsNone(null, *)       = true
 * StringUtils.containsNone(*, null)       = true
 * StringUtils.containsNone("""", *)         = true
 * StringUtils.containsNone(""ab"", """")      = true
 * StringUtils.containsNone(""abab"", ""xyz"") = true
 * StringUtils.containsNone(""ab1"", ""xyz"")  = true
 * StringUtils.containsNone(""abz"", ""xyz"")  = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param invalidChars  a String of invalid chars, may be null
 * @return true if it contains none of the invalid chars, or is null
 * @since 2.0
 * @since 3.0 Changed signature from containsNone(String, String) to containsNone(CharSequence, String)
 */"
"// -----------------------------------------------------------------------
/**
 * <p>Splits the provided text into an array, using whitespace as the
 * separator, preserving all tokens, including empty tokens created by
 * adjacent separators. This is an alternative to using StringTokenizer.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as separators for empty tokens.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.splitPreserveAllTokens(null)       = null
 * StringUtils.splitPreserveAllTokens("""")         = []
 * StringUtils.splitPreserveAllTokens(""abc def"")  = [""abc"", ""def""]
 * StringUtils.splitPreserveAllTokens(""abc  def"") = [""abc"", """", ""def""]
 * StringUtils.splitPreserveAllTokens("" abc "")    = ["""", ""abc"", """"]
 * </pre>
 *
 * @param str  the String to parse, may be {@code null}
 * @return an array of parsed Strings, {@code null} if null String input
 * @since 2.1
 */
public static String[] splitPreserveAllTokens(String str) {
    return splitWorker(str, null, -1, true);
}","public void test249517() throws Throwable {
    int int0 = 4492;
    String string0 = StringUtils.repeat("""", 4492);
    boolean boolean0 = StringUtils.containsNone((CharSequence) """", """");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens("""");
    assertEquals(0, stringArray0.length);
}",""
"public static boolean containsNone(CharSequence cs, String invalidChars) {
    if (cs == null || invalidChars == null) {
        return true;
    }
    return containsNone(cs, invalidChars.toCharArray());
}","public void test249519() throws Throwable {
    int int0 = 4492;
    String string0 = StringUtils.repeat("""", 4492);
    boolean boolean0 = StringUtils.containsNone((CharSequence) """", """");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens("""");
    boolean boolean1 = StringUtils.containsNone((CharSequence) """", ""n"");
    assertTrue(boolean1);
}","/**
 * <p>Checks that the CharSequence does not contain certain characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code true}.
 * A {@code null} invalid character array will return {@code true}.
 * An empty String ("""") always returns true.</p>
 *
 * <pre>
 * StringUtils.containsNone(null, *)       = true
 * StringUtils.containsNone(*, null)       = true
 * StringUtils.containsNone("""", *)         = true
 * StringUtils.containsNone(""ab"", """")      = true
 * StringUtils.containsNone(""abab"", ""xyz"") = true
 * StringUtils.containsNone(""ab1"", ""xyz"")  = true
 * StringUtils.containsNone(""abz"", ""xyz"")  = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param invalidChars  a String of invalid chars, may be null
 * @return true if it contains none of the invalid chars, or is null
 * @since 2.0
 * @since 3.0 Changed signature from containsNone(String, String) to containsNone(CharSequence, String)
 */"
"public static String[] stripAll(String[] strs, String stripChars) {
    int strsLen;
    if (strs == null || (strsLen = strs.length) == 0) {
        return strs;
    }
    String[] newArr = new String[strsLen];
    for (int i = 0; i < strsLen; i++) {
        newArr[i] = strip(strs[i], stripChars);
    }
    return newArr;
}","public void test249521() throws Throwable {
    int int0 = 4492;
    String string0 = StringUtils.repeat("""", 4492);
    boolean boolean0 = StringUtils.containsNone((CharSequence) """", """");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens("""");
    boolean boolean1 = StringUtils.containsNone((CharSequence) """", ""n"");
    String string1 = ""\\u00"";
    String[] stringArray1 = StringUtils.stripAll(stringArray0, string1);
    assertSame(stringArray0, stringArray1);
}","/**
 * <p>Strips any of a set of characters from the start and end of every
 * String in an array.</p>
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <p>A new array is returned each time, except for length zero.
 * A {@code null} array will return {@code null}.
 * An empty array will return itself.
 * A {@code null} array entry will be ignored.
 * A {@code null} stripChars will strip whitespace as defined by
 * {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripAll(null, *)                = null
 * StringUtils.stripAll([], *)                  = []
 * StringUtils.stripAll([""abc"", ""  abc""], null) = [""abc"", ""abc""]
 * StringUtils.stripAll([""abc  "", null], null)  = [""abc"", null]
 * StringUtils.stripAll([""abc  "", null], ""yz"")  = [""abc  "", null]
 * StringUtils.stripAll([""yabcz"", null], ""yz"")  = [""abc"", null]
 * </pre>
 *
 * @param strs  the array to remove characters from, may be null
 * @param stripChars  the characters to remove, null treated as whitespace
 * @return the stripped Strings, {@code null} if null array input
 */"
"public static String repeat(char ch, int repeat) {
    char[] buf = new char[repeat];
    for (int i = repeat - 1; i >= 0; i--) {
        buf[i] = ch;
    }
    return new String(buf);
}","public void test249527() throws Throwable {
    int int0 = 4492;
    String string0 = StringUtils.repeat("""", 4492);
    boolean boolean0 = StringUtils.containsNone((CharSequence) """", """");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens("""");
    boolean boolean1 = StringUtils.containsNone((CharSequence) """", ""n"");
    String string1 = ""\\u00"";
    String[] stringArray1 = StringUtils.stripAll(stringArray0, string1);
    String string2 = StringUtils.repeat('f', 4492);
    assertNotNull(string2);
}","/**
 * <p>Returns padding using the specified delimiter repeated
 * to a given length.</p>
 *
 * <pre>
 * StringUtils.repeat(0, 'e')  = """"
 * StringUtils.repeat(3, 'e')  = ""eee""
 * StringUtils.repeat(-2, 'e') = """"
 * </pre>
 *
 * <p>Note: this method doesn't not support padding with
 * <a href=""http://www.unicode.org/glossary/#supplementary_character"">Unicode Supplementary Characters</a>
 * as they require a pair of {@code char}s to be represented.
 * If you are needing to support full I18N of your applications
 * consider using {@link #repeat(String, int)} instead.
 * </p>
 *
 * @param ch  character to repeat
 * @param repeat  number of times to repeat char, negative treated as zero
 * @return String with repeated character
 * @see #repeat(String, int)
 */"
"public static String trimToEmpty(String str) {
    return str == null ? EMPTY : str.trim();
}","public void test249530() throws Throwable {
    int int0 = 4492;
    String string0 = StringUtils.repeat("""", 4492);
    boolean boolean0 = StringUtils.containsNone((CharSequence) """", """");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens("""");
    boolean boolean1 = StringUtils.containsNone((CharSequence) """", ""n"");
    String string1 = ""\\u00"";
    String[] stringArray1 = StringUtils.stripAll(stringArray0, string1);
    String string2 = StringUtils.repeat('f', 4492);
    String string3 = StringUtils.trimToEmpty(string2);
    assertNotNull(string3);
}","/**
 * <p>Removes control characters (char &lt;= 32) from both
 * ends of this String returning an empty String ("""") if the String
 * is empty ("""") after the trim or if it is {@code null}.
 *
 * <p>The String is trimmed using {@link String#trim()}.
 * Trim removes start and end characters &lt;= 32.
 * To strip whitespace use {@link #stripToEmpty(String)}.</p>
 *
 * <pre>
 * StringUtils.trimToEmpty(null)          = """"
 * StringUtils.trimToEmpty("""")            = """"
 * StringUtils.trimToEmpty(""     "")       = """"
 * StringUtils.trimToEmpty(""abc"")         = ""abc""
 * StringUtils.trimToEmpty(""    abc    "") = ""abc""
 * </pre>
 *
 * @param str  the String to be trimmed, may be null
 * @return the trimmed String, or an empty String if {@code null} input
 * @since 2.0
 */"
"public static String leftPad(String str, int size, char padChar) {
    if (str == null) {
        return null;
    }
    int pads = size - str.length();
    if (pads <= 0) {
        // returns original String when possible
        return str;
    }
    if (pads > PAD_LIMIT) {
        return leftPad(str, size, String.valueOf(padChar));
    }
    return repeat(padChar, pads).concat(str);
}","public void test249535() throws Throwable {
    int int0 = 4492;
    String string0 = StringUtils.repeat("""", 4492);
    boolean boolean0 = StringUtils.containsNone((CharSequence) """", """");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens("""");
    boolean boolean1 = StringUtils.containsNone((CharSequence) """", ""n"");
    String string1 = ""\\u00"";
    String[] stringArray1 = StringUtils.stripAll(stringArray0, string1);
    String string2 = StringUtils.repeat('f', 4492);
    String string3 = StringUtils.trimToEmpty(string2);
    String string4 = ""DDb\""N+yvh"";
    String string5 = StringUtils.leftPad(""DDb\""N+yvh"", 4492, 'f');
    assertNotNull(string5);
}","/**
 * <p>Left pad a String with a specified character.</p>
 *
 * <p>Pad to a size of {@code size}.</p>
 *
 * <pre>
 * StringUtils.leftPad(null, *, *)     = null
 * StringUtils.leftPad("""", 3, 'z')     = ""zzz""
 * StringUtils.leftPad(""bat"", 3, 'z')  = ""bat""
 * StringUtils.leftPad(""bat"", 5, 'z')  = ""zzbat""
 * StringUtils.leftPad(""bat"", 1, 'z')  = ""bat""
 * StringUtils.leftPad(""bat"", -1, 'z') = ""bat""
 * </pre>
 *
 * @param str  the String to pad out, may be null
 * @param size  the size to pad to
 * @param padChar  the character to pad with
 * @return left padded String or original String if no padding is necessary,
 *  {@code null} if null String input
 * @since 2.0
 */"
"public static boolean isAllLowerCase(CharSequence cs) {
    if (cs == null || isEmpty(cs)) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isLowerCase(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test249541() throws Throwable {
    int int0 = 4492;
    String string0 = StringUtils.repeat("""", 4492);
    boolean boolean0 = StringUtils.containsNone((CharSequence) """", """");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens("""");
    boolean boolean1 = StringUtils.containsNone((CharSequence) """", ""n"");
    String string1 = ""\\u00"";
    String[] stringArray1 = StringUtils.stripAll(stringArray0, string1);
    String string2 = StringUtils.repeat('f', 4492);
    String string3 = StringUtils.trimToEmpty(string2);
    String string4 = ""DDb\""N+yvh"";
    String string5 = StringUtils.leftPad(""DDb\""N+yvh"", 4492, 'f');
    boolean boolean2 = StringUtils.isAllLowerCase("""");
    assertFalse(boolean2);
}","/**
 * <p>Checks if the CharSequence contains only lowercase characters.</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty CharSequence (length()=0) will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.isAllLowerCase(null)   = false
 * StringUtils.isAllLowerCase("""")     = false
 * StringUtils.isAllLowerCase(""  "")   = false
 * StringUtils.isAllLowerCase(""abc"")  = true
 * StringUtils.isAllLowerCase(""abC"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if only contains lowercase characters, and is non-null
 * @since 2.5
 * @since 3.0 Changed signature from isAllLowerCase(String) to isAllLowerCase(CharSequence)
 */"
"public static int lastOrdinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal) {
    return ordinalIndexOf(str, searchStr, ordinal, true);
}","public void test249544() throws Throwable {
    int int0 = 4492;
    String string0 = StringUtils.repeat("""", 4492);
    boolean boolean0 = StringUtils.containsNone((CharSequence) """", """");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens("""");
    boolean boolean1 = StringUtils.containsNone((CharSequence) """", ""n"");
    String string1 = ""\\u00"";
    String[] stringArray1 = StringUtils.stripAll(stringArray0, string1);
    String string2 = StringUtils.repeat('f', 4492);
    String string3 = StringUtils.trimToEmpty(string2);
    String string4 = ""DDb\""N+yvh"";
    String string5 = StringUtils.leftPad(""DDb\""N+yvh"", 4492, 'f');
    boolean boolean2 = StringUtils.isAllLowerCase("""");
    int int1 = StringUtils.lastOrdinalIndexOf(string3, """", 3568);
    assertEquals(4492, int1);
}","/**
 * <p>Finds the n-th last index within a String, handling {@code null}.
 * This method uses {@link String#lastIndexOf(String)}.</p>
 *
 * <p>A {@code null} String will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.lastOrdinalIndexOf(null, *, *)          = -1
 * StringUtils.lastOrdinalIndexOf(*, null, *)          = -1
 * StringUtils.lastOrdinalIndexOf("""", """", *)           = 0
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", ""a"", 1)  = 7
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", ""a"", 2)  = 6
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", ""b"", 1)  = 5
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", ""b"", 2)  = 2
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", ""ab"", 1) = 4
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", ""ab"", 2) = 1
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", """", 1)   = 8
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", """", 2)   = 8
 * </pre>
 *
 * <p>Note that 'tail(CharSequence str, int n)' may be implemented as: </p>
 *
 * <pre>
 *   str.substring(lastOrdinalIndexOf(str, ""\n"", n) + 1)
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @param ordinal  the n-th last {@code searchStr} to find
 * @return the n-th last index of the search CharSequence,
 *  {@code -1} ({@code INDEX_NOT_FOUND}) if no match or {@code null} string input
 * @since 2.5
 * @since 3.0 Changed signature from lastOrdinalIndexOf(String, String, int) to lastOrdinalIndexOf(CharSequence, CharSequence, int)
 */"
"// Defaults
//-----------------------------------------------------------------------
/**
 * <p>Returns either the passed in String,
 * or if the String is {@code null}, an empty String ("""").</p>
 *
 * <pre>
 * StringUtils.defaultString(null)  = """"
 * StringUtils.defaultString("""")    = """"
 * StringUtils.defaultString(""bat"") = ""bat""
 * </pre>
 *
 * @see ObjectUtils#toString(Object)
 * @see String#valueOf(Object)
 * @param str  the String to check, may be null
 * @return the passed in String, or the empty String if it
 *  was {@code null}
 */
public static String defaultString(String str) {
    return str == null ? EMPTY : str;
}","public void test249554() throws Throwable {
    int int0 = 4492;
    String string0 = StringUtils.repeat("""", 4492);
    boolean boolean0 = StringUtils.containsNone((CharSequence) """", """");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens("""");
    boolean boolean1 = StringUtils.containsNone((CharSequence) """", ""n"");
    String string1 = ""\\u00"";
    String[] stringArray1 = StringUtils.stripAll(stringArray0, string1);
    String string2 = StringUtils.repeat('f', 4492);
    String string3 = StringUtils.trimToEmpty(string2);
    String string4 = ""DDb\""N+yvh"";
    String string5 = StringUtils.leftPad(""DDb\""N+yvh"", 4492, 'f');
    boolean boolean2 = StringUtils.isAllLowerCase("""");
    int int1 = StringUtils.lastOrdinalIndexOf(string3, """", 3568);
    String string6 = StringUtils.defaultString(string2);
    assertNotNull(string6);
}",""
"public static int lastIndexOf(CharSequence seq, int searchChar, int startPos) {
    if (isEmpty(seq)) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.lastIndexOf(seq, searchChar, startPos);
}","public void test249563() throws Throwable {
    int int0 = 4492;
    String string0 = StringUtils.repeat("""", 4492);
    boolean boolean0 = StringUtils.containsNone((CharSequence) """", """");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens("""");
    boolean boolean1 = StringUtils.containsNone((CharSequence) """", ""n"");
    String string1 = ""\\u00"";
    String[] stringArray1 = StringUtils.stripAll(stringArray0, string1);
    String string2 = StringUtils.repeat('f', 4492);
    String string3 = StringUtils.trimToEmpty(string2);
    String string4 = ""DDb\""N+yvh"";
    String string5 = StringUtils.leftPad(""DDb\""N+yvh"", 4492, 'f');
    boolean boolean2 = StringUtils.isAllLowerCase("""");
    int int1 = StringUtils.lastOrdinalIndexOf(string3, """", 3568);
    String string6 = StringUtils.defaultString(string2);
    int int2 = StringUtils.lastIndexOf((CharSequence) """", (-736), 1934);
    assertEquals((-1), int2);
}","/**
 * <p>Finds the last index within a CharSequence from a start position,
 * handling {@code null}.
 * This method uses {@link String#lastIndexOf(int, int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("""") CharSequence will return {@code -1}.
 * A negative start position returns {@code -1}.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOf(null, *, *)          = -1
 * StringUtils.lastIndexOf("""", *,  *)           = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 8)  = 5
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 4)  = 2
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 0)  = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 9)  = 5
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', -1) = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'a', 0)  = 0
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @param startPos  the start position
 * @return the last index of the search character,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from lastIndexOf(String, int, int) to lastIndexOf(CharSequence, int, int)
 */"
"public static boolean isAlphanumericSpace(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {
            return false;
        }
    }
    return true;
}","public void test249566() throws Throwable {
    int int0 = 4492;
    String string0 = StringUtils.repeat("""", 4492);
    boolean boolean0 = StringUtils.containsNone((CharSequence) """", """");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens("""");
    boolean boolean1 = StringUtils.containsNone((CharSequence) """", ""n"");
    String string1 = ""\\u00"";
    String[] stringArray1 = StringUtils.stripAll(stringArray0, string1);
    String string2 = StringUtils.repeat('f', 4492);
    String string3 = StringUtils.trimToEmpty(string2);
    String string4 = ""DDb\""N+yvh"";
    String string5 = StringUtils.leftPad(""DDb\""N+yvh"", 4492, 'f');
    boolean boolean2 = StringUtils.isAllLowerCase("""");
    int int1 = StringUtils.lastOrdinalIndexOf(string3, """", 3568);
    String string6 = StringUtils.defaultString(string2);
    int int2 = StringUtils.lastIndexOf((CharSequence) """", (-736), 1934);
    boolean boolean3 = StringUtils.isAlphanumericSpace(string1);
    assertFalse(boolean3);
}","/**
 * <p>Checks if the CharSequence contains only unicode letters, digits
 * or space ({@code ' '}).</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty CharSequence (length()=0) will return {@code true}.</p>
 *
 * <pre>
 * StringUtils.isAlphanumericSpace(null)   = false
 * StringUtils.isAlphanumericSpace("""")     = true
 * StringUtils.isAlphanumericSpace(""  "")   = true
 * StringUtils.isAlphanumericSpace(""abc"")  = true
 * StringUtils.isAlphanumericSpace(""ab c"") = true
 * StringUtils.isAlphanumericSpace(""ab2c"") = true
 * StringUtils.isAlphanumericSpace(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if only contains letters, digits or space,
 *  and is non-null
 * @since 3.0 Changed signature from isAlphanumericSpace(String) to isAlphanumericSpace(CharSequence)
 */"
"public static boolean containsIgnoreCase(CharSequence str, CharSequence searchStr) {
    if (str == null || searchStr == null) {
        return false;
    }
    int len = searchStr.length();
    int max = str.length() - len;
    for (int i = 0; i <= max; i++) {
        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) {
            return true;
        }
    }
    return false;
}","public void test249599() throws Throwable {
    int int0 = 4492;
    String string0 = StringUtils.repeat("""", 4492);
    boolean boolean0 = StringUtils.containsNone((CharSequence) """", """");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens("""");
    boolean boolean1 = StringUtils.containsNone((CharSequence) """", ""n"");
    String string1 = ""\\u00"";
    String[] stringArray1 = StringUtils.stripAll(stringArray0, string1);
    String string2 = StringUtils.repeat('f', 4492);
    String string3 = StringUtils.trimToEmpty(string2);
    String string4 = ""DDb\""N+yvh"";
    String string5 = StringUtils.leftPad(""DDb\""N+yvh"", 4492, 'f');
    boolean boolean2 = StringUtils.isAllLowerCase("""");
    int int1 = StringUtils.lastOrdinalIndexOf(string3, """", 3568);
    String string6 = StringUtils.defaultString(string2);
    int int2 = StringUtils.lastIndexOf((CharSequence) """", (-736), 1934);
    boolean boolean3 = StringUtils.isAlphanumericSpace(string1);
    CharBuffer charBuffer0 = CharBuffer.allocate(1);
    boolean boolean4 = StringUtils.containsIgnoreCase("""", charBuffer0);
    assertFalse(boolean4);
}","/**
 * <p>Checks if CharSequence contains a search CharSequence irrespective of case,
 * handling {@code null}. Case-insensitivity is defined as by
 * {@link String#equalsIgnoreCase(String)}.
 *
 * <p>A {@code null} CharSequence will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.contains(null, *) = false
 * StringUtils.contains(*, null) = false
 * StringUtils.contains("""", """") = true
 * StringUtils.contains(""abc"", """") = true
 * StringUtils.contains(""abc"", ""a"") = true
 * StringUtils.contains(""abc"", ""z"") = false
 * StringUtils.contains(""abc"", ""A"") = true
 * StringUtils.contains(""abc"", ""Z"") = false
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @return true if the CharSequence contains the search CharSequence irrespective of
 * case or false if not or {@code null} string input
 * @since 3.0 Changed signature from containsIgnoreCase(String, String) to containsIgnoreCase(CharSequence, CharSequence)
 */"
"public static int indexOf(CharSequence seq, int searchChar, int startPos) {
    if (isEmpty(seq)) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.indexOf(seq, searchChar, startPos);
}","public void test249604() throws Throwable {
    int int0 = 4492;
    String string0 = StringUtils.repeat("""", 4492);
    boolean boolean0 = StringUtils.containsNone((CharSequence) """", """");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens("""");
    boolean boolean1 = StringUtils.containsNone((CharSequence) """", ""n"");
    String string1 = ""\\u00"";
    String[] stringArray1 = StringUtils.stripAll(stringArray0, string1);
    String string2 = StringUtils.repeat('f', 4492);
    String string3 = StringUtils.trimToEmpty(string2);
    String string4 = ""DDb\""N+yvh"";
    String string5 = StringUtils.leftPad(""DDb\""N+yvh"", 4492, 'f');
    boolean boolean2 = StringUtils.isAllLowerCase("""");
    int int1 = StringUtils.lastOrdinalIndexOf(string3, """", 3568);
    String string6 = StringUtils.defaultString(string2);
    int int2 = StringUtils.lastIndexOf((CharSequence) """", (-736), 1934);
    boolean boolean3 = StringUtils.isAlphanumericSpace(string1);
    CharBuffer charBuffer0 = CharBuffer.allocate(1);
    boolean boolean4 = StringUtils.containsIgnoreCase("""", charBuffer0);
    int int3 = StringUtils.indexOf((CharSequence) """", (-2023), 1683);
    assertEquals((-1), int3);
}","/**
 * <p>Finds the first index within a CharSequence from a start position,
 * handling {@code null}.
 * This method uses {@link String#indexOf(int, int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("""") CharSequence will return {@code (INDEX_NOT_FOUND) -1}.
 * A negative start position is treated as zero.
 * A start position greater than the string length returns {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOf(null, *, *)          = -1
 * StringUtils.indexOf("""", *, *)            = -1
 * StringUtils.indexOf(""aabaabaa"", 'b', 0)  = 2
 * StringUtils.indexOf(""aabaabaa"", 'b', 3)  = 5
 * StringUtils.indexOf(""aabaabaa"", 'b', 9)  = -1
 * StringUtils.indexOf(""aabaabaa"", 'b', -1) = 2
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @param startPos  the start position, negative treated as zero
 * @return the first index of the search character,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from indexOf(String, int, int) to indexOf(CharSequence, int, int)
 */"
"public StringUtils() {
    super();
}","public void test249608() throws Throwable {
    int int0 = 4492;
    String string0 = StringUtils.repeat("""", 4492);
    boolean boolean0 = StringUtils.containsNone((CharSequence) """", """");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens("""");
    boolean boolean1 = StringUtils.containsNone((CharSequence) """", ""n"");
    String string1 = ""\\u00"";
    String[] stringArray1 = StringUtils.stripAll(stringArray0, string1);
    String string2 = StringUtils.repeat('f', 4492);
    String string3 = StringUtils.trimToEmpty(string2);
    String string4 = ""DDb\""N+yvh"";
    String string5 = StringUtils.leftPad(""DDb\""N+yvh"", 4492, 'f');
    boolean boolean2 = StringUtils.isAllLowerCase("""");
    int int1 = StringUtils.lastOrdinalIndexOf(string3, """", 3568);
    String string6 = StringUtils.defaultString(string2);
    int int2 = StringUtils.lastIndexOf((CharSequence) """", (-736), 1934);
    boolean boolean3 = StringUtils.isAlphanumericSpace(string1);
    CharBuffer charBuffer0 = CharBuffer.allocate(1);
    boolean boolean4 = StringUtils.containsIgnoreCase("""", charBuffer0);
    int int3 = StringUtils.indexOf((CharSequence) """", (-2023), 1683);
    StringUtils stringUtils0 = new StringUtils();
    assertEquals((-1), StringUtils.INDEX_NOT_FOUND);
}","/**
 * <p>{@code StringUtils} instances should NOT be constructed in
 * standard programming. Instead, the class should be used as
 * {@code StringUtils.trim("" foo "");}.</p>
 *
 * <p>This constructor is public to permit tools that require a JavaBean
 * instance to operate.</p>
 */"
"public static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    return lastIndexOfIgnoreCase(str, searchStr, str.length());
}","public void test249610() throws Throwable {
    int int0 = 4492;
    String string0 = StringUtils.repeat("""", 4492);
    boolean boolean0 = StringUtils.containsNone((CharSequence) """", """");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens("""");
    boolean boolean1 = StringUtils.containsNone((CharSequence) """", ""n"");
    String string1 = ""\\u00"";
    String[] stringArray1 = StringUtils.stripAll(stringArray0, string1);
    String string2 = StringUtils.repeat('f', 4492);
    String string3 = StringUtils.trimToEmpty(string2);
    String string4 = ""DDb\""N+yvh"";
    String string5 = StringUtils.leftPad(""DDb\""N+yvh"", 4492, 'f');
    boolean boolean2 = StringUtils.isAllLowerCase("""");
    int int1 = StringUtils.lastOrdinalIndexOf(string3, """", 3568);
    String string6 = StringUtils.defaultString(string2);
    int int2 = StringUtils.lastIndexOf((CharSequence) """", (-736), 1934);
    boolean boolean3 = StringUtils.isAlphanumericSpace(string1);
    CharBuffer charBuffer0 = CharBuffer.allocate(1);
    boolean boolean4 = StringUtils.containsIgnoreCase("""", charBuffer0);
    int int3 = StringUtils.indexOf((CharSequence) """", (-2023), 1683);
    StringUtils stringUtils0 = new StringUtils();
    int int4 = StringUtils.lastIndexOfIgnoreCase((CharSequence) ""n"", (CharSequence) string5);
    assertEquals((-1), int4);
}","/**
 * <p>Case in-sensitive find of the last index within a CharSequence.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A negative start position returns {@code -1}.
 * An empty ("""") search CharSequence always matches unless the start position is negative.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOfIgnoreCase(null, *)          = -1
 * StringUtils.lastIndexOfIgnoreCase(*, null)          = -1
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""A"")  = 7
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"")  = 5
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""AB"") = 4
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @return the first index of the search CharSequence,
 *  -1 if no match or {@code null} string input
 * @since 2.5
 * @since 3.0 Changed signature from lastIndexOfIgnoreCase(String, String) to lastIndexOfIgnoreCase(CharSequence, CharSequence)
 */"
"public static <T extends CharSequence> T defaultIfBlank(T str, T defaultStr) {
    return StringUtils.isBlank(str) ? defaultStr : str;
}","public void test250621() throws Throwable {
    String string0 = StringUtils.defaultIfBlank(""+kVab&Ox<ZA:/<9n>N'"", ""+kVab&Ox<ZA:/<9n>N'"");
    assertNotNull(string0);
}","/**
 * <p>Returns either the passed in CharSequence, or if the CharSequence is
 * whitespace, empty ("""") or {@code null}, the value of {@code defaultStr}.</p>
 *
 * <pre>
 * StringUtils.defaultIfBlank(null, ""NULL"")  = ""NULL""
 * StringUtils.defaultIfBlank("""", ""NULL"")    = ""NULL""
 * StringUtils.defaultIfBlank("" "", ""NULL"")   = ""NULL""
 * StringUtils.defaultIfBlank(""bat"", ""NULL"") = ""bat""
 * StringUtils.defaultIfBlank("""", null)      = null
 * </pre>
 * @param <T> the specific kind of CharSequence
 * @param str the CharSequence to check, may be null
 * @param defaultStr  the default CharSequence to return
 *  if the input is whitespace, empty ("""") or {@code null}, may be null
 * @return the passed in CharSequence, or the default
 * @see StringUtils#defaultString(String, String)
 */"
"public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {
    return splitWorker(str, separatorChars, max, true);
}","public void test250623() throws Throwable {
    String string0 = StringUtils.defaultIfBlank(""+kVab&Ox<ZA:/<9n>N'"", ""+kVab&Ox<ZA:/<9n>N'"");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""+kVab&Ox<ZA:/<9n>N'"", """", (-7));
    assertEquals(1, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array with a maximum length,
 * separators specified, preserving all tokens, including empty tokens
 * created by adjacent separators.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as separators for empty tokens.
 * Adjacent separators are treated as one separator.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} separatorChars splits on whitespace.</p>
 *
 * <p>If more than {@code max} delimited substrings are found, the last
 * returned string includes all characters after the first {@code max - 1}
 * returned strings (including separator characters).</p>
 *
 * <pre>
 * StringUtils.splitPreserveAllTokens(null, *, *)            = null
 * StringUtils.splitPreserveAllTokens("""", *, *)              = []
 * StringUtils.splitPreserveAllTokens(""ab de fg"", null, 0)   = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 0) = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef"", "":"", 0)    = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef"", "":"", 2)    = [""ab"", ""cd:ef""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 2) = [""ab"", ""  de fg""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 3) = [""ab"", """", "" de fg""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 4) = [""ab"", """", """", ""de fg""]
 * </pre>
 *
 * @param str  the String to parse, may be {@code null}
 * @param separatorChars  the characters used as the delimiters,
 *  {@code null} splits on whitespace
 * @param max  the maximum number of elements to include in the
 *  array. A zero or negative value implies no limit
 * @return an array of parsed Strings, {@code null} if null String input
 * @since 2.1
 */"
"public static boolean containsOnly(CharSequence cs, String validChars) {
    if (cs == null || validChars == null) {
        return false;
    }
    return containsOnly(cs, validChars.toCharArray());
}","public void test250625() throws Throwable {
    String string0 = StringUtils.defaultIfBlank(""+kVab&Ox<ZA:/<9n>N'"", ""+kVab&Ox<ZA:/<9n>N'"");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""+kVab&Ox<ZA:/<9n>N'"", """", (-7));
    boolean boolean0 = StringUtils.containsOnly((CharSequence) """", """");
    assertTrue(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only certain characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.
 * A {@code null} valid character String will return {@code false}.
 * An empty String (length()=0) always returns {@code true}.</p>
 *
 * <pre>
 * StringUtils.containsOnly(null, *)       = false
 * StringUtils.containsOnly(*, null)       = false
 * StringUtils.containsOnly("""", *)         = true
 * StringUtils.containsOnly(""ab"", """")      = false
 * StringUtils.containsOnly(""abab"", ""abc"") = true
 * StringUtils.containsOnly(""ab1"", ""abc"")  = false
 * StringUtils.containsOnly(""abz"", ""abc"")  = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param validChars  a String of valid chars, may be null
 * @return true if it only contains valid chars and is non-null
 * @since 2.0
 * @since 3.0 Changed signature from containsOnly(String, String) to containsOnly(CharSequence, String)
 */"
"// See also Lucene's ASCIIFoldingFilter (Lucene 2.9) that replaces accented characters by their unaccented equivalent (and uncommited bug fix: https://issues.apache.org/jira/browse/LUCENE-1343?focusedCommentId=12858907&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12858907).
public static String stripAccents(String input) {
    if (input == null) {
        return null;
    }
    try {
        String result = null;
        if (java6Available) {
            result = removeAccentsJava6(input);
        } else if (sunAvailable) {
            result = removeAccentsSUN(input);
        } else {
            throw new UnsupportedOperationException(""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"");
        }
        // Note that none of the above methods correctly remove ligatures...
        return result;
    } catch (IllegalArgumentException iae) {
        throw new RuntimeException(""IllegalArgumentException occurred"", iae);
    } catch (IllegalAccessException iae) {
        throw new RuntimeException(""IllegalAccessException occurred"", iae);
    } catch (InvocationTargetException ite) {
        throw new RuntimeException(""InvocationTargetException occurred"", ite);
    } catch (SecurityException se) {
        throw new RuntimeException(""SecurityException occurred"", se);
    }
}","public void test250626() throws Throwable {
    String string0 = StringUtils.defaultIfBlank(""+kVab&Ox<ZA:/<9n>N'"", ""+kVab&Ox<ZA:/<9n>N'"");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""+kVab&Ox<ZA:/<9n>N'"", """", (-7));
    boolean boolean0 = StringUtils.containsOnly((CharSequence) """", """");
    String string1 = StringUtils.stripAccents("""");
    assertNotNull(string1);
}","/**
 * <p>Removes diacritics (~= accents) from a string. The case will not be altered.</p>
 * <p>For instance, '&agrave;' will be replaced by 'a'.</p>
 * <p>Note that ligatures will be left as is.</p>
 *
 * <p>This method will use the first available implementation of:
 * Java 6's {@link java.text.Normalizer}, Java 1.3&ndash;1.5's {@code sun.text.Normalizer}</p>
 *
 * <pre>
 * StringUtils.stripAccents(null)                = null
 * StringUtils.stripAccents("""")                  = """"
 * StringUtils.stripAccents(""control"")           = ""control""
 * StringUtils.stripAccents(""&ecute;clair"")      = ""eclair""
 * </pre>
 *
 * @param input String to be stripped
 * @return input text with diacritics removed
 *
 * @since 3.0
 */"
"public static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr, int startPos) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    if (startPos > (str.length() - searchStr.length())) {
        startPos = str.length() - searchStr.length();
    }
    if (startPos < 0) {
        return INDEX_NOT_FOUND;
    }
    if (searchStr.length() == 0) {
        return startPos;
    }
    for (int i = startPos; i >= 0; i--) {
        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test250629() throws Throwable {
    String string0 = StringUtils.defaultIfBlank(""+kVab&Ox<ZA:/<9n>N'"", ""+kVab&Ox<ZA:/<9n>N'"");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""+kVab&Ox<ZA:/<9n>N'"", """", (-7));
    boolean boolean0 = StringUtils.containsOnly((CharSequence) """", """");
    String string1 = StringUtils.stripAccents("""");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) """", (CharSequence) """", (-7));
    assertEquals((-1), int0);
}","/**
 * <p>Case in-sensitive find of the last index within a CharSequence
 * from the specified position.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A negative start position returns {@code -1}.
 * An empty ("""") search CharSequence always matches unless the start position is negative.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOfIgnoreCase(null, *, *)          = -1
 * StringUtils.lastIndexOfIgnoreCase(*, null, *)          = -1
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""A"", 8)  = 7
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"", 8)  = 5
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""AB"", 8) = 4
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"", 9)  = 5
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"", -1) = -1
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""A"", 0)  = 0
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"", 0)  = -1
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @param startPos  the start position
 * @return the first index of the search CharSequence,
 *  -1 if no match or {@code null} input
 * @since 2.5
 * @since 3.0 Changed signature from lastIndexOfIgnoreCase(String, String, int) to lastIndexOfIgnoreCase(CharSequence, CharSequence, int)
 */"
"public static String removeEndIgnoreCase(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (endsWithIgnoreCase(str, remove)) {
        return str.substring(0, str.length() - remove.length());
    }
    return str;
}","public void test250630() throws Throwable {
    String string0 = StringUtils.defaultIfBlank(""+kVab&Ox<ZA:/<9n>N'"", ""+kVab&Ox<ZA:/<9n>N'"");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""+kVab&Ox<ZA:/<9n>N'"", """", (-7));
    boolean boolean0 = StringUtils.containsOnly((CharSequence) """", """");
    String string1 = StringUtils.stripAccents("""");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) """", (CharSequence) """", (-7));
    String string2 = StringUtils.removeEndIgnoreCase("""", ""+kVab&Ox<ZA:/<9n>N'"");
    assertNotNull(string2);
}","/**
 * <p>Case insensitive removal of a substring if it is at the end of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("""") source string will return the empty string.
 * A {@code null} search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeEndIgnoreCase(null, *)      = null
 * StringUtils.removeEndIgnoreCase("""", *)        = """"
 * StringUtils.removeEndIgnoreCase(*, null)      = *
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", "".com."")  = ""www.domain.com""
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", "".com"")   = ""www.domain""
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeEndIgnoreCase(""abc"", """")    = ""abc""
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", "".COM"") = ""www.domain"")
 * StringUtils.removeEndIgnoreCase(""www.domain.COM"", "".com"") = ""www.domain"")
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for (case insensitive) and remove, may be null
 * @return the substring with the string removed if found,
 *  {@code null} if null String input
 * @since 2.4
 */"
"// LastIndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the last index within a CharSequence, handling {@code null}.
 * This method uses {@link String#lastIndexOf(int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("""") CharSequence will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.lastIndexOf(null, *)         = -1
 * StringUtils.lastIndexOf("""", *)           = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'a') = 7
 * StringUtils.lastIndexOf(""aabaabaa"", 'b') = 5
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @return the last index of the search character,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from lastIndexOf(String, int) to lastIndexOf(CharSequence, int)
 */
public static int lastIndexOf(CharSequence seq, int searchChar) {
    if (isEmpty(seq)) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.lastIndexOf(seq, searchChar, seq.length());
}","public void test250634() throws Throwable {
    String string0 = StringUtils.defaultIfBlank(""+kVab&Ox<ZA:/<9n>N'"", ""+kVab&Ox<ZA:/<9n>N'"");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""+kVab&Ox<ZA:/<9n>N'"", """", (-7));
    boolean boolean0 = StringUtils.containsOnly((CharSequence) """", """");
    String string1 = StringUtils.stripAccents("""");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) """", (CharSequence) """", (-7));
    String string2 = StringUtils.removeEndIgnoreCase("""", ""+kVab&Ox<ZA:/<9n>N'"");
    int int1 = StringUtils.lastIndexOf((CharSequence) ""+kVab&Ox<ZA:/<9n>N'"", (-7));
    assertEquals((-1), int1);
}",""
"public static String rightPad(String str, int size, String padStr) {
    if (str == null) {
        return null;
    }
    if (isEmpty(padStr)) {
        padStr = "" "";
    }
    int padLen = padStr.length();
    int strLen = str.length();
    int pads = size - strLen;
    if (pads <= 0) {
        // returns original String when possible
        return str;
    }
    if (padLen == 1 && pads <= PAD_LIMIT) {
        return rightPad(str, size, padStr.charAt(0));
    }
    if (pads == padLen) {
        return str.concat(padStr);
    } else if (pads < padLen) {
        return str.concat(padStr.substring(0, pads));
    } else {
        char[] padding = new char[pads];
        char[] padChars = padStr.toCharArray();
        for (int i = 0; i < pads; i++) {
            padding[i] = padChars[i % padLen];
        }
        return str.concat(new String(padding));
    }
}","public void test250636() throws Throwable {
    String string0 = StringUtils.defaultIfBlank(""+kVab&Ox<ZA:/<9n>N'"", ""+kVab&Ox<ZA:/<9n>N'"");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""+kVab&Ox<ZA:/<9n>N'"", """", (-7));
    boolean boolean0 = StringUtils.containsOnly((CharSequence) """", """");
    String string1 = StringUtils.stripAccents("""");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) """", (CharSequence) """", (-7));
    String string2 = StringUtils.removeEndIgnoreCase("""", ""+kVab&Ox<ZA:/<9n>N'"");
    int int1 = StringUtils.lastIndexOf((CharSequence) ""+kVab&Ox<ZA:/<9n>N'"", (-7));
    String string3 = StringUtils.rightPad(""+kVab&Ox<ZA:/<9n>N'"", 0, """");
    assertNotNull(string3);
}","/**
 * <p>Right pad a String with a specified String.</p>
 *
 * <p>The String is padded to the size of {@code size}.</p>
 *
 * <pre>
 * StringUtils.rightPad(null, *, *)      = null
 * StringUtils.rightPad("""", 3, ""z"")      = ""zzz""
 * StringUtils.rightPad(""bat"", 3, ""yz"")  = ""bat""
 * StringUtils.rightPad(""bat"", 5, ""yz"")  = ""batyz""
 * StringUtils.rightPad(""bat"", 8, ""yz"")  = ""batyzyzy""
 * StringUtils.rightPad(""bat"", 1, ""yz"")  = ""bat""
 * StringUtils.rightPad(""bat"", -1, ""yz"") = ""bat""
 * StringUtils.rightPad(""bat"", 5, null)  = ""bat  ""
 * StringUtils.rightPad(""bat"", 5, """")    = ""bat  ""
 * </pre>
 *
 * @param str  the String to pad out, may be null
 * @param size  the size to pad to
 * @param padStr  the String to pad with, null or empty treated as single space
 * @return right padded String or original String if no padding is necessary,
 *  {@code null} if null String input
 */"
"public static String trimToEmpty(String str) {
    return str == null ? EMPTY : str.trim();
}","public void test251641() throws Throwable {
    String string0 = StringUtils.trimToEmpty(""r[zmHb.(TH"");
    assertNotNull(string0);
}","/**
 * <p>Removes control characters (char &lt;= 32) from both
 * ends of this String returning an empty String ("""") if the String
 * is empty ("""") after the trim or if it is {@code null}.
 *
 * <p>The String is trimmed using {@link String#trim()}.
 * Trim removes start and end characters &lt;= 32.
 * To strip whitespace use {@link #stripToEmpty(String)}.</p>
 *
 * <pre>
 * StringUtils.trimToEmpty(null)          = """"
 * StringUtils.trimToEmpty("""")            = """"
 * StringUtils.trimToEmpty(""     "")       = """"
 * StringUtils.trimToEmpty(""abc"")         = ""abc""
 * StringUtils.trimToEmpty(""    abc    "") = ""abc""
 * </pre>
 *
 * @param str  the String to be trimmed, may be null
 * @return the trimmed String, or an empty String if {@code null} input
 * @since 2.0
 */"
"public static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    return lastIndexOfIgnoreCase(str, searchStr, str.length());
}","public void test251643() throws Throwable {
    String string0 = StringUtils.trimToEmpty(""r[zmHb.(TH"");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) ""r[zmHb.(TH"", (CharSequence) ""r[zmHb.(TH"");
    assertEquals(0, int0);
}","/**
 * <p>Case in-sensitive find of the last index within a CharSequence.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A negative start position returns {@code -1}.
 * An empty ("""") search CharSequence always matches unless the start position is negative.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOfIgnoreCase(null, *)          = -1
 * StringUtils.lastIndexOfIgnoreCase(*, null)          = -1
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""A"")  = 7
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"")  = 5
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""AB"") = 4
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @return the first index of the search CharSequence,
 *  -1 if no match or {@code null} string input
 * @since 2.5
 * @since 3.0 Changed signature from lastIndexOfIgnoreCase(String, String) to lastIndexOfIgnoreCase(CharSequence, CharSequence)
 */"
"// endsWith
//-----------------------------------------------------------------------
/**
 * <p>Check if a CharSequence ends with a specified suffix.</p>
 *
 * <p>{@code null}s are handled without exceptions. Two {@code null}
 * references are considered to be equal. The comparison is case sensitive.</p>
 *
 * <pre>
 * StringUtils.endsWith(null, null)      = true
 * StringUtils.endsWith(null, ""def"")     = false
 * StringUtils.endsWith(""abcdef"", null)  = false
 * StringUtils.endsWith(""abcdef"", ""def"") = true
 * StringUtils.endsWith(""ABCDEF"", ""def"") = false
 * StringUtils.endsWith(""ABCDEF"", ""cde"") = false
 * </pre>
 *
 * @see java.lang.String#endsWith(String)
 * @param str  the CharSequence to check, may be null
 * @param suffix the suffix to find, may be null
 * @return {@code true} if the CharSequence ends with the suffix, case sensitive, or
 *  both {@code null}
 * @since 2.4
 * @since 3.0 Changed signature from endsWith(String, String) to endsWith(CharSequence, CharSequence)
 */
public static boolean endsWith(CharSequence str, CharSequence suffix) {
    return endsWith(str, suffix, false);
}","public void test251644() throws Throwable {
    String string0 = StringUtils.trimToEmpty(""r[zmHb.(TH"");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) ""r[zmHb.(TH"", (CharSequence) ""r[zmHb.(TH"");
    boolean boolean0 = StringUtils.endsWith(""r[zmHb.(TH"", ""r[zmHb.(TH"");
    assertTrue(boolean0);
}",""
"public static String uncapitalize(String str) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    return new StringBuilder(strLen).append(Character.toLowerCase(str.charAt(0))).append(str.substring(1)).toString();
}","public void test251645() throws Throwable {
    String string0 = StringUtils.trimToEmpty(""r[zmHb.(TH"");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) ""r[zmHb.(TH"", (CharSequence) ""r[zmHb.(TH"");
    boolean boolean0 = StringUtils.endsWith(""r[zmHb.(TH"", ""r[zmHb.(TH"");
    String string1 = StringUtils.uncapitalize(""r[zmHb.(TH"");
    assertNotNull(string1);
}","/**
 * <p>Uncapitalizes a String changing the first letter to title case as
 * per {@link Character#toLowerCase(char)}. No other letters are changed.</p>
 *
 * <p>For a word based algorithm, see {@link org.apache.commons.lang3.text.WordUtils#uncapitalize(String)}.
 * A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.uncapitalize(null)  = null
 * StringUtils.uncapitalize("""")    = """"
 * StringUtils.uncapitalize(""Cat"") = ""cat""
 * StringUtils.uncapitalize(""CAT"") = ""cAT""
 * </pre>
 *
 * @param str the String to uncapitalize, may be null
 * @return the uncapitalized String, {@code null} if null String input
 * @see org.apache.commons.lang3.text.WordUtils#uncapitalize(String)
 * @see #capitalize(String)
 * @since 2.0
 */"
"public static boolean containsOnly(CharSequence cs, String validChars) {
    if (cs == null || validChars == null) {
        return false;
    }
    return containsOnly(cs, validChars.toCharArray());
}","public void test251648() throws Throwable {
    String string0 = StringUtils.trimToEmpty(""r[zmHb.(TH"");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) ""r[zmHb.(TH"", (CharSequence) ""r[zmHb.(TH"");
    boolean boolean0 = StringUtils.endsWith(""r[zmHb.(TH"", ""r[zmHb.(TH"");
    String string1 = StringUtils.uncapitalize(""r[zmHb.(TH"");
    boolean boolean1 = StringUtils.containsOnly((CharSequence) ""r[zmHb.(TH"", ""r[zmHb.(TH"");
    assertTrue(boolean1);
}","/**
 * <p>Checks if the CharSequence contains only certain characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.
 * A {@code null} valid character String will return {@code false}.
 * An empty String (length()=0) always returns {@code true}.</p>
 *
 * <pre>
 * StringUtils.containsOnly(null, *)       = false
 * StringUtils.containsOnly(*, null)       = false
 * StringUtils.containsOnly("""", *)         = true
 * StringUtils.containsOnly(""ab"", """")      = false
 * StringUtils.containsOnly(""abab"", ""abc"") = true
 * StringUtils.containsOnly(""ab1"", ""abc"")  = false
 * StringUtils.containsOnly(""abz"", ""abc"")  = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param validChars  a String of valid chars, may be null
 * @return true if it only contains valid chars and is non-null
 * @since 2.0
 * @since 3.0 Changed signature from containsOnly(String, String) to containsOnly(CharSequence, String)
 */"
"public static String replace(String text, String searchString, String replacement) {
    return replace(text, searchString, replacement, -1);
}","public void test251650() throws Throwable {
    String string0 = StringUtils.trimToEmpty(""r[zmHb.(TH"");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) ""r[zmHb.(TH"", (CharSequence) ""r[zmHb.(TH"");
    boolean boolean0 = StringUtils.endsWith(""r[zmHb.(TH"", ""r[zmHb.(TH"");
    String string1 = StringUtils.uncapitalize(""r[zmHb.(TH"");
    boolean boolean1 = StringUtils.containsOnly((CharSequence) ""r[zmHb.(TH"", ""r[zmHb.(TH"");
    String string2 = StringUtils.replace("""", ""r[zmHb.(TH"", ""r[zmHb.(TH"");
    assertNotNull(string2);
}","/**
 * <p>Replaces all occurrences of a String within another String.</p>
 *
 * <p>A {@code null} reference passed to this method is a no-op.</p>
 *
 * <pre>
 * StringUtils.replace(null, *, *)        = null
 * StringUtils.replace("""", *, *)          = """"
 * StringUtils.replace(""any"", null, *)    = ""any""
 * StringUtils.replace(""any"", *, null)    = ""any""
 * StringUtils.replace(""any"", """", *)      = ""any""
 * StringUtils.replace(""aba"", ""a"", null)  = ""aba""
 * StringUtils.replace(""aba"", ""a"", """")    = ""b""
 * StringUtils.replace(""aba"", ""a"", ""z"")   = ""zbz""
 * </pre>
 *
 * @see #replace(String text, String searchString, String replacement, int max)
 * @param text  text to search and replace in, may be null
 * @param searchString  the String to search for, may be null
 * @param replacement  the String to replace it with, may be null
 * @return the text with any replacements processed,
 *  {@code null} if null String input
 */"
"public static boolean isAllUpperCase(CharSequence cs) {
    if (cs == null || isEmpty(cs)) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isUpperCase(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test251654() throws Throwable {
    String string0 = StringUtils.trimToEmpty(""r[zmHb.(TH"");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) ""r[zmHb.(TH"", (CharSequence) ""r[zmHb.(TH"");
    boolean boolean0 = StringUtils.endsWith(""r[zmHb.(TH"", ""r[zmHb.(TH"");
    String string1 = StringUtils.uncapitalize(""r[zmHb.(TH"");
    boolean boolean1 = StringUtils.containsOnly((CharSequence) ""r[zmHb.(TH"", ""r[zmHb.(TH"");
    String string2 = StringUtils.replace("""", ""r[zmHb.(TH"", ""r[zmHb.(TH"");
    boolean boolean2 = StringUtils.isAllUpperCase("""");
    assertFalse(boolean2);
}","/**
 * <p>Checks if the CharSequence contains only uppercase characters.</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty String (length()=0) will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.isAllUpperCase(null)   = false
 * StringUtils.isAllUpperCase("""")     = false
 * StringUtils.isAllUpperCase(""  "")   = false
 * StringUtils.isAllUpperCase(""ABC"")  = true
 * StringUtils.isAllUpperCase(""aBC"") = false
 * </pre>
 *
 * @param cs the CharSequence to check, may be null
 * @return {@code true} if only contains uppercase characters, and is non-null
 * @since 2.5
 * @since 3.0 Changed signature from isAllUpperCase(String) to isAllUpperCase(CharSequence)
 */"
"public static boolean isNumericSpace(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {
            return false;
        }
    }
    return true;
}","public void test251657() throws Throwable {
    String string0 = StringUtils.trimToEmpty(""r[zmHb.(TH"");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) ""r[zmHb.(TH"", (CharSequence) ""r[zmHb.(TH"");
    boolean boolean0 = StringUtils.endsWith(""r[zmHb.(TH"", ""r[zmHb.(TH"");
    String string1 = StringUtils.uncapitalize(""r[zmHb.(TH"");
    boolean boolean1 = StringUtils.containsOnly((CharSequence) ""r[zmHb.(TH"", ""r[zmHb.(TH"");
    String string2 = StringUtils.replace("""", ""r[zmHb.(TH"", ""r[zmHb.(TH"");
    boolean boolean2 = StringUtils.isAllUpperCase("""");
    boolean boolean3 = StringUtils.isNumericSpace("""");
    assertTrue(boolean3);
}","/**
 * <p>Checks if the CharSequence contains only unicode digits or space
 * ({@code ' '}).
 * A decimal point is not a unicode digit and returns false.</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty CharSequence (length()=0) will return {@code true}.</p>
 *
 * <pre>
 * StringUtils.isNumericSpace(null)   = false
 * StringUtils.isNumericSpace("""")     = true
 * StringUtils.isNumericSpace(""  "")   = true
 * StringUtils.isNumericSpace(""123"")  = true
 * StringUtils.isNumericSpace(""12 3"") = true
 * StringUtils.isNumericSpace(""ab2c"") = false
 * StringUtils.isNumericSpace(""12-3"") = false
 * StringUtils.isNumericSpace(""12.3"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if only contains digits or space,
 *  and is non-null
 * @since 3.0 Changed signature from isNumericSpace(String) to isNumericSpace(CharSequence)
 */"
"// Left/Right/Mid
//-----------------------------------------------------------------------
/**
 * <p>Gets the leftmost {@code len} characters of a String.</p>
 *
 * <p>If {@code len} characters are not available, or the
 * String is {@code null}, the String will be returned without
 * an exception. An empty String is returned if len is negative.</p>
 *
 * <pre>
 * StringUtils.left(null, *)    = null
 * StringUtils.left(*, -ve)     = """"
 * StringUtils.left("""", *)      = """"
 * StringUtils.left(""abc"", 0)   = """"
 * StringUtils.left(""abc"", 2)   = ""ab""
 * StringUtils.left(""abc"", 4)   = ""abc""
 * </pre>
 *
 * @param str  the String to get the leftmost characters from, may be null
 * @param len  the length of the required String
 * @return the leftmost characters, {@code null} if null String input
 */
public static String left(String str, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0) {
        return EMPTY;
    }
    if (str.length() <= len) {
        return str;
    }
    return str.substring(0, len);
}","public void test251661() throws Throwable {
    String string0 = StringUtils.trimToEmpty(""r[zmHb.(TH"");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) ""r[zmHb.(TH"", (CharSequence) ""r[zmHb.(TH"");
    boolean boolean0 = StringUtils.endsWith(""r[zmHb.(TH"", ""r[zmHb.(TH"");
    String string1 = StringUtils.uncapitalize(""r[zmHb.(TH"");
    boolean boolean1 = StringUtils.containsOnly((CharSequence) ""r[zmHb.(TH"", ""r[zmHb.(TH"");
    String string2 = StringUtils.replace("""", ""r[zmHb.(TH"", ""r[zmHb.(TH"");
    boolean boolean2 = StringUtils.isAllUpperCase("""");
    boolean boolean3 = StringUtils.isNumericSpace("""");
    String string3 = StringUtils.left("":A!+.>c8Cst/sz?I]2"", 0);
    assertNotNull(string3);
}",""
"public static String trimToEmpty(String str) {
    return str == null ? EMPTY : str.trim();
}","public void test251666() throws Throwable {
    String string0 = StringUtils.trimToEmpty(""r[zmHb.(TH"");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) ""r[zmHb.(TH"", (CharSequence) ""r[zmHb.(TH"");
    boolean boolean0 = StringUtils.endsWith(""r[zmHb.(TH"", ""r[zmHb.(TH"");
    String string1 = StringUtils.uncapitalize(""r[zmHb.(TH"");
    boolean boolean1 = StringUtils.containsOnly((CharSequence) ""r[zmHb.(TH"", ""r[zmHb.(TH"");
    String string2 = StringUtils.replace("""", ""r[zmHb.(TH"", ""r[zmHb.(TH"");
    boolean boolean2 = StringUtils.isAllUpperCase("""");
    boolean boolean3 = StringUtils.isNumericSpace("""");
    String string3 = StringUtils.left("":A!+.>c8Cst/sz?I]2"", 0);
    String string4 = StringUtils.trimToEmpty(""L]V"");
    assertNotNull(string4);
}","/**
 * <p>Removes control characters (char &lt;= 32) from both
 * ends of this String returning an empty String ("""") if the String
 * is empty ("""") after the trim or if it is {@code null}.
 *
 * <p>The String is trimmed using {@link String#trim()}.
 * Trim removes start and end characters &lt;= 32.
 * To strip whitespace use {@link #stripToEmpty(String)}.</p>
 *
 * <pre>
 * StringUtils.trimToEmpty(null)          = """"
 * StringUtils.trimToEmpty("""")            = """"
 * StringUtils.trimToEmpty(""     "")       = """"
 * StringUtils.trimToEmpty(""abc"")         = ""abc""
 * StringUtils.trimToEmpty(""    abc    "") = ""abc""
 * </pre>
 *
 * @param str  the String to be trimmed, may be null
 * @return the trimmed String, or an empty String if {@code null} input
 * @since 2.0
 */"
"public static boolean containsOnly(CharSequence cs, String validChars) {
    if (cs == null || validChars == null) {
        return false;
    }
    return containsOnly(cs, validChars.toCharArray());
}","public void test251672() throws Throwable {
    String string0 = StringUtils.trimToEmpty(""r[zmHb.(TH"");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) ""r[zmHb.(TH"", (CharSequence) ""r[zmHb.(TH"");
    boolean boolean0 = StringUtils.endsWith(""r[zmHb.(TH"", ""r[zmHb.(TH"");
    String string1 = StringUtils.uncapitalize(""r[zmHb.(TH"");
    boolean boolean1 = StringUtils.containsOnly((CharSequence) ""r[zmHb.(TH"", ""r[zmHb.(TH"");
    String string2 = StringUtils.replace("""", ""r[zmHb.(TH"", ""r[zmHb.(TH"");
    boolean boolean2 = StringUtils.isAllUpperCase("""");
    boolean boolean3 = StringUtils.isNumericSpace("""");
    String string3 = StringUtils.left("":A!+.>c8Cst/sz?I]2"", 0);
    String string4 = StringUtils.trimToEmpty(""L]V"");
    boolean boolean4 = StringUtils.containsOnly((CharSequence) ""L]V"", ""L]V"");
    assertTrue(boolean4);
}","/**
 * <p>Checks if the CharSequence contains only certain characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.
 * A {@code null} valid character String will return {@code false}.
 * An empty String (length()=0) always returns {@code true}.</p>
 *
 * <pre>
 * StringUtils.containsOnly(null, *)       = false
 * StringUtils.containsOnly(*, null)       = false
 * StringUtils.containsOnly("""", *)         = true
 * StringUtils.containsOnly(""ab"", """")      = false
 * StringUtils.containsOnly(""abab"", ""abc"") = true
 * StringUtils.containsOnly(""ab1"", ""abc"")  = false
 * StringUtils.containsOnly(""abz"", ""abc"")  = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param validChars  a String of valid chars, may be null
 * @return true if it only contains valid chars and is non-null
 * @since 2.0
 * @since 3.0 Changed signature from containsOnly(String, String) to containsOnly(CharSequence, String)
 */"
"public static boolean isNotEmpty(CharSequence cs) {
    return !StringUtils.isEmpty(cs);
}","public void test251677() throws Throwable {
    String string0 = StringUtils.trimToEmpty(""r[zmHb.(TH"");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) ""r[zmHb.(TH"", (CharSequence) ""r[zmHb.(TH"");
    boolean boolean0 = StringUtils.endsWith(""r[zmHb.(TH"", ""r[zmHb.(TH"");
    String string1 = StringUtils.uncapitalize(""r[zmHb.(TH"");
    boolean boolean1 = StringUtils.containsOnly((CharSequence) ""r[zmHb.(TH"", ""r[zmHb.(TH"");
    String string2 = StringUtils.replace("""", ""r[zmHb.(TH"", ""r[zmHb.(TH"");
    boolean boolean2 = StringUtils.isAllUpperCase("""");
    boolean boolean3 = StringUtils.isNumericSpace("""");
    String string3 = StringUtils.left("":A!+.>c8Cst/sz?I]2"", 0);
    String string4 = StringUtils.trimToEmpty(""L]V"");
    boolean boolean4 = StringUtils.containsOnly((CharSequence) ""L]V"", ""L]V"");
    boolean boolean5 = StringUtils.isNotEmpty("""");
    assertFalse(boolean5);
}","/**
 * <p>Checks if a CharSequence is not empty ("""") and not null.</p>
 *
 * <pre>
 * StringUtils.isNotEmpty(null)      = false
 * StringUtils.isNotEmpty("""")        = false
 * StringUtils.isNotEmpty("" "")       = true
 * StringUtils.isNotEmpty(""bob"")     = true
 * StringUtils.isNotEmpty(""  bob  "") = true
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if the CharSequence is not empty and not null
 * @since 3.0 Changed signature from isNotEmpty(String) to isNotEmpty(CharSequence)
 */"
"// Chopping
//-----------------------------------------------------------------------
/**
 * <p>Remove the last character from a String.</p>
 *
 * <p>If the String ends in {@code \r\n}, then remove both
 * of them.</p>
 *
 * <pre>
 * StringUtils.chop(null)          = null
 * StringUtils.chop("""")            = """"
 * StringUtils.chop(""abc \r"")      = ""abc ""
 * StringUtils.chop(""abc\n"")       = ""abc""
 * StringUtils.chop(""abc\r\n"")     = ""abc""
 * StringUtils.chop(""abc"")         = ""ab""
 * StringUtils.chop(""abc\nabc"")    = ""abc\nab""
 * StringUtils.chop(""a"")           = """"
 * StringUtils.chop(""\r"")          = """"
 * StringUtils.chop(""\n"")          = """"
 * StringUtils.chop(""\r\n"")        = """"
 * </pre>
 *
 * @param str  the String to chop last character from, may be null
 * @return String without last character, {@code null} if null String input
 */
public static String chop(String str) {
    if (str == null) {
        return null;
    }
    int strLen = str.length();
    if (strLen < 2) {
        return EMPTY;
    }
    int lastIdx = strLen - 1;
    String ret = str.substring(0, lastIdx);
    char last = str.charAt(lastIdx);
    if (last == CharUtils.LF) {
        if (ret.charAt(lastIdx - 1) == CharUtils.CR) {
            return ret.substring(0, lastIdx - 1);
        }
    }
    return ret;
}","public void test251683() throws Throwable {
    String string0 = StringUtils.trimToEmpty(""r[zmHb.(TH"");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) ""r[zmHb.(TH"", (CharSequence) ""r[zmHb.(TH"");
    boolean boolean0 = StringUtils.endsWith(""r[zmHb.(TH"", ""r[zmHb.(TH"");
    String string1 = StringUtils.uncapitalize(""r[zmHb.(TH"");
    boolean boolean1 = StringUtils.containsOnly((CharSequence) ""r[zmHb.(TH"", ""r[zmHb.(TH"");
    String string2 = StringUtils.replace("""", ""r[zmHb.(TH"", ""r[zmHb.(TH"");
    boolean boolean2 = StringUtils.isAllUpperCase("""");
    boolean boolean3 = StringUtils.isNumericSpace("""");
    String string3 = StringUtils.left("":A!+.>c8Cst/sz?I]2"", 0);
    String string4 = StringUtils.trimToEmpty(""L]V"");
    boolean boolean4 = StringUtils.containsOnly((CharSequence) ""L]V"", ""L]V"");
    boolean boolean5 = StringUtils.isNotEmpty("""");
    String string5 = StringUtils.chop(""java.text.Normalizer$Form"");
    assertNotNull(string5);
}",""
"public static String mid(String str, int pos, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0 || pos > str.length()) {
        return EMPTY;
    }
    if (pos < 0) {
        pos = 0;
    }
    if (str.length() <= (pos + len)) {
        return str.substring(pos);
    }
    return str.substring(pos, pos + len);
}","public void test251690() throws Throwable {
    String string0 = StringUtils.trimToEmpty(""r[zmHb.(TH"");
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) ""r[zmHb.(TH"", (CharSequence) ""r[zmHb.(TH"");
    boolean boolean0 = StringUtils.endsWith(""r[zmHb.(TH"", ""r[zmHb.(TH"");
    String string1 = StringUtils.uncapitalize(""r[zmHb.(TH"");
    boolean boolean1 = StringUtils.containsOnly((CharSequence) ""r[zmHb.(TH"", ""r[zmHb.(TH"");
    String string2 = StringUtils.replace("""", ""r[zmHb.(TH"", ""r[zmHb.(TH"");
    boolean boolean2 = StringUtils.isAllUpperCase("""");
    boolean boolean3 = StringUtils.isNumericSpace("""");
    String string3 = StringUtils.left("":A!+.>c8Cst/sz?I]2"", 0);
    String string4 = StringUtils.trimToEmpty(""L]V"");
    boolean boolean4 = StringUtils.containsOnly((CharSequence) ""L]V"", ""L]V"");
    boolean boolean5 = StringUtils.isNotEmpty("""");
    String string5 = StringUtils.chop(""java.text.Normalizer$Form"");
    String string6 = StringUtils.mid(""L]V"", 90, 3343);
    assertNotNull(string6);
}","/**
 * <p>Gets {@code len} characters from the middle of a String.</p>
 *
 * <p>If {@code len} characters are not available, the remainder
 * of the String will be returned without an exception. If the
 * String is {@code null}, {@code null} will be returned.
 * An empty String is returned if len is negative or exceeds the
 * length of {@code str}.</p>
 *
 * <pre>
 * StringUtils.mid(null, *, *)    = null
 * StringUtils.mid(*, *, -ve)     = """"
 * StringUtils.mid("""", 0, *)      = """"
 * StringUtils.mid(""abc"", 0, 2)   = ""ab""
 * StringUtils.mid(""abc"", 0, 4)   = ""abc""
 * StringUtils.mid(""abc"", 2, 4)   = ""c""
 * StringUtils.mid(""abc"", 4, 2)   = """"
 * StringUtils.mid(""abc"", -2, 2)  = ""ab""
 * </pre>
 *
 * @param str  the String to get the characters from, may be null
 * @param pos  the position to start from, negative treated as zero
 * @param len  the length of the required String
 * @return the middle characters, {@code null} if null String input
 */"
"public static int lastIndexOf(CharSequence seq, int searchChar, int startPos) {
    if (isEmpty(seq)) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.lastIndexOf(seq, searchChar, startPos);
}","public void test252698() throws Throwable {
    int int0 = StringUtils.lastIndexOf((CharSequence) null, 0, 0);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index within a CharSequence from a start position,
 * handling {@code null}.
 * This method uses {@link String#lastIndexOf(int, int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("""") CharSequence will return {@code -1}.
 * A negative start position returns {@code -1}.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOf(null, *, *)          = -1
 * StringUtils.lastIndexOf("""", *,  *)           = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 8)  = 5
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 4)  = 2
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 0)  = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 9)  = 5
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', -1) = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'a', 0)  = 0
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @param startPos  the start position
 * @return the last index of the search character,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from lastIndexOf(String, int, int) to lastIndexOf(CharSequence, int, int)
 */"
"// Centering
//-----------------------------------------------------------------------
/**
 * <p>Centers a String in a larger String of size {@code size}
 * using the space character (' ').<p>
 *
 * <p>If the size is less than the String length, the String is returned.
 * A {@code null} String returns {@code null}.
 * A negative size is treated as zero.</p>
 *
 * <p>Equivalent to {@code center(str, size, "" "")}.</p>
 *
 * <pre>
 * StringUtils.center(null, *)   = null
 * StringUtils.center("""", 4)     = ""    ""
 * StringUtils.center(""ab"", -1)  = ""ab""
 * StringUtils.center(""ab"", 4)   = "" ab ""
 * StringUtils.center(""abcd"", 2) = ""abcd""
 * StringUtils.center(""a"", 4)    = "" a  ""
 * </pre>
 *
 * @param str  the String to center, may be null
 * @param size  the int size of new String, negative treated as zero
 * @return centered String, {@code null} if null String input
 */
public static String center(String str, int size) {
    return center(str, size, ' ');
}","public void test252699() throws Throwable {
    int int0 = StringUtils.lastIndexOf((CharSequence) null, 0, 0);
    String string0 = StringUtils.center("""", 7);
    assertNotNull(string0);
}",""
"// Chopping
//-----------------------------------------------------------------------
/**
 * <p>Remove the last character from a String.</p>
 *
 * <p>If the String ends in {@code \r\n}, then remove both
 * of them.</p>
 *
 * <pre>
 * StringUtils.chop(null)          = null
 * StringUtils.chop("""")            = """"
 * StringUtils.chop(""abc \r"")      = ""abc ""
 * StringUtils.chop(""abc\n"")       = ""abc""
 * StringUtils.chop(""abc\r\n"")     = ""abc""
 * StringUtils.chop(""abc"")         = ""ab""
 * StringUtils.chop(""abc\nabc"")    = ""abc\nab""
 * StringUtils.chop(""a"")           = """"
 * StringUtils.chop(""\r"")          = """"
 * StringUtils.chop(""\n"")          = """"
 * StringUtils.chop(""\r\n"")        = """"
 * </pre>
 *
 * @param str  the String to chop last character from, may be null
 * @return String without last character, {@code null} if null String input
 */
public static String chop(String str) {
    if (str == null) {
        return null;
    }
    int strLen = str.length();
    if (strLen < 2) {
        return EMPTY;
    }
    int lastIdx = strLen - 1;
    String ret = str.substring(0, lastIdx);
    char last = str.charAt(lastIdx);
    if (last == CharUtils.LF) {
        if (ret.charAt(lastIdx - 1) == CharUtils.CR) {
            return ret.substring(0, lastIdx - 1);
        }
    }
    return ret;
}","public void test252701() throws Throwable {
    int int0 = StringUtils.lastIndexOf((CharSequence) null, 0, 0);
    String string0 = StringUtils.center("""", 7);
    String string1 = StringUtils.chop("""");
    assertNotNull(string1);
}",""
"public static String strip(String str, String stripChars) {
    if (isEmpty(str)) {
        return str;
    }
    str = stripStart(str, stripChars);
    return stripEnd(str, stripChars);
}","public void test252704() throws Throwable {
    int int0 = StringUtils.lastIndexOf((CharSequence) null, 0, 0);
    String string0 = StringUtils.center("""", 7);
    String string1 = StringUtils.chop("""");
    String string2 = StringUtils.strip(""0V5Tf=)&&x_=}6-0"", ""H'yQxJJ\""Z?2<O^"");
    assertNotNull(string2);
}","/**
 * <p>Strips any of a set of characters from the start and end of a String.
 * This is similar to {@link String#trim()} but allows the characters
 * to be stripped to be controlled.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * An empty string ("""") input returns the empty string.</p>
 *
 * <p>If the stripChars String is {@code null}, whitespace is
 * stripped as defined by {@link Character#isWhitespace(char)}.
 * Alternatively use {@link #strip(String)}.</p>
 *
 * <pre>
 * StringUtils.strip(null, *)          = null
 * StringUtils.strip("""", *)            = """"
 * StringUtils.strip(""abc"", null)      = ""abc""
 * StringUtils.strip(""  abc"", null)    = ""abc""
 * StringUtils.strip(""abc  "", null)    = ""abc""
 * StringUtils.strip("" abc "", null)    = ""abc""
 * StringUtils.strip(""  abcyx"", ""xyz"") = ""  abc""
 * </pre>
 *
 * @param str  the String to remove characters from, may be null
 * @param stripChars  the characters to remove, null treated as whitespace
 * @return the stripped String, {@code null} if null String input
 */"
"// Nested extraction
//-----------------------------------------------------------------------
// Splitting
//-----------------------------------------------------------------------
/**
 * <p>Splits the provided text into an array, using whitespace as the
 * separator.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as one separator.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.split(null)       = null
 * StringUtils.split("""")         = []
 * StringUtils.split(""abc def"")  = [""abc"", ""def""]
 * StringUtils.split(""abc  def"") = [""abc"", ""def""]
 * StringUtils.split("" abc "")    = [""abc""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @return an array of parsed Strings, {@code null} if null String input
 */
public static String[] split(String str) {
    return split(str, null, -1);
}","public void test252708() throws Throwable {
    int int0 = StringUtils.lastIndexOf((CharSequence) null, 0, 0);
    String string0 = StringUtils.center("""", 7);
    String string1 = StringUtils.chop("""");
    String string2 = StringUtils.strip(""0V5Tf=)&&x_=}6-0"", ""H'yQxJJ\""Z?2<O^"");
    String[] stringArray0 = StringUtils.split(""oW<8<~$opisp6)`"");
    assertEquals(1, stringArray0.length);
}",""
"public static String lowerCase(String str, Locale locale) {
    if (str == null) {
        return null;
    }
    return str.toLowerCase(locale);
}","public void test252755() throws Throwable {
    int int0 = StringUtils.lastIndexOf((CharSequence) null, 0, 0);
    String string0 = StringUtils.center("""", 7);
    String string1 = StringUtils.chop("""");
    String string2 = StringUtils.strip(""0V5Tf=)&&x_=}6-0"", ""H'yQxJJ\""Z?2<O^"");
    String[] stringArray0 = StringUtils.split(""oW<8<~$opisp6)`"");
    Locale locale0 = Locale.FRANCE;
    Set<String> set0 = locale0.getUnicodeLocaleKeys();
    Stack<Locale.LanguageRange> stack0 = new Stack<Locale.LanguageRange>();
    ArrayDeque<String> arrayDeque0 = new ArrayDeque<String>();
    List<String> list0 = Locale.filterTags((List<Locale.LanguageRange>) stack0, (Collection<String>) arrayDeque0);
    String string3 = StringUtils.lowerCase(""9rXUD?c4sV6oV"", locale0);
    assertNotNull(string3);
}","/**
 * <p>Converts a String to lower case as per {@link String#toLowerCase(Locale)}.</p>
 *
 * <p>A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.lowerCase(null, Locale.ENGLISH)  = null
 * StringUtils.lowerCase("""", Locale.ENGLISH)    = """"
 * StringUtils.lowerCase(""aBc"", Locale.ENGLISH) = ""abc""
 * </pre>
 *
 * @param str  the String to lower case, may be null
 * @param locale  the locale that defines the case transformation rules, must not be null
 * @return the lower cased String, {@code null} if null String input
 * @since 2.5
 */"
"public static int lastOrdinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal) {
    return ordinalIndexOf(str, searchStr, ordinal, true);
}","public void test252760() throws Throwable {
    int int0 = StringUtils.lastIndexOf((CharSequence) null, 0, 0);
    String string0 = StringUtils.center("""", 7);
    String string1 = StringUtils.chop("""");
    String string2 = StringUtils.strip(""0V5Tf=)&&x_=}6-0"", ""H'yQxJJ\""Z?2<O^"");
    String[] stringArray0 = StringUtils.split(""oW<8<~$opisp6)`"");
    Locale locale0 = Locale.FRANCE;
    Set<String> set0 = locale0.getUnicodeLocaleKeys();
    Stack<Locale.LanguageRange> stack0 = new Stack<Locale.LanguageRange>();
    ArrayDeque<String> arrayDeque0 = new ArrayDeque<String>();
    List<String> list0 = Locale.filterTags((List<Locale.LanguageRange>) stack0, (Collection<String>) arrayDeque0);
    String string3 = StringUtils.lowerCase(""9rXUD?c4sV6oV"", locale0);
    int int1 = StringUtils.lastOrdinalIndexOf("""", (CharSequence) null, 7);
    assertEquals((-1), int1);
}","/**
 * <p>Finds the n-th last index within a String, handling {@code null}.
 * This method uses {@link String#lastIndexOf(String)}.</p>
 *
 * <p>A {@code null} String will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.lastOrdinalIndexOf(null, *, *)          = -1
 * StringUtils.lastOrdinalIndexOf(*, null, *)          = -1
 * StringUtils.lastOrdinalIndexOf("""", """", *)           = 0
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", ""a"", 1)  = 7
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", ""a"", 2)  = 6
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", ""b"", 1)  = 5
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", ""b"", 2)  = 2
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", ""ab"", 1) = 4
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", ""ab"", 2) = 1
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", """", 1)   = 8
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", """", 2)   = 8
 * </pre>
 *
 * <p>Note that 'tail(CharSequence str, int n)' may be implemented as: </p>
 *
 * <pre>
 *   str.substring(lastOrdinalIndexOf(str, ""\n"", n) + 1)
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @param ordinal  the n-th last {@code searchStr} to find
 * @return the n-th last index of the search CharSequence,
 *  {@code -1} ({@code INDEX_NOT_FOUND}) if no match or {@code null} string input
 * @since 2.5
 * @since 3.0 Changed signature from lastOrdinalIndexOf(String, String, int) to lastOrdinalIndexOf(CharSequence, CharSequence, int)
 */"
"public static String swapCase(String str) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    StringBuilder buffer = new StringBuilder(strLen);
    char ch = 0;
    for (int i = 0; i < strLen; i++) {
        ch = str.charAt(i);
        if (Character.isUpperCase(ch)) {
            ch = Character.toLowerCase(ch);
        } else if (Character.isTitleCase(ch)) {
            ch = Character.toLowerCase(ch);
        } else if (Character.isLowerCase(ch)) {
            ch = Character.toUpperCase(ch);
        }
        buffer.append(ch);
    }
    return buffer.toString();
}","public void test253762() throws Throwable {
    String string0 = StringUtils.swapCase((String) null);
    assertNull(string0);
}","/**
 * <p>Swaps the case of a String changing upper and title case to
 * lower case, and lower case to upper case.</p>
 *
 * <ul>
 *  <li>Upper case character converts to Lower case</li>
 *  <li>Title case character converts to Lower case</li>
 *  <li>Lower case character converts to Upper case</li>
 * </ul>
 *
 * <p>For a word based algorithm, see {@link org.apache.commons.lang3.text.WordUtils#swapCase(String)}.
 * A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.swapCase(null)                 = null
 * StringUtils.swapCase("""")                   = """"
 * StringUtils.swapCase(""The dog has a BONE"") = ""tHE DOG HAS A bone""
 * </pre>
 *
 * <p>NOTE: This method changed in Lang version 2.0.
 * It no longer performs a word based algorithm.
 * If you only use ASCII, you will notice no change.
 * That functionality is available in org.apache.commons.lang3.text.WordUtils.</p>
 *
 * @param str  the String to swap case, may be null
 * @return the changed String, {@code null} if null String input
 */"
"public static int lastIndexOf(CharSequence seq, int searchChar, int startPos) {
    if (isEmpty(seq)) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.lastIndexOf(seq, searchChar, startPos);
}","public void test253763() throws Throwable {
    String string0 = StringUtils.swapCase((String) null);
    int int0 = StringUtils.lastIndexOf((CharSequence) null, 90, 90);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index within a CharSequence from a start position,
 * handling {@code null}.
 * This method uses {@link String#lastIndexOf(int, int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("""") CharSequence will return {@code -1}.
 * A negative start position returns {@code -1}.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOf(null, *, *)          = -1
 * StringUtils.lastIndexOf("""", *,  *)           = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 8)  = 5
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 4)  = 2
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 0)  = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 9)  = 5
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', -1) = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'a', 0)  = 0
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @param startPos  the start position
 * @return the last index of the search character,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from lastIndexOf(String, int, int) to lastIndexOf(CharSequence, int, int)
 */"
"// Replacing
//-----------------------------------------------------------------------
/**
 * <p>Replaces a String with another String inside a larger String, once.</p>
 *
 * <p>A {@code null} reference passed to this method is a no-op.</p>
 *
 * <pre>
 * StringUtils.replaceOnce(null, *, *)        = null
 * StringUtils.replaceOnce("""", *, *)          = """"
 * StringUtils.replaceOnce(""any"", null, *)    = ""any""
 * StringUtils.replaceOnce(""any"", *, null)    = ""any""
 * StringUtils.replaceOnce(""any"", """", *)      = ""any""
 * StringUtils.replaceOnce(""aba"", ""a"", null)  = ""aba""
 * StringUtils.replaceOnce(""aba"", ""a"", """")    = ""ba""
 * StringUtils.replaceOnce(""aba"", ""a"", ""z"")   = ""zba""
 * </pre>
 *
 * @see #replace(String text, String searchString, String replacement, int max)
 * @param text  text to search and replace in, may be null
 * @param searchString  the String to search for, may be null
 * @param replacement  the String to replace with, may be null
 * @return the text with any replacements processed,
 *  {@code null} if null String input
 */
public static String replaceOnce(String text, String searchString, String replacement) {
    return replace(text, searchString, replacement, 1);
}","public void test254764() throws Throwable {
    String string0 = StringUtils.replaceOnce("""", ""9#1\""^hDjCR<{HrN{"", """");
    assertNotNull(string0);
}",""
"// Stripping
//-----------------------------------------------------------------------
/**
 * <p>Strips whitespace from the start and end of a String.</p>
 *
 * <p>This is similar to {@link #trim(String)} but removes whitespace.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <p>A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.strip(null)     = null
 * StringUtils.strip("""")       = """"
 * StringUtils.strip(""   "")    = """"
 * StringUtils.strip(""abc"")    = ""abc""
 * StringUtils.strip(""  abc"")  = ""abc""
 * StringUtils.strip(""abc  "")  = ""abc""
 * StringUtils.strip("" abc "")  = ""abc""
 * StringUtils.strip("" ab c "") = ""ab c""
 * </pre>
 *
 * @param str  the String to remove whitespace from, may be null
 * @return the stripped String, {@code null} if null String input
 */
public static String strip(String str) {
    return strip(str, null);
}","public void test254766() throws Throwable {
    String string0 = StringUtils.replaceOnce("""", ""9#1\""^hDjCR<{HrN{"", """");
    String string1 = StringUtils.strip("""");
    assertNotNull(string1);
}",""
"public static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal) {
    return ordinalIndexOf(str, searchStr, ordinal, false);
}","public void test254769() throws Throwable {
    String string0 = StringUtils.replaceOnce("""", ""9#1\""^hDjCR<{HrN{"", """");
    String string1 = StringUtils.strip("""");
    int int0 = StringUtils.ordinalIndexOf(""9#1\""^hDjCR<{HrN{"", """", 540);
    assertEquals(0, int0);
}","/**
 * <p>Finds the n-th index within a CharSequence, handling {@code null}.
 * This method uses {@link String#indexOf(String)} if possible.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.ordinalIndexOf(null, *, *)          = -1
 * StringUtils.ordinalIndexOf(*, null, *)          = -1
 * StringUtils.ordinalIndexOf("""", """", *)           = 0
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""a"", 1)  = 0
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""a"", 2)  = 1
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""b"", 1)  = 2
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""b"", 2)  = 5
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""ab"", 1) = 1
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""ab"", 2) = 4
 * StringUtils.ordinalIndexOf(""aabaabaa"", """", 1)   = 0
 * StringUtils.ordinalIndexOf(""aabaabaa"", """", 2)   = 0
 * </pre>
 *
 * <p>Note that 'head(CharSequence str, int n)' may be implemented as: </p>
 *
 * <pre>
 *   str.substring(0, lastOrdinalIndexOf(str, ""\n"", n))
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @param ordinal  the n-th {@code searchStr} to find
 * @return the n-th index of the search CharSequence,
 *  {@code -1} ({@code INDEX_NOT_FOUND}) if no match or {@code null} string input
 * @since 2.1
 * @since 3.0 Changed signature from ordinalIndexOf(String, String, int) to ordinalIndexOf(CharSequence, CharSequence, int)
 */"
"public static int indexOfAny(CharSequence cs, String searchChars) {
    if (isEmpty(cs) || isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    return indexOfAny(cs, searchChars.toCharArray());
}","public void test254770() throws Throwable {
    String string0 = StringUtils.replaceOnce("""", ""9#1\""^hDjCR<{HrN{"", """");
    String string1 = StringUtils.strip("""");
    int int0 = StringUtils.ordinalIndexOf(""9#1\""^hDjCR<{HrN{"", """", 540);
    int int1 = StringUtils.indexOfAny((CharSequence) ""9#1\""^hDjCR<{HrN{"", ""9#1\""^hDjCR<{HrN{"");
    assertEquals(0, int1);
}","/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A {@code null} String will return {@code -1}.
 * A {@code null} search string will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)            = -1
 * StringUtils.indexOfAny("""", *)              = -1
 * StringUtils.indexOfAny(*, null)            = -1
 * StringUtils.indexOfAny(*, """")              = -1
 * StringUtils.indexOfAny(""zzabyycdxx"", ""za"") = 0
 * StringUtils.indexOfAny(""zzabyycdxx"", ""by"") = 3
 * StringUtils.indexOfAny(""aba"",""z"")          = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAny(String, String) to indexOfAny(CharSequence, String)
 */"
"public static boolean containsIgnoreCase(CharSequence str, CharSequence searchStr) {
    if (str == null || searchStr == null) {
        return false;
    }
    int len = searchStr.length();
    int max = str.length() - len;
    for (int i = 0; i <= max; i++) {
        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) {
            return true;
        }
    }
    return false;
}","public void test254772() throws Throwable {
    String string0 = StringUtils.replaceOnce("""", ""9#1\""^hDjCR<{HrN{"", """");
    String string1 = StringUtils.strip("""");
    int int0 = StringUtils.ordinalIndexOf(""9#1\""^hDjCR<{HrN{"", """", 540);
    int int1 = StringUtils.indexOfAny((CharSequence) ""9#1\""^hDjCR<{HrN{"", ""9#1\""^hDjCR<{HrN{"");
    boolean boolean0 = StringUtils.containsIgnoreCase("""", ""9#1\""^hDjCR<{HrN{"");
    assertFalse(boolean0);
}","/**
 * <p>Checks if CharSequence contains a search CharSequence irrespective of case,
 * handling {@code null}. Case-insensitivity is defined as by
 * {@link String#equalsIgnoreCase(String)}.
 *
 * <p>A {@code null} CharSequence will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.contains(null, *) = false
 * StringUtils.contains(*, null) = false
 * StringUtils.contains("""", """") = true
 * StringUtils.contains(""abc"", """") = true
 * StringUtils.contains(""abc"", ""a"") = true
 * StringUtils.contains(""abc"", ""z"") = false
 * StringUtils.contains(""abc"", ""A"") = true
 * StringUtils.contains(""abc"", ""Z"") = false
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @return true if the CharSequence contains the search CharSequence irrespective of
 * case or false if not or {@code null} string input
 * @since 3.0 Changed signature from containsIgnoreCase(String, String) to containsIgnoreCase(CharSequence, CharSequence)
 */"
"public static String strip(String str, String stripChars) {
    if (isEmpty(str)) {
        return str;
    }
    str = stripStart(str, stripChars);
    return stripEnd(str, stripChars);
}","public void test254773() throws Throwable {
    String string0 = StringUtils.replaceOnce("""", ""9#1\""^hDjCR<{HrN{"", """");
    String string1 = StringUtils.strip("""");
    int int0 = StringUtils.ordinalIndexOf(""9#1\""^hDjCR<{HrN{"", """", 540);
    int int1 = StringUtils.indexOfAny((CharSequence) ""9#1\""^hDjCR<{HrN{"", ""9#1\""^hDjCR<{HrN{"");
    boolean boolean0 = StringUtils.containsIgnoreCase("""", ""9#1\""^hDjCR<{HrN{"");
    String string2 = StringUtils.strip(""JRlpwr]=tL%oKu"", ""I]*OO&Adp=WC:h5"");
    assertNotNull(string2);
}","/**
 * <p>Strips any of a set of characters from the start and end of a String.
 * This is similar to {@link String#trim()} but allows the characters
 * to be stripped to be controlled.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * An empty string ("""") input returns the empty string.</p>
 *
 * <p>If the stripChars String is {@code null}, whitespace is
 * stripped as defined by {@link Character#isWhitespace(char)}.
 * Alternatively use {@link #strip(String)}.</p>
 *
 * <pre>
 * StringUtils.strip(null, *)          = null
 * StringUtils.strip("""", *)            = """"
 * StringUtils.strip(""abc"", null)      = ""abc""
 * StringUtils.strip(""  abc"", null)    = ""abc""
 * StringUtils.strip(""abc  "", null)    = ""abc""
 * StringUtils.strip("" abc "", null)    = ""abc""
 * StringUtils.strip(""  abcyx"", ""xyz"") = ""  abc""
 * </pre>
 *
 * @param str  the String to remove characters from, may be null
 * @param stripChars  the characters to remove, null treated as whitespace
 * @return the stripped String, {@code null} if null String input
 */"
"// startsWith
//-----------------------------------------------------------------------
/**
 * <p>Check if a CharSequence starts with a specified prefix.</p>
 *
 * <p>{@code null}s are handled without exceptions. Two {@code null}
 * references are considered to be equal. The comparison is case sensitive.</p>
 *
 * <pre>
 * StringUtils.startsWith(null, null)      = true
 * StringUtils.startsWith(null, ""abc"")     = false
 * StringUtils.startsWith(""abcdef"", null)  = false
 * StringUtils.startsWith(""abcdef"", ""abc"") = true
 * StringUtils.startsWith(""ABCDEF"", ""abc"") = false
 * </pre>
 *
 * @see java.lang.String#startsWith(String)
 * @param str  the CharSequence to check, may be null
 * @param prefix the prefix to find, may be null
 * @return {@code true} if the CharSequence starts with the prefix, case sensitive, or
 *  both {@code null}
 * @since 2.4
 * @since 3.0 Changed signature from startsWith(String, String) to startsWith(CharSequence, CharSequence)
 */
public static boolean startsWith(CharSequence str, CharSequence prefix) {
    return startsWith(str, prefix, false);
}","public void test254777() throws Throwable {
    String string0 = StringUtils.replaceOnce("""", ""9#1\""^hDjCR<{HrN{"", """");
    String string1 = StringUtils.strip("""");
    int int0 = StringUtils.ordinalIndexOf(""9#1\""^hDjCR<{HrN{"", """", 540);
    int int1 = StringUtils.indexOfAny((CharSequence) ""9#1\""^hDjCR<{HrN{"", ""9#1\""^hDjCR<{HrN{"");
    boolean boolean0 = StringUtils.containsIgnoreCase("""", ""9#1\""^hDjCR<{HrN{"");
    String string2 = StringUtils.strip(""JRlpwr]=tL%oKu"", ""I]*OO&Adp=WC:h5"");
    boolean boolean1 = StringUtils.startsWith("""", """");
    assertTrue(boolean1);
}",""
"// Remove
//-----------------------------------------------------------------------
/**
 * <p>Removes a substring only if it is at the begining of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("""") source string will return the empty string.
 * A {@code null} search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeStart(null, *)      = null
 * StringUtils.removeStart("""", *)        = """"
 * StringUtils.removeStart(*, null)      = *
 * StringUtils.removeStart(""www.domain.com"", ""www."")   = ""domain.com""
 * StringUtils.removeStart(""domain.com"", ""www."")       = ""domain.com""
 * StringUtils.removeStart(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeStart(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for and remove, may be null
 * @return the substring with the string removed if found,
 *  {@code null} if null String input
 * @since 2.1
 */
public static String removeStart(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (str.startsWith(remove)) {
        return str.substring(remove.length());
    }
    return str;
}","public void test254779() throws Throwable {
    String string0 = StringUtils.replaceOnce("""", ""9#1\""^hDjCR<{HrN{"", """");
    String string1 = StringUtils.strip("""");
    int int0 = StringUtils.ordinalIndexOf(""9#1\""^hDjCR<{HrN{"", """", 540);
    int int1 = StringUtils.indexOfAny((CharSequence) ""9#1\""^hDjCR<{HrN{"", ""9#1\""^hDjCR<{HrN{"");
    boolean boolean0 = StringUtils.containsIgnoreCase("""", ""9#1\""^hDjCR<{HrN{"");
    String string2 = StringUtils.strip(""JRlpwr]=tL%oKu"", ""I]*OO&Adp=WC:h5"");
    boolean boolean1 = StringUtils.startsWith("""", """");
    String string3 = StringUtils.removeStart(""{r[v@3Rg"", """");
    assertNotNull(string3);
}",""
"public StringUtils() {
    super();
}","public void test255783() throws Throwable {
    StringUtils stringUtils0 = new StringUtils();
    assertEquals((-1), StringUtils.INDEX_NOT_FOUND);
}","/**
 * <p>{@code StringUtils} instances should NOT be constructed in
 * standard programming. Instead, the class should be used as
 * {@code StringUtils.trim("" foo "");}.</p>
 *
 * <p>This constructor is public to permit tools that require a JavaBean
 * instance to operate.</p>
 */"
"// Case conversion
//-----------------------------------------------------------------------
/**
 * <p>Converts a String to upper case as per {@link String#toUpperCase()}.</p>
 *
 * <p>A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.upperCase(null)  = null
 * StringUtils.upperCase("""")    = """"
 * StringUtils.upperCase(""aBc"") = ""ABC""
 * </pre>
 *
 * <p><strong>Note:</strong> As described in the documentation for {@link String#toUpperCase()},
 * the result of this method is affected by the current locale.
 * For platform-independent case transformations, the method {@link #lowerCase(String, Locale)}
 * should be used with a specific locale (e.g. {@link Locale#ENGLISH}).</p>
 *
 * @param str  the String to upper case, may be null
 * @return the upper cased String, {@code null} if null String input
 */
public static String upperCase(String str) {
    if (str == null) {
        return null;
    }
    return str.toUpperCase();
}","public void test255785() throws Throwable {
    StringUtils stringUtils0 = new StringUtils();
    String string0 = StringUtils.upperCase(""Sw(kT@rOU|*#kC@TvV<"");
    assertNotNull(string0);
}",""
"public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) {
    return StringUtils.isEmpty(str) ? defaultStr : str;
}","public void test256787() throws Throwable {
    String string0 = """";
    String string1 = StringUtils.defaultIfEmpty("""", """");
    assertNotNull(string1);
}","/**
 * <p>Returns either the passed in CharSequence, or if the CharSequence is
 * empty or {@code null}, the value of {@code defaultStr}.</p>
 *
 * <pre>
 * StringUtils.defaultIfEmpty(null, ""NULL"")  = ""NULL""
 * StringUtils.defaultIfEmpty("""", ""NULL"")    = ""NULL""
 * StringUtils.defaultIfEmpty(""bat"", ""NULL"") = ""bat""
 * StringUtils.defaultIfEmpty("""", null)      = null
 * </pre>
 * @param <T> the specific kind of CharSequence
 * @param str  the CharSequence to check, may be null
 * @param defaultStr  the default CharSequence to return
 *  if the input is empty ("""") or {@code null}, may be null
 * @return the passed in CharSequence, or the default
 * @see StringUtils#defaultString(String, String)
 */"
"public static boolean isNotEmpty(CharSequence cs) {
    return !StringUtils.isEmpty(cs);
}","public void test256790() throws Throwable {
    String string0 = """";
    String string1 = StringUtils.defaultIfEmpty("""", """");
    boolean boolean0 = StringUtils.isNotEmpty("""");
    assertFalse(boolean0);
}","/**
 * <p>Checks if a CharSequence is not empty ("""") and not null.</p>
 *
 * <pre>
 * StringUtils.isNotEmpty(null)      = false
 * StringUtils.isNotEmpty("""")        = false
 * StringUtils.isNotEmpty("" "")       = true
 * StringUtils.isNotEmpty(""bob"")     = true
 * StringUtils.isNotEmpty(""  bob  "") = true
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if the CharSequence is not empty and not null
 * @since 3.0 Changed signature from isNotEmpty(String) to isNotEmpty(CharSequence)
 */"
"public static String[] splitByWholeSeparator(String str, String separator) {
    return splitByWholeSeparatorWorker(str, separator, -1, false);
}","public void test256791() throws Throwable {
    String string0 = """";
    String string1 = StringUtils.defaultIfEmpty("""", """");
    boolean boolean0 = StringUtils.isNotEmpty("""");
    String[] stringArray0 = StringUtils.splitByWholeSeparator("""", """");
    assertEquals(0, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array, separator string specified.</p>
 *
 * <p>The separator(s) will not be included in the returned String array.
 * Adjacent separators are treated as one separator.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} separator splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.splitByWholeSeparator(null, *)               = null
 * StringUtils.splitByWholeSeparator("""", *)                 = []
 * StringUtils.splitByWholeSeparator(""ab de fg"", null)      = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparator(""ab   de fg"", null)    = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparator(""ab:cd:ef"", "":"")       = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitByWholeSeparator(""ab-!-cd-!-ef"", ""-!-"") = [""ab"", ""cd"", ""ef""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @param separator  String containing the String to be used as a delimiter,
 *  {@code null} splits on whitespace
 * @return an array of parsed Strings, {@code null} if null String was input
 */"
"public static int indexOfDifference(CharSequence... css) {
    if (css == null || css.length <= 1) {
        return INDEX_NOT_FOUND;
    }
    boolean anyStringNull = false;
    boolean allStringsNull = true;
    int arrayLen = css.length;
    int shortestStrLen = Integer.MAX_VALUE;
    int longestStrLen = 0;
    // find the min and max string lengths; this avoids checking to make
    // sure we are not exceeding the length of the string each time through
    // the bottom loop.
    for (int i = 0; i < arrayLen; i++) {
        if (css[i] == null) {
            anyStringNull = true;
            shortestStrLen = 0;
        } else {
            allStringsNull = false;
            shortestStrLen = Math.min(css[i].length(), shortestStrLen);
            longestStrLen = Math.max(css[i].length(), longestStrLen);
        }
    }
    // handle lists containing all nulls or all empty strings
    if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) {
        return INDEX_NOT_FOUND;
    }
    // handle lists containing some nulls or some empty strings
    if (shortestStrLen == 0) {
        return 0;
    }
    // find the position with the first difference across all strings
    int firstDiff = -1;
    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {
        char comparisonChar = css[0].charAt(stringPos);
        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {
            if (css[arrayPos].charAt(stringPos) != comparisonChar) {
                firstDiff = stringPos;
                break;
            }
        }
        if (firstDiff != -1) {
            break;
        }
    }
    if (firstDiff == -1 && shortestStrLen != longestStrLen) {
        // we compared all of the characters up to the length of the
        // shortest string and didn't find a match, but the string lengths
        // vary, so return the length of the shortest string.
        return shortestStrLen;
    }
    return firstDiff;
}","public void test256793() throws Throwable {
    String string0 = """";
    String string1 = StringUtils.defaultIfEmpty("""", """");
    boolean boolean0 = StringUtils.isNotEmpty("""");
    String[] stringArray0 = StringUtils.splitByWholeSeparator("""", """");
    CharSequence[] charSequenceArray0 = new CharSequence[6];
    charSequenceArray0[0] = (CharSequence) """";
    charSequenceArray0[1] = (CharSequence) """";
    charSequenceArray0[2] = (CharSequence) """";
    charSequenceArray0[3] = (CharSequence) """";
    charSequenceArray0[4] = (CharSequence) """";
    charSequenceArray0[5] = (CharSequence) """";
    int int0 = StringUtils.indexOfDifference(charSequenceArray0);
    assertEquals(6, charSequenceArray0.length);
}","/**
 * <p>Compares all CharSequences in an array and returns the index at which the
 * CharSequences begin to differ.</p>
 *
 * <p>For example,
 * <code>indexOfDifference(new String[] {""i am a machine"", ""i am a robot""}) -> 7</code></p>
 *
 * <pre>
 * StringUtils.indexOfDifference(null) = -1
 * StringUtils.indexOfDifference(new String[] {}) = -1
 * StringUtils.indexOfDifference(new String[] {""abc""}) = -1
 * StringUtils.indexOfDifference(new String[] {null, null}) = -1
 * StringUtils.indexOfDifference(new String[] {"""", """"}) = -1
 * StringUtils.indexOfDifference(new String[] {"""", null}) = 0
 * StringUtils.indexOfDifference(new String[] {""abc"", null, null}) = 0
 * StringUtils.indexOfDifference(new String[] {null, null, ""abc""}) = 0
 * StringUtils.indexOfDifference(new String[] {"""", ""abc""}) = 0
 * StringUtils.indexOfDifference(new String[] {""abc"", """"}) = 0
 * StringUtils.indexOfDifference(new String[] {""abc"", ""abc""}) = -1
 * StringUtils.indexOfDifference(new String[] {""abc"", ""a""}) = 1
 * StringUtils.indexOfDifference(new String[] {""ab"", ""abxyz""}) = 2
 * StringUtils.indexOfDifference(new String[] {""abcde"", ""abxyz""}) = 2
 * StringUtils.indexOfDifference(new String[] {""abcde"", ""xyz""}) = 0
 * StringUtils.indexOfDifference(new String[] {""xyz"", ""abcde""}) = 0
 * StringUtils.indexOfDifference(new String[] {""i am a machine"", ""i am a robot""}) = 7
 * </pre>
 *
 * @param css  array of CharSequences, entries may be null
 * @return the index where the strings begin to differ; -1 if they are all equal
 * @since 2.4
 * @since 3.0 Changed signature from indexOfDifference(String...) to indexOfDifference(CharSequence...)
 */"
"public static String right(String str, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0) {
        return EMPTY;
    }
    if (str.length() <= len) {
        return str;
    }
    return str.substring(str.length() - len);
}","public void test257796() throws Throwable {
    String string0 = StringUtils.right(""NFD"", 0);
    assertNotNull(string0);
}","/**
 * <p>Gets the rightmost {@code len} characters of a String.</p>
 *
 * <p>If {@code len} characters are not available, or the String
 * is {@code null}, the String will be returned without an
 * an exception. An empty String is returned if len is negative.</p>
 *
 * <pre>
 * StringUtils.right(null, *)    = null
 * StringUtils.right(*, -ve)     = """"
 * StringUtils.right("""", *)      = """"
 * StringUtils.right(""abc"", 0)   = """"
 * StringUtils.right(""abc"", 2)   = ""bc""
 * StringUtils.right(""abc"", 4)   = ""abc""
 * </pre>
 *
 * @param str  the String to get the rightmost characters from, may be null
 * @param len  the length of the required String
 * @return the rightmost characters, {@code null} if null String input
 */"
"public static String uncapitalize(String str) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    return new StringBuilder(strLen).append(Character.toLowerCase(str.charAt(0))).append(str.substring(1)).toString();
}","public void test257798() throws Throwable {
    String string0 = StringUtils.right(""NFD"", 0);
    String string1 = StringUtils.uncapitalize(""NFD"");
    assertNotNull(string1);
}","/**
 * <p>Uncapitalizes a String changing the first letter to title case as
 * per {@link Character#toLowerCase(char)}. No other letters are changed.</p>
 *
 * <p>For a word based algorithm, see {@link org.apache.commons.lang3.text.WordUtils#uncapitalize(String)}.
 * A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.uncapitalize(null)  = null
 * StringUtils.uncapitalize("""")    = """"
 * StringUtils.uncapitalize(""Cat"") = ""cat""
 * StringUtils.uncapitalize(""CAT"") = ""cAT""
 * </pre>
 *
 * @param str the String to uncapitalize, may be null
 * @return the uncapitalized String, {@code null} if null String input
 * @see org.apache.commons.lang3.text.WordUtils#uncapitalize(String)
 * @see #capitalize(String)
 * @since 2.0
 */"
"// Case conversion
//-----------------------------------------------------------------------
/**
 * <p>Converts a String to upper case as per {@link String#toUpperCase()}.</p>
 *
 * <p>A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.upperCase(null)  = null
 * StringUtils.upperCase("""")    = """"
 * StringUtils.upperCase(""aBc"") = ""ABC""
 * </pre>
 *
 * <p><strong>Note:</strong> As described in the documentation for {@link String#toUpperCase()},
 * the result of this method is affected by the current locale.
 * For platform-independent case transformations, the method {@link #lowerCase(String, Locale)}
 * should be used with a specific locale (e.g. {@link Locale#ENGLISH}).</p>
 *
 * @param str  the String to upper case, may be null
 * @return the upper cased String, {@code null} if null String input
 */
public static String upperCase(String str) {
    if (str == null) {
        return null;
    }
    return str.toUpperCase();
}","public void test257801() throws Throwable {
    String string0 = StringUtils.right(""NFD"", 0);
    String string1 = StringUtils.uncapitalize(""NFD"");
    String string2 = StringUtils.upperCase("""");
    assertNotNull(string2);
}",""
"public static String[] splitByWholeSeparator(String str, String separator) {
    return splitByWholeSeparatorWorker(str, separator, -1, false);
}","public void test257805() throws Throwable {
    String string0 = StringUtils.right(""NFD"", 0);
    String string1 = StringUtils.uncapitalize(""NFD"");
    String string2 = StringUtils.upperCase("""");
    String[] stringArray0 = StringUtils.splitByWholeSeparator("""", ""v%e)&i7_BZ(%L.wD^u"");
    assertEquals(0, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array, separator string specified.</p>
 *
 * <p>The separator(s) will not be included in the returned String array.
 * Adjacent separators are treated as one separator.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} separator splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.splitByWholeSeparator(null, *)               = null
 * StringUtils.splitByWholeSeparator("""", *)                 = []
 * StringUtils.splitByWholeSeparator(""ab de fg"", null)      = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparator(""ab   de fg"", null)    = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparator(""ab:cd:ef"", "":"")       = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitByWholeSeparator(""ab-!-cd-!-ef"", ""-!-"") = [""ab"", ""cd"", ""ef""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @param separator  String containing the String to be used as a delimiter,
 *  {@code null} splits on whitespace
 * @return an array of parsed Strings, {@code null} if null String was input
 */"
"public static String[] splitPreserveAllTokens(String str, String separatorChars) {
    return splitWorker(str, separatorChars, -1, true);
}","public void test257807() throws Throwable {
    String string0 = StringUtils.right(""NFD"", 0);
    String string1 = StringUtils.uncapitalize(""NFD"");
    String string2 = StringUtils.upperCase("""");
    String[] stringArray0 = StringUtils.splitByWholeSeparator("""", ""v%e)&i7_BZ(%L.wD^u"");
    String[] stringArray1 = StringUtils.splitPreserveAllTokens(""v%e)&i7_BZ(%L.wD^u"", ""v%e)&i7_BZ(%L.wD^u"");
    assertNotSame(stringArray1, stringArray0);
}","/**
 * <p>Splits the provided text into an array, separators specified,
 * preserving all tokens, including empty tokens created by adjacent
 * separators. This is an alternative to using StringTokenizer.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as separators for empty tokens.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} separatorChars splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.splitPreserveAllTokens(null, *)           = null
 * StringUtils.splitPreserveAllTokens("""", *)             = []
 * StringUtils.splitPreserveAllTokens(""abc def"", null)   = [""abc"", ""def""]
 * StringUtils.splitPreserveAllTokens(""abc def"", "" "")    = [""abc"", ""def""]
 * StringUtils.splitPreserveAllTokens(""abc  def"", "" "")   = [""abc"", """", def""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef"", "":"")   = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef:"", "":"")  = [""ab"", ""cd"", ""ef"", """"]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef::"", "":"") = [""ab"", ""cd"", ""ef"", """", """"]
 * StringUtils.splitPreserveAllTokens(""ab::cd:ef"", "":"")  = [""ab"", """", cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens("":cd:ef"", "":"")     = ["""", cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""::cd:ef"", "":"")    = ["""", """", cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens("":cd:ef:"", "":"")    = ["""", cd"", ""ef"", """"]
 * </pre>
 *
 * @param str  the String to parse, may be {@code null}
 * @param separatorChars  the characters used as the delimiters,
 *  {@code null} splits on whitespace
 * @return an array of parsed Strings, {@code null} if null String input
 * @since 2.1
 */"
"public static boolean isAsciiPrintable(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test257811() throws Throwable {
    String string0 = StringUtils.right(""NFD"", 0);
    String string1 = StringUtils.uncapitalize(""NFD"");
    String string2 = StringUtils.upperCase("""");
    String[] stringArray0 = StringUtils.splitByWholeSeparator("""", ""v%e)&i7_BZ(%L.wD^u"");
    String[] stringArray1 = StringUtils.splitPreserveAllTokens(""v%e)&i7_BZ(%L.wD^u"", ""v%e)&i7_BZ(%L.wD^u"");
    boolean boolean0 = StringUtils.isAsciiPrintable("""");
    assertTrue(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only ASCII printable characters.</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty CharSequence (length()=0) will return {@code true}.</p>
 *
 * <pre>
 * StringUtils.isAsciiPrintable(null)     = false
 * StringUtils.isAsciiPrintable("""")       = true
 * StringUtils.isAsciiPrintable("" "")      = true
 * StringUtils.isAsciiPrintable(""Ceki"")   = true
 * StringUtils.isAsciiPrintable(""ab2c"")   = true
 * StringUtils.isAsciiPrintable(""!ab-c~"") = true
 * StringUtils.isAsciiPrintable(""\u0020"") = true
 * StringUtils.isAsciiPrintable(""\u0021"") = true
 * StringUtils.isAsciiPrintable(""\u007e"") = true
 * StringUtils.isAsciiPrintable(""\u007f"") = false
 * StringUtils.isAsciiPrintable(""Ceki G\u00fclc\u00fc"") = false
 * </pre>
 *
 * @param cs the CharSequence to check, may be null
 * @return {@code true} if every character is in the range
 *  32 thru 126
 * @since 2.1
 * @since 3.0 Changed signature from isAsciiPrintable(String) to isAsciiPrintable(CharSequence)
 */"
"public static String replace(String text, String searchString, String replacement, int max) {
    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {
        return text;
    }
    int start = 0;
    int end = text.indexOf(searchString, start);
    if (end == INDEX_NOT_FOUND) {
        return text;
    }
    int replLength = searchString.length();
    int increase = replacement.length() - replLength;
    increase = (increase < 0 ? 0 : increase);
    increase *= (max < 0 ? 16 : (max > 64 ? 64 : max));
    StringBuilder buf = new StringBuilder(text.length() + increase);
    while (end != INDEX_NOT_FOUND) {
        buf.append(text.substring(start, end)).append(replacement);
        start = end + replLength;
        if (--max == 0) {
            break;
        }
        end = text.indexOf(searchString, start);
    }
    buf.append(text.substring(start));
    return buf.toString();
}","public void test257812() throws Throwable {
    String string0 = StringUtils.right(""NFD"", 0);
    String string1 = StringUtils.uncapitalize(""NFD"");
    String string2 = StringUtils.upperCase("""");
    String[] stringArray0 = StringUtils.splitByWholeSeparator("""", ""v%e)&i7_BZ(%L.wD^u"");
    String[] stringArray1 = StringUtils.splitPreserveAllTokens(""v%e)&i7_BZ(%L.wD^u"", ""v%e)&i7_BZ(%L.wD^u"");
    boolean boolean0 = StringUtils.isAsciiPrintable("""");
    String string3 = StringUtils.replace(""NFD"", """", ""The Array must not be null"", 0);
    assertNotNull(string3);
}","/**
 * <p>Replaces a String with another String inside a larger String,
 * for the first {@code max} values of the search String.</p>
 *
 * <p>A {@code null} reference passed to this method is a no-op.</p>
 *
 * <pre>
 * StringUtils.replace(null, *, *, *)         = null
 * StringUtils.replace("""", *, *, *)           = """"
 * StringUtils.replace(""any"", null, *, *)     = ""any""
 * StringUtils.replace(""any"", *, null, *)     = ""any""
 * StringUtils.replace(""any"", """", *, *)       = ""any""
 * StringUtils.replace(""any"", *, *, 0)        = ""any""
 * StringUtils.replace(""abaa"", ""a"", null, -1) = ""abaa""
 * StringUtils.replace(""abaa"", ""a"", """", -1)   = ""b""
 * StringUtils.replace(""abaa"", ""a"", ""z"", 0)   = ""abaa""
 * StringUtils.replace(""abaa"", ""a"", ""z"", 1)   = ""zbaa""
 * StringUtils.replace(""abaa"", ""a"", ""z"", 2)   = ""zbza""
 * StringUtils.replace(""abaa"", ""a"", ""z"", -1)  = ""zbzz""
 * </pre>
 *
 * @param text  text to search and replace in, may be null
 * @param searchString  the String to search for, may be null
 * @param replacement  the String to replace it with, may be null
 * @param max  maximum number of values to replace, or {@code -1} if no maximum
 * @return the text with any replacements processed,
 *  {@code null} if null String input
 */"
"public static String join(Object[] array, char separator, int startIndex, int endIndex) {
    if (array == null) {
        return null;
    }
    int noOfItems = (endIndex - startIndex);
    if (noOfItems <= 0) {
        return EMPTY;
    }
    StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}","public void test257817() throws Throwable {
    String string0 = StringUtils.right(""NFD"", 0);
    String string1 = StringUtils.uncapitalize(""NFD"");
    String string2 = StringUtils.upperCase("""");
    String[] stringArray0 = StringUtils.splitByWholeSeparator("""", ""v%e)&i7_BZ(%L.wD^u"");
    String[] stringArray1 = StringUtils.splitPreserveAllTokens(""v%e)&i7_BZ(%L.wD^u"", ""v%e)&i7_BZ(%L.wD^u"");
    boolean boolean0 = StringUtils.isAsciiPrintable("""");
    String string3 = StringUtils.replace(""NFD"", """", ""The Array must not be null"", 0);
    // Undeclared exception!
    try {
        StringUtils.join((Object[]) stringArray1, 'Y', 0, 32);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 19
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)               = null
 * StringUtils.join([], *)                 = """"
 * StringUtils.join([null], *)             = """"
 * StringUtils.join([""a"", ""b"", ""c""], ';')  = ""a;b;c""
 * StringUtils.join([""a"", ""b"", ""c""], null) = ""abc""
 * StringUtils.join([null, """", ""a""], ';')  = "";;a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use
 * @param startIndex the first index to start joining from.  It is
 * an error to pass in an end index past the end of the array
 * @param endIndex the index to stop joining from (exclusive). It is
 * an error to pass in an end index past the end of the array
 * @return the joined String, {@code null} if null array input
 * @since 2.0
 */"
"public static String stripStart(String str, String stripChars) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    int start = 0;
    if (stripChars == null) {
        while ((start != strLen) && Character.isWhitespace(str.charAt(start))) {
            start++;
        }
    } else if (stripChars.length() == 0) {
        return str;
    } else {
        while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) {
            start++;
        }
    }
    return str.substring(start);
}","public void test258818() throws Throwable {
    String string0 = StringUtils.stripStart(""Array and element cannot both be null"", ""Array and element cannot both be null"");
    assertNotNull(string0);
}","/**
 * <p>Strips any of a set of characters from the start of a String.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * An empty string ("""") input returns the empty string.</p>
 *
 * <p>If the stripChars String is {@code null}, whitespace is
 * stripped as defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripStart(null, *)          = null
 * StringUtils.stripStart("""", *)            = """"
 * StringUtils.stripStart(""abc"", """")        = ""abc""
 * StringUtils.stripStart(""abc"", null)      = ""abc""
 * StringUtils.stripStart(""  abc"", null)    = ""abc""
 * StringUtils.stripStart(""abc  "", null)    = ""abc  ""
 * StringUtils.stripStart("" abc "", null)    = ""abc ""
 * StringUtils.stripStart(""yxabc  "", ""xyz"") = ""abc  ""
 * </pre>
 *
 * @param str  the String to remove characters from, may be null
 * @param stripChars  the characters to remove, null treated as whitespace
 * @return the stripped String, {@code null} if null String input
 */"
"// IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the first index within a CharSequence, handling {@code null}.
 * This method uses {@link String#indexOf(int, int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("""") CharSequence will return {@code INDEX_NOT_FOUND (-1)}.</p>
 *
 * <pre>
 * StringUtils.indexOf(null, *)         = -1
 * StringUtils.indexOf("""", *)           = -1
 * StringUtils.indexOf(""aabaabaa"", 'a') = 0
 * StringUtils.indexOf(""aabaabaa"", 'b') = 2
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @return the first index of the search character,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from indexOf(String, int) to indexOf(CharSequence, int)
 */
public static int indexOf(CharSequence seq, int searchChar) {
    if (isEmpty(seq)) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.indexOf(seq, searchChar, 0);
}","public void test258820() throws Throwable {
    String string0 = StringUtils.stripStart(""Array and element cannot both be null"", ""Array and element cannot both be null"");
    int int0 = StringUtils.indexOf((CharSequence) ""Array and element cannot both be null"", 0);
    assertEquals((-1), int0);
}",""
"public static String repeat(char ch, int repeat) {
    char[] buf = new char[repeat];
    for (int i = repeat - 1; i >= 0; i--) {
        buf[i] = ch;
    }
    return new String(buf);
}","public void test258821() throws Throwable {
    String string0 = StringUtils.stripStart(""Array and element cannot both be null"", ""Array and element cannot both be null"");
    int int0 = StringUtils.indexOf((CharSequence) ""Array and element cannot both be null"", 0);
    String string1 = StringUtils.repeat('s', 0);
    assertNotNull(string1);
}","/**
 * <p>Returns padding using the specified delimiter repeated
 * to a given length.</p>
 *
 * <pre>
 * StringUtils.repeat(0, 'e')  = """"
 * StringUtils.repeat(3, 'e')  = ""eee""
 * StringUtils.repeat(-2, 'e') = """"
 * </pre>
 *
 * <p>Note: this method doesn't not support padding with
 * <a href=""http://www.unicode.org/glossary/#supplementary_character"">Unicode Supplementary Characters</a>
 * as they require a pair of {@code char}s to be represented.
 * If you are needing to support full I18N of your applications
 * consider using {@link #repeat(String, int)} instead.
 * </p>
 *
 * @param ch  character to repeat
 * @param repeat  number of times to repeat char, negative treated as zero
 * @return String with repeated character
 * @see #repeat(String, int)
 */"
"public static boolean containsAny(CharSequence cs, CharSequence searchChars) {
    if (searchChars == null) {
        return false;
    }
    return containsAny(cs, CharSequenceUtils.toCharArray(searchChars));
}","public void test258824() throws Throwable {
    String string0 = StringUtils.stripStart(""Array and element cannot both be null"", ""Array and element cannot both be null"");
    int int0 = StringUtils.indexOf((CharSequence) ""Array and element cannot both be null"", 0);
    String string1 = StringUtils.repeat('s', 0);
    boolean boolean0 = StringUtils.containsAny((CharSequence) """", (CharSequence) """");
    assertFalse(boolean0);
}","/**
 * <p>
 * Checks if the CharSequence contains any character in the given set of characters.
 * </p>
 *
 * <p>
 * A {@code null} CharSequence will return {@code false}. A {@code null} search CharSequence will return
 * {@code false}.
 * </p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)            = false
 * StringUtils.containsAny("""", *)              = false
 * StringUtils.containsAny(*, null)            = false
 * StringUtils.containsAny(*, """")              = false
 * StringUtils.containsAny(""zzabyycdxx"", ""za"") = true
 * StringUtils.containsAny(""zzabyycdxx"", ""by"") = true
 * StringUtils.containsAny(""aba"",""z"")          = false
 * </pre>
 *
 * @param cs
 *            the CharSequence to check, may be null
 * @param searchChars
 *            the chars to search for, may be null
 * @return the {@code true} if any of the chars are found, {@code false} if no match or null input
 * @since 2.4
 * @since 3.0 Changed signature from containsAny(String, String) to containsAny(CharSequence, CharSequence)
 */"
"public static boolean isNotEmpty(CharSequence cs) {
    return !StringUtils.isEmpty(cs);
}","public void test258825() throws Throwable {
    String string0 = StringUtils.stripStart(""Array and element cannot both be null"", ""Array and element cannot both be null"");
    int int0 = StringUtils.indexOf((CharSequence) ""Array and element cannot both be null"", 0);
    String string1 = StringUtils.repeat('s', 0);
    boolean boolean0 = StringUtils.containsAny((CharSequence) """", (CharSequence) """");
    boolean boolean1 = StringUtils.isNotEmpty(""Array and element cannot both be null"");
    assertTrue(boolean1);
}","/**
 * <p>Checks if a CharSequence is not empty ("""") and not null.</p>
 *
 * <pre>
 * StringUtils.isNotEmpty(null)      = false
 * StringUtils.isNotEmpty("""")        = false
 * StringUtils.isNotEmpty("" "")       = true
 * StringUtils.isNotEmpty(""bob"")     = true
 * StringUtils.isNotEmpty(""  bob  "") = true
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if the CharSequence is not empty and not null
 * @since 3.0 Changed signature from isNotEmpty(String) to isNotEmpty(CharSequence)
 */"
"// IndexOfAnyBut chars
//-----------------------------------------------------------------------
/**
 * <p>Searches a CharSequence to find the first index of any
 * character not in the given set of characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A {@code null} or zero length search array will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAnyBut(null, *)                              = -1
 * StringUtils.indexOfAnyBut("""", *)                                = -1
 * StringUtils.indexOfAnyBut(*, null)                              = -1
 * StringUtils.indexOfAnyBut(*, [])                                = -1
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", new char[] {'z', 'a'} ) = 3
 * StringUtils.indexOfAnyBut(""aba"", new char[] {'z'} )             = 0
 * StringUtils.indexOfAnyBut(""aba"", new char[] {'a', 'b'} )        = -1
 *
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAnyBut(String, char[]) to indexOfAnyBut(CharSequence, char...)
 */
public static int indexOfAnyBut(CharSequence cs, char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int csLen = cs.length();
    int csLast = csLen - 1;
    int searchLen = searchChars.length;
    int searchLast = searchLen - 1;
    outer: for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
                    if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        continue outer;
                    }
                } else {
                    continue outer;
                }
            }
        }
        return i;
    }
    return INDEX_NOT_FOUND;
}","public void test258827() throws Throwable {
    String string0 = StringUtils.stripStart(""Array and element cannot both be null"", ""Array and element cannot both be null"");
    int int0 = StringUtils.indexOf((CharSequence) ""Array and element cannot both be null"", 0);
    String string1 = StringUtils.repeat('s', 0);
    boolean boolean0 = StringUtils.containsAny((CharSequence) """", (CharSequence) """");
    boolean boolean1 = StringUtils.isNotEmpty(""Array and element cannot both be null"");
    char[] charArray0 = new char[1];
    charArray0[0] = 's';
    int int1 = StringUtils.indexOfAnyBut((CharSequence) """", charArray0);
    assertEquals(1, charArray0.length);
}",""
"// Difference
//-----------------------------------------------------------------------
/**
 * <p>Compares two Strings, and returns the portion where they differ.
 * (More precisely, return the remainder of the second String,
 * starting from where it's different from the first.)</p>
 *
 * <p>For example,
 * {@code difference(""i am a machine"", ""i am a robot"") -> ""robot""}.</p>
 *
 * <pre>
 * StringUtils.difference(null, null) = null
 * StringUtils.difference("""", """") = """"
 * StringUtils.difference("""", ""abc"") = ""abc""
 * StringUtils.difference(""abc"", """") = """"
 * StringUtils.difference(""abc"", ""abc"") = """"
 * StringUtils.difference(""ab"", ""abxyz"") = ""xyz""
 * StringUtils.difference(""abcde"", ""abxyz"") = ""xyz""
 * StringUtils.difference(""abcde"", ""xyz"") = ""xyz""
 * </pre>
 *
 * @param str1  the first String, may be null
 * @param str2  the second String, may be null
 * @return the portion of str2 where it differs from str1; returns the
 * empty String if they are equal
 * @since 2.0
 */
public static String difference(String str1, String str2) {
    if (str1 == null) {
        return str2;
    }
    if (str2 == null) {
        return str1;
    }
    int at = indexOfDifference(str1, str2);
    if (at == INDEX_NOT_FOUND) {
        return EMPTY;
    }
    return str2.substring(at);
}","public void test259831() throws Throwable {
    String string0 = StringUtils.difference(""InvocationTargetException occurred"", ""0|Yn"");
    assertNotNull(string0);
}",""
"public static boolean isAsciiPrintable(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test259833() throws Throwable {
    String string0 = StringUtils.difference(""InvocationTargetException occurred"", ""0|Yn"");
    boolean boolean0 = StringUtils.isAsciiPrintable(""0|Yn"");
    assertTrue(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only ASCII printable characters.</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty CharSequence (length()=0) will return {@code true}.</p>
 *
 * <pre>
 * StringUtils.isAsciiPrintable(null)     = false
 * StringUtils.isAsciiPrintable("""")       = true
 * StringUtils.isAsciiPrintable("" "")      = true
 * StringUtils.isAsciiPrintable(""Ceki"")   = true
 * StringUtils.isAsciiPrintable(""ab2c"")   = true
 * StringUtils.isAsciiPrintable(""!ab-c~"") = true
 * StringUtils.isAsciiPrintable(""\u0020"") = true
 * StringUtils.isAsciiPrintable(""\u0021"") = true
 * StringUtils.isAsciiPrintable(""\u007e"") = true
 * StringUtils.isAsciiPrintable(""\u007f"") = false
 * StringUtils.isAsciiPrintable(""Ceki G\u00fclc\u00fc"") = false
 * </pre>
 *
 * @param cs the CharSequence to check, may be null
 * @return {@code true} if every character is in the range
 *  32 thru 126
 * @since 2.1
 * @since 3.0 Changed signature from isAsciiPrintable(String) to isAsciiPrintable(CharSequence)
 */"
"// ContainsAny
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains any character in the given
 * set of characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.
 * A {@code null} or zero length search array will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)                = false
 * StringUtils.containsAny("""", *)                  = false
 * StringUtils.containsAny(*, null)                = false
 * StringUtils.containsAny(*, [])                  = false
 * StringUtils.containsAny(""zzabyycdxx"",['z','a']) = true
 * StringUtils.containsAny(""zzabyycdxx"",['b','y']) = true
 * StringUtils.containsAny(""aba"", ['z'])           = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the {@code true} if any of the chars are found,
 * {@code false} if no match or null input
 * @since 2.4
 * @since 3.0 Changed signature from containsAny(String, char[]) to containsAny(CharSequence, char...)
 */
public static boolean containsAny(CharSequence cs, char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    int csLast = csLength - 1;
    int searchLast = searchLength - 1;
    for (int i = 0; i < csLength; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == ch) {
                if (Character.isHighSurrogate(ch)) {
                    if (j == searchLast) {
                        // missing low surrogate, fine, like String.indexOf(String)
                        return true;
                    }
                    if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
                        return true;
                    }
                } else {
                    // ch is in the Basic Multilingual Plane
                    return true;
                }
            }
        }
    }
    return false;
}","public void test259834() throws Throwable {
    String string0 = StringUtils.difference(""InvocationTargetException occurred"", ""0|Yn"");
    boolean boolean0 = StringUtils.isAsciiPrintable(""0|Yn"");
    char[] charArray0 = new char[3];
    charArray0[0] = 'h';
    charArray0[1] = ',';
    charArray0[2] = 'l';
    boolean boolean1 = StringUtils.containsAny((CharSequence) ""InvocationTargetException occurred"", charArray0);
    assertEquals(3, charArray0.length);
}",""
"public static boolean contains(CharSequence seq, CharSequence searchSeq) {
    if (seq == null || searchSeq == null) {
        return false;
    }
    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;
}","public void test259838() throws Throwable {
    String string0 = StringUtils.difference(""InvocationTargetException occurred"", ""0|Yn"");
    boolean boolean0 = StringUtils.isAsciiPrintable(""0|Yn"");
    char[] charArray0 = new char[3];
    charArray0[0] = 'h';
    charArray0[1] = ',';
    charArray0[2] = 'l';
    boolean boolean1 = StringUtils.containsAny((CharSequence) ""InvocationTargetException occurred"", charArray0);
    boolean boolean2 = StringUtils.contains((CharSequence) ""InvocationTargetException occurred"", (CharSequence) ""0|Yn"");
    assertFalse(boolean2);
}","/**
 * <p>Checks if CharSequence contains a search CharSequence, handling {@code null}.
 * This method uses {@link String#indexOf(String)} if possible.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.contains(null, *)     = false
 * StringUtils.contains(*, null)     = false
 * StringUtils.contains("""", """")      = true
 * StringUtils.contains(""abc"", """")   = true
 * StringUtils.contains(""abc"", ""a"")  = true
 * StringUtils.contains(""abc"", ""z"")  = false
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchSeq  the CharSequence to find, may be null
 * @return true if the CharSequence contains the search CharSequence,
 *  false if not or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from contains(String, String) to contains(CharSequence, CharSequence)
 */"
"public static boolean containsNone(CharSequence cs, String invalidChars) {
    if (cs == null || invalidChars == null) {
        return true;
    }
    return containsNone(cs, invalidChars.toCharArray());
}","public void test259841() throws Throwable {
    String string0 = StringUtils.difference(""InvocationTargetException occurred"", ""0|Yn"");
    boolean boolean0 = StringUtils.isAsciiPrintable(""0|Yn"");
    char[] charArray0 = new char[3];
    charArray0[0] = 'h';
    charArray0[1] = ',';
    charArray0[2] = 'l';
    boolean boolean1 = StringUtils.containsAny((CharSequence) ""InvocationTargetException occurred"", charArray0);
    boolean boolean2 = StringUtils.contains((CharSequence) ""InvocationTargetException occurred"", (CharSequence) ""0|Yn"");
    boolean boolean3 = StringUtils.containsNone((CharSequence) ""InvocationTargetException occurred"", ""0|Yn"");
    assertFalse(boolean3);
}","/**
 * <p>Checks that the CharSequence does not contain certain characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code true}.
 * A {@code null} invalid character array will return {@code true}.
 * An empty String ("""") always returns true.</p>
 *
 * <pre>
 * StringUtils.containsNone(null, *)       = true
 * StringUtils.containsNone(*, null)       = true
 * StringUtils.containsNone("""", *)         = true
 * StringUtils.containsNone(""ab"", """")      = true
 * StringUtils.containsNone(""abab"", ""xyz"") = true
 * StringUtils.containsNone(""ab1"", ""xyz"")  = true
 * StringUtils.containsNone(""abz"", ""xyz"")  = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param invalidChars  a String of invalid chars, may be null
 * @return true if it contains none of the invalid chars, or is null
 * @since 2.0
 * @since 3.0 Changed signature from containsNone(String, String) to containsNone(CharSequence, String)
 */"
"// Chomping
//-----------------------------------------------------------------------
/**
 * <p>Removes one newline from end of a String if it's there,
 * otherwise leave it alone.  A newline is &quot;{@code \n}&quot;,
 * &quot;{@code \r}&quot;, or &quot;{@code \r\n}&quot;.</p>
 *
 * <p>NOTE: This method changed in 2.0.
 * It now more closely matches Perl chomp.</p>
 *
 * <pre>
 * StringUtils.chomp(null)          = null
 * StringUtils.chomp("""")            = """"
 * StringUtils.chomp(""abc \r"")      = ""abc ""
 * StringUtils.chomp(""abc\n"")       = ""abc""
 * StringUtils.chomp(""abc\r\n"")     = ""abc""
 * StringUtils.chomp(""abc\r\n\r\n"") = ""abc\r\n""
 * StringUtils.chomp(""abc\n\r"")     = ""abc\n""
 * StringUtils.chomp(""abc\n\rabc"")  = ""abc\n\rabc""
 * StringUtils.chomp(""\r"")          = """"
 * StringUtils.chomp(""\n"")          = """"
 * StringUtils.chomp(""\r\n"")        = """"
 * </pre>
 *
 * @param str  the String to chomp a newline from, may be null
 * @return String without newline, {@code null} if null String input
 */
public static String chomp(String str) {
    if (isEmpty(str)) {
        return str;
    }
    if (str.length() == 1) {
        char ch = str.charAt(0);
        if (ch == CharUtils.CR || ch == CharUtils.LF) {
            return EMPTY;
        }
        return str;
    }
    int lastIdx = str.length() - 1;
    char last = str.charAt(lastIdx);
    if (last == CharUtils.LF) {
        if (str.charAt(lastIdx - 1) == CharUtils.CR) {
            lastIdx--;
        }
    } else if (last != CharUtils.CR) {
        lastIdx++;
    }
    return str.substring(0, lastIdx);
}","public void test259845() throws Throwable {
    String string0 = StringUtils.difference(""InvocationTargetException occurred"", ""0|Yn"");
    boolean boolean0 = StringUtils.isAsciiPrintable(""0|Yn"");
    char[] charArray0 = new char[3];
    charArray0[0] = 'h';
    charArray0[1] = ',';
    charArray0[2] = 'l';
    boolean boolean1 = StringUtils.containsAny((CharSequence) ""InvocationTargetException occurred"", charArray0);
    boolean boolean2 = StringUtils.contains((CharSequence) ""InvocationTargetException occurred"", (CharSequence) ""0|Yn"");
    boolean boolean3 = StringUtils.containsNone((CharSequence) ""InvocationTargetException occurred"", ""0|Yn"");
    String string1 = StringUtils.chomp(""InvocationTargetException occurred"");
    assertNotNull(string1);
}",""
"// Difference
//-----------------------------------------------------------------------
/**
 * <p>Compares two Strings, and returns the portion where they differ.
 * (More precisely, return the remainder of the second String,
 * starting from where it's different from the first.)</p>
 *
 * <p>For example,
 * {@code difference(""i am a machine"", ""i am a robot"") -> ""robot""}.</p>
 *
 * <pre>
 * StringUtils.difference(null, null) = null
 * StringUtils.difference("""", """") = """"
 * StringUtils.difference("""", ""abc"") = ""abc""
 * StringUtils.difference(""abc"", """") = """"
 * StringUtils.difference(""abc"", ""abc"") = """"
 * StringUtils.difference(""ab"", ""abxyz"") = ""xyz""
 * StringUtils.difference(""abcde"", ""abxyz"") = ""xyz""
 * StringUtils.difference(""abcde"", ""xyz"") = ""xyz""
 * </pre>
 *
 * @param str1  the first String, may be null
 * @param str2  the second String, may be null
 * @return the portion of str2 where it differs from str1; returns the
 * empty String if they are equal
 * @since 2.0
 */
public static String difference(String str1, String str2) {
    if (str1 == null) {
        return str2;
    }
    if (str2 == null) {
        return str1;
    }
    int at = indexOfDifference(str1, str2);
    if (at == INDEX_NOT_FOUND) {
        return EMPTY;
    }
    return str2.substring(at);
}","public void test259848() throws Throwable {
    String string0 = StringUtils.difference(""InvocationTargetException occurred"", ""0|Yn"");
    boolean boolean0 = StringUtils.isAsciiPrintable(""0|Yn"");
    char[] charArray0 = new char[3];
    charArray0[0] = 'h';
    charArray0[1] = ',';
    charArray0[2] = 'l';
    boolean boolean1 = StringUtils.containsAny((CharSequence) ""InvocationTargetException occurred"", charArray0);
    boolean boolean2 = StringUtils.contains((CharSequence) ""InvocationTargetException occurred"", (CharSequence) ""0|Yn"");
    boolean boolean3 = StringUtils.containsNone((CharSequence) ""InvocationTargetException occurred"", ""0|Yn"");
    String string1 = StringUtils.chomp(""InvocationTargetException occurred"");
    String string2 = StringUtils.difference(""InvocationTargetException occurred"", ""InvocationTargetException occurred"");
    assertNotNull(string2);
}",""
"// Replace, character based
//-----------------------------------------------------------------------
/**
 * <p>Replaces all occurrences of a character in a String with another.
 * This is a null-safe version of {@link String#replace(char, char)}.</p>
 *
 * <p>A {@code null} string input returns {@code null}.
 * An empty ("""") string input returns an empty string.</p>
 *
 * <pre>
 * StringUtils.replaceChars(null, *, *)        = null
 * StringUtils.replaceChars("""", *, *)          = """"
 * StringUtils.replaceChars(""abcba"", 'b', 'y') = ""aycya""
 * StringUtils.replaceChars(""abcba"", 'z', 'y') = ""abcba""
 * </pre>
 *
 * @param str  String to replace characters in, may be null
 * @param searchChar  the character to search for, may be null
 * @param replaceChar  the character to replace, may be null
 * @return modified String, {@code null} if null string input
 * @since 2.0
 */
public static String replaceChars(String str, char searchChar, char replaceChar) {
    if (str == null) {
        return null;
    }
    return str.replace(searchChar, replaceChar);
}","public void test259852() throws Throwable {
    String string0 = StringUtils.difference(""InvocationTargetException occurred"", ""0|Yn"");
    boolean boolean0 = StringUtils.isAsciiPrintable(""0|Yn"");
    char[] charArray0 = new char[3];
    charArray0[0] = 'h';
    charArray0[1] = ',';
    charArray0[2] = 'l';
    boolean boolean1 = StringUtils.containsAny((CharSequence) ""InvocationTargetException occurred"", charArray0);
    boolean boolean2 = StringUtils.contains((CharSequence) ""InvocationTargetException occurred"", (CharSequence) ""0|Yn"");
    boolean boolean3 = StringUtils.containsNone((CharSequence) ""InvocationTargetException occurred"", ""0|Yn"");
    String string1 = StringUtils.chomp(""InvocationTargetException occurred"");
    String string2 = StringUtils.difference(""InvocationTargetException occurred"", ""InvocationTargetException occurred"");
    String string3 = StringUtils.replaceChars("";"", 'n', 'l');
    assertNotNull(string3);
}",""
"public static String[] split(String str, String separatorChars, int max) {
    return splitWorker(str, separatorChars, max, false);
}","public void test259857() throws Throwable {
    String string0 = StringUtils.difference(""InvocationTargetException occurred"", ""0|Yn"");
    boolean boolean0 = StringUtils.isAsciiPrintable(""0|Yn"");
    char[] charArray0 = new char[3];
    charArray0[0] = 'h';
    charArray0[1] = ',';
    charArray0[2] = 'l';
    boolean boolean1 = StringUtils.containsAny((CharSequence) ""InvocationTargetException occurred"", charArray0);
    boolean boolean2 = StringUtils.contains((CharSequence) ""InvocationTargetException occurred"", (CharSequence) ""0|Yn"");
    boolean boolean3 = StringUtils.containsNone((CharSequence) ""InvocationTargetException occurred"", ""0|Yn"");
    String string1 = StringUtils.chomp(""InvocationTargetException occurred"");
    String string2 = StringUtils.difference(""InvocationTargetException occurred"", ""InvocationTargetException occurred"");
    String string3 = StringUtils.replaceChars("";"", 'n', 'l');
    String[] stringArray0 = StringUtils.split((String) null, "" vs "", (-243));
    assertNull(stringArray0);
}","/**
 * <p>Splits the provided text into an array with a maximum length,
 * separators specified.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as one separator.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} separatorChars splits on whitespace.</p>
 *
 * <p>If more than {@code max} delimited substrings are found, the last
 * returned string includes all characters after the first {@code max - 1}
 * returned strings (including separator characters).</p>
 *
 * <pre>
 * StringUtils.split(null, *, *)            = null
 * StringUtils.split("""", *, *)              = []
 * StringUtils.split(""ab de fg"", null, 0)   = [""ab"", ""cd"", ""ef""]
 * StringUtils.split(""ab   de fg"", null, 0) = [""ab"", ""cd"", ""ef""]
 * StringUtils.split(""ab:cd:ef"", "":"", 0)    = [""ab"", ""cd"", ""ef""]
 * StringUtils.split(""ab:cd:ef"", "":"", 2)    = [""ab"", ""cd:ef""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @param separatorChars  the characters used as the delimiters,
 *  {@code null} splits on whitespace
 * @param max  the maximum number of elements to include in the
 *  array. A zero or negative value implies no limit
 * @return an array of parsed Strings, {@code null} if null String input
 */"
"// Conversion
//-----------------------------------------------------------------------
// Padding
//-----------------------------------------------------------------------
/**
 * <p>Repeat a String {@code repeat} times to form a
 * new String.</p>
 *
 * <pre>
 * StringUtils.repeat(null, 2) = null
 * StringUtils.repeat("""", 0)   = """"
 * StringUtils.repeat("""", 2)   = """"
 * StringUtils.repeat(""a"", 3)  = ""aaa""
 * StringUtils.repeat(""ab"", 2) = ""abab""
 * StringUtils.repeat(""a"", -2) = """"
 * </pre>
 *
 * @param str  the String to repeat, may be null
 * @param repeat  number of times to repeat str, negative treated as zero
 * @return a new String consisting of the original String repeated,
 *  {@code null} if null String input
 */
public static String repeat(String str, int repeat) {
    // Performance tuned for 2.0 (JDK1.4)
    if (str == null) {
        return null;
    }
    if (repeat <= 0) {
        return EMPTY;
    }
    int inputLength = str.length();
    if (repeat == 1 || inputLength == 0) {
        return str;
    }
    if (inputLength == 1 && repeat <= PAD_LIMIT) {
        return repeat(str.charAt(0), repeat);
    }
    int outputLength = inputLength * repeat;
    switch(inputLength) {
        case 1:
            return repeat(str.charAt(0), repeat);
        case 2:
            char ch0 = str.charAt(0);
            char ch1 = str.charAt(1);
            char[] output2 = new char[outputLength];
            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {
                output2[i] = ch0;
                output2[i + 1] = ch1;
            }
            return new String(output2);
        default:
            StringBuilder buf = new StringBuilder(outputLength);
            for (int i = 0; i < repeat; i++) {
                buf.append(str);
            }
            return buf.toString();
    }
}","public void test259858() throws Throwable {
    String string0 = StringUtils.difference(""InvocationTargetException occurred"", ""0|Yn"");
    boolean boolean0 = StringUtils.isAsciiPrintable(""0|Yn"");
    char[] charArray0 = new char[3];
    charArray0[0] = 'h';
    charArray0[1] = ',';
    charArray0[2] = 'l';
    boolean boolean1 = StringUtils.containsAny((CharSequence) ""InvocationTargetException occurred"", charArray0);
    boolean boolean2 = StringUtils.contains((CharSequence) ""InvocationTargetException occurred"", (CharSequence) ""0|Yn"");
    boolean boolean3 = StringUtils.containsNone((CharSequence) ""InvocationTargetException occurred"", ""0|Yn"");
    String string1 = StringUtils.chomp(""InvocationTargetException occurred"");
    String string2 = StringUtils.difference(""InvocationTargetException occurred"", ""InvocationTargetException occurred"");
    String string3 = StringUtils.replaceChars("";"", 'n', 'l');
    String[] stringArray0 = StringUtils.split((String) null, "" vs "", (-243));
    String string4 = StringUtils.repeat(""InvocationTargetException occurred"", 0);
    assertNotNull(string4);
}",""
"public static int indexOfIgnoreCase(CharSequence str, CharSequence searchStr, int startPos) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    if (startPos < 0) {
        startPos = 0;
    }
    int endLimit = (str.length() - searchStr.length()) + 1;
    if (startPos > endLimit) {
        return INDEX_NOT_FOUND;
    }
    if (searchStr.length() == 0) {
        return startPos;
    }
    for (int i = startPos; i < endLimit; i++) {
        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, searchStr.length())) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test259863() throws Throwable {
    String string0 = StringUtils.difference(""InvocationTargetException occurred"", ""0|Yn"");
    boolean boolean0 = StringUtils.isAsciiPrintable(""0|Yn"");
    char[] charArray0 = new char[3];
    charArray0[0] = 'h';
    charArray0[1] = ',';
    charArray0[2] = 'l';
    boolean boolean1 = StringUtils.containsAny((CharSequence) ""InvocationTargetException occurred"", charArray0);
    boolean boolean2 = StringUtils.contains((CharSequence) ""InvocationTargetException occurred"", (CharSequence) ""0|Yn"");
    boolean boolean3 = StringUtils.containsNone((CharSequence) ""InvocationTargetException occurred"", ""0|Yn"");
    String string1 = StringUtils.chomp(""InvocationTargetException occurred"");
    String string2 = StringUtils.difference(""InvocationTargetException occurred"", ""InvocationTargetException occurred"");
    String string3 = StringUtils.replaceChars("";"", 'n', 'l');
    String[] stringArray0 = StringUtils.split((String) null, "" vs "", (-243));
    String string4 = StringUtils.repeat(""InvocationTargetException occurred"", 0);
    int int0 = StringUtils.indexOfIgnoreCase((CharSequence) "";"", (CharSequence) ""InvocationTargetException occurred"", (-2820));
    assertEquals((-1), int0);
}","/**
 * <p>Case in-sensitive find of the first index within a CharSequence
 * from the specified position.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A negative start position is treated as zero.
 * An empty ("""") search CharSequence always matches.
 * A start position greater than the string length only matches
 * an empty search CharSequence.</p>
 *
 * <pre>
 * StringUtils.indexOfIgnoreCase(null, *, *)          = -1
 * StringUtils.indexOfIgnoreCase(*, null, *)          = -1
 * StringUtils.indexOfIgnoreCase("""", """", 0)           = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""A"", 0)  = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", 0)  = 2
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""AB"", 0) = 1
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", 3)  = 5
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", 9)  = -1
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", -1) = 2
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", """", 2)   = 2
 * StringUtils.indexOfIgnoreCase(""abc"", """", 9)        = 3
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @param startPos  the start position, negative treated as zero
 * @return the first index of the search CharSequence,
 *  -1 if no match or {@code null} string input
 * @since 2.5
 * @since 3.0 Changed signature from indexOfIgnoreCase(String, String, int) to indexOfIgnoreCase(CharSequence, CharSequence, int)
 */"
"// Case conversion
//-----------------------------------------------------------------------
/**
 * <p>Converts a String to upper case as per {@link String#toUpperCase()}.</p>
 *
 * <p>A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.upperCase(null)  = null
 * StringUtils.upperCase("""")    = """"
 * StringUtils.upperCase(""aBc"") = ""ABC""
 * </pre>
 *
 * <p><strong>Note:</strong> As described in the documentation for {@link String#toUpperCase()},
 * the result of this method is affected by the current locale.
 * For platform-independent case transformations, the method {@link #lowerCase(String, Locale)}
 * should be used with a specific locale (e.g. {@link Locale#ENGLISH}).</p>
 *
 * @param str  the String to upper case, may be null
 * @return the upper cased String, {@code null} if null String input
 */
public static String upperCase(String str) {
    if (str == null) {
        return null;
    }
    return str.toUpperCase();
}","public void test259864() throws Throwable {
    String string0 = StringUtils.difference(""InvocationTargetException occurred"", ""0|Yn"");
    boolean boolean0 = StringUtils.isAsciiPrintable(""0|Yn"");
    char[] charArray0 = new char[3];
    charArray0[0] = 'h';
    charArray0[1] = ',';
    charArray0[2] = 'l';
    boolean boolean1 = StringUtils.containsAny((CharSequence) ""InvocationTargetException occurred"", charArray0);
    boolean boolean2 = StringUtils.contains((CharSequence) ""InvocationTargetException occurred"", (CharSequence) ""0|Yn"");
    boolean boolean3 = StringUtils.containsNone((CharSequence) ""InvocationTargetException occurred"", ""0|Yn"");
    String string1 = StringUtils.chomp(""InvocationTargetException occurred"");
    String string2 = StringUtils.difference(""InvocationTargetException occurred"", ""InvocationTargetException occurred"");
    String string3 = StringUtils.replaceChars("";"", 'n', 'l');
    String[] stringArray0 = StringUtils.split((String) null, "" vs "", (-243));
    String string4 = StringUtils.repeat(""InvocationTargetException occurred"", 0);
    int int0 = StringUtils.indexOfIgnoreCase((CharSequence) "";"", (CharSequence) ""InvocationTargetException occurred"", (-2820));
    String string5 = StringUtils.upperCase((String) null);
    assertNull(string5);
}",""
"// ContainsAny
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains any character in the given
 * set of characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.
 * A {@code null} or zero length search array will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)                = false
 * StringUtils.containsAny("""", *)                  = false
 * StringUtils.containsAny(*, null)                = false
 * StringUtils.containsAny(*, [])                  = false
 * StringUtils.containsAny(""zzabyycdxx"",['z','a']) = true
 * StringUtils.containsAny(""zzabyycdxx"",['b','y']) = true
 * StringUtils.containsAny(""aba"", ['z'])           = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the {@code true} if any of the chars are found,
 * {@code false} if no match or null input
 * @since 2.4
 * @since 3.0 Changed signature from containsAny(String, char[]) to containsAny(CharSequence, char...)
 */
public static boolean containsAny(CharSequence cs, char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    int csLast = csLength - 1;
    int searchLast = searchLength - 1;
    for (int i = 0; i < csLength; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == ch) {
                if (Character.isHighSurrogate(ch)) {
                    if (j == searchLast) {
                        // missing low surrogate, fine, like String.indexOf(String)
                        return true;
                    }
                    if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
                        return true;
                    }
                } else {
                    // ch is in the Basic Multilingual Plane
                    return true;
                }
            }
        }
    }
    return false;
}","public void test259865() throws Throwable {
    String string0 = StringUtils.difference(""InvocationTargetException occurred"", ""0|Yn"");
    boolean boolean0 = StringUtils.isAsciiPrintable(""0|Yn"");
    char[] charArray0 = new char[3];
    charArray0[0] = 'h';
    charArray0[1] = ',';
    charArray0[2] = 'l';
    boolean boolean1 = StringUtils.containsAny((CharSequence) ""InvocationTargetException occurred"", charArray0);
    boolean boolean2 = StringUtils.contains((CharSequence) ""InvocationTargetException occurred"", (CharSequence) ""0|Yn"");
    boolean boolean3 = StringUtils.containsNone((CharSequence) ""InvocationTargetException occurred"", ""0|Yn"");
    String string1 = StringUtils.chomp(""InvocationTargetException occurred"");
    String string2 = StringUtils.difference(""InvocationTargetException occurred"", ""InvocationTargetException occurred"");
    String string3 = StringUtils.replaceChars("";"", 'n', 'l');
    String[] stringArray0 = StringUtils.split((String) null, "" vs "", (-243));
    String string4 = StringUtils.repeat(""InvocationTargetException occurred"", 0);
    int int0 = StringUtils.indexOfIgnoreCase((CharSequence) "";"", (CharSequence) ""InvocationTargetException occurred"", (-2820));
    String string5 = StringUtils.upperCase((String) null);
    boolean boolean4 = StringUtils.containsAny((CharSequence) """", charArray0);
    assertEquals(3, charArray0.length);
}",""
"public static String stripEnd(String str, String stripChars) {
    int end;
    if (str == null || (end = str.length()) == 0) {
        return str;
    }
    if (stripChars == null) {
        while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) {
            end--;
        }
    } else if (stripChars.length() == 0) {
        return str;
    } else {
        while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) {
            end--;
        }
    }
    return str.substring(0, end);
}","public void test259872() throws Throwable {
    String string0 = StringUtils.difference(""InvocationTargetException occurred"", ""0|Yn"");
    boolean boolean0 = StringUtils.isAsciiPrintable(""0|Yn"");
    char[] charArray0 = new char[3];
    charArray0[0] = 'h';
    charArray0[1] = ',';
    charArray0[2] = 'l';
    boolean boolean1 = StringUtils.containsAny((CharSequence) ""InvocationTargetException occurred"", charArray0);
    boolean boolean2 = StringUtils.contains((CharSequence) ""InvocationTargetException occurred"", (CharSequence) ""0|Yn"");
    boolean boolean3 = StringUtils.containsNone((CharSequence) ""InvocationTargetException occurred"", ""0|Yn"");
    String string1 = StringUtils.chomp(""InvocationTargetException occurred"");
    String string2 = StringUtils.difference(""InvocationTargetException occurred"", ""InvocationTargetException occurred"");
    String string3 = StringUtils.replaceChars("";"", 'n', 'l');
    String[] stringArray0 = StringUtils.split((String) null, "" vs "", (-243));
    String string4 = StringUtils.repeat(""InvocationTargetException occurred"", 0);
    int int0 = StringUtils.indexOfIgnoreCase((CharSequence) "";"", (CharSequence) ""InvocationTargetException occurred"", (-2820));
    String string5 = StringUtils.upperCase((String) null);
    boolean boolean4 = StringUtils.containsAny((CharSequence) """", charArray0);
    String string6 = StringUtils.stripEnd(""java.text.Normalizer is not available"", ""InvocationTargetException occurred"");
    assertNotNull(string6);
}","/**
 * <p>Strips any of a set of characters from the end of a String.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * An empty string ("""") input returns the empty string.</p>
 *
 * <p>If the stripChars String is {@code null}, whitespace is
 * stripped as defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripEnd(null, *)          = null
 * StringUtils.stripEnd("""", *)            = """"
 * StringUtils.stripEnd(""abc"", """")        = ""abc""
 * StringUtils.stripEnd(""abc"", null)      = ""abc""
 * StringUtils.stripEnd(""  abc"", null)    = ""  abc""
 * StringUtils.stripEnd(""abc  "", null)    = ""abc""
 * StringUtils.stripEnd("" abc "", null)    = "" abc""
 * StringUtils.stripEnd(""  abcyx"", ""xyz"") = ""  abc""
 * StringUtils.stripEnd(""120.00"", "".0"")   = ""12""
 * </pre>
 *
 * @param str  the String to remove characters from, may be null
 * @param stripChars  the set of characters to remove, null treated as whitespace
 * @return the stripped String, {@code null} if null String input
 */"
"public static String swapCase(String str) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    StringBuilder buffer = new StringBuilder(strLen);
    char ch = 0;
    for (int i = 0; i < strLen; i++) {
        ch = str.charAt(i);
        if (Character.isUpperCase(ch)) {
            ch = Character.toLowerCase(ch);
        } else if (Character.isTitleCase(ch)) {
            ch = Character.toLowerCase(ch);
        } else if (Character.isLowerCase(ch)) {
            ch = Character.toUpperCase(ch);
        }
        buffer.append(ch);
    }
    return buffer.toString();
}","public void test259879() throws Throwable {
    String string0 = StringUtils.difference(""InvocationTargetException occurred"", ""0|Yn"");
    boolean boolean0 = StringUtils.isAsciiPrintable(""0|Yn"");
    char[] charArray0 = new char[3];
    charArray0[0] = 'h';
    charArray0[1] = ',';
    charArray0[2] = 'l';
    boolean boolean1 = StringUtils.containsAny((CharSequence) ""InvocationTargetException occurred"", charArray0);
    boolean boolean2 = StringUtils.contains((CharSequence) ""InvocationTargetException occurred"", (CharSequence) ""0|Yn"");
    boolean boolean3 = StringUtils.containsNone((CharSequence) ""InvocationTargetException occurred"", ""0|Yn"");
    String string1 = StringUtils.chomp(""InvocationTargetException occurred"");
    String string2 = StringUtils.difference(""InvocationTargetException occurred"", ""InvocationTargetException occurred"");
    String string3 = StringUtils.replaceChars("";"", 'n', 'l');
    String[] stringArray0 = StringUtils.split((String) null, "" vs "", (-243));
    String string4 = StringUtils.repeat(""InvocationTargetException occurred"", 0);
    int int0 = StringUtils.indexOfIgnoreCase((CharSequence) "";"", (CharSequence) ""InvocationTargetException occurred"", (-2820));
    String string5 = StringUtils.upperCase((String) null);
    boolean boolean4 = StringUtils.containsAny((CharSequence) """", charArray0);
    String string6 = StringUtils.stripEnd(""java.text.Normalizer is not available"", ""InvocationTargetException occurred"");
    String string7 = StringUtils.swapCase("":J"");
    assertNotNull(string7);
}","/**
 * <p>Swaps the case of a String changing upper and title case to
 * lower case, and lower case to upper case.</p>
 *
 * <ul>
 *  <li>Upper case character converts to Lower case</li>
 *  <li>Title case character converts to Lower case</li>
 *  <li>Lower case character converts to Upper case</li>
 * </ul>
 *
 * <p>For a word based algorithm, see {@link org.apache.commons.lang3.text.WordUtils#swapCase(String)}.
 * A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.swapCase(null)                 = null
 * StringUtils.swapCase("""")                   = """"
 * StringUtils.swapCase(""The dog has a BONE"") = ""tHE DOG HAS A bone""
 * </pre>
 *
 * <p>NOTE: This method changed in Lang version 2.0.
 * It no longer performs a word based algorithm.
 * If you only use ASCII, you will notice no change.
 * That functionality is available in org.apache.commons.lang3.text.WordUtils.</p>
 *
 * @param str  the String to swap case, may be null
 * @return the changed String, {@code null} if null String input
 */"
"public static String trimToEmpty(String str) {
    return str == null ? EMPTY : str.trim();
}","public void test260887() throws Throwable {
    String string0 = StringUtils.trimToEmpty("""");
    assertNotNull(string0);
}","/**
 * <p>Removes control characters (char &lt;= 32) from both
 * ends of this String returning an empty String ("""") if the String
 * is empty ("""") after the trim or if it is {@code null}.
 *
 * <p>The String is trimmed using {@link String#trim()}.
 * Trim removes start and end characters &lt;= 32.
 * To strip whitespace use {@link #stripToEmpty(String)}.</p>
 *
 * <pre>
 * StringUtils.trimToEmpty(null)          = """"
 * StringUtils.trimToEmpty("""")            = """"
 * StringUtils.trimToEmpty(""     "")       = """"
 * StringUtils.trimToEmpty(""abc"")         = ""abc""
 * StringUtils.trimToEmpty(""    abc    "") = ""abc""
 * </pre>
 *
 * @param str  the String to be trimmed, may be null
 * @return the trimmed String, or an empty String if {@code null} input
 * @since 2.0
 */"
"public static <T extends CharSequence> T defaultIfBlank(T str, T defaultStr) {
    return StringUtils.isBlank(str) ? defaultStr : str;
}","public void test260889() throws Throwable {
    String string0 = StringUtils.trimToEmpty("""");
    CharSequence charSequence0 = StringUtils.defaultIfBlank((CharSequence) """", (CharSequence) """");
    assertNotNull(charSequence0);
}","/**
 * <p>Returns either the passed in CharSequence, or if the CharSequence is
 * whitespace, empty ("""") or {@code null}, the value of {@code defaultStr}.</p>
 *
 * <pre>
 * StringUtils.defaultIfBlank(null, ""NULL"")  = ""NULL""
 * StringUtils.defaultIfBlank("""", ""NULL"")    = ""NULL""
 * StringUtils.defaultIfBlank("" "", ""NULL"")   = ""NULL""
 * StringUtils.defaultIfBlank(""bat"", ""NULL"") = ""bat""
 * StringUtils.defaultIfBlank("""", null)      = null
 * </pre>
 * @param <T> the specific kind of CharSequence
 * @param str the CharSequence to check, may be null
 * @param defaultStr  the default CharSequence to return
 *  if the input is whitespace, empty ("""") or {@code null}, may be null
 * @return the passed in CharSequence, or the default
 * @see StringUtils#defaultString(String, String)
 */"
"public static boolean isNumericSpace(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {
            return false;
        }
    }
    return true;
}","public void test260892() throws Throwable {
    String string0 = StringUtils.trimToEmpty("""");
    CharSequence charSequence0 = StringUtils.defaultIfBlank((CharSequence) """", (CharSequence) """");
    boolean boolean0 = StringUtils.isNumericSpace("""");
    assertTrue(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only unicode digits or space
 * ({@code ' '}).
 * A decimal point is not a unicode digit and returns false.</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty CharSequence (length()=0) will return {@code true}.</p>
 *
 * <pre>
 * StringUtils.isNumericSpace(null)   = false
 * StringUtils.isNumericSpace("""")     = true
 * StringUtils.isNumericSpace(""  "")   = true
 * StringUtils.isNumericSpace(""123"")  = true
 * StringUtils.isNumericSpace(""12 3"") = true
 * StringUtils.isNumericSpace(""ab2c"") = false
 * StringUtils.isNumericSpace(""12-3"") = false
 * StringUtils.isNumericSpace(""12.3"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if only contains digits or space,
 *  and is non-null
 * @since 3.0 Changed signature from isNumericSpace(String) to isNumericSpace(CharSequence)
 */"
"// IndexOfAny chars
//-----------------------------------------------------------------------
/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A {@code null} String will return {@code -1}.
 * A {@code null} or zero length search array will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)                = -1
 * StringUtils.indexOfAny("""", *)                  = -1
 * StringUtils.indexOfAny(*, null)                = -1
 * StringUtils.indexOfAny(*, [])                  = -1
 * StringUtils.indexOfAny(""zzabyycdxx"",['z','a']) = 0
 * StringUtils.indexOfAny(""zzabyycdxx"",['b','y']) = 3
 * StringUtils.indexOfAny(""aba"", ['z'])           = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAny(String, char[]) to indexOfAny(CharSequence, char...)
 */
public static int indexOfAny(CharSequence cs, char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int csLen = cs.length();
    int csLast = csLen - 1;
    int searchLen = searchChars.length;
    int searchLast = searchLen - 1;
    for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
                    // ch is a supplementary character
                    if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        return i;
                    }
                } else {
                    return i;
                }
            }
        }
    }
    return INDEX_NOT_FOUND;
}","public void test260893() throws Throwable {
    String string0 = StringUtils.trimToEmpty("""");
    CharSequence charSequence0 = StringUtils.defaultIfBlank((CharSequence) """", (CharSequence) """");
    boolean boolean0 = StringUtils.isNumericSpace("""");
    char[] charArray0 = new char[2];
    charArray0[0] = '';
    charArray0[1] = '^';
    int int0 = StringUtils.indexOfAny((CharSequence) """", charArray0);
    assertEquals(2, charArray0.length);
}",""
"public static String remove(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    return replace(str, remove, EMPTY, -1);
}","public void test260896() throws Throwable {
    String string0 = StringUtils.trimToEmpty("""");
    CharSequence charSequence0 = StringUtils.defaultIfBlank((CharSequence) """", (CharSequence) """");
    boolean boolean0 = StringUtils.isNumericSpace("""");
    char[] charArray0 = new char[2];
    charArray0[0] = '';
    charArray0[1] = '^';
    int int0 = StringUtils.indexOfAny((CharSequence) """", charArray0);
    CharSequence[] charSequenceArray0 = new CharSequence[8];
    charSequenceArray0[0] = (CharSequence) """";
    charSequenceArray0[1] = (CharSequence) """";
    charSequenceArray0[2] = (CharSequence) """";
    charSequenceArray0[3] = (CharSequence) """";
    charSequenceArray0[4] = (CharSequence) """";
    charSequenceArray0[5] = (CharSequence) """";
    String string1 = StringUtils.remove("""", ""IllegalAccessException occurred"");
    assertNotNull(string1);
}","/**
 * <p>Removes all occurrences of a substring from within the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("""") source string will return the empty string.
 * A {@code null} remove string will return the source string.
 * An empty ("""") remove string will return the source string.</p>
 *
 * <pre>
 * StringUtils.remove(null, *)        = null
 * StringUtils.remove("""", *)          = """"
 * StringUtils.remove(*, null)        = *
 * StringUtils.remove(*, """")          = *
 * StringUtils.remove(""queued"", ""ue"") = ""qd""
 * StringUtils.remove(""queued"", ""zz"") = ""queued""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for and remove, may be null
 * @return the substring with the string removed if found,
 *  {@code null} if null String input
 * @since 2.1
 */"
"public static int indexOfDifference(CharSequence... css) {
    if (css == null || css.length <= 1) {
        return INDEX_NOT_FOUND;
    }
    boolean anyStringNull = false;
    boolean allStringsNull = true;
    int arrayLen = css.length;
    int shortestStrLen = Integer.MAX_VALUE;
    int longestStrLen = 0;
    // find the min and max string lengths; this avoids checking to make
    // sure we are not exceeding the length of the string each time through
    // the bottom loop.
    for (int i = 0; i < arrayLen; i++) {
        if (css[i] == null) {
            anyStringNull = true;
            shortestStrLen = 0;
        } else {
            allStringsNull = false;
            shortestStrLen = Math.min(css[i].length(), shortestStrLen);
            longestStrLen = Math.max(css[i].length(), longestStrLen);
        }
    }
    // handle lists containing all nulls or all empty strings
    if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) {
        return INDEX_NOT_FOUND;
    }
    // handle lists containing some nulls or some empty strings
    if (shortestStrLen == 0) {
        return 0;
    }
    // find the position with the first difference across all strings
    int firstDiff = -1;
    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {
        char comparisonChar = css[0].charAt(stringPos);
        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {
            if (css[arrayPos].charAt(stringPos) != comparisonChar) {
                firstDiff = stringPos;
                break;
            }
        }
        if (firstDiff != -1) {
            break;
        }
    }
    if (firstDiff == -1 && shortestStrLen != longestStrLen) {
        // we compared all of the characters up to the length of the
        // shortest string and didn't find a match, but the string lengths
        // vary, so return the length of the shortest string.
        return shortestStrLen;
    }
    return firstDiff;
}","public void test260900() throws Throwable {
    String string0 = StringUtils.trimToEmpty("""");
    CharSequence charSequence0 = StringUtils.defaultIfBlank((CharSequence) """", (CharSequence) """");
    boolean boolean0 = StringUtils.isNumericSpace("""");
    char[] charArray0 = new char[2];
    charArray0[0] = '';
    charArray0[1] = '^';
    int int0 = StringUtils.indexOfAny((CharSequence) """", charArray0);
    CharSequence[] charSequenceArray0 = new CharSequence[8];
    charSequenceArray0[0] = (CharSequence) """";
    charSequenceArray0[1] = (CharSequence) """";
    charSequenceArray0[2] = (CharSequence) """";
    charSequenceArray0[3] = (CharSequence) """";
    charSequenceArray0[4] = (CharSequence) """";
    charSequenceArray0[5] = (CharSequence) """";
    String string1 = StringUtils.remove("""", ""IllegalAccessException occurred"");
    charSequenceArray0[6] = (CharSequence) """";
    charSequenceArray0[7] = (CharSequence) """";
    int int1 = StringUtils.indexOfDifference(charSequenceArray0);
    assertEquals(8, charSequenceArray0.length);
}","/**
 * <p>Compares all CharSequences in an array and returns the index at which the
 * CharSequences begin to differ.</p>
 *
 * <p>For example,
 * <code>indexOfDifference(new String[] {""i am a machine"", ""i am a robot""}) -> 7</code></p>
 *
 * <pre>
 * StringUtils.indexOfDifference(null) = -1
 * StringUtils.indexOfDifference(new String[] {}) = -1
 * StringUtils.indexOfDifference(new String[] {""abc""}) = -1
 * StringUtils.indexOfDifference(new String[] {null, null}) = -1
 * StringUtils.indexOfDifference(new String[] {"""", """"}) = -1
 * StringUtils.indexOfDifference(new String[] {"""", null}) = 0
 * StringUtils.indexOfDifference(new String[] {""abc"", null, null}) = 0
 * StringUtils.indexOfDifference(new String[] {null, null, ""abc""}) = 0
 * StringUtils.indexOfDifference(new String[] {"""", ""abc""}) = 0
 * StringUtils.indexOfDifference(new String[] {""abc"", """"}) = 0
 * StringUtils.indexOfDifference(new String[] {""abc"", ""abc""}) = -1
 * StringUtils.indexOfDifference(new String[] {""abc"", ""a""}) = 1
 * StringUtils.indexOfDifference(new String[] {""ab"", ""abxyz""}) = 2
 * StringUtils.indexOfDifference(new String[] {""abcde"", ""abxyz""}) = 2
 * StringUtils.indexOfDifference(new String[] {""abcde"", ""xyz""}) = 0
 * StringUtils.indexOfDifference(new String[] {""xyz"", ""abcde""}) = 0
 * StringUtils.indexOfDifference(new String[] {""i am a machine"", ""i am a robot""}) = 7
 * </pre>
 *
 * @param css  array of CharSequences, entries may be null
 * @return the index where the strings begin to differ; -1 if they are all equal
 * @since 2.4
 * @since 3.0 Changed signature from indexOfDifference(String...) to indexOfDifference(CharSequence...)
 */"
"public static int indexOfAny(CharSequence cs, String searchChars) {
    if (isEmpty(cs) || isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    return indexOfAny(cs, searchChars.toCharArray());
}","public void test260903() throws Throwable {
    String string0 = StringUtils.trimToEmpty("""");
    CharSequence charSequence0 = StringUtils.defaultIfBlank((CharSequence) """", (CharSequence) """");
    boolean boolean0 = StringUtils.isNumericSpace("""");
    char[] charArray0 = new char[2];
    charArray0[0] = '';
    charArray0[1] = '^';
    int int0 = StringUtils.indexOfAny((CharSequence) """", charArray0);
    CharSequence[] charSequenceArray0 = new CharSequence[8];
    charSequenceArray0[0] = (CharSequence) """";
    charSequenceArray0[1] = (CharSequence) """";
    charSequenceArray0[2] = (CharSequence) """";
    charSequenceArray0[3] = (CharSequence) """";
    charSequenceArray0[4] = (CharSequence) """";
    charSequenceArray0[5] = (CharSequence) """";
    String string1 = StringUtils.remove("""", ""IllegalAccessException occurred"");
    charSequenceArray0[6] = (CharSequence) """";
    charSequenceArray0[7] = (CharSequence) """";
    int int1 = StringUtils.indexOfDifference(charSequenceArray0);
    int int2 = StringUtils.indexOfAny(charSequenceArray0[4], ""java.text.Normalizer$Form"");
    assertEquals(8, charSequenceArray0.length);
}","/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A {@code null} String will return {@code -1}.
 * A {@code null} search string will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)            = -1
 * StringUtils.indexOfAny("""", *)              = -1
 * StringUtils.indexOfAny(*, null)            = -1
 * StringUtils.indexOfAny(*, """")              = -1
 * StringUtils.indexOfAny(""zzabyycdxx"", ""za"") = 0
 * StringUtils.indexOfAny(""zzabyycdxx"", ""by"") = 3
 * StringUtils.indexOfAny(""aba"",""z"")          = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAny(String, String) to indexOfAny(CharSequence, String)
 */"
"// Left/Right/Mid
//-----------------------------------------------------------------------
/**
 * <p>Gets the leftmost {@code len} characters of a String.</p>
 *
 * <p>If {@code len} characters are not available, or the
 * String is {@code null}, the String will be returned without
 * an exception. An empty String is returned if len is negative.</p>
 *
 * <pre>
 * StringUtils.left(null, *)    = null
 * StringUtils.left(*, -ve)     = """"
 * StringUtils.left("""", *)      = """"
 * StringUtils.left(""abc"", 0)   = """"
 * StringUtils.left(""abc"", 2)   = ""ab""
 * StringUtils.left(""abc"", 4)   = ""abc""
 * </pre>
 *
 * @param str  the String to get the leftmost characters from, may be null
 * @param len  the length of the required String
 * @return the leftmost characters, {@code null} if null String input
 */
public static String left(String str, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0) {
        return EMPTY;
    }
    if (str.length() <= len) {
        return str;
    }
    return str.substring(0, len);
}","public void test261907() throws Throwable {
    String string0 = StringUtils.left("";x~WwI]V@i%'P>>DP"", 363);
    assertNotNull(string0);
}",""
"public static String getCommonPrefix(String... strs) {
    if (strs == null || strs.length == 0) {
        return EMPTY;
    }
    int smallestIndexOfDiff = indexOfDifference(strs);
    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {
        // all strings were identical
        if (strs[0] == null) {
            return EMPTY;
        }
        return strs[0];
    } else if (smallestIndexOfDiff == 0) {
        // there were no common initial characters
        return EMPTY;
    } else {
        // we found a common initial character sequence
        return strs[0].substring(0, smallestIndexOfDiff);
    }
}","public void test261909() throws Throwable {
    String string0 = StringUtils.left("";x~WwI]V@i%'P>>DP"", 363);
    String[] stringArray0 = new String[9];
    stringArray0[0] = "";x~WwI]V@i%'P>>DP"";
    stringArray0[1] = "";x~WwI]V@i%'P>>DP"";
    stringArray0[2] = "";x~WwI]V@i%'P>>DP"";
    stringArray0[3] = """";
    stringArray0[4] = "";x~WwI]V@i%'P>>DP"";
    stringArray0[5] = "";x~WwI]V@i%'P>>DP"";
    stringArray0[6] = "";x~WwI]V@i%'P>>DP"";
    stringArray0[7] = "";x~WwI]V@i%'P>>DP"";
    stringArray0[8] = ""java.text.Normalizer is not available"";
    String string1 = StringUtils.getCommonPrefix(stringArray0);
    assertEquals(9, stringArray0.length);
}","/**
 * <p>Compares all Strings in an array and returns the initial sequence of
 * characters that is common to all of them.</p>
 *
 * <p>For example,
 * <code>getCommonPrefix(new String[] {""i am a machine"", ""i am a robot""}) -> ""i am a ""</code></p>
 *
 * <pre>
 * StringUtils.getCommonPrefix(null) = """"
 * StringUtils.getCommonPrefix(new String[] {}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc""}) = ""abc""
 * StringUtils.getCommonPrefix(new String[] {null, null}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", """"}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", null}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", null, null}) = """"
 * StringUtils.getCommonPrefix(new String[] {null, null, ""abc""}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", ""abc""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", """"}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", ""abc""}) = ""abc""
 * StringUtils.getCommonPrefix(new String[] {""abc"", ""a""}) = ""a""
 * StringUtils.getCommonPrefix(new String[] {""ab"", ""abxyz""}) = ""ab""
 * StringUtils.getCommonPrefix(new String[] {""abcde"", ""abxyz""}) = ""ab""
 * StringUtils.getCommonPrefix(new String[] {""abcde"", ""xyz""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""xyz"", ""abcde""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""i am a machine"", ""i am a robot""}) = ""i am a ""
 * </pre>
 *
 * @param strs  array of String objects, entries may be null
 * @return the initial sequence of characters that are common to all Strings
 * in the array; empty String if the array is null, the elements are all null
 * or if there is no common prefix.
 * @since 2.4
 */"
"public static String reverseDelimited(String str, char separatorChar) {
    if (str == null) {
        return null;
    }
    // could implement manually, but simple way is to reuse other,
    // probably slower, methods.
    String[] strs = split(str, separatorChar);
    ArrayUtils.reverse(strs);
    return join(strs, separatorChar);
}","public void test261913() throws Throwable {
    String string0 = StringUtils.left("";x~WwI]V@i%'P>>DP"", 363);
    String[] stringArray0 = new String[9];
    stringArray0[0] = "";x~WwI]V@i%'P>>DP"";
    stringArray0[1] = "";x~WwI]V@i%'P>>DP"";
    stringArray0[2] = "";x~WwI]V@i%'P>>DP"";
    stringArray0[3] = """";
    stringArray0[4] = "";x~WwI]V@i%'P>>DP"";
    stringArray0[5] = "";x~WwI]V@i%'P>>DP"";
    stringArray0[6] = "";x~WwI]V@i%'P>>DP"";
    stringArray0[7] = "";x~WwI]V@i%'P>>DP"";
    stringArray0[8] = ""java.text.Normalizer is not available"";
    String string1 = StringUtils.getCommonPrefix(stringArray0);
    String string2 = StringUtils.reverseDelimited((String) null, '~');
    assertNull(string2);
}","/**
 * <p>Reverses a String that is delimited by a specific character.</p>
 *
 * <p>The Strings between the delimiters are not reversed.
 * Thus java.lang.String becomes String.lang.java (if the delimiter
 * is {@code '.'}).</p>
 *
 * <pre>
 * StringUtils.reverseDelimited(null, *)      = null
 * StringUtils.reverseDelimited("""", *)        = """"
 * StringUtils.reverseDelimited(""a.b.c"", 'x') = ""a.b.c""
 * StringUtils.reverseDelimited(""a.b.c"", ""."") = ""c.b.a""
 * </pre>
 *
 * @param str  the String to reverse, may be null
 * @param separatorChar  the separator character to use
 * @return the reversed String, {@code null} if null String input
 * @since 2.0
 */"
"public static boolean endsWithAny(CharSequence string, CharSequence... searchStrings) {
    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {
        return false;
    }
    for (int i = 0; i < searchStrings.length; i++) {
        CharSequence searchString = searchStrings[i];
        if (StringUtils.endsWith(string, searchString)) {
            return true;
        }
    }
    return false;
}","public void test261914() throws Throwable {
    String string0 = StringUtils.left("";x~WwI]V@i%'P>>DP"", 363);
    String[] stringArray0 = new String[9];
    stringArray0[0] = "";x~WwI]V@i%'P>>DP"";
    stringArray0[1] = "";x~WwI]V@i%'P>>DP"";
    stringArray0[2] = "";x~WwI]V@i%'P>>DP"";
    stringArray0[3] = """";
    stringArray0[4] = "";x~WwI]V@i%'P>>DP"";
    stringArray0[5] = "";x~WwI]V@i%'P>>DP"";
    stringArray0[6] = "";x~WwI]V@i%'P>>DP"";
    stringArray0[7] = "";x~WwI]V@i%'P>>DP"";
    stringArray0[8] = ""java.text.Normalizer is not available"";
    String string1 = StringUtils.getCommonPrefix(stringArray0);
    String string2 = StringUtils.reverseDelimited((String) null, '~');
    boolean boolean0 = StringUtils.endsWithAny("""", stringArray0);
    assertEquals(9, stringArray0.length);
}","/**
 * <p>Check if a CharSequence ends with any of an array of specified strings.</p>
 *
 * <pre>
 * StringUtils.endsWithAny(null, null)      = false
 * StringUtils.endsWithAny(null, new String[] {""abc""})  = false
 * StringUtils.endsWithAny(""abcxyz"", null)     = false
 * StringUtils.endsWithAny(""abcxyz"", new String[] {""""}) = true
 * StringUtils.endsWithAny(""abcxyz"", new String[] {""xyz""}) = true
 * StringUtils.endsWithAny(""abcxyz"", new String[] {null, ""xyz"", ""abc""}) = true
 * </pre>
 *
 * @param string  the CharSequence to check, may be null
 * @param searchStrings the CharSequences to find, may be null or empty
 * @return {@code true} if the CharSequence ends with any of the the prefixes, case insensitive, or
 *  both {@code null}
 * @since 3.0
 */"
"// Left/Right/Mid
//-----------------------------------------------------------------------
/**
 * <p>Gets the leftmost {@code len} characters of a String.</p>
 *
 * <p>If {@code len} characters are not available, or the
 * String is {@code null}, the String will be returned without
 * an exception. An empty String is returned if len is negative.</p>
 *
 * <pre>
 * StringUtils.left(null, *)    = null
 * StringUtils.left(*, -ve)     = """"
 * StringUtils.left("""", *)      = """"
 * StringUtils.left(""abc"", 0)   = """"
 * StringUtils.left(""abc"", 2)   = ""ab""
 * StringUtils.left(""abc"", 4)   = ""abc""
 * </pre>
 *
 * @param str  the String to get the leftmost characters from, may be null
 * @param len  the length of the required String
 * @return the leftmost characters, {@code null} if null String input
 */
public static String left(String str, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0) {
        return EMPTY;
    }
    if (str.length() <= len) {
        return str;
    }
    return str.substring(0, len);
}","public void test262916() throws Throwable {
    String string0 = StringUtils.left("" is not in the range '0' - '9'"", (-1475));
    assertNotNull(string0);
}",""
"// endsWith
//-----------------------------------------------------------------------
/**
 * <p>Check if a CharSequence ends with a specified suffix.</p>
 *
 * <p>{@code null}s are handled without exceptions. Two {@code null}
 * references are considered to be equal. The comparison is case sensitive.</p>
 *
 * <pre>
 * StringUtils.endsWith(null, null)      = true
 * StringUtils.endsWith(null, ""def"")     = false
 * StringUtils.endsWith(""abcdef"", null)  = false
 * StringUtils.endsWith(""abcdef"", ""def"") = true
 * StringUtils.endsWith(""ABCDEF"", ""def"") = false
 * StringUtils.endsWith(""ABCDEF"", ""cde"") = false
 * </pre>
 *
 * @see java.lang.String#endsWith(String)
 * @param str  the CharSequence to check, may be null
 * @param suffix the suffix to find, may be null
 * @return {@code true} if the CharSequence ends with the suffix, case sensitive, or
 *  both {@code null}
 * @since 2.4
 * @since 3.0 Changed signature from endsWith(String, String) to endsWith(CharSequence, CharSequence)
 */
public static boolean endsWith(CharSequence str, CharSequence suffix) {
    return endsWith(str, suffix, false);
}","public void test262918() throws Throwable {
    String string0 = StringUtils.left("" is not in the range '0' - '9'"", (-1475));
    boolean boolean0 = StringUtils.endsWith("""", "" is not in the range '0' - '9'"");
    assertFalse(boolean0);
}",""
"public static String replace(String text, String searchString, String replacement, int max) {
    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {
        return text;
    }
    int start = 0;
    int end = text.indexOf(searchString, start);
    if (end == INDEX_NOT_FOUND) {
        return text;
    }
    int replLength = searchString.length();
    int increase = replacement.length() - replLength;
    increase = (increase < 0 ? 0 : increase);
    increase *= (max < 0 ? 16 : (max > 64 ? 64 : max));
    StringBuilder buf = new StringBuilder(text.length() + increase);
    while (end != INDEX_NOT_FOUND) {
        buf.append(text.substring(start, end)).append(replacement);
        start = end + replLength;
        if (--max == 0) {
            break;
        }
        end = text.indexOf(searchString, start);
    }
    buf.append(text.substring(start));
    return buf.toString();
}","public void test262919() throws Throwable {
    String string0 = StringUtils.left("" is not in the range '0' - '9'"", (-1475));
    boolean boolean0 = StringUtils.endsWith("""", "" is not in the range '0' - '9'"");
    String string1 = StringUtils.replace("" is not in the range '0' - '9'"", ""%2[[:c9:4[./[KEs-Pm"", """", (-1475));
    assertNotNull(string1);
}","/**
 * <p>Replaces a String with another String inside a larger String,
 * for the first {@code max} values of the search String.</p>
 *
 * <p>A {@code null} reference passed to this method is a no-op.</p>
 *
 * <pre>
 * StringUtils.replace(null, *, *, *)         = null
 * StringUtils.replace("""", *, *, *)           = """"
 * StringUtils.replace(""any"", null, *, *)     = ""any""
 * StringUtils.replace(""any"", *, null, *)     = ""any""
 * StringUtils.replace(""any"", """", *, *)       = ""any""
 * StringUtils.replace(""any"", *, *, 0)        = ""any""
 * StringUtils.replace(""abaa"", ""a"", null, -1) = ""abaa""
 * StringUtils.replace(""abaa"", ""a"", """", -1)   = ""b""
 * StringUtils.replace(""abaa"", ""a"", ""z"", 0)   = ""abaa""
 * StringUtils.replace(""abaa"", ""a"", ""z"", 1)   = ""zbaa""
 * StringUtils.replace(""abaa"", ""a"", ""z"", 2)   = ""zbza""
 * StringUtils.replace(""abaa"", ""a"", ""z"", -1)  = ""zbzz""
 * </pre>
 *
 * @param text  text to search and replace in, may be null
 * @param searchString  the String to search for, may be null
 * @param replacement  the String to replace it with, may be null
 * @param max  maximum number of values to replace, or {@code -1} if no maximum
 * @return the text with any replacements processed,
 *  {@code null} if null String input
 */"
"public static String stripToEmpty(String str) {
    return str == null ? EMPTY : strip(str, null);
}","public void test262922() throws Throwable {
    String string0 = StringUtils.left("" is not in the range '0' - '9'"", (-1475));
    boolean boolean0 = StringUtils.endsWith("""", "" is not in the range '0' - '9'"");
    String string1 = StringUtils.replace("" is not in the range '0' - '9'"", ""%2[[:c9:4[./[KEs-Pm"", """", (-1475));
    String string2 = StringUtils.stripToEmpty(""6qMH{Y|@0C@S3y#6"");
    assertNotNull(string2);
}","/**
 * <p>Strips whitespace from the start and end of a String  returning
 * an empty String if {@code null} input.</p>
 *
 * <p>This is similar to {@link #trimToEmpty(String)} but removes whitespace.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripToEmpty(null)     = """"
 * StringUtils.stripToEmpty("""")       = """"
 * StringUtils.stripToEmpty(""   "")    = """"
 * StringUtils.stripToEmpty(""abc"")    = ""abc""
 * StringUtils.stripToEmpty(""  abc"")  = ""abc""
 * StringUtils.stripToEmpty(""abc  "")  = ""abc""
 * StringUtils.stripToEmpty("" abc "")  = ""abc""
 * StringUtils.stripToEmpty("" ab c "") = ""ab c""
 * </pre>
 *
 * @param str  the String to be stripped, may be null
 * @return the trimmed String, or an empty String if {@code null} input
 * @since 2.0
 */"
"public static String[] splitByWholeSeparator(String str, String separator, int max) {
    return splitByWholeSeparatorWorker(str, separator, max, false);
}","public void test262926() throws Throwable {
    String string0 = StringUtils.left("" is not in the range '0' - '9'"", (-1475));
    boolean boolean0 = StringUtils.endsWith("""", "" is not in the range '0' - '9'"");
    String string1 = StringUtils.replace("" is not in the range '0' - '9'"", ""%2[[:c9:4[./[KEs-Pm"", """", (-1475));
    String string2 = StringUtils.stripToEmpty(""6qMH{Y|@0C@S3y#6"");
    String[] stringArray0 = StringUtils.splitByWholeSeparator("""", """", (-1475));
    assertEquals(0, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array, separator string specified.
 * Returns a maximum of {@code max} substrings.</p>
 *
 * <p>The separator(s) will not be included in the returned String array.
 * Adjacent separators are treated as one separator.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} separator splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.splitByWholeSeparator(null, *, *)               = null
 * StringUtils.splitByWholeSeparator("""", *, *)                 = []
 * StringUtils.splitByWholeSeparator(""ab de fg"", null, 0)      = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparator(""ab   de fg"", null, 0)    = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparator(""ab:cd:ef"", "":"", 2)       = [""ab"", ""cd:ef""]
 * StringUtils.splitByWholeSeparator(""ab-!-cd-!-ef"", ""-!-"", 5) = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitByWholeSeparator(""ab-!-cd-!-ef"", ""-!-"", 2) = [""ab"", ""cd-!-ef""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @param separator  String containing the String to be used as a delimiter,
 *  {@code null} splits on whitespace
 * @param max  the maximum number of elements to include in the returned
 *  array. A zero or negative value implies no limit.
 * @return an array of parsed Strings, {@code null} if null String was input
 */"
"// SubStringAfter/SubStringBefore
//-----------------------------------------------------------------------
/**
 * <p>Gets the substring before the first occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A {@code null} string input will return {@code null}.
 * An empty ("""") string input will return the empty string.
 * A {@code null} separator will return the input string.</p>
 *
 * <p>If nothing is found, the string input is returned.</p>
 *
 * <pre>
 * StringUtils.substringBefore(null, *)      = null
 * StringUtils.substringBefore("""", *)        = """"
 * StringUtils.substringBefore(""abc"", ""a"")   = """"
 * StringUtils.substringBefore(""abcba"", ""b"") = ""a""
 * StringUtils.substringBefore(""abc"", ""c"")   = ""ab""
 * StringUtils.substringBefore(""abc"", ""d"")   = ""abc""
 * StringUtils.substringBefore(""abc"", """")    = """"
 * StringUtils.substringBefore(""abc"", null)  = ""abc""
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring before the first occurrence of the separator,
 *  {@code null} if null String input
 * @since 2.0
 */
public static String substringBefore(String str, String separator) {
    if (isEmpty(str) || separator == null) {
        return str;
    }
    if (separator.length() == 0) {
        return EMPTY;
    }
    int pos = str.indexOf(separator);
    if (pos == INDEX_NOT_FOUND) {
        return str;
    }
    return str.substring(0, pos);
}","public void test263928() throws Throwable {
    String string0 = StringUtils.substringBefore("""", """");
    assertNotNull(string0);
}",""
"public static String replace(String text, String searchString, String replacement, int max) {
    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {
        return text;
    }
    int start = 0;
    int end = text.indexOf(searchString, start);
    if (end == INDEX_NOT_FOUND) {
        return text;
    }
    int replLength = searchString.length();
    int increase = replacement.length() - replLength;
    increase = (increase < 0 ? 0 : increase);
    increase *= (max < 0 ? 16 : (max > 64 ? 64 : max));
    StringBuilder buf = new StringBuilder(text.length() + increase);
    while (end != INDEX_NOT_FOUND) {
        buf.append(text.substring(start, end)).append(replacement);
        start = end + replLength;
        if (--max == 0) {
            break;
        }
        end = text.indexOf(searchString, start);
    }
    buf.append(text.substring(start));
    return buf.toString();
}","public void test263930() throws Throwable {
    String string0 = StringUtils.substringBefore("""", """");
    String string1 = StringUtils.replace("""", """", """", 364);
    assertNotNull(string1);
}","/**
 * <p>Replaces a String with another String inside a larger String,
 * for the first {@code max} values of the search String.</p>
 *
 * <p>A {@code null} reference passed to this method is a no-op.</p>
 *
 * <pre>
 * StringUtils.replace(null, *, *, *)         = null
 * StringUtils.replace("""", *, *, *)           = """"
 * StringUtils.replace(""any"", null, *, *)     = ""any""
 * StringUtils.replace(""any"", *, null, *)     = ""any""
 * StringUtils.replace(""any"", """", *, *)       = ""any""
 * StringUtils.replace(""any"", *, *, 0)        = ""any""
 * StringUtils.replace(""abaa"", ""a"", null, -1) = ""abaa""
 * StringUtils.replace(""abaa"", ""a"", """", -1)   = ""b""
 * StringUtils.replace(""abaa"", ""a"", ""z"", 0)   = ""abaa""
 * StringUtils.replace(""abaa"", ""a"", ""z"", 1)   = ""zbaa""
 * StringUtils.replace(""abaa"", ""a"", ""z"", 2)   = ""zbza""
 * StringUtils.replace(""abaa"", ""a"", ""z"", -1)  = ""zbzz""
 * </pre>
 *
 * @param text  text to search and replace in, may be null
 * @param searchString  the String to search for, may be null
 * @param replacement  the String to replace it with, may be null
 * @param max  maximum number of values to replace, or {@code -1} if no maximum
 * @return the text with any replacements processed,
 *  {@code null} if null String input
 */"
"// Conversion
//-----------------------------------------------------------------------
// Padding
//-----------------------------------------------------------------------
/**
 * <p>Repeat a String {@code repeat} times to form a
 * new String.</p>
 *
 * <pre>
 * StringUtils.repeat(null, 2) = null
 * StringUtils.repeat("""", 0)   = """"
 * StringUtils.repeat("""", 2)   = """"
 * StringUtils.repeat(""a"", 3)  = ""aaa""
 * StringUtils.repeat(""ab"", 2) = ""abab""
 * StringUtils.repeat(""a"", -2) = """"
 * </pre>
 *
 * @param str  the String to repeat, may be null
 * @param repeat  number of times to repeat str, negative treated as zero
 * @return a new String consisting of the original String repeated,
 *  {@code null} if null String input
 */
public static String repeat(String str, int repeat) {
    // Performance tuned for 2.0 (JDK1.4)
    if (str == null) {
        return null;
    }
    if (repeat <= 0) {
        return EMPTY;
    }
    int inputLength = str.length();
    if (repeat == 1 || inputLength == 0) {
        return str;
    }
    if (inputLength == 1 && repeat <= PAD_LIMIT) {
        return repeat(str.charAt(0), repeat);
    }
    int outputLength = inputLength * repeat;
    switch(inputLength) {
        case 1:
            return repeat(str.charAt(0), repeat);
        case 2:
            char ch0 = str.charAt(0);
            char ch1 = str.charAt(1);
            char[] output2 = new char[outputLength];
            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {
                output2[i] = ch0;
                output2[i + 1] = ch1;
            }
            return new String(output2);
        default:
            StringBuilder buf = new StringBuilder(outputLength);
            for (int i = 0; i < repeat; i++) {
                buf.append(str);
            }
            return buf.toString();
    }
}","public void test264933() throws Throwable {
    String string0 = StringUtils.repeat(""AEp]<"", 772);
    assertNotNull(string0);
}",""
"public static String uncapitalize(String str) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    return new StringBuilder(strLen).append(Character.toLowerCase(str.charAt(0))).append(str.substring(1)).toString();
}","public void test264934() throws Throwable {
    String string0 = StringUtils.repeat(""AEp]<"", 772);
    String string1 = StringUtils.uncapitalize("",W)"");
    assertNotNull(string1);
}","/**
 * <p>Uncapitalizes a String changing the first letter to title case as
 * per {@link Character#toLowerCase(char)}. No other letters are changed.</p>
 *
 * <p>For a word based algorithm, see {@link org.apache.commons.lang3.text.WordUtils#uncapitalize(String)}.
 * A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.uncapitalize(null)  = null
 * StringUtils.uncapitalize("""")    = """"
 * StringUtils.uncapitalize(""Cat"") = ""cat""
 * StringUtils.uncapitalize(""CAT"") = ""cAT""
 * </pre>
 *
 * @param str the String to uncapitalize, may be null
 * @return the uncapitalized String, {@code null} if null String input
 * @see org.apache.commons.lang3.text.WordUtils#uncapitalize(String)
 * @see #capitalize(String)
 * @since 2.0
 */"
"// LastIndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the last index within a CharSequence, handling {@code null}.
 * This method uses {@link String#lastIndexOf(int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("""") CharSequence will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.lastIndexOf(null, *)         = -1
 * StringUtils.lastIndexOf("""", *)           = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'a') = 7
 * StringUtils.lastIndexOf(""aabaabaa"", 'b') = 5
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @return the last index of the search character,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from lastIndexOf(String, int) to lastIndexOf(CharSequence, int)
 */
public static int lastIndexOf(CharSequence seq, int searchChar) {
    if (isEmpty(seq)) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.lastIndexOf(seq, searchChar, seq.length());
}","public void test264937() throws Throwable {
    String string0 = StringUtils.repeat(""AEp]<"", 772);
    String string1 = StringUtils.uncapitalize("",W)"");
    int int0 = StringUtils.lastIndexOf((CharSequence) string0, 772);
    assertEquals((-1), int0);
}",""
"public static boolean isAsciiPrintable(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test264939() throws Throwable {
    String string0 = StringUtils.repeat(""AEp]<"", 772);
    String string1 = StringUtils.uncapitalize("",W)"");
    int int0 = StringUtils.lastIndexOf((CharSequence) string0, 772);
    boolean boolean0 = StringUtils.isAsciiPrintable(""AEp]<"");
    assertTrue(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only ASCII printable characters.</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty CharSequence (length()=0) will return {@code true}.</p>
 *
 * <pre>
 * StringUtils.isAsciiPrintable(null)     = false
 * StringUtils.isAsciiPrintable("""")       = true
 * StringUtils.isAsciiPrintable("" "")      = true
 * StringUtils.isAsciiPrintable(""Ceki"")   = true
 * StringUtils.isAsciiPrintable(""ab2c"")   = true
 * StringUtils.isAsciiPrintable(""!ab-c~"") = true
 * StringUtils.isAsciiPrintable(""\u0020"") = true
 * StringUtils.isAsciiPrintable(""\u0021"") = true
 * StringUtils.isAsciiPrintable(""\u007e"") = true
 * StringUtils.isAsciiPrintable(""\u007f"") = false
 * StringUtils.isAsciiPrintable(""Ceki G\u00fclc\u00fc"") = false
 * </pre>
 *
 * @param cs the CharSequence to check, may be null
 * @return {@code true} if every character is in the range
 *  32 thru 126
 * @since 2.1
 * @since 3.0 Changed signature from isAsciiPrintable(String) to isAsciiPrintable(CharSequence)
 */"
"public static boolean startsWithAny(CharSequence string, CharSequence... searchStrings) {
    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {
        return false;
    }
    for (int i = 0; i < searchStrings.length; i++) {
        CharSequence searchString = searchStrings[i];
        if (StringUtils.startsWith(string, searchString)) {
            return true;
        }
    }
    return false;
}","public void test264940() throws Throwable {
    String string0 = StringUtils.repeat(""AEp]<"", 772);
    String string1 = StringUtils.uncapitalize("",W)"");
    int int0 = StringUtils.lastIndexOf((CharSequence) string0, 772);
    boolean boolean0 = StringUtils.isAsciiPrintable(""AEp]<"");
    CharSequence[] charSequenceArray0 = new CharSequence[5];
    charSequenceArray0[0] = (CharSequence) ""AEp]<"";
    charSequenceArray0[1] = (CharSequence) string0;
    charSequenceArray0[2] = (CharSequence) "",W)"";
    charSequenceArray0[3] = (CharSequence) "",W)"";
    charSequenceArray0[4] = (CharSequence) "",W)"";
    boolean boolean1 = StringUtils.startsWithAny(string0, charSequenceArray0);
    assertEquals(5, charSequenceArray0.length);
}","/**
 * <p>Check if a CharSequence starts with any of an array of specified strings.</p>
 *
 * <pre>
 * StringUtils.startsWithAny(null, null)      = false
 * StringUtils.startsWithAny(null, new String[] {""abc""})  = false
 * StringUtils.startsWithAny(""abcxyz"", null)     = false
 * StringUtils.startsWithAny(""abcxyz"", new String[] {""""}) = false
 * StringUtils.startsWithAny(""abcxyz"", new String[] {""abc""}) = true
 * StringUtils.startsWithAny(""abcxyz"", new String[] {null, ""xyz"", ""abc""}) = true
 * </pre>
 *
 * @param string  the CharSequence to check, may be null
 * @param searchStrings the CharSequences to find, may be null or empty
 * @return {@code true} if the CharSequence starts with any of the the prefixes, case insensitive, or
 *  both {@code null}
 * @since 2.5
 * @since 3.0 Changed signature from startsWithAny(String, String[]) to startsWithAny(CharSequence, CharSequence...)
 */"
"public static String rightPad(String str, int size) {
    return rightPad(str, size, ' ');
}","public void test264944() throws Throwable {
    String string0 = StringUtils.repeat(""AEp]<"", 772);
    String string1 = StringUtils.uncapitalize("",W)"");
    int int0 = StringUtils.lastIndexOf((CharSequence) string0, 772);
    boolean boolean0 = StringUtils.isAsciiPrintable(""AEp]<"");
    CharSequence[] charSequenceArray0 = new CharSequence[5];
    charSequenceArray0[0] = (CharSequence) ""AEp]<"";
    charSequenceArray0[1] = (CharSequence) string0;
    charSequenceArray0[2] = (CharSequence) "",W)"";
    charSequenceArray0[3] = (CharSequence) "",W)"";
    charSequenceArray0[4] = (CharSequence) "",W)"";
    boolean boolean1 = StringUtils.startsWithAny(string0, charSequenceArray0);
    String string2 = StringUtils.rightPad("",W)"", 772);
    assertNotNull(string2);
}","/**
 * <p>Right pad a String with spaces (' ').</p>
 *
 * <p>The String is padded to the size of {@code size}.</p>
 *
 * <pre>
 * StringUtils.rightPad(null, *)   = null
 * StringUtils.rightPad("""", 3)     = ""   ""
 * StringUtils.rightPad(""bat"", 3)  = ""bat""
 * StringUtils.rightPad(""bat"", 5)  = ""bat  ""
 * StringUtils.rightPad(""bat"", 1)  = ""bat""
 * StringUtils.rightPad(""bat"", -1) = ""bat""
 * </pre>
 *
 * @param str  the String to pad out, may be null
 * @param size  the size to pad to
 * @return right padded String or original String if no padding is necessary,
 *  {@code null} if null String input
 */"
"// Substring
//-----------------------------------------------------------------------
/**
 * <p>Gets a substring from the specified String avoiding exceptions.</p>
 *
 * <p>A negative start position can be used to start {@code n}
 * characters from the end of the String.</p>
 *
 * <p>A {@code null} String will return {@code null}.
 * An empty ("""") String will return """".</p>
 *
 * <pre>
 * StringUtils.substring(null, *)   = null
 * StringUtils.substring("""", *)     = """"
 * StringUtils.substring(""abc"", 0)  = ""abc""
 * StringUtils.substring(""abc"", 2)  = ""c""
 * StringUtils.substring(""abc"", 4)  = """"
 * StringUtils.substring(""abc"", -2) = ""bc""
 * StringUtils.substring(""abc"", -4) = ""abc""
 * </pre>
 *
 * @param str  the String to get the substring from, may be null
 * @param start  the position to start from, negative means
 *  count back from the end of the String by this many characters
 * @return substring from start position, {@code null} if null String input
 */
public static String substring(String str, int start) {
    if (str == null) {
        return null;
    }
    // handle negatives, which means last n characters
    if (start < 0) {
        // remember start is negative
        start = str.length() + start;
    }
    if (start < 0) {
        start = 0;
    }
    if (start > str.length()) {
        return EMPTY;
    }
    return str.substring(start);
}","public void test264948() throws Throwable {
    String string0 = StringUtils.repeat(""AEp]<"", 772);
    String string1 = StringUtils.uncapitalize("",W)"");
    int int0 = StringUtils.lastIndexOf((CharSequence) string0, 772);
    boolean boolean0 = StringUtils.isAsciiPrintable(""AEp]<"");
    CharSequence[] charSequenceArray0 = new CharSequence[5];
    charSequenceArray0[0] = (CharSequence) ""AEp]<"";
    charSequenceArray0[1] = (CharSequence) string0;
    charSequenceArray0[2] = (CharSequence) "",W)"";
    charSequenceArray0[3] = (CharSequence) "",W)"";
    charSequenceArray0[4] = (CharSequence) "",W)"";
    boolean boolean1 = StringUtils.startsWithAny(string0, charSequenceArray0);
    String string2 = StringUtils.rightPad("",W)"", 772);
    String string3 = StringUtils.substring("",W)"", 772);
    assertNotNull(string3);
}",""
"public static String join(Iterator<?> iterator, char separator) {
    // handle null, zero and one elements before building a buffer
    if (iterator == null) {
        return null;
    }
    if (!iterator.hasNext()) {
        return EMPTY;
    }
    Object first = iterator.next();
    if (!iterator.hasNext()) {
        return ObjectUtils.toString(first);
    }
    // two or more elements
    // Java default is 16, probably too small
    StringBuilder buf = new StringBuilder(256);
    if (first != null) {
        buf.append(first);
    }
    while (iterator.hasNext()) {
        buf.append(separator);
        Object obj = iterator.next();
        if (obj != null) {
            buf.append(obj);
        }
    }
    return buf.toString();
}","public void test265960() throws Throwable {
    Class<Object> class0 = Object.class;
    ServiceLoader<Object> serviceLoader0 = ServiceLoader.load(class0, (ClassLoader) null);
    Iterator<Object> iterator0 = serviceLoader0.iterator();
    Class<Locale.FilteringMode> class1 = Locale.FilteringMode.class;
    ServiceLoader<Locale.FilteringMode> serviceLoader1 = ServiceLoader.load(class1);
    String string0 = StringUtils.join(iterator0, 'g');
    assertNotNull(string0);
}","/**
 * <p>Joins the elements of the provided {@code Iterator} into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list. Null objects or empty
 * strings within the iteration are represented by empty strings.</p>
 *
 * <p>See the examples here: {@link #join(Object[],char)}. </p>
 *
 * @param iterator  the {@code Iterator} of values to join together, may be null
 * @param separator  the separator character to use
 * @return the joined String, {@code null} if null iterator input
 * @since 2.0
 */"
"public static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    return lastIndexOfIgnoreCase(str, searchStr, str.length());
}","public void test265962() throws Throwable {
    Class<Object> class0 = Object.class;
    ServiceLoader<Object> serviceLoader0 = ServiceLoader.load(class0, (ClassLoader) null);
    Iterator<Object> iterator0 = serviceLoader0.iterator();
    Class<Locale.FilteringMode> class1 = Locale.FilteringMode.class;
    ServiceLoader<Locale.FilteringMode> serviceLoader1 = ServiceLoader.load(class1);
    String string0 = StringUtils.join(iterator0, 'g');
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) """", (CharSequence) """");
    assertEquals(0, int0);
}","/**
 * <p>Case in-sensitive find of the last index within a CharSequence.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A negative start position returns {@code -1}.
 * An empty ("""") search CharSequence always matches unless the start position is negative.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOfIgnoreCase(null, *)          = -1
 * StringUtils.lastIndexOfIgnoreCase(*, null)          = -1
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""A"")  = 7
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"")  = 5
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""AB"") = 4
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @return the first index of the search CharSequence,
 *  -1 if no match or {@code null} string input
 * @since 2.5
 * @since 3.0 Changed signature from lastIndexOfIgnoreCase(String, String) to lastIndexOfIgnoreCase(CharSequence, CharSequence)
 */"
"public static boolean isAlphaSpace(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {
            return false;
        }
    }
    return true;
}","public void test265963() throws Throwable {
    Class<Object> class0 = Object.class;
    ServiceLoader<Object> serviceLoader0 = ServiceLoader.load(class0, (ClassLoader) null);
    Iterator<Object> iterator0 = serviceLoader0.iterator();
    Class<Locale.FilteringMode> class1 = Locale.FilteringMode.class;
    ServiceLoader<Locale.FilteringMode> serviceLoader1 = ServiceLoader.load(class1);
    String string0 = StringUtils.join(iterator0, 'g');
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) """", (CharSequence) """");
    boolean boolean0 = StringUtils.isAlphaSpace("""");
    assertTrue(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only unicode letters and
 * space (' ').</p>
 *
 * <p>{@code null} will return {@code false}
 * An empty CharSequence (length()=0) will return {@code true}.</p>
 *
 * <pre>
 * StringUtils.isAlphaSpace(null)   = false
 * StringUtils.isAlphaSpace("""")     = true
 * StringUtils.isAlphaSpace(""  "")   = true
 * StringUtils.isAlphaSpace(""abc"")  = true
 * StringUtils.isAlphaSpace(""ab c"") = true
 * StringUtils.isAlphaSpace(""ab2c"") = false
 * StringUtils.isAlphaSpace(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if only contains letters and space,
 *  and is non-null
 * @since 3.0 Changed signature from isAlphaSpace(String) to isAlphaSpace(CharSequence)
 */"
"public static boolean isAsciiPrintable(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test265964() throws Throwable {
    Class<Object> class0 = Object.class;
    ServiceLoader<Object> serviceLoader0 = ServiceLoader.load(class0, (ClassLoader) null);
    Iterator<Object> iterator0 = serviceLoader0.iterator();
    Class<Locale.FilteringMode> class1 = Locale.FilteringMode.class;
    ServiceLoader<Locale.FilteringMode> serviceLoader1 = ServiceLoader.load(class1);
    String string0 = StringUtils.join(iterator0, 'g');
    int int0 = StringUtils.lastIndexOfIgnoreCase((CharSequence) """", (CharSequence) """");
    boolean boolean0 = StringUtils.isAlphaSpace("""");
    boolean boolean1 = StringUtils.isAsciiPrintable("""");
    assertTrue(boolean1);
}","/**
 * <p>Checks if the CharSequence contains only ASCII printable characters.</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty CharSequence (length()=0) will return {@code true}.</p>
 *
 * <pre>
 * StringUtils.isAsciiPrintable(null)     = false
 * StringUtils.isAsciiPrintable("""")       = true
 * StringUtils.isAsciiPrintable("" "")      = true
 * StringUtils.isAsciiPrintable(""Ceki"")   = true
 * StringUtils.isAsciiPrintable(""ab2c"")   = true
 * StringUtils.isAsciiPrintable(""!ab-c~"") = true
 * StringUtils.isAsciiPrintable(""\u0020"") = true
 * StringUtils.isAsciiPrintable(""\u0021"") = true
 * StringUtils.isAsciiPrintable(""\u007e"") = true
 * StringUtils.isAsciiPrintable(""\u007f"") = false
 * StringUtils.isAsciiPrintable(""Ceki G\u00fclc\u00fc"") = false
 * </pre>
 *
 * @param cs the CharSequence to check, may be null
 * @return {@code true} if every character is in the range
 *  32 thru 126
 * @since 2.1
 * @since 3.0 Changed signature from isAsciiPrintable(String) to isAsciiPrintable(CharSequence)
 */"
"// Trim
//-----------------------------------------------------------------------
/**
 * <p>Removes control characters (char &lt;= 32) from both
 * ends of this String, handling {@code null} by returning
 * {@code null}.</p>
 *
 * <p>The String is trimmed using {@link String#trim()}.
 * Trim removes start and end characters &lt;= 32.
 * To strip whitespace use {@link #strip(String)}.</p>
 *
 * <p>To trim your choice of characters, use the
 * {@link #strip(String, String)} methods.</p>
 *
 * <pre>
 * StringUtils.trim(null)          = null
 * StringUtils.trim("""")            = """"
 * StringUtils.trim(""     "")       = """"
 * StringUtils.trim(""abc"")         = ""abc""
 * StringUtils.trim(""    abc    "") = ""abc""
 * </pre>
 *
 * @param str  the String to be trimmed, may be null
 * @return the trimmed string, {@code null} if null String input
 */
public static String trim(String str) {
    return str == null ? null : str.trim();
}","public void test266966() throws Throwable {
    String string0 = StringUtils.trim("""");
    assertNotNull(string0);
}",""
"public static String substringBetween(String str, String open, String close) {
    if (str == null || open == null || close == null) {
        return null;
    }
    int start = str.indexOf(open);
    if (start != INDEX_NOT_FOUND) {
        int end = str.indexOf(close, start + open.length());
        if (end != INDEX_NOT_FOUND) {
            return str.substring(start + open.length(), end);
        }
    }
    return null;
}","public void test266968() throws Throwable {
    String string0 = StringUtils.trim("""");
    String string1 = StringUtils.substringBetween("""", """", ""-Mas/?k{8$nl+"");
    assertNull(string1);
}","/**
 * <p>Gets the String that is nested in between two Strings.
 * Only the first match is returned.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} open/close returns {@code null} (no match).
 * An empty ("""") open and close returns an empty string.</p>
 *
 * <pre>
 * StringUtils.substringBetween(""wx[b]yz"", ""["", ""]"") = ""b""
 * StringUtils.substringBetween(null, *, *)          = null
 * StringUtils.substringBetween(*, null, *)          = null
 * StringUtils.substringBetween(*, *, null)          = null
 * StringUtils.substringBetween("""", """", """")          = """"
 * StringUtils.substringBetween("""", """", ""]"")         = null
 * StringUtils.substringBetween("""", ""["", ""]"")        = null
 * StringUtils.substringBetween(""yabcz"", """", """")     = """"
 * StringUtils.substringBetween(""yabcz"", ""y"", ""z"")   = ""abc""
 * StringUtils.substringBetween(""yabczyabcz"", ""y"", ""z"")   = ""abc""
 * </pre>
 *
 * @param str  the String containing the substring, may be null
 * @param open  the String before the substring, may be null
 * @param close  the String after the substring, may be null
 * @return the substring, {@code null} if no match
 * @since 2.0
 */"
"public static String getCommonPrefix(String... strs) {
    if (strs == null || strs.length == 0) {
        return EMPTY;
    }
    int smallestIndexOfDiff = indexOfDifference(strs);
    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {
        // all strings were identical
        if (strs[0] == null) {
            return EMPTY;
        }
        return strs[0];
    } else if (smallestIndexOfDiff == 0) {
        // there were no common initial characters
        return EMPTY;
    } else {
        // we found a common initial character sequence
        return strs[0].substring(0, smallestIndexOfDiff);
    }
}","public void test266969() throws Throwable {
    String string0 = StringUtils.trim("""");
    String string1 = StringUtils.substringBetween("""", """", ""-Mas/?k{8$nl+"");
    String[] stringArray0 = new String[1];
    stringArray0[0] = """";
    String string2 = StringUtils.getCommonPrefix(stringArray0);
    assertEquals(1, stringArray0.length);
}","/**
 * <p>Compares all Strings in an array and returns the initial sequence of
 * characters that is common to all of them.</p>
 *
 * <p>For example,
 * <code>getCommonPrefix(new String[] {""i am a machine"", ""i am a robot""}) -> ""i am a ""</code></p>
 *
 * <pre>
 * StringUtils.getCommonPrefix(null) = """"
 * StringUtils.getCommonPrefix(new String[] {}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc""}) = ""abc""
 * StringUtils.getCommonPrefix(new String[] {null, null}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", """"}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", null}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", null, null}) = """"
 * StringUtils.getCommonPrefix(new String[] {null, null, ""abc""}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", ""abc""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", """"}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", ""abc""}) = ""abc""
 * StringUtils.getCommonPrefix(new String[] {""abc"", ""a""}) = ""a""
 * StringUtils.getCommonPrefix(new String[] {""ab"", ""abxyz""}) = ""ab""
 * StringUtils.getCommonPrefix(new String[] {""abcde"", ""abxyz""}) = ""ab""
 * StringUtils.getCommonPrefix(new String[] {""abcde"", ""xyz""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""xyz"", ""abcde""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""i am a machine"", ""i am a robot""}) = ""i am a ""
 * </pre>
 *
 * @param strs  array of String objects, entries may be null
 * @return the initial sequence of characters that are common to all Strings
 * in the array; empty String if the array is null, the elements are all null
 * or if there is no common prefix.
 * @since 2.4
 */"
"public static boolean contains(CharSequence seq, CharSequence searchSeq) {
    if (seq == null || searchSeq == null) {
        return false;
    }
    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;
}","public void test266973() throws Throwable {
    String string0 = StringUtils.trim("""");
    String string1 = StringUtils.substringBetween("""", """", ""-Mas/?k{8$nl+"");
    String[] stringArray0 = new String[1];
    stringArray0[0] = """";
    String string2 = StringUtils.getCommonPrefix(stringArray0);
    boolean boolean0 = StringUtils.contains((CharSequence) """", (CharSequence) """");
    assertTrue(boolean0);
}","/**
 * <p>Checks if CharSequence contains a search CharSequence, handling {@code null}.
 * This method uses {@link String#indexOf(String)} if possible.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.contains(null, *)     = false
 * StringUtils.contains(*, null)     = false
 * StringUtils.contains("""", """")      = true
 * StringUtils.contains(""abc"", """")   = true
 * StringUtils.contains(""abc"", ""a"")  = true
 * StringUtils.contains(""abc"", ""z"")  = false
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchSeq  the CharSequence to find, may be null
 * @return true if the CharSequence contains the search CharSequence,
 *  false if not or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from contains(String, String) to contains(CharSequence, CharSequence)
 */"
"public static String right(String str, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0) {
        return EMPTY;
    }
    if (str.length() <= len) {
        return str;
    }
    return str.substring(str.length() - len);
}","public void test266974() throws Throwable {
    String string0 = StringUtils.trim("""");
    String string1 = StringUtils.substringBetween("""", """", ""-Mas/?k{8$nl+"");
    String[] stringArray0 = new String[1];
    stringArray0[0] = """";
    String string2 = StringUtils.getCommonPrefix(stringArray0);
    boolean boolean0 = StringUtils.contains((CharSequence) """", (CharSequence) """");
    String string3 = StringUtils.right("""", 13);
    assertNotNull(string3);
}","/**
 * <p>Gets the rightmost {@code len} characters of a String.</p>
 *
 * <p>If {@code len} characters are not available, or the String
 * is {@code null}, the String will be returned without an
 * an exception. An empty String is returned if len is negative.</p>
 *
 * <pre>
 * StringUtils.right(null, *)    = null
 * StringUtils.right(*, -ve)     = """"
 * StringUtils.right("""", *)      = """"
 * StringUtils.right(""abc"", 0)   = """"
 * StringUtils.right(""abc"", 2)   = ""bc""
 * StringUtils.right(""abc"", 4)   = ""abc""
 * </pre>
 *
 * @param str  the String to get the rightmost characters from, may be null
 * @param len  the length of the required String
 * @return the rightmost characters, {@code null} if null String input
 */"
"public static boolean isAllUpperCase(CharSequence cs) {
    if (cs == null || isEmpty(cs)) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isUpperCase(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test266978() throws Throwable {
    String string0 = StringUtils.trim("""");
    String string1 = StringUtils.substringBetween("""", """", ""-Mas/?k{8$nl+"");
    String[] stringArray0 = new String[1];
    stringArray0[0] = """";
    String string2 = StringUtils.getCommonPrefix(stringArray0);
    boolean boolean0 = StringUtils.contains((CharSequence) """", (CharSequence) """");
    String string3 = StringUtils.right("""", 13);
    boolean boolean1 = StringUtils.isAllUpperCase((CharSequence) null);
    assertFalse(boolean1);
}","/**
 * <p>Checks if the CharSequence contains only uppercase characters.</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty String (length()=0) will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.isAllUpperCase(null)   = false
 * StringUtils.isAllUpperCase("""")     = false
 * StringUtils.isAllUpperCase(""  "")   = false
 * StringUtils.isAllUpperCase(""ABC"")  = true
 * StringUtils.isAllUpperCase(""aBC"") = false
 * </pre>
 *
 * @param cs the CharSequence to check, may be null
 * @return {@code true} if only contains uppercase characters, and is non-null
 * @since 2.5
 * @since 3.0 Changed signature from isAllUpperCase(String) to isAllUpperCase(CharSequence)
 */"
"public static String join(Iterable<?> iterable, String separator) {
    if (iterable == null) {
        return null;
    }
    return join(iterable.iterator(), separator);
}","public void test266983() throws Throwable {
    String string0 = StringUtils.trim("""");
    String string1 = StringUtils.substringBetween("""", """", ""-Mas/?k{8$nl+"");
    String[] stringArray0 = new String[1];
    stringArray0[0] = """";
    String string2 = StringUtils.getCommonPrefix(stringArray0);
    boolean boolean0 = StringUtils.contains((CharSequence) """", (CharSequence) """");
    String string3 = StringUtils.right("""", 13);
    boolean boolean1 = StringUtils.isAllUpperCase((CharSequence) null);
    Class<String> class0 = String.class;
    ServiceLoader<String> serviceLoader0 = ServiceLoader.load(class0);
    String string4 = StringUtils.join((Iterable<?>) serviceLoader0, ""6Xri"");
    assertNotNull(string4);
}","/**
 * <p>Joins the elements of the provided {@code Iterable} into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A {@code null} separator is the same as an empty String ("""").</p>
 *
 * <p>See the examples here: {@link #join(Object[],String)}. </p>
 *
 * @param iterable  the {@code Iterable} providing the values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @return the joined String, {@code null} if null iterator input
 * @since 2.3
 */"
"public static String trimToNull(String str) {
    String ts = trim(str);
    return isEmpty(ts) ? null : ts;
}","public void test267988() throws Throwable {
    String string0 = StringUtils.trimToNull(""7A=bIz*i\""|3<sq3{"");
    assertNotNull(string0);
}","/**
 * <p>Removes control characters (char &lt;= 32) from both
 * ends of this String returning {@code null} if the String is
 * empty ("""") after the trim or if it is {@code null}.
 *
 * <p>The String is trimmed using {@link String#trim()}.
 * Trim removes start and end characters &lt;= 32.
 * To strip whitespace use {@link #stripToNull(String)}.</p>
 *
 * <pre>
 * StringUtils.trimToNull(null)          = null
 * StringUtils.trimToNull("""")            = null
 * StringUtils.trimToNull(""     "")       = null
 * StringUtils.trimToNull(""abc"")         = ""abc""
 * StringUtils.trimToNull(""    abc    "") = ""abc""
 * </pre>
 *
 * @param str  the String to be trimmed, may be null
 * @return the trimmed String,
 *  {@code null} if only chars &lt;= 32, empty or null String input
 * @since 2.0
 */"
"public static boolean isNotEmpty(CharSequence cs) {
    return !StringUtils.isEmpty(cs);
}","public void test267990() throws Throwable {
    String string0 = StringUtils.trimToNull(""7A=bIz*i\""|3<sq3{"");
    boolean boolean0 = StringUtils.isNotEmpty(""7A=bIz*i\""|3<sq3{"");
    assertTrue(boolean0);
}","/**
 * <p>Checks if a CharSequence is not empty ("""") and not null.</p>
 *
 * <pre>
 * StringUtils.isNotEmpty(null)      = false
 * StringUtils.isNotEmpty("""")        = false
 * StringUtils.isNotEmpty("" "")       = true
 * StringUtils.isNotEmpty(""bob"")     = true
 * StringUtils.isNotEmpty(""  bob  "") = true
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if the CharSequence is not empty and not null
 * @since 3.0 Changed signature from isNotEmpty(String) to isNotEmpty(CharSequence)
 */"
"public static int length(CharSequence cs) {
    return cs == null ? 0 : cs.length();
}","public void test267991() throws Throwable {
    String string0 = StringUtils.trimToNull(""7A=bIz*i\""|3<sq3{"");
    boolean boolean0 = StringUtils.isNotEmpty(""7A=bIz*i\""|3<sq3{"");
    int int0 = StringUtils.length(""7A=bIz*i\""|3<sq3{"");
    assertEquals(16, int0);
}","/**
 * Gets a CharSequence length or {@code 0} if the CharSequence is
 * {@code null}.
 *
 * @param cs
 *            a CharSequence or {@code null}
 * @return CharSequence length or {@code 0} if the CharSequence is
 *         {@code null}.
 * @since 2.4
 * @since 3.0 Changed signature from length(String) to length(CharSequence)
 */"
"public static String uncapitalize(String str) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    return new StringBuilder(strLen).append(Character.toLowerCase(str.charAt(0))).append(str.substring(1)).toString();
}","public void test267992() throws Throwable {
    String string0 = StringUtils.trimToNull(""7A=bIz*i\""|3<sq3{"");
    boolean boolean0 = StringUtils.isNotEmpty(""7A=bIz*i\""|3<sq3{"");
    int int0 = StringUtils.length(""7A=bIz*i\""|3<sq3{"");
    String string1 = StringUtils.uncapitalize(""7A=bIz*i\""|3<sq3{"");
    assertNotNull(string1);
}","/**
 * <p>Uncapitalizes a String changing the first letter to title case as
 * per {@link Character#toLowerCase(char)}. No other letters are changed.</p>
 *
 * <p>For a word based algorithm, see {@link org.apache.commons.lang3.text.WordUtils#uncapitalize(String)}.
 * A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.uncapitalize(null)  = null
 * StringUtils.uncapitalize("""")    = """"
 * StringUtils.uncapitalize(""Cat"") = ""cat""
 * StringUtils.uncapitalize(""CAT"") = ""cAT""
 * </pre>
 *
 * @param str the String to uncapitalize, may be null
 * @return the uncapitalized String, {@code null} if null String input
 * @see org.apache.commons.lang3.text.WordUtils#uncapitalize(String)
 * @see #capitalize(String)
 * @since 2.0
 */"
"// Misc
//-----------------------------------------------------------------------
/**
 * <p>Find the Levenshtein distance between two Strings.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>The previous implementation of the Levenshtein distance algorithm
 * was from <a href=""http://www.merriampark.com/ld.htm"">http://www.merriampark.com/ld.htm</a></p>
 *
 * <p>Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError
 * which can occur when my Java implementation is used with very large strings.<br>
 * This implementation of the Levenshtein distance algorithm
 * is from <a href=""http://www.merriampark.com/ldjava.htm"">http://www.merriampark.com/ldjava.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("""","""")               = 0
 * StringUtils.getLevenshteinDistance("""",""a"")              = 1
 * StringUtils.getLevenshteinDistance(""aaapppp"", """")       = 7
 * StringUtils.getLevenshteinDistance(""frog"", ""fog"")       = 1
 * StringUtils.getLevenshteinDistance(""fly"", ""ant"")        = 3
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""zzzzzzzz"") = 8
 * StringUtils.getLevenshteinDistance(""hello"", ""hallo"")    = 1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @return result distance
 * @throws IllegalArgumentException if either String input {@code null}
 * @since 3.0 Changed signature from getLevenshteinDistance(String, String) to
 * getLevenshteinDistance(CharSequence, CharSequence)
 */
public static int getLevenshteinDistance(CharSequence s, CharSequence t) {
    if (s == null || t == null) {
        throw new IllegalArgumentException(""Strings must not be null"");
    }
    /*
           The difference between this impl. and the previous is that, rather
           than creating and retaining a matrix of size s.length() + 1 by t.length() + 1,
           we maintain two single-dimensional arrays of length s.length() + 1.  The first, d,
           is the 'current working' distance array that maintains the newest distance cost
           counts as we iterate through the characters of String s.  Each time we increment
           the index of String t we are comparing, d is copied to p, the second int[].  Doing so
           allows us to retain the previous cost counts as required by the algorithm (taking
           the minimum of the cost count to the left, up one, and diagonally up and to the left
           of the current cost count being calculated).  (Note that the arrays aren't really
           copied anymore, just switched...this is clearly much better than cloning an array
           or doing a System.arraycopy() each time  through the outer loop.)

           Effectively, the difference between the two implementations is this one does not
           cause an out of memory condition when calculating the LD over two very large strings.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    if (n == 0) {
        return m;
    } else if (m == 0) {
        return n;
    }
    if (n > m) {
        // swap the input strings to consume less memory
        CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    //'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    //placeholder to assist in swapping p and d
    int[] _d;
    // indexes into strings s and t
    // iterates through s
    int i;
    // iterates through t
    int j;
    // jth character of t
    char t_j;
    // cost
    int cost;
    for (i = 0; i <= n; i++) {
        p[i] = i;
    }
    for (j = 1; j <= m; j++) {
        t_j = t.charAt(j - 1);
        d[0] = j;
        for (i = 1; i <= n; i++) {
            cost = s.charAt(i - 1) == t_j ? 0 : 1;
            // minimum of cell to the left+1, to the top+1, diagonally left and up +cost
            d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost);
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // our last action in the above loop was to switch d and p, so p now
    // actually has the most recent cost counts
    return p[n];
}","public void test267995() throws Throwable {
    String string0 = StringUtils.trimToNull(""7A=bIz*i\""|3<sq3{"");
    boolean boolean0 = StringUtils.isNotEmpty(""7A=bIz*i\""|3<sq3{"");
    int int0 = StringUtils.length(""7A=bIz*i\""|3<sq3{"");
    String string1 = StringUtils.uncapitalize(""7A=bIz*i\""|3<sq3{"");
    int int1 = StringUtils.getLevenshteinDistance((CharSequence) ""7A=bIz*i\""|3<sq3{"", (CharSequence) ""7A=bIz*i\""|3<sq3{"");
    assertEquals(0, int1);
}",""
"// Nested extraction
//-----------------------------------------------------------------------
// Splitting
//-----------------------------------------------------------------------
/**
 * <p>Splits the provided text into an array, using whitespace as the
 * separator.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as one separator.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.split(null)       = null
 * StringUtils.split("""")         = []
 * StringUtils.split(""abc def"")  = [""abc"", ""def""]
 * StringUtils.split(""abc  def"") = [""abc"", ""def""]
 * StringUtils.split("" abc "")    = [""abc""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @return an array of parsed Strings, {@code null} if null String input
 */
public static String[] split(String str) {
    return split(str, null, -1);
}","public void test267997() throws Throwable {
    String string0 = StringUtils.trimToNull(""7A=bIz*i\""|3<sq3{"");
    boolean boolean0 = StringUtils.isNotEmpty(""7A=bIz*i\""|3<sq3{"");
    int int0 = StringUtils.length(""7A=bIz*i\""|3<sq3{"");
    String string1 = StringUtils.uncapitalize(""7A=bIz*i\""|3<sq3{"");
    int int1 = StringUtils.getLevenshteinDistance((CharSequence) ""7A=bIz*i\""|3<sq3{"", (CharSequence) ""7A=bIz*i\""|3<sq3{"");
    String[] stringArray0 = StringUtils.split("""");
    assertEquals(0, stringArray0.length);
}",""
"// Replacing
//-----------------------------------------------------------------------
/**
 * <p>Replaces a String with another String inside a larger String, once.</p>
 *
 * <p>A {@code null} reference passed to this method is a no-op.</p>
 *
 * <pre>
 * StringUtils.replaceOnce(null, *, *)        = null
 * StringUtils.replaceOnce("""", *, *)          = """"
 * StringUtils.replaceOnce(""any"", null, *)    = ""any""
 * StringUtils.replaceOnce(""any"", *, null)    = ""any""
 * StringUtils.replaceOnce(""any"", """", *)      = ""any""
 * StringUtils.replaceOnce(""aba"", ""a"", null)  = ""aba""
 * StringUtils.replaceOnce(""aba"", ""a"", """")    = ""ba""
 * StringUtils.replaceOnce(""aba"", ""a"", ""z"")   = ""zba""
 * </pre>
 *
 * @see #replace(String text, String searchString, String replacement, int max)
 * @param text  text to search and replace in, may be null
 * @param searchString  the String to search for, may be null
 * @param replacement  the String to replace with, may be null
 * @return the text with any replacements processed,
 *  {@code null} if null String input
 */
public static String replaceOnce(String text, String searchString, String replacement) {
    return replace(text, searchString, replacement, 1);
}","public void test267999() throws Throwable {
    String string0 = StringUtils.trimToNull(""7A=bIz*i\""|3<sq3{"");
    boolean boolean0 = StringUtils.isNotEmpty(""7A=bIz*i\""|3<sq3{"");
    int int0 = StringUtils.length(""7A=bIz*i\""|3<sq3{"");
    String string1 = StringUtils.uncapitalize(""7A=bIz*i\""|3<sq3{"");
    int int1 = StringUtils.getLevenshteinDistance((CharSequence) ""7A=bIz*i\""|3<sq3{"", (CharSequence) ""7A=bIz*i\""|3<sq3{"");
    String[] stringArray0 = StringUtils.split("""");
    String string2 = StringUtils.replaceOnce("""", ""7A=bIz*i\""|3<sq3{"", ""yywr@HmQ^zjzmK"");
    assertNotNull(string2);
}",""
"public static String repeat(String str, String separator, int repeat) {
    if (str == null || separator == null) {
        return repeat(str, repeat);
    } else {
        // given that repeat(String, int) is quite optimized, better to rely on it than try and splice this into it
        String result = repeat(str + separator, repeat);
        return removeEnd(result, separator);
    }
}","public void test2671003() throws Throwable {
    String string0 = StringUtils.trimToNull(""7A=bIz*i\""|3<sq3{"");
    boolean boolean0 = StringUtils.isNotEmpty(""7A=bIz*i\""|3<sq3{"");
    int int0 = StringUtils.length(""7A=bIz*i\""|3<sq3{"");
    String string1 = StringUtils.uncapitalize(""7A=bIz*i\""|3<sq3{"");
    int int1 = StringUtils.getLevenshteinDistance((CharSequence) ""7A=bIz*i\""|3<sq3{"", (CharSequence) ""7A=bIz*i\""|3<sq3{"");
    String[] stringArray0 = StringUtils.split("""");
    String string2 = StringUtils.replaceOnce("""", ""7A=bIz*i\""|3<sq3{"", ""yywr@HmQ^zjzmK"");
    String string3 = StringUtils.repeat(""xHg=S@Dq79^}1"", ""xHg=S@Dq79^}1"", 0);
    assertNotNull(string3);
}","/**
 * <p>Repeat a String {@code repeat} times to form a
 * new String, with a String separator injected each time. </p>
 *
 * <pre>
 * StringUtils.repeat(null, null, 2) = null
 * StringUtils.repeat(null, ""x"", 2)  = null
 * StringUtils.repeat("""", null, 0)   = """"
 * StringUtils.repeat("""", """", 2)     = """"
 * StringUtils.repeat("""", ""x"", 3)    = ""xxx""
 * StringUtils.repeat(""?"", "", "", 3)  = ""?, ?, ?""
 * </pre>
 *
 * @param str        the String to repeat, may be null
 * @param separator  the String to inject, may be null
 * @param repeat     number of times to repeat str, negative treated as zero
 * @return a new String consisting of the original String repeated,
 *  {@code null} if null String input
 * @since 2.5
 */"
"public static String join(Object[] array, char separator, int startIndex, int endIndex) {
    if (array == null) {
        return null;
    }
    int noOfItems = (endIndex - startIndex);
    if (noOfItems <= 0) {
        return EMPTY;
    }
    StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}","public void test2671008() throws Throwable {
    String string0 = StringUtils.trimToNull(""7A=bIz*i\""|3<sq3{"");
    boolean boolean0 = StringUtils.isNotEmpty(""7A=bIz*i\""|3<sq3{"");
    int int0 = StringUtils.length(""7A=bIz*i\""|3<sq3{"");
    String string1 = StringUtils.uncapitalize(""7A=bIz*i\""|3<sq3{"");
    int int1 = StringUtils.getLevenshteinDistance((CharSequence) ""7A=bIz*i\""|3<sq3{"", (CharSequence) ""7A=bIz*i\""|3<sq3{"");
    String[] stringArray0 = StringUtils.split("""");
    String string2 = StringUtils.replaceOnce("""", ""7A=bIz*i\""|3<sq3{"", ""yywr@HmQ^zjzmK"");
    String string3 = StringUtils.repeat(""xHg=S@Dq79^}1"", ""xHg=S@Dq79^}1"", 0);
    int int2 = (-764);
    // Undeclared exception!
    try {
        StringUtils.join((Object[]) stringArray0, 'T', (-764), 17);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // -764
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)               = null
 * StringUtils.join([], *)                 = """"
 * StringUtils.join([null], *)             = """"
 * StringUtils.join([""a"", ""b"", ""c""], ';')  = ""a;b;c""
 * StringUtils.join([""a"", ""b"", ""c""], null) = ""abc""
 * StringUtils.join([null, """", ""a""], ';')  = "";;a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use
 * @param startIndex the first index to start joining from.  It is
 * an error to pass in an end index past the end of the array
 * @param endIndex the index to stop joining from (exclusive). It is
 * an error to pass in an end index past the end of the array
 * @return the joined String, {@code null} if null array input
 * @since 2.0
 */"
"public static String substringBeforeLast(String str, String separator) {
    if (isEmpty(str) || isEmpty(separator)) {
        return str;
    }
    int pos = str.lastIndexOf(separator);
    if (pos == INDEX_NOT_FOUND) {
        return str;
    }
    return str.substring(0, pos);
}","public void test2681009() throws Throwable {
    String string0 = StringUtils.substringBeforeLast("""", """");
    assertNotNull(string0);
}","/**
 * <p>Gets the substring before the last occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A {@code null} string input will return {@code null}.
 * An empty ("""") string input will return the empty string.
 * An empty or {@code null} separator will return the input string.</p>
 *
 * <p>If nothing is found, the string input is returned.</p>
 *
 * <pre>
 * StringUtils.substringBeforeLast(null, *)      = null
 * StringUtils.substringBeforeLast("""", *)        = """"
 * StringUtils.substringBeforeLast(""abcba"", ""b"") = ""abc""
 * StringUtils.substringBeforeLast(""abc"", ""c"")   = ""ab""
 * StringUtils.substringBeforeLast(""a"", ""a"")     = """"
 * StringUtils.substringBeforeLast(""a"", ""z"")     = ""a""
 * StringUtils.substringBeforeLast(""a"", null)    = ""a""
 * StringUtils.substringBeforeLast(""a"", """")      = ""a""
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring before the last occurrence of the separator,
 *  {@code null} if null String input
 * @since 2.0
 */"
"// ContainsNone
//-----------------------------------------------------------------------
/**
 * <p>Checks that the CharSequence does not contain certain characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code true}.
 * A {@code null} invalid character array will return {@code true}.
 * An empty CharSequence (length()=0) always returns true.</p>
 *
 * <pre>
 * StringUtils.containsNone(null, *)       = true
 * StringUtils.containsNone(*, null)       = true
 * StringUtils.containsNone("""", *)         = true
 * StringUtils.containsNone(""ab"", '')      = true
 * StringUtils.containsNone(""abab"", 'xyz') = true
 * StringUtils.containsNone(""ab1"", 'xyz')  = true
 * StringUtils.containsNone(""abz"", 'xyz')  = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  an array of invalid chars, may be null
 * @return true if it contains none of the invalid chars, or is null
 * @since 2.0
 * @since 3.0 Changed signature from containsNone(String, char[]) to containsNone(CharSequence, char...)
 */
public static boolean containsNone(CharSequence cs, char... searchChars) {
    if (cs == null || searchChars == null) {
        return true;
    }
    int csLen = cs.length();
    int csLast = csLen - 1;
    int searchLen = searchChars.length;
    int searchLast = searchLen - 1;
    for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (Character.isHighSurrogate(ch)) {
                    if (j == searchLast) {
                        // missing low surrogate, fine, like String.indexOf(String)
                        return false;
                    }
                    if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
                        return false;
                    }
                } else {
                    // ch is in the Basic Multilingual Plane
                    return false;
                }
            }
        }
    }
    return true;
}","public void test2681011() throws Throwable {
    String string0 = StringUtils.substringBeforeLast("""", """");
    boolean boolean0 = StringUtils.containsNone((CharSequence) """", (char[]) null);
    assertTrue(boolean0);
}",""
"public static boolean endsWithAny(CharSequence string, CharSequence... searchStrings) {
    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {
        return false;
    }
    for (int i = 0; i < searchStrings.length; i++) {
        CharSequence searchString = searchStrings[i];
        if (StringUtils.endsWith(string, searchString)) {
            return true;
        }
    }
    return false;
}","public void test2681012() throws Throwable {
    String string0 = StringUtils.substringBeforeLast("""", """");
    boolean boolean0 = StringUtils.containsNone((CharSequence) """", (char[]) null);
    CharSequence[] charSequenceArray0 = new CharSequence[7];
    charSequenceArray0[0] = (CharSequence) """";
    charSequenceArray0[1] = (CharSequence) """";
    charSequenceArray0[2] = (CharSequence) """";
    charSequenceArray0[3] = (CharSequence) """";
    charSequenceArray0[4] = (CharSequence) """";
    charSequenceArray0[5] = (CharSequence) """";
    charSequenceArray0[6] = (CharSequence) """";
    boolean boolean1 = StringUtils.endsWithAny("""", charSequenceArray0);
    assertEquals(7, charSequenceArray0.length);
}","/**
 * <p>Check if a CharSequence ends with any of an array of specified strings.</p>
 *
 * <pre>
 * StringUtils.endsWithAny(null, null)      = false
 * StringUtils.endsWithAny(null, new String[] {""abc""})  = false
 * StringUtils.endsWithAny(""abcxyz"", null)     = false
 * StringUtils.endsWithAny(""abcxyz"", new String[] {""""}) = true
 * StringUtils.endsWithAny(""abcxyz"", new String[] {""xyz""}) = true
 * StringUtils.endsWithAny(""abcxyz"", new String[] {null, ""xyz"", ""abc""}) = true
 * </pre>
 *
 * @param string  the CharSequence to check, may be null
 * @param searchStrings the CharSequences to find, may be null or empty
 * @return {@code true} if the CharSequence ends with any of the the prefixes, case insensitive, or
 *  both {@code null}
 * @since 3.0
 */"
"public static String[] splitByCharacterTypeCamelCase(String str) {
    return splitByCharacterType(str, true);
}","public void test2681015() throws Throwable {
    String string0 = StringUtils.substringBeforeLast("""", """");
    boolean boolean0 = StringUtils.containsNone((CharSequence) """", (char[]) null);
    CharSequence[] charSequenceArray0 = new CharSequence[7];
    charSequenceArray0[0] = (CharSequence) """";
    charSequenceArray0[1] = (CharSequence) """";
    charSequenceArray0[2] = (CharSequence) """";
    charSequenceArray0[3] = (CharSequence) """";
    charSequenceArray0[4] = (CharSequence) """";
    charSequenceArray0[5] = (CharSequence) """";
    charSequenceArray0[6] = (CharSequence) """";
    boolean boolean1 = StringUtils.endsWithAny("""", charSequenceArray0);
    String[] stringArray0 = StringUtils.splitByCharacterTypeCamelCase("""");
    assertEquals(0, stringArray0.length);
}","/**
 * <p>Splits a String by Character type as returned by
 * {@code java.lang.Character.getType(char)}. Groups of contiguous
 * characters of the same type are returned as complete tokens, with the
 * following exception: the character of type
 * {@code Character.UPPERCASE_LETTER}, if any, immediately
 * preceding a token of type {@code Character.LOWERCASE_LETTER}
 * will belong to the following token rather than to the preceding, if any,
 * {@code Character.UPPERCASE_LETTER} token.
 * <pre>
 * StringUtils.splitByCharacterTypeCamelCase(null)         = null
 * StringUtils.splitByCharacterTypeCamelCase("""")           = []
 * StringUtils.splitByCharacterTypeCamelCase(""ab de fg"")   = [""ab"", "" "", ""de"", "" "", ""fg""]
 * StringUtils.splitByCharacterTypeCamelCase(""ab   de fg"") = [""ab"", ""   "", ""de"", "" "", ""fg""]
 * StringUtils.splitByCharacterTypeCamelCase(""ab:cd:ef"")   = [""ab"", "":"", ""cd"", "":"", ""ef""]
 * StringUtils.splitByCharacterTypeCamelCase(""number5"")    = [""number"", ""5""]
 * StringUtils.splitByCharacterTypeCamelCase(""fooBar"")     = [""foo"", ""Bar""]
 * StringUtils.splitByCharacterTypeCamelCase(""foo200Bar"")  = [""foo"", ""200"", ""Bar""]
 * StringUtils.splitByCharacterTypeCamelCase(""ASFRules"")   = [""ASF"", ""Rules""]
 * </pre>
 * @param str the String to split, may be {@code null}
 * @return an array of parsed Strings, {@code null} if null String input
 * @since 2.4
 */"
"public static String[] stripAll(String[] strs, String stripChars) {
    int strsLen;
    if (strs == null || (strsLen = strs.length) == 0) {
        return strs;
    }
    String[] newArr = new String[strsLen];
    for (int i = 0; i < strsLen; i++) {
        newArr[i] = strip(strs[i], stripChars);
    }
    return newArr;
}","public void test2681017() throws Throwable {
    String string0 = StringUtils.substringBeforeLast("""", """");
    boolean boolean0 = StringUtils.containsNone((CharSequence) """", (char[]) null);
    CharSequence[] charSequenceArray0 = new CharSequence[7];
    charSequenceArray0[0] = (CharSequence) """";
    charSequenceArray0[1] = (CharSequence) """";
    charSequenceArray0[2] = (CharSequence) """";
    charSequenceArray0[3] = (CharSequence) """";
    charSequenceArray0[4] = (CharSequence) """";
    charSequenceArray0[5] = (CharSequence) """";
    charSequenceArray0[6] = (CharSequence) """";
    boolean boolean1 = StringUtils.endsWithAny("""", charSequenceArray0);
    String[] stringArray0 = StringUtils.splitByCharacterTypeCamelCase("""");
    String[] stringArray1 = StringUtils.stripAll(stringArray0, ""org.apache.commons.lang3.ArrayUtils"");
    assertSame(stringArray0, stringArray1);
}","/**
 * <p>Strips any of a set of characters from the start and end of every
 * String in an array.</p>
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <p>A new array is returned each time, except for length zero.
 * A {@code null} array will return {@code null}.
 * An empty array will return itself.
 * A {@code null} array entry will be ignored.
 * A {@code null} stripChars will strip whitespace as defined by
 * {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripAll(null, *)                = null
 * StringUtils.stripAll([], *)                  = []
 * StringUtils.stripAll([""abc"", ""  abc""], null) = [""abc"", ""abc""]
 * StringUtils.stripAll([""abc  "", null], null)  = [""abc"", null]
 * StringUtils.stripAll([""abc  "", null], ""yz"")  = [""abc  "", null]
 * StringUtils.stripAll([""yabcz"", null], ""yz"")  = [""abc"", null]
 * </pre>
 *
 * @param strs  the array to remove characters from, may be null
 * @param stripChars  the characters to remove, null treated as whitespace
 * @return the stripped Strings, {@code null} if null array input
 */"
"public static String join(Object[] array, char separator) {
    if (array == null) {
        return null;
    }
    return join(array, separator, 0, array.length);
}","public void test2681023() throws Throwable {
    String string0 = StringUtils.substringBeforeLast("""", """");
    boolean boolean0 = StringUtils.containsNone((CharSequence) """", (char[]) null);
    CharSequence[] charSequenceArray0 = new CharSequence[7];
    charSequenceArray0[0] = (CharSequence) """";
    charSequenceArray0[1] = (CharSequence) """";
    charSequenceArray0[2] = (CharSequence) """";
    charSequenceArray0[3] = (CharSequence) """";
    charSequenceArray0[4] = (CharSequence) """";
    charSequenceArray0[5] = (CharSequence) """";
    charSequenceArray0[6] = (CharSequence) """";
    boolean boolean1 = StringUtils.endsWithAny("""", charSequenceArray0);
    String[] stringArray0 = StringUtils.splitByCharacterTypeCamelCase("""");
    String[] stringArray1 = StringUtils.stripAll(stringArray0, ""org.apache.commons.lang3.ArrayUtils"");
    Object[] objectArray0 = new Object[2];
    Object object0 = new Object();
    objectArray0[0] = object0;
    objectArray0[1] = (Object) """";
    String string1 = StringUtils.join(objectArray0, 'y');
    assertEquals(2, objectArray0.length);
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)               = null
 * StringUtils.join([], *)                 = """"
 * StringUtils.join([null], *)             = """"
 * StringUtils.join([""a"", ""b"", ""c""], ';')  = ""a;b;c""
 * StringUtils.join([""a"", ""b"", ""c""], null) = ""abc""
 * StringUtils.join([null, """", ""a""], ';')  = "";;a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use
 * @return the joined String, {@code null} if null array input
 * @since 2.0
 */"
"// Reversing
//-----------------------------------------------------------------------
/**
 * <p>Reverses a String as per {@link StringBuilder#reverse()}.</p>
 *
 * <p>A {@code null} String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.reverse(null)  = null
 * StringUtils.reverse("""")    = """"
 * StringUtils.reverse(""bat"") = ""tab""
 * </pre>
 *
 * @param str  the String to reverse, may be null
 * @return the reversed String, {@code null} if null String input
 */
public static String reverse(String str) {
    if (str == null) {
        return null;
    }
    return new StringBuilder(str).reverse().toString();
}","public void test2691026() throws Throwable {
    String string0 = StringUtils.reverse("""");
    assertNotNull(string0);
}",""
"public static int length(CharSequence cs) {
    return cs == null ? 0 : cs.length();
}","public void test2691028() throws Throwable {
    String string0 = StringUtils.reverse("""");
    int int0 = StringUtils.length("""");
    assertEquals(0, int0);
}","/**
 * Gets a CharSequence length or {@code 0} if the CharSequence is
 * {@code null}.
 *
 * @param cs
 *            a CharSequence or {@code null}
 * @return CharSequence length or {@code 0} if the CharSequence is
 *         {@code null}.
 * @since 2.4
 * @since 3.0 Changed signature from length(String) to length(CharSequence)
 */"
"// ContainsNone
//-----------------------------------------------------------------------
/**
 * <p>Checks that the CharSequence does not contain certain characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code true}.
 * A {@code null} invalid character array will return {@code true}.
 * An empty CharSequence (length()=0) always returns true.</p>
 *
 * <pre>
 * StringUtils.containsNone(null, *)       = true
 * StringUtils.containsNone(*, null)       = true
 * StringUtils.containsNone("""", *)         = true
 * StringUtils.containsNone(""ab"", '')      = true
 * StringUtils.containsNone(""abab"", 'xyz') = true
 * StringUtils.containsNone(""ab1"", 'xyz')  = true
 * StringUtils.containsNone(""abz"", 'xyz')  = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  an array of invalid chars, may be null
 * @return true if it contains none of the invalid chars, or is null
 * @since 2.0
 * @since 3.0 Changed signature from containsNone(String, char[]) to containsNone(CharSequence, char...)
 */
public static boolean containsNone(CharSequence cs, char... searchChars) {
    if (cs == null || searchChars == null) {
        return true;
    }
    int csLen = cs.length();
    int csLast = csLen - 1;
    int searchLen = searchChars.length;
    int searchLast = searchLen - 1;
    for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (Character.isHighSurrogate(ch)) {
                    if (j == searchLast) {
                        // missing low surrogate, fine, like String.indexOf(String)
                        return false;
                    }
                    if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
                        return false;
                    }
                } else {
                    // ch is in the Basic Multilingual Plane
                    return false;
                }
            }
        }
    }
    return true;
}","public void test2691029() throws Throwable {
    String string0 = StringUtils.reverse("""");
    int int0 = StringUtils.length("""");
    char[] charArray0 = new char[2];
    charArray0[0] = '-';
    charArray0[1] = ';';
    boolean boolean0 = StringUtils.containsNone((CharSequence) """", charArray0);
    assertEquals(2, charArray0.length);
}",""
"public static boolean isNumericSpace(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {
            return false;
        }
    }
    return true;
}","public void test2691032() throws Throwable {
    String string0 = StringUtils.reverse("""");
    int int0 = StringUtils.length("""");
    char[] charArray0 = new char[2];
    charArray0[0] = '-';
    charArray0[1] = ';';
    boolean boolean0 = StringUtils.containsNone((CharSequence) """", charArray0);
    boolean boolean1 = StringUtils.isNumericSpace("""");
    assertTrue(boolean1);
}","/**
 * <p>Checks if the CharSequence contains only unicode digits or space
 * ({@code ' '}).
 * A decimal point is not a unicode digit and returns false.</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty CharSequence (length()=0) will return {@code true}.</p>
 *
 * <pre>
 * StringUtils.isNumericSpace(null)   = false
 * StringUtils.isNumericSpace("""")     = true
 * StringUtils.isNumericSpace(""  "")   = true
 * StringUtils.isNumericSpace(""123"")  = true
 * StringUtils.isNumericSpace(""12 3"") = true
 * StringUtils.isNumericSpace(""ab2c"") = false
 * StringUtils.isNumericSpace(""12-3"") = false
 * StringUtils.isNumericSpace(""12.3"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if only contains digits or space,
 *  and is non-null
 * @since 3.0 Changed signature from isNumericSpace(String) to isNumericSpace(CharSequence)
 */"
"public static boolean isWhitespace(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if ((Character.isWhitespace(cs.charAt(i)) == false)) {
            return false;
        }
    }
    return true;
}","public void test2691034() throws Throwable {
    String string0 = StringUtils.reverse("""");
    int int0 = StringUtils.length("""");
    char[] charArray0 = new char[2];
    charArray0[0] = '-';
    charArray0[1] = ';';
    boolean boolean0 = StringUtils.containsNone((CharSequence) """", charArray0);
    boolean boolean1 = StringUtils.isNumericSpace("""");
    boolean boolean2 = StringUtils.isWhitespace("""");
    assertTrue(boolean2);
}","/**
 * <p>Checks if the CharSequence contains only whitespace.</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty CharSequence (length()=0) will return {@code true}.</p>
 *
 * <pre>
 * StringUtils.isWhitespace(null)   = false
 * StringUtils.isWhitespace("""")     = true
 * StringUtils.isWhitespace(""  "")   = true
 * StringUtils.isWhitespace(""abc"")  = false
 * StringUtils.isWhitespace(""ab2c"") = false
 * StringUtils.isWhitespace(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if only contains whitespace, and is non-null
 * @since 2.0
 * @since 3.0 Changed signature from isWhitespace(String) to isWhitespace(CharSequence)
 */"
"public static boolean equalsIgnoreCase(CharSequence str1, CharSequence str2) {
    if (str1 == null || str2 == null) {
        return str1 == str2;
    } else {
        return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, Math.max(str1.length(), str2.length()));
    }
}","public void test2691037() throws Throwable {
    String string0 = StringUtils.reverse("""");
    int int0 = StringUtils.length("""");
    char[] charArray0 = new char[2];
    charArray0[0] = '-';
    charArray0[1] = ';';
    boolean boolean0 = StringUtils.containsNone((CharSequence) """", charArray0);
    boolean boolean1 = StringUtils.isNumericSpace("""");
    boolean boolean2 = StringUtils.isWhitespace("""");
    boolean boolean3 = StringUtils.equalsIgnoreCase("""", """");
    assertTrue(boolean3);
}","/**
 * <p>Compares two CharSequences, returning {@code true} if they are equal ignoring
 * the case.</p>
 *
 * <p>{@code null}s are handled without exceptions. Two {@code null}
 * references are considered equal. Comparison is case insensitive.</p>
 *
 * <pre>
 * StringUtils.equalsIgnoreCase(null, null)   = true
 * StringUtils.equalsIgnoreCase(null, ""abc"")  = false
 * StringUtils.equalsIgnoreCase(""abc"", null)  = false
 * StringUtils.equalsIgnoreCase(""abc"", ""abc"") = true
 * StringUtils.equalsIgnoreCase(""abc"", ""ABC"") = true
 * </pre>
 *
 * @param str1  the first CharSequence, may be null
 * @param str2  the second CharSequence, may be null
 * @return {@code true} if the CharSequence are equal, case insensitive, or
 *  both {@code null}
 * @since 3.0 Changed signature from equalsIgnoreCase(String, String) to equalsIgnoreCase(CharSequence, CharSequence)
 */"
"public static String[] substringsBetween(String str, String open, String close) {
    if (str == null || isEmpty(open) || isEmpty(close)) {
        return null;
    }
    int strLen = str.length();
    if (strLen == 0) {
        return ArrayUtils.EMPTY_STRING_ARRAY;
    }
    int closeLen = close.length();
    int openLen = open.length();
    List<String> list = new ArrayList<String>();
    int pos = 0;
    while (pos < (strLen - closeLen)) {
        int start = str.indexOf(open, pos);
        if (start < 0) {
            break;
        }
        start += openLen;
        int end = str.indexOf(close, start);
        if (end < 0) {
            break;
        }
        list.add(str.substring(start, end));
        pos = end + closeLen;
    }
    if (list.isEmpty()) {
        return null;
    }
    return list.toArray(new String[list.size()]);
}","public void test2691041() throws Throwable {
    String string0 = StringUtils.reverse("""");
    int int0 = StringUtils.length("""");
    char[] charArray0 = new char[2];
    charArray0[0] = '-';
    charArray0[1] = ';';
    boolean boolean0 = StringUtils.containsNone((CharSequence) """", charArray0);
    boolean boolean1 = StringUtils.isNumericSpace("""");
    boolean boolean2 = StringUtils.isWhitespace("""");
    boolean boolean3 = StringUtils.equalsIgnoreCase("""", """");
    String[] stringArray0 = StringUtils.substringsBetween("""", """", (String) null);
    assertNull(stringArray0);
}","/**
 * <p>Searches a String for substrings delimited by a start and end tag,
 * returning all matching substrings in an array.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} open/close returns {@code null} (no match).
 * An empty ("""") open/close returns {@code null} (no match).</p>
 *
 * <pre>
 * StringUtils.substringsBetween(""[a][b][c]"", ""["", ""]"") = [""a"",""b"",""c""]
 * StringUtils.substringsBetween(null, *, *)            = null
 * StringUtils.substringsBetween(*, null, *)            = null
 * StringUtils.substringsBetween(*, *, null)            = null
 * StringUtils.substringsBetween("""", ""["", ""]"")          = []
 * </pre>
 *
 * @param str  the String containing the substrings, null returns null, empty returns empty
 * @param open  the String identifying the start of the substring, empty returns null
 * @param close  the String identifying the end of the substring, empty returns null
 * @return a String Array of substrings, or {@code null} if no match
 * @since 2.3
 */"
"public static String replace(String text, String searchString, String replacement) {
    return replace(text, searchString, replacement, -1);
}","public void test2691042() throws Throwable {
    String string0 = StringUtils.reverse("""");
    int int0 = StringUtils.length("""");
    char[] charArray0 = new char[2];
    charArray0[0] = '-';
    charArray0[1] = ';';
    boolean boolean0 = StringUtils.containsNone((CharSequence) """", charArray0);
    boolean boolean1 = StringUtils.isNumericSpace("""");
    boolean boolean2 = StringUtils.isWhitespace("""");
    boolean boolean3 = StringUtils.equalsIgnoreCase("""", """");
    String[] stringArray0 = StringUtils.substringsBetween("""", """", (String) null);
    String string1 = StringUtils.replace((String) null, """", """");
    assertNull(string1);
}","/**
 * <p>Replaces all occurrences of a String within another String.</p>
 *
 * <p>A {@code null} reference passed to this method is a no-op.</p>
 *
 * <pre>
 * StringUtils.replace(null, *, *)        = null
 * StringUtils.replace("""", *, *)          = """"
 * StringUtils.replace(""any"", null, *)    = ""any""
 * StringUtils.replace(""any"", *, null)    = ""any""
 * StringUtils.replace(""any"", """", *)      = ""any""
 * StringUtils.replace(""aba"", ""a"", null)  = ""aba""
 * StringUtils.replace(""aba"", ""a"", """")    = ""b""
 * StringUtils.replace(""aba"", ""a"", ""z"")   = ""zbz""
 * </pre>
 *
 * @see #replace(String text, String searchString, String replacement, int max)
 * @param text  text to search and replace in, may be null
 * @param searchString  the String to search for, may be null
 * @param replacement  the String to replace it with, may be null
 * @return the text with any replacements processed,
 *  {@code null} if null String input
 */"
"// -----------------------------------------------------------------------
/**
 * <p>Splits the provided text into an array, using whitespace as the
 * separator, preserving all tokens, including empty tokens created by
 * adjacent separators. This is an alternative to using StringTokenizer.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as separators for empty tokens.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.splitPreserveAllTokens(null)       = null
 * StringUtils.splitPreserveAllTokens("""")         = []
 * StringUtils.splitPreserveAllTokens(""abc def"")  = [""abc"", ""def""]
 * StringUtils.splitPreserveAllTokens(""abc  def"") = [""abc"", """", ""def""]
 * StringUtils.splitPreserveAllTokens("" abc "")    = ["""", ""abc"", """"]
 * </pre>
 *
 * @param str  the String to parse, may be {@code null}
 * @return an array of parsed Strings, {@code null} if null String input
 * @since 2.1
 */
public static String[] splitPreserveAllTokens(String str) {
    return splitWorker(str, null, -1, true);
}","public void test2701043() throws Throwable {
    String string0 = null;
    String[] stringArray0 = StringUtils.splitPreserveAllTokens((String) null);
    assertNull(stringArray0);
}",""
"public static boolean containsAny(CharSequence cs, CharSequence searchChars) {
    if (searchChars == null) {
        return false;
    }
    return containsAny(cs, CharSequenceUtils.toCharArray(searchChars));
}","public void test2701044() throws Throwable {
    String string0 = null;
    String[] stringArray0 = StringUtils.splitPreserveAllTokens((String) null);
    boolean boolean0 = StringUtils.containsAny((CharSequence) null, (CharSequence) null);
    assertFalse(boolean0);
}","/**
 * <p>
 * Checks if the CharSequence contains any character in the given set of characters.
 * </p>
 *
 * <p>
 * A {@code null} CharSequence will return {@code false}. A {@code null} search CharSequence will return
 * {@code false}.
 * </p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)            = false
 * StringUtils.containsAny("""", *)              = false
 * StringUtils.containsAny(*, null)            = false
 * StringUtils.containsAny(*, """")              = false
 * StringUtils.containsAny(""zzabyycdxx"", ""za"") = true
 * StringUtils.containsAny(""zzabyycdxx"", ""by"") = true
 * StringUtils.containsAny(""aba"",""z"")          = false
 * </pre>
 *
 * @param cs
 *            the CharSequence to check, may be null
 * @param searchChars
 *            the chars to search for, may be null
 * @return the {@code true} if any of the chars are found, {@code false} if no match or null input
 * @since 2.4
 * @since 3.0 Changed signature from containsAny(String, String) to containsAny(CharSequence, CharSequence)
 */"
"public static String abbreviate(String str, int offset, int maxWidth) {
    if (str == null) {
        return null;
    }
    if (maxWidth < 4) {
        throw new IllegalArgumentException(""Minimum abbreviation width is 4"");
    }
    if (str.length() <= maxWidth) {
        return str;
    }
    if (offset > str.length()) {
        offset = str.length();
    }
    if ((str.length() - offset) < (maxWidth - 3)) {
        offset = str.length() - (maxWidth - 3);
    }
    final String abrevMarker = ""..."";
    if (offset <= 4) {
        return str.substring(0, maxWidth - 3) + abrevMarker;
    }
    if (maxWidth < 7) {
        throw new IllegalArgumentException(""Minimum abbreviation width with offset is 7"");
    }
    if ((offset + (maxWidth - 3)) < str.length()) {
        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);
    }
    return abrevMarker + str.substring(str.length() - (maxWidth - 3));
}","public void test2701045() throws Throwable {
    String string0 = null;
    String[] stringArray0 = StringUtils.splitPreserveAllTokens((String) null);
    boolean boolean0 = StringUtils.containsAny((CharSequence) null, (CharSequence) null);
    String string1 = StringUtils.abbreviate((String) null, (-1245), 137);
    assertNull(string1);
}","/**
 * <p>Abbreviates a String using ellipses. This will turn
 * ""Now is the time for all good men"" into ""...is the time for...""</p>
 *
 * <p>Works like {@code abbreviate(String, int)}, but allows you to specify
 * a ""left edge"" offset.  Note that this left edge is not necessarily going to
 * be the leftmost character in the result, or the first character following the
 * ellipses, but it will appear somewhere in the result.
 *
 * <p>In no case will it return a String of length greater than
 * {@code maxWidth}.</p>
 *
 * <pre>
 * StringUtils.abbreviate(null, *, *)                = null
 * StringUtils.abbreviate("""", 0, 4)                  = """"
 * StringUtils.abbreviate(""abcdefghijklmno"", -1, 10) = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 0, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 1, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 4, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 5, 10)  = ""...fghi...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 6, 10)  = ""...ghij...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 8, 10)  = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghijklmno"", 10, 10) = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghijklmno"", 12, 10) = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghij"", 0, 3)        = IllegalArgumentException
 * StringUtils.abbreviate(""abcdefghij"", 5, 6)        = IllegalArgumentException
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param offset  left edge of source String
 * @param maxWidth  maximum length of result String, must be at least 4
 * @return abbreviated String, {@code null} if null String input
 * @throws IllegalArgumentException if the width is too small
 * @since 2.0
 */"
"public static boolean equalsIgnoreCase(CharSequence str1, CharSequence str2) {
    if (str1 == null || str2 == null) {
        return str1 == str2;
    } else {
        return CharSequenceUtils.regionMatches(str1, true, 0, str2, 0, Math.max(str1.length(), str2.length()));
    }
}","public void test2701046() throws Throwable {
    String string0 = null;
    String[] stringArray0 = StringUtils.splitPreserveAllTokens((String) null);
    boolean boolean0 = StringUtils.containsAny((CharSequence) null, (CharSequence) null);
    String string1 = StringUtils.abbreviate((String) null, (-1245), 137);
    boolean boolean1 = StringUtils.equalsIgnoreCase((CharSequence) null, (CharSequence) null);
    assertTrue(boolean1);
}","/**
 * <p>Compares two CharSequences, returning {@code true} if they are equal ignoring
 * the case.</p>
 *
 * <p>{@code null}s are handled without exceptions. Two {@code null}
 * references are considered equal. Comparison is case insensitive.</p>
 *
 * <pre>
 * StringUtils.equalsIgnoreCase(null, null)   = true
 * StringUtils.equalsIgnoreCase(null, ""abc"")  = false
 * StringUtils.equalsIgnoreCase(""abc"", null)  = false
 * StringUtils.equalsIgnoreCase(""abc"", ""abc"") = true
 * StringUtils.equalsIgnoreCase(""abc"", ""ABC"") = true
 * </pre>
 *
 * @param str1  the first CharSequence, may be null
 * @param str2  the second CharSequence, may be null
 * @return {@code true} if the CharSequence are equal, case insensitive, or
 *  both {@code null}
 * @since 3.0 Changed signature from equalsIgnoreCase(String, String) to equalsIgnoreCase(CharSequence, CharSequence)
 */"
"public static String rightPad(String str, int size) {
    return rightPad(str, size, ' ');
}","public void test2701048() throws Throwable {
    String string0 = null;
    String[] stringArray0 = StringUtils.splitPreserveAllTokens((String) null);
    boolean boolean0 = StringUtils.containsAny((CharSequence) null, (CharSequence) null);
    String string1 = StringUtils.abbreviate((String) null, (-1245), 137);
    boolean boolean1 = StringUtils.equalsIgnoreCase((CharSequence) null, (CharSequence) null);
    String string2 = StringUtils.rightPad((String) null, 137);
    assertNull(string2);
}","/**
 * <p>Right pad a String with spaces (' ').</p>
 *
 * <p>The String is padded to the size of {@code size}.</p>
 *
 * <pre>
 * StringUtils.rightPad(null, *)   = null
 * StringUtils.rightPad("""", 3)     = ""   ""
 * StringUtils.rightPad(""bat"", 3)  = ""bat""
 * StringUtils.rightPad(""bat"", 5)  = ""bat  ""
 * StringUtils.rightPad(""bat"", 1)  = ""bat""
 * StringUtils.rightPad(""bat"", -1) = ""bat""
 * </pre>
 *
 * @param str  the String to pad out, may be null
 * @param size  the size to pad to
 * @return right padded String or original String if no padding is necessary,
 *  {@code null} if null String input
 */"
"public static boolean isNumeric(CharSequence cs) {
    if (cs == null || cs.length() == 0) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isDigit(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test2701049() throws Throwable {
    String string0 = null;
    String[] stringArray0 = StringUtils.splitPreserveAllTokens((String) null);
    boolean boolean0 = StringUtils.containsAny((CharSequence) null, (CharSequence) null);
    String string1 = StringUtils.abbreviate((String) null, (-1245), 137);
    boolean boolean1 = StringUtils.equalsIgnoreCase((CharSequence) null, (CharSequence) null);
    String string2 = StringUtils.rightPad((String) null, 137);
    boolean boolean2 = StringUtils.isNumeric((CharSequence) null);
    assertFalse(boolean2);
}","/**
 * <p>Checks if the CharSequence contains only unicode digits.
 * A decimal point is not a unicode digit and returns false.</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty CharSequence (length()=0) will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.isNumeric(null)   = false
 * StringUtils.isNumeric("""")     = false
 * StringUtils.isNumeric(""  "")   = false
 * StringUtils.isNumeric(""123"")  = true
 * StringUtils.isNumeric(""12 3"") = false
 * StringUtils.isNumeric(""ab2c"") = false
 * StringUtils.isNumeric(""12-3"") = false
 * StringUtils.isNumeric(""12.3"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if only contains digits, and is non-null
 * @since 3.0 Changed signature from isNumeric(String) to isNumeric(CharSequence)
 * @since 3.0 Changed """" to return false and not true
 */"
"public static String removeEnd(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (str.endsWith(remove)) {
        return str.substring(0, str.length() - remove.length());
    }
    return str;
}","public void test2701052() throws Throwable {
    String string0 = null;
    String[] stringArray0 = StringUtils.splitPreserveAllTokens((String) null);
    boolean boolean0 = StringUtils.containsAny((CharSequence) null, (CharSequence) null);
    String string1 = StringUtils.abbreviate((String) null, (-1245), 137);
    boolean boolean1 = StringUtils.equalsIgnoreCase((CharSequence) null, (CharSequence) null);
    String string2 = StringUtils.rightPad((String) null, 137);
    boolean boolean2 = StringUtils.isNumeric((CharSequence) null);
    String string3 = "" in an array of "";
    String string4 = StringUtils.removeEnd(""Minimum abbreviation width with offset is 7"", "" in an array of "");
    assertNotNull(string4);
}","/**
 * <p>Removes a substring only if it is at the end of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("""") source string will return the empty string.
 * A {@code null} search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeEnd(null, *)      = null
 * StringUtils.removeEnd("""", *)        = """"
 * StringUtils.removeEnd(*, null)      = *
 * StringUtils.removeEnd(""www.domain.com"", "".com."")  = ""www.domain.com""
 * StringUtils.removeEnd(""www.domain.com"", "".com"")   = ""www.domain""
 * StringUtils.removeEnd(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeEnd(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for and remove, may be null
 * @return the substring with the string removed if found,
 *  {@code null} if null String input
 * @since 2.1
 */"
"public static String join(Object[] array, String separator, int startIndex, int endIndex) {
    if (array == null) {
        return null;
    }
    if (separator == null) {
        separator = EMPTY;
    }
    // endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))
    //           (Assuming that all Strings are roughly equally long)
    int noOfItems = (endIndex - startIndex);
    if (noOfItems <= 0) {
        return EMPTY;
    }
    StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}","public void test2701055() throws Throwable {
    String string0 = null;
    String[] stringArray0 = StringUtils.splitPreserveAllTokens((String) null);
    boolean boolean0 = StringUtils.containsAny((CharSequence) null, (CharSequence) null);
    String string1 = StringUtils.abbreviate((String) null, (-1245), 137);
    boolean boolean1 = StringUtils.equalsIgnoreCase((CharSequence) null, (CharSequence) null);
    String string2 = StringUtils.rightPad((String) null, 137);
    boolean boolean2 = StringUtils.isNumeric((CharSequence) null);
    String string3 = "" in an array of "";
    String string4 = StringUtils.removeEnd(""Minimum abbreviation width with offset is 7"", "" in an array of "");
    String string5 = StringUtils.join((Object[]) null, """", (-1245), (-2918));
    assertNull(string5);
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A {@code null} separator is the same as an empty String ("""").
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)                = null
 * StringUtils.join([], *)                  = """"
 * StringUtils.join([null], *)              = """"
 * StringUtils.join([""a"", ""b"", ""c""], ""--"")  = ""a--b--c""
 * StringUtils.join([""a"", ""b"", ""c""], null)  = ""abc""
 * StringUtils.join([""a"", ""b"", ""c""], """")    = ""abc""
 * StringUtils.join([null, """", ""a""], ',')   = "",,a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @param startIndex the first index to start joining from.  It is
 * an error to pass in an end index past the end of the array
 * @param endIndex the index to stop joining from (exclusive). It is
 * an error to pass in an end index past the end of the array
 * @return the joined String, {@code null} if null array input
 */"
"public static boolean isNumericSpace(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {
            return false;
        }
    }
    return true;
}","public void test2701056() throws Throwable {
    String string0 = null;
    String[] stringArray0 = StringUtils.splitPreserveAllTokens((String) null);
    boolean boolean0 = StringUtils.containsAny((CharSequence) null, (CharSequence) null);
    String string1 = StringUtils.abbreviate((String) null, (-1245), 137);
    boolean boolean1 = StringUtils.equalsIgnoreCase((CharSequence) null, (CharSequence) null);
    String string2 = StringUtils.rightPad((String) null, 137);
    boolean boolean2 = StringUtils.isNumeric((CharSequence) null);
    String string3 = "" in an array of "";
    String string4 = StringUtils.removeEnd(""Minimum abbreviation width with offset is 7"", "" in an array of "");
    String string5 = StringUtils.join((Object[]) null, """", (-1245), (-2918));
    boolean boolean3 = StringUtils.isNumericSpace("" in an array of "");
    assertFalse(boolean3);
}","/**
 * <p>Checks if the CharSequence contains only unicode digits or space
 * ({@code ' '}).
 * A decimal point is not a unicode digit and returns false.</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty CharSequence (length()=0) will return {@code true}.</p>
 *
 * <pre>
 * StringUtils.isNumericSpace(null)   = false
 * StringUtils.isNumericSpace("""")     = true
 * StringUtils.isNumericSpace(""  "")   = true
 * StringUtils.isNumericSpace(""123"")  = true
 * StringUtils.isNumericSpace(""12 3"") = true
 * StringUtils.isNumericSpace(""ab2c"") = false
 * StringUtils.isNumericSpace(""12-3"") = false
 * StringUtils.isNumericSpace(""12.3"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if only contains digits or space,
 *  and is non-null
 * @since 3.0 Changed signature from isNumericSpace(String) to isNumericSpace(CharSequence)
 */"
"public static String mid(String str, int pos, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0 || pos > str.length()) {
        return EMPTY;
    }
    if (pos < 0) {
        pos = 0;
    }
    if (str.length() <= (pos + len)) {
        return str.substring(pos);
    }
    return str.substring(pos, pos + len);
}","public void test2701060() throws Throwable {
    String string0 = null;
    String[] stringArray0 = StringUtils.splitPreserveAllTokens((String) null);
    boolean boolean0 = StringUtils.containsAny((CharSequence) null, (CharSequence) null);
    String string1 = StringUtils.abbreviate((String) null, (-1245), 137);
    boolean boolean1 = StringUtils.equalsIgnoreCase((CharSequence) null, (CharSequence) null);
    String string2 = StringUtils.rightPad((String) null, 137);
    boolean boolean2 = StringUtils.isNumeric((CharSequence) null);
    String string3 = "" in an array of "";
    String string4 = StringUtils.removeEnd(""Minimum abbreviation width with offset is 7"", "" in an array of "");
    String string5 = StringUtils.join((Object[]) null, """", (-1245), (-2918));
    boolean boolean3 = StringUtils.isNumericSpace("" in an array of "");
    String string6 = StringUtils.mid((String) null, 137, 8192);
    assertNull(string6);
}","/**
 * <p>Gets {@code len} characters from the middle of a String.</p>
 *
 * <p>If {@code len} characters are not available, the remainder
 * of the String will be returned without an exception. If the
 * String is {@code null}, {@code null} will be returned.
 * An empty String is returned if len is negative or exceeds the
 * length of {@code str}.</p>
 *
 * <pre>
 * StringUtils.mid(null, *, *)    = null
 * StringUtils.mid(*, *, -ve)     = """"
 * StringUtils.mid("""", 0, *)      = """"
 * StringUtils.mid(""abc"", 0, 2)   = ""ab""
 * StringUtils.mid(""abc"", 0, 4)   = ""abc""
 * StringUtils.mid(""abc"", 2, 4)   = ""c""
 * StringUtils.mid(""abc"", 4, 2)   = """"
 * StringUtils.mid(""abc"", -2, 2)  = ""ab""
 * </pre>
 *
 * @param str  the String to get the characters from, may be null
 * @param pos  the position to start from, negative treated as zero
 * @param len  the length of the required String
 * @return the middle characters, {@code null} if null String input
 */"
"public static int getLevenshteinDistance(CharSequence s, CharSequence t, int threshold) {
    if (s == null || t == null) {
        throw new IllegalArgumentException(""Strings must not be null"");
    }
    if (threshold < 0) {
        throw new IllegalArgumentException(""Threshold must not be negative"");
    }
    /*
        This implementation only computes the distance if it's less than or equal to the
        threshold value, returning -1 if it's greater.  The advantage is performance: unbounded
        distance is O(nm), but a bound of k allows us to reduce it to O(km) time by only 
        computing a diagonal stripe of width 2k + 1 of the cost table.
        It is also possible to use this to compute the unbounded Levenshtein distance by starting
        the threshold at 1 and doubling each time until the distance is found; this is O(dm), where
        d is the distance.
        
        One subtlety comes from needing to ignore entries on the border of our stripe
        eg.
        p[] = |#|#|#|*
        d[] =  *|#|#|#|
        We must ignore the entry to the left of the leftmost member
        We must ignore the entry above the rightmost member
        
        Another subtlety comes from our stripe running off the matrix if the strings aren't
        of the same size.  Since string s is always swapped to be the shorter of the two, 
        the stripe will always run off to the upper right instead of the lower left of the matrix.
        
        As a concrete example, suppose s is of length 5, t is of length 7, and our threshold is 1.
        In this case we're going to walk a stripe of length 3.  The matrix would look like so:
        
           1 2 3 4 5
        1 |#|#| | | |
        2 |#|#|#| | |
        3 | |#|#|#| |
        4 | | |#|#|#|
        5 | | | |#|#|
        6 | | | | |#|
        7 | | | | | |

        Note how the stripe leads off the table as there is no possible way to turn a string of length 5
        into one of length 7 in edit distance of 1.
        
        Additionally, this implementation decreases memory usage by using two 
        single-dimensional arrays and swapping them back and forth instead of allocating
        an entire n by m matrix.  This requires a few minor changes, such as immediately returning 
        when it's detected that the stripe has run off the matrix and initially filling the arrays with
        large values so that entries we don't compute are ignored.

        See Algorithms on Strings, Trees and Sequences by Dan Gusfield for some discussion.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    // if one string is empty, the edit distance is necessarily the length of the other
    if (n == 0) {
        return m <= threshold ? m : -1;
    } else if (m == 0) {
        return n <= threshold ? n : -1;
    }
    if (n > m) {
        // swap the two strings to consume less memory
        CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    // 'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    // placeholder to assist in swapping p and d
    int[] _d;
    // fill in starting table values
    int boundary = Math.min(n, threshold) + 1;
    for (int i = 0; i < boundary; i++) {
        p[i] = i;
    }
    // these fills ensure that the value above the rightmost entry of our
    // stripe will be ignored in following loop iterations
    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);
    Arrays.fill(d, Integer.MAX_VALUE);
    // iterates through t
    for (int j = 1; j <= m; j++) {
        // jth character of t
        char t_j = t.charAt(j - 1);
        d[0] = j;
        // compute stripe indices, constrain to array size
        int min = Math.max(1, j - threshold);
        int max = Math.min(n, j + threshold);
        // the stripe may lead off of the table if s and t are of different sizes
        if (min > max) {
            return -1;
        }
        // ignore entry left of leftmost
        if (min > 1) {
            d[min - 1] = Integer.MAX_VALUE;
        }
        // iterates through [min, max] in s
        for (int i = min; i <= max; i++) {
            if (s.charAt(i - 1) == t_j) {
                // diagonally left and up
                d[i] = p[i - 1];
            } else {
                // 1 + minimum of cell to the left, to the top, diagonally left and up
                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);
            }
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // if p[n] is greater than the threshold, there's no guarantee on it being the correct
    // distance
    if (p[n] <= threshold) {
        return p[n];
    } else {
        return -1;
    }
}","public void test2701061() throws Throwable {
    String string0 = null;
    String[] stringArray0 = StringUtils.splitPreserveAllTokens((String) null);
    boolean boolean0 = StringUtils.containsAny((CharSequence) null, (CharSequence) null);
    String string1 = StringUtils.abbreviate((String) null, (-1245), 137);
    boolean boolean1 = StringUtils.equalsIgnoreCase((CharSequence) null, (CharSequence) null);
    String string2 = StringUtils.rightPad((String) null, 137);
    boolean boolean2 = StringUtils.isNumeric((CharSequence) null);
    String string3 = "" in an array of "";
    String string4 = StringUtils.removeEnd(""Minimum abbreviation width with offset is 7"", "" in an array of "");
    String string5 = StringUtils.join((Object[]) null, """", (-1245), (-2918));
    boolean boolean3 = StringUtils.isNumericSpace("" in an array of "");
    String string6 = StringUtils.mid((String) null, 137, 8192);
    // Undeclared exception!
    try {
        StringUtils.getLevenshteinDistance((CharSequence) null, (CharSequence) "" in an array of "", 2276);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Strings must not be null
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}","/**
 * <p>Find the Levenshtein distance between two Strings if it's less than or equal to a given
 * threshold.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>This implementation follows from Algorithms on Strings, Trees and Sequences by Dan Gusfield
 * and Chas Emerick's implementation of the Levenshtein distance algorithm from
 * <a href=""http://www.merriampark.com/ld.htm"">http://www.merriampark.com/ld.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, *, -1)               = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("""","""", 0)               = 0
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 8)       = 7
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 7)       = 7
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 6))      = -1
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"", 7) = 7
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"", 6) = -1
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"", 7) = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"", 6) = -1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @param threshold the target threshold, must not be negative
 * @return result distance, or {@code -1} if the distance would be greater than the threshold
 * @throws IllegalArgumentException if either String input {@code null} or negative threshold
 */"
"// Reversing
//-----------------------------------------------------------------------
/**
 * <p>Reverses a String as per {@link StringBuilder#reverse()}.</p>
 *
 * <p>A {@code null} String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.reverse(null)  = null
 * StringUtils.reverse("""")    = """"
 * StringUtils.reverse(""bat"") = ""tab""
 * </pre>
 *
 * @param str  the String to reverse, may be null
 * @return the reversed String, {@code null} if null String input
 */
public static String reverse(String str) {
    if (str == null) {
        return null;
    }
    return new StringBuilder(str).reverse().toString();
}","public void test2711062() throws Throwable {
    String string0 = StringUtils.reverse(""s6)>fSxxyb"");
    assertNotNull(string0);
}",""
"public static boolean containsAny(CharSequence cs, CharSequence searchChars) {
    if (searchChars == null) {
        return false;
    }
    return containsAny(cs, CharSequenceUtils.toCharArray(searchChars));
}","public void test2711064() throws Throwable {
    String string0 = StringUtils.reverse(""s6)>fSxxyb"");
    boolean boolean0 = StringUtils.containsAny((CharSequence) ""s6)>fSxxyb"", (CharSequence) ""s6)>fSxxyb"");
    assertTrue(boolean0);
}","/**
 * <p>
 * Checks if the CharSequence contains any character in the given set of characters.
 * </p>
 *
 * <p>
 * A {@code null} CharSequence will return {@code false}. A {@code null} search CharSequence will return
 * {@code false}.
 * </p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)            = false
 * StringUtils.containsAny("""", *)              = false
 * StringUtils.containsAny(*, null)            = false
 * StringUtils.containsAny(*, """")              = false
 * StringUtils.containsAny(""zzabyycdxx"", ""za"") = true
 * StringUtils.containsAny(""zzabyycdxx"", ""by"") = true
 * StringUtils.containsAny(""aba"",""z"")          = false
 * </pre>
 *
 * @param cs
 *            the CharSequence to check, may be null
 * @param searchChars
 *            the chars to search for, may be null
 * @return the {@code true} if any of the chars are found, {@code false} if no match or null input
 * @since 2.4
 * @since 3.0 Changed signature from containsAny(String, String) to containsAny(CharSequence, CharSequence)
 */"
"public static String mid(String str, int pos, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0 || pos > str.length()) {
        return EMPTY;
    }
    if (pos < 0) {
        pos = 0;
    }
    if (str.length() <= (pos + len)) {
        return str.substring(pos);
    }
    return str.substring(pos, pos + len);
}","public void test2721065() throws Throwable {
    String string0 = StringUtils.mid((String) null, 66, 0);
    assertNull(string0);
}","/**
 * <p>Gets {@code len} characters from the middle of a String.</p>
 *
 * <p>If {@code len} characters are not available, the remainder
 * of the String will be returned without an exception. If the
 * String is {@code null}, {@code null} will be returned.
 * An empty String is returned if len is negative or exceeds the
 * length of {@code str}.</p>
 *
 * <pre>
 * StringUtils.mid(null, *, *)    = null
 * StringUtils.mid(*, *, -ve)     = """"
 * StringUtils.mid("""", 0, *)      = """"
 * StringUtils.mid(""abc"", 0, 2)   = ""ab""
 * StringUtils.mid(""abc"", 0, 4)   = ""abc""
 * StringUtils.mid(""abc"", 2, 4)   = ""c""
 * StringUtils.mid(""abc"", 4, 2)   = """"
 * StringUtils.mid(""abc"", -2, 2)  = ""ab""
 * </pre>
 *
 * @param str  the String to get the characters from, may be null
 * @param pos  the position to start from, negative treated as zero
 * @param len  the length of the required String
 * @return the middle characters, {@code null} if null String input
 */"
"// Stripping
//-----------------------------------------------------------------------
/**
 * <p>Strips whitespace from the start and end of a String.</p>
 *
 * <p>This is similar to {@link #trim(String)} but removes whitespace.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <p>A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.strip(null)     = null
 * StringUtils.strip("""")       = """"
 * StringUtils.strip(""   "")    = """"
 * StringUtils.strip(""abc"")    = ""abc""
 * StringUtils.strip(""  abc"")  = ""abc""
 * StringUtils.strip(""abc  "")  = ""abc""
 * StringUtils.strip("" abc "")  = ""abc""
 * StringUtils.strip("" ab c "") = ""ab c""
 * </pre>
 *
 * @param str  the String to remove whitespace from, may be null
 * @return the stripped String, {@code null} if null String input
 */
public static String strip(String str) {
    return strip(str, null);
}","public void test2721066() throws Throwable {
    String string0 = StringUtils.mid((String) null, 66, 0);
    String string1 = StringUtils.strip((String) null);
    assertNull(string1);
}",""
"// Trim
//-----------------------------------------------------------------------
/**
 * <p>Removes control characters (char &lt;= 32) from both
 * ends of this String, handling {@code null} by returning
 * {@code null}.</p>
 *
 * <p>The String is trimmed using {@link String#trim()}.
 * Trim removes start and end characters &lt;= 32.
 * To strip whitespace use {@link #strip(String)}.</p>
 *
 * <p>To trim your choice of characters, use the
 * {@link #strip(String, String)} methods.</p>
 *
 * <pre>
 * StringUtils.trim(null)          = null
 * StringUtils.trim("""")            = """"
 * StringUtils.trim(""     "")       = """"
 * StringUtils.trim(""abc"")         = ""abc""
 * StringUtils.trim(""    abc    "") = ""abc""
 * </pre>
 *
 * @param str  the String to be trimmed, may be null
 * @return the trimmed string, {@code null} if null String input
 */
public static String trim(String str) {
    return str == null ? null : str.trim();
}","public void test2721067() throws Throwable {
    String string0 = StringUtils.mid((String) null, 66, 0);
    String string1 = StringUtils.strip((String) null);
    String string2 = StringUtils.trim(""Tt]ldbHk|Gj!'"");
    assertNotNull(string2);
}",""
"public static <T extends CharSequence> T defaultIfBlank(T str, T defaultStr) {
    return StringUtils.isBlank(str) ? defaultStr : str;
}","public void test2721069() throws Throwable {
    String string0 = StringUtils.mid((String) null, 66, 0);
    String string1 = StringUtils.strip((String) null);
    String string2 = StringUtils.trim(""Tt]ldbHk|Gj!'"");
    String string3 = StringUtils.defaultIfBlank(""na|~#+%|r<*Jv]P`MO"", ""Ks5~eH|q"");
    assertNotNull(string3);
}","/**
 * <p>Returns either the passed in CharSequence, or if the CharSequence is
 * whitespace, empty ("""") or {@code null}, the value of {@code defaultStr}.</p>
 *
 * <pre>
 * StringUtils.defaultIfBlank(null, ""NULL"")  = ""NULL""
 * StringUtils.defaultIfBlank("""", ""NULL"")    = ""NULL""
 * StringUtils.defaultIfBlank("" "", ""NULL"")   = ""NULL""
 * StringUtils.defaultIfBlank(""bat"", ""NULL"") = ""bat""
 * StringUtils.defaultIfBlank("""", null)      = null
 * </pre>
 * @param <T> the specific kind of CharSequence
 * @param str the CharSequence to check, may be null
 * @param defaultStr  the default CharSequence to return
 *  if the input is whitespace, empty ("""") or {@code null}, may be null
 * @return the passed in CharSequence, or the default
 * @see StringUtils#defaultString(String, String)
 */"
"// LastIndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the last index within a CharSequence, handling {@code null}.
 * This method uses {@link String#lastIndexOf(int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("""") CharSequence will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.lastIndexOf(null, *)         = -1
 * StringUtils.lastIndexOf("""", *)           = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'a') = 7
 * StringUtils.lastIndexOf(""aabaabaa"", 'b') = 5
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @return the last index of the search character,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from lastIndexOf(String, int) to lastIndexOf(CharSequence, int)
 */
public static int lastIndexOf(CharSequence seq, int searchChar) {
    if (isEmpty(seq)) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.lastIndexOf(seq, searchChar, seq.length());
}","public void test2721072() throws Throwable {
    String string0 = StringUtils.mid((String) null, 66, 0);
    String string1 = StringUtils.strip((String) null);
    String string2 = StringUtils.trim(""Tt]ldbHk|Gj!'"");
    String string3 = StringUtils.defaultIfBlank(""na|~#+%|r<*Jv]P`MO"", ""Ks5~eH|q"");
    int int0 = StringUtils.lastIndexOf((CharSequence) ""na|~#+%|r<*Jv]P`MO"", 0);
    assertEquals((-1), int0);
}",""
"// Case conversion
//-----------------------------------------------------------------------
/**
 * <p>Converts a String to upper case as per {@link String#toUpperCase()}.</p>
 *
 * <p>A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.upperCase(null)  = null
 * StringUtils.upperCase("""")    = """"
 * StringUtils.upperCase(""aBc"") = ""ABC""
 * </pre>
 *
 * <p><strong>Note:</strong> As described in the documentation for {@link String#toUpperCase()},
 * the result of this method is affected by the current locale.
 * For platform-independent case transformations, the method {@link #lowerCase(String, Locale)}
 * should be used with a specific locale (e.g. {@link Locale#ENGLISH}).</p>
 *
 * @param str  the String to upper case, may be null
 * @return the upper cased String, {@code null} if null String input
 */
public static String upperCase(String str) {
    if (str == null) {
        return null;
    }
    return str.toUpperCase();
}","public void test2731073() throws Throwable {
    String string0 = StringUtils.upperCase(""{}"");
    assertNotNull(string0);
}",""
"public static boolean isNotEmpty(CharSequence cs) {
    return !StringUtils.isEmpty(cs);
}","public void test2731075() throws Throwable {
    String string0 = StringUtils.upperCase(""{}"");
    boolean boolean0 = StringUtils.isNotEmpty(""{}"");
    assertTrue(boolean0);
}","/**
 * <p>Checks if a CharSequence is not empty ("""") and not null.</p>
 *
 * <pre>
 * StringUtils.isNotEmpty(null)      = false
 * StringUtils.isNotEmpty("""")        = false
 * StringUtils.isNotEmpty("" "")       = true
 * StringUtils.isNotEmpty(""bob"")     = true
 * StringUtils.isNotEmpty(""  bob  "") = true
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if the CharSequence is not empty and not null
 * @since 3.0 Changed signature from isNotEmpty(String) to isNotEmpty(CharSequence)
 */"
"// Substring
//-----------------------------------------------------------------------
/**
 * <p>Gets a substring from the specified String avoiding exceptions.</p>
 *
 * <p>A negative start position can be used to start {@code n}
 * characters from the end of the String.</p>
 *
 * <p>A {@code null} String will return {@code null}.
 * An empty ("""") String will return """".</p>
 *
 * <pre>
 * StringUtils.substring(null, *)   = null
 * StringUtils.substring("""", *)     = """"
 * StringUtils.substring(""abc"", 0)  = ""abc""
 * StringUtils.substring(""abc"", 2)  = ""c""
 * StringUtils.substring(""abc"", 4)  = """"
 * StringUtils.substring(""abc"", -2) = ""bc""
 * StringUtils.substring(""abc"", -4) = ""abc""
 * </pre>
 *
 * @param str  the String to get the substring from, may be null
 * @param start  the position to start from, negative means
 *  count back from the end of the String by this many characters
 * @return substring from start position, {@code null} if null String input
 */
public static String substring(String str, int start) {
    if (str == null) {
        return null;
    }
    // handle negatives, which means last n characters
    if (start < 0) {
        // remember start is negative
        start = str.length() + start;
    }
    if (start < 0) {
        start = 0;
    }
    if (start > str.length()) {
        return EMPTY;
    }
    return str.substring(start);
}","public void test2731076() throws Throwable {
    String string0 = StringUtils.upperCase(""{}"");
    boolean boolean0 = StringUtils.isNotEmpty(""{}"");
    String string1 = StringUtils.substring(""{}"", 101);
    assertNotNull(string1);
}",""
"public static String right(String str, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0) {
        return EMPTY;
    }
    if (str.length() <= len) {
        return str;
    }
    return str.substring(str.length() - len);
}","public void test2731079() throws Throwable {
    String string0 = StringUtils.upperCase(""{}"");
    boolean boolean0 = StringUtils.isNotEmpty(""{}"");
    String string1 = StringUtils.substring(""{}"", 101);
    String string2 = StringUtils.right("""", 101);
    assertNotNull(string2);
}","/**
 * <p>Gets the rightmost {@code len} characters of a String.</p>
 *
 * <p>If {@code len} characters are not available, or the String
 * is {@code null}, the String will be returned without an
 * an exception. An empty String is returned if len is negative.</p>
 *
 * <pre>
 * StringUtils.right(null, *)    = null
 * StringUtils.right(*, -ve)     = """"
 * StringUtils.right("""", *)      = """"
 * StringUtils.right(""abc"", 0)   = """"
 * StringUtils.right(""abc"", 2)   = ""bc""
 * StringUtils.right(""abc"", 4)   = ""abc""
 * </pre>
 *
 * @param str  the String to get the rightmost characters from, may be null
 * @param len  the length of the required String
 * @return the rightmost characters, {@code null} if null String input
 */"
"// Remove
//-----------------------------------------------------------------------
/**
 * <p>Removes a substring only if it is at the begining of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("""") source string will return the empty string.
 * A {@code null} search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeStart(null, *)      = null
 * StringUtils.removeStart("""", *)        = """"
 * StringUtils.removeStart(*, null)      = *
 * StringUtils.removeStart(""www.domain.com"", ""www."")   = ""domain.com""
 * StringUtils.removeStart(""domain.com"", ""www."")       = ""domain.com""
 * StringUtils.removeStart(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeStart(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for and remove, may be null
 * @return the substring with the string removed if found,
 *  {@code null} if null String input
 * @since 2.1
 */
public static String removeStart(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (str.startsWith(remove)) {
        return str.substring(remove.length());
    }
    return str;
}","public void test2731083() throws Throwable {
    String string0 = StringUtils.upperCase(""{}"");
    boolean boolean0 = StringUtils.isNotEmpty(""{}"");
    String string1 = StringUtils.substring(""{}"", 101);
    String string2 = StringUtils.right("""", 101);
    CharSequence[] charSequenceArray0 = new CharSequence[6];
    charSequenceArray0[0] = (CharSequence) ""{}"";
    String string3 = StringUtils.removeStart(""Ty9(le[JyF'8FT#"", """");
    assertNotNull(string3);
}",""
"// IndexOfAny strings
//-----------------------------------------------------------------------
/**
 * <p>Find the first index of any of a set of potential substrings.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A {@code null} or zero length search array will return {@code -1}.
 * A {@code null} search array entry will be ignored, but a search
 * array containing """" will return {@code 0} if {@code str} is not
 * null. This method uses {@link String#indexOf(String)} if possible.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)                     = -1
 * StringUtils.indexOfAny(*, null)                     = -1
 * StringUtils.indexOfAny(*, [])                       = -1
 * StringUtils.indexOfAny(""zzabyycdxx"", [""ab"",""cd""])   = 2
 * StringUtils.indexOfAny(""zzabyycdxx"", [""cd"",""ab""])   = 2
 * StringUtils.indexOfAny(""zzabyycdxx"", [""mn"",""op""])   = -1
 * StringUtils.indexOfAny(""zzabyycdxx"", [""zab"",""aby""]) = 1
 * StringUtils.indexOfAny(""zzabyycdxx"", [""""])          = 0
 * StringUtils.indexOfAny("""", [""""])                    = 0
 * StringUtils.indexOfAny("""", [""a""])                   = -1
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStrs  the CharSequences to search for, may be null
 * @return the first index of any of the searchStrs in str, -1 if no match
 * @since 3.0 Changed signature from indexOfAny(String, String[]) to indexOfAny(CharSequence, CharSequence...)
 */
public static int indexOfAny(CharSequence str, CharSequence... searchStrs) {
    if (str == null || searchStrs == null) {
        return INDEX_NOT_FOUND;
    }
    int sz = searchStrs.length;
    // String's can't have a MAX_VALUEth index.
    int ret = Integer.MAX_VALUE;
    int tmp = 0;
    for (int i = 0; i < sz; i++) {
        CharSequence search = searchStrs[i];
        if (search == null) {
            continue;
        }
        tmp = CharSequenceUtils.indexOf(str, search, 0);
        if (tmp == INDEX_NOT_FOUND) {
            continue;
        }
        if (tmp < ret) {
            ret = tmp;
        }
    }
    return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret;
}","public void test2731088() throws Throwable {
    String string0 = StringUtils.upperCase(""{}"");
    boolean boolean0 = StringUtils.isNotEmpty(""{}"");
    String string1 = StringUtils.substring(""{}"", 101);
    String string2 = StringUtils.right("""", 101);
    CharSequence[] charSequenceArray0 = new CharSequence[6];
    charSequenceArray0[0] = (CharSequence) ""{}"";
    String string3 = StringUtils.removeStart(""Ty9(le[JyF'8FT#"", """");
    charSequenceArray0[1] = (CharSequence) ""Ty9(le[JyF'8FT#"";
    charSequenceArray0[2] = (CharSequence) """";
    charSequenceArray0[3] = (CharSequence) """";
    charSequenceArray0[4] = (CharSequence) ""{}"";
    charSequenceArray0[5] = (CharSequence) """";
    int int0 = StringUtils.indexOfAny((CharSequence) """", charSequenceArray0);
    assertEquals(6, charSequenceArray0.length);
}",""
"public static String join(Iterator<?> iterator, char separator) {
    // handle null, zero and one elements before building a buffer
    if (iterator == null) {
        return null;
    }
    if (!iterator.hasNext()) {
        return EMPTY;
    }
    Object first = iterator.next();
    if (!iterator.hasNext()) {
        return ObjectUtils.toString(first);
    }
    // two or more elements
    // Java default is 16, probably too small
    StringBuilder buf = new StringBuilder(256);
    if (first != null) {
        buf.append(first);
    }
    while (iterator.hasNext()) {
        buf.append(separator);
        Object obj = iterator.next();
        if (obj != null) {
            buf.append(obj);
        }
    }
    return buf.toString();
}","public void test2741100() throws Throwable {
    LinkedList<String> linkedList0 = new LinkedList<String>();
    ListIterator<String> listIterator0 = linkedList0.listIterator();
    String string0 = StringUtils.join((Iterator<?>) listIterator0, 'B');
    assertNotNull(string0);
}","/**
 * <p>Joins the elements of the provided {@code Iterator} into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list. Null objects or empty
 * strings within the iteration are represented by empty strings.</p>
 *
 * <p>See the examples here: {@link #join(Object[],char)}. </p>
 *
 * @param iterator  the {@code Iterator} of values to join together, may be null
 * @param separator  the separator character to use
 * @return the joined String, {@code null} if null iterator input
 * @since 2.0
 */"
"// Empty checks
//-----------------------------------------------------------------------
/**
 * <p>Checks if a CharSequence is empty ("""") or null.</p>
 *
 * <pre>
 * StringUtils.isEmpty(null)      = true
 * StringUtils.isEmpty("""")        = true
 * StringUtils.isEmpty("" "")       = false
 * StringUtils.isEmpty(""bob"")     = false
 * StringUtils.isEmpty(""  bob  "") = false
 * </pre>
 *
 * <p>NOTE: This method changed in Lang version 2.0.
 * It no longer trims the CharSequence.
 * That functionality is available in isBlank().</p>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if the CharSequence is empty or null
 * @since 3.0 Changed signature from isEmpty(String) to isEmpty(CharSequence)
 */
public static boolean isEmpty(CharSequence cs) {
    return cs == null || cs.length() == 0;
}","public void test2741102() throws Throwable {
    LinkedList<String> linkedList0 = new LinkedList<String>();
    ListIterator<String> listIterator0 = linkedList0.listIterator();
    String string0 = StringUtils.join((Iterator<?>) listIterator0, 'B');
    boolean boolean0 = StringUtils.isEmpty("""");
    assertTrue(boolean0);
}",""
"// IndexOfAny strings
//-----------------------------------------------------------------------
/**
 * <p>Find the first index of any of a set of potential substrings.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A {@code null} or zero length search array will return {@code -1}.
 * A {@code null} search array entry will be ignored, but a search
 * array containing """" will return {@code 0} if {@code str} is not
 * null. This method uses {@link String#indexOf(String)} if possible.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)                     = -1
 * StringUtils.indexOfAny(*, null)                     = -1
 * StringUtils.indexOfAny(*, [])                       = -1
 * StringUtils.indexOfAny(""zzabyycdxx"", [""ab"",""cd""])   = 2
 * StringUtils.indexOfAny(""zzabyycdxx"", [""cd"",""ab""])   = 2
 * StringUtils.indexOfAny(""zzabyycdxx"", [""mn"",""op""])   = -1
 * StringUtils.indexOfAny(""zzabyycdxx"", [""zab"",""aby""]) = 1
 * StringUtils.indexOfAny(""zzabyycdxx"", [""""])          = 0
 * StringUtils.indexOfAny("""", [""""])                    = 0
 * StringUtils.indexOfAny("""", [""a""])                   = -1
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStrs  the CharSequences to search for, may be null
 * @return the first index of any of the searchStrs in str, -1 if no match
 * @since 3.0 Changed signature from indexOfAny(String, String[]) to indexOfAny(CharSequence, CharSequence...)
 */
public static int indexOfAny(CharSequence str, CharSequence... searchStrs) {
    if (str == null || searchStrs == null) {
        return INDEX_NOT_FOUND;
    }
    int sz = searchStrs.length;
    // String's can't have a MAX_VALUEth index.
    int ret = Integer.MAX_VALUE;
    int tmp = 0;
    for (int i = 0; i < sz; i++) {
        CharSequence search = searchStrs[i];
        if (search == null) {
            continue;
        }
        tmp = CharSequenceUtils.indexOf(str, search, 0);
        if (tmp == INDEX_NOT_FOUND) {
            continue;
        }
        if (tmp < ret) {
            ret = tmp;
        }
    }
    return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret;
}","public void test2741103() throws Throwable {
    LinkedList<String> linkedList0 = new LinkedList<String>();
    ListIterator<String> listIterator0 = linkedList0.listIterator();
    String string0 = StringUtils.join((Iterator<?>) listIterator0, 'B');
    boolean boolean0 = StringUtils.isEmpty("""");
    CharSequence[] charSequenceArray0 = new CharSequence[2];
    charSequenceArray0[0] = (CharSequence) """";
    charSequenceArray0[1] = (CharSequence) """";
    int int0 = StringUtils.indexOfAny((CharSequence) """", charSequenceArray0);
    assertEquals(2, charSequenceArray0.length);
}",""
"// Replacing
//-----------------------------------------------------------------------
/**
 * <p>Replaces a String with another String inside a larger String, once.</p>
 *
 * <p>A {@code null} reference passed to this method is a no-op.</p>
 *
 * <pre>
 * StringUtils.replaceOnce(null, *, *)        = null
 * StringUtils.replaceOnce("""", *, *)          = """"
 * StringUtils.replaceOnce(""any"", null, *)    = ""any""
 * StringUtils.replaceOnce(""any"", *, null)    = ""any""
 * StringUtils.replaceOnce(""any"", """", *)      = ""any""
 * StringUtils.replaceOnce(""aba"", ""a"", null)  = ""aba""
 * StringUtils.replaceOnce(""aba"", ""a"", """")    = ""ba""
 * StringUtils.replaceOnce(""aba"", ""a"", ""z"")   = ""zba""
 * </pre>
 *
 * @see #replace(String text, String searchString, String replacement, int max)
 * @param text  text to search and replace in, may be null
 * @param searchString  the String to search for, may be null
 * @param replacement  the String to replace with, may be null
 * @return the text with any replacements processed,
 *  {@code null} if null String input
 */
public static String replaceOnce(String text, String searchString, String replacement) {
    return replace(text, searchString, replacement, 1);
}","public void test2751105() throws Throwable {
    String string0 = StringUtils.replaceOnce(""IllegalArgumentException occurred"", ""IllegalArgumentException occurred"", ""IllegalArgumentException occurred"");
    assertNotNull(string0);
}",""
"// Contains
//-----------------------------------------------------------------------
/**
 * <p>Checks if CharSequence contains a search character, handling {@code null}.
 * This method uses {@link String#indexOf(int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("""") CharSequence will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.contains(null, *)    = false
 * StringUtils.contains("""", *)      = false
 * StringUtils.contains(""abc"", 'a') = true
 * StringUtils.contains(""abc"", 'z') = false
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @return true if the CharSequence contains the search character,
 *  false if not or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from contains(String, int) to contains(CharSequence, int)
 */
public static boolean contains(CharSequence seq, int searchChar) {
    if (isEmpty(seq)) {
        return false;
    }
    return CharSequenceUtils.indexOf(seq, searchChar, 0) >= 0;
}","public void test2751107() throws Throwable {
    String string0 = StringUtils.replaceOnce(""IllegalArgumentException occurred"", ""IllegalArgumentException occurred"", ""IllegalArgumentException occurred"");
    boolean boolean0 = StringUtils.contains((CharSequence) ""IllegalArgumentException occurred"", 179);
    assertFalse(boolean0);
}",""
"public static String[] splitByWholeSeparator(String str, String separator) {
    return splitByWholeSeparatorWorker(str, separator, -1, false);
}","public void test2751108() throws Throwable {
    String string0 = StringUtils.replaceOnce(""IllegalArgumentException occurred"", ""IllegalArgumentException occurred"", ""IllegalArgumentException occurred"");
    boolean boolean0 = StringUtils.contains((CharSequence) ""IllegalArgumentException occurred"", 179);
    String[] stringArray0 = StringUtils.splitByWholeSeparator(""IllegalArgumentException occurred"", ""IllegalArgumentException occurred"");
    assertEquals(1, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array, separator string specified.</p>
 *
 * <p>The separator(s) will not be included in the returned String array.
 * Adjacent separators are treated as one separator.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} separator splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.splitByWholeSeparator(null, *)               = null
 * StringUtils.splitByWholeSeparator("""", *)                 = []
 * StringUtils.splitByWholeSeparator(""ab de fg"", null)      = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparator(""ab   de fg"", null)    = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparator(""ab:cd:ef"", "":"")       = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitByWholeSeparator(""ab-!-cd-!-ef"", ""-!-"") = [""ab"", ""cd"", ""ef""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @param separator  String containing the String to be used as a delimiter,
 *  {@code null} splits on whitespace
 * @return an array of parsed Strings, {@code null} if null String was input
 */"
"public static String reverseDelimited(String str, char separatorChar) {
    if (str == null) {
        return null;
    }
    // could implement manually, but simple way is to reuse other,
    // probably slower, methods.
    String[] strs = split(str, separatorChar);
    ArrayUtils.reverse(strs);
    return join(strs, separatorChar);
}","public void test2751110() throws Throwable {
    String string0 = StringUtils.replaceOnce(""IllegalArgumentException occurred"", ""IllegalArgumentException occurred"", ""IllegalArgumentException occurred"");
    boolean boolean0 = StringUtils.contains((CharSequence) ""IllegalArgumentException occurred"", 179);
    String[] stringArray0 = StringUtils.splitByWholeSeparator(""IllegalArgumentException occurred"", ""IllegalArgumentException occurred"");
    String string1 = StringUtils.reverseDelimited("""", 'Q');
    assertNotNull(string1);
}","/**
 * <p>Reverses a String that is delimited by a specific character.</p>
 *
 * <p>The Strings between the delimiters are not reversed.
 * Thus java.lang.String becomes String.lang.java (if the delimiter
 * is {@code '.'}).</p>
 *
 * <pre>
 * StringUtils.reverseDelimited(null, *)      = null
 * StringUtils.reverseDelimited("""", *)        = """"
 * StringUtils.reverseDelimited(""a.b.c"", 'x') = ""a.b.c""
 * StringUtils.reverseDelimited(""a.b.c"", ""."") = ""c.b.a""
 * </pre>
 *
 * @param str  the String to reverse, may be null
 * @param separatorChar  the separator character to use
 * @return the reversed String, {@code null} if null String input
 * @since 2.0
 */"
"public static boolean isNotEmpty(CharSequence cs) {
    return !StringUtils.isEmpty(cs);
}","public void test2751113() throws Throwable {
    String string0 = StringUtils.replaceOnce(""IllegalArgumentException occurred"", ""IllegalArgumentException occurred"", ""IllegalArgumentException occurred"");
    boolean boolean0 = StringUtils.contains((CharSequence) ""IllegalArgumentException occurred"", 179);
    String[] stringArray0 = StringUtils.splitByWholeSeparator(""IllegalArgumentException occurred"", ""IllegalArgumentException occurred"");
    String string1 = StringUtils.reverseDelimited("""", 'Q');
    boolean boolean1 = StringUtils.isNotEmpty(""IllegalArgumentException occurred"");
    assertTrue(boolean1);
}","/**
 * <p>Checks if a CharSequence is not empty ("""") and not null.</p>
 *
 * <pre>
 * StringUtils.isNotEmpty(null)      = false
 * StringUtils.isNotEmpty("""")        = false
 * StringUtils.isNotEmpty("" "")       = true
 * StringUtils.isNotEmpty(""bob"")     = true
 * StringUtils.isNotEmpty(""  bob  "") = true
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if the CharSequence is not empty and not null
 * @since 3.0 Changed signature from isNotEmpty(String) to isNotEmpty(CharSequence)
 */"
"public static String stripEnd(String str, String stripChars) {
    int end;
    if (str == null || (end = str.length()) == 0) {
        return str;
    }
    if (stripChars == null) {
        while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) {
            end--;
        }
    } else if (stripChars.length() == 0) {
        return str;
    } else {
        while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) {
            end--;
        }
    }
    return str.substring(0, end);
}","public void test2761115() throws Throwable {
    String string0 = StringUtils.stripEnd(""Jd}BE$.wq])m9"", ""Jd}BE$.wq])m9"");
    assertNotNull(string0);
}","/**
 * <p>Strips any of a set of characters from the end of a String.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * An empty string ("""") input returns the empty string.</p>
 *
 * <p>If the stripChars String is {@code null}, whitespace is
 * stripped as defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripEnd(null, *)          = null
 * StringUtils.stripEnd("""", *)            = """"
 * StringUtils.stripEnd(""abc"", """")        = ""abc""
 * StringUtils.stripEnd(""abc"", null)      = ""abc""
 * StringUtils.stripEnd(""  abc"", null)    = ""  abc""
 * StringUtils.stripEnd(""abc  "", null)    = ""abc""
 * StringUtils.stripEnd("" abc "", null)    = "" abc""
 * StringUtils.stripEnd(""  abcyx"", ""xyz"") = ""  abc""
 * StringUtils.stripEnd(""120.00"", "".0"")   = ""12""
 * </pre>
 *
 * @param str  the String to remove characters from, may be null
 * @param stripChars  the set of characters to remove, null treated as whitespace
 * @return the stripped String, {@code null} if null String input
 */"
"public static boolean isAlphanumericSpace(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {
            return false;
        }
    }
    return true;
}","public void test2761117() throws Throwable {
    String string0 = StringUtils.stripEnd(""Jd}BE$.wq])m9"", ""Jd}BE$.wq])m9"");
    boolean boolean0 = StringUtils.isAlphanumericSpace(""Jd}BE$.wq])m9"");
    assertFalse(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only unicode letters, digits
 * or space ({@code ' '}).</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty CharSequence (length()=0) will return {@code true}.</p>
 *
 * <pre>
 * StringUtils.isAlphanumericSpace(null)   = false
 * StringUtils.isAlphanumericSpace("""")     = true
 * StringUtils.isAlphanumericSpace(""  "")   = true
 * StringUtils.isAlphanumericSpace(""abc"")  = true
 * StringUtils.isAlphanumericSpace(""ab c"") = true
 * StringUtils.isAlphanumericSpace(""ab2c"") = true
 * StringUtils.isAlphanumericSpace(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if only contains letters, digits or space,
 *  and is non-null
 * @since 3.0 Changed signature from isAlphanumericSpace(String) to isAlphanumericSpace(CharSequence)
 */"
"public static String join(Iterator<?> iterator, String separator) {
    // handle null, zero and one elements before building a buffer
    if (iterator == null) {
        return null;
    }
    if (!iterator.hasNext()) {
        return EMPTY;
    }
    Object first = iterator.next();
    if (!iterator.hasNext()) {
        return ObjectUtils.toString(first);
    }
    // two or more elements
    // Java default is 16, probably too small
    StringBuilder buf = new StringBuilder(256);
    if (first != null) {
        buf.append(first);
    }
    while (iterator.hasNext()) {
        if (separator != null) {
            buf.append(separator);
        }
        Object obj = iterator.next();
        if (obj != null) {
            buf.append(obj);
        }
    }
    return buf.toString();
}","public void test2761139() throws Throwable {
    String string0 = StringUtils.stripEnd(""Jd}BE$.wq])m9"", ""Jd}BE$.wq])m9"");
    boolean boolean0 = StringUtils.isAlphanumericSpace(""Jd}BE$.wq])m9"");
    TreeSet<Object> treeSet0 = new TreeSet<Object>();
    TreeSet<Object> treeSet1 = new TreeSet<Object>((SortedSet<Object>) treeSet0);
    boolean boolean1 = treeSet1.add(""Jd}BE$.wq])m9"");
    Iterator<Object> iterator0 = treeSet1.iterator();
    String string1 = StringUtils.join(iterator0, """");
    assertNotSame(treeSet0, treeSet1);
}","/**
 * <p>Joins the elements of the provided {@code Iterator} into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A {@code null} separator is the same as an empty String ("""").</p>
 *
 * <p>See the examples here: {@link #join(Object[],String)}. </p>
 *
 * @param iterator  the {@code Iterator} of values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @return the joined String, {@code null} if null iterator input
 */"
"// Abbreviating
//-----------------------------------------------------------------------
/**
 * <p>Abbreviates a String using ellipses. This will turn
 * ""Now is the time for all good men"" into ""Now is the time for...""</p>
 *
 * <p>Specifically:
 * <ul>
 *   <li>If {@code str} is less than {@code maxWidth} characters
 *       long, return it.</li>
 *   <li>Else abbreviate it to {@code (substring(str, 0, max-3) + ""..."")}.</li>
 *   <li>If {@code maxWidth} is less than {@code 4}, throw an
 *       {@code IllegalArgumentException}.</li>
 *   <li>In no case will it return a String of length greater than
 *       {@code maxWidth}.</li>
 * </ul>
 * </p>
 *
 * <pre>
 * StringUtils.abbreviate(null, *)      = null
 * StringUtils.abbreviate("""", 4)        = """"
 * StringUtils.abbreviate(""abcdefg"", 6) = ""abc...""
 * StringUtils.abbreviate(""abcdefg"", 7) = ""abcdefg""
 * StringUtils.abbreviate(""abcdefg"", 8) = ""abcdefg""
 * StringUtils.abbreviate(""abcdefg"", 4) = ""a...""
 * StringUtils.abbreviate(""abcdefg"", 3) = IllegalArgumentException
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param maxWidth  maximum length of result String, must be at least 4
 * @return abbreviated String, {@code null} if null String input
 * @throws IllegalArgumentException if the width is too small
 * @since 2.0
 */
public static String abbreviate(String str, int maxWidth) {
    return abbreviate(str, 0, maxWidth);
}","public void test2761148() throws Throwable {
    String string0 = StringUtils.stripEnd(""Jd}BE$.wq])m9"", ""Jd}BE$.wq])m9"");
    boolean boolean0 = StringUtils.isAlphanumericSpace(""Jd}BE$.wq])m9"");
    TreeSet<Object> treeSet0 = new TreeSet<Object>();
    TreeSet<Object> treeSet1 = new TreeSet<Object>((SortedSet<Object>) treeSet0);
    boolean boolean1 = treeSet1.add(""Jd}BE$.wq])m9"");
    Iterator<Object> iterator0 = treeSet1.iterator();
    String string1 = StringUtils.join(iterator0, """");
    // Undeclared exception!
    try {
        StringUtils.abbreviate(""8Nmlf.>\""5Zl"", 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Minimum abbreviation width is 4
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}",""
"public static String[] split(String str, String separatorChars) {
    return splitWorker(str, separatorChars, -1, false);
}","public void test2771149() throws Throwable {
    String string0 = ""\\u00"";
    String[] stringArray0 = StringUtils.split(string0, string0);
    assertEquals(0, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array, separators specified.
 * This is an alternative to using StringTokenizer.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as one separator.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} separatorChars splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.split(null, *)         = null
 * StringUtils.split("""", *)           = []
 * StringUtils.split(""abc def"", null) = [""abc"", ""def""]
 * StringUtils.split(""abc def"", "" "")  = [""abc"", ""def""]
 * StringUtils.split(""abc  def"", "" "") = [""abc"", ""def""]
 * StringUtils.split(""ab:cd:ef"", "":"") = [""ab"", ""cd"", ""ef""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @param separatorChars  the characters used as the delimiters,
 *  {@code null} splits on whitespace
 * @return an array of parsed Strings, {@code null} if null String input
 */"
"public static String[] stripAll(String[] strs, String stripChars) {
    int strsLen;
    if (strs == null || (strsLen = strs.length) == 0) {
        return strs;
    }
    String[] newArr = new String[strsLen];
    for (int i = 0; i < strsLen; i++) {
        newArr[i] = strip(strs[i], stripChars);
    }
    return newArr;
}","public void test2771152() throws Throwable {
    String string0 = ""\\u00"";
    String[] stringArray0 = StringUtils.split(string0, string0);
    String[] stringArray1 = new String[4];
    stringArray1[0] = string0;
    stringArray1[1] = ""m6yRs\""=D+xS"";
    stringArray1[2] = string0;
    stringArray1[3] = string0;
    String[] stringArray2 = StringUtils.stripAll(stringArray1, ""y8]@<)uMmQ]"");
    assertNotSame(stringArray1, stringArray0);
}","/**
 * <p>Strips any of a set of characters from the start and end of every
 * String in an array.</p>
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <p>A new array is returned each time, except for length zero.
 * A {@code null} array will return {@code null}.
 * An empty array will return itself.
 * A {@code null} array entry will be ignored.
 * A {@code null} stripChars will strip whitespace as defined by
 * {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripAll(null, *)                = null
 * StringUtils.stripAll([], *)                  = []
 * StringUtils.stripAll([""abc"", ""  abc""], null) = [""abc"", ""abc""]
 * StringUtils.stripAll([""abc  "", null], null)  = [""abc"", null]
 * StringUtils.stripAll([""abc  "", null], ""yz"")  = [""abc  "", null]
 * StringUtils.stripAll([""yabcz"", null], ""yz"")  = [""abc"", null]
 * </pre>
 *
 * @param strs  the array to remove characters from, may be null
 * @param stripChars  the characters to remove, null treated as whitespace
 * @return the stripped Strings, {@code null} if null array input
 */"
"public static String[] splitPreserveAllTokens(String str, String separatorChars) {
    return splitWorker(str, separatorChars, -1, true);
}","public void test2781162() throws Throwable {
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""7jju?tjxzsql"", """");
    assertEquals(1, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array, separators specified,
 * preserving all tokens, including empty tokens created by adjacent
 * separators. This is an alternative to using StringTokenizer.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as separators for empty tokens.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} separatorChars splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.splitPreserveAllTokens(null, *)           = null
 * StringUtils.splitPreserveAllTokens("""", *)             = []
 * StringUtils.splitPreserveAllTokens(""abc def"", null)   = [""abc"", ""def""]
 * StringUtils.splitPreserveAllTokens(""abc def"", "" "")    = [""abc"", ""def""]
 * StringUtils.splitPreserveAllTokens(""abc  def"", "" "")   = [""abc"", """", def""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef"", "":"")   = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef:"", "":"")  = [""ab"", ""cd"", ""ef"", """"]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef::"", "":"") = [""ab"", ""cd"", ""ef"", """", """"]
 * StringUtils.splitPreserveAllTokens(""ab::cd:ef"", "":"")  = [""ab"", """", cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens("":cd:ef"", "":"")     = ["""", cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""::cd:ef"", "":"")    = ["""", """", cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens("":cd:ef:"", "":"")    = ["""", cd"", ""ef"", """"]
 * </pre>
 *
 * @param str  the String to parse, may be {@code null}
 * @param separatorChars  the characters used as the delimiters,
 *  {@code null} splits on whitespace
 * @return an array of parsed Strings, {@code null} if null String input
 * @since 2.1
 */"
"// StripAll
//-----------------------------------------------------------------------
/**
 * <p>Strips whitespace from the start and end of every String in an array.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <p>A new array is returned each time, except for length zero.
 * A {@code null} array will return {@code null}.
 * An empty array will return itself.
 * A {@code null} array entry will be ignored.</p>
 *
 * <pre>
 * StringUtils.stripAll(null)             = null
 * StringUtils.stripAll([])               = []
 * StringUtils.stripAll([""abc"", ""  abc""]) = [""abc"", ""abc""]
 * StringUtils.stripAll([""abc  "", null])  = [""abc"", null]
 * </pre>
 *
 * @param strs  the array to remove whitespace from, may be null
 * @return the stripped Strings, {@code null} if null array input
 */
public static String[] stripAll(String... strs) {
    return stripAll(strs, null);
}","public void test2781164() throws Throwable {
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""7jju?tjxzsql"", """");
    String[] stringArray1 = StringUtils.stripAll(stringArray0);
    assertNotSame(stringArray0, stringArray1);
}",""
"public static int indexOf(CharSequence seq, CharSequence searchSeq) {
    if (seq == null || searchSeq == null) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.indexOf(seq, searchSeq, 0);
}","public void test2781170() throws Throwable {
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""7jju?tjxzsql"", """");
    String[] stringArray1 = StringUtils.stripAll(stringArray0);
    int int0 = StringUtils.indexOf((CharSequence) """", (CharSequence) """");
    assertEquals(0, int0);
}","/**
 * <p>Finds the first index within a CharSequence, handling {@code null}.
 * This method uses {@link String#indexOf(String, int)} if possible.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOf(null, *)          = -1
 * StringUtils.indexOf(*, null)          = -1
 * StringUtils.indexOf("""", """")           = 0
 * StringUtils.indexOf("""", *)            = -1 (except when * = """")
 * StringUtils.indexOf(""aabaabaa"", ""a"")  = 0
 * StringUtils.indexOf(""aabaabaa"", ""b"")  = 2
 * StringUtils.indexOf(""aabaabaa"", ""ab"") = 1
 * StringUtils.indexOf(""aabaabaa"", """")   = 0
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchSeq  the CharSequence to find, may be null
 * @return the first index of the search CharSequence,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from indexOf(String, String) to indexOf(CharSequence, CharSequence)
 */"
"// Centering
//-----------------------------------------------------------------------
/**
 * <p>Centers a String in a larger String of size {@code size}
 * using the space character (' ').<p>
 *
 * <p>If the size is less than the String length, the String is returned.
 * A {@code null} String returns {@code null}.
 * A negative size is treated as zero.</p>
 *
 * <p>Equivalent to {@code center(str, size, "" "")}.</p>
 *
 * <pre>
 * StringUtils.center(null, *)   = null
 * StringUtils.center("""", 4)     = ""    ""
 * StringUtils.center(""ab"", -1)  = ""ab""
 * StringUtils.center(""ab"", 4)   = "" ab ""
 * StringUtils.center(""abcd"", 2) = ""abcd""
 * StringUtils.center(""a"", 4)    = "" a  ""
 * </pre>
 *
 * @param str  the String to center, may be null
 * @param size  the int size of new String, negative treated as zero
 * @return centered String, {@code null} if null String input
 */
public static String center(String str, int size) {
    return center(str, size, ' ');
}","public void test2791171() throws Throwable {
    String string0 = StringUtils.center("""", 0);
    assertNotNull(string0);
}",""
"public static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal) {
    return ordinalIndexOf(str, searchStr, ordinal, false);
}","public void test2791173() throws Throwable {
    String string0 = StringUtils.center("""", 0);
    int int0 = StringUtils.ordinalIndexOf("""", """", 0);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the n-th index within a CharSequence, handling {@code null}.
 * This method uses {@link String#indexOf(String)} if possible.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.ordinalIndexOf(null, *, *)          = -1
 * StringUtils.ordinalIndexOf(*, null, *)          = -1
 * StringUtils.ordinalIndexOf("""", """", *)           = 0
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""a"", 1)  = 0
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""a"", 2)  = 1
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""b"", 1)  = 2
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""b"", 2)  = 5
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""ab"", 1) = 1
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""ab"", 2) = 4
 * StringUtils.ordinalIndexOf(""aabaabaa"", """", 1)   = 0
 * StringUtils.ordinalIndexOf(""aabaabaa"", """", 2)   = 0
 * </pre>
 *
 * <p>Note that 'head(CharSequence str, int n)' may be implemented as: </p>
 *
 * <pre>
 *   str.substring(0, lastOrdinalIndexOf(str, ""\n"", n))
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @param ordinal  the n-th {@code searchStr} to find
 * @return the n-th index of the search CharSequence,
 *  {@code -1} ({@code INDEX_NOT_FOUND}) if no match or {@code null} string input
 * @since 2.1
 * @since 3.0 Changed signature from ordinalIndexOf(String, String, int) to ordinalIndexOf(CharSequence, CharSequence, int)
 */"
"public static boolean containsIgnoreCase(CharSequence str, CharSequence searchStr) {
    if (str == null || searchStr == null) {
        return false;
    }
    int len = searchStr.length();
    int max = str.length() - len;
    for (int i = 0; i <= max; i++) {
        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) {
            return true;
        }
    }
    return false;
}","public void test2791174() throws Throwable {
    String string0 = StringUtils.center("""", 0);
    int int0 = StringUtils.ordinalIndexOf("""", """", 0);
    boolean boolean0 = StringUtils.containsIgnoreCase("""", """");
    assertTrue(boolean0);
}","/**
 * <p>Checks if CharSequence contains a search CharSequence irrespective of case,
 * handling {@code null}. Case-insensitivity is defined as by
 * {@link String#equalsIgnoreCase(String)}.
 *
 * <p>A {@code null} CharSequence will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.contains(null, *) = false
 * StringUtils.contains(*, null) = false
 * StringUtils.contains("""", """") = true
 * StringUtils.contains(""abc"", """") = true
 * StringUtils.contains(""abc"", ""a"") = true
 * StringUtils.contains(""abc"", ""z"") = false
 * StringUtils.contains(""abc"", ""A"") = true
 * StringUtils.contains(""abc"", ""Z"") = false
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @return true if the CharSequence contains the search CharSequence irrespective of
 * case or false if not or {@code null} string input
 * @since 3.0 Changed signature from containsIgnoreCase(String, String) to containsIgnoreCase(CharSequence, CharSequence)
 */"
"public static String substringBetween(String str, String open, String close) {
    if (str == null || open == null || close == null) {
        return null;
    }
    int start = str.indexOf(open);
    if (start != INDEX_NOT_FOUND) {
        int end = str.indexOf(close, start + open.length());
        if (end != INDEX_NOT_FOUND) {
            return str.substring(start + open.length(), end);
        }
    }
    return null;
}","public void test2791175() throws Throwable {
    String string0 = StringUtils.center("""", 0);
    int int0 = StringUtils.ordinalIndexOf("""", """", 0);
    boolean boolean0 = StringUtils.containsIgnoreCase("""", """");
    String string1 = StringUtils.substringBetween((String) null, """", """");
    assertNull(string1);
}","/**
 * <p>Gets the String that is nested in between two Strings.
 * Only the first match is returned.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} open/close returns {@code null} (no match).
 * An empty ("""") open and close returns an empty string.</p>
 *
 * <pre>
 * StringUtils.substringBetween(""wx[b]yz"", ""["", ""]"") = ""b""
 * StringUtils.substringBetween(null, *, *)          = null
 * StringUtils.substringBetween(*, null, *)          = null
 * StringUtils.substringBetween(*, *, null)          = null
 * StringUtils.substringBetween("""", """", """")          = """"
 * StringUtils.substringBetween("""", """", ""]"")         = null
 * StringUtils.substringBetween("""", ""["", ""]"")        = null
 * StringUtils.substringBetween(""yabcz"", """", """")     = """"
 * StringUtils.substringBetween(""yabcz"", ""y"", ""z"")   = ""abc""
 * StringUtils.substringBetween(""yabczyabcz"", ""y"", ""z"")   = ""abc""
 * </pre>
 *
 * @param str  the String containing the substring, may be null
 * @param open  the String before the substring, may be null
 * @param close  the String after the substring, may be null
 * @return the substring, {@code null} if no match
 * @since 2.0
 */"
"public static int indexOf(CharSequence seq, int searchChar, int startPos) {
    if (isEmpty(seq)) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.indexOf(seq, searchChar, startPos);
}","public void test2791176() throws Throwable {
    String string0 = StringUtils.center("""", 0);
    int int0 = StringUtils.ordinalIndexOf("""", """", 0);
    boolean boolean0 = StringUtils.containsIgnoreCase("""", """");
    String string1 = StringUtils.substringBetween((String) null, """", """");
    int int1 = StringUtils.indexOf((CharSequence) null, 0, 506);
    assertEquals((-1), int1);
}","/**
 * <p>Finds the first index within a CharSequence from a start position,
 * handling {@code null}.
 * This method uses {@link String#indexOf(int, int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("""") CharSequence will return {@code (INDEX_NOT_FOUND) -1}.
 * A negative start position is treated as zero.
 * A start position greater than the string length returns {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOf(null, *, *)          = -1
 * StringUtils.indexOf("""", *, *)            = -1
 * StringUtils.indexOf(""aabaabaa"", 'b', 0)  = 2
 * StringUtils.indexOf(""aabaabaa"", 'b', 3)  = 5
 * StringUtils.indexOf(""aabaabaa"", 'b', 9)  = -1
 * StringUtils.indexOf(""aabaabaa"", 'b', -1) = 2
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @param startPos  the start position, negative treated as zero
 * @return the first index of the search character,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from indexOf(String, int, int) to indexOf(CharSequence, int, int)
 */"
"public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {
    return splitWorker(str, separatorChars, max, true);
}","public void test2791178() throws Throwable {
    String string0 = StringUtils.center("""", 0);
    int int0 = StringUtils.ordinalIndexOf("""", """", 0);
    boolean boolean0 = StringUtils.containsIgnoreCase("""", """");
    String string1 = StringUtils.substringBetween((String) null, """", """");
    int int1 = StringUtils.indexOf((CharSequence) null, 0, 506);
    String[] stringArray0 = StringUtils.splitPreserveAllTokens((String) null, ""s1aT[?@{%;&56t6i`d"", 805);
    assertNull(stringArray0);
}","/**
 * <p>Splits the provided text into an array with a maximum length,
 * separators specified, preserving all tokens, including empty tokens
 * created by adjacent separators.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as separators for empty tokens.
 * Adjacent separators are treated as one separator.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} separatorChars splits on whitespace.</p>
 *
 * <p>If more than {@code max} delimited substrings are found, the last
 * returned string includes all characters after the first {@code max - 1}
 * returned strings (including separator characters).</p>
 *
 * <pre>
 * StringUtils.splitPreserveAllTokens(null, *, *)            = null
 * StringUtils.splitPreserveAllTokens("""", *, *)              = []
 * StringUtils.splitPreserveAllTokens(""ab de fg"", null, 0)   = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 0) = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef"", "":"", 0)    = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef"", "":"", 2)    = [""ab"", ""cd:ef""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 2) = [""ab"", ""  de fg""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 3) = [""ab"", """", "" de fg""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 4) = [""ab"", """", """", ""de fg""]
 * </pre>
 *
 * @param str  the String to parse, may be {@code null}
 * @param separatorChars  the characters used as the delimiters,
 *  {@code null} splits on whitespace
 * @param max  the maximum number of elements to include in the
 *  array. A zero or negative value implies no limit
 * @return an array of parsed Strings, {@code null} if null String input
 * @since 2.1
 */"
"public static String rightPad(String str, int size) {
    return rightPad(str, size, ' ');
}","public void test2801179() throws Throwable {
    String string0 = StringUtils.rightPad(""qk*%oj0K08=CrGn{"", (-2601));
    assertNotNull(string0);
}","/**
 * <p>Right pad a String with spaces (' ').</p>
 *
 * <p>The String is padded to the size of {@code size}.</p>
 *
 * <pre>
 * StringUtils.rightPad(null, *)   = null
 * StringUtils.rightPad("""", 3)     = ""   ""
 * StringUtils.rightPad(""bat"", 3)  = ""bat""
 * StringUtils.rightPad(""bat"", 5)  = ""bat  ""
 * StringUtils.rightPad(""bat"", 1)  = ""bat""
 * StringUtils.rightPad(""bat"", -1) = ""bat""
 * </pre>
 *
 * @param str  the String to pad out, may be null
 * @param size  the size to pad to
 * @return right padded String or original String if no padding is necessary,
 *  {@code null} if null String input
 */"
"public static int indexOf(CharSequence seq, int searchChar, int startPos) {
    if (isEmpty(seq)) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.indexOf(seq, searchChar, startPos);
}","public void test2801181() throws Throwable {
    String string0 = StringUtils.rightPad(""qk*%oj0K08=CrGn{"", (-2601));
    int int0 = StringUtils.indexOf((CharSequence) ""qk*%oj0K08=CrGn{"", 5, (-2601));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the first index within a CharSequence from a start position,
 * handling {@code null}.
 * This method uses {@link String#indexOf(int, int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("""") CharSequence will return {@code (INDEX_NOT_FOUND) -1}.
 * A negative start position is treated as zero.
 * A start position greater than the string length returns {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOf(null, *, *)          = -1
 * StringUtils.indexOf("""", *, *)            = -1
 * StringUtils.indexOf(""aabaabaa"", 'b', 0)  = 2
 * StringUtils.indexOf(""aabaabaa"", 'b', 3)  = 5
 * StringUtils.indexOf(""aabaabaa"", 'b', 9)  = -1
 * StringUtils.indexOf(""aabaabaa"", 'b', -1) = 2
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @param startPos  the start position, negative treated as zero
 * @return the first index of the search character,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from indexOf(String, int, int) to indexOf(CharSequence, int, int)
 */"
"public static boolean startsWithIgnoreCase(CharSequence str, CharSequence prefix) {
    return startsWith(str, prefix, true);
}","public void test2801182() throws Throwable {
    String string0 = StringUtils.rightPad(""qk*%oj0K08=CrGn{"", (-2601));
    int int0 = StringUtils.indexOf((CharSequence) ""qk*%oj0K08=CrGn{"", 5, (-2601));
    boolean boolean0 = StringUtils.startsWithIgnoreCase(""qk*%oj0K08=CrGn{"", ""qk*%oj0K08=CrGn{"");
    assertTrue(boolean0);
}","/**
 * <p>Case insensitive check if a CharSequence starts with a specified prefix.</p>
 *
 * <p>{@code null}s are handled without exceptions. Two {@code null}
 * references are considered to be equal. The comparison is case insensitive.</p>
 *
 * <pre>
 * StringUtils.startsWithIgnoreCase(null, null)      = true
 * StringUtils.startsWithIgnoreCase(null, ""abc"")     = false
 * StringUtils.startsWithIgnoreCase(""abcdef"", null)  = false
 * StringUtils.startsWithIgnoreCase(""abcdef"", ""abc"") = true
 * StringUtils.startsWithIgnoreCase(""ABCDEF"", ""abc"") = true
 * </pre>
 *
 * @see java.lang.String#startsWith(String)
 * @param str  the CharSequence to check, may be null
 * @param prefix the prefix to find, may be null
 * @return {@code true} if the CharSequence starts with the prefix, case insensitive, or
 *  both {@code null}
 * @since 2.4
 * @since 3.0 Changed signature from startsWithIgnoreCase(String, String) to startsWithIgnoreCase(CharSequence, CharSequence)
 */"
"// Chopping
//-----------------------------------------------------------------------
/**
 * <p>Remove the last character from a String.</p>
 *
 * <p>If the String ends in {@code \r\n}, then remove both
 * of them.</p>
 *
 * <pre>
 * StringUtils.chop(null)          = null
 * StringUtils.chop("""")            = """"
 * StringUtils.chop(""abc \r"")      = ""abc ""
 * StringUtils.chop(""abc\n"")       = ""abc""
 * StringUtils.chop(""abc\r\n"")     = ""abc""
 * StringUtils.chop(""abc"")         = ""ab""
 * StringUtils.chop(""abc\nabc"")    = ""abc\nab""
 * StringUtils.chop(""a"")           = """"
 * StringUtils.chop(""\r"")          = """"
 * StringUtils.chop(""\n"")          = """"
 * StringUtils.chop(""\r\n"")        = """"
 * </pre>
 *
 * @param str  the String to chop last character from, may be null
 * @return String without last character, {@code null} if null String input
 */
public static String chop(String str) {
    if (str == null) {
        return null;
    }
    int strLen = str.length();
    if (strLen < 2) {
        return EMPTY;
    }
    int lastIdx = strLen - 1;
    String ret = str.substring(0, lastIdx);
    char last = str.charAt(lastIdx);
    if (last == CharUtils.LF) {
        if (ret.charAt(lastIdx - 1) == CharUtils.CR) {
            return ret.substring(0, lastIdx - 1);
        }
    }
    return ret;
}","public void test2811183() throws Throwable {
    String string0 = StringUtils.chop(""p{InCombiningDiacriticalMarks}+"");
    assertNotNull(string0);
}",""
"public static int getLevenshteinDistance(CharSequence s, CharSequence t, int threshold) {
    if (s == null || t == null) {
        throw new IllegalArgumentException(""Strings must not be null"");
    }
    if (threshold < 0) {
        throw new IllegalArgumentException(""Threshold must not be negative"");
    }
    /*
        This implementation only computes the distance if it's less than or equal to the
        threshold value, returning -1 if it's greater.  The advantage is performance: unbounded
        distance is O(nm), but a bound of k allows us to reduce it to O(km) time by only 
        computing a diagonal stripe of width 2k + 1 of the cost table.
        It is also possible to use this to compute the unbounded Levenshtein distance by starting
        the threshold at 1 and doubling each time until the distance is found; this is O(dm), where
        d is the distance.
        
        One subtlety comes from needing to ignore entries on the border of our stripe
        eg.
        p[] = |#|#|#|*
        d[] =  *|#|#|#|
        We must ignore the entry to the left of the leftmost member
        We must ignore the entry above the rightmost member
        
        Another subtlety comes from our stripe running off the matrix if the strings aren't
        of the same size.  Since string s is always swapped to be the shorter of the two, 
        the stripe will always run off to the upper right instead of the lower left of the matrix.
        
        As a concrete example, suppose s is of length 5, t is of length 7, and our threshold is 1.
        In this case we're going to walk a stripe of length 3.  The matrix would look like so:
        
           1 2 3 4 5
        1 |#|#| | | |
        2 |#|#|#| | |
        3 | |#|#|#| |
        4 | | |#|#|#|
        5 | | | |#|#|
        6 | | | | |#|
        7 | | | | | |

        Note how the stripe leads off the table as there is no possible way to turn a string of length 5
        into one of length 7 in edit distance of 1.
        
        Additionally, this implementation decreases memory usage by using two 
        single-dimensional arrays and swapping them back and forth instead of allocating
        an entire n by m matrix.  This requires a few minor changes, such as immediately returning 
        when it's detected that the stripe has run off the matrix and initially filling the arrays with
        large values so that entries we don't compute are ignored.

        See Algorithms on Strings, Trees and Sequences by Dan Gusfield for some discussion.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    // if one string is empty, the edit distance is necessarily the length of the other
    if (n == 0) {
        return m <= threshold ? m : -1;
    } else if (m == 0) {
        return n <= threshold ? n : -1;
    }
    if (n > m) {
        // swap the two strings to consume less memory
        CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    // 'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    // placeholder to assist in swapping p and d
    int[] _d;
    // fill in starting table values
    int boundary = Math.min(n, threshold) + 1;
    for (int i = 0; i < boundary; i++) {
        p[i] = i;
    }
    // these fills ensure that the value above the rightmost entry of our
    // stripe will be ignored in following loop iterations
    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);
    Arrays.fill(d, Integer.MAX_VALUE);
    // iterates through t
    for (int j = 1; j <= m; j++) {
        // jth character of t
        char t_j = t.charAt(j - 1);
        d[0] = j;
        // compute stripe indices, constrain to array size
        int min = Math.max(1, j - threshold);
        int max = Math.min(n, j + threshold);
        // the stripe may lead off of the table if s and t are of different sizes
        if (min > max) {
            return -1;
        }
        // ignore entry left of leftmost
        if (min > 1) {
            d[min - 1] = Integer.MAX_VALUE;
        }
        // iterates through [min, max] in s
        for (int i = min; i <= max; i++) {
            if (s.charAt(i - 1) == t_j) {
                // diagonally left and up
                d[i] = p[i - 1];
            } else {
                // 1 + minimum of cell to the left, to the top, diagonally left and up
                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);
            }
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // if p[n] is greater than the threshold, there's no guarantee on it being the correct
    // distance
    if (p[n] <= threshold) {
        return p[n];
    } else {
        return -1;
    }
}","public void test2811185() throws Throwable {
    String string0 = StringUtils.chop(""p{InCombiningDiacriticalMarks}+"");
    int int0 = StringUtils.getLevenshteinDistance((CharSequence) ""p{InCombiningDiacriticalMarks}"", (CharSequence) ""p{InCombiningDiacriticalMarks}+"", 1975);
    assertEquals(1, int0);
}","/**
 * <p>Find the Levenshtein distance between two Strings if it's less than or equal to a given
 * threshold.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>This implementation follows from Algorithms on Strings, Trees and Sequences by Dan Gusfield
 * and Chas Emerick's implementation of the Levenshtein distance algorithm from
 * <a href=""http://www.merriampark.com/ld.htm"">http://www.merriampark.com/ld.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, *, -1)               = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("""","""", 0)               = 0
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 8)       = 7
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 7)       = 7
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 6))      = -1
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"", 7) = 7
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"", 6) = -1
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"", 7) = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"", 6) = -1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @param threshold the target threshold, must not be negative
 * @return result distance, or {@code -1} if the distance would be greater than the threshold
 * @throws IllegalArgumentException if either String input {@code null} or negative threshold
 */"
"public static boolean containsNone(CharSequence cs, String invalidChars) {
    if (cs == null || invalidChars == null) {
        return true;
    }
    return containsNone(cs, invalidChars.toCharArray());
}","public void test2811186() throws Throwable {
    String string0 = StringUtils.chop(""p{InCombiningDiacriticalMarks}+"");
    int int0 = StringUtils.getLevenshteinDistance((CharSequence) ""p{InCombiningDiacriticalMarks}"", (CharSequence) ""p{InCombiningDiacriticalMarks}+"", 1975);
    boolean boolean0 = StringUtils.containsNone((CharSequence) ""p{InCombiningDiacriticalMarks}+"", ""p{InCombiningDiacriticalMarks}+"");
    assertFalse(boolean0);
}","/**
 * <p>Checks that the CharSequence does not contain certain characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code true}.
 * A {@code null} invalid character array will return {@code true}.
 * An empty String ("""") always returns true.</p>
 *
 * <pre>
 * StringUtils.containsNone(null, *)       = true
 * StringUtils.containsNone(*, null)       = true
 * StringUtils.containsNone("""", *)         = true
 * StringUtils.containsNone(""ab"", """")      = true
 * StringUtils.containsNone(""abab"", ""xyz"") = true
 * StringUtils.containsNone(""ab1"", ""xyz"")  = true
 * StringUtils.containsNone(""abz"", ""xyz"")  = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param invalidChars  a String of invalid chars, may be null
 * @return true if it contains none of the invalid chars, or is null
 * @since 2.0
 * @since 3.0 Changed signature from containsNone(String, String) to containsNone(CharSequence, String)
 */"
"// ContainsOnly
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains only certain characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.
 * A {@code null} valid character array will return {@code false}.
 * An empty CharSequence (length()=0) always returns {@code true}.</p>
 *
 * <pre>
 * StringUtils.containsOnly(null, *)       = false
 * StringUtils.containsOnly(*, null)       = false
 * StringUtils.containsOnly("""", *)         = true
 * StringUtils.containsOnly(""ab"", '')      = false
 * StringUtils.containsOnly(""abab"", 'abc') = true
 * StringUtils.containsOnly(""ab1"", 'abc')  = false
 * StringUtils.containsOnly(""abz"", 'abc')  = false
 * </pre>
 *
 * @param cs  the String to check, may be null
 * @param valid  an array of valid chars, may be null
 * @return true if it only contains valid chars and is non-null
 * @since 3.0 Changed signature from containsOnly(String, char[]) to containsOnly(CharSequence, char...)
 */
public static boolean containsOnly(CharSequence cs, char... valid) {
    // All these pre-checks are to maintain API with an older version
    if (valid == null || cs == null) {
        return false;
    }
    if (cs.length() == 0) {
        return true;
    }
    if (valid.length == 0) {
        return false;
    }
    return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND;
}","public void test2811187() throws Throwable {
    String string0 = StringUtils.chop(""p{InCombiningDiacriticalMarks}+"");
    int int0 = StringUtils.getLevenshteinDistance((CharSequence) ""p{InCombiningDiacriticalMarks}"", (CharSequence) ""p{InCombiningDiacriticalMarks}+"", 1975);
    boolean boolean0 = StringUtils.containsNone((CharSequence) ""p{InCombiningDiacriticalMarks}+"", ""p{InCombiningDiacriticalMarks}+"");
    char[] charArray0 = new char[4];
    charArray0[0] = 'Z';
    charArray0[1] = 'S';
    charArray0[2] = 'E';
    charArray0[3] = 'c';
    boolean boolean1 = StringUtils.containsOnly((CharSequence) ""p{InCombiningDiacriticalMarks}"", charArray0);
    assertEquals(4, charArray0.length);
}",""
"// SubStringAfter/SubStringBefore
//-----------------------------------------------------------------------
/**
 * <p>Gets the substring before the first occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A {@code null} string input will return {@code null}.
 * An empty ("""") string input will return the empty string.
 * A {@code null} separator will return the input string.</p>
 *
 * <p>If nothing is found, the string input is returned.</p>
 *
 * <pre>
 * StringUtils.substringBefore(null, *)      = null
 * StringUtils.substringBefore("""", *)        = """"
 * StringUtils.substringBefore(""abc"", ""a"")   = """"
 * StringUtils.substringBefore(""abcba"", ""b"") = ""a""
 * StringUtils.substringBefore(""abc"", ""c"")   = ""ab""
 * StringUtils.substringBefore(""abc"", ""d"")   = ""abc""
 * StringUtils.substringBefore(""abc"", """")    = """"
 * StringUtils.substringBefore(""abc"", null)  = ""abc""
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring before the first occurrence of the separator,
 *  {@code null} if null String input
 * @since 2.0
 */
public static String substringBefore(String str, String separator) {
    if (isEmpty(str) || separator == null) {
        return str;
    }
    if (separator.length() == 0) {
        return EMPTY;
    }
    int pos = str.indexOf(separator);
    if (pos == INDEX_NOT_FOUND) {
        return str;
    }
    return str.substring(0, pos);
}","public void test2811191() throws Throwable {
    String string0 = StringUtils.chop(""p{InCombiningDiacriticalMarks}+"");
    int int0 = StringUtils.getLevenshteinDistance((CharSequence) ""p{InCombiningDiacriticalMarks}"", (CharSequence) ""p{InCombiningDiacriticalMarks}+"", 1975);
    boolean boolean0 = StringUtils.containsNone((CharSequence) ""p{InCombiningDiacriticalMarks}+"", ""p{InCombiningDiacriticalMarks}+"");
    char[] charArray0 = new char[4];
    charArray0[0] = 'Z';
    charArray0[1] = 'S';
    charArray0[2] = 'E';
    charArray0[3] = 'c';
    boolean boolean1 = StringUtils.containsOnly((CharSequence) ""p{InCombiningDiacriticalMarks}"", charArray0);
    String string1 = StringUtils.substringBefore(""(m'~h1DlVpMUe"", ""3jL9%"");
    assertNotNull(string1);
}",""
"// ContainsNone
//-----------------------------------------------------------------------
/**
 * <p>Checks that the CharSequence does not contain certain characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code true}.
 * A {@code null} invalid character array will return {@code true}.
 * An empty CharSequence (length()=0) always returns true.</p>
 *
 * <pre>
 * StringUtils.containsNone(null, *)       = true
 * StringUtils.containsNone(*, null)       = true
 * StringUtils.containsNone("""", *)         = true
 * StringUtils.containsNone(""ab"", '')      = true
 * StringUtils.containsNone(""abab"", 'xyz') = true
 * StringUtils.containsNone(""ab1"", 'xyz')  = true
 * StringUtils.containsNone(""abz"", 'xyz')  = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  an array of invalid chars, may be null
 * @return true if it contains none of the invalid chars, or is null
 * @since 2.0
 * @since 3.0 Changed signature from containsNone(String, char[]) to containsNone(CharSequence, char...)
 */
public static boolean containsNone(CharSequence cs, char... searchChars) {
    if (cs == null || searchChars == null) {
        return true;
    }
    int csLen = cs.length();
    int csLast = csLen - 1;
    int searchLen = searchChars.length;
    int searchLast = searchLen - 1;
    for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (Character.isHighSurrogate(ch)) {
                    if (j == searchLast) {
                        // missing low surrogate, fine, like String.indexOf(String)
                        return false;
                    }
                    if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
                        return false;
                    }
                } else {
                    // ch is in the Basic Multilingual Plane
                    return false;
                }
            }
        }
    }
    return true;
}","public void test2811194() throws Throwable {
    String string0 = StringUtils.chop(""p{InCombiningDiacriticalMarks}+"");
    int int0 = StringUtils.getLevenshteinDistance((CharSequence) ""p{InCombiningDiacriticalMarks}"", (CharSequence) ""p{InCombiningDiacriticalMarks}+"", 1975);
    boolean boolean0 = StringUtils.containsNone((CharSequence) ""p{InCombiningDiacriticalMarks}+"", ""p{InCombiningDiacriticalMarks}+"");
    char[] charArray0 = new char[4];
    charArray0[0] = 'Z';
    charArray0[1] = 'S';
    charArray0[2] = 'E';
    charArray0[3] = 'c';
    boolean boolean1 = StringUtils.containsOnly((CharSequence) ""p{InCombiningDiacriticalMarks}"", charArray0);
    String string1 = StringUtils.substringBefore(""(m'~h1DlVpMUe"", ""3jL9%"");
    boolean boolean2 = StringUtils.containsNone((CharSequence) ""(m'~h1DlVpMUe"", charArray0);
    assertEquals(4, charArray0.length);
}",""
"public static boolean isNumeric(CharSequence cs) {
    if (cs == null || cs.length() == 0) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isDigit(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test2811199() throws Throwable {
    String string0 = StringUtils.chop(""p{InCombiningDiacriticalMarks}+"");
    int int0 = StringUtils.getLevenshteinDistance((CharSequence) ""p{InCombiningDiacriticalMarks}"", (CharSequence) ""p{InCombiningDiacriticalMarks}+"", 1975);
    boolean boolean0 = StringUtils.containsNone((CharSequence) ""p{InCombiningDiacriticalMarks}+"", ""p{InCombiningDiacriticalMarks}+"");
    char[] charArray0 = new char[4];
    charArray0[0] = 'Z';
    charArray0[1] = 'S';
    charArray0[2] = 'E';
    charArray0[3] = 'c';
    boolean boolean1 = StringUtils.containsOnly((CharSequence) ""p{InCombiningDiacriticalMarks}"", charArray0);
    String string1 = StringUtils.substringBefore(""(m'~h1DlVpMUe"", ""3jL9%"");
    boolean boolean2 = StringUtils.containsNone((CharSequence) ""(m'~h1DlVpMUe"", charArray0);
    boolean boolean3 = StringUtils.isNumeric(""p{InCombiningDiacriticalMarks}"");
    assertFalse(boolean3);
}","/**
 * <p>Checks if the CharSequence contains only unicode digits.
 * A decimal point is not a unicode digit and returns false.</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty CharSequence (length()=0) will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.isNumeric(null)   = false
 * StringUtils.isNumeric("""")     = false
 * StringUtils.isNumeric(""  "")   = false
 * StringUtils.isNumeric(""123"")  = true
 * StringUtils.isNumeric(""12 3"") = false
 * StringUtils.isNumeric(""ab2c"") = false
 * StringUtils.isNumeric(""12-3"") = false
 * StringUtils.isNumeric(""12.3"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if only contains digits, and is non-null
 * @since 3.0 Changed signature from isNumeric(String) to isNumeric(CharSequence)
 * @since 3.0 Changed """" to return false and not true
 */"
"public static boolean isAllUpperCase(CharSequence cs) {
    if (cs == null || isEmpty(cs)) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isUpperCase(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test2811203() throws Throwable {
    String string0 = StringUtils.chop(""p{InCombiningDiacriticalMarks}+"");
    int int0 = StringUtils.getLevenshteinDistance((CharSequence) ""p{InCombiningDiacriticalMarks}"", (CharSequence) ""p{InCombiningDiacriticalMarks}+"", 1975);
    boolean boolean0 = StringUtils.containsNone((CharSequence) ""p{InCombiningDiacriticalMarks}+"", ""p{InCombiningDiacriticalMarks}+"");
    char[] charArray0 = new char[4];
    charArray0[0] = 'Z';
    charArray0[1] = 'S';
    charArray0[2] = 'E';
    charArray0[3] = 'c';
    boolean boolean1 = StringUtils.containsOnly((CharSequence) ""p{InCombiningDiacriticalMarks}"", charArray0);
    String string1 = StringUtils.substringBefore(""(m'~h1DlVpMUe"", ""3jL9%"");
    boolean boolean2 = StringUtils.containsNone((CharSequence) ""(m'~h1DlVpMUe"", charArray0);
    boolean boolean3 = StringUtils.isNumeric(""p{InCombiningDiacriticalMarks}"");
    boolean boolean4 = StringUtils.isAllUpperCase(""(m'~h1DlVpMUe"");
    assertFalse(boolean4);
}","/**
 * <p>Checks if the CharSequence contains only uppercase characters.</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty String (length()=0) will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.isAllUpperCase(null)   = false
 * StringUtils.isAllUpperCase("""")     = false
 * StringUtils.isAllUpperCase(""  "")   = false
 * StringUtils.isAllUpperCase(""ABC"")  = true
 * StringUtils.isAllUpperCase(""aBC"") = false
 * </pre>
 *
 * @param cs the CharSequence to check, may be null
 * @return {@code true} if only contains uppercase characters, and is non-null
 * @since 2.5
 * @since 3.0 Changed signature from isAllUpperCase(String) to isAllUpperCase(CharSequence)
 */"
"public static int getLevenshteinDistance(CharSequence s, CharSequence t, int threshold) {
    if (s == null || t == null) {
        throw new IllegalArgumentException(""Strings must not be null"");
    }
    if (threshold < 0) {
        throw new IllegalArgumentException(""Threshold must not be negative"");
    }
    /*
        This implementation only computes the distance if it's less than or equal to the
        threshold value, returning -1 if it's greater.  The advantage is performance: unbounded
        distance is O(nm), but a bound of k allows us to reduce it to O(km) time by only 
        computing a diagonal stripe of width 2k + 1 of the cost table.
        It is also possible to use this to compute the unbounded Levenshtein distance by starting
        the threshold at 1 and doubling each time until the distance is found; this is O(dm), where
        d is the distance.
        
        One subtlety comes from needing to ignore entries on the border of our stripe
        eg.
        p[] = |#|#|#|*
        d[] =  *|#|#|#|
        We must ignore the entry to the left of the leftmost member
        We must ignore the entry above the rightmost member
        
        Another subtlety comes from our stripe running off the matrix if the strings aren't
        of the same size.  Since string s is always swapped to be the shorter of the two, 
        the stripe will always run off to the upper right instead of the lower left of the matrix.
        
        As a concrete example, suppose s is of length 5, t is of length 7, and our threshold is 1.
        In this case we're going to walk a stripe of length 3.  The matrix would look like so:
        
           1 2 3 4 5
        1 |#|#| | | |
        2 |#|#|#| | |
        3 | |#|#|#| |
        4 | | |#|#|#|
        5 | | | |#|#|
        6 | | | | |#|
        7 | | | | | |

        Note how the stripe leads off the table as there is no possible way to turn a string of length 5
        into one of length 7 in edit distance of 1.
        
        Additionally, this implementation decreases memory usage by using two 
        single-dimensional arrays and swapping them back and forth instead of allocating
        an entire n by m matrix.  This requires a few minor changes, such as immediately returning 
        when it's detected that the stripe has run off the matrix and initially filling the arrays with
        large values so that entries we don't compute are ignored.

        See Algorithms on Strings, Trees and Sequences by Dan Gusfield for some discussion.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    // if one string is empty, the edit distance is necessarily the length of the other
    if (n == 0) {
        return m <= threshold ? m : -1;
    } else if (m == 0) {
        return n <= threshold ? n : -1;
    }
    if (n > m) {
        // swap the two strings to consume less memory
        CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    // 'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    // placeholder to assist in swapping p and d
    int[] _d;
    // fill in starting table values
    int boundary = Math.min(n, threshold) + 1;
    for (int i = 0; i < boundary; i++) {
        p[i] = i;
    }
    // these fills ensure that the value above the rightmost entry of our
    // stripe will be ignored in following loop iterations
    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);
    Arrays.fill(d, Integer.MAX_VALUE);
    // iterates through t
    for (int j = 1; j <= m; j++) {
        // jth character of t
        char t_j = t.charAt(j - 1);
        d[0] = j;
        // compute stripe indices, constrain to array size
        int min = Math.max(1, j - threshold);
        int max = Math.min(n, j + threshold);
        // the stripe may lead off of the table if s and t are of different sizes
        if (min > max) {
            return -1;
        }
        // ignore entry left of leftmost
        if (min > 1) {
            d[min - 1] = Integer.MAX_VALUE;
        }
        // iterates through [min, max] in s
        for (int i = min; i <= max; i++) {
            if (s.charAt(i - 1) == t_j) {
                // diagonally left and up
                d[i] = p[i - 1];
            } else {
                // 1 + minimum of cell to the left, to the top, diagonally left and up
                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);
            }
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // if p[n] is greater than the threshold, there's no guarantee on it being the correct
    // distance
    if (p[n] <= threshold) {
        return p[n];
    } else {
        return -1;
    }
}","public void test2811208() throws Throwable {
    String string0 = StringUtils.chop(""p{InCombiningDiacriticalMarks}+"");
    int int0 = StringUtils.getLevenshteinDistance((CharSequence) ""p{InCombiningDiacriticalMarks}"", (CharSequence) ""p{InCombiningDiacriticalMarks}+"", 1975);
    boolean boolean0 = StringUtils.containsNone((CharSequence) ""p{InCombiningDiacriticalMarks}+"", ""p{InCombiningDiacriticalMarks}+"");
    char[] charArray0 = new char[4];
    charArray0[0] = 'Z';
    charArray0[1] = 'S';
    charArray0[2] = 'E';
    charArray0[3] = 'c';
    boolean boolean1 = StringUtils.containsOnly((CharSequence) ""p{InCombiningDiacriticalMarks}"", charArray0);
    String string1 = StringUtils.substringBefore(""(m'~h1DlVpMUe"", ""3jL9%"");
    boolean boolean2 = StringUtils.containsNone((CharSequence) ""(m'~h1DlVpMUe"", charArray0);
    boolean boolean3 = StringUtils.isNumeric(""p{InCombiningDiacriticalMarks}"");
    boolean boolean4 = StringUtils.isAllUpperCase(""(m'~h1DlVpMUe"");
    int int1 = StringUtils.getLevenshteinDistance((CharSequence) ""p{InCombiningDiacriticalMarks}"", (CharSequence) ""(m'~h1DlVpMUe"", 128);
    assertEquals(27, int1);
}","/**
 * <p>Find the Levenshtein distance between two Strings if it's less than or equal to a given
 * threshold.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>This implementation follows from Algorithms on Strings, Trees and Sequences by Dan Gusfield
 * and Chas Emerick's implementation of the Levenshtein distance algorithm from
 * <a href=""http://www.merriampark.com/ld.htm"">http://www.merriampark.com/ld.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, *, -1)               = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("""","""", 0)               = 0
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 8)       = 7
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 7)       = 7
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 6))      = -1
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"", 7) = 7
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"", 6) = -1
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"", 7) = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"", 6) = -1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @param threshold the target threshold, must not be negative
 * @return result distance, or {@code -1} if the distance would be greater than the threshold
 * @throws IllegalArgumentException if either String input {@code null} or negative threshold
 */"
"// Chopping
//-----------------------------------------------------------------------
/**
 * <p>Remove the last character from a String.</p>
 *
 * <p>If the String ends in {@code \r\n}, then remove both
 * of them.</p>
 *
 * <pre>
 * StringUtils.chop(null)          = null
 * StringUtils.chop("""")            = """"
 * StringUtils.chop(""abc \r"")      = ""abc ""
 * StringUtils.chop(""abc\n"")       = ""abc""
 * StringUtils.chop(""abc\r\n"")     = ""abc""
 * StringUtils.chop(""abc"")         = ""ab""
 * StringUtils.chop(""abc\nabc"")    = ""abc\nab""
 * StringUtils.chop(""a"")           = """"
 * StringUtils.chop(""\r"")          = """"
 * StringUtils.chop(""\n"")          = """"
 * StringUtils.chop(""\r\n"")        = """"
 * </pre>
 *
 * @param str  the String to chop last character from, may be null
 * @return String without last character, {@code null} if null String input
 */
public static String chop(String str) {
    if (str == null) {
        return null;
    }
    int strLen = str.length();
    if (strLen < 2) {
        return EMPTY;
    }
    int lastIdx = strLen - 1;
    String ret = str.substring(0, lastIdx);
    char last = str.charAt(lastIdx);
    if (last == CharUtils.LF) {
        if (ret.charAt(lastIdx - 1) == CharUtils.CR) {
            return ret.substring(0, lastIdx - 1);
        }
    }
    return ret;
}","public void test2811210() throws Throwable {
    String string0 = StringUtils.chop(""p{InCombiningDiacriticalMarks}+"");
    int int0 = StringUtils.getLevenshteinDistance((CharSequence) ""p{InCombiningDiacriticalMarks}"", (CharSequence) ""p{InCombiningDiacriticalMarks}+"", 1975);
    boolean boolean0 = StringUtils.containsNone((CharSequence) ""p{InCombiningDiacriticalMarks}+"", ""p{InCombiningDiacriticalMarks}+"");
    char[] charArray0 = new char[4];
    charArray0[0] = 'Z';
    charArray0[1] = 'S';
    charArray0[2] = 'E';
    charArray0[3] = 'c';
    boolean boolean1 = StringUtils.containsOnly((CharSequence) ""p{InCombiningDiacriticalMarks}"", charArray0);
    String string1 = StringUtils.substringBefore(""(m'~h1DlVpMUe"", ""3jL9%"");
    boolean boolean2 = StringUtils.containsNone((CharSequence) ""(m'~h1DlVpMUe"", charArray0);
    boolean boolean3 = StringUtils.isNumeric(""p{InCombiningDiacriticalMarks}"");
    boolean boolean4 = StringUtils.isAllUpperCase(""(m'~h1DlVpMUe"");
    int int1 = StringUtils.getLevenshteinDistance((CharSequence) ""p{InCombiningDiacriticalMarks}"", (CharSequence) ""(m'~h1DlVpMUe"", 128);
    String string2 = StringUtils.chop(""p{InCombiningDiacriticalMarks}+"");
    assertNotNull(string2);
}",""
"// Difference
//-----------------------------------------------------------------------
/**
 * <p>Compares two Strings, and returns the portion where they differ.
 * (More precisely, return the remainder of the second String,
 * starting from where it's different from the first.)</p>
 *
 * <p>For example,
 * {@code difference(""i am a machine"", ""i am a robot"") -> ""robot""}.</p>
 *
 * <pre>
 * StringUtils.difference(null, null) = null
 * StringUtils.difference("""", """") = """"
 * StringUtils.difference("""", ""abc"") = ""abc""
 * StringUtils.difference(""abc"", """") = """"
 * StringUtils.difference(""abc"", ""abc"") = """"
 * StringUtils.difference(""ab"", ""abxyz"") = ""xyz""
 * StringUtils.difference(""abcde"", ""abxyz"") = ""xyz""
 * StringUtils.difference(""abcde"", ""xyz"") = ""xyz""
 * </pre>
 *
 * @param str1  the first String, may be null
 * @param str2  the second String, may be null
 * @return the portion of str2 where it differs from str1; returns the
 * empty String if they are equal
 * @since 2.0
 */
public static String difference(String str1, String str2) {
    if (str1 == null) {
        return str2;
    }
    if (str2 == null) {
        return str1;
    }
    int at = indexOfDifference(str1, str2);
    if (at == INDEX_NOT_FOUND) {
        return EMPTY;
    }
    return str2.substring(at);
}","public void test2811214() throws Throwable {
    String string0 = StringUtils.chop(""p{InCombiningDiacriticalMarks}+"");
    int int0 = StringUtils.getLevenshteinDistance((CharSequence) ""p{InCombiningDiacriticalMarks}"", (CharSequence) ""p{InCombiningDiacriticalMarks}+"", 1975);
    boolean boolean0 = StringUtils.containsNone((CharSequence) ""p{InCombiningDiacriticalMarks}+"", ""p{InCombiningDiacriticalMarks}+"");
    char[] charArray0 = new char[4];
    charArray0[0] = 'Z';
    charArray0[1] = 'S';
    charArray0[2] = 'E';
    charArray0[3] = 'c';
    boolean boolean1 = StringUtils.containsOnly((CharSequence) ""p{InCombiningDiacriticalMarks}"", charArray0);
    String string1 = StringUtils.substringBefore(""(m'~h1DlVpMUe"", ""3jL9%"");
    boolean boolean2 = StringUtils.containsNone((CharSequence) ""(m'~h1DlVpMUe"", charArray0);
    boolean boolean3 = StringUtils.isNumeric(""p{InCombiningDiacriticalMarks}"");
    boolean boolean4 = StringUtils.isAllUpperCase(""(m'~h1DlVpMUe"");
    int int1 = StringUtils.getLevenshteinDistance((CharSequence) ""p{InCombiningDiacriticalMarks}"", (CharSequence) ""(m'~h1DlVpMUe"", 128);
    String string2 = StringUtils.chop(""p{InCombiningDiacriticalMarks}+"");
    String string3 = StringUtils.difference(""(m'~h1DlVpMUe"", ""3jL9%"");
    assertNotNull(string3);
}",""
"// Remove
//-----------------------------------------------------------------------
/**
 * <p>Removes a substring only if it is at the begining of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("""") source string will return the empty string.
 * A {@code null} search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeStart(null, *)      = null
 * StringUtils.removeStart("""", *)        = """"
 * StringUtils.removeStart(*, null)      = *
 * StringUtils.removeStart(""www.domain.com"", ""www."")   = ""domain.com""
 * StringUtils.removeStart(""domain.com"", ""www."")       = ""domain.com""
 * StringUtils.removeStart(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeStart(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for and remove, may be null
 * @return the substring with the string removed if found,
 *  {@code null} if null String input
 * @since 2.1
 */
public static String removeStart(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (str.startsWith(remove)) {
        return str.substring(remove.length());
    }
    return str;
}","public void test2811219() throws Throwable {
    String string0 = StringUtils.chop(""p{InCombiningDiacriticalMarks}+"");
    int int0 = StringUtils.getLevenshteinDistance((CharSequence) ""p{InCombiningDiacriticalMarks}"", (CharSequence) ""p{InCombiningDiacriticalMarks}+"", 1975);
    boolean boolean0 = StringUtils.containsNone((CharSequence) ""p{InCombiningDiacriticalMarks}+"", ""p{InCombiningDiacriticalMarks}+"");
    char[] charArray0 = new char[4];
    charArray0[0] = 'Z';
    charArray0[1] = 'S';
    charArray0[2] = 'E';
    charArray0[3] = 'c';
    boolean boolean1 = StringUtils.containsOnly((CharSequence) ""p{InCombiningDiacriticalMarks}"", charArray0);
    String string1 = StringUtils.substringBefore(""(m'~h1DlVpMUe"", ""3jL9%"");
    boolean boolean2 = StringUtils.containsNone((CharSequence) ""(m'~h1DlVpMUe"", charArray0);
    boolean boolean3 = StringUtils.isNumeric(""p{InCombiningDiacriticalMarks}"");
    boolean boolean4 = StringUtils.isAllUpperCase(""(m'~h1DlVpMUe"");
    int int1 = StringUtils.getLevenshteinDistance((CharSequence) ""p{InCombiningDiacriticalMarks}"", (CharSequence) ""(m'~h1DlVpMUe"", 128);
    String string2 = StringUtils.chop(""p{InCombiningDiacriticalMarks}+"");
    String string3 = StringUtils.difference(""(m'~h1DlVpMUe"", ""3jL9%"");
    String string4 = StringUtils.removeStart(""p{InCombiningDiacriticalMarks}"", ""p{InCombiningDiacriticalMarks}"");
    assertNotNull(string4);
}",""
"public static String join(Iterator<?> iterator, char separator) {
    // handle null, zero and one elements before building a buffer
    if (iterator == null) {
        return null;
    }
    if (!iterator.hasNext()) {
        return EMPTY;
    }
    Object first = iterator.next();
    if (!iterator.hasNext()) {
        return ObjectUtils.toString(first);
    }
    // two or more elements
    // Java default is 16, probably too small
    StringBuilder buf = new StringBuilder(256);
    if (first != null) {
        buf.append(first);
    }
    while (iterator.hasNext()) {
        buf.append(separator);
        Object obj = iterator.next();
        if (obj != null) {
            buf.append(obj);
        }
    }
    return buf.toString();
}","public void test2811248() throws Throwable {
    String string0 = StringUtils.chop(""p{InCombiningDiacriticalMarks}+"");
    int int0 = StringUtils.getLevenshteinDistance((CharSequence) ""p{InCombiningDiacriticalMarks}"", (CharSequence) ""p{InCombiningDiacriticalMarks}+"", 1975);
    boolean boolean0 = StringUtils.containsNone((CharSequence) ""p{InCombiningDiacriticalMarks}+"", ""p{InCombiningDiacriticalMarks}+"");
    char[] charArray0 = new char[4];
    charArray0[0] = 'Z';
    charArray0[1] = 'S';
    charArray0[2] = 'E';
    charArray0[3] = 'c';
    boolean boolean1 = StringUtils.containsOnly((CharSequence) ""p{InCombiningDiacriticalMarks}"", charArray0);
    String string1 = StringUtils.substringBefore(""(m'~h1DlVpMUe"", ""3jL9%"");
    boolean boolean2 = StringUtils.containsNone((CharSequence) ""(m'~h1DlVpMUe"", charArray0);
    boolean boolean3 = StringUtils.isNumeric(""p{InCombiningDiacriticalMarks}"");
    boolean boolean4 = StringUtils.isAllUpperCase(""(m'~h1DlVpMUe"");
    int int1 = StringUtils.getLevenshteinDistance((CharSequence) ""p{InCombiningDiacriticalMarks}"", (CharSequence) ""(m'~h1DlVpMUe"", 128);
    String string2 = StringUtils.chop(""p{InCombiningDiacriticalMarks}+"");
    String string3 = StringUtils.difference(""(m'~h1DlVpMUe"", ""3jL9%"");
    String string4 = StringUtils.removeStart(""p{InCombiningDiacriticalMarks}"", ""p{InCombiningDiacriticalMarks}"");
    LinkedList<String> linkedList0 = new LinkedList<String>();
    boolean boolean5 = linkedList0.add(""v>Bqb>JG:!j+4'(BF"");
    ListIterator<String> listIterator0 = linkedList0.listIterator();
    String string5 = StringUtils.join((Iterator<?>) listIterator0, 'Z');
    assertNotNull(string5);
}","/**
 * <p>Joins the elements of the provided {@code Iterator} into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list. Null objects or empty
 * strings within the iteration are represented by empty strings.</p>
 *
 * <p>See the examples here: {@link #join(Object[],char)}. </p>
 *
 * @param iterator  the {@code Iterator} of values to join together, may be null
 * @param separator  the separator character to use
 * @return the joined String, {@code null} if null iterator input
 * @since 2.0
 */"
"// Delete
//-----------------------------------------------------------------------
/**
 * <p>Deletes all whitespaces from a String as defined by
 * {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.deleteWhitespace(null)         = null
 * StringUtils.deleteWhitespace("""")           = """"
 * StringUtils.deleteWhitespace(""abc"")        = ""abc""
 * StringUtils.deleteWhitespace(""   ab  c  "") = ""abc""
 * </pre>
 *
 * @param str  the String to delete whitespace from, may be null
 * @return the String without whitespaces, {@code null} if null String input
 */
public static String deleteWhitespace(String str) {
    if (isEmpty(str)) {
        return str;
    }
    int sz = str.length();
    char[] chs = new char[sz];
    int count = 0;
    for (int i = 0; i < sz; i++) {
        if (!Character.isWhitespace(str.charAt(i))) {
            chs[count++] = str.charAt(i);
        }
    }
    if (count == sz) {
        return str;
    }
    return new String(chs, 0, count);
}","public void test2811254() throws Throwable {
    String string0 = StringUtils.chop(""p{InCombiningDiacriticalMarks}+"");
    int int0 = StringUtils.getLevenshteinDistance((CharSequence) ""p{InCombiningDiacriticalMarks}"", (CharSequence) ""p{InCombiningDiacriticalMarks}+"", 1975);
    boolean boolean0 = StringUtils.containsNone((CharSequence) ""p{InCombiningDiacriticalMarks}+"", ""p{InCombiningDiacriticalMarks}+"");
    char[] charArray0 = new char[4];
    charArray0[0] = 'Z';
    charArray0[1] = 'S';
    charArray0[2] = 'E';
    charArray0[3] = 'c';
    boolean boolean1 = StringUtils.containsOnly((CharSequence) ""p{InCombiningDiacriticalMarks}"", charArray0);
    String string1 = StringUtils.substringBefore(""(m'~h1DlVpMUe"", ""3jL9%"");
    boolean boolean2 = StringUtils.containsNone((CharSequence) ""(m'~h1DlVpMUe"", charArray0);
    boolean boolean3 = StringUtils.isNumeric(""p{InCombiningDiacriticalMarks}"");
    boolean boolean4 = StringUtils.isAllUpperCase(""(m'~h1DlVpMUe"");
    int int1 = StringUtils.getLevenshteinDistance((CharSequence) ""p{InCombiningDiacriticalMarks}"", (CharSequence) ""(m'~h1DlVpMUe"", 128);
    String string2 = StringUtils.chop(""p{InCombiningDiacriticalMarks}+"");
    String string3 = StringUtils.difference(""(m'~h1DlVpMUe"", ""3jL9%"");
    String string4 = StringUtils.removeStart(""p{InCombiningDiacriticalMarks}"", ""p{InCombiningDiacriticalMarks}"");
    LinkedList<String> linkedList0 = new LinkedList<String>();
    boolean boolean5 = linkedList0.add(""v>Bqb>JG:!j+4'(BF"");
    ListIterator<String> listIterator0 = linkedList0.listIterator();
    String string5 = StringUtils.join((Iterator<?>) listIterator0, 'Z');
    String string6 = StringUtils.deleteWhitespace(""(m'~h1DlVpMUe"");
    assertNotNull(string6);
}",""
"public static String substringBeforeLast(String str, String separator) {
    if (isEmpty(str) || isEmpty(separator)) {
        return str;
    }
    int pos = str.lastIndexOf(separator);
    if (pos == INDEX_NOT_FOUND) {
        return str;
    }
    return str.substring(0, pos);
}","public void test2811262() throws Throwable {
    String string0 = StringUtils.chop(""p{InCombiningDiacriticalMarks}+"");
    int int0 = StringUtils.getLevenshteinDistance((CharSequence) ""p{InCombiningDiacriticalMarks}"", (CharSequence) ""p{InCombiningDiacriticalMarks}+"", 1975);
    boolean boolean0 = StringUtils.containsNone((CharSequence) ""p{InCombiningDiacriticalMarks}+"", ""p{InCombiningDiacriticalMarks}+"");
    char[] charArray0 = new char[4];
    charArray0[0] = 'Z';
    charArray0[1] = 'S';
    charArray0[2] = 'E';
    charArray0[3] = 'c';
    boolean boolean1 = StringUtils.containsOnly((CharSequence) ""p{InCombiningDiacriticalMarks}"", charArray0);
    String string1 = StringUtils.substringBefore(""(m'~h1DlVpMUe"", ""3jL9%"");
    boolean boolean2 = StringUtils.containsNone((CharSequence) ""(m'~h1DlVpMUe"", charArray0);
    boolean boolean3 = StringUtils.isNumeric(""p{InCombiningDiacriticalMarks}"");
    boolean boolean4 = StringUtils.isAllUpperCase(""(m'~h1DlVpMUe"");
    int int1 = StringUtils.getLevenshteinDistance((CharSequence) ""p{InCombiningDiacriticalMarks}"", (CharSequence) ""(m'~h1DlVpMUe"", 128);
    String string2 = StringUtils.chop(""p{InCombiningDiacriticalMarks}+"");
    String string3 = StringUtils.difference(""(m'~h1DlVpMUe"", ""3jL9%"");
    String string4 = StringUtils.removeStart(""p{InCombiningDiacriticalMarks}"", ""p{InCombiningDiacriticalMarks}"");
    LinkedList<String> linkedList0 = new LinkedList<String>();
    boolean boolean5 = linkedList0.add(""v>Bqb>JG:!j+4'(BF"");
    ListIterator<String> listIterator0 = linkedList0.listIterator();
    String string5 = StringUtils.join((Iterator<?>) listIterator0, 'Z');
    String string6 = StringUtils.deleteWhitespace(""(m'~h1DlVpMUe"");
    String string7 = StringUtils.substringBeforeLast(""The character must not be null"", ""3jL9%"");
    assertNotNull(string7);
}","/**
 * <p>Gets the substring before the last occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A {@code null} string input will return {@code null}.
 * An empty ("""") string input will return the empty string.
 * An empty or {@code null} separator will return the input string.</p>
 *
 * <p>If nothing is found, the string input is returned.</p>
 *
 * <pre>
 * StringUtils.substringBeforeLast(null, *)      = null
 * StringUtils.substringBeforeLast("""", *)        = """"
 * StringUtils.substringBeforeLast(""abcba"", ""b"") = ""abc""
 * StringUtils.substringBeforeLast(""abc"", ""c"")   = ""ab""
 * StringUtils.substringBeforeLast(""a"", ""a"")     = """"
 * StringUtils.substringBeforeLast(""a"", ""z"")     = ""a""
 * StringUtils.substringBeforeLast(""a"", null)    = ""a""
 * StringUtils.substringBeforeLast(""a"", """")      = ""a""
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring before the last occurrence of the separator,
 *  {@code null} if null String input
 * @since 2.0
 */"
"public static boolean isNumeric(CharSequence cs) {
    if (cs == null || cs.length() == 0) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isDigit(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test2821271() throws Throwable {
    boolean boolean0 = StringUtils.isNumeric((CharSequence) null);
    assertFalse(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only unicode digits.
 * A decimal point is not a unicode digit and returns false.</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty CharSequence (length()=0) will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.isNumeric(null)   = false
 * StringUtils.isNumeric("""")     = false
 * StringUtils.isNumeric(""  "")   = false
 * StringUtils.isNumeric(""123"")  = true
 * StringUtils.isNumeric(""12 3"") = false
 * StringUtils.isNumeric(""ab2c"") = false
 * StringUtils.isNumeric(""12-3"") = false
 * StringUtils.isNumeric(""12.3"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if only contains digits, and is non-null
 * @since 3.0 Changed signature from isNumeric(String) to isNumeric(CharSequence)
 * @since 3.0 Changed """" to return false and not true
 */"
"public static int length(CharSequence cs) {
    return cs == null ? 0 : cs.length();
}","public void test2821272() throws Throwable {
    boolean boolean0 = StringUtils.isNumeric((CharSequence) null);
    int int0 = StringUtils.length((CharSequence) null);
    assertEquals(0, int0);
}","/**
 * Gets a CharSequence length or {@code 0} if the CharSequence is
 * {@code null}.
 *
 * @param cs
 *            a CharSequence or {@code null}
 * @return CharSequence length or {@code 0} if the CharSequence is
 *         {@code null}.
 * @since 2.4
 * @since 3.0 Changed signature from length(String) to length(CharSequence)
 */"
"// Overlay
//-----------------------------------------------------------------------
/**
 * <p>Overlays part of a String with another String.</p>
 *
 * <p>A {@code null} string input returns {@code null}.
 * A negative index is treated as zero.
 * An index greater than the string length is treated as the string length.
 * The start index is always the smaller of the two indices.</p>
 *
 * <pre>
 * StringUtils.overlay(null, *, *, *)            = null
 * StringUtils.overlay("""", ""abc"", 0, 0)          = ""abc""
 * StringUtils.overlay(""abcdef"", null, 2, 4)     = ""abef""
 * StringUtils.overlay(""abcdef"", """", 2, 4)       = ""abef""
 * StringUtils.overlay(""abcdef"", """", 4, 2)       = ""abef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 2, 4)   = ""abzzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 4, 2)   = ""abzzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", -1, 4)  = ""zzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 2, 8)   = ""abzzzz""
 * StringUtils.overlay(""abcdef"", ""zzzz"", -2, -3) = ""zzzzabcdef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 8, 10)  = ""abcdefzzzz""
 * </pre>
 *
 * @param str  the String to do overlaying in, may be null
 * @param overlay  the String to overlay, may be null
 * @param start  the position to start overlaying at
 * @param end  the position to stop overlaying before
 * @return overlayed String, {@code null} if null String input
 * @since 2.0
 */
public static String overlay(String str, String overlay, int start, int end) {
    if (str == null) {
        return null;
    }
    if (overlay == null) {
        overlay = EMPTY;
    }
    int len = str.length();
    if (start < 0) {
        start = 0;
    }
    if (start > len) {
        start = len;
    }
    if (end < 0) {
        end = 0;
    }
    if (end > len) {
        end = len;
    }
    if (start > end) {
        int temp = start;
        start = end;
        end = temp;
    }
    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();
}","public void test2821273() throws Throwable {
    boolean boolean0 = StringUtils.isNumeric((CharSequence) null);
    int int0 = StringUtils.length((CharSequence) null);
    String string0 = StringUtils.overlay(""S)ne)L/"", ""?P]})Ye)okq3&4cv"", 0, 1);
    assertNotNull(string0);
}",""
"// IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the first index within a CharSequence, handling {@code null}.
 * This method uses {@link String#indexOf(int, int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("""") CharSequence will return {@code INDEX_NOT_FOUND (-1)}.</p>
 *
 * <pre>
 * StringUtils.indexOf(null, *)         = -1
 * StringUtils.indexOf("""", *)           = -1
 * StringUtils.indexOf(""aabaabaa"", 'a') = 0
 * StringUtils.indexOf(""aabaabaa"", 'b') = 2
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @return the first index of the search character,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from indexOf(String, int) to indexOf(CharSequence, int)
 */
public static int indexOf(CharSequence seq, int searchChar) {
    if (isEmpty(seq)) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.indexOf(seq, searchChar, 0);
}","public void test2821275() throws Throwable {
    boolean boolean0 = StringUtils.isNumeric((CharSequence) null);
    int int0 = StringUtils.length((CharSequence) null);
    String string0 = StringUtils.overlay(""S)ne)L/"", ""?P]})Ye)okq3&4cv"", 0, 1);
    int int1 = StringUtils.indexOf((CharSequence) null, (-3107));
    assertEquals((-1), int1);
}",""
"public static boolean isAlphanumeric(CharSequence cs) {
    if (cs == null || cs.length() == 0) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isLetterOrDigit(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test2821277() throws Throwable {
    boolean boolean0 = StringUtils.isNumeric((CharSequence) null);
    int int0 = StringUtils.length((CharSequence) null);
    String string0 = StringUtils.overlay(""S)ne)L/"", ""?P]})Ye)okq3&4cv"", 0, 1);
    int int1 = StringUtils.indexOf((CharSequence) null, (-3107));
    boolean boolean1 = StringUtils.isAlphanumeric((CharSequence) null);
    assertFalse(boolean1);
}","/**
 * <p>Checks if the CharSequence contains only unicode letters or digits.</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty CharSequence (length()=0) will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.isAlphanumeric(null)   = false
 * StringUtils.isAlphanumeric("""")     = false
 * StringUtils.isAlphanumeric(""  "")   = false
 * StringUtils.isAlphanumeric(""abc"")  = true
 * StringUtils.isAlphanumeric(""ab c"") = false
 * StringUtils.isAlphanumeric(""ab2c"") = true
 * StringUtils.isAlphanumeric(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if only contains letters or digits,
 *  and is non-null
 * @since 3.0 Changed signature from isAlphanumeric(String) to isAlphanumeric(CharSequence)
 * @since 3.0 Changed """" to return false and not true
 */"
"public static String abbreviate(String str, int offset, int maxWidth) {
    if (str == null) {
        return null;
    }
    if (maxWidth < 4) {
        throw new IllegalArgumentException(""Minimum abbreviation width is 4"");
    }
    if (str.length() <= maxWidth) {
        return str;
    }
    if (offset > str.length()) {
        offset = str.length();
    }
    if ((str.length() - offset) < (maxWidth - 3)) {
        offset = str.length() - (maxWidth - 3);
    }
    final String abrevMarker = ""..."";
    if (offset <= 4) {
        return str.substring(0, maxWidth - 3) + abrevMarker;
    }
    if (maxWidth < 7) {
        throw new IllegalArgumentException(""Minimum abbreviation width with offset is 7"");
    }
    if ((offset + (maxWidth - 3)) < str.length()) {
        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);
    }
    return abrevMarker + str.substring(str.length() - (maxWidth - 3));
}","public void test2821279() throws Throwable {
    boolean boolean0 = StringUtils.isNumeric((CharSequence) null);
    int int0 = StringUtils.length((CharSequence) null);
    String string0 = StringUtils.overlay(""S)ne)L/"", ""?P]})Ye)okq3&4cv"", 0, 1);
    int int1 = StringUtils.indexOf((CharSequence) null, (-3107));
    boolean boolean1 = StringUtils.isAlphanumeric((CharSequence) null);
    String string1 = StringUtils.abbreviate(""S)ne)L/"", 1, 17);
    assertNotNull(string1);
}","/**
 * <p>Abbreviates a String using ellipses. This will turn
 * ""Now is the time for all good men"" into ""...is the time for...""</p>
 *
 * <p>Works like {@code abbreviate(String, int)}, but allows you to specify
 * a ""left edge"" offset.  Note that this left edge is not necessarily going to
 * be the leftmost character in the result, or the first character following the
 * ellipses, but it will appear somewhere in the result.
 *
 * <p>In no case will it return a String of length greater than
 * {@code maxWidth}.</p>
 *
 * <pre>
 * StringUtils.abbreviate(null, *, *)                = null
 * StringUtils.abbreviate("""", 0, 4)                  = """"
 * StringUtils.abbreviate(""abcdefghijklmno"", -1, 10) = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 0, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 1, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 4, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 5, 10)  = ""...fghi...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 6, 10)  = ""...ghij...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 8, 10)  = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghijklmno"", 10, 10) = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghijklmno"", 12, 10) = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghij"", 0, 3)        = IllegalArgumentException
 * StringUtils.abbreviate(""abcdefghij"", 5, 6)        = IllegalArgumentException
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param offset  left edge of source String
 * @param maxWidth  maximum length of result String, must be at least 4
 * @return abbreviated String, {@code null} if null String input
 * @throws IllegalArgumentException if the width is too small
 * @since 2.0
 */"
"public static String stripEnd(String str, String stripChars) {
    int end;
    if (str == null || (end = str.length()) == 0) {
        return str;
    }
    if (stripChars == null) {
        while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) {
            end--;
        }
    } else if (stripChars.length() == 0) {
        return str;
    } else {
        while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) {
            end--;
        }
    }
    return str.substring(0, end);
}","public void test2821282() throws Throwable {
    boolean boolean0 = StringUtils.isNumeric((CharSequence) null);
    int int0 = StringUtils.length((CharSequence) null);
    String string0 = StringUtils.overlay(""S)ne)L/"", ""?P]})Ye)okq3&4cv"", 0, 1);
    int int1 = StringUtils.indexOf((CharSequence) null, (-3107));
    boolean boolean1 = StringUtils.isAlphanumeric((CharSequence) null);
    String string1 = StringUtils.abbreviate(""S)ne)L/"", 1, 17);
    String string2 = StringUtils.stripEnd(""?P]})Ye)okq3&4cv"", ""S)ne)L/"");
    assertNotNull(string2);
}","/**
 * <p>Strips any of a set of characters from the end of a String.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * An empty string ("""") input returns the empty string.</p>
 *
 * <p>If the stripChars String is {@code null}, whitespace is
 * stripped as defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripEnd(null, *)          = null
 * StringUtils.stripEnd("""", *)            = """"
 * StringUtils.stripEnd(""abc"", """")        = ""abc""
 * StringUtils.stripEnd(""abc"", null)      = ""abc""
 * StringUtils.stripEnd(""  abc"", null)    = ""  abc""
 * StringUtils.stripEnd(""abc  "", null)    = ""abc""
 * StringUtils.stripEnd("" abc "", null)    = "" abc""
 * StringUtils.stripEnd(""  abcyx"", ""xyz"") = ""  abc""
 * StringUtils.stripEnd(""120.00"", "".0"")   = ""12""
 * </pre>
 *
 * @param str  the String to remove characters from, may be null
 * @param stripChars  the set of characters to remove, null treated as whitespace
 * @return the stripped String, {@code null} if null String input
 */"
"public static String abbreviateMiddle(String str, String middle, int length) {
    if (isEmpty(str) || isEmpty(middle)) {
        return str;
    }
    if (length >= str.length() || length < (middle.length() + 2)) {
        return str;
    }
    int targetSting = length - middle.length();
    int startOffset = targetSting / 2 + targetSting % 2;
    int endOffset = str.length() - targetSting / 2;
    StringBuilder builder = new StringBuilder(length);
    builder.append(str.substring(0, startOffset));
    builder.append(middle);
    builder.append(str.substring(endOffset));
    return builder.toString();
}","public void test2821286() throws Throwable {
    boolean boolean0 = StringUtils.isNumeric((CharSequence) null);
    int int0 = StringUtils.length((CharSequence) null);
    String string0 = StringUtils.overlay(""S)ne)L/"", ""?P]})Ye)okq3&4cv"", 0, 1);
    int int1 = StringUtils.indexOf((CharSequence) null, (-3107));
    boolean boolean1 = StringUtils.isAlphanumeric((CharSequence) null);
    String string1 = StringUtils.abbreviate(""S)ne)L/"", 1, 17);
    String string2 = StringUtils.stripEnd(""?P]})Ye)okq3&4cv"", ""S)ne)L/"");
    String string3 = StringUtils.abbreviateMiddle(""ciX?-maH5XWZ("", ""?P]})Ye)okq3&4cv)ne)L/"", (-1));
    assertNotNull(string3);
}","/**
 * <p>Abbreviates a String to the length passed, replacing the middle characters with the supplied
 * replacement String.</p>
 *
 * <p>This abbreviation only occurs if the following criteria is met:
 * <ul>
 * <li>Neither the String for abbreviation nor the replacement String are null or empty </li>
 * <li>The length to truncate to is less than the length of the supplied String</li>
 * <li>The length to truncate to is greater than 0</li>
 * <li>The abbreviated String will have enough room for the length supplied replacement String
 * and the first and last characters of the supplied String for abbreviation</li>
 * </ul>
 * Otherwise, the returned String will be the same as the supplied String for abbreviation.
 * </p>
 *
 * <pre>
 * StringUtils.abbreviateMiddle(null, null, 0)      = null
 * StringUtils.abbreviateMiddle(""abc"", null, 0)      = ""abc""
 * StringUtils.abbreviateMiddle(""abc"", ""."", 0)      = ""abc""
 * StringUtils.abbreviateMiddle(""abc"", ""."", 3)      = ""abc""
 * StringUtils.abbreviateMiddle(""abcdef"", ""."", 4)     = ""ab.f""
 * </pre>
 *
 * @param str  the String to abbreviate, may be null
 * @param middle the String to replace the middle characters with, may be null
 * @param length the length to abbreviate {@code str} to.
 * @return the abbreviated String if the above criteria is met, or the original String supplied for abbreviation.
 * @since 2.5
 */"
"public static int indexOf(CharSequence seq, CharSequence searchSeq) {
    if (seq == null || searchSeq == null) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.indexOf(seq, searchSeq, 0);
}","public void test2821291() throws Throwable {
    boolean boolean0 = StringUtils.isNumeric((CharSequence) null);
    int int0 = StringUtils.length((CharSequence) null);
    String string0 = StringUtils.overlay(""S)ne)L/"", ""?P]})Ye)okq3&4cv"", 0, 1);
    int int1 = StringUtils.indexOf((CharSequence) null, (-3107));
    boolean boolean1 = StringUtils.isAlphanumeric((CharSequence) null);
    String string1 = StringUtils.abbreviate(""S)ne)L/"", 1, 17);
    String string2 = StringUtils.stripEnd(""?P]})Ye)okq3&4cv"", ""S)ne)L/"");
    String string3 = StringUtils.abbreviateMiddle(""ciX?-maH5XWZ("", ""?P]})Ye)okq3&4cv)ne)L/"", (-1));
    int int2 = StringUtils.indexOf((CharSequence) null, (CharSequence) ""S)ne)L/"");
    assertEquals((-1), int2);
}","/**
 * <p>Finds the first index within a CharSequence, handling {@code null}.
 * This method uses {@link String#indexOf(String, int)} if possible.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOf(null, *)          = -1
 * StringUtils.indexOf(*, null)          = -1
 * StringUtils.indexOf("""", """")           = 0
 * StringUtils.indexOf("""", *)            = -1 (except when * = """")
 * StringUtils.indexOf(""aabaabaa"", ""a"")  = 0
 * StringUtils.indexOf(""aabaabaa"", ""b"")  = 2
 * StringUtils.indexOf(""aabaabaa"", ""ab"") = 1
 * StringUtils.indexOf(""aabaabaa"", """")   = 0
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchSeq  the CharSequence to find, may be null
 * @return the first index of the search CharSequence,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from indexOf(String, String) to indexOf(CharSequence, CharSequence)
 */"
"// Overlay
//-----------------------------------------------------------------------
/**
 * <p>Overlays part of a String with another String.</p>
 *
 * <p>A {@code null} string input returns {@code null}.
 * A negative index is treated as zero.
 * An index greater than the string length is treated as the string length.
 * The start index is always the smaller of the two indices.</p>
 *
 * <pre>
 * StringUtils.overlay(null, *, *, *)            = null
 * StringUtils.overlay("""", ""abc"", 0, 0)          = ""abc""
 * StringUtils.overlay(""abcdef"", null, 2, 4)     = ""abef""
 * StringUtils.overlay(""abcdef"", """", 2, 4)       = ""abef""
 * StringUtils.overlay(""abcdef"", """", 4, 2)       = ""abef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 2, 4)   = ""abzzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 4, 2)   = ""abzzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", -1, 4)  = ""zzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 2, 8)   = ""abzzzz""
 * StringUtils.overlay(""abcdef"", ""zzzz"", -2, -3) = ""zzzzabcdef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 8, 10)  = ""abcdefzzzz""
 * </pre>
 *
 * @param str  the String to do overlaying in, may be null
 * @param overlay  the String to overlay, may be null
 * @param start  the position to start overlaying at
 * @param end  the position to stop overlaying before
 * @return overlayed String, {@code null} if null String input
 * @since 2.0
 */
public static String overlay(String str, String overlay, int start, int end) {
    if (str == null) {
        return null;
    }
    if (overlay == null) {
        overlay = EMPTY;
    }
    int len = str.length();
    if (start < 0) {
        start = 0;
    }
    if (start > len) {
        start = len;
    }
    if (end < 0) {
        end = 0;
    }
    if (end > len) {
        end = len;
    }
    if (start > end) {
        int temp = start;
        start = end;
        end = temp;
    }
    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();
}","public void test2821294() throws Throwable {
    boolean boolean0 = StringUtils.isNumeric((CharSequence) null);
    int int0 = StringUtils.length((CharSequence) null);
    String string0 = StringUtils.overlay(""S)ne)L/"", ""?P]})Ye)okq3&4cv"", 0, 1);
    int int1 = StringUtils.indexOf((CharSequence) null, (-3107));
    boolean boolean1 = StringUtils.isAlphanumeric((CharSequence) null);
    String string1 = StringUtils.abbreviate(""S)ne)L/"", 1, 17);
    String string2 = StringUtils.stripEnd(""?P]})Ye)okq3&4cv"", ""S)ne)L/"");
    String string3 = StringUtils.abbreviateMiddle(""ciX?-maH5XWZ("", ""?P]})Ye)okq3&4cv)ne)L/"", (-1));
    int int2 = StringUtils.indexOf((CharSequence) null, (CharSequence) ""S)ne)L/"");
    String string4 = StringUtils.overlay(""?P]})Ye)okq3&4cv)ne)L/"", ""?#H:|Iy>mdGE|hhc)"", 17, 469);
    assertNotNull(string4);
}",""
"public static String right(String str, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0) {
        return EMPTY;
    }
    if (str.length() <= len) {
        return str;
    }
    return str.substring(str.length() - len);
}","public void test2821300() throws Throwable {
    boolean boolean0 = StringUtils.isNumeric((CharSequence) null);
    int int0 = StringUtils.length((CharSequence) null);
    String string0 = StringUtils.overlay(""S)ne)L/"", ""?P]})Ye)okq3&4cv"", 0, 1);
    int int1 = StringUtils.indexOf((CharSequence) null, (-3107));
    boolean boolean1 = StringUtils.isAlphanumeric((CharSequence) null);
    String string1 = StringUtils.abbreviate(""S)ne)L/"", 1, 17);
    String string2 = StringUtils.stripEnd(""?P]})Ye)okq3&4cv"", ""S)ne)L/"");
    String string3 = StringUtils.abbreviateMiddle(""ciX?-maH5XWZ("", ""?P]})Ye)okq3&4cv)ne)L/"", (-1));
    int int2 = StringUtils.indexOf((CharSequence) null, (CharSequence) ""S)ne)L/"");
    String string4 = StringUtils.overlay(""?P]})Ye)okq3&4cv)ne)L/"", ""?#H:|Iy>mdGE|hhc)"", 17, 469);
    String string5 = StringUtils.right(""InvocationTargetException occurred"", (-1));
    assertNotNull(string5);
}","/**
 * <p>Gets the rightmost {@code len} characters of a String.</p>
 *
 * <p>If {@code len} characters are not available, or the String
 * is {@code null}, the String will be returned without an
 * an exception. An empty String is returned if len is negative.</p>
 *
 * <pre>
 * StringUtils.right(null, *)    = null
 * StringUtils.right(*, -ve)     = """"
 * StringUtils.right("""", *)      = """"
 * StringUtils.right(""abc"", 0)   = """"
 * StringUtils.right(""abc"", 2)   = ""bc""
 * StringUtils.right(""abc"", 4)   = ""abc""
 * </pre>
 *
 * @param str  the String to get the rightmost characters from, may be null
 * @param len  the length of the required String
 * @return the rightmost characters, {@code null} if null String input
 */"
"public static boolean isNumeric(CharSequence cs) {
    if (cs == null || cs.length() == 0) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isDigit(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test2821307() throws Throwable {
    boolean boolean0 = StringUtils.isNumeric((CharSequence) null);
    int int0 = StringUtils.length((CharSequence) null);
    String string0 = StringUtils.overlay(""S)ne)L/"", ""?P]})Ye)okq3&4cv"", 0, 1);
    int int1 = StringUtils.indexOf((CharSequence) null, (-3107));
    boolean boolean1 = StringUtils.isAlphanumeric((CharSequence) null);
    String string1 = StringUtils.abbreviate(""S)ne)L/"", 1, 17);
    String string2 = StringUtils.stripEnd(""?P]})Ye)okq3&4cv"", ""S)ne)L/"");
    String string3 = StringUtils.abbreviateMiddle(""ciX?-maH5XWZ("", ""?P]})Ye)okq3&4cv)ne)L/"", (-1));
    int int2 = StringUtils.indexOf((CharSequence) null, (CharSequence) ""S)ne)L/"");
    String string4 = StringUtils.overlay(""?P]})Ye)okq3&4cv)ne)L/"", ""?#H:|Iy>mdGE|hhc)"", 17, 469);
    String string5 = StringUtils.right(""InvocationTargetException occurred"", (-1));
    boolean boolean2 = StringUtils.isNumeric("""");
    assertFalse(boolean2);
}","/**
 * <p>Checks if the CharSequence contains only unicode digits.
 * A decimal point is not a unicode digit and returns false.</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty CharSequence (length()=0) will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.isNumeric(null)   = false
 * StringUtils.isNumeric("""")     = false
 * StringUtils.isNumeric(""  "")   = false
 * StringUtils.isNumeric(""123"")  = true
 * StringUtils.isNumeric(""12 3"") = false
 * StringUtils.isNumeric(""ab2c"") = false
 * StringUtils.isNumeric(""12-3"") = false
 * StringUtils.isNumeric(""12.3"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if only contains digits, and is non-null
 * @since 3.0 Changed signature from isNumeric(String) to isNumeric(CharSequence)
 * @since 3.0 Changed """" to return false and not true
 */"
"public static <T extends CharSequence> T defaultIfBlank(T str, T defaultStr) {
    return StringUtils.isBlank(str) ? defaultStr : str;
}","public void test2821310() throws Throwable {
    boolean boolean0 = StringUtils.isNumeric((CharSequence) null);
    int int0 = StringUtils.length((CharSequence) null);
    String string0 = StringUtils.overlay(""S)ne)L/"", ""?P]})Ye)okq3&4cv"", 0, 1);
    int int1 = StringUtils.indexOf((CharSequence) null, (-3107));
    boolean boolean1 = StringUtils.isAlphanumeric((CharSequence) null);
    String string1 = StringUtils.abbreviate(""S)ne)L/"", 1, 17);
    String string2 = StringUtils.stripEnd(""?P]})Ye)okq3&4cv"", ""S)ne)L/"");
    String string3 = StringUtils.abbreviateMiddle(""ciX?-maH5XWZ("", ""?P]})Ye)okq3&4cv)ne)L/"", (-1));
    int int2 = StringUtils.indexOf((CharSequence) null, (CharSequence) ""S)ne)L/"");
    String string4 = StringUtils.overlay(""?P]})Ye)okq3&4cv)ne)L/"", ""?#H:|Iy>mdGE|hhc)"", 17, 469);
    String string5 = StringUtils.right(""InvocationTargetException occurred"", (-1));
    boolean boolean2 = StringUtils.isNumeric("""");
    String string6 = StringUtils.defaultIfBlank(""[Q.GLM$"", ""java.text.Normalizer"");
    assertNotNull(string6);
}","/**
 * <p>Returns either the passed in CharSequence, or if the CharSequence is
 * whitespace, empty ("""") or {@code null}, the value of {@code defaultStr}.</p>
 *
 * <pre>
 * StringUtils.defaultIfBlank(null, ""NULL"")  = ""NULL""
 * StringUtils.defaultIfBlank("""", ""NULL"")    = ""NULL""
 * StringUtils.defaultIfBlank("" "", ""NULL"")   = ""NULL""
 * StringUtils.defaultIfBlank(""bat"", ""NULL"") = ""bat""
 * StringUtils.defaultIfBlank("""", null)      = null
 * </pre>
 * @param <T> the specific kind of CharSequence
 * @param str the CharSequence to check, may be null
 * @param defaultStr  the default CharSequence to return
 *  if the input is whitespace, empty ("""") or {@code null}, may be null
 * @return the passed in CharSequence, or the default
 * @see StringUtils#defaultString(String, String)
 */"
"// ContainsNone
//-----------------------------------------------------------------------
/**
 * <p>Checks that the CharSequence does not contain certain characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code true}.
 * A {@code null} invalid character array will return {@code true}.
 * An empty CharSequence (length()=0) always returns true.</p>
 *
 * <pre>
 * StringUtils.containsNone(null, *)       = true
 * StringUtils.containsNone(*, null)       = true
 * StringUtils.containsNone("""", *)         = true
 * StringUtils.containsNone(""ab"", '')      = true
 * StringUtils.containsNone(""abab"", 'xyz') = true
 * StringUtils.containsNone(""ab1"", 'xyz')  = true
 * StringUtils.containsNone(""abz"", 'xyz')  = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  an array of invalid chars, may be null
 * @return true if it contains none of the invalid chars, or is null
 * @since 2.0
 * @since 3.0 Changed signature from containsNone(String, char[]) to containsNone(CharSequence, char...)
 */
public static boolean containsNone(CharSequence cs, char... searchChars) {
    if (cs == null || searchChars == null) {
        return true;
    }
    int csLen = cs.length();
    int csLast = csLen - 1;
    int searchLen = searchChars.length;
    int searchLast = searchLen - 1;
    for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (Character.isHighSurrogate(ch)) {
                    if (j == searchLast) {
                        // missing low surrogate, fine, like String.indexOf(String)
                        return false;
                    }
                    if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
                        return false;
                    }
                } else {
                    // ch is in the Basic Multilingual Plane
                    return false;
                }
            }
        }
    }
    return true;
}","public void test2821318() throws Throwable {
    boolean boolean0 = StringUtils.isNumeric((CharSequence) null);
    int int0 = StringUtils.length((CharSequence) null);
    String string0 = StringUtils.overlay(""S)ne)L/"", ""?P]})Ye)okq3&4cv"", 0, 1);
    int int1 = StringUtils.indexOf((CharSequence) null, (-3107));
    boolean boolean1 = StringUtils.isAlphanumeric((CharSequence) null);
    String string1 = StringUtils.abbreviate(""S)ne)L/"", 1, 17);
    String string2 = StringUtils.stripEnd(""?P]})Ye)okq3&4cv"", ""S)ne)L/"");
    String string3 = StringUtils.abbreviateMiddle(""ciX?-maH5XWZ("", ""?P]})Ye)okq3&4cv)ne)L/"", (-1));
    int int2 = StringUtils.indexOf((CharSequence) null, (CharSequence) ""S)ne)L/"");
    String string4 = StringUtils.overlay(""?P]})Ye)okq3&4cv)ne)L/"", ""?#H:|Iy>mdGE|hhc)"", 17, 469);
    String string5 = StringUtils.right(""InvocationTargetException occurred"", (-1));
    boolean boolean2 = StringUtils.isNumeric("""");
    String string6 = StringUtils.defaultIfBlank(""[Q.GLM$"", ""java.text.Normalizer"");
    char[] charArray0 = new char[3];
    charArray0[0] = 'D';
    charArray0[1] = 'W';
    charArray0[2] = ')';
    boolean boolean3 = StringUtils.containsNone((CharSequence) ""?P]})Ye)okq3&4cv"", charArray0);
    assertEquals(3, charArray0.length);
}",""
"// See also Lucene's ASCIIFoldingFilter (Lucene 2.9) that replaces accented characters by their unaccented equivalent (and uncommited bug fix: https://issues.apache.org/jira/browse/LUCENE-1343?focusedCommentId=12858907&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12858907).
public static String stripAccents(String input) {
    if (input == null) {
        return null;
    }
    try {
        String result = null;
        if (java6Available) {
            result = removeAccentsJava6(input);
        } else if (sunAvailable) {
            result = removeAccentsSUN(input);
        } else {
            throw new UnsupportedOperationException(""The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM"");
        }
        // Note that none of the above methods correctly remove ligatures...
        return result;
    } catch (IllegalArgumentException iae) {
        throw new RuntimeException(""IllegalArgumentException occurred"", iae);
    } catch (IllegalAccessException iae) {
        throw new RuntimeException(""IllegalAccessException occurred"", iae);
    } catch (InvocationTargetException ite) {
        throw new RuntimeException(""InvocationTargetException occurred"", ite);
    } catch (SecurityException se) {
        throw new RuntimeException(""SecurityException occurred"", se);
    }
}","public void test2831324() throws Throwable {
    String string0 = StringUtils.stripAccents(""FF[zjaSYY>[-=pDMZi"");
    assertNotNull(string0);
}","/**
 * <p>Removes diacritics (~= accents) from a string. The case will not be altered.</p>
 * <p>For instance, '&agrave;' will be replaced by 'a'.</p>
 * <p>Note that ligatures will be left as is.</p>
 *
 * <p>This method will use the first available implementation of:
 * Java 6's {@link java.text.Normalizer}, Java 1.3&ndash;1.5's {@code sun.text.Normalizer}</p>
 *
 * <pre>
 * StringUtils.stripAccents(null)                = null
 * StringUtils.stripAccents("""")                  = """"
 * StringUtils.stripAccents(""control"")           = ""control""
 * StringUtils.stripAccents(""&ecute;clair"")      = ""eclair""
 * </pre>
 *
 * @param input String to be stripped
 * @return input text with diacritics removed
 *
 * @since 3.0
 */"
"public static String chomp(String str, String separator) {
    if (isEmpty(str) || separator == null) {
        return str;
    }
    if (str.endsWith(separator)) {
        return str.substring(0, str.length() - separator.length());
    }
    return str;
}","public void test2831326() throws Throwable {
    String string0 = StringUtils.stripAccents(""FF[zjaSYY>[-=pDMZi"");
    String string1 = StringUtils.chomp(""^&T>YsQa|P:6\"""", ""FF[zjaSYY>[-=pDMZi"");
    assertNotNull(string1);
}","/**
 * <p>Removes {@code separator} from the end of
 * {@code str} if it's there, otherwise leave it alone.</p>
 *
 * <p>NOTE: This method changed in version 2.0.
 * It now more closely matches Perl chomp.
 * For the previous behavior, use {@link #substringBeforeLast(String, String)}.
 * This method uses {@link String#endsWith(String)}.</p>
 *
 * <pre>
 * StringUtils.chomp(null, *)         = null
 * StringUtils.chomp("""", *)           = """"
 * StringUtils.chomp(""foobar"", ""bar"") = ""foo""
 * StringUtils.chomp(""foobar"", ""baz"") = ""foobar""
 * StringUtils.chomp(""foo"", ""foo"")    = """"
 * StringUtils.chomp(""foo "", ""foo"")   = ""foo ""
 * StringUtils.chomp("" foo"", ""foo"")   = "" ""
 * StringUtils.chomp(""foo"", ""foooo"")  = ""foo""
 * StringUtils.chomp(""foo"", """")       = ""foo""
 * StringUtils.chomp(""foo"", null)     = ""foo""
 * </pre>
 *
 * @param str  the String to chomp from, may be null
 * @param separator  separator String, may be null
 * @return String without trailing separator, {@code null} if null String input
 */"
"public static String capitalize(String str) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    return new StringBuilder(strLen).append(Character.toTitleCase(str.charAt(0))).append(str.substring(1)).toString();
}","public void test2831329() throws Throwable {
    String string0 = StringUtils.stripAccents(""FF[zjaSYY>[-=pDMZi"");
    String string1 = StringUtils.chomp(""^&T>YsQa|P:6\"""", ""FF[zjaSYY>[-=pDMZi"");
    String string2 = StringUtils.capitalize(""^&T>YsQa|P:6\"""");
    assertNotNull(string2);
}","/**
 * <p>Capitalizes a String changing the first letter to title case as
 * per {@link Character#toTitleCase(char)}. No other letters are changed.</p>
 *
 * <p>For a word based algorithm, see {@link org.apache.commons.lang3.text.WordUtils#capitalize(String)}.
 * A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.capitalize(null)  = null
 * StringUtils.capitalize("""")    = """"
 * StringUtils.capitalize(""cat"") = ""Cat""
 * StringUtils.capitalize(""cAt"") = ""CAt""
 * </pre>
 *
 * @param str the String to capitalize, may be null
 * @return the capitalized String, {@code null} if null String input
 * @see org.apache.commons.lang3.text.WordUtils#capitalize(String)
 * @see #uncapitalize(String)
 * @since 2.0
 */"
"public static String join(Iterator<?> iterator, char separator) {
    // handle null, zero and one elements before building a buffer
    if (iterator == null) {
        return null;
    }
    if (!iterator.hasNext()) {
        return EMPTY;
    }
    Object first = iterator.next();
    if (!iterator.hasNext()) {
        return ObjectUtils.toString(first);
    }
    // two or more elements
    // Java default is 16, probably too small
    StringBuilder buf = new StringBuilder(256);
    if (first != null) {
        buf.append(first);
    }
    while (iterator.hasNext()) {
        buf.append(separator);
        Object obj = iterator.next();
        if (obj != null) {
            buf.append(obj);
        }
    }
    return buf.toString();
}","public void test2831335() throws Throwable {
    String string0 = StringUtils.stripAccents(""FF[zjaSYY>[-=pDMZi"");
    String string1 = StringUtils.chomp(""^&T>YsQa|P:6\"""", ""FF[zjaSYY>[-=pDMZi"");
    String string2 = StringUtils.capitalize(""^&T>YsQa|P:6\"""");
    TreeSet<Integer> treeSet0 = new TreeSet<Integer>();
    Iterator<Integer> iterator0 = treeSet0.iterator();
    String string3 = StringUtils.join(iterator0, 'D');
    assertNotNull(string3);
}","/**
 * <p>Joins the elements of the provided {@code Iterator} into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list. Null objects or empty
 * strings within the iteration are represented by empty strings.</p>
 *
 * <p>See the examples here: {@link #join(Object[],char)}. </p>
 *
 * @param iterator  the {@code Iterator} of values to join together, may be null
 * @param separator  the separator character to use
 * @return the joined String, {@code null} if null iterator input
 * @since 2.0
 */"
"public static int getLevenshteinDistance(CharSequence s, CharSequence t, int threshold) {
    if (s == null || t == null) {
        throw new IllegalArgumentException(""Strings must not be null"");
    }
    if (threshold < 0) {
        throw new IllegalArgumentException(""Threshold must not be negative"");
    }
    /*
        This implementation only computes the distance if it's less than or equal to the
        threshold value, returning -1 if it's greater.  The advantage is performance: unbounded
        distance is O(nm), but a bound of k allows us to reduce it to O(km) time by only 
        computing a diagonal stripe of width 2k + 1 of the cost table.
        It is also possible to use this to compute the unbounded Levenshtein distance by starting
        the threshold at 1 and doubling each time until the distance is found; this is O(dm), where
        d is the distance.
        
        One subtlety comes from needing to ignore entries on the border of our stripe
        eg.
        p[] = |#|#|#|*
        d[] =  *|#|#|#|
        We must ignore the entry to the left of the leftmost member
        We must ignore the entry above the rightmost member
        
        Another subtlety comes from our stripe running off the matrix if the strings aren't
        of the same size.  Since string s is always swapped to be the shorter of the two, 
        the stripe will always run off to the upper right instead of the lower left of the matrix.
        
        As a concrete example, suppose s is of length 5, t is of length 7, and our threshold is 1.
        In this case we're going to walk a stripe of length 3.  The matrix would look like so:
        
           1 2 3 4 5
        1 |#|#| | | |
        2 |#|#|#| | |
        3 | |#|#|#| |
        4 | | |#|#|#|
        5 | | | |#|#|
        6 | | | | |#|
        7 | | | | | |

        Note how the stripe leads off the table as there is no possible way to turn a string of length 5
        into one of length 7 in edit distance of 1.
        
        Additionally, this implementation decreases memory usage by using two 
        single-dimensional arrays and swapping them back and forth instead of allocating
        an entire n by m matrix.  This requires a few minor changes, such as immediately returning 
        when it's detected that the stripe has run off the matrix and initially filling the arrays with
        large values so that entries we don't compute are ignored.

        See Algorithms on Strings, Trees and Sequences by Dan Gusfield for some discussion.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    // if one string is empty, the edit distance is necessarily the length of the other
    if (n == 0) {
        return m <= threshold ? m : -1;
    } else if (m == 0) {
        return n <= threshold ? n : -1;
    }
    if (n > m) {
        // swap the two strings to consume less memory
        CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    // 'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    // placeholder to assist in swapping p and d
    int[] _d;
    // fill in starting table values
    int boundary = Math.min(n, threshold) + 1;
    for (int i = 0; i < boundary; i++) {
        p[i] = i;
    }
    // these fills ensure that the value above the rightmost entry of our
    // stripe will be ignored in following loop iterations
    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);
    Arrays.fill(d, Integer.MAX_VALUE);
    // iterates through t
    for (int j = 1; j <= m; j++) {
        // jth character of t
        char t_j = t.charAt(j - 1);
        d[0] = j;
        // compute stripe indices, constrain to array size
        int min = Math.max(1, j - threshold);
        int max = Math.min(n, j + threshold);
        // the stripe may lead off of the table if s and t are of different sizes
        if (min > max) {
            return -1;
        }
        // ignore entry left of leftmost
        if (min > 1) {
            d[min - 1] = Integer.MAX_VALUE;
        }
        // iterates through [min, max] in s
        for (int i = min; i <= max; i++) {
            if (s.charAt(i - 1) == t_j) {
                // diagonally left and up
                d[i] = p[i - 1];
            } else {
                // 1 + minimum of cell to the left, to the top, diagonally left and up
                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);
            }
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // if p[n] is greater than the threshold, there's no guarantee on it being the correct
    // distance
    if (p[n] <= threshold) {
        return p[n];
    } else {
        return -1;
    }
}","public void test2831340() throws Throwable {
    String string0 = StringUtils.stripAccents(""FF[zjaSYY>[-=pDMZi"");
    String string1 = StringUtils.chomp(""^&T>YsQa|P:6\"""", ""FF[zjaSYY>[-=pDMZi"");
    String string2 = StringUtils.capitalize(""^&T>YsQa|P:6\"""");
    TreeSet<Integer> treeSet0 = new TreeSet<Integer>();
    Iterator<Integer> iterator0 = treeSet0.iterator();
    String string3 = StringUtils.join(iterator0, 'D');
    int int0 = StringUtils.getLevenshteinDistance((CharSequence) ""^&T>YsQa|P:6\"""", (CharSequence) ""^&T>YsQa|P:6\"""", 16);
    assertEquals(0, int0);
}","/**
 * <p>Find the Levenshtein distance between two Strings if it's less than or equal to a given
 * threshold.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>This implementation follows from Algorithms on Strings, Trees and Sequences by Dan Gusfield
 * and Chas Emerick's implementation of the Levenshtein distance algorithm from
 * <a href=""http://www.merriampark.com/ld.htm"">http://www.merriampark.com/ld.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, *, -1)               = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("""","""", 0)               = 0
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 8)       = 7
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 7)       = 7
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 6))      = -1
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"", 7) = 7
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"", 6) = -1
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"", 7) = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"", 6) = -1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @param threshold the target threshold, must not be negative
 * @return result distance, or {@code -1} if the distance would be greater than the threshold
 * @throws IllegalArgumentException if either String input {@code null} or negative threshold
 */"
"public static String repeat(char ch, int repeat) {
    char[] buf = new char[repeat];
    for (int i = repeat - 1; i >= 0; i--) {
        buf[i] = ch;
    }
    return new String(buf);
}","public void test2831341() throws Throwable {
    String string0 = StringUtils.stripAccents(""FF[zjaSYY>[-=pDMZi"");
    String string1 = StringUtils.chomp(""^&T>YsQa|P:6\"""", ""FF[zjaSYY>[-=pDMZi"");
    String string2 = StringUtils.capitalize(""^&T>YsQa|P:6\"""");
    TreeSet<Integer> treeSet0 = new TreeSet<Integer>();
    Iterator<Integer> iterator0 = treeSet0.iterator();
    String string3 = StringUtils.join(iterator0, 'D');
    int int0 = StringUtils.getLevenshteinDistance((CharSequence) ""^&T>YsQa|P:6\"""", (CharSequence) ""^&T>YsQa|P:6\"""", 16);
    String string4 = StringUtils.repeat('v', 0);
    assertNotNull(string4);
}","/**
 * <p>Returns padding using the specified delimiter repeated
 * to a given length.</p>
 *
 * <pre>
 * StringUtils.repeat(0, 'e')  = """"
 * StringUtils.repeat(3, 'e')  = ""eee""
 * StringUtils.repeat(-2, 'e') = """"
 * </pre>
 *
 * <p>Note: this method doesn't not support padding with
 * <a href=""http://www.unicode.org/glossary/#supplementary_character"">Unicode Supplementary Characters</a>
 * as they require a pair of {@code char}s to be represented.
 * If you are needing to support full I18N of your applications
 * consider using {@link #repeat(String, int)} instead.
 * </p>
 *
 * @param ch  character to repeat
 * @param repeat  number of times to repeat char, negative treated as zero
 * @return String with repeated character
 * @see #repeat(String, int)
 */"
"public static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal) {
    return ordinalIndexOf(str, searchStr, ordinal, false);
}","public void test2831347() throws Throwable {
    String string0 = StringUtils.stripAccents(""FF[zjaSYY>[-=pDMZi"");
    String string1 = StringUtils.chomp(""^&T>YsQa|P:6\"""", ""FF[zjaSYY>[-=pDMZi"");
    String string2 = StringUtils.capitalize(""^&T>YsQa|P:6\"""");
    TreeSet<Integer> treeSet0 = new TreeSet<Integer>();
    Iterator<Integer> iterator0 = treeSet0.iterator();
    String string3 = StringUtils.join(iterator0, 'D');
    int int0 = StringUtils.getLevenshteinDistance((CharSequence) ""^&T>YsQa|P:6\"""", (CharSequence) ""^&T>YsQa|P:6\"""", 16);
    String string4 = StringUtils.repeat('v', 0);
    int int1 = StringUtils.ordinalIndexOf(""FF[zjaSYY>[-=pDMZi"", """", 0);
    assertEquals((-1), int1);
}","/**
 * <p>Finds the n-th index within a CharSequence, handling {@code null}.
 * This method uses {@link String#indexOf(String)} if possible.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.ordinalIndexOf(null, *, *)          = -1
 * StringUtils.ordinalIndexOf(*, null, *)          = -1
 * StringUtils.ordinalIndexOf("""", """", *)           = 0
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""a"", 1)  = 0
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""a"", 2)  = 1
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""b"", 1)  = 2
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""b"", 2)  = 5
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""ab"", 1) = 1
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""ab"", 2) = 4
 * StringUtils.ordinalIndexOf(""aabaabaa"", """", 1)   = 0
 * StringUtils.ordinalIndexOf(""aabaabaa"", """", 2)   = 0
 * </pre>
 *
 * <p>Note that 'head(CharSequence str, int n)' may be implemented as: </p>
 *
 * <pre>
 *   str.substring(0, lastOrdinalIndexOf(str, ""\n"", n))
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @param ordinal  the n-th {@code searchStr} to find
 * @return the n-th index of the search CharSequence,
 *  {@code -1} ({@code INDEX_NOT_FOUND}) if no match or {@code null} string input
 * @since 2.1
 * @since 3.0 Changed signature from ordinalIndexOf(String, String, int) to ordinalIndexOf(CharSequence, CharSequence, int)
 */"
"public static boolean isWhitespace(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if ((Character.isWhitespace(cs.charAt(i)) == false)) {
            return false;
        }
    }
    return true;
}","public void test2831349() throws Throwable {
    String string0 = StringUtils.stripAccents(""FF[zjaSYY>[-=pDMZi"");
    String string1 = StringUtils.chomp(""^&T>YsQa|P:6\"""", ""FF[zjaSYY>[-=pDMZi"");
    String string2 = StringUtils.capitalize(""^&T>YsQa|P:6\"""");
    TreeSet<Integer> treeSet0 = new TreeSet<Integer>();
    Iterator<Integer> iterator0 = treeSet0.iterator();
    String string3 = StringUtils.join(iterator0, 'D');
    int int0 = StringUtils.getLevenshteinDistance((CharSequence) ""^&T>YsQa|P:6\"""", (CharSequence) ""^&T>YsQa|P:6\"""", 16);
    String string4 = StringUtils.repeat('v', 0);
    int int1 = StringUtils.ordinalIndexOf(""FF[zjaSYY>[-=pDMZi"", """", 0);
    boolean boolean0 = StringUtils.isWhitespace(""FF[zjaSYY>[-=pDMZi"");
    assertFalse(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only whitespace.</p>
 *
 * <p>{@code null} will return {@code false}.
 * An empty CharSequence (length()=0) will return {@code true}.</p>
 *
 * <pre>
 * StringUtils.isWhitespace(null)   = false
 * StringUtils.isWhitespace("""")     = true
 * StringUtils.isWhitespace(""  "")   = true
 * StringUtils.isWhitespace(""abc"")  = false
 * StringUtils.isWhitespace(""ab2c"") = false
 * StringUtils.isWhitespace(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if only contains whitespace, and is non-null
 * @since 2.0
 * @since 3.0 Changed signature from isWhitespace(String) to isWhitespace(CharSequence)
 */"
"public static String join(Object[] array, char separator, int startIndex, int endIndex) {
    if (array == null) {
        return null;
    }
    int noOfItems = (endIndex - startIndex);
    if (noOfItems <= 0) {
        return EMPTY;
    }
    StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}","public void test2831356() throws Throwable {
    String string0 = StringUtils.stripAccents(""FF[zjaSYY>[-=pDMZi"");
    String string1 = StringUtils.chomp(""^&T>YsQa|P:6\"""", ""FF[zjaSYY>[-=pDMZi"");
    String string2 = StringUtils.capitalize(""^&T>YsQa|P:6\"""");
    TreeSet<Integer> treeSet0 = new TreeSet<Integer>();
    Iterator<Integer> iterator0 = treeSet0.iterator();
    String string3 = StringUtils.join(iterator0, 'D');
    int int0 = StringUtils.getLevenshteinDistance((CharSequence) ""^&T>YsQa|P:6\"""", (CharSequence) ""^&T>YsQa|P:6\"""", 16);
    String string4 = StringUtils.repeat('v', 0);
    int int1 = StringUtils.ordinalIndexOf(""FF[zjaSYY>[-=pDMZi"", """", 0);
    boolean boolean0 = StringUtils.isWhitespace(""FF[zjaSYY>[-=pDMZi"");
    Object[] objectArray0 = new Object[4];
    Object object0 = new Object();
    objectArray0[0] = object0;
    Object object1 = new Object();
    objectArray0[1] = object1;
    objectArray0[2] = (Object) ""^&T>YsQa|P:6\"""";
    Object object2 = new Object();
    objectArray0[3] = object2;
    String string5 = StringUtils.join(objectArray0, 'D', (-1), Integer.MAX_VALUE);
    assertEquals(4, objectArray0.length);
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)               = null
 * StringUtils.join([], *)                 = """"
 * StringUtils.join([null], *)             = """"
 * StringUtils.join([""a"", ""b"", ""c""], ';')  = ""a;b;c""
 * StringUtils.join([""a"", ""b"", ""c""], null) = ""abc""
 * StringUtils.join([null, """", ""a""], ';')  = "";;a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use
 * @param startIndex the first index to start joining from.  It is
 * an error to pass in an end index past the end of the array
 * @param endIndex the index to stop joining from (exclusive). It is
 * an error to pass in an end index past the end of the array
 * @return the joined String, {@code null} if null array input
 * @since 2.0
 */"
"public static String center(String str, int size, char padChar) {
    if (str == null || size <= 0) {
        return str;
    }
    int strLen = str.length();
    int pads = size - strLen;
    if (pads <= 0) {
        return str;
    }
    str = leftPad(str, strLen + pads / 2, padChar);
    str = rightPad(str, size, padChar);
    return str;
}","public void test2841363() throws Throwable {
    String string0 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 169, 'x');
    assertNotNull(string0);
}","/**
 * <p>Centers a String in a larger String of size {@code size}.
 * Uses a supplied character as the value to pad the String with.</p>
 *
 * <p>If the size is less than the String length, the String is returned.
 * A {@code null} String returns {@code null}.
 * A negative size is treated as zero.</p>
 *
 * <pre>
 * StringUtils.center(null, *, *)     = null
 * StringUtils.center("""", 4, ' ')     = ""    ""
 * StringUtils.center(""ab"", -1, ' ')  = ""ab""
 * StringUtils.center(""ab"", 4, ' ')   = "" ab""
 * StringUtils.center(""abcd"", 2, ' ') = ""abcd""
 * StringUtils.center(""a"", 4, ' ')    = "" a  ""
 * StringUtils.center(""a"", 4, 'y')    = ""yayy""
 * </pre>
 *
 * @param str  the String to center, may be null
 * @param size  the int size of new String, negative treated as zero
 * @param padChar  the character to pad the new String with
 * @return centered String, {@code null} if null String input
 * @since 2.0
 */"
"public static String[] stripAll(String[] strs, String stripChars) {
    int strsLen;
    if (strs == null || (strsLen = strs.length) == 0) {
        return strs;
    }
    String[] newArr = new String[strsLen];
    for (int i = 0; i < strsLen; i++) {
        newArr[i] = strip(strs[i], stripChars);
    }
    return newArr;
}","public void test2841365() throws Throwable {
    String string0 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 169, 'x');
    String[] stringArray0 = StringUtils.stripAll((String[]) null, ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    assertNull(stringArray0);
}","/**
 * <p>Strips any of a set of characters from the start and end of every
 * String in an array.</p>
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <p>A new array is returned each time, except for length zero.
 * A {@code null} array will return {@code null}.
 * An empty array will return itself.
 * A {@code null} array entry will be ignored.
 * A {@code null} stripChars will strip whitespace as defined by
 * {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripAll(null, *)                = null
 * StringUtils.stripAll([], *)                  = []
 * StringUtils.stripAll([""abc"", ""  abc""], null) = [""abc"", ""abc""]
 * StringUtils.stripAll([""abc  "", null], null)  = [""abc"", null]
 * StringUtils.stripAll([""abc  "", null], ""yz"")  = [""abc  "", null]
 * StringUtils.stripAll([""yabcz"", null], ""yz"")  = [""abc"", null]
 * </pre>
 *
 * @param strs  the array to remove characters from, may be null
 * @param stripChars  the characters to remove, null treated as whitespace
 * @return the stripped Strings, {@code null} if null array input
 */"
"public static String center(String str, int size, char padChar) {
    if (str == null || size <= 0) {
        return str;
    }
    int strLen = str.length();
    int pads = size - strLen;
    if (pads <= 0) {
        return str;
    }
    str = leftPad(str, strLen + pads / 2, padChar);
    str = rightPad(str, size, padChar);
    return str;
}","public void test2841366() throws Throwable {
    String string0 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 169, 'x');
    String[] stringArray0 = StringUtils.stripAll((String[]) null, ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string1 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 7, 'Q');
    assertNotNull(string1);
}","/**
 * <p>Centers a String in a larger String of size {@code size}.
 * Uses a supplied character as the value to pad the String with.</p>
 *
 * <p>If the size is less than the String length, the String is returned.
 * A {@code null} String returns {@code null}.
 * A negative size is treated as zero.</p>
 *
 * <pre>
 * StringUtils.center(null, *, *)     = null
 * StringUtils.center("""", 4, ' ')     = ""    ""
 * StringUtils.center(""ab"", -1, ' ')  = ""ab""
 * StringUtils.center(""ab"", 4, ' ')   = "" ab""
 * StringUtils.center(""abcd"", 2, ' ') = ""abcd""
 * StringUtils.center(""a"", 4, ' ')    = "" a  ""
 * StringUtils.center(""a"", 4, 'y')    = ""yayy""
 * </pre>
 *
 * @param str  the String to center, may be null
 * @param size  the int size of new String, negative treated as zero
 * @param padChar  the character to pad the new String with
 * @return centered String, {@code null} if null String input
 * @since 2.0
 */"
"public static String defaultString(String str, String defaultStr) {
    return str == null ? defaultStr : str;
}","public void test2841369() throws Throwable {
    String string0 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 169, 'x');
    String[] stringArray0 = StringUtils.stripAll((String[]) null, ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string1 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 7, 'Q');
    String string2 = StringUtils.defaultString(""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"", ""xR(}3$+"");
    assertNotNull(string2);
}","/**
 * <p>Returns either the passed in String, or if the String is
 * {@code null}, the value of {@code defaultStr}.</p>
 *
 * <pre>
 * StringUtils.defaultString(null, ""NULL"")  = ""NULL""
 * StringUtils.defaultString("""", ""NULL"")    = """"
 * StringUtils.defaultString(""bat"", ""NULL"") = ""bat""
 * </pre>
 *
 * @see ObjectUtils#toString(Object,String)
 * @see String#valueOf(Object)
 * @param str  the String to check, may be null
 * @param defaultStr  the default String to return
 *  if the input is {@code null}, may be null
 * @return the passed in String, or the default if it was {@code null}
 */"
"// LastIndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the last index within a CharSequence, handling {@code null}.
 * This method uses {@link String#lastIndexOf(int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("""") CharSequence will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.lastIndexOf(null, *)         = -1
 * StringUtils.lastIndexOf("""", *)           = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'a') = 7
 * StringUtils.lastIndexOf(""aabaabaa"", 'b') = 5
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @return the last index of the search character,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from lastIndexOf(String, int) to lastIndexOf(CharSequence, int)
 */
public static int lastIndexOf(CharSequence seq, int searchChar) {
    if (isEmpty(seq)) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.lastIndexOf(seq, searchChar, seq.length());
}","public void test2841373() throws Throwable {
    String string0 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 169, 'x');
    String[] stringArray0 = StringUtils.stripAll((String[]) null, ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string1 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 7, 'Q');
    String string2 = StringUtils.defaultString(""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"", ""xR(}3$+"");
    int int0 = StringUtils.lastIndexOf((CharSequence) ""xDTm(m'~h1DlVpMe"", (-1158));
    assertEquals((-1), int0);
}",""
"public static boolean endsWithAny(CharSequence string, CharSequence... searchStrings) {
    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {
        return false;
    }
    for (int i = 0; i < searchStrings.length; i++) {
        CharSequence searchString = searchStrings[i];
        if (StringUtils.endsWith(string, searchString)) {
            return true;
        }
    }
    return false;
}","public void test2841374() throws Throwable {
    String string0 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 169, 'x');
    String[] stringArray0 = StringUtils.stripAll((String[]) null, ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string1 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 7, 'Q');
    String string2 = StringUtils.defaultString(""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"", ""xR(}3$+"");
    int int0 = StringUtils.lastIndexOf((CharSequence) ""xDTm(m'~h1DlVpMe"", (-1158));
    boolean boolean0 = StringUtils.endsWithAny(""xDTm(m'~h1DlVpMe"", (CharSequence[]) null);
    assertFalse(boolean0);
}","/**
 * <p>Check if a CharSequence ends with any of an array of specified strings.</p>
 *
 * <pre>
 * StringUtils.endsWithAny(null, null)      = false
 * StringUtils.endsWithAny(null, new String[] {""abc""})  = false
 * StringUtils.endsWithAny(""abcxyz"", null)     = false
 * StringUtils.endsWithAny(""abcxyz"", new String[] {""""}) = true
 * StringUtils.endsWithAny(""abcxyz"", new String[] {""xyz""}) = true
 * StringUtils.endsWithAny(""abcxyz"", new String[] {null, ""xyz"", ""abc""}) = true
 * </pre>
 *
 * @param string  the CharSequence to check, may be null
 * @param searchStrings the CharSequences to find, may be null or empty
 * @return {@code true} if the CharSequence ends with any of the the prefixes, case insensitive, or
 *  both {@code null}
 * @since 3.0
 */"
"public static String replaceChars(String str, String searchChars, String replaceChars) {
    if (isEmpty(str) || isEmpty(searchChars)) {
        return str;
    }
    if (replaceChars == null) {
        replaceChars = EMPTY;
    }
    boolean modified = false;
    int replaceCharsLength = replaceChars.length();
    int strLength = str.length();
    StringBuilder buf = new StringBuilder(strLength);
    for (int i = 0; i < strLength; i++) {
        char ch = str.charAt(i);
        int index = searchChars.indexOf(ch);
        if (index >= 0) {
            modified = true;
            if (index < replaceCharsLength) {
                buf.append(replaceChars.charAt(index));
            }
        } else {
            buf.append(ch);
        }
    }
    if (modified) {
        return buf.toString();
    }
    return str;
}","public void test2841375() throws Throwable {
    String string0 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 169, 'x');
    String[] stringArray0 = StringUtils.stripAll((String[]) null, ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string1 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 7, 'Q');
    String string2 = StringUtils.defaultString(""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"", ""xR(}3$+"");
    int int0 = StringUtils.lastIndexOf((CharSequence) ""xDTm(m'~h1DlVpMe"", (-1158));
    boolean boolean0 = StringUtils.endsWithAny(""xDTm(m'~h1DlVpMe"", (CharSequence[]) null);
    String string3 = StringUtils.replaceChars(""xDTm(m'~h1DlVpMe"", ""xDTm(m'~h1DlVpMe"", ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    assertNotNull(string3);
}","/**
 * <p>Replaces multiple characters in a String in one go.
 * This method can also be used to delete characters.</p>
 *
 * <p>For example:<br />
 * <code>replaceChars(&quot;hello&quot;, &quot;ho&quot;, &quot;jy&quot;) = jelly</code>.</p>
 *
 * <p>A {@code null} string input returns {@code null}.
 * An empty ("""") string input returns an empty string.
 * A null or empty set of search characters returns the input string.</p>
 *
 * <p>The length of the search characters should normally equal the length
 * of the replace characters.
 * If the search characters is longer, then the extra search characters
 * are deleted.
 * If the search characters is shorter, then the extra replace characters
 * are ignored.</p>
 *
 * <pre>
 * StringUtils.replaceChars(null, *, *)           = null
 * StringUtils.replaceChars("""", *, *)             = """"
 * StringUtils.replaceChars(""abc"", null, *)       = ""abc""
 * StringUtils.replaceChars(""abc"", """", *)         = ""abc""
 * StringUtils.replaceChars(""abc"", ""b"", null)     = ""ac""
 * StringUtils.replaceChars(""abc"", ""b"", """")       = ""ac""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""yz"")  = ""ayzya""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""y"")   = ""ayya""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""yzx"") = ""ayzya""
 * </pre>
 *
 * @param str  String to replace characters in, may be null
 * @param searchChars  a set of characters to search for, may be null
 * @param replaceChars  a set of characters to replace, may be null
 * @return modified String, {@code null} if null string input
 * @since 2.0
 */"
"public static String leftPad(String str, int size, char padChar) {
    if (str == null) {
        return null;
    }
    int pads = size - str.length();
    if (pads <= 0) {
        // returns original String when possible
        return str;
    }
    if (pads > PAD_LIMIT) {
        return leftPad(str, size, String.valueOf(padChar));
    }
    return repeat(padChar, pads).concat(str);
}","public void test2841380() throws Throwable {
    String string0 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 169, 'x');
    String[] stringArray0 = StringUtils.stripAll((String[]) null, ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string1 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 7, 'Q');
    String string2 = StringUtils.defaultString(""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"", ""xR(}3$+"");
    int int0 = StringUtils.lastIndexOf((CharSequence) ""xDTm(m'~h1DlVpMe"", (-1158));
    boolean boolean0 = StringUtils.endsWithAny(""xDTm(m'~h1DlVpMe"", (CharSequence[]) null);
    String string3 = StringUtils.replaceChars(""xDTm(m'~h1DlVpMe"", ""xDTm(m'~h1DlVpMe"", ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string4 = StringUtils.leftPad(""XOq)XOq)"", (-1158), 'd');
    assertNotNull(string4);
}","/**
 * <p>Left pad a String with a specified character.</p>
 *
 * <p>Pad to a size of {@code size}.</p>
 *
 * <pre>
 * StringUtils.leftPad(null, *, *)     = null
 * StringUtils.leftPad("""", 3, 'z')     = ""zzz""
 * StringUtils.leftPad(""bat"", 3, 'z')  = ""bat""
 * StringUtils.leftPad(""bat"", 5, 'z')  = ""zzbat""
 * StringUtils.leftPad(""bat"", 1, 'z')  = ""bat""
 * StringUtils.leftPad(""bat"", -1, 'z') = ""bat""
 * </pre>
 *
 * @param str  the String to pad out, may be null
 * @param size  the size to pad to
 * @param padChar  the character to pad with
 * @return left padded String or original String if no padding is necessary,
 *  {@code null} if null String input
 * @since 2.0
 */"
"public static String stripToNull(String str) {
    if (str == null) {
        return null;
    }
    str = strip(str, null);
    return str.length() == 0 ? null : str;
}","public void test2841386() throws Throwable {
    String string0 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 169, 'x');
    String[] stringArray0 = StringUtils.stripAll((String[]) null, ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string1 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 7, 'Q');
    String string2 = StringUtils.defaultString(""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"", ""xR(}3$+"");
    int int0 = StringUtils.lastIndexOf((CharSequence) ""xDTm(m'~h1DlVpMe"", (-1158));
    boolean boolean0 = StringUtils.endsWithAny(""xDTm(m'~h1DlVpMe"", (CharSequence[]) null);
    String string3 = StringUtils.replaceChars(""xDTm(m'~h1DlVpMe"", ""xDTm(m'~h1DlVpMe"", ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string4 = StringUtils.leftPad(""XOq)XOq)"", (-1158), 'd');
    String string5 = StringUtils.stripToNull(""XOq)XOq)"");
    assertNotNull(string5);
}","/**
 * <p>Strips whitespace from the start and end of a String  returning
 * {@code null} if the String is empty ("""") after the strip.</p>
 *
 * <p>This is similar to {@link #trimToNull(String)} but removes whitespace.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripToNull(null)     = null
 * StringUtils.stripToNull("""")       = null
 * StringUtils.stripToNull(""   "")    = null
 * StringUtils.stripToNull(""abc"")    = ""abc""
 * StringUtils.stripToNull(""  abc"")  = ""abc""
 * StringUtils.stripToNull(""abc  "")  = ""abc""
 * StringUtils.stripToNull("" abc "")  = ""abc""
 * StringUtils.stripToNull("" ab c "") = ""ab c""
 * </pre>
 *
 * @param str  the String to be stripped, may be null
 * @return the stripped String,
 *  {@code null} if whitespace, empty or null String input
 * @since 2.0
 */"
"public static int indexOfDifference(CharSequence cs1, CharSequence cs2) {
    if (cs1 == cs2) {
        return INDEX_NOT_FOUND;
    }
    if (cs1 == null || cs2 == null) {
        return 0;
    }
    int i;
    for (i = 0; i < cs1.length() && i < cs2.length(); ++i) {
        if (cs1.charAt(i) != cs2.charAt(i)) {
            break;
        }
    }
    if (i < cs2.length() || i < cs1.length()) {
        return i;
    }
    return INDEX_NOT_FOUND;
}","public void test2841393() throws Throwable {
    String string0 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 169, 'x');
    String[] stringArray0 = StringUtils.stripAll((String[]) null, ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string1 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 7, 'Q');
    String string2 = StringUtils.defaultString(""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"", ""xR(}3$+"");
    int int0 = StringUtils.lastIndexOf((CharSequence) ""xDTm(m'~h1DlVpMe"", (-1158));
    boolean boolean0 = StringUtils.endsWithAny(""xDTm(m'~h1DlVpMe"", (CharSequence[]) null);
    String string3 = StringUtils.replaceChars(""xDTm(m'~h1DlVpMe"", ""xDTm(m'~h1DlVpMe"", ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string4 = StringUtils.leftPad(""XOq)XOq)"", (-1158), 'd');
    String string5 = StringUtils.stripToNull(""XOq)XOq)"");
    int int1 = StringUtils.indexOfDifference((CharSequence) ""xDTm(m'~h1DlVpMe"", (CharSequence) ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    assertEquals(1, int1);
}","/**
 * <p>Compares two CharSequences, and returns the index at which the
 * CharSequences begin to differ.</p>
 *
 * <p>For example,
 * {@code indexOfDifference(""i am a machine"", ""i am a robot"") -> 7}</p>
 *
 * <pre>
 * StringUtils.indexOfDifference(null, null) = -1
 * StringUtils.indexOfDifference("""", """") = -1
 * StringUtils.indexOfDifference("""", ""abc"") = 0
 * StringUtils.indexOfDifference(""abc"", """") = 0
 * StringUtils.indexOfDifference(""abc"", ""abc"") = -1
 * StringUtils.indexOfDifference(""ab"", ""abxyz"") = 2
 * StringUtils.indexOfDifference(""abcde"", ""abxyz"") = 2
 * StringUtils.indexOfDifference(""abcde"", ""xyz"") = 0
 * </pre>
 *
 * @param cs1  the first CharSequence, may be null
 * @param cs2  the second CharSequence, may be null
 * @return the index where cs1 and cs2 begin to differ; -1 if they are equal
 * @since 2.0
 * @since 3.0 Changed signature from indexOfDifference(String, String) to
 * indexOfDifference(CharSequence, CharSequence)
 */"
"// Trim
//-----------------------------------------------------------------------
/**
 * <p>Removes control characters (char &lt;= 32) from both
 * ends of this String, handling {@code null} by returning
 * {@code null}.</p>
 *
 * <p>The String is trimmed using {@link String#trim()}.
 * Trim removes start and end characters &lt;= 32.
 * To strip whitespace use {@link #strip(String)}.</p>
 *
 * <p>To trim your choice of characters, use the
 * {@link #strip(String, String)} methods.</p>
 *
 * <pre>
 * StringUtils.trim(null)          = null
 * StringUtils.trim("""")            = """"
 * StringUtils.trim(""     "")       = """"
 * StringUtils.trim(""abc"")         = ""abc""
 * StringUtils.trim(""    abc    "") = ""abc""
 * </pre>
 *
 * @param str  the String to be trimmed, may be null
 * @return the trimmed string, {@code null} if null String input
 */
public static String trim(String str) {
    return str == null ? null : str.trim();
}","public void test2841395() throws Throwable {
    String string0 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 169, 'x');
    String[] stringArray0 = StringUtils.stripAll((String[]) null, ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string1 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 7, 'Q');
    String string2 = StringUtils.defaultString(""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"", ""xR(}3$+"");
    int int0 = StringUtils.lastIndexOf((CharSequence) ""xDTm(m'~h1DlVpMe"", (-1158));
    boolean boolean0 = StringUtils.endsWithAny(""xDTm(m'~h1DlVpMe"", (CharSequence[]) null);
    String string3 = StringUtils.replaceChars(""xDTm(m'~h1DlVpMe"", ""xDTm(m'~h1DlVpMe"", ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string4 = StringUtils.leftPad(""XOq)XOq)"", (-1158), 'd');
    String string5 = StringUtils.stripToNull(""XOq)XOq)"");
    int int1 = StringUtils.indexOfDifference((CharSequence) ""xDTm(m'~h1DlVpMe"", (CharSequence) ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string6 = StringUtils.trim(""lOBgKp"");
    assertNotNull(string6);
}",""
"public static boolean isBlank(CharSequence cs) {
    int strLen;
    if (cs == null || (strLen = cs.length()) == 0) {
        return true;
    }
    for (int i = 0; i < strLen; i++) {
        if ((Character.isWhitespace(cs.charAt(i)) == false)) {
            return false;
        }
    }
    return true;
}","public void test2841403() throws Throwable {
    String string0 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 169, 'x');
    String[] stringArray0 = StringUtils.stripAll((String[]) null, ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string1 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 7, 'Q');
    String string2 = StringUtils.defaultString(""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"", ""xR(}3$+"");
    int int0 = StringUtils.lastIndexOf((CharSequence) ""xDTm(m'~h1DlVpMe"", (-1158));
    boolean boolean0 = StringUtils.endsWithAny(""xDTm(m'~h1DlVpMe"", (CharSequence[]) null);
    String string3 = StringUtils.replaceChars(""xDTm(m'~h1DlVpMe"", ""xDTm(m'~h1DlVpMe"", ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string4 = StringUtils.leftPad(""XOq)XOq)"", (-1158), 'd');
    String string5 = StringUtils.stripToNull(""XOq)XOq)"");
    int int1 = StringUtils.indexOfDifference((CharSequence) ""xDTm(m'~h1DlVpMe"", (CharSequence) ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string6 = StringUtils.trim(""lOBgKp"");
    boolean boolean1 = StringUtils.isBlank(""lOBgKp"");
    assertFalse(boolean1);
}","/**
 * <p>Checks if a CharSequence is whitespace, empty ("""") or null.</p>
 *
 * <pre>
 * StringUtils.isBlank(null)      = true
 * StringUtils.isBlank("""")        = true
 * StringUtils.isBlank("" "")       = true
 * StringUtils.isBlank(""bob"")     = false
 * StringUtils.isBlank(""  bob  "") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if the CharSequence is null, empty or whitespace
 * @since 2.0
 * @since 3.0 Changed signature from isBlank(String) to isBlank(CharSequence)
 */"
"public static String stripStart(String str, String stripChars) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    int start = 0;
    if (stripChars == null) {
        while ((start != strLen) && Character.isWhitespace(str.charAt(start))) {
            start++;
        }
    } else if (stripChars.length() == 0) {
        return str;
    } else {
        while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) {
            start++;
        }
    }
    return str.substring(start);
}","public void test2841405() throws Throwable {
    String string0 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 169, 'x');
    String[] stringArray0 = StringUtils.stripAll((String[]) null, ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string1 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 7, 'Q');
    String string2 = StringUtils.defaultString(""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"", ""xR(}3$+"");
    int int0 = StringUtils.lastIndexOf((CharSequence) ""xDTm(m'~h1DlVpMe"", (-1158));
    boolean boolean0 = StringUtils.endsWithAny(""xDTm(m'~h1DlVpMe"", (CharSequence[]) null);
    String string3 = StringUtils.replaceChars(""xDTm(m'~h1DlVpMe"", ""xDTm(m'~h1DlVpMe"", ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string4 = StringUtils.leftPad(""XOq)XOq)"", (-1158), 'd');
    String string5 = StringUtils.stripToNull(""XOq)XOq)"");
    int int1 = StringUtils.indexOfDifference((CharSequence) ""xDTm(m'~h1DlVpMe"", (CharSequence) ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string6 = StringUtils.trim(""lOBgKp"");
    boolean boolean1 = StringUtils.isBlank(""lOBgKp"");
    String string7 = StringUtils.stripStart(""DT"", ""UlEP6(r?\""&<"");
    assertNotNull(string7);
}","/**
 * <p>Strips any of a set of characters from the start of a String.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * An empty string ("""") input returns the empty string.</p>
 *
 * <p>If the stripChars String is {@code null}, whitespace is
 * stripped as defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripStart(null, *)          = null
 * StringUtils.stripStart("""", *)            = """"
 * StringUtils.stripStart(""abc"", """")        = ""abc""
 * StringUtils.stripStart(""abc"", null)      = ""abc""
 * StringUtils.stripStart(""  abc"", null)    = ""abc""
 * StringUtils.stripStart(""abc  "", null)    = ""abc  ""
 * StringUtils.stripStart("" abc "", null)    = ""abc ""
 * StringUtils.stripStart(""yxabc  "", ""xyz"") = ""abc  ""
 * </pre>
 *
 * @param str  the String to remove characters from, may be null
 * @param stripChars  the characters to remove, null treated as whitespace
 * @return the stripped String, {@code null} if null String input
 */"
"public static boolean startsWithAny(CharSequence string, CharSequence... searchStrings) {
    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {
        return false;
    }
    for (int i = 0; i < searchStrings.length; i++) {
        CharSequence searchString = searchStrings[i];
        if (StringUtils.startsWith(string, searchString)) {
            return true;
        }
    }
    return false;
}","public void test2841414() throws Throwable {
    String string0 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 169, 'x');
    String[] stringArray0 = StringUtils.stripAll((String[]) null, ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string1 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 7, 'Q');
    String string2 = StringUtils.defaultString(""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"", ""xR(}3$+"");
    int int0 = StringUtils.lastIndexOf((CharSequence) ""xDTm(m'~h1DlVpMe"", (-1158));
    boolean boolean0 = StringUtils.endsWithAny(""xDTm(m'~h1DlVpMe"", (CharSequence[]) null);
    String string3 = StringUtils.replaceChars(""xDTm(m'~h1DlVpMe"", ""xDTm(m'~h1DlVpMe"", ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string4 = StringUtils.leftPad(""XOq)XOq)"", (-1158), 'd');
    String string5 = StringUtils.stripToNull(""XOq)XOq)"");
    int int1 = StringUtils.indexOfDifference((CharSequence) ""xDTm(m'~h1DlVpMe"", (CharSequence) ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string6 = StringUtils.trim(""lOBgKp"");
    boolean boolean1 = StringUtils.isBlank(""lOBgKp"");
    String string7 = StringUtils.stripStart(""DT"", ""UlEP6(r?\""&<"");
    boolean boolean2 = StringUtils.startsWithAny(""DT"", (CharSequence[]) null);
    assertFalse(boolean2);
}","/**
 * <p>Check if a CharSequence starts with any of an array of specified strings.</p>
 *
 * <pre>
 * StringUtils.startsWithAny(null, null)      = false
 * StringUtils.startsWithAny(null, new String[] {""abc""})  = false
 * StringUtils.startsWithAny(""abcxyz"", null)     = false
 * StringUtils.startsWithAny(""abcxyz"", new String[] {""""}) = false
 * StringUtils.startsWithAny(""abcxyz"", new String[] {""abc""}) = true
 * StringUtils.startsWithAny(""abcxyz"", new String[] {null, ""xyz"", ""abc""}) = true
 * </pre>
 *
 * @param string  the CharSequence to check, may be null
 * @param searchStrings the CharSequences to find, may be null or empty
 * @return {@code true} if the CharSequence starts with any of the the prefixes, case insensitive, or
 *  both {@code null}
 * @since 2.5
 * @since 3.0 Changed signature from startsWithAny(String, String[]) to startsWithAny(CharSequence, CharSequence...)
 */"
"// IndexOfAny strings
//-----------------------------------------------------------------------
/**
 * <p>Find the first index of any of a set of potential substrings.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A {@code null} or zero length search array will return {@code -1}.
 * A {@code null} search array entry will be ignored, but a search
 * array containing """" will return {@code 0} if {@code str} is not
 * null. This method uses {@link String#indexOf(String)} if possible.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)                     = -1
 * StringUtils.indexOfAny(*, null)                     = -1
 * StringUtils.indexOfAny(*, [])                       = -1
 * StringUtils.indexOfAny(""zzabyycdxx"", [""ab"",""cd""])   = 2
 * StringUtils.indexOfAny(""zzabyycdxx"", [""cd"",""ab""])   = 2
 * StringUtils.indexOfAny(""zzabyycdxx"", [""mn"",""op""])   = -1
 * StringUtils.indexOfAny(""zzabyycdxx"", [""zab"",""aby""]) = 1
 * StringUtils.indexOfAny(""zzabyycdxx"", [""""])          = 0
 * StringUtils.indexOfAny("""", [""""])                    = 0
 * StringUtils.indexOfAny("""", [""a""])                   = -1
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStrs  the CharSequences to search for, may be null
 * @return the first index of any of the searchStrs in str, -1 if no match
 * @since 3.0 Changed signature from indexOfAny(String, String[]) to indexOfAny(CharSequence, CharSequence...)
 */
public static int indexOfAny(CharSequence str, CharSequence... searchStrs) {
    if (str == null || searchStrs == null) {
        return INDEX_NOT_FOUND;
    }
    int sz = searchStrs.length;
    // String's can't have a MAX_VALUEth index.
    int ret = Integer.MAX_VALUE;
    int tmp = 0;
    for (int i = 0; i < sz; i++) {
        CharSequence search = searchStrs[i];
        if (search == null) {
            continue;
        }
        tmp = CharSequenceUtils.indexOf(str, search, 0);
        if (tmp == INDEX_NOT_FOUND) {
            continue;
        }
        if (tmp < ret) {
            ret = tmp;
        }
    }
    return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret;
}","public void test2841417() throws Throwable {
    String string0 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 169, 'x');
    String[] stringArray0 = StringUtils.stripAll((String[]) null, ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string1 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 7, 'Q');
    String string2 = StringUtils.defaultString(""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"", ""xR(}3$+"");
    int int0 = StringUtils.lastIndexOf((CharSequence) ""xDTm(m'~h1DlVpMe"", (-1158));
    boolean boolean0 = StringUtils.endsWithAny(""xDTm(m'~h1DlVpMe"", (CharSequence[]) null);
    String string3 = StringUtils.replaceChars(""xDTm(m'~h1DlVpMe"", ""xDTm(m'~h1DlVpMe"", ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string4 = StringUtils.leftPad(""XOq)XOq)"", (-1158), 'd');
    String string5 = StringUtils.stripToNull(""XOq)XOq)"");
    int int1 = StringUtils.indexOfDifference((CharSequence) ""xDTm(m'~h1DlVpMe"", (CharSequence) ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string6 = StringUtils.trim(""lOBgKp"");
    boolean boolean1 = StringUtils.isBlank(""lOBgKp"");
    String string7 = StringUtils.stripStart(""DT"", ""UlEP6(r?\""&<"");
    boolean boolean2 = StringUtils.startsWithAny(""DT"", (CharSequence[]) null);
    int int2 = StringUtils.indexOfAny((CharSequence) ""xR(}3$+"", (CharSequence[]) null);
    assertEquals((-1), int2);
}",""
"public static String defaultString(String str, String defaultStr) {
    return str == null ? defaultStr : str;
}","public void test2841420() throws Throwable {
    String string0 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 169, 'x');
    String[] stringArray0 = StringUtils.stripAll((String[]) null, ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string1 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 7, 'Q');
    String string2 = StringUtils.defaultString(""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"", ""xR(}3$+"");
    int int0 = StringUtils.lastIndexOf((CharSequence) ""xDTm(m'~h1DlVpMe"", (-1158));
    boolean boolean0 = StringUtils.endsWithAny(""xDTm(m'~h1DlVpMe"", (CharSequence[]) null);
    String string3 = StringUtils.replaceChars(""xDTm(m'~h1DlVpMe"", ""xDTm(m'~h1DlVpMe"", ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string4 = StringUtils.leftPad(""XOq)XOq)"", (-1158), 'd');
    String string5 = StringUtils.stripToNull(""XOq)XOq)"");
    int int1 = StringUtils.indexOfDifference((CharSequence) ""xDTm(m'~h1DlVpMe"", (CharSequence) ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string6 = StringUtils.trim(""lOBgKp"");
    boolean boolean1 = StringUtils.isBlank(""lOBgKp"");
    String string7 = StringUtils.stripStart(""DT"", ""UlEP6(r?\""&<"");
    boolean boolean2 = StringUtils.startsWithAny(""DT"", (CharSequence[]) null);
    int int2 = StringUtils.indexOfAny((CharSequence) ""xR(}3$+"", (CharSequence[]) null);
    String string8 = StringUtils.defaultString(""DT"", ""XOq)XOq)"");
    assertNotNull(string8);
}","/**
 * <p>Returns either the passed in String, or if the String is
 * {@code null}, the value of {@code defaultStr}.</p>
 *
 * <pre>
 * StringUtils.defaultString(null, ""NULL"")  = ""NULL""
 * StringUtils.defaultString("""", ""NULL"")    = """"
 * StringUtils.defaultString(""bat"", ""NULL"") = ""bat""
 * </pre>
 *
 * @see ObjectUtils#toString(Object,String)
 * @see String#valueOf(Object)
 * @param str  the String to check, may be null
 * @param defaultStr  the default String to return
 *  if the input is {@code null}, may be null
 * @return the passed in String, or the default if it was {@code null}
 */"
"// Count matches
//-----------------------------------------------------------------------
/**
 * <p>Counts how many times the substring appears in the larger string.</p>
 *
 * <p>A {@code null} or empty ("""") String input returns {@code 0}.</p>
 *
 * <pre>
 * StringUtils.countMatches(null, *)       = 0
 * StringUtils.countMatches("""", *)         = 0
 * StringUtils.countMatches(""abba"", null)  = 0
 * StringUtils.countMatches(""abba"", """")    = 0
 * StringUtils.countMatches(""abba"", ""a"")   = 2
 * StringUtils.countMatches(""abba"", ""ab"")  = 1
 * StringUtils.countMatches(""abba"", ""xxx"") = 0
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param sub  the substring to count, may be null
 * @return the number of occurrences, 0 if either CharSequence is {@code null}
 * @since 3.0 Changed signature from countMatches(String, String) to countMatches(CharSequence, CharSequence)
 */
public static int countMatches(CharSequence str, CharSequence sub) {
    if (isEmpty(str) || isEmpty(sub)) {
        return 0;
    }
    int count = 0;
    int idx = 0;
    while ((idx = CharSequenceUtils.indexOf(str, sub, idx)) != INDEX_NOT_FOUND) {
        count++;
        idx += sub.length();
    }
    return count;
}","public void test2841430() throws Throwable {
    String string0 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 169, 'x');
    String[] stringArray0 = StringUtils.stripAll((String[]) null, ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string1 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 7, 'Q');
    String string2 = StringUtils.defaultString(""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"", ""xR(}3$+"");
    int int0 = StringUtils.lastIndexOf((CharSequence) ""xDTm(m'~h1DlVpMe"", (-1158));
    boolean boolean0 = StringUtils.endsWithAny(""xDTm(m'~h1DlVpMe"", (CharSequence[]) null);
    String string3 = StringUtils.replaceChars(""xDTm(m'~h1DlVpMe"", ""xDTm(m'~h1DlVpMe"", ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string4 = StringUtils.leftPad(""XOq)XOq)"", (-1158), 'd');
    String string5 = StringUtils.stripToNull(""XOq)XOq)"");
    int int1 = StringUtils.indexOfDifference((CharSequence) ""xDTm(m'~h1DlVpMe"", (CharSequence) ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string6 = StringUtils.trim(""lOBgKp"");
    boolean boolean1 = StringUtils.isBlank(""lOBgKp"");
    String string7 = StringUtils.stripStart(""DT"", ""UlEP6(r?\""&<"");
    boolean boolean2 = StringUtils.startsWithAny(""DT"", (CharSequence[]) null);
    int int2 = StringUtils.indexOfAny((CharSequence) ""xR(}3$+"", (CharSequence[]) null);
    String string8 = StringUtils.defaultString(""DT"", ""XOq)XOq)"");
    int int3 = StringUtils.countMatches(""xxxxxxxxxxxxxxxx"", ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    assertEquals(0, int3);
}",""
"public static int indexOfIgnoreCase(CharSequence str, CharSequence searchStr) {
    return indexOfIgnoreCase(str, searchStr, 0);
}","public void test2841434() throws Throwable {
    String string0 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 169, 'x');
    String[] stringArray0 = StringUtils.stripAll((String[]) null, ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string1 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 7, 'Q');
    String string2 = StringUtils.defaultString(""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"", ""xR(}3$+"");
    int int0 = StringUtils.lastIndexOf((CharSequence) ""xDTm(m'~h1DlVpMe"", (-1158));
    boolean boolean0 = StringUtils.endsWithAny(""xDTm(m'~h1DlVpMe"", (CharSequence[]) null);
    String string3 = StringUtils.replaceChars(""xDTm(m'~h1DlVpMe"", ""xDTm(m'~h1DlVpMe"", ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string4 = StringUtils.leftPad(""XOq)XOq)"", (-1158), 'd');
    String string5 = StringUtils.stripToNull(""XOq)XOq)"");
    int int1 = StringUtils.indexOfDifference((CharSequence) ""xDTm(m'~h1DlVpMe"", (CharSequence) ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string6 = StringUtils.trim(""lOBgKp"");
    boolean boolean1 = StringUtils.isBlank(""lOBgKp"");
    String string7 = StringUtils.stripStart(""DT"", ""UlEP6(r?\""&<"");
    boolean boolean2 = StringUtils.startsWithAny(""DT"", (CharSequence[]) null);
    int int2 = StringUtils.indexOfAny((CharSequence) ""xR(}3$+"", (CharSequence[]) null);
    String string8 = StringUtils.defaultString(""DT"", ""XOq)XOq)"");
    int int3 = StringUtils.countMatches(""xxxxxxxxxxxxxxxx"", ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    int int4 = StringUtils.indexOfIgnoreCase((CharSequence) ""xDTm(m'~h1DlVpMe"", (CharSequence) ""UlEP6(r?\""&<"");
    assertEquals((-1), int4);
}","/**
 * <p>Case in-sensitive find of the first index within a CharSequence.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A negative start position is treated as zero.
 * An empty ("""") search CharSequence always matches.
 * A start position greater than the string length only matches
 * an empty search CharSequence.</p>
 *
 * <pre>
 * StringUtils.indexOfIgnoreCase(null, *)          = -1
 * StringUtils.indexOfIgnoreCase(*, null)          = -1
 * StringUtils.indexOfIgnoreCase("""", """")           = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""a"")  = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""b"")  = 2
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""ab"") = 1
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @return the first index of the search CharSequence,
 *  -1 if no match or {@code null} string input
 * @since 2.5
 * @since 3.0 Changed signature from indexOfIgnoreCase(String, String) to indexOfIgnoreCase(CharSequence, CharSequence)
 */"
"public static String getCommonPrefix(String... strs) {
    if (strs == null || strs.length == 0) {
        return EMPTY;
    }
    int smallestIndexOfDiff = indexOfDifference(strs);
    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {
        // all strings were identical
        if (strs[0] == null) {
            return EMPTY;
        }
        return strs[0];
    } else if (smallestIndexOfDiff == 0) {
        // there were no common initial characters
        return EMPTY;
    } else {
        // we found a common initial character sequence
        return strs[0].substring(0, smallestIndexOfDiff);
    }
}","public void test2841439() throws Throwable {
    String string0 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 169, 'x');
    String[] stringArray0 = StringUtils.stripAll((String[]) null, ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string1 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 7, 'Q');
    String string2 = StringUtils.defaultString(""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"", ""xR(}3$+"");
    int int0 = StringUtils.lastIndexOf((CharSequence) ""xDTm(m'~h1DlVpMe"", (-1158));
    boolean boolean0 = StringUtils.endsWithAny(""xDTm(m'~h1DlVpMe"", (CharSequence[]) null);
    String string3 = StringUtils.replaceChars(""xDTm(m'~h1DlVpMe"", ""xDTm(m'~h1DlVpMe"", ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string4 = StringUtils.leftPad(""XOq)XOq)"", (-1158), 'd');
    String string5 = StringUtils.stripToNull(""XOq)XOq)"");
    int int1 = StringUtils.indexOfDifference((CharSequence) ""xDTm(m'~h1DlVpMe"", (CharSequence) ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string6 = StringUtils.trim(""lOBgKp"");
    boolean boolean1 = StringUtils.isBlank(""lOBgKp"");
    String string7 = StringUtils.stripStart(""DT"", ""UlEP6(r?\""&<"");
    boolean boolean2 = StringUtils.startsWithAny(""DT"", (CharSequence[]) null);
    int int2 = StringUtils.indexOfAny((CharSequence) ""xR(}3$+"", (CharSequence[]) null);
    String string8 = StringUtils.defaultString(""DT"", ""XOq)XOq)"");
    int int3 = StringUtils.countMatches(""xxxxxxxxxxxxxxxx"", ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    int int4 = StringUtils.indexOfIgnoreCase((CharSequence) ""xDTm(m'~h1DlVpMe"", (CharSequence) ""UlEP6(r?\""&<"");
    String string9 = StringUtils.getCommonPrefix((String[]) null);
    assertNotNull(string9);
}","/**
 * <p>Compares all Strings in an array and returns the initial sequence of
 * characters that is common to all of them.</p>
 *
 * <p>For example,
 * <code>getCommonPrefix(new String[] {""i am a machine"", ""i am a robot""}) -> ""i am a ""</code></p>
 *
 * <pre>
 * StringUtils.getCommonPrefix(null) = """"
 * StringUtils.getCommonPrefix(new String[] {}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc""}) = ""abc""
 * StringUtils.getCommonPrefix(new String[] {null, null}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", """"}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", null}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", null, null}) = """"
 * StringUtils.getCommonPrefix(new String[] {null, null, ""abc""}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", ""abc""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", """"}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", ""abc""}) = ""abc""
 * StringUtils.getCommonPrefix(new String[] {""abc"", ""a""}) = ""a""
 * StringUtils.getCommonPrefix(new String[] {""ab"", ""abxyz""}) = ""ab""
 * StringUtils.getCommonPrefix(new String[] {""abcde"", ""abxyz""}) = ""ab""
 * StringUtils.getCommonPrefix(new String[] {""abcde"", ""xyz""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""xyz"", ""abcde""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""i am a machine"", ""i am a robot""}) = ""i am a ""
 * </pre>
 *
 * @param strs  array of String objects, entries may be null
 * @return the initial sequence of characters that are common to all Strings
 * in the array; empty String if the array is null, the elements are all null
 * or if there is no common prefix.
 * @since 2.4
 */"
"public static boolean isBlank(CharSequence cs) {
    int strLen;
    if (cs == null || (strLen = cs.length()) == 0) {
        return true;
    }
    for (int i = 0; i < strLen; i++) {
        if ((Character.isWhitespace(cs.charAt(i)) == false)) {
            return false;
        }
    }
    return true;
}","public void test2841450() throws Throwable {
    String string0 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 169, 'x');
    String[] stringArray0 = StringUtils.stripAll((String[]) null, ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string1 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 7, 'Q');
    String string2 = StringUtils.defaultString(""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"", ""xR(}3$+"");
    int int0 = StringUtils.lastIndexOf((CharSequence) ""xDTm(m'~h1DlVpMe"", (-1158));
    boolean boolean0 = StringUtils.endsWithAny(""xDTm(m'~h1DlVpMe"", (CharSequence[]) null);
    String string3 = StringUtils.replaceChars(""xDTm(m'~h1DlVpMe"", ""xDTm(m'~h1DlVpMe"", ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string4 = StringUtils.leftPad(""XOq)XOq)"", (-1158), 'd');
    String string5 = StringUtils.stripToNull(""XOq)XOq)"");
    int int1 = StringUtils.indexOfDifference((CharSequence) ""xDTm(m'~h1DlVpMe"", (CharSequence) ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string6 = StringUtils.trim(""lOBgKp"");
    boolean boolean1 = StringUtils.isBlank(""lOBgKp"");
    String string7 = StringUtils.stripStart(""DT"", ""UlEP6(r?\""&<"");
    boolean boolean2 = StringUtils.startsWithAny(""DT"", (CharSequence[]) null);
    int int2 = StringUtils.indexOfAny((CharSequence) ""xR(}3$+"", (CharSequence[]) null);
    String string8 = StringUtils.defaultString(""DT"", ""XOq)XOq)"");
    int int3 = StringUtils.countMatches(""xxxxxxxxxxxxxxxx"", ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    int int4 = StringUtils.indexOfIgnoreCase((CharSequence) ""xDTm(m'~h1DlVpMe"", (CharSequence) ""UlEP6(r?\""&<"");
    String string9 = StringUtils.getCommonPrefix((String[]) null);
    boolean boolean3 = StringUtils.isBlank(""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    assertFalse(boolean3);
}","/**
 * <p>Checks if a CharSequence is whitespace, empty ("""") or null.</p>
 *
 * <pre>
 * StringUtils.isBlank(null)      = true
 * StringUtils.isBlank("""")        = true
 * StringUtils.isBlank("" "")       = true
 * StringUtils.isBlank(""bob"")     = false
 * StringUtils.isBlank(""  bob  "") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if the CharSequence is null, empty or whitespace
 * @since 2.0
 * @since 3.0 Changed signature from isBlank(String) to isBlank(CharSequence)
 */"
"public static String substringAfter(String str, String separator) {
    if (isEmpty(str)) {
        return str;
    }
    if (separator == null) {
        return EMPTY;
    }
    int pos = str.indexOf(separator);
    if (pos == INDEX_NOT_FOUND) {
        return EMPTY;
    }
    return str.substring(pos + separator.length());
}","public void test2841454() throws Throwable {
    String string0 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 169, 'x');
    String[] stringArray0 = StringUtils.stripAll((String[]) null, ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string1 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 7, 'Q');
    String string2 = StringUtils.defaultString(""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"", ""xR(}3$+"");
    int int0 = StringUtils.lastIndexOf((CharSequence) ""xDTm(m'~h1DlVpMe"", (-1158));
    boolean boolean0 = StringUtils.endsWithAny(""xDTm(m'~h1DlVpMe"", (CharSequence[]) null);
    String string3 = StringUtils.replaceChars(""xDTm(m'~h1DlVpMe"", ""xDTm(m'~h1DlVpMe"", ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string4 = StringUtils.leftPad(""XOq)XOq)"", (-1158), 'd');
    String string5 = StringUtils.stripToNull(""XOq)XOq)"");
    int int1 = StringUtils.indexOfDifference((CharSequence) ""xDTm(m'~h1DlVpMe"", (CharSequence) ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string6 = StringUtils.trim(""lOBgKp"");
    boolean boolean1 = StringUtils.isBlank(""lOBgKp"");
    String string7 = StringUtils.stripStart(""DT"", ""UlEP6(r?\""&<"");
    boolean boolean2 = StringUtils.startsWithAny(""DT"", (CharSequence[]) null);
    int int2 = StringUtils.indexOfAny((CharSequence) ""xR(}3$+"", (CharSequence[]) null);
    String string8 = StringUtils.defaultString(""DT"", ""XOq)XOq)"");
    int int3 = StringUtils.countMatches(""xxxxxxxxxxxxxxxx"", ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    int int4 = StringUtils.indexOfIgnoreCase((CharSequence) ""xDTm(m'~h1DlVpMe"", (CharSequence) ""UlEP6(r?\""&<"");
    String string9 = StringUtils.getCommonPrefix((String[]) null);
    boolean boolean3 = StringUtils.isBlank(""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string10 = StringUtils.substringAfter("",_T?gGN"", ""xR(}3$+"");
    assertNotNull(string10);
}","/**
 * <p>Gets the substring after the first occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A {@code null} string input will return {@code null}.
 * An empty ("""") string input will return the empty string.
 * A {@code null} separator will return the empty string if the
 * input string is not {@code null}.</p>
 *
 * <p>If nothing is found, the empty string is returned.</p>
 *
 * <pre>
 * StringUtils.substringAfter(null, *)      = null
 * StringUtils.substringAfter("""", *)        = """"
 * StringUtils.substringAfter(*, null)      = """"
 * StringUtils.substringAfter(""abc"", ""a"")   = ""bc""
 * StringUtils.substringAfter(""abcba"", ""b"") = ""cba""
 * StringUtils.substringAfter(""abc"", ""c"")   = """"
 * StringUtils.substringAfter(""abc"", ""d"")   = """"
 * StringUtils.substringAfter(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring after the first occurrence of the separator,
 *  {@code null} if null String input
 * @since 2.0
 */"
"public static boolean isAlphaSpace(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {
            return false;
        }
    }
    return true;
}","public void test2841465() throws Throwable {
    String string0 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 169, 'x');
    String[] stringArray0 = StringUtils.stripAll((String[]) null, ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string1 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 7, 'Q');
    String string2 = StringUtils.defaultString(""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"", ""xR(}3$+"");
    int int0 = StringUtils.lastIndexOf((CharSequence) ""xDTm(m'~h1DlVpMe"", (-1158));
    boolean boolean0 = StringUtils.endsWithAny(""xDTm(m'~h1DlVpMe"", (CharSequence[]) null);
    String string3 = StringUtils.replaceChars(""xDTm(m'~h1DlVpMe"", ""xDTm(m'~h1DlVpMe"", ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string4 = StringUtils.leftPad(""XOq)XOq)"", (-1158), 'd');
    String string5 = StringUtils.stripToNull(""XOq)XOq)"");
    int int1 = StringUtils.indexOfDifference((CharSequence) ""xDTm(m'~h1DlVpMe"", (CharSequence) ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string6 = StringUtils.trim(""lOBgKp"");
    boolean boolean1 = StringUtils.isBlank(""lOBgKp"");
    String string7 = StringUtils.stripStart(""DT"", ""UlEP6(r?\""&<"");
    boolean boolean2 = StringUtils.startsWithAny(""DT"", (CharSequence[]) null);
    int int2 = StringUtils.indexOfAny((CharSequence) ""xR(}3$+"", (CharSequence[]) null);
    String string8 = StringUtils.defaultString(""DT"", ""XOq)XOq)"");
    int int3 = StringUtils.countMatches(""xxxxxxxxxxxxxxxx"", ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    int int4 = StringUtils.indexOfIgnoreCase((CharSequence) ""xDTm(m'~h1DlVpMe"", (CharSequence) ""UlEP6(r?\""&<"");
    String string9 = StringUtils.getCommonPrefix((String[]) null);
    boolean boolean3 = StringUtils.isBlank(""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string10 = StringUtils.substringAfter("",_T?gGN"", ""xR(}3$+"");
    boolean boolean4 = StringUtils.isAlphaSpace(""XOq)XOq)"");
    assertFalse(boolean4);
}","/**
 * <p>Checks if the CharSequence contains only unicode letters and
 * space (' ').</p>
 *
 * <p>{@code null} will return {@code false}
 * An empty CharSequence (length()=0) will return {@code true}.</p>
 *
 * <pre>
 * StringUtils.isAlphaSpace(null)   = false
 * StringUtils.isAlphaSpace("""")     = true
 * StringUtils.isAlphaSpace(""  "")   = true
 * StringUtils.isAlphaSpace(""abc"")  = true
 * StringUtils.isAlphaSpace(""ab c"") = true
 * StringUtils.isAlphaSpace(""ab2c"") = false
 * StringUtils.isAlphaSpace(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if only contains letters and space,
 *  and is non-null
 * @since 3.0 Changed signature from isAlphaSpace(String) to isAlphaSpace(CharSequence)
 */"
"// Contains
//-----------------------------------------------------------------------
/**
 * <p>Checks if CharSequence contains a search character, handling {@code null}.
 * This method uses {@link String#indexOf(int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("""") CharSequence will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.contains(null, *)    = false
 * StringUtils.contains("""", *)      = false
 * StringUtils.contains(""abc"", 'a') = true
 * StringUtils.contains(""abc"", 'z') = false
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @return true if the CharSequence contains the search character,
 *  false if not or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from contains(String, int) to contains(CharSequence, int)
 */
public static boolean contains(CharSequence seq, int searchChar) {
    if (isEmpty(seq)) {
        return false;
    }
    return CharSequenceUtils.indexOf(seq, searchChar, 0) >= 0;
}","public void test2841470() throws Throwable {
    String string0 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 169, 'x');
    String[] stringArray0 = StringUtils.stripAll((String[]) null, ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string1 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 7, 'Q');
    String string2 = StringUtils.defaultString(""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"", ""xR(}3$+"");
    int int0 = StringUtils.lastIndexOf((CharSequence) ""xDTm(m'~h1DlVpMe"", (-1158));
    boolean boolean0 = StringUtils.endsWithAny(""xDTm(m'~h1DlVpMe"", (CharSequence[]) null);
    String string3 = StringUtils.replaceChars(""xDTm(m'~h1DlVpMe"", ""xDTm(m'~h1DlVpMe"", ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string4 = StringUtils.leftPad(""XOq)XOq)"", (-1158), 'd');
    String string5 = StringUtils.stripToNull(""XOq)XOq)"");
    int int1 = StringUtils.indexOfDifference((CharSequence) ""xDTm(m'~h1DlVpMe"", (CharSequence) ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string6 = StringUtils.trim(""lOBgKp"");
    boolean boolean1 = StringUtils.isBlank(""lOBgKp"");
    String string7 = StringUtils.stripStart(""DT"", ""UlEP6(r?\""&<"");
    boolean boolean2 = StringUtils.startsWithAny(""DT"", (CharSequence[]) null);
    int int2 = StringUtils.indexOfAny((CharSequence) ""xR(}3$+"", (CharSequence[]) null);
    String string8 = StringUtils.defaultString(""DT"", ""XOq)XOq)"");
    int int3 = StringUtils.countMatches(""xxxxxxxxxxxxxxxx"", ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    int int4 = StringUtils.indexOfIgnoreCase((CharSequence) ""xDTm(m'~h1DlVpMe"", (CharSequence) ""UlEP6(r?\""&<"");
    String string9 = StringUtils.getCommonPrefix((String[]) null);
    boolean boolean3 = StringUtils.isBlank(""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string10 = StringUtils.substringAfter("",_T?gGN"", ""xR(}3$+"");
    boolean boolean4 = StringUtils.isAlphaSpace(""XOq)XOq)"");
    boolean boolean5 = StringUtils.contains((CharSequence) """", Integer.MAX_VALUE);
    assertFalse(boolean5);
}",""
"public static String trimToNull(String str) {
    String ts = trim(str);
    return isEmpty(ts) ? null : ts;
}","public void test2841476() throws Throwable {
    String string0 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 169, 'x');
    String[] stringArray0 = StringUtils.stripAll((String[]) null, ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string1 = StringUtils.center(""xDTm(m'~h1DlVpMe"", 7, 'Q');
    String string2 = StringUtils.defaultString(""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"", ""xR(}3$+"");
    int int0 = StringUtils.lastIndexOf((CharSequence) ""xDTm(m'~h1DlVpMe"", (-1158));
    boolean boolean0 = StringUtils.endsWithAny(""xDTm(m'~h1DlVpMe"", (CharSequence[]) null);
    String string3 = StringUtils.replaceChars(""xDTm(m'~h1DlVpMe"", ""xDTm(m'~h1DlVpMe"", ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string4 = StringUtils.leftPad(""XOq)XOq)"", (-1158), 'd');
    String string5 = StringUtils.stripToNull(""XOq)XOq)"");
    int int1 = StringUtils.indexOfDifference((CharSequence) ""xDTm(m'~h1DlVpMe"", (CharSequence) ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string6 = StringUtils.trim(""lOBgKp"");
    boolean boolean1 = StringUtils.isBlank(""lOBgKp"");
    String string7 = StringUtils.stripStart(""DT"", ""UlEP6(r?\""&<"");
    boolean boolean2 = StringUtils.startsWithAny(""DT"", (CharSequence[]) null);
    int int2 = StringUtils.indexOfAny((CharSequence) ""xR(}3$+"", (CharSequence[]) null);
    String string8 = StringUtils.defaultString(""DT"", ""XOq)XOq)"");
    int int3 = StringUtils.countMatches(""xxxxxxxxxxxxxxxx"", ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    int int4 = StringUtils.indexOfIgnoreCase((CharSequence) ""xDTm(m'~h1DlVpMe"", (CharSequence) ""UlEP6(r?\""&<"");
    String string9 = StringUtils.getCommonPrefix((String[]) null);
    boolean boolean3 = StringUtils.isBlank(""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxDTm(m'~h1DlVpMexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"");
    String string10 = StringUtils.substringAfter("",_T?gGN"", ""xR(}3$+"");
    boolean boolean4 = StringUtils.isAlphaSpace(""XOq)XOq)"");
    boolean boolean5 = StringUtils.contains((CharSequence) """", Integer.MAX_VALUE);
    String string11 = StringUtils.trimToNull(""k[z3~.y6V@Ai4"");
    assertNotNull(string11);
}","/**
 * <p>Removes control characters (char &lt;= 32) from both
 * ends of this String returning {@code null} if the String is
 * empty ("""") after the trim or if it is {@code null}.
 *
 * <p>The String is trimmed using {@link String#trim()}.
 * Trim removes start and end characters &lt;= 32.
 * To strip whitespace use {@link #stripToNull(String)}.</p>
 *
 * <pre>
 * StringUtils.trimToNull(null)          = null
 * StringUtils.trimToNull("""")            = null
 * StringUtils.trimToNull(""     "")       = null
 * StringUtils.trimToNull(""abc"")         = ""abc""
 * StringUtils.trimToNull(""    abc    "") = ""abc""
 * </pre>
 *
 * @param str  the String to be trimmed, may be null
 * @return the trimmed String,
 *  {@code null} if only chars &lt;= 32, empty or null String input
 * @since 2.0
 */"
"// Misc
//-----------------------------------------------------------------------
/**
 * <p>Find the Levenshtein distance between two Strings.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>The previous implementation of the Levenshtein distance algorithm
 * was from <a href=""http://www.merriampark.com/ld.htm"">http://www.merriampark.com/ld.htm</a></p>
 *
 * <p>Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError
 * which can occur when my Java implementation is used with very large strings.<br>
 * This implementation of the Levenshtein distance algorithm
 * is from <a href=""http://www.merriampark.com/ldjava.htm"">http://www.merriampark.com/ldjava.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("""","""")               = 0
 * StringUtils.getLevenshteinDistance("""",""a"")              = 1
 * StringUtils.getLevenshteinDistance(""aaapppp"", """")       = 7
 * StringUtils.getLevenshteinDistance(""frog"", ""fog"")       = 1
 * StringUtils.getLevenshteinDistance(""fly"", ""ant"")        = 3
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""zzzzzzzz"") = 8
 * StringUtils.getLevenshteinDistance(""hello"", ""hallo"")    = 1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @return result distance
 * @throws IllegalArgumentException if either String input {@code null}
 * @since 3.0 Changed signature from getLevenshteinDistance(String, String) to
 * getLevenshteinDistance(CharSequence, CharSequence)
 */
public static int getLevenshteinDistance(CharSequence s, CharSequence t) {
    if (s == null || t == null) {
        throw new IllegalArgumentException(""Strings must not be null"");
    }
    /*
           The difference between this impl. and the previous is that, rather
           than creating and retaining a matrix of size s.length() + 1 by t.length() + 1,
           we maintain two single-dimensional arrays of length s.length() + 1.  The first, d,
           is the 'current working' distance array that maintains the newest distance cost
           counts as we iterate through the characters of String s.  Each time we increment
           the index of String t we are comparing, d is copied to p, the second int[].  Doing so
           allows us to retain the previous cost counts as required by the algorithm (taking
           the minimum of the cost count to the left, up one, and diagonally up and to the left
           of the current cost count being calculated).  (Note that the arrays aren't really
           copied anymore, just switched...this is clearly much better than cloning an array
           or doing a System.arraycopy() each time  through the outer loop.)

           Effectively, the difference between the two implementations is this one does not
           cause an out of memory condition when calculating the LD over two very large strings.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    if (n == 0) {
        return m;
    } else if (m == 0) {
        return n;
    }
    if (n > m) {
        // swap the input strings to consume less memory
        CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    //'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    //placeholder to assist in swapping p and d
    int[] _d;
    // indexes into strings s and t
    // iterates through s
    int i;
    // iterates through t
    int j;
    // jth character of t
    char t_j;
    // cost
    int cost;
    for (i = 0; i <= n; i++) {
        p[i] = i;
    }
    for (j = 1; j <= m; j++) {
        t_j = t.charAt(j - 1);
        d[0] = j;
        for (i = 1; i <= n; i++) {
            cost = s.charAt(i - 1) == t_j ? 0 : 1;
            // minimum of cell to the left+1, to the top+1, diagonally left and up +cost
            d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost);
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // our last action in the above loop was to switch d and p, so p now
    // actually has the most recent cost counts
    return p[n];
}","public void test2851489() throws Throwable {
    int int0 = 4492;
    StringUtils.repeat("""", 4492);
    StringUtils.containsNone((CharSequence) """", """");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens("""");
    StringUtils.containsNone((CharSequence) """", ""n"");
    String string0 = ""\\u00"";
    StringUtils.stripAll(stringArray0, string0);
    String string1 = StringUtils.repeat('f', 4492);
    String string2 = StringUtils.trimToEmpty(string1);
    String string3 = ""DDb\""N+yvh"";
    String string4 = StringUtils.leftPad(""DDb\""N+yvh"", 4492, 'f');
    StringUtils.isAllLowerCase("""");
    StringUtils.lastOrdinalIndexOf(string2, """", 'f');
    StringUtils.defaultString(string1);
    StringUtils.lastIndexOf((CharSequence) """", (-736), 1934);
    StringUtils.isAlphanumericSpace(string0);
    CharBuffer charBuffer0 = CharBuffer.allocate(1);
    StringUtils.containsIgnoreCase("""", charBuffer0);
    StringUtils.indexOf((CharSequence) """", (-2023), 1683);
    StringUtils.lastIndexOfIgnoreCase((CharSequence) ""n"", (CharSequence) string4);
    // Undeclared exception!
    StringUtils.getLevenshteinDistance((CharSequence) string2, (CharSequence) string0);
}",""
"// Misc
//-----------------------------------------------------------------------
/**
 * <p>Find the Levenshtein distance between two Strings.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>The previous implementation of the Levenshtein distance algorithm
 * was from <a href=""http://www.merriampark.com/ld.htm"">http://www.merriampark.com/ld.htm</a></p>
 *
 * <p>Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError
 * which can occur when my Java implementation is used with very large strings.<br>
 * This implementation of the Levenshtein distance algorithm
 * is from <a href=""http://www.merriampark.com/ldjava.htm"">http://www.merriampark.com/ldjava.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("""","""")               = 0
 * StringUtils.getLevenshteinDistance("""",""a"")              = 1
 * StringUtils.getLevenshteinDistance(""aaapppp"", """")       = 7
 * StringUtils.getLevenshteinDistance(""frog"", ""fog"")       = 1
 * StringUtils.getLevenshteinDistance(""fly"", ""ant"")        = 3
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""zzzzzzzz"") = 8
 * StringUtils.getLevenshteinDistance(""hello"", ""hallo"")    = 1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @return result distance
 * @throws IllegalArgumentException if either String input {@code null}
 * @since 3.0 Changed signature from getLevenshteinDistance(String, String) to
 * getLevenshteinDistance(CharSequence, CharSequence)
 */
public static int getLevenshteinDistance(CharSequence s, CharSequence t) {
    if (s == null || t == null) {
        throw new IllegalArgumentException(""Strings must not be null"");
    }
    /*
           The difference between this impl. and the previous is that, rather
           than creating and retaining a matrix of size s.length() + 1 by t.length() + 1,
           we maintain two single-dimensional arrays of length s.length() + 1.  The first, d,
           is the 'current working' distance array that maintains the newest distance cost
           counts as we iterate through the characters of String s.  Each time we increment
           the index of String t we are comparing, d is copied to p, the second int[].  Doing so
           allows us to retain the previous cost counts as required by the algorithm (taking
           the minimum of the cost count to the left, up one, and diagonally up and to the left
           of the current cost count being calculated).  (Note that the arrays aren't really
           copied anymore, just switched...this is clearly much better than cloning an array
           or doing a System.arraycopy() each time  through the outer loop.)

           Effectively, the difference between the two implementations is this one does not
           cause an out of memory condition when calculating the LD over two very large strings.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    if (n == 0) {
        return m;
    } else if (m == 0) {
        return n;
    }
    if (n > m) {
        // swap the input strings to consume less memory
        CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    //'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    //placeholder to assist in swapping p and d
    int[] _d;
    // indexes into strings s and t
    // iterates through s
    int i;
    // iterates through t
    int j;
    // jth character of t
    char t_j;
    // cost
    int cost;
    for (i = 0; i <= n; i++) {
        p[i] = i;
    }
    for (j = 1; j <= m; j++) {
        t_j = t.charAt(j - 1);
        d[0] = j;
        for (i = 1; i <= n; i++) {
            cost = s.charAt(i - 1) == t_j ? 0 : 1;
            // minimum of cell to the left+1, to the top+1, diagonally left and up +cost
            d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost);
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // our last action in the above loop was to switch d and p, so p now
    // actually has the most recent cost counts
    return p[n];
}","public void test2861490() throws Throwable {
    StringUtils.splitByCharacterType(""#QZ&D \""l"");
    StringUtils.indexOfIgnoreCase((CharSequence) ""#QZ&D \""l"", (CharSequence) ""#QZ&D \""l"");
    StringUtils.abbreviateMiddle((String) null, (String) null, 0);
    StringUtils.stripEnd(""#QZ&D \""l"", ""#QZ&D \""l"");
    StringUtils.rightPad(""#QZ&D \""l"", 43, ""r"");
    StringUtils.stripAccents(""#QZ&D \""l"");
    StringUtils.trimToNull(""#QZ&D \""l"");
    StringUtils.indexOfIgnoreCase((CharSequence) null, (CharSequence) null);
    StringUtils.center(""^%OBe<1l?5a]:LA7I7d"", (-865), 'y');
    StringUtils.ordinalIndexOf((CharSequence) null, ""^%OBe<1l?5a]:LA7I7d"", (-1683));
    StringUtils.substring("")D<^x)lb;rM3r"", (-1), (-1));
    StringUtils.contains((CharSequence) ""^%OBe<1l?5a]:LA7I7d"", (CharSequence) ""^%OBe<1l?5a]:LA7I7d"");
    StringUtils.overlay(""The Character must not be null"", ""ntrRV0~NI"", (-1683), 30);
    StringUtils.contains((CharSequence) """", (CharSequence) ""#QZ&D \""l"");
    StringUtils.indexOfIgnoreCase((CharSequence) ""^%OBe<1l?5a]:LA7I7d"", (CharSequence) ""r"", 3415);
    StringUtils.center((String) null, 32, ""rr[Y1jd lPy*oG !J-?7SyC"");
    // Undeclared exception!
    try {
        StringUtils.getLevenshteinDistance((CharSequence) ""^%OBe<1l?5a]:LA7I7d"", (CharSequence) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Strings must not be null
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}",""
"// Chopping
//-----------------------------------------------------------------------
/**
 * <p>Remove the last character from a String.</p>
 *
 * <p>If the String ends in {@code \r\n}, then remove both
 * of them.</p>
 *
 * <pre>
 * StringUtils.chop(null)          = null
 * StringUtils.chop("""")            = """"
 * StringUtils.chop(""abc \r"")      = ""abc ""
 * StringUtils.chop(""abc\n"")       = ""abc""
 * StringUtils.chop(""abc\r\n"")     = ""abc""
 * StringUtils.chop(""abc"")         = ""ab""
 * StringUtils.chop(""abc\nabc"")    = ""abc\nab""
 * StringUtils.chop(""a"")           = """"
 * StringUtils.chop(""\r"")          = """"
 * StringUtils.chop(""\n"")          = """"
 * StringUtils.chop(""\r\n"")        = """"
 * </pre>
 *
 * @param str  the String to chop last character from, may be null
 * @return String without last character, {@code null} if null String input
 */
public static String chop(String str) {
    if (str == null) {
        return null;
    }
    int strLen = str.length();
    if (strLen < 2) {
        return EMPTY;
    }
    int lastIdx = strLen - 1;
    String ret = str.substring(0, lastIdx);
    char last = str.charAt(lastIdx);
    if (last == CharUtils.LF) {
        if (ret.charAt(lastIdx - 1) == CharUtils.CR) {
            return ret.substring(0, lastIdx - 1);
        }
    }
    return ret;
}","public void test2871492() throws Throwable {
    String string0 = StringUtils.removeStart(""Exception cloning Cloneable type "", ""Exception cloning Cloneable type "");
    String string1 = StringUtils.removeStart("""", "".KkU1YgR}zN"");
    StringUtils.chomp("""");
    String string2 = StringUtils.replaceChars("""", """", ""Qhj\""F!dPV6AR3rv"");
    String string3 = StringUtils.chop(""7k"");
    assertNotNull(string3);
}",""
"public static String join(Object[] array, char separator) {
    if (array == null) {
        return null;
    }
    return join(array, separator, 0, array.length);
}","public void test2871494() throws Throwable {
    String string0 = StringUtils.removeStart(""Exception cloning Cloneable type "", ""Exception cloning Cloneable type "");
    String string1 = StringUtils.removeStart("""", "".KkU1YgR}zN"");
    StringUtils.chomp("""");
    String string2 = StringUtils.replaceChars("""", """", ""Qhj\""F!dPV6AR3rv"");
    String string3 = StringUtils.chop(""7k"");
    Object[] objectArray0 = new Object[7];
    objectArray0[0] = (Object) """";
    objectArray0[1] = (Object) ""7k"";
    objectArray0[2] = (Object) """";
    objectArray0[3] = (Object) """";
    objectArray0[4] = (Object) """";
    objectArray0[5] = (Object) ""7k"";
    objectArray0[6] = (Object) ""Exception cloning Cloneable type "";
    String string4 = StringUtils.join(objectArray0, 'f');
    assertEquals(""f7kffff7kfException cloning Cloneable type "", string4);
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)               = null
 * StringUtils.join([], *)                 = """"
 * StringUtils.join([null], *)             = """"
 * StringUtils.join([""a"", ""b"", ""c""], ';')  = ""a;b;c""
 * StringUtils.join([""a"", ""b"", ""c""], null) = ""abc""
 * StringUtils.join([null, """", ""a""], ';')  = "";;a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use
 * @return the joined String, {@code null} if null array input
 * @since 2.0
 */"
"public static boolean containsOnly(CharSequence cs, String validChars) {
    if (cs == null || validChars == null) {
        return false;
    }
    return containsOnly(cs, validChars.toCharArray());
}","public void test2871496() throws Throwable {
    String string0 = StringUtils.removeStart(""Exception cloning Cloneable type "", ""Exception cloning Cloneable type "");
    String string1 = StringUtils.removeStart("""", "".KkU1YgR}zN"");
    StringUtils.chomp("""");
    String string2 = StringUtils.replaceChars("""", """", ""Qhj\""F!dPV6AR3rv"");
    String string3 = StringUtils.chop(""7k"");
    Object[] objectArray0 = new Object[7];
    objectArray0[0] = (Object) """";
    objectArray0[1] = (Object) ""7k"";
    objectArray0[2] = (Object) """";
    objectArray0[3] = (Object) """";
    objectArray0[4] = (Object) """";
    objectArray0[5] = (Object) ""7k"";
    objectArray0[6] = (Object) ""Exception cloning Cloneable type "";
    String string4 = StringUtils.join(objectArray0, 'f');
    String string5 = StringUtils.substringBeforeLast("""", ""4444"");
    boolean boolean0 = StringUtils.containsOnly((CharSequence) """", ""[Ef\""^h"");
    assertTrue(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only certain characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.
 * A {@code null} valid character String will return {@code false}.
 * An empty String (length()=0) always returns {@code true}.</p>
 *
 * <pre>
 * StringUtils.containsOnly(null, *)       = false
 * StringUtils.containsOnly(*, null)       = false
 * StringUtils.containsOnly("""", *)         = true
 * StringUtils.containsOnly(""ab"", """")      = false
 * StringUtils.containsOnly(""abab"", ""abc"") = true
 * StringUtils.containsOnly(""ab1"", ""abc"")  = false
 * StringUtils.containsOnly(""abz"", ""abc"")  = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param validChars  a String of valid chars, may be null
 * @return true if it only contains valid chars and is non-null
 * @since 2.0
 * @since 3.0 Changed signature from containsOnly(String, String) to containsOnly(CharSequence, String)
 */"
"public static String leftPad(String str, int size, String padStr) {
    if (str == null) {
        return null;
    }
    if (isEmpty(padStr)) {
        padStr = "" "";
    }
    int padLen = padStr.length();
    int strLen = str.length();
    int pads = size - strLen;
    if (pads <= 0) {
        // returns original String when possible
        return str;
    }
    if (padLen == 1 && pads <= PAD_LIMIT) {
        return leftPad(str, size, padStr.charAt(0));
    }
    if (pads == padLen) {
        return padStr.concat(str);
    } else if (pads < padLen) {
        return padStr.substring(0, pads).concat(str);
    } else {
        char[] padding = new char[pads];
        char[] padChars = padStr.toCharArray();
        for (int i = 0; i < pads; i++) {
            padding[i] = padChars[i % padLen];
        }
        return new String(padding).concat(str);
    }
}","public void test2881498() throws Throwable {
    String string0 = StringUtils.leftPad(""ciX?-maH5XWZ("", 510, ""ciX?-maH5XWZ("");
    assertEquals(""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("", string0);
}","/**
 * <p>Left pad a String with a specified String.</p>
 *
 * <p>Pad to a size of {@code size}.</p>
 *
 * <pre>
 * StringUtils.leftPad(null, *, *)      = null
 * StringUtils.leftPad("""", 3, ""z"")      = ""zzz""
 * StringUtils.leftPad(""bat"", 3, ""yz"")  = ""bat""
 * StringUtils.leftPad(""bat"", 5, ""yz"")  = ""yzbat""
 * StringUtils.leftPad(""bat"", 8, ""yz"")  = ""yzyzybat""
 * StringUtils.leftPad(""bat"", 1, ""yz"")  = ""bat""
 * StringUtils.leftPad(""bat"", -1, ""yz"") = ""bat""
 * StringUtils.leftPad(""bat"", 5, null)  = ""  bat""
 * StringUtils.leftPad(""bat"", 5, """")    = ""  bat""
 * </pre>
 *
 * @param str  the String to pad out, may be null
 * @param size  the size to pad to
 * @param padStr  the String to pad with, null or empty treated as single space
 * @return left padded String or original String if no padding is necessary,
 *  {@code null} if null String input
 */"
"public static boolean endsWithAny(CharSequence string, CharSequence... searchStrings) {
    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {
        return false;
    }
    for (int i = 0; i < searchStrings.length; i++) {
        CharSequence searchString = searchStrings[i];
        if (StringUtils.endsWith(string, searchString)) {
            return true;
        }
    }
    return false;
}","public void test2881499() throws Throwable {
    String string0 = StringUtils.leftPad(""ciX?-maH5XWZ("", 510, ""ciX?-maH5XWZ("");
    CharSequence[] charSequenceArray0 = new CharSequence[2];
    charSequenceArray0[0] = (CharSequence) ""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("";
    charSequenceArray0[1] = (CharSequence) ""ciX?-maH5XWZ("";
    boolean boolean0 = StringUtils.endsWithAny(""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("", charSequenceArray0);
    assertTrue(boolean0);
}","/**
 * <p>Check if a CharSequence ends with any of an array of specified strings.</p>
 *
 * <pre>
 * StringUtils.endsWithAny(null, null)      = false
 * StringUtils.endsWithAny(null, new String[] {""abc""})  = false
 * StringUtils.endsWithAny(""abcxyz"", null)     = false
 * StringUtils.endsWithAny(""abcxyz"", new String[] {""""}) = true
 * StringUtils.endsWithAny(""abcxyz"", new String[] {""xyz""}) = true
 * StringUtils.endsWithAny(""abcxyz"", new String[] {null, ""xyz"", ""abc""}) = true
 * </pre>
 *
 * @param string  the CharSequence to check, may be null
 * @param searchStrings the CharSequences to find, may be null or empty
 * @return {@code true} if the CharSequence ends with any of the the prefixes, case insensitive, or
 *  both {@code null}
 * @since 3.0
 */"
"// Abbreviating
//-----------------------------------------------------------------------
/**
 * <p>Abbreviates a String using ellipses. This will turn
 * ""Now is the time for all good men"" into ""Now is the time for...""</p>
 *
 * <p>Specifically:
 * <ul>
 *   <li>If {@code str} is less than {@code maxWidth} characters
 *       long, return it.</li>
 *   <li>Else abbreviate it to {@code (substring(str, 0, max-3) + ""..."")}.</li>
 *   <li>If {@code maxWidth} is less than {@code 4}, throw an
 *       {@code IllegalArgumentException}.</li>
 *   <li>In no case will it return a String of length greater than
 *       {@code maxWidth}.</li>
 * </ul>
 * </p>
 *
 * <pre>
 * StringUtils.abbreviate(null, *)      = null
 * StringUtils.abbreviate("""", 4)        = """"
 * StringUtils.abbreviate(""abcdefg"", 6) = ""abc...""
 * StringUtils.abbreviate(""abcdefg"", 7) = ""abcdefg""
 * StringUtils.abbreviate(""abcdefg"", 8) = ""abcdefg""
 * StringUtils.abbreviate(""abcdefg"", 4) = ""a...""
 * StringUtils.abbreviate(""abcdefg"", 3) = IllegalArgumentException
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param maxWidth  maximum length of result String, must be at least 4
 * @return abbreviated String, {@code null} if null String input
 * @throws IllegalArgumentException if the width is too small
 * @since 2.0
 */
public static String abbreviate(String str, int maxWidth) {
    return abbreviate(str, 0, maxWidth);
}","public void test2881500() throws Throwable {
    String string0 = StringUtils.leftPad(""ciX?-maH5XWZ("", 510, ""ciX?-maH5XWZ("");
    CharSequence[] charSequenceArray0 = new CharSequence[2];
    charSequenceArray0[0] = (CharSequence) ""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("";
    charSequenceArray0[1] = (CharSequence) ""ciX?-maH5XWZ("";
    boolean boolean0 = StringUtils.endsWithAny(""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("", charSequenceArray0);
    String[] stringArray0 = new String[1];
    stringArray0[0] = ""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("";
    String[] stringArray1 = StringUtils.stripAll(stringArray0);
    String string1 = StringUtils.abbreviate(""Exception cloning Cloneable type "", 13);
    assertEquals(""Exception ..."", string1);
}",""
"public static int lastIndexOfAny(CharSequence str, CharSequence... searchStrs) {
    if (str == null || searchStrs == null) {
        return INDEX_NOT_FOUND;
    }
    int sz = searchStrs.length;
    int ret = INDEX_NOT_FOUND;
    int tmp = 0;
    for (int i = 0; i < sz; i++) {
        CharSequence search = searchStrs[i];
        if (search == null) {
            continue;
        }
        tmp = CharSequenceUtils.lastIndexOf(str, search, str.length());
        if (tmp > ret) {
            ret = tmp;
        }
    }
    return ret;
}","public void test2881501() throws Throwable {
    String string0 = StringUtils.leftPad(""ciX?-maH5XWZ("", 510, ""ciX?-maH5XWZ("");
    CharSequence[] charSequenceArray0 = new CharSequence[2];
    charSequenceArray0[0] = (CharSequence) ""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("";
    charSequenceArray0[1] = (CharSequence) ""ciX?-maH5XWZ("";
    boolean boolean0 = StringUtils.endsWithAny(""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("", charSequenceArray0);
    String[] stringArray0 = new String[1];
    stringArray0[0] = ""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("";
    String[] stringArray1 = StringUtils.stripAll(stringArray0);
    String string1 = StringUtils.abbreviate(""Exception cloning Cloneable type "", 13);
    StringUtils.ordinalIndexOf(""ciX?-maH5XWZ("", charSequenceArray0[0], 13);
    int int0 = StringUtils.lastIndexOfAny(charSequenceArray0[0], stringArray1);
    assertNotSame(stringArray1, stringArray0);
}","/**
 * <p>Find the latest index of any of a set of potential substrings.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A {@code null} search array will return {@code -1}.
 * A {@code null} or zero length search array entry will be ignored,
 * but a search array containing """" will return the length of {@code str}
 * if {@code str} is not null. This method uses {@link String#indexOf(String)} if possible</p>
 *
 * <pre>
 * StringUtils.lastIndexOfAny(null, *)                   = -1
 * StringUtils.lastIndexOfAny(*, null)                   = -1
 * StringUtils.lastIndexOfAny(*, [])                     = -1
 * StringUtils.lastIndexOfAny(*, [null])                 = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""ab"",""cd""]) = 6
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""cd"",""ab""]) = 6
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""op""]) = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""op""]) = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""""])   = 10
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStrs  the CharSequences to search for, may be null
 * @return the last index of any of the CharSequences, -1 if no match
 * @since 3.0 Changed signature from lastIndexOfAny(String, String[]) to lastIndexOfAny(CharSequence, CharSequence)
 */"
"public static String mid(String str, int pos, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0 || pos > str.length()) {
        return EMPTY;
    }
    if (pos < 0) {
        pos = 0;
    }
    if (str.length() <= (pos + len)) {
        return str.substring(pos);
    }
    return str.substring(pos, pos + len);
}","public void test2881503() throws Throwable {
    String string0 = StringUtils.leftPad(""ciX?-maH5XWZ("", 510, ""ciX?-maH5XWZ("");
    CharSequence[] charSequenceArray0 = new CharSequence[2];
    charSequenceArray0[0] = (CharSequence) ""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("";
    charSequenceArray0[1] = (CharSequence) ""ciX?-maH5XWZ("";
    boolean boolean0 = StringUtils.endsWithAny(""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("", charSequenceArray0);
    String[] stringArray0 = new String[1];
    stringArray0[0] = ""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("";
    String[] stringArray1 = StringUtils.stripAll(stringArray0);
    String string1 = StringUtils.abbreviate(""Exception cloning Cloneable type "", 13);
    StringUtils.ordinalIndexOf(""ciX?-maH5XWZ("", charSequenceArray0[0], 13);
    int int0 = StringUtils.lastIndexOfAny(charSequenceArray0[0], stringArray1);
    StringUtils.stripToNull(""Exception ..."");
    String string2 = StringUtils.mid(""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("", 13, 510);
    assertEquals(""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("", string2);
}","/**
 * <p>Gets {@code len} characters from the middle of a String.</p>
 *
 * <p>If {@code len} characters are not available, the remainder
 * of the String will be returned without an exception. If the
 * String is {@code null}, {@code null} will be returned.
 * An empty String is returned if len is negative or exceeds the
 * length of {@code str}.</p>
 *
 * <pre>
 * StringUtils.mid(null, *, *)    = null
 * StringUtils.mid(*, *, -ve)     = """"
 * StringUtils.mid("""", 0, *)      = """"
 * StringUtils.mid(""abc"", 0, 2)   = ""ab""
 * StringUtils.mid(""abc"", 0, 4)   = ""abc""
 * StringUtils.mid(""abc"", 2, 4)   = ""c""
 * StringUtils.mid(""abc"", 4, 2)   = """"
 * StringUtils.mid(""abc"", -2, 2)  = ""ab""
 * </pre>
 *
 * @param str  the String to get the characters from, may be null
 * @param pos  the position to start from, negative treated as zero
 * @param len  the length of the required String
 * @return the middle characters, {@code null} if null String input
 */"
"// Overlay
//-----------------------------------------------------------------------
/**
 * <p>Overlays part of a String with another String.</p>
 *
 * <p>A {@code null} string input returns {@code null}.
 * A negative index is treated as zero.
 * An index greater than the string length is treated as the string length.
 * The start index is always the smaller of the two indices.</p>
 *
 * <pre>
 * StringUtils.overlay(null, *, *, *)            = null
 * StringUtils.overlay("""", ""abc"", 0, 0)          = ""abc""
 * StringUtils.overlay(""abcdef"", null, 2, 4)     = ""abef""
 * StringUtils.overlay(""abcdef"", """", 2, 4)       = ""abef""
 * StringUtils.overlay(""abcdef"", """", 4, 2)       = ""abef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 2, 4)   = ""abzzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 4, 2)   = ""abzzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", -1, 4)  = ""zzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 2, 8)   = ""abzzzz""
 * StringUtils.overlay(""abcdef"", ""zzzz"", -2, -3) = ""zzzzabcdef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 8, 10)  = ""abcdefzzzz""
 * </pre>
 *
 * @param str  the String to do overlaying in, may be null
 * @param overlay  the String to overlay, may be null
 * @param start  the position to start overlaying at
 * @param end  the position to stop overlaying before
 * @return overlayed String, {@code null} if null String input
 * @since 2.0
 */
public static String overlay(String str, String overlay, int start, int end) {
    if (str == null) {
        return null;
    }
    if (overlay == null) {
        overlay = EMPTY;
    }
    int len = str.length();
    if (start < 0) {
        start = 0;
    }
    if (start > len) {
        start = len;
    }
    if (end < 0) {
        end = 0;
    }
    if (end > len) {
        end = len;
    }
    if (start > end) {
        int temp = start;
        start = end;
        end = temp;
    }
    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();
}","public void test2881504() throws Throwable {
    String string0 = StringUtils.leftPad(""ciX?-maH5XWZ("", 510, ""ciX?-maH5XWZ("");
    CharSequence[] charSequenceArray0 = new CharSequence[2];
    charSequenceArray0[0] = (CharSequence) ""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("";
    charSequenceArray0[1] = (CharSequence) ""ciX?-maH5XWZ("";
    boolean boolean0 = StringUtils.endsWithAny(""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("", charSequenceArray0);
    String[] stringArray0 = new String[1];
    stringArray0[0] = ""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("";
    String[] stringArray1 = StringUtils.stripAll(stringArray0);
    String string1 = StringUtils.abbreviate(""Exception cloning Cloneable type "", 13);
    StringUtils.ordinalIndexOf(""ciX?-maH5XWZ("", charSequenceArray0[0], 13);
    int int0 = StringUtils.lastIndexOfAny(charSequenceArray0[0], stringArray1);
    StringUtils.stripToNull(""Exception ..."");
    String string2 = StringUtils.mid(""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("", 13, 510);
    LinkedHashSet<Locale.FilteringMode> linkedHashSet0 = new LinkedHashSet<Locale.FilteringMode>();
    Iterator<Locale.FilteringMode> iterator0 = linkedHashSet0.iterator();
    Locale.FilteringMode locale_FilteringMode0 = Locale.FilteringMode.REJECT_EXTENDED_RANGES;
    linkedHashSet0.add(locale_FilteringMode0);
    StringUtils.join(iterator0, '}');
    StringUtils.rightPad(""ciX?-maH5XWZ("", 0, ""/x&<_x`RJm/x&<_x`RJm"");
    StringUtils.chomp(""xDTm(m'~h1DlVpMUe"", ""ciX?-maH5XWZ("");
    StringUtils.lastIndexOf((CharSequence) ""xDTm(m'~h1DlVpMe"", (CharSequence) ""xDTm(m'~h1DlVpMUe"");
    String string3 = StringUtils.overlay(""ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciX?-maH5XWZ(ciXciX?-maH5XWZ("", ""Yr|%/Du0&"", 1814, (-1));
    assertEquals(""Yr|%/Du0&"", string3);
}",""
"public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {
    // timeToLive should be 0 if not used or nothing to replace, else it's
    // the length of the replace array
    int timeToLive = searchList == null ? 0 : searchList.length;
    return replaceEach(text, searchList, replacementList, true, timeToLive);
}","public void test2891505() throws Throwable {
    String string0 = StringUtils.replaceEachRepeatedly(""p{InCombiningDiacriticalMarks}+"", (String[]) null, (String[]) null);
    assertEquals(""p{InCombiningDiacriticalMarks}+"", string0);
}","/**
 * <p>
 * Replaces all occurrences of Strings within another String.
 * </p>
 *
 * <p>
 * A {@code null} reference passed to this method is a no-op, or if
 * any ""search string"" or ""string to replace"" is null, that replace will be
 * ignored. This will not repeat. For repeating replaces, call the
 * overloaded method.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *, *) = null
 *  StringUtils.replaceEach("""", *, *, *) = """"
 *  StringUtils.replaceEach(""aba"", null, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[0], null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", null, new String[0], *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""}, *) = ""b""
 *  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""}, *) = ""aba""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""}, *) = ""wcte""
 *  (example of how it repeats)
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, false) = ""dcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, true) = ""tcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, true) = IllegalArgumentException
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, false) = ""dcabe""
 * </pre>
 *
 * @param text
 *            text to search and replace in, no-op if null
 * @param searchList
 *            the Strings to search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @return the text with any replacements processed, {@code null} if
 *         null String input
 * @throws IllegalArgumentException
 *             if the search is repeating and there is an endless loop due
 *             to outputs of one being inputs to another
 * @throws IndexOutOfBoundsException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */"
"public static int indexOfAnyBut(CharSequence seq, CharSequence searchChars) {
    if (isEmpty(seq) || isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int strLen = seq.length();
    for (int i = 0; i < strLen; i++) {
        char ch = seq.charAt(i);
        boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0;
        if (i + 1 < strLen && Character.isHighSurrogate(ch)) {
            char ch2 = seq.charAt(i + 1);
            if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) {
                return i;
            }
        } else {
            if (!chFound) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}","public void test2891506() throws Throwable {
    String string0 = StringUtils.replaceEachRepeatedly(""p{InCombiningDiacriticalMarks}+"", (String[]) null, (String[]) null);
    StringUtils.indexOfAny((CharSequence) ""p{InCombiningDiacriticalMarks}+"", (CharSequence[]) null);
    int int0 = StringUtils.indexOfAnyBut((CharSequence) ""p{InCombiningDiacriticalMarks}+"", (CharSequence) ""p{InCombiningDiacriticalMarks}+"");
    assertEquals((-1), int0);
}","/**
 * <p>Search a CharSequence to find the first index of any
 * character not in the given set of characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A {@code null} or empty search string will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAnyBut(null, *)            = -1
 * StringUtils.indexOfAnyBut("""", *)              = -1
 * StringUtils.indexOfAnyBut(*, null)            = -1
 * StringUtils.indexOfAnyBut(*, """")              = -1
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", ""za"") = 3
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", """")   = -1
 * StringUtils.indexOfAnyBut(""aba"",""ab"")         = -1
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAnyBut(String, String) to indexOfAnyBut(CharSequence, CharSequence)
 */"
"public static String center(String str, int size, String padStr) {
    if (str == null || size <= 0) {
        return str;
    }
    if (isEmpty(padStr)) {
        padStr = "" "";
    }
    int strLen = str.length();
    int pads = size - strLen;
    if (pads <= 0) {
        return str;
    }
    str = leftPad(str, strLen + pads / 2, padStr);
    str = rightPad(str, size, padStr);
    return str;
}","public void test2891507() throws Throwable {
    String string0 = StringUtils.replaceEachRepeatedly(""p{InCombiningDiacriticalMarks}+"", (String[]) null, (String[]) null);
    StringUtils.indexOfAny((CharSequence) ""p{InCombiningDiacriticalMarks}+"", (CharSequence[]) null);
    int int0 = StringUtils.indexOfAnyBut((CharSequence) ""p{InCombiningDiacriticalMarks}+"", (CharSequence) ""p{InCombiningDiacriticalMarks}+"");
    StringUtils.equalsIgnoreCase(""p{InCombiningDiacriticalMarks}+"", ""p{InCombiningDiacriticalMarks}+"");
    StringUtils.center(""p{InCombiningDiacriticalMarks}+"", (-1), '\""');
    String string1 = StringUtils.center(""NFD"", 103, ""p{InCombiningDiacriticalMarks}+"");
    assertEquals(""p{InCombiningDiacriticalMarks}+p{InCombiningDiacriNFDp{InCombiningDiacriticalMarks}+p{InCombiningDiacri"", string1);
}","/**
 * <p>Centers a String in a larger String of size {@code size}.
 * Uses a supplied String as the value to pad the String with.</p>
 *
 * <p>If the size is less than the String length, the String is returned.
 * A {@code null} String returns {@code null}.
 * A negative size is treated as zero.</p>
 *
 * <pre>
 * StringUtils.center(null, *, *)     = null
 * StringUtils.center("""", 4, "" "")     = ""    ""
 * StringUtils.center(""ab"", -1, "" "")  = ""ab""
 * StringUtils.center(""ab"", 4, "" "")   = "" ab""
 * StringUtils.center(""abcd"", 2, "" "") = ""abcd""
 * StringUtils.center(""a"", 4, "" "")    = "" a  ""
 * StringUtils.center(""a"", 4, ""yz"")   = ""yayz""
 * StringUtils.center(""abc"", 7, null) = ""  abc  ""
 * StringUtils.center(""abc"", 7, """")   = ""  abc  ""
 * </pre>
 *
 * @param str  the String to center, may be null
 * @param size  the int size of new String, negative treated as zero
 * @param padStr  the String to pad the new String with, must not be null or empty
 * @return centered String, {@code null} if null String input
 * @throws IllegalArgumentException if padStr is {@code null} or empty
 */"
"public static String removeStartIgnoreCase(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (startsWithIgnoreCase(str, remove)) {
        return str.substring(remove.length());
    }
    return str;
}","public void test2901508() throws Throwable {
    String string0 = StringUtils.chomp("""", """");
    String string1 = StringUtils.removeStartIgnoreCase(""(Rnu{iF%.J^M#D"", ""(Rnu{iF%.J^M#D"");
    assertEquals("""", string1);
}","/**
 * <p>Case insensitive removal of a substring if it is at the begining of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("""") source string will return the empty string.
 * A {@code null} search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeStartIgnoreCase(null, *)      = null
 * StringUtils.removeStartIgnoreCase("""", *)        = """"
 * StringUtils.removeStartIgnoreCase(*, null)      = *
 * StringUtils.removeStartIgnoreCase(""www.domain.com"", ""www."")   = ""domain.com""
 * StringUtils.removeStartIgnoreCase(""www.domain.com"", ""WWW."")   = ""domain.com""
 * StringUtils.removeStartIgnoreCase(""domain.com"", ""www."")       = ""domain.com""
 * StringUtils.removeStartIgnoreCase(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeStartIgnoreCase(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for (case insensitive) and remove, may be null
 * @return the substring with the string removed if found,
 *  {@code null} if null String input
 * @since 2.4
 */"
"// Delete
//-----------------------------------------------------------------------
/**
 * <p>Deletes all whitespaces from a String as defined by
 * {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.deleteWhitespace(null)         = null
 * StringUtils.deleteWhitespace("""")           = """"
 * StringUtils.deleteWhitespace(""abc"")        = ""abc""
 * StringUtils.deleteWhitespace(""   ab  c  "") = ""abc""
 * </pre>
 *
 * @param str  the String to delete whitespace from, may be null
 * @return the String without whitespaces, {@code null} if null String input
 */
public static String deleteWhitespace(String str) {
    if (isEmpty(str)) {
        return str;
    }
    int sz = str.length();
    char[] chs = new char[sz];
    int count = 0;
    for (int i = 0; i < sz; i++) {
        if (!Character.isWhitespace(str.charAt(i))) {
            chs[count++] = str.charAt(i);
        }
    }
    if (count == sz) {
        return str;
    }
    return new String(chs, 0, count);
}","public void test2901509() throws Throwable {
    String string0 = StringUtils.chomp("""", """");
    String string1 = StringUtils.removeStartIgnoreCase(""(Rnu{iF%.J^M#D"", ""(Rnu{iF%.J^M#D"");
    String string2 = StringUtils.deleteWhitespace(""(Rnu{iF%.J^M#D"");
    assertEquals(""(Rnu{iF%.J^M#D"", string2);
}",""
"public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {
    return splitWorker(str, separatorChars, max, true);
}","public void test2901510() throws Throwable {
    String string0 = StringUtils.chomp("""", """");
    String string1 = StringUtils.removeStartIgnoreCase(""(Rnu{iF%.J^M#D"", ""(Rnu{iF%.J^M#D"");
    String string2 = StringUtils.deleteWhitespace(""(Rnu{iF%.J^M#D"");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""(Rnu{iF%.J^M#D"", ""decompose"", 0);
    assertEquals(1, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array with a maximum length,
 * separators specified, preserving all tokens, including empty tokens
 * created by adjacent separators.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as separators for empty tokens.
 * Adjacent separators are treated as one separator.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} separatorChars splits on whitespace.</p>
 *
 * <p>If more than {@code max} delimited substrings are found, the last
 * returned string includes all characters after the first {@code max - 1}
 * returned strings (including separator characters).</p>
 *
 * <pre>
 * StringUtils.splitPreserveAllTokens(null, *, *)            = null
 * StringUtils.splitPreserveAllTokens("""", *, *)              = []
 * StringUtils.splitPreserveAllTokens(""ab de fg"", null, 0)   = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 0) = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef"", "":"", 0)    = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef"", "":"", 2)    = [""ab"", ""cd:ef""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 2) = [""ab"", ""  de fg""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 3) = [""ab"", """", "" de fg""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 4) = [""ab"", """", """", ""de fg""]
 * </pre>
 *
 * @param str  the String to parse, may be {@code null}
 * @param separatorChars  the characters used as the delimiters,
 *  {@code null} splits on whitespace
 * @param max  the maximum number of elements to include in the
 *  array. A zero or negative value implies no limit
 * @return an array of parsed Strings, {@code null} if null String input
 * @since 2.1
 */"
"public static String uncapitalize(String str) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    return new StringBuilder(strLen).append(Character.toLowerCase(str.charAt(0))).append(str.substring(1)).toString();
}","public void test2901511() throws Throwable {
    String string0 = StringUtils.chomp("""", """");
    String string1 = StringUtils.removeStartIgnoreCase(""(Rnu{iF%.J^M#D"", ""(Rnu{iF%.J^M#D"");
    String string2 = StringUtils.deleteWhitespace(""(Rnu{iF%.J^M#D"");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""(Rnu{iF%.J^M#D"", ""decompose"", 0);
    String string3 = StringUtils.rightPad("""", 1462, ""SecurityException occurred"");
    StringUtils.capitalize(""XOq)"");
    StringUtils.removeStartIgnoreCase("""", ""I9"");
    String string4 = StringUtils.uncapitalize(""Xw%#c{@u7-q"");
    assertEquals(""xw%#c{@u7-q"", string4);
}","/**
 * <p>Uncapitalizes a String changing the first letter to title case as
 * per {@link Character#toLowerCase(char)}. No other letters are changed.</p>
 *
 * <p>For a word based algorithm, see {@link org.apache.commons.lang3.text.WordUtils#uncapitalize(String)}.
 * A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.uncapitalize(null)  = null
 * StringUtils.uncapitalize("""")    = """"
 * StringUtils.uncapitalize(""Cat"") = ""cat""
 * StringUtils.uncapitalize(""CAT"") = ""cAT""
 * </pre>
 *
 * @param str the String to uncapitalize, may be null
 * @return the uncapitalized String, {@code null} if null String input
 * @see org.apache.commons.lang3.text.WordUtils#uncapitalize(String)
 * @see #capitalize(String)
 * @since 2.0
 */"
"public static int indexOfAny(CharSequence cs, String searchChars) {
    if (isEmpty(cs) || isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    return indexOfAny(cs, searchChars.toCharArray());
}","public void test2901512() throws Throwable {
    String string0 = StringUtils.chomp("""", """");
    String string1 = StringUtils.removeStartIgnoreCase(""(Rnu{iF%.J^M#D"", ""(Rnu{iF%.J^M#D"");
    String string2 = StringUtils.deleteWhitespace(""(Rnu{iF%.J^M#D"");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""(Rnu{iF%.J^M#D"", ""decompose"", 0);
    String string3 = StringUtils.rightPad("""", 1462, ""SecurityException occurred"");
    StringUtils.capitalize(""XOq)"");
    StringUtils.removeStartIgnoreCase("""", ""I9"");
    String string4 = StringUtils.uncapitalize(""Xw%#c{@u7-q"");
    String string5 = ""\\u00"";
    StringUtils.substringBetween("""", string5, ""I9"");
    int int0 = StringUtils.indexOfAny((CharSequence) ""decompose"", ""7L4i=QvvR#D"");
    assertEquals((-1), int0);
}","/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A {@code null} String will return {@code -1}.
 * A {@code null} search string will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)            = -1
 * StringUtils.indexOfAny("""", *)              = -1
 * StringUtils.indexOfAny(*, null)            = -1
 * StringUtils.indexOfAny(*, """")              = -1
 * StringUtils.indexOfAny(""zzabyycdxx"", ""za"") = 0
 * StringUtils.indexOfAny(""zzabyycdxx"", ""by"") = 3
 * StringUtils.indexOfAny(""aba"",""z"")          = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAny(String, String) to indexOfAny(CharSequence, String)
 */"
"// Count matches
//-----------------------------------------------------------------------
/**
 * <p>Counts how many times the substring appears in the larger string.</p>
 *
 * <p>A {@code null} or empty ("""") String input returns {@code 0}.</p>
 *
 * <pre>
 * StringUtils.countMatches(null, *)       = 0
 * StringUtils.countMatches("""", *)         = 0
 * StringUtils.countMatches(""abba"", null)  = 0
 * StringUtils.countMatches(""abba"", """")    = 0
 * StringUtils.countMatches(""abba"", ""a"")   = 2
 * StringUtils.countMatches(""abba"", ""ab"")  = 1
 * StringUtils.countMatches(""abba"", ""xxx"") = 0
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param sub  the substring to count, may be null
 * @return the number of occurrences, 0 if either CharSequence is {@code null}
 * @since 3.0 Changed signature from countMatches(String, String) to countMatches(CharSequence, CharSequence)
 */
public static int countMatches(CharSequence str, CharSequence sub) {
    if (isEmpty(str) || isEmpty(sub)) {
        return 0;
    }
    int count = 0;
    int idx = 0;
    while ((idx = CharSequenceUtils.indexOf(str, sub, idx)) != INDEX_NOT_FOUND) {
        count++;
        idx += sub.length();
    }
    return count;
}","public void test2901513() throws Throwable {
    String string0 = StringUtils.chomp("""", """");
    String string1 = StringUtils.removeStartIgnoreCase(""(Rnu{iF%.J^M#D"", ""(Rnu{iF%.J^M#D"");
    String string2 = StringUtils.deleteWhitespace(""(Rnu{iF%.J^M#D"");
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""(Rnu{iF%.J^M#D"", ""decompose"", 0);
    String string3 = StringUtils.rightPad("""", 1462, ""SecurityException occurred"");
    StringUtils.capitalize(""XOq)"");
    StringUtils.removeStartIgnoreCase("""", ""I9"");
    String string4 = StringUtils.uncapitalize(""Xw%#c{@u7-q"");
    String string5 = ""\\u00"";
    StringUtils.substringBetween("""", string5, ""I9"");
    int int0 = StringUtils.indexOfAny((CharSequence) ""decompose"", ""7L4i=QvvR#D"");
    StringUtils.lastIndexOf((CharSequence) ""xw%#c{@u7-q"", (CharSequence) ""7L4i=QvvR#D"", 1462);
    int int1 = StringUtils.indexOfDifference((CharSequence) """", (CharSequence) ""I9"");
    StringUtils.center(string5, 2328);
    int int2 = StringUtils.countMatches(""decompose"", string5);
    assertTrue(int2 == int1);
}",""
"public static String strip(String str, String stripChars) {
    if (isEmpty(str)) {
        return str;
    }
    str = stripStart(str, stripChars);
    return stripEnd(str, stripChars);
}","public void test2911515() throws Throwable {
    String string0 = StringUtils.right(""#_"", 0);
    String string1 = StringUtils.strip(""_w[IYfF9g^Av33Q6"", ""_w[IYfF9g^Av33Q6"");
    assertEquals("""", string1);
}","/**
 * <p>Strips any of a set of characters from the start and end of a String.
 * This is similar to {@link String#trim()} but allows the characters
 * to be stripped to be controlled.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * An empty string ("""") input returns the empty string.</p>
 *
 * <p>If the stripChars String is {@code null}, whitespace is
 * stripped as defined by {@link Character#isWhitespace(char)}.
 * Alternatively use {@link #strip(String)}.</p>
 *
 * <pre>
 * StringUtils.strip(null, *)          = null
 * StringUtils.strip("""", *)            = """"
 * StringUtils.strip(""abc"", null)      = ""abc""
 * StringUtils.strip(""  abc"", null)    = ""abc""
 * StringUtils.strip(""abc  "", null)    = ""abc""
 * StringUtils.strip("" abc "", null)    = ""abc""
 * StringUtils.strip(""  abcyx"", ""xyz"") = ""  abc""
 * </pre>
 *
 * @param str  the String to remove characters from, may be null
 * @param stripChars  the characters to remove, null treated as whitespace
 * @return the stripped String, {@code null} if null String input
 */"
"// ContainsAny
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains any character in the given
 * set of characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.
 * A {@code null} or zero length search array will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)                = false
 * StringUtils.containsAny("""", *)                  = false
 * StringUtils.containsAny(*, null)                = false
 * StringUtils.containsAny(*, [])                  = false
 * StringUtils.containsAny(""zzabyycdxx"",['z','a']) = true
 * StringUtils.containsAny(""zzabyycdxx"",['b','y']) = true
 * StringUtils.containsAny(""aba"", ['z'])           = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the {@code true} if any of the chars are found,
 * {@code false} if no match or null input
 * @since 2.4
 * @since 3.0 Changed signature from containsAny(String, char[]) to containsAny(CharSequence, char...)
 */
public static boolean containsAny(CharSequence cs, char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    int csLast = csLength - 1;
    int searchLast = searchLength - 1;
    for (int i = 0; i < csLength; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == ch) {
                if (Character.isHighSurrogate(ch)) {
                    if (j == searchLast) {
                        // missing low surrogate, fine, like String.indexOf(String)
                        return true;
                    }
                    if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
                        return true;
                    }
                } else {
                    // ch is in the Basic Multilingual Plane
                    return true;
                }
            }
        }
    }
    return false;
}","public void test2911516() throws Throwable {
    String string0 = StringUtils.right(""#_"", 0);
    String string1 = StringUtils.strip(""_w[IYfF9g^Av33Q6"", ""_w[IYfF9g^Av33Q6"");
    StringUtils.lastIndexOf((CharSequence) """", (CharSequence) ""_w[IYfF9g^Av33Q6"");
    char[] charArray0 = new char[4];
    charArray0[0] = '.';
    charArray0[1] = 'H';
    charArray0[2] = '.';
    charArray0[3] = '.';
    boolean boolean0 = StringUtils.containsAny((CharSequence) ""_w[IYfF9g^Av33Q6"", charArray0);
    assertFalse(boolean0);
}",""
"public static String defaultString(String str, String defaultStr) {
    return str == null ? defaultStr : str;
}","public void test2911518() throws Throwable {
    String string0 = StringUtils.right(""#_"", 0);
    String string1 = StringUtils.strip(""_w[IYfF9g^Av33Q6"", ""_w[IYfF9g^Av33Q6"");
    StringUtils.lastIndexOf((CharSequence) """", (CharSequence) ""_w[IYfF9g^Av33Q6"");
    char[] charArray0 = new char[4];
    charArray0[0] = '.';
    charArray0[1] = 'H';
    charArray0[2] = '.';
    charArray0[3] = '.';
    boolean boolean0 = StringUtils.containsAny((CharSequence) ""_w[IYfF9g^Av33Q6"", charArray0);
    String[] stringArray0 = new String[5];
    stringArray0[0] = ""5G^_e"";
    stringArray0[1] = ""5G^_e"";
    stringArray0[2] = ""_w[IYfF9g^Av33Q6"";
    stringArray0[3] = """";
    stringArray0[4] = """";
    String string2 = StringUtils.getCommonPrefix(stringArray0);
    StringUtils.isAlphaSpace("""");
    String string3 = StringUtils.defaultString(""5G^_e"", ""The Array must not be null"");
    assertEquals(""5G^_e"", string3);
}","/**
 * <p>Returns either the passed in String, or if the String is
 * {@code null}, the value of {@code defaultStr}.</p>
 *
 * <pre>
 * StringUtils.defaultString(null, ""NULL"")  = ""NULL""
 * StringUtils.defaultString("""", ""NULL"")    = """"
 * StringUtils.defaultString(""bat"", ""NULL"") = ""bat""
 * </pre>
 *
 * @see ObjectUtils#toString(Object,String)
 * @see String#valueOf(Object)
 * @param str  the String to check, may be null
 * @param defaultStr  the default String to return
 *  if the input is {@code null}, may be null
 * @return the passed in String, or the default if it was {@code null}
 */"
"public static String chomp(String str, String separator) {
    if (isEmpty(str) || separator == null) {
        return str;
    }
    if (str.endsWith(separator)) {
        return str.substring(0, str.length() - separator.length());
    }
    return str;
}","public void test2911519() throws Throwable {
    String string0 = StringUtils.right(""#_"", 0);
    String string1 = StringUtils.strip(""_w[IYfF9g^Av33Q6"", ""_w[IYfF9g^Av33Q6"");
    StringUtils.lastIndexOf((CharSequence) """", (CharSequence) ""_w[IYfF9g^Av33Q6"");
    char[] charArray0 = new char[4];
    charArray0[0] = '.';
    charArray0[1] = 'H';
    charArray0[2] = '.';
    charArray0[3] = '.';
    boolean boolean0 = StringUtils.containsAny((CharSequence) ""_w[IYfF9g^Av33Q6"", charArray0);
    String[] stringArray0 = new String[5];
    stringArray0[0] = ""5G^_e"";
    stringArray0[1] = ""5G^_e"";
    stringArray0[2] = ""_w[IYfF9g^Av33Q6"";
    stringArray0[3] = """";
    stringArray0[4] = """";
    String string2 = StringUtils.getCommonPrefix(stringArray0);
    StringUtils.isAlphaSpace("""");
    String string3 = StringUtils.defaultString(""5G^_e"", ""The Array must not be null"");
    String string4 = StringUtils.chomp(""Search and Replace array lengths don't match: "", ""_w[IYfF9g^Av33Q6"");
    assertEquals(""Search and Replace array lengths don't match: "", string4);
}","/**
 * <p>Removes {@code separator} from the end of
 * {@code str} if it's there, otherwise leave it alone.</p>
 *
 * <p>NOTE: This method changed in version 2.0.
 * It now more closely matches Perl chomp.
 * For the previous behavior, use {@link #substringBeforeLast(String, String)}.
 * This method uses {@link String#endsWith(String)}.</p>
 *
 * <pre>
 * StringUtils.chomp(null, *)         = null
 * StringUtils.chomp("""", *)           = """"
 * StringUtils.chomp(""foobar"", ""bar"") = ""foo""
 * StringUtils.chomp(""foobar"", ""baz"") = ""foobar""
 * StringUtils.chomp(""foo"", ""foo"")    = """"
 * StringUtils.chomp(""foo "", ""foo"")   = ""foo ""
 * StringUtils.chomp("" foo"", ""foo"")   = "" ""
 * StringUtils.chomp(""foo"", ""foooo"")  = ""foo""
 * StringUtils.chomp(""foo"", """")       = ""foo""
 * StringUtils.chomp(""foo"", null)     = ""foo""
 * </pre>
 *
 * @param str  the String to chomp from, may be null
 * @param separator  separator String, may be null
 * @return String without trailing separator, {@code null} if null String input
 */"
"public static boolean containsAny(CharSequence cs, CharSequence searchChars) {
    if (searchChars == null) {
        return false;
    }
    return containsAny(cs, CharSequenceUtils.toCharArray(searchChars));
}","public void test2921521() throws Throwable {
    StringUtils.capitalize(""|`?_p[g"");
    StringUtils.isAlphaSpace(""|`?_p[g"");
    String[] stringArray0 = new String[5];
    stringArray0[0] = ""|`?_p[g"";
    stringArray0[1] = ""|`?_p[g"";
    stringArray0[2] = ""|`?_p[g"";
    stringArray0[3] = ""Dy_r=Wr2"";
    stringArray0[4] = ""|`?_p[g"";
    String string0 = StringUtils.getCommonPrefix(stringArray0);
    String string1 = StringUtils.defaultIfEmpty(""|`?_p[g"", """");
    boolean boolean0 = StringUtils.containsIgnoreCase(""|`?_p[g"", ""|`?_p[g"");
    boolean boolean1 = StringUtils.containsAny((CharSequence) ""Dy_r=Wr2"", (CharSequence) ""|`?_p[g"");
    assertTrue(boolean1 == boolean0);
}","/**
 * <p>
 * Checks if the CharSequence contains any character in the given set of characters.
 * </p>
 *
 * <p>
 * A {@code null} CharSequence will return {@code false}. A {@code null} search CharSequence will return
 * {@code false}.
 * </p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)            = false
 * StringUtils.containsAny("""", *)              = false
 * StringUtils.containsAny(*, null)            = false
 * StringUtils.containsAny(*, """")              = false
 * StringUtils.containsAny(""zzabyycdxx"", ""za"") = true
 * StringUtils.containsAny(""zzabyycdxx"", ""by"") = true
 * StringUtils.containsAny(""aba"",""z"")          = false
 * </pre>
 *
 * @param cs
 *            the CharSequence to check, may be null
 * @param searchChars
 *            the chars to search for, may be null
 * @return the {@code true} if any of the chars are found, {@code false} if no match or null input
 * @since 2.4
 * @since 3.0 Changed signature from containsAny(String, String) to containsAny(CharSequence, CharSequence)
 */"
"public static String reverseDelimited(String str, char separatorChar) {
    if (str == null) {
        return null;
    }
    // could implement manually, but simple way is to reuse other,
    // probably slower, methods.
    String[] strs = split(str, separatorChar);
    ArrayUtils.reverse(strs);
    return join(strs, separatorChar);
}","public void test2921522() throws Throwable {
    StringUtils.capitalize(""|`?_p[g"");
    StringUtils.isAlphaSpace(""|`?_p[g"");
    String[] stringArray0 = new String[5];
    stringArray0[0] = ""|`?_p[g"";
    stringArray0[1] = ""|`?_p[g"";
    stringArray0[2] = ""|`?_p[g"";
    stringArray0[3] = ""Dy_r=Wr2"";
    stringArray0[4] = ""|`?_p[g"";
    String string0 = StringUtils.getCommonPrefix(stringArray0);
    String string1 = StringUtils.defaultIfEmpty(""|`?_p[g"", """");
    boolean boolean0 = StringUtils.containsIgnoreCase(""|`?_p[g"", ""|`?_p[g"");
    boolean boolean1 = StringUtils.containsAny((CharSequence) ""Dy_r=Wr2"", (CharSequence) ""|`?_p[g"");
    StringUtils.isAlpha(""|`?_p[g"");
    StringUtils.removeEndIgnoreCase(""|`?_p[g"", ""|`?_p[g"");
    StringUtils.stripAll(stringArray0);
    StringUtils.isNumericSpace(""|`?_p[g"");
    String string2 = StringUtils.reverseDelimited(""Dy_r=Wr2"", '8');
    assertEquals(""Dy_r=Wr2"", string2);
}","/**
 * <p>Reverses a String that is delimited by a specific character.</p>
 *
 * <p>The Strings between the delimiters are not reversed.
 * Thus java.lang.String becomes String.lang.java (if the delimiter
 * is {@code '.'}).</p>
 *
 * <pre>
 * StringUtils.reverseDelimited(null, *)      = null
 * StringUtils.reverseDelimited("""", *)        = """"
 * StringUtils.reverseDelimited(""a.b.c"", 'x') = ""a.b.c""
 * StringUtils.reverseDelimited(""a.b.c"", ""."") = ""c.b.a""
 * </pre>
 *
 * @param str  the String to reverse, may be null
 * @param separatorChar  the separator character to use
 * @return the reversed String, {@code null} if null String input
 * @since 2.0
 */"
"public static String join(Object[] array, String separator) {
    if (array == null) {
        return null;
    }
    return join(array, separator, 0, array.length);
}","public void test2921523() throws Throwable {
    StringUtils.capitalize(""|`?_p[g"");
    StringUtils.isAlphaSpace(""|`?_p[g"");
    String[] stringArray0 = new String[5];
    stringArray0[0] = ""|`?_p[g"";
    stringArray0[1] = ""|`?_p[g"";
    stringArray0[2] = ""|`?_p[g"";
    stringArray0[3] = ""Dy_r=Wr2"";
    stringArray0[4] = ""|`?_p[g"";
    String string0 = StringUtils.getCommonPrefix(stringArray0);
    String string1 = StringUtils.defaultIfEmpty(""|`?_p[g"", """");
    boolean boolean0 = StringUtils.containsIgnoreCase(""|`?_p[g"", ""|`?_p[g"");
    boolean boolean1 = StringUtils.containsAny((CharSequence) ""Dy_r=Wr2"", (CharSequence) ""|`?_p[g"");
    StringUtils.isAlpha(""|`?_p[g"");
    StringUtils.removeEndIgnoreCase(""|`?_p[g"", ""|`?_p[g"");
    StringUtils.stripAll(stringArray0);
    StringUtils.isNumericSpace(""|`?_p[g"");
    String string2 = StringUtils.reverseDelimited(""Dy_r=Wr2"", '8');
    StringUtils.endsWithAny(""Dy_r=Wr2"", stringArray0);
    String[] stringArray1 = StringUtils.splitByWholeSeparator(""}@s`E{_"", ""Dy_r=Wr2"");
    StringUtils.substringBefore("""", ""Dy_r=Wr2"");
    String string3 = StringUtils.join((Object[]) stringArray0, """");
    assertEquals(""|`?_p[g|`?_p[g|`?_p[gDy_r=Wr2|`?_p[g"", string3);
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A {@code null} separator is the same as an empty String ("""").
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)                = null
 * StringUtils.join([], *)                  = """"
 * StringUtils.join([null], *)              = """"
 * StringUtils.join([""a"", ""b"", ""c""], ""--"")  = ""a--b--c""
 * StringUtils.join([""a"", ""b"", ""c""], null)  = ""abc""
 * StringUtils.join([""a"", ""b"", ""c""], """")    = ""abc""
 * StringUtils.join([null, """", ""a""], ',')   = "",,a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @return the joined String, {@code null} if null array input
 */"
"public static String[] splitByWholeSeparator(String str, String separator, int max) {
    return splitByWholeSeparatorWorker(str, separator, max, false);
}","public void test2921524() throws Throwable {
    StringUtils.capitalize(""|`?_p[g"");
    StringUtils.isAlphaSpace(""|`?_p[g"");
    String[] stringArray0 = new String[5];
    stringArray0[0] = ""|`?_p[g"";
    stringArray0[1] = ""|`?_p[g"";
    stringArray0[2] = ""|`?_p[g"";
    stringArray0[3] = ""Dy_r=Wr2"";
    stringArray0[4] = ""|`?_p[g"";
    String string0 = StringUtils.getCommonPrefix(stringArray0);
    String string1 = StringUtils.defaultIfEmpty(""|`?_p[g"", """");
    boolean boolean0 = StringUtils.containsIgnoreCase(""|`?_p[g"", ""|`?_p[g"");
    boolean boolean1 = StringUtils.containsAny((CharSequence) ""Dy_r=Wr2"", (CharSequence) ""|`?_p[g"");
    StringUtils.isAlpha(""|`?_p[g"");
    StringUtils.removeEndIgnoreCase(""|`?_p[g"", ""|`?_p[g"");
    StringUtils.stripAll(stringArray0);
    StringUtils.isNumericSpace(""|`?_p[g"");
    String string2 = StringUtils.reverseDelimited(""Dy_r=Wr2"", '8');
    StringUtils.endsWithAny(""Dy_r=Wr2"", stringArray0);
    String[] stringArray1 = StringUtils.splitByWholeSeparator(""}@s`E{_"", ""Dy_r=Wr2"");
    StringUtils.substringBefore("""", ""Dy_r=Wr2"");
    String string3 = StringUtils.join((Object[]) stringArray0, """");
    String[] stringArray2 = StringUtils.splitByWholeSeparator(""Dy_r=Wr2"", ""Dy_r=Wr2"", (-379));
    assertNotNull(stringArray2);
}","/**
 * <p>Splits the provided text into an array, separator string specified.
 * Returns a maximum of {@code max} substrings.</p>
 *
 * <p>The separator(s) will not be included in the returned String array.
 * Adjacent separators are treated as one separator.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * A {@code null} separator splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.splitByWholeSeparator(null, *, *)               = null
 * StringUtils.splitByWholeSeparator("""", *, *)                 = []
 * StringUtils.splitByWholeSeparator(""ab de fg"", null, 0)      = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparator(""ab   de fg"", null, 0)    = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparator(""ab:cd:ef"", "":"", 2)       = [""ab"", ""cd:ef""]
 * StringUtils.splitByWholeSeparator(""ab-!-cd-!-ef"", ""-!-"", 5) = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitByWholeSeparator(""ab-!-cd-!-ef"", ""-!-"", 2) = [""ab"", ""cd-!-ef""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @param separator  String containing the String to be used as a delimiter,
 *  {@code null} splits on whitespace
 * @param max  the maximum number of elements to include in the returned
 *  array. A zero or negative value implies no limit.
 * @return an array of parsed Strings, {@code null} if null String was input
 */"
"public static String repeat(String str, String separator, int repeat) {
    if (str == null || separator == null) {
        return repeat(str, repeat);
    } else {
        // given that repeat(String, int) is quite optimized, better to rely on it than try and splice this into it
        String result = repeat(str + separator, repeat);
        return removeEnd(result, separator);
    }
}","public void test2921525() throws Throwable {
    StringUtils.capitalize(""|`?_p[g"");
    StringUtils.isAlphaSpace(""|`?_p[g"");
    String[] stringArray0 = new String[5];
    stringArray0[0] = ""|`?_p[g"";
    stringArray0[1] = ""|`?_p[g"";
    stringArray0[2] = ""|`?_p[g"";
    stringArray0[3] = ""Dy_r=Wr2"";
    stringArray0[4] = ""|`?_p[g"";
    String string0 = StringUtils.getCommonPrefix(stringArray0);
    String string1 = StringUtils.defaultIfEmpty(""|`?_p[g"", """");
    boolean boolean0 = StringUtils.containsIgnoreCase(""|`?_p[g"", ""|`?_p[g"");
    boolean boolean1 = StringUtils.containsAny((CharSequence) ""Dy_r=Wr2"", (CharSequence) ""|`?_p[g"");
    StringUtils.isAlpha(""|`?_p[g"");
    StringUtils.removeEndIgnoreCase(""|`?_p[g"", ""|`?_p[g"");
    StringUtils.stripAll(stringArray0);
    StringUtils.isNumericSpace(""|`?_p[g"");
    String string2 = StringUtils.reverseDelimited(""Dy_r=Wr2"", '8');
    StringUtils.endsWithAny(""Dy_r=Wr2"", stringArray0);
    String[] stringArray1 = StringUtils.splitByWholeSeparator(""}@s`E{_"", ""Dy_r=Wr2"");
    StringUtils.substringBefore("""", ""Dy_r=Wr2"");
    String string3 = StringUtils.join((Object[]) stringArray0, """");
    String[] stringArray2 = StringUtils.splitByWholeSeparator(""Dy_r=Wr2"", ""Dy_r=Wr2"", (-379));
    StringUtils.replaceEach("""", stringArray1, stringArray0);
    String string4 = StringUtils.repeat((String) null, (String) null, (-379));
    assertNull(string4);
}","/**
 * <p>Repeat a String {@code repeat} times to form a
 * new String, with a String separator injected each time. </p>
 *
 * <pre>
 * StringUtils.repeat(null, null, 2) = null
 * StringUtils.repeat(null, ""x"", 2)  = null
 * StringUtils.repeat("""", null, 0)   = """"
 * StringUtils.repeat("""", """", 2)     = """"
 * StringUtils.repeat("""", ""x"", 3)    = ""xxx""
 * StringUtils.repeat(""?"", "", "", 3)  = ""?, ?, ?""
 * </pre>
 *
 * @param str        the String to repeat, may be null
 * @param separator  the String to inject, may be null
 * @param repeat     number of times to repeat str, negative treated as zero
 * @return a new String consisting of the original String repeated,
 *  {@code null} if null String input
 * @since 2.5
 */"
"public static String center(String str, int size, String padStr) {
    if (str == null || size <= 0) {
        return str;
    }
    if (isEmpty(padStr)) {
        padStr = "" "";
    }
    int strLen = str.length();
    int pads = size - strLen;
    if (pads <= 0) {
        return str;
    }
    str = leftPad(str, strLen + pads / 2, padStr);
    str = rightPad(str, size, padStr);
    return str;
}","public void test2921526() throws Throwable {
    StringUtils.capitalize(""|`?_p[g"");
    StringUtils.isAlphaSpace(""|`?_p[g"");
    String[] stringArray0 = new String[5];
    stringArray0[0] = ""|`?_p[g"";
    stringArray0[1] = ""|`?_p[g"";
    stringArray0[2] = ""|`?_p[g"";
    stringArray0[3] = ""Dy_r=Wr2"";
    stringArray0[4] = ""|`?_p[g"";
    String string0 = StringUtils.getCommonPrefix(stringArray0);
    String string1 = StringUtils.defaultIfEmpty(""|`?_p[g"", """");
    boolean boolean0 = StringUtils.containsIgnoreCase(""|`?_p[g"", ""|`?_p[g"");
    boolean boolean1 = StringUtils.containsAny((CharSequence) ""Dy_r=Wr2"", (CharSequence) ""|`?_p[g"");
    StringUtils.isAlpha(""|`?_p[g"");
    StringUtils.removeEndIgnoreCase(""|`?_p[g"", ""|`?_p[g"");
    StringUtils.stripAll(stringArray0);
    StringUtils.isNumericSpace(""|`?_p[g"");
    String string2 = StringUtils.reverseDelimited(""Dy_r=Wr2"", '8');
    StringUtils.endsWithAny(""Dy_r=Wr2"", stringArray0);
    String[] stringArray1 = StringUtils.splitByWholeSeparator(""}@s`E{_"", ""Dy_r=Wr2"");
    StringUtils.substringBefore("""", ""Dy_r=Wr2"");
    String string3 = StringUtils.join((Object[]) stringArray0, """");
    String[] stringArray2 = StringUtils.splitByWholeSeparator(""Dy_r=Wr2"", ""Dy_r=Wr2"", (-379));
    StringUtils.replaceEach("""", stringArray1, stringArray0);
    String string4 = StringUtils.repeat((String) null, (String) null, (-379));
    StringUtils.replace("""", ""Dy_r=Wr2"", """");
    StringUtils.isWhitespace(""Dy_r=Wr2"");
    String string5 = StringUtils.center("")"", 64, ""normalize"");
    assertEquals(""normalizenormalizenormalizenorm)normalizenormalizenormalizenorma"", string5);
}","/**
 * <p>Centers a String in a larger String of size {@code size}.
 * Uses a supplied String as the value to pad the String with.</p>
 *
 * <p>If the size is less than the String length, the String is returned.
 * A {@code null} String returns {@code null}.
 * A negative size is treated as zero.</p>
 *
 * <pre>
 * StringUtils.center(null, *, *)     = null
 * StringUtils.center("""", 4, "" "")     = ""    ""
 * StringUtils.center(""ab"", -1, "" "")  = ""ab""
 * StringUtils.center(""ab"", 4, "" "")   = "" ab""
 * StringUtils.center(""abcd"", 2, "" "") = ""abcd""
 * StringUtils.center(""a"", 4, "" "")    = "" a  ""
 * StringUtils.center(""a"", 4, ""yz"")   = ""yayz""
 * StringUtils.center(""abc"", 7, null) = ""  abc  ""
 * StringUtils.center(""abc"", 7, """")   = ""  abc  ""
 * </pre>
 *
 * @param str  the String to center, may be null
 * @param size  the int size of new String, negative treated as zero
 * @param padStr  the String to pad the new String with, must not be null or empty
 * @return centered String, {@code null} if null String input
 * @throws IllegalArgumentException if padStr is {@code null} or empty
 */"
"public static int getLevenshteinDistance(CharSequence s, CharSequence t, int threshold) {
    if (s == null || t == null) {
        throw new IllegalArgumentException(""Strings must not be null"");
    }
    if (threshold < 0) {
        throw new IllegalArgumentException(""Threshold must not be negative"");
    }
    /*
        This implementation only computes the distance if it's less than or equal to the
        threshold value, returning -1 if it's greater.  The advantage is performance: unbounded
        distance is O(nm), but a bound of k allows us to reduce it to O(km) time by only 
        computing a diagonal stripe of width 2k + 1 of the cost table.
        It is also possible to use this to compute the unbounded Levenshtein distance by starting
        the threshold at 1 and doubling each time until the distance is found; this is O(dm), where
        d is the distance.
        
        One subtlety comes from needing to ignore entries on the border of our stripe
        eg.
        p[] = |#|#|#|*
        d[] =  *|#|#|#|
        We must ignore the entry to the left of the leftmost member
        We must ignore the entry above the rightmost member
        
        Another subtlety comes from our stripe running off the matrix if the strings aren't
        of the same size.  Since string s is always swapped to be the shorter of the two, 
        the stripe will always run off to the upper right instead of the lower left of the matrix.
        
        As a concrete example, suppose s is of length 5, t is of length 7, and our threshold is 1.
        In this case we're going to walk a stripe of length 3.  The matrix would look like so:
        
           1 2 3 4 5
        1 |#|#| | | |
        2 |#|#|#| | |
        3 | |#|#|#| |
        4 | | |#|#|#|
        5 | | | |#|#|
        6 | | | | |#|
        7 | | | | | |

        Note how the stripe leads off the table as there is no possible way to turn a string of length 5
        into one of length 7 in edit distance of 1.
        
        Additionally, this implementation decreases memory usage by using two 
        single-dimensional arrays and swapping them back and forth instead of allocating
        an entire n by m matrix.  This requires a few minor changes, such as immediately returning 
        when it's detected that the stripe has run off the matrix and initially filling the arrays with
        large values so that entries we don't compute are ignored.

        See Algorithms on Strings, Trees and Sequences by Dan Gusfield for some discussion.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    // if one string is empty, the edit distance is necessarily the length of the other
    if (n == 0) {
        return m <= threshold ? m : -1;
    } else if (m == 0) {
        return n <= threshold ? n : -1;
    }
    if (n > m) {
        // swap the two strings to consume less memory
        CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    // 'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    // placeholder to assist in swapping p and d
    int[] _d;
    // fill in starting table values
    int boundary = Math.min(n, threshold) + 1;
    for (int i = 0; i < boundary; i++) {
        p[i] = i;
    }
    // these fills ensure that the value above the rightmost entry of our
    // stripe will be ignored in following loop iterations
    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);
    Arrays.fill(d, Integer.MAX_VALUE);
    // iterates through t
    for (int j = 1; j <= m; j++) {
        // jth character of t
        char t_j = t.charAt(j - 1);
        d[0] = j;
        // compute stripe indices, constrain to array size
        int min = Math.max(1, j - threshold);
        int max = Math.min(n, j + threshold);
        // the stripe may lead off of the table if s and t are of different sizes
        if (min > max) {
            return -1;
        }
        // ignore entry left of leftmost
        if (min > 1) {
            d[min - 1] = Integer.MAX_VALUE;
        }
        // iterates through [min, max] in s
        for (int i = min; i <= max; i++) {
            if (s.charAt(i - 1) == t_j) {
                // diagonally left and up
                d[i] = p[i - 1];
            } else {
                // 1 + minimum of cell to the left, to the top, diagonally left and up
                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);
            }
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // if p[n] is greater than the threshold, there's no guarantee on it being the correct
    // distance
    if (p[n] <= threshold) {
        return p[n];
    } else {
        return -1;
    }
}","public void test2931527() throws Throwable {
    StringUtils.defaultIfEmpty((String) null, ""Minimum abbreviation width is 4"");
    StringUtils.splitByWholeSeparator(""Minimum abbreviation width is 4"", "",F*,8W?<%"", 128);
    StringUtils.capitalize((String) null);
    StringUtils.isBlank("",F*,8W?<%"");
    String string0 = ""vDPx(Q6BG~~,K:+rbc"";
    StringUtils.replace("""", "",F*,8W?<%"", ""vDPx(Q6BG~~,K:+rbc"");
    // Undeclared exception!
    try {
        StringUtils.getLevenshteinDistance((CharSequence) ""Minimum abbreviation width is 4"", (CharSequence) null, 128);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Strings must not be null
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}","/**
 * <p>Find the Levenshtein distance between two Strings if it's less than or equal to a given
 * threshold.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>This implementation follows from Algorithms on Strings, Trees and Sequences by Dan Gusfield
 * and Chas Emerick's implementation of the Levenshtein distance algorithm from
 * <a href=""http://www.merriampark.com/ld.htm"">http://www.merriampark.com/ld.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, *, -1)               = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("""","""", 0)               = 0
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 8)       = 7
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 7)       = 7
 * StringUtils.getLevenshteinDistance(""aaapppp"", """", 6))      = -1
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"", 7) = 7
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"", 6) = -1
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"", 7) = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"", 6) = -1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @param threshold the target threshold, must not be negative
 * @return result distance, or {@code -1} if the distance would be greater than the threshold
 * @throws IllegalArgumentException if either String input {@code null} or negative threshold
 */"
"public static String remove(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    return replace(str, remove, EMPTY, -1);
}","public void test2951529() throws Throwable {
    String string0 = StringUtils.remove(""Minimum abbreviation width with offset is 7"", ""Minimum abbreviation width with offset is 7"");
    assertEquals("""", string0);
}","/**
 * <p>Removes all occurrences of a substring from within the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("""") source string will return the empty string.
 * A {@code null} remove string will return the source string.
 * An empty ("""") remove string will return the source string.</p>
 *
 * <pre>
 * StringUtils.remove(null, *)        = null
 * StringUtils.remove("""", *)          = """"
 * StringUtils.remove(*, null)        = *
 * StringUtils.remove(*, """")          = *
 * StringUtils.remove(""queued"", ""ue"") = ""qd""
 * StringUtils.remove(""queued"", ""zz"") = ""queued""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for and remove, may be null
 * @return the substring with the string removed if found,
 *  {@code null} if null String input
 * @since 2.1
 */"
"public static boolean isNotEmpty(CharSequence cs) {
    return !StringUtils.isEmpty(cs);
}","public void test2951530() throws Throwable {
    String string0 = StringUtils.remove(""Minimum abbreviation width with offset is 7"", ""Minimum abbreviation width with offset is 7"");
    boolean boolean0 = StringUtils.isNotEmpty("""");
    assertFalse(boolean0);
}","/**
 * <p>Checks if a CharSequence is not empty ("""") and not null.</p>
 *
 * <pre>
 * StringUtils.isNotEmpty(null)      = false
 * StringUtils.isNotEmpty("""")        = false
 * StringUtils.isNotEmpty("" "")       = true
 * StringUtils.isNotEmpty(""bob"")     = true
 * StringUtils.isNotEmpty(""  bob  "") = true
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if the CharSequence is not empty and not null
 * @since 3.0 Changed signature from isNotEmpty(String) to isNotEmpty(CharSequence)
 */"
"public static int indexOf(CharSequence seq, CharSequence searchSeq) {
    if (seq == null || searchSeq == null) {
        return INDEX_NOT_FOUND;
    }
    return CharSequenceUtils.indexOf(seq, searchSeq, 0);
}","public void test2951531() throws Throwable {
    String string0 = StringUtils.remove(""Minimum abbreviation width with offset is 7"", ""Minimum abbreviation width with offset is 7"");
    boolean boolean0 = StringUtils.isNotEmpty("""");
    int int0 = StringUtils.indexOf((CharSequence) ""Minimum abbreviation width with offset is 7"", (CharSequence) """");
    assertEquals(0, int0);
}","/**
 * <p>Finds the first index within a CharSequence, handling {@code null}.
 * This method uses {@link String#indexOf(String, int)} if possible.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOf(null, *)          = -1
 * StringUtils.indexOf(*, null)          = -1
 * StringUtils.indexOf("""", """")           = 0
 * StringUtils.indexOf("""", *)            = -1 (except when * = """")
 * StringUtils.indexOf(""aabaabaa"", ""a"")  = 0
 * StringUtils.indexOf(""aabaabaa"", ""b"")  = 2
 * StringUtils.indexOf(""aabaabaa"", ""ab"") = 1
 * StringUtils.indexOf(""aabaabaa"", """")   = 0
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchSeq  the CharSequence to find, may be null
 * @return the first index of the search CharSequence,
 *  -1 if no match or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from indexOf(String, String) to indexOf(CharSequence, CharSequence)
 */"
"public static String join(Iterable<?> iterable, char separator) {
    if (iterable == null) {
        return null;
    }
    return join(iterable.iterator(), separator);
}","public void test2951532() throws Throwable {
    String string0 = StringUtils.remove(""Minimum abbreviation width with offset is 7"", ""Minimum abbreviation width with offset is 7"");
    boolean boolean0 = StringUtils.isNotEmpty("""");
    int int0 = StringUtils.indexOf((CharSequence) ""Minimum abbreviation width with offset is 7"", (CharSequence) """");
    char[] charArray0 = new char[0];
    StringUtils.containsAny((CharSequence) ""Minimum abbreviation width with offset is 7"", charArray0);
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    linkedHashSet0.add(""Minimum abbreviation width with offset is 7"");
    String string1 = StringUtils.join((Iterable<?>) linkedHashSet0, 'b');
    assertNotNull(string1);
}","/**
 * <p>Joins the elements of the provided {@code Iterable} into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list. Null objects or empty
 * strings within the iteration are represented by empty strings.</p>
 *
 * <p>See the examples here: {@link #join(Object[],char)}. </p>
 *
 * @param iterable  the {@code Iterable} providing the values to join together, may be null
 * @param separator  the separator character to use
 * @return the joined String, {@code null} if null iterator input
 * @since 2.3
 */"
"public static String abbreviate(String str, int offset, int maxWidth) {
    if (str == null) {
        return null;
    }
    if (maxWidth < 4) {
        throw new IllegalArgumentException(""Minimum abbreviation width is 4"");
    }
    if (str.length() <= maxWidth) {
        return str;
    }
    if (offset > str.length()) {
        offset = str.length();
    }
    if ((str.length() - offset) < (maxWidth - 3)) {
        offset = str.length() - (maxWidth - 3);
    }
    final String abrevMarker = ""..."";
    if (offset <= 4) {
        return str.substring(0, maxWidth - 3) + abrevMarker;
    }
    if (maxWidth < 7) {
        throw new IllegalArgumentException(""Minimum abbreviation width with offset is 7"");
    }
    if ((offset + (maxWidth - 3)) < str.length()) {
        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);
    }
    return abrevMarker + str.substring(str.length() - (maxWidth - 3));
}","public void test2951533() throws Throwable {
    String string0 = StringUtils.remove(""Minimum abbreviation width with offset is 7"", ""Minimum abbreviation width with offset is 7"");
    boolean boolean0 = StringUtils.isNotEmpty("""");
    int int0 = StringUtils.indexOf((CharSequence) ""Minimum abbreviation width with offset is 7"", (CharSequence) """");
    char[] charArray0 = new char[0];
    StringUtils.containsAny((CharSequence) ""Minimum abbreviation width with offset is 7"", charArray0);
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    linkedHashSet0.add(""Minimum abbreviation width with offset is 7"");
    String string1 = StringUtils.join((Iterable<?>) linkedHashSet0, 'b');
    linkedHashSet0.add((String) null);
    String string2 = StringUtils.abbreviate(""Minimum abbreviation width with offset is 7"", 57, 1872);
    assertNotNull(string2);
}","/**
 * <p>Abbreviates a String using ellipses. This will turn
 * ""Now is the time for all good men"" into ""...is the time for...""</p>
 *
 * <p>Works like {@code abbreviate(String, int)}, but allows you to specify
 * a ""left edge"" offset.  Note that this left edge is not necessarily going to
 * be the leftmost character in the result, or the first character following the
 * ellipses, but it will appear somewhere in the result.
 *
 * <p>In no case will it return a String of length greater than
 * {@code maxWidth}.</p>
 *
 * <pre>
 * StringUtils.abbreviate(null, *, *)                = null
 * StringUtils.abbreviate("""", 0, 4)                  = """"
 * StringUtils.abbreviate(""abcdefghijklmno"", -1, 10) = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 0, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 1, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 4, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 5, 10)  = ""...fghi...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 6, 10)  = ""...ghij...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 8, 10)  = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghijklmno"", 10, 10) = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghijklmno"", 12, 10) = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghij"", 0, 3)        = IllegalArgumentException
 * StringUtils.abbreviate(""abcdefghij"", 5, 6)        = IllegalArgumentException
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param offset  left edge of source String
 * @param maxWidth  maximum length of result String, must be at least 4
 * @return abbreviated String, {@code null} if null String input
 * @throws IllegalArgumentException if the width is too small
 * @since 2.0
 */"
"// Misc
//-----------------------------------------------------------------------
/**
 * <p>Find the Levenshtein distance between two Strings.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>The previous implementation of the Levenshtein distance algorithm
 * was from <a href=""http://www.merriampark.com/ld.htm"">http://www.merriampark.com/ld.htm</a></p>
 *
 * <p>Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError
 * which can occur when my Java implementation is used with very large strings.<br>
 * This implementation of the Levenshtein distance algorithm
 * is from <a href=""http://www.merriampark.com/ldjava.htm"">http://www.merriampark.com/ldjava.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("""","""")               = 0
 * StringUtils.getLevenshteinDistance("""",""a"")              = 1
 * StringUtils.getLevenshteinDistance(""aaapppp"", """")       = 7
 * StringUtils.getLevenshteinDistance(""frog"", ""fog"")       = 1
 * StringUtils.getLevenshteinDistance(""fly"", ""ant"")        = 3
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""zzzzzzzz"") = 8
 * StringUtils.getLevenshteinDistance(""hello"", ""hallo"")    = 1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @return result distance
 * @throws IllegalArgumentException if either String input {@code null}
 * @since 3.0 Changed signature from getLevenshteinDistance(String, String) to
 * getLevenshteinDistance(CharSequence, CharSequence)
 */
public static int getLevenshteinDistance(CharSequence s, CharSequence t) {
    if (s == null || t == null) {
        throw new IllegalArgumentException(""Strings must not be null"");
    }
    /*
           The difference between this impl. and the previous is that, rather
           than creating and retaining a matrix of size s.length() + 1 by t.length() + 1,
           we maintain two single-dimensional arrays of length s.length() + 1.  The first, d,
           is the 'current working' distance array that maintains the newest distance cost
           counts as we iterate through the characters of String s.  Each time we increment
           the index of String t we are comparing, d is copied to p, the second int[].  Doing so
           allows us to retain the previous cost counts as required by the algorithm (taking
           the minimum of the cost count to the left, up one, and diagonally up and to the left
           of the current cost count being calculated).  (Note that the arrays aren't really
           copied anymore, just switched...this is clearly much better than cloning an array
           or doing a System.arraycopy() each time  through the outer loop.)

           Effectively, the difference between the two implementations is this one does not
           cause an out of memory condition when calculating the LD over two very large strings.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    if (n == 0) {
        return m;
    } else if (m == 0) {
        return n;
    }
    if (n > m) {
        // swap the input strings to consume less memory
        CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    //'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    //placeholder to assist in swapping p and d
    int[] _d;
    // indexes into strings s and t
    // iterates through s
    int i;
    // iterates through t
    int j;
    // jth character of t
    char t_j;
    // cost
    int cost;
    for (i = 0; i <= n; i++) {
        p[i] = i;
    }
    for (j = 1; j <= m; j++) {
        t_j = t.charAt(j - 1);
        d[0] = j;
        for (i = 1; i <= n; i++) {
            cost = s.charAt(i - 1) == t_j ? 0 : 1;
            // minimum of cell to the left+1, to the top+1, diagonally left and up +cost
            d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost);
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // our last action in the above loop was to switch d and p, so p now
    // actually has the most recent cost counts
    return p[n];
}","public void test2951536() throws Throwable {
    String string0 = StringUtils.remove(""Minimum abbreviation width with offset is 7"", ""Minimum abbreviation width with offset is 7"");
    boolean boolean0 = StringUtils.isNotEmpty("""");
    int int0 = StringUtils.indexOf((CharSequence) ""Minimum abbreviation width with offset is 7"", (CharSequence) """");
    char[] charArray0 = new char[0];
    StringUtils.containsAny((CharSequence) ""Minimum abbreviation width with offset is 7"", charArray0);
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    linkedHashSet0.add(""Minimum abbreviation width with offset is 7"");
    String string1 = StringUtils.join((Iterable<?>) linkedHashSet0, 'b');
    linkedHashSet0.add((String) null);
    String string2 = StringUtils.abbreviate(""Minimum abbreviation width with offset is 7"", 57, 1872);
    StringUtils.defaultString("""", """");
    int int1 = StringUtils.getLevenshteinDistance((CharSequence) ""Minimum abbreviation width with offset is 7"", (CharSequence) """");
    assertEquals(43, int1);
}",""
