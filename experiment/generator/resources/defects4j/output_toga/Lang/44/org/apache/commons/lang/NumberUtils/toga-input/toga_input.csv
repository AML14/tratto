focal_method,test_prefix,docstring
"//--------------------------------------------------------------------
// must handle Long, Float, Integer, Float, Short,
//                  BigDecimal, BigInteger and Byte
// useful methods:
// Byte.decode(String)
// Byte.valueOf(String,int radix)
// Byte.valueOf(String)
// Double.valueOf(String)
// Float.valueOf(String)
// new Float(String)
// Integer.valueOf(String,int radix)
// Integer.valueOf(String)
// Integer.decode(String)
// Integer.getInteger(String)
// Integer.getInteger(String,int val)
// Integer.getInteger(String,Integer val)
// new Integer(String)
// new Double(String)
// new Byte(String)
// new Long(String)
// Long.getLong(String)
// Long.getLong(String,int)
// Long.getLong(String,Integer)
// Long.valueOf(String,int)
// Long.valueOf(String)
// new Short(String)
// Short.decode(String)
// Short.valueOf(String,int)
// Short.valueOf(String)
// new BigDecimal(String)
// new BigInteger(String)
// new BigInteger(String,int radix)
// Possible inputs:
// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd
// plus minus everything. Prolly more. A lot are not separable.
/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>First, the value is examined for a type qualifier on the end
 * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can hold the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it
 * will be interpreted as a hexadecimal integer.  Values with leading
 * <code>0</code>'s will not be interpreted as octal.</p>
 *
 * @param val String containing a number
 * @return Number created from the string
 * @throws NumberFormatException if the value cannot be converted
 */
public static Number createNumber(String val) throws NumberFormatException {
    if (val == null) {
        return null;
    }
    if (val.length() == 0) {
        throw new NumberFormatException(""\""\"" is not a valid number."");
    }
    if (val.startsWith(""--"")) {
        // this is protection for poorness in java.lang.BigDecimal.
        // it accepts this as a legal value, but it does not appear
        // to be in specification of class. OS X Java parses it to
        // a wrong value.
        return null;
    }
    if (val.startsWith(""0x"") || val.startsWith(""-0x"")) {
        return createInteger(val);
    }
    char lastChar = val.charAt(val.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = val.indexOf('.');
    int expPos = val.indexOf('e') + val.indexOf('E') + 1;
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(val + "" is not a valid number."");
            }
            dec = val.substring(decPos + 1, expPos);
        } else {
            dec = val.substring(decPos + 1);
        }
        mant = val.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = val.substring(0, expPos);
        } else {
            mant = val;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar)) {
        if (expPos > -1 && expPos < val.length() - 1) {
            exp = val.substring(expPos + 1, val.length() - 1);
        } else {
            exp = null;
        }
        //Requesting a specific type..
        String numeric = val.substring(0, val.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        //Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(val + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        //If it's too big for a float or the float value = 0 and the string
                        //has non-zeros in it, then float does not have the precision we want
                        return f;
                    }
                } catch (NumberFormatException e) {
                    // ignore the bad number
                }
            //Fall through
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // empty catch
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                    // empty catch
                }
            //Fall through
            default:
                throw new NumberFormatException(val + "" is not a valid number."");
        }
    } else {
        //User doesn't have a preference on the return type, so let's start
        //small and go from there...
        if (expPos > -1 && expPos < val.length() - 1) {
            exp = val.substring(expPos + 1, val.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            //Must be an int,long,bigint
            try {
                return createInteger(val);
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            try {
                return createLong(val);
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            return createBigInteger(val);
        } else {
            //Must be a float,double,BigDec
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(val);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            try {
                Double d = createDouble(val);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            return createBigDecimal(val);
        }
    }
}","public void test000() throws Throwable {
    String string0 = ""?G<-2z'j@xi_AAjO/6"";
    NumberUtils.isNumber(""?G<-2z'j@xi_AAjO/6"");
    try {
        NumberUtils.createNumber(""?G<-2z'j@xi_AAjO/6"");
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
        //
        // Illegal embedded sign character
        //
        verifyException(""java.math.BigInteger"", e);
    }
}",""
"public static Double createDouble(String val) {
    return Double.valueOf(val);
}","public void test011() throws Throwable {
    String string0 = """";
    NumberUtils.stringToInt("""");
    String string1 = ""zp"";
    // Undeclared exception!
    try {
        NumberUtils.createDouble(""zp"");
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
    }
}","/**
 * <p>Convert a <code>String</code> to a <code>Double</code>.</p>
 *
 * @param val  a <code>String</code> to convert
 * @return converted <code>Double</code>
 * @throws NumberFormatException if the value cannot be converted
 */"
"// DEPRECATED CLASS !!!
/**
 * <p><code>NumberUtils</code> instances should NOT be constructed in standard programming.
 * Instead, the class should be used as <code>NumberUtils.stringToInt(""6"");</code>.</p>
 *
 * <p>This constructor is public to permit tools that require a JavaBean instance
 * to operate.</p>
 */
public NumberUtils() {
    super();
}","public void test022() throws Throwable {
    String string0 = ""kQR.S(5FA9+qO7"";
    NumberUtils.stringToInt(""kQR.S(5FA9+qO7"", (-1));
    NumberUtils.maximum(2628, (-1), 2628);
    NumberUtils.minimum((-1), 2628, 570);
    NumberUtils.maximum((-1), (-1), (-10));
    NumberUtils.stringToInt(""kQR.S(5FA9+qO7"", 2628);
    NumberUtils.stringToInt(""kQR.S(5FA9+qO7"", (-1486));
    String string1 = """";
    NumberUtils.createBigDecimal("""");
    long long0 = 427L;
    long long1 = 1311L;
    NumberUtils.minimum(long0, long1, long0);
    NumberUtils.createBigInteger(string0);
    NumberUtils numberUtils0 = null;
    try {
        numberUtils0 = new NumberUtils();
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.math.BigDecimal"", e);
    }
}",""
"//--------------------------------------------------------------------
/**
 * <p>Checks whether the <code>String</code> contains only
 * digit characters.</p>
 *
 * <p><code>Null</code> and empty String will return
 * <code>false</code>.</p>
 *
 * @param str  the <code>String</code> to check
 * @return <code>true</code> if str contains only unicode numeric
 */
public static boolean isDigits(String str) {
    if ((str == null) || (str.length() == 0)) {
        return false;
    }
    for (int i = 0; i < str.length(); i++) {
        if (!Character.isDigit(str.charAt(i))) {
            return false;
        }
    }
    return true;
}","public void test033() throws Throwable {
    NumberUtils.maximum(0, 0, 0);
    NumberUtils.isDigits(""9wi!*mYxvM_.$"");
    NumberUtils.minimum(0, (-328), (-254));
    NumberUtils.isDigits(""9wi!*mYxvM_.$"");
    NumberUtils.isDigits(""--"");
}",""
"//--------------------------------------------------------------------
/**
 * <p>Compares two <code>doubles</code> for order.</p>
 *
 * <p>This method is more comprehensive than the standard Java greater
 * than, less than and equals operators.</p>
 * <ul>
 *  <li>It returns <code>-1</code> if the first value is less than the second.
 *  <li>It returns <code>+1</code> if the first value is greater than the second.
 *  <li>It returns <code>0</code> if the values are equal.
 * </ul>
 *
 * <p>
 * The ordering is as follows, largest to smallest:
 * <ul>
 *  <li>NaN
 *  <li>Positive infinity
 *  <li>Maximum double
 *  <li>Normal positive numbers
 *  <li>+0.0
 *  <li>-0.0
 *  <li>Normal negative numbers
 *  <li>Minimum double (-Double.MAX_VALUE)
 *  <li>Negative infinity
 * </ul>
 * </p>
 *
 * <p>Comparing <code>NaN</code> with <code>NaN</code> will
 * return <code>0</code>.</p>
 *
 * @param lhs  the first <code>double</code>
 * @param rhs  the second <code>double</code>
 * @return <code>-1</code> if lhs is less, <code>+1</code> if greater,
 *  <code>0</code> if equal to rhs
 */
public static int compare(double lhs, double rhs) {
    if (lhs < rhs) {
        return -1;
    }
    if (lhs > rhs) {
        return +1;
    }
    // Need to compare bits to handle 0.0 == -0.0 being true
    // compare should put -0.0 < +0.0
    // Two NaNs are also == for compare purposes
    // where NaN == NaN is false
    long lhsBits = Double.doubleToLongBits(lhs);
    long rhsBits = Double.doubleToLongBits(rhs);
    if (lhsBits == rhsBits) {
        return 0;
    }
    // Something exotic! A comparison to NaN or 0.0 vs -0.0
    // Fortunately NaN's long is > than everything else
    // Also negzeros bits < poszero
    // NAN: 9221120237041090560
    // MAX: 9218868437227405311
    // NEGZERO: -9223372036854775808
    if (lhsBits < rhsBits) {
        return -1;
    } else {
        return +1;
    }
}","public void test066() throws Throwable {
    NumberUtils.compare(1001.01864075434, 1001.01864075434);
}",""
"public static long maximum(long a, long b, long c) {
    if (b > a) {
        a = b;
    }
    if (c > a) {
        a = c;
    }
    return a;
}","public void test077() throws Throwable {
    NumberUtils.compare((-1.0F), (-2397.77F));
    NumberUtils.maximum((-2284L), (-1247L), 788L);
}","/**
 * <p>Gets the maximum of three <code>long</code> values.</p>
 *
 * @param a  value 1
 * @param b  value 2
 * @param c  value 3
 * @return  the largest of the values
 */"
"//--------------------------------------------------------------------
/**
 * <p>Convert a <code>String</code> to a <code>Float</code>.</p>
 *
 * @param val  a <code>String</code> to convert
 * @return converted <code>Float</code>
 * @throws NumberFormatException if the value cannot be converted
 */
public static Float createFloat(String val) {
    return Float.valueOf(val);
}","public void test088() throws Throwable {
    NumberUtils.createFloat(""v2@S"");
}",""
"public static int stringToInt(String str, int defaultValue) {
    try {
        return Integer.parseInt(str);
    } catch (NumberFormatException nfe) {
        return defaultValue;
    }
}","public void test099() throws Throwable {
    int int0 = (-1);
    int int1 = (-2342);
    NumberUtils.maximum((-1), (-1), (-2342));
    String string0 = """";
    NumberUtils.isNumber("""");
    NumberUtils.createInteger(""0x"");
    // Undeclared exception!
    try {
        NumberUtils.stringToInt(string0, int0);
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
        //
        // For input string: \""\""
        //
        verifyException(""java.lang.NumberFormatException"", e);
    }
}","/**
 * <p>Convert a <code>String</code> to an <code>int</code>, returning a
 * default value if the conversion fails.</p>
 *
 * @param str  the string to convert
 * @param defaultValue  the default value
 * @return the int represented by the string, or the default if conversion fails
 */"
"//--------------------------------------------------------------------
// must handle Long, Float, Integer, Float, Short,
//                  BigDecimal, BigInteger and Byte
// useful methods:
// Byte.decode(String)
// Byte.valueOf(String,int radix)
// Byte.valueOf(String)
// Double.valueOf(String)
// Float.valueOf(String)
// new Float(String)
// Integer.valueOf(String,int radix)
// Integer.valueOf(String)
// Integer.decode(String)
// Integer.getInteger(String)
// Integer.getInteger(String,int val)
// Integer.getInteger(String,Integer val)
// new Integer(String)
// new Double(String)
// new Byte(String)
// new Long(String)
// Long.getLong(String)
// Long.getLong(String,int)
// Long.getLong(String,Integer)
// Long.valueOf(String,int)
// Long.valueOf(String)
// new Short(String)
// Short.decode(String)
// Short.valueOf(String,int)
// Short.valueOf(String)
// new BigDecimal(String)
// new BigInteger(String)
// new BigInteger(String,int radix)
// Possible inputs:
// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd
// plus minus everything. Prolly more. A lot are not separable.
/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>First, the value is examined for a type qualifier on the end
 * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can hold the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it
 * will be interpreted as a hexadecimal integer.  Values with leading
 * <code>0</code>'s will not be interpreted as octal.</p>
 *
 * @param val String containing a number
 * @return Number created from the string
 * @throws NumberFormatException if the value cannot be converted
 */
public static Number createNumber(String val) throws NumberFormatException {
    if (val == null) {
        return null;
    }
    if (val.length() == 0) {
        throw new NumberFormatException(""\""\"" is not a valid number."");
    }
    if (val.startsWith(""--"")) {
        // this is protection for poorness in java.lang.BigDecimal.
        // it accepts this as a legal value, but it does not appear
        // to be in specification of class. OS X Java parses it to
        // a wrong value.
        return null;
    }
    if (val.startsWith(""0x"") || val.startsWith(""-0x"")) {
        return createInteger(val);
    }
    char lastChar = val.charAt(val.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = val.indexOf('.');
    int expPos = val.indexOf('e') + val.indexOf('E') + 1;
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(val + "" is not a valid number."");
            }
            dec = val.substring(decPos + 1, expPos);
        } else {
            dec = val.substring(decPos + 1);
        }
        mant = val.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = val.substring(0, expPos);
        } else {
            mant = val;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar)) {
        if (expPos > -1 && expPos < val.length() - 1) {
            exp = val.substring(expPos + 1, val.length() - 1);
        } else {
            exp = null;
        }
        //Requesting a specific type..
        String numeric = val.substring(0, val.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        //Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(val + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        //If it's too big for a float or the float value = 0 and the string
                        //has non-zeros in it, then float does not have the precision we want
                        return f;
                    }
                } catch (NumberFormatException e) {
                    // ignore the bad number
                }
            //Fall through
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // empty catch
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                    // empty catch
                }
            //Fall through
            default:
                throw new NumberFormatException(val + "" is not a valid number."");
        }
    } else {
        //User doesn't have a preference on the return type, so let's start
        //small and go from there...
        if (expPos > -1 && expPos < val.length() - 1) {
            exp = val.substring(expPos + 1, val.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            //Must be an int,long,bigint
            try {
                return createInteger(val);
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            try {
                return createLong(val);
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            return createBigInteger(val);
        } else {
            //Must be a float,double,BigDec
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(val);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            try {
                Double d = createDouble(val);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            return createBigDecimal(val);
        }
    }
}","public void test1010() throws Throwable {
    String string0 = ""?@{%;&56t6i"";
    try {
        NumberUtils.createNumber(""?@{%;&56t6i"");
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
        //
        // ?@{%;&56t6i is not a valid number.
        //
        verifyException(""org.apache.commons.lang.NumberUtils"", e);
    }
}",""
"//--------------------------------------------------------------------
/**
 * <p>Convert a <code>String</code> to a <code>Float</code>.</p>
 *
 * @param val  a <code>String</code> to convert
 * @return converted <code>Float</code>
 * @throws NumberFormatException if the value cannot be converted
 */
public static Float createFloat(String val) {
    return Float.valueOf(val);
}","public void test1212() throws Throwable {
    String string0 = "" f71I9!oAMBoC)8pkBv"";
    // Undeclared exception!
    try {
        NumberUtils.createFloat("" f71I9!oAMBoC)8pkBv"");
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
    }
}",""
"public static BigDecimal createBigDecimal(String val) {
    BigDecimal bd = new BigDecimal(val);
    return bd;
}","public void test1313() throws Throwable {
    String string0 = """";
    // Undeclared exception!
    try {
        NumberUtils.createBigDecimal("""");
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.math.BigDecimal"", e);
    }
}","/**
 * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>
 *
 * @param val  a <code>String</code> to convert
 * @return converted <code>BigDecimal</code>
 * @throws NumberFormatException if the value cannot be converted
 */"
"public static BigInteger createBigInteger(String val) {
    BigInteger bi = new BigInteger(val);
    return bi;
}","public void test1414() throws Throwable {
    String string0 = null;
    // Undeclared exception!
    try {
        NumberUtils.createBigInteger((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.math.BigInteger"", e);
    }
}","/**
 * <p>Convert a <code>String</code> to a <code>BigInteger</code>.</p>
 *
 * @param val  a <code>String</code> to convert
 * @return converted <code>BigInteger</code>
 * @throws NumberFormatException if the value cannot be converted
 */"
"//--------------------------------------------------------------------
// must handle Long, Float, Integer, Float, Short,
//                  BigDecimal, BigInteger and Byte
// useful methods:
// Byte.decode(String)
// Byte.valueOf(String,int radix)
// Byte.valueOf(String)
// Double.valueOf(String)
// Float.valueOf(String)
// new Float(String)
// Integer.valueOf(String,int radix)
// Integer.valueOf(String)
// Integer.decode(String)
// Integer.getInteger(String)
// Integer.getInteger(String,int val)
// Integer.getInteger(String,Integer val)
// new Integer(String)
// new Double(String)
// new Byte(String)
// new Long(String)
// Long.getLong(String)
// Long.getLong(String,int)
// Long.getLong(String,Integer)
// Long.valueOf(String,int)
// Long.valueOf(String)
// new Short(String)
// Short.decode(String)
// Short.valueOf(String,int)
// Short.valueOf(String)
// new BigDecimal(String)
// new BigInteger(String)
// new BigInteger(String,int radix)
// Possible inputs:
// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd
// plus minus everything. Prolly more. A lot are not separable.
/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>First, the value is examined for a type qualifier on the end
 * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can hold the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it
 * will be interpreted as a hexadecimal integer.  Values with leading
 * <code>0</code>'s will not be interpreted as octal.</p>
 *
 * @param val String containing a number
 * @return Number created from the string
 * @throws NumberFormatException if the value cannot be converted
 */
public static Number createNumber(String val) throws NumberFormatException {
    if (val == null) {
        return null;
    }
    if (val.length() == 0) {
        throw new NumberFormatException(""\""\"" is not a valid number."");
    }
    if (val.startsWith(""--"")) {
        // this is protection for poorness in java.lang.BigDecimal.
        // it accepts this as a legal value, but it does not appear
        // to be in specification of class. OS X Java parses it to
        // a wrong value.
        return null;
    }
    if (val.startsWith(""0x"") || val.startsWith(""-0x"")) {
        return createInteger(val);
    }
    char lastChar = val.charAt(val.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = val.indexOf('.');
    int expPos = val.indexOf('e') + val.indexOf('E') + 1;
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(val + "" is not a valid number."");
            }
            dec = val.substring(decPos + 1, expPos);
        } else {
            dec = val.substring(decPos + 1);
        }
        mant = val.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = val.substring(0, expPos);
        } else {
            mant = val;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar)) {
        if (expPos > -1 && expPos < val.length() - 1) {
            exp = val.substring(expPos + 1, val.length() - 1);
        } else {
            exp = null;
        }
        //Requesting a specific type..
        String numeric = val.substring(0, val.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        //Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(val + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        //If it's too big for a float or the float value = 0 and the string
                        //has non-zeros in it, then float does not have the precision we want
                        return f;
                    }
                } catch (NumberFormatException e) {
                    // ignore the bad number
                }
            //Fall through
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // empty catch
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                    // empty catch
                }
            //Fall through
            default:
                throw new NumberFormatException(val + "" is not a valid number."");
        }
    } else {
        //User doesn't have a preference on the return type, so let's start
        //small and go from there...
        if (expPos > -1 && expPos < val.length() - 1) {
            exp = val.substring(expPos + 1, val.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            //Must be an int,long,bigint
            try {
                return createInteger(val);
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            try {
                return createLong(val);
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            return createBigInteger(val);
        } else {
            //Must be a float,double,BigDec
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(val);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            try {
                Double d = createDouble(val);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            return createBigDecimal(val);
        }
    }
}","public void test1515() throws Throwable {
    int int0 = 1919;
    NumberUtils.maximum(1919, 1, 1919);
    String string0 = """";
    NumberUtils.createDouble("""");
    try {
        NumberUtils.createNumber(string0);
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
    }
}",""
"//--------------------------------------------------------------------
/**
 * <p>Compares two <code>doubles</code> for order.</p>
 *
 * <p>This method is more comprehensive than the standard Java greater
 * than, less than and equals operators.</p>
 * <ul>
 *  <li>It returns <code>-1</code> if the first value is less than the second.
 *  <li>It returns <code>+1</code> if the first value is greater than the second.
 *  <li>It returns <code>0</code> if the values are equal.
 * </ul>
 *
 * <p>
 * The ordering is as follows, largest to smallest:
 * <ul>
 *  <li>NaN
 *  <li>Positive infinity
 *  <li>Maximum double
 *  <li>Normal positive numbers
 *  <li>+0.0
 *  <li>-0.0
 *  <li>Normal negative numbers
 *  <li>Minimum double (-Double.MAX_VALUE)
 *  <li>Negative infinity
 * </ul>
 * </p>
 *
 * <p>Comparing <code>NaN</code> with <code>NaN</code> will
 * return <code>0</code>.</p>
 *
 * @param lhs  the first <code>double</code>
 * @param rhs  the second <code>double</code>
 * @return <code>-1</code> if lhs is less, <code>+1</code> if greater,
 *  <code>0</code> if equal to rhs
 */
public static int compare(double lhs, double rhs) {
    if (lhs < rhs) {
        return -1;
    }
    if (lhs > rhs) {
        return +1;
    }
    // Need to compare bits to handle 0.0 == -0.0 being true
    // compare should put -0.0 < +0.0
    // Two NaNs are also == for compare purposes
    // where NaN == NaN is false
    long lhsBits = Double.doubleToLongBits(lhs);
    long rhsBits = Double.doubleToLongBits(rhs);
    if (lhsBits == rhsBits) {
        return 0;
    }
    // Something exotic! A comparison to NaN or 0.0 vs -0.0
    // Fortunately NaN's long is > than everything else
    // Also negzeros bits < poszero
    // NAN: 9221120237041090560
    // MAX: 9218868437227405311
    // NEGZERO: -9223372036854775808
    if (lhsBits < rhsBits) {
        return -1;
    } else {
        return +1;
    }
}","public void test1616() throws Throwable {
    NumberUtils.minimum((-466), 2074, (-5394));
    NumberUtils.stringToInt("""");
    NumberUtils.createBigDecimal("""");
    double double0 = 361.7;
    double double1 = 0.0;
    NumberUtils.compare(double0, double1);
}",""
"//--------------------------------------------------------------------
/**
 * <p>Convert a <code>String</code> to a <code>Float</code>.</p>
 *
 * @param val  a <code>String</code> to convert
 * @return converted <code>Float</code>
 * @throws NumberFormatException if the value cannot be converted
 */
public static Float createFloat(String val) {
    return Float.valueOf(val);
}","public void test1717() throws Throwable {
    NumberUtils.minimum(0L, 0L, 0L);
    NumberUtils.createFloat(""aRZ"");
}",""
"public static int minimum(int a, int b, int c) {
    if (b < a) {
        a = b;
    }
    if (c < a) {
        a = c;
    }
    return a;
}","public void test1818() throws Throwable {
    NumberUtils.minimum((-3510), (-3510), 678);
}","/**
 * <p>Gets the minimum of three <code>int</code> values.</p>
 *
 * @param a  value 1
 * @param b  value 2
 * @param c  value 3
 * @return  the smallest of the values
 */"
"//--------------------------------------------------------------------
// must handle Long, Float, Integer, Float, Short,
//                  BigDecimal, BigInteger and Byte
// useful methods:
// Byte.decode(String)
// Byte.valueOf(String,int radix)
// Byte.valueOf(String)
// Double.valueOf(String)
// Float.valueOf(String)
// new Float(String)
// Integer.valueOf(String,int radix)
// Integer.valueOf(String)
// Integer.decode(String)
// Integer.getInteger(String)
// Integer.getInteger(String,int val)
// Integer.getInteger(String,Integer val)
// new Integer(String)
// new Double(String)
// new Byte(String)
// new Long(String)
// Long.getLong(String)
// Long.getLong(String,int)
// Long.getLong(String,Integer)
// Long.valueOf(String,int)
// Long.valueOf(String)
// new Short(String)
// Short.decode(String)
// Short.valueOf(String,int)
// Short.valueOf(String)
// new BigDecimal(String)
// new BigInteger(String)
// new BigInteger(String,int radix)
// Possible inputs:
// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd
// plus minus everything. Prolly more. A lot are not separable.
/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>First, the value is examined for a type qualifier on the end
 * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can hold the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it
 * will be interpreted as a hexadecimal integer.  Values with leading
 * <code>0</code>'s will not be interpreted as octal.</p>
 *
 * @param val String containing a number
 * @return Number created from the string
 * @throws NumberFormatException if the value cannot be converted
 */
public static Number createNumber(String val) throws NumberFormatException {
    if (val == null) {
        return null;
    }
    if (val.length() == 0) {
        throw new NumberFormatException(""\""\"" is not a valid number."");
    }
    if (val.startsWith(""--"")) {
        // this is protection for poorness in java.lang.BigDecimal.
        // it accepts this as a legal value, but it does not appear
        // to be in specification of class. OS X Java parses it to
        // a wrong value.
        return null;
    }
    if (val.startsWith(""0x"") || val.startsWith(""-0x"")) {
        return createInteger(val);
    }
    char lastChar = val.charAt(val.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = val.indexOf('.');
    int expPos = val.indexOf('e') + val.indexOf('E') + 1;
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(val + "" is not a valid number."");
            }
            dec = val.substring(decPos + 1, expPos);
        } else {
            dec = val.substring(decPos + 1);
        }
        mant = val.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = val.substring(0, expPos);
        } else {
            mant = val;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar)) {
        if (expPos > -1 && expPos < val.length() - 1) {
            exp = val.substring(expPos + 1, val.length() - 1);
        } else {
            exp = null;
        }
        //Requesting a specific type..
        String numeric = val.substring(0, val.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        //Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(val + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        //If it's too big for a float or the float value = 0 and the string
                        //has non-zeros in it, then float does not have the precision we want
                        return f;
                    }
                } catch (NumberFormatException e) {
                    // ignore the bad number
                }
            //Fall through
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // empty catch
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                    // empty catch
                }
            //Fall through
            default:
                throw new NumberFormatException(val + "" is not a valid number."");
        }
    } else {
        //User doesn't have a preference on the return type, so let's start
        //small and go from there...
        if (expPos > -1 && expPos < val.length() - 1) {
            exp = val.substring(expPos + 1, val.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            //Must be an int,long,bigint
            try {
                return createInteger(val);
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            try {
                return createLong(val);
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            return createBigInteger(val);
        } else {
            //Must be a float,double,BigDec
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(val);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            try {
                Double d = createDouble(val);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            return createBigDecimal(val);
        }
    }
}","public void test2020() throws Throwable {
    NumberUtils.createNumber(""\""\"" is not a valid number."");
}",""
"//--------------------------------------------------------------------
/**
 * <p>Convert a <code>String</code> to an <code>int</code>, returning
 * <code>zero</code> if the conversion fails.</p>
 *
 * @param str  the string to convert
 * @return the int represented by the string, or <code>zero</code> if
 *  conversion fails
 */
public static int stringToInt(String str) {
    return stringToInt(str, 0);
}","public void test2121() throws Throwable {
    long long0 = 168L;
    NumberUtils.maximum((-767L), 168L, 168L);
    String string0 = ""MDw.`n~_g|U=[{<D"";
    NumberUtils.createNumber(""MDw.`n~_g|U=[{<D"");
    // Undeclared exception!
    try {
        NumberUtils.stringToInt(string0);
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
        //
        // MDw.`n~_g|U=[{<D is not a valid number.
        //
        verifyException(""org.apache.commons.lang.NumberUtils"", e);
    }
}",""
"//--------------------------------------------------------------------
/**
 * <p>Convert a <code>String</code> to a <code>Float</code>.</p>
 *
 * @param val  a <code>String</code> to convert
 * @return converted <code>Float</code>
 * @throws NumberFormatException if the value cannot be converted
 */
public static Float createFloat(String val) {
    return Float.valueOf(val);
}","public void test2222() throws Throwable {
    NumberUtils.maximum(241L, 0L, 0L);
    NumberUtils.createFloat("""");
}",""
"public static int stringToInt(String str, int defaultValue) {
    try {
        return Integer.parseInt(str);
    } catch (NumberFormatException nfe) {
        return defaultValue;
    }
}","public void test2424() throws Throwable {
    NumberUtils.stringToInt("""", 2515);
    NumberUtils.maximum((long) 2515, (long) 2515, (-1L));
    NumberUtils.isNumber(""j|c"");
    NumberUtils.maximum(1132, 2515, (-3173));
    NumberUtils.maximum(0L, (long) 2515, (long) (-3173));
    NumberUtils.createBigDecimal("""");
    String string0 = ""2b|W"";
    int int0 = (-1);
    NumberUtils.stringToInt(string0, int0);
}","/**
 * <p>Convert a <code>String</code> to an <code>int</code>, returning a
 * default value if the conversion fails.</p>
 *
 * @param str  the string to convert
 * @param defaultValue  the default value
 * @return the int represented by the string, or the default if conversion fails
 */"
"//--------------------------------------------------------------------
/**
 * <p>Checks whether the <code>String</code> contains only
 * digit characters.</p>
 *
 * <p><code>Null</code> and empty String will return
 * <code>false</code>.</p>
 *
 * @param str  the <code>String</code> to check
 * @return <code>true</code> if str contains only unicode numeric
 */
public static boolean isDigits(String str) {
    if ((str == null) || (str.length() == 0)) {
        return false;
    }
    for (int i = 0; i < str.length(); i++) {
        if (!Character.isDigit(str.charAt(i))) {
            return false;
        }
    }
    return true;
}","public void test2626() throws Throwable {
    NumberUtils.isDigits(""}p*z.T\""YQp;IDCa"");
    NumberUtils.isDigits("""");
}",""
"//--------------------------------------------------------------------
/**
 * <p>Checks whether the <code>String</code> contains only
 * digit characters.</p>
 *
 * <p><code>Null</code> and empty String will return
 * <code>false</code>.</p>
 *
 * @param str  the <code>String</code> to check
 * @return <code>true</code> if str contains only unicode numeric
 */
public static boolean isDigits(String str) {
    if ((str == null) || (str.length() == 0)) {
        return false;
    }
    for (int i = 0; i < str.length(); i++) {
        if (!Character.isDigit(str.charAt(i))) {
            return false;
        }
    }
    return true;
}","public void test2727() throws Throwable {
    NumberUtils.minimum((-397), (-2065), (-2065));
    NumberUtils.createBigDecimal("""");
    String string0 = null;
    NumberUtils.isDigits(string0);
}",""
"public static long maximum(long a, long b, long c) {
    if (b > a) {
        a = b;
    }
    if (c > a) {
        a = c;
    }
    return a;
}","public void test2828() throws Throwable {
    NumberUtils.minimum(0L, 0L, 2222L);
    NumberUtils.isNumber("""");
    NumberUtils.maximum(0L, 2428L, 0L);
}","/**
 * <p>Gets the maximum of three <code>long</code> values.</p>
 *
 * @param a  value 1
 * @param b  value 2
 * @param c  value 3
 * @return  the largest of the values
 */"
"public static BigInteger createBigInteger(String val) {
    BigInteger bi = new BigInteger(val);
    return bi;
}","public void test2929() throws Throwable {
    NumberUtils.minimum(43, 43, 43);
    NumberUtils.minimum(0, 43, 43);
    NumberUtils.stringToInt(""TVYGd7CQrF>JH`M#3KC"");
    NumberUtils.createBigInteger((String) null);
}","/**
 * <p>Convert a <code>String</code> to a <code>BigInteger</code>.</p>
 *
 * @param val  a <code>String</code> to convert
 * @return converted <code>BigInteger</code>
 * @throws NumberFormatException if the value cannot be converted
 */"
"//--------------------------------------------------------------------
// must handle Long, Float, Integer, Float, Short,
//                  BigDecimal, BigInteger and Byte
// useful methods:
// Byte.decode(String)
// Byte.valueOf(String,int radix)
// Byte.valueOf(String)
// Double.valueOf(String)
// Float.valueOf(String)
// new Float(String)
// Integer.valueOf(String,int radix)
// Integer.valueOf(String)
// Integer.decode(String)
// Integer.getInteger(String)
// Integer.getInteger(String,int val)
// Integer.getInteger(String,Integer val)
// new Integer(String)
// new Double(String)
// new Byte(String)
// new Long(String)
// Long.getLong(String)
// Long.getLong(String,int)
// Long.getLong(String,Integer)
// Long.valueOf(String,int)
// Long.valueOf(String)
// new Short(String)
// Short.decode(String)
// Short.valueOf(String,int)
// Short.valueOf(String)
// new BigDecimal(String)
// new BigInteger(String)
// new BigInteger(String,int radix)
// Possible inputs:
// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd
// plus minus everything. Prolly more. A lot are not separable.
/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>First, the value is examined for a type qualifier on the end
 * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can hold the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it
 * will be interpreted as a hexadecimal integer.  Values with leading
 * <code>0</code>'s will not be interpreted as octal.</p>
 *
 * @param val String containing a number
 * @return Number created from the string
 * @throws NumberFormatException if the value cannot be converted
 */
public static Number createNumber(String val) throws NumberFormatException {
    if (val == null) {
        return null;
    }
    if (val.length() == 0) {
        throw new NumberFormatException(""\""\"" is not a valid number."");
    }
    if (val.startsWith(""--"")) {
        // this is protection for poorness in java.lang.BigDecimal.
        // it accepts this as a legal value, but it does not appear
        // to be in specification of class. OS X Java parses it to
        // a wrong value.
        return null;
    }
    if (val.startsWith(""0x"") || val.startsWith(""-0x"")) {
        return createInteger(val);
    }
    char lastChar = val.charAt(val.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = val.indexOf('.');
    int expPos = val.indexOf('e') + val.indexOf('E') + 1;
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(val + "" is not a valid number."");
            }
            dec = val.substring(decPos + 1, expPos);
        } else {
            dec = val.substring(decPos + 1);
        }
        mant = val.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = val.substring(0, expPos);
        } else {
            mant = val;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar)) {
        if (expPos > -1 && expPos < val.length() - 1) {
            exp = val.substring(expPos + 1, val.length() - 1);
        } else {
            exp = null;
        }
        //Requesting a specific type..
        String numeric = val.substring(0, val.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        //Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(val + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        //If it's too big for a float or the float value = 0 and the string
                        //has non-zeros in it, then float does not have the precision we want
                        return f;
                    }
                } catch (NumberFormatException e) {
                    // ignore the bad number
                }
            //Fall through
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // empty catch
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                    // empty catch
                }
            //Fall through
            default:
                throw new NumberFormatException(val + "" is not a valid number."");
        }
    } else {
        //User doesn't have a preference on the return type, so let's start
        //small and go from there...
        if (expPos > -1 && expPos < val.length() - 1) {
            exp = val.substring(expPos + 1, val.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            //Must be an int,long,bigint
            try {
                return createInteger(val);
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            try {
                return createLong(val);
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            return createBigInteger(val);
        } else {
            //Must be a float,double,BigDec
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(val);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            try {
                Double d = createDouble(val);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            return createBigDecimal(val);
        }
    }
}","public void test3030() throws Throwable {
    long long0 = 6024L;
    NumberUtils.minimum(6024L, 6024L, 1L);
    int int0 = 68;
    NumberUtils.stringToInt("""", 68);
    NumberUtils.stringToInt(""twdW3Wh[ 3]7"", (-227));
    NumberUtils.createBigDecimal("""");
    NumberUtils.minimum(long0, (long) int0, (long) int0);
    String string0 = """";
    NumberUtils.isNumber(string0);
    String string1 = ""oL"";
    try {
        NumberUtils.createNumber(string1);
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.math.BigDecimal"", e);
    }
}",""
"//--------------------------------------------------------------------
/**
 * <p>Convert a <code>String</code> to a <code>Float</code>.</p>
 *
 * @param val  a <code>String</code> to convert
 * @return converted <code>Float</code>
 * @throws NumberFormatException if the value cannot be converted
 */
public static Float createFloat(String val) {
    return Float.valueOf(val);
}","public void test3131() throws Throwable {
    NumberUtils.createNumber((String) null);
    NumberUtils.isDigits((String) null);
    NumberUtils.minimum((-81L), (-81L), (-81L));
    NumberUtils.isNumber((String) null);
    NumberUtils.compare((double) (-81L), 3958.34361937761);
    NumberUtils.maximum((-81L), 1L, (-4488L));
    NumberUtils.isDigits((String) null);
    NumberUtils.createFloat((String) null);
}",""
"//--------------------------------------------------------------------
/**
 * <p>Compares two <code>doubles</code> for order.</p>
 *
 * <p>This method is more comprehensive than the standard Java greater
 * than, less than and equals operators.</p>
 * <ul>
 *  <li>It returns <code>-1</code> if the first value is less than the second.
 *  <li>It returns <code>+1</code> if the first value is greater than the second.
 *  <li>It returns <code>0</code> if the values are equal.
 * </ul>
 *
 * <p>
 * The ordering is as follows, largest to smallest:
 * <ul>
 *  <li>NaN
 *  <li>Positive infinity
 *  <li>Maximum double
 *  <li>Normal positive numbers
 *  <li>+0.0
 *  <li>-0.0
 *  <li>Normal negative numbers
 *  <li>Minimum double (-Double.MAX_VALUE)
 *  <li>Negative infinity
 * </ul>
 * </p>
 *
 * <p>Comparing <code>NaN</code> with <code>NaN</code> will
 * return <code>0</code>.</p>
 *
 * @param lhs  the first <code>double</code>
 * @param rhs  the second <code>double</code>
 * @return <code>-1</code> if lhs is less, <code>+1</code> if greater,
 *  <code>0</code> if equal to rhs
 */
public static int compare(double lhs, double rhs) {
    if (lhs < rhs) {
        return -1;
    }
    if (lhs > rhs) {
        return +1;
    }
    // Need to compare bits to handle 0.0 == -0.0 being true
    // compare should put -0.0 < +0.0
    // Two NaNs are also == for compare purposes
    // where NaN == NaN is false
    long lhsBits = Double.doubleToLongBits(lhs);
    long rhsBits = Double.doubleToLongBits(rhs);
    if (lhsBits == rhsBits) {
        return 0;
    }
    // Something exotic! A comparison to NaN or 0.0 vs -0.0
    // Fortunately NaN's long is > than everything else
    // Also negzeros bits < poszero
    // NAN: 9221120237041090560
    // MAX: 9218868437227405311
    // NEGZERO: -9223372036854775808
    if (lhsBits < rhsBits) {
        return -1;
    } else {
        return +1;
    }
}","public void test3333() throws Throwable {
    NumberUtils.compare((-38.4689), (-38.4689));
    int int0 = NumberUtils.compare((-38.4689), (-3928.3036262));
    NumberUtils.maximum(1, 0, 0);
    String string0 = """";
    NumberUtils.createBigDecimal("""");
    NumberUtils.isDigits(string0);
    double double0 = 0.0;
    // Undeclared exception!
    try {
        NumberUtils.compare((double) int0, double0);
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.math.BigDecimal"", e);
    }
}",""
"public static Long createLong(String val) {
    return Long.valueOf(val);
}","public void test3535() throws Throwable {
    NumberUtils.isNumber(""9f.PFI7z-;T#."");
    NumberUtils.compare((-512.11), (-512.11));
    NumberUtils.compare(0.0, 0.0);
    NumberUtils.createLong("""");
}","/**
 * <p>Convert a <code>String</code> to a <code>Long</code>.</p>
 *
 * @param val  a <code>String</code> to convert
 * @return converted <code>Long</code>
 * @throws NumberFormatException if the value cannot be converted
 */"
"public static Integer createInteger(String val) {
    // decode() handles 0xAABD and 0777 (hex and octal) as well.
    return Integer.decode(val);
}","public void test3838() throws Throwable {
    String string0 = null;
    // Undeclared exception!
    try {
        NumberUtils.createInteger((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.lang.Integer"", e);
    }
}","/**
 * <p>Convert a <code>String</code> to a <code>Integer</code>, handling
 * hex and octal notations.</p>
 *
 * @param val  a <code>String</code> to convert
 * @return converted <code>Integer</code>
 * @throws NumberFormatException if the value cannot be converted
 */"
"public static Double createDouble(String val) {
    return Double.valueOf(val);
}","public void test3939() throws Throwable {
    String string0 = "" is not a valid number."";
    NumberUtils.isNumber("" is not a valid number."");
    // Undeclared exception!
    try {
        NumberUtils.createDouble("" is not a valid number."");
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
    }
}","/**
 * <p>Convert a <code>String</code> to a <code>Double</code>.</p>
 *
 * @param val  a <code>String</code> to convert
 * @return converted <code>Double</code>
 * @throws NumberFormatException if the value cannot be converted
 */"
"public static BigDecimal createBigDecimal(String val) {
    BigDecimal bd = new BigDecimal(val);
    return bd;
}","public void test4141() throws Throwable {
    String string0 = ""0x"";
    NumberUtils.isNumber(""0x"");
    // Undeclared exception!
    try {
        NumberUtils.createBigDecimal(""0x"");
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.math.BigDecimal"", e);
    }
}","/**
 * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>
 *
 * @param val  a <code>String</code> to convert
 * @return converted <code>BigDecimal</code>
 * @throws NumberFormatException if the value cannot be converted
 */"
"// DEPRECATED CLASS !!!
/**
 * <p><code>NumberUtils</code> instances should NOT be constructed in standard programming.
 * Instead, the class should be used as <code>NumberUtils.stringToInt(""6"");</code>.</p>
 *
 * <p>This constructor is public to permit tools that require a JavaBean instance
 * to operate.</p>
 */
public NumberUtils() {
    super();
}","public void test4242() throws Throwable {
    NumberUtils.createNumber(""=~S~Le"");
    NumberUtils numberUtils0 = null;
    try {
        numberUtils0 = new NumberUtils();
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
        //
        // =~S~Le is not a valid number.
        //
        verifyException(""org.apache.commons.lang.NumberUtils"", e);
    }
}",""
"//--------------------------------------------------------------------
/**
 * <p>Checks whether the <code>String</code> contains only
 * digit characters.</p>
 *
 * <p><code>Null</code> and empty String will return
 * <code>false</code>.</p>
 *
 * @param str  the <code>String</code> to check
 * @return <code>true</code> if str contains only unicode numeric
 */
public static boolean isDigits(String str) {
    if ((str == null) || (str.length() == 0)) {
        return false;
    }
    for (int i = 0; i < str.length(); i++) {
        if (!Character.isDigit(str.charAt(i))) {
            return false;
        }
    }
    return true;
}","public void test4343() throws Throwable {
    int int0 = (-5222);
    NumberUtils.maximum((-5222), (-5222), (-5222));
    NumberUtils.maximum((long) (-5222), 0L, 0L);
    NumberUtils.createDouble((String) null);
    String string0 = null;
    // Undeclared exception!
    try {
        NumberUtils.isDigits(string0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
    }
}",""
"//--------------------------------------------------------------------
// must handle Long, Float, Integer, Float, Short,
//                  BigDecimal, BigInteger and Byte
// useful methods:
// Byte.decode(String)
// Byte.valueOf(String,int radix)
// Byte.valueOf(String)
// Double.valueOf(String)
// Float.valueOf(String)
// new Float(String)
// Integer.valueOf(String,int radix)
// Integer.valueOf(String)
// Integer.decode(String)
// Integer.getInteger(String)
// Integer.getInteger(String,int val)
// Integer.getInteger(String,Integer val)
// new Integer(String)
// new Double(String)
// new Byte(String)
// new Long(String)
// Long.getLong(String)
// Long.getLong(String,int)
// Long.getLong(String,Integer)
// Long.valueOf(String,int)
// Long.valueOf(String)
// new Short(String)
// Short.decode(String)
// Short.valueOf(String,int)
// Short.valueOf(String)
// new BigDecimal(String)
// new BigInteger(String)
// new BigInteger(String,int radix)
// Possible inputs:
// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd
// plus minus everything. Prolly more. A lot are not separable.
/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>First, the value is examined for a type qualifier on the end
 * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can hold the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it
 * will be interpreted as a hexadecimal integer.  Values with leading
 * <code>0</code>'s will not be interpreted as octal.</p>
 *
 * @param val String containing a number
 * @return Number created from the string
 * @throws NumberFormatException if the value cannot be converted
 */
public static Number createNumber(String val) throws NumberFormatException {
    if (val == null) {
        return null;
    }
    if (val.length() == 0) {
        throw new NumberFormatException(""\""\"" is not a valid number."");
    }
    if (val.startsWith(""--"")) {
        // this is protection for poorness in java.lang.BigDecimal.
        // it accepts this as a legal value, but it does not appear
        // to be in specification of class. OS X Java parses it to
        // a wrong value.
        return null;
    }
    if (val.startsWith(""0x"") || val.startsWith(""-0x"")) {
        return createInteger(val);
    }
    char lastChar = val.charAt(val.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = val.indexOf('.');
    int expPos = val.indexOf('e') + val.indexOf('E') + 1;
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(val + "" is not a valid number."");
            }
            dec = val.substring(decPos + 1, expPos);
        } else {
            dec = val.substring(decPos + 1);
        }
        mant = val.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = val.substring(0, expPos);
        } else {
            mant = val;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar)) {
        if (expPos > -1 && expPos < val.length() - 1) {
            exp = val.substring(expPos + 1, val.length() - 1);
        } else {
            exp = null;
        }
        //Requesting a specific type..
        String numeric = val.substring(0, val.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        //Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(val + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        //If it's too big for a float or the float value = 0 and the string
                        //has non-zeros in it, then float does not have the precision we want
                        return f;
                    }
                } catch (NumberFormatException e) {
                    // ignore the bad number
                }
            //Fall through
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // empty catch
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                    // empty catch
                }
            //Fall through
            default:
                throw new NumberFormatException(val + "" is not a valid number."");
        }
    } else {
        //User doesn't have a preference on the return type, so let's start
        //small and go from there...
        if (expPos > -1 && expPos < val.length() - 1) {
            exp = val.substring(expPos + 1, val.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            //Must be an int,long,bigint
            try {
                return createInteger(val);
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            try {
                return createLong(val);
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            return createBigInteger(val);
        } else {
            //Must be a float,double,BigDec
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(val);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            try {
                Double d = createDouble(val);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            return createBigDecimal(val);
        }
    }
}","public void test4646() throws Throwable {
    NumberUtils.compare(1258.5579753887, (-1.0));
    NumberUtils.stringToInt(""?9[ D3(7Zr!~cfS"", (-2558));
    NumberUtils.createDouble(""1"");
    NumberUtils.maximum((long) (-2558), (long) (-2558), (-2293L));
    NumberUtils numberUtils0 = new NumberUtils();
    NumberUtils.isNumber("""");
    NumberUtils.compare((double) (-2558), 1.0);
    NumberUtils.createNumber(""1.Ly"");
}",""
"public static Long createLong(String val) {
    return Long.valueOf(val);
}","public void test4747() throws Throwable {
    String string0 = ""-0x6D(CP2dt"";
    NumberUtils.isNumber(""-0x6D(CP2dt"");
    NumberUtils.createLong((String) null);
    // Undeclared exception!
    try {
        NumberUtils.createLong(string0);
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
        //
        // null
        //
        verifyException(""java.lang.Long"", e);
    }
}","/**
 * <p>Convert a <code>String</code> to a <code>Long</code>.</p>
 *
 * @param val  a <code>String</code> to convert
 * @return converted <code>Long</code>
 * @throws NumberFormatException if the value cannot be converted
 */"
"public static BigInteger createBigInteger(String val) {
    BigInteger bi = new BigInteger(val);
    return bi;
}","public void test4848() throws Throwable {
    NumberUtils.compare((-1.0F), (-1.0F));
    NumberUtils.stringToInt(""pE|&"");
    String string0 = ""..."";
    NumberUtils.isNumber(""..."");
    NumberUtils.stringToInt(""0x"");
    NumberUtils.createNumber(""0x"");
    NumberUtils.createBigInteger(string0);
    String string1 = "" \t\r\n\b"";
    // Undeclared exception!
    try {
        NumberUtils.createBigInteger(string1);
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
        //
        // For input string: \""\""
        //
        verifyException(""java.lang.NumberFormatException"", e);
    }
}","/**
 * <p>Convert a <code>String</code> to a <code>BigInteger</code>.</p>
 *
 * @param val  a <code>String</code> to convert
 * @return converted <code>BigInteger</code>
 * @throws NumberFormatException if the value cannot be converted
 */"
"//--------------------------------------------------------------------
// must handle Long, Float, Integer, Float, Short,
//                  BigDecimal, BigInteger and Byte
// useful methods:
// Byte.decode(String)
// Byte.valueOf(String,int radix)
// Byte.valueOf(String)
// Double.valueOf(String)
// Float.valueOf(String)
// new Float(String)
// Integer.valueOf(String,int radix)
// Integer.valueOf(String)
// Integer.decode(String)
// Integer.getInteger(String)
// Integer.getInteger(String,int val)
// Integer.getInteger(String,Integer val)
// new Integer(String)
// new Double(String)
// new Byte(String)
// new Long(String)
// Long.getLong(String)
// Long.getLong(String,int)
// Long.getLong(String,Integer)
// Long.valueOf(String,int)
// Long.valueOf(String)
// new Short(String)
// Short.decode(String)
// Short.valueOf(String,int)
// Short.valueOf(String)
// new BigDecimal(String)
// new BigInteger(String)
// new BigInteger(String,int radix)
// Possible inputs:
// 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd
// plus minus everything. Prolly more. A lot are not separable.
/**
 * <p>Turns a string value into a java.lang.Number.</p>
 *
 * <p>First, the value is examined for a type qualifier on the end
 * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts
 * trying to create successively larger types from the type specified
 * until one is found that can hold the value.</p>
 *
 * <p>If a type specifier is not found, it will check for a decimal point
 * and then try successively larger types from <code>Integer</code> to
 * <code>BigInteger</code> and from <code>Float</code> to
 * <code>BigDecimal</code>.</p>
 *
 * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it
 * will be interpreted as a hexadecimal integer.  Values with leading
 * <code>0</code>'s will not be interpreted as octal.</p>
 *
 * @param val String containing a number
 * @return Number created from the string
 * @throws NumberFormatException if the value cannot be converted
 */
public static Number createNumber(String val) throws NumberFormatException {
    if (val == null) {
        return null;
    }
    if (val.length() == 0) {
        throw new NumberFormatException(""\""\"" is not a valid number."");
    }
    if (val.startsWith(""--"")) {
        // this is protection for poorness in java.lang.BigDecimal.
        // it accepts this as a legal value, but it does not appear
        // to be in specification of class. OS X Java parses it to
        // a wrong value.
        return null;
    }
    if (val.startsWith(""0x"") || val.startsWith(""-0x"")) {
        return createInteger(val);
    }
    char lastChar = val.charAt(val.length() - 1);
    String mant;
    String dec;
    String exp;
    int decPos = val.indexOf('.');
    int expPos = val.indexOf('e') + val.indexOf('E') + 1;
    if (decPos > -1) {
        if (expPos > -1) {
            if (expPos < decPos) {
                throw new NumberFormatException(val + "" is not a valid number."");
            }
            dec = val.substring(decPos + 1, expPos);
        } else {
            dec = val.substring(decPos + 1);
        }
        mant = val.substring(0, decPos);
    } else {
        if (expPos > -1) {
            mant = val.substring(0, expPos);
        } else {
            mant = val;
        }
        dec = null;
    }
    if (!Character.isDigit(lastChar)) {
        if (expPos > -1 && expPos < val.length() - 1) {
            exp = val.substring(expPos + 1, val.length() - 1);
        } else {
            exp = null;
        }
        //Requesting a specific type..
        String numeric = val.substring(0, val.length() - 1);
        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
        switch(lastChar) {
            case 'l':
            case 'L':
                if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                    try {
                        return createLong(numeric);
                    } catch (NumberFormatException nfe) {
                        //Too big for a long
                    }
                    return createBigInteger(numeric);
                }
                throw new NumberFormatException(val + "" is not a valid number."");
            case 'f':
            case 'F':
                try {
                    Float f = NumberUtils.createFloat(numeric);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        //If it's too big for a float or the float value = 0 and the string
                        //has non-zeros in it, then float does not have the precision we want
                        return f;
                    }
                } catch (NumberFormatException e) {
                    // ignore the bad number
                }
            //Fall through
            case 'd':
            case 'D':
                try {
                    Double d = NumberUtils.createDouble(numeric);
                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // empty catch
                }
                try {
                    return createBigDecimal(numeric);
                } catch (NumberFormatException e) {
                    // empty catch
                }
            //Fall through
            default:
                throw new NumberFormatException(val + "" is not a valid number."");
        }
    } else {
        //User doesn't have a preference on the return type, so let's start
        //small and go from there...
        if (expPos > -1 && expPos < val.length() - 1) {
            exp = val.substring(expPos + 1, val.length());
        } else {
            exp = null;
        }
        if (dec == null && exp == null) {
            //Must be an int,long,bigint
            try {
                return createInteger(val);
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            try {
                return createLong(val);
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            return createBigInteger(val);
        } else {
            //Must be a float,double,BigDec
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            try {
                Float f = createFloat(val);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                    return f;
                }
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            try {
                Double d = createDouble(val);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                    return d;
                }
            } catch (NumberFormatException nfe) {
                // empty catch
            }
            return createBigDecimal(val);
        }
    }
}","public void test4949() throws Throwable {
    NumberUtils.compare((-512.11), (-667.0));
    NumberUtils.createNumber(""Search and Replace array lengths don't match: "");
}",""
