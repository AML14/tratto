focal_method,test_prefix,docstring
"public final String translate(CharSequence input) {
    if (input == null) {
        return null;
    }
    try {
        StringWriter writer = new StringWriter(input.length() * 2);
        translate(input, writer);
        return writer.toString();
    } catch (IOException ioe) {
        // this should never ever happen while writing to a StringWriter
        throw new RuntimeException(ioe);
    }
}","public void test00() throws Throwable {
    NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();
    char[] charArray0 = new char[2];
    charArray0[1] = '&';
    charArray0[0] = '&';
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);
    assertEquals(""&&"", string0);
}","/**
 * Helper for non-Writer usage.
 * @param input CharSequence to be translated
 * @return String output of translation
 */"
"@Override
public int translate(CharSequence input, int index, Writer out) throws IOException {
    int seqEnd = input.length();
    // Uses -2 to ensure there is something after the &#
    if (input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
        int start = index + 2;
        boolean isHex = false;
        char firstChar = input.charAt(start);
        if (firstChar == 'x' || firstChar == 'X') {
            start++;
            isHex = true;
            // Check there's more than just an x after the &#
        }
        int end = start;
        // Note that this supports character codes without a ; on the end
        while (input.charAt(end) != ';') {
            end++;
        }
        int entityValue;
        try {
            if (isHex) {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
            } else {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
            }
        } catch (NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start + ""]["" + end + ""]"");
            return 0;
        }
        if (entityValue > 0xFFFF) {
            char[] chrs = Character.toChars(entityValue);
            out.write(chrs[0]);
            out.write(chrs[1]);
        } else {
            out.write(entityValue);
        }
        return 2 + (end - start) + (isHex ? 1 : 0) + 1;
    }
    return 0;
}","public void test11() throws Throwable {
    NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();
    StringWriter stringWriter0 = new StringWriter(35);
    // Undeclared exception!
    try {
        numericEntityUnescaper0.translate((CharSequence) ""23"", 35, (Writer) stringWriter0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public int translate(CharSequence input, int index, Writer out) throws IOException {
    int seqEnd = input.length();
    // Uses -2 to ensure there is something after the &#
    if (input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
        int start = index + 2;
        boolean isHex = false;
        char firstChar = input.charAt(start);
        if (firstChar == 'x' || firstChar == 'X') {
            start++;
            isHex = true;
            // Check there's more than just an x after the &#
        }
        int end = start;
        // Note that this supports character codes without a ; on the end
        while (input.charAt(end) != ';') {
            end++;
        }
        int entityValue;
        try {
            if (isHex) {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
            } else {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
            }
        } catch (NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start + ""]["" + end + ""]"");
            return 0;
        }
        if (entityValue > 0xFFFF) {
            char[] chrs = Character.toChars(entityValue);
            out.write(chrs[0]);
            out.write(chrs[1]);
        } else {
            out.write(entityValue);
        }
        return 2 + (end - start) + (isHex ? 1 : 0) + 1;
    }
    return 0;
}","public void test22() throws Throwable {
    NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();
    StringWriter stringWriter0 = new StringWriter();
    // Undeclared exception!
    try {
        numericEntityUnescaper0.translate((CharSequence) null, 923, (Writer) stringWriter0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.text.translate.NumericEntityUnescaper"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public int translate(CharSequence input, int index, Writer out) throws IOException {
    int seqEnd = input.length();
    // Uses -2 to ensure there is something after the &#
    if (input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
        int start = index + 2;
        boolean isHex = false;
        char firstChar = input.charAt(start);
        if (firstChar == 'x' || firstChar == 'X') {
            start++;
            isHex = true;
            // Check there's more than just an x after the &#
        }
        int end = start;
        // Note that this supports character codes without a ; on the end
        while (input.charAt(end) != ';') {
            end++;
        }
        int entityValue;
        try {
            if (isHex) {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
            } else {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
            }
        } catch (NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start + ""]["" + end + ""]"");
            return 0;
        }
        if (entityValue > 0xFFFF) {
            char[] chrs = Character.toChars(entityValue);
            out.write(chrs[0]);
            out.write(chrs[1]);
        } else {
            out.write(entityValue);
        }
        return 2 + (end - start) + (isHex ? 1 : 0) + 1;
    }
    return 0;
}","public void test33() throws Throwable {
    NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();
    CharBuffer charBuffer0 = CharBuffer.wrap((CharSequence) ""5C"");
    StringWriter stringWriter0 = new StringWriter();
    CharBuffer charBuffer1 = CharBuffer.wrap((CharSequence) charBuffer0, 0, 0);
    // Undeclared exception!
    try {
        numericEntityUnescaper0.translate((CharSequence) charBuffer1, 0, (Writer) stringWriter0);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.nio.Buffer"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public int translate(CharSequence input, int index, Writer out) throws IOException {
    int seqEnd = input.length();
    // Uses -2 to ensure there is something after the &#
    if (input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
        int start = index + 2;
        boolean isHex = false;
        char firstChar = input.charAt(start);
        if (firstChar == 'x' || firstChar == 'X') {
            start++;
            isHex = true;
            // Check there's more than just an x after the &#
        }
        int end = start;
        // Note that this supports character codes without a ; on the end
        while (input.charAt(end) != ';') {
            end++;
        }
        int entityValue;
        try {
            if (isHex) {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
            } else {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
            }
        } catch (NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start + ""]["" + end + ""]"");
            return 0;
        }
        if (entityValue > 0xFFFF) {
            char[] chrs = Character.toChars(entityValue);
            out.write(chrs[0]);
            out.write(chrs[1]);
        } else {
            out.write(entityValue);
        }
        return 2 + (end - start) + (isHex ? 1 : 0) + 1;
    }
    return 0;
}","public void test44() throws Throwable {
    NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();
    char[] charArray0 = new char[4];
    charArray0[0] = '&';
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    StringWriter stringWriter0 = new StringWriter();
    int int0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0, (int) '\u0000', (Writer) stringWriter0);
    assertEquals(0, int0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public int translate(CharSequence input, int index, Writer out) throws IOException {
    int seqEnd = input.length();
    // Uses -2 to ensure there is something after the &#
    if (input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
        int start = index + 2;
        boolean isHex = false;
        char firstChar = input.charAt(start);
        if (firstChar == 'x' || firstChar == 'X') {
            start++;
            isHex = true;
            // Check there's more than just an x after the &#
        }
        int end = start;
        // Note that this supports character codes without a ; on the end
        while (input.charAt(end) != ';') {
            end++;
        }
        int entityValue;
        try {
            if (isHex) {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
            } else {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
            }
        } catch (NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start + ""]["" + end + ""]"");
            return 0;
        }
        if (entityValue > 0xFFFF) {
            char[] chrs = Character.toChars(entityValue);
            out.write(chrs[0]);
            out.write(chrs[1]);
        } else {
            out.write(entityValue);
        }
        return 2 + (end - start) + (isHex ? 1 : 0) + 1;
    }
    return 0;
}","public void test55() throws Throwable {
    NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();
    CharBuffer charBuffer0 = CharBuffer.wrap((CharSequence) ""0"");
    StringWriter stringWriter0 = new StringWriter(0);
    int int0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0, 0, (Writer) stringWriter0);
    assertEquals(0, int0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public int translate(CharSequence input, int index, Writer out) throws IOException {
    int seqEnd = input.length();
    // Uses -2 to ensure there is something after the &#
    if (input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
        int start = index + 2;
        boolean isHex = false;
        char firstChar = input.charAt(start);
        if (firstChar == 'x' || firstChar == 'X') {
            start++;
            isHex = true;
            // Check there's more than just an x after the &#
        }
        int end = start;
        // Note that this supports character codes without a ; on the end
        while (input.charAt(end) != ';') {
            end++;
        }
        int entityValue;
        try {
            if (isHex) {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
            } else {
                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
            }
        } catch (NumberFormatException nfe) {
            System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start + ""]["" + end + ""]"");
            return 0;
        }
        if (entityValue > 0xFFFF) {
            char[] chrs = Character.toChars(entityValue);
            out.write(chrs[0]);
            out.write(chrs[1]);
        } else {
            out.write(entityValue);
        }
        return 2 + (end - start) + (isHex ? 1 : 0) + 1;
    }
    return 0;
}","public void test66() throws Throwable {
    NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();
    StringWriter stringWriter0 = new StringWriter();
    int int0 = numericEntityUnescaper0.translate((CharSequence) ""\u0000\u0000\u0000&"", 3, (Writer) stringWriter0);
    assertEquals(0, int0);
}","/**
 * {@inheritDoc}
 */"
"public final String translate(CharSequence input) {
    if (input == null) {
        return null;
    }
    try {
        StringWriter writer = new StringWriter(input.length() * 2);
        translate(input, writer);
        return writer.toString();
    } catch (IOException ioe) {
        // this should never ever happen while writing to a StringWriter
        throw new RuntimeException(ioe);
    }
}","public void test77() throws Throwable {
    NumericEntityUnescaper numericEntityUnescaper0 = new NumericEntityUnescaper();
    char[] charArray0 = new char[4];
    charArray0[3] = '&';
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    String string0 = numericEntityUnescaper0.translate((CharSequence) charBuffer0);
    assertEquals(""\u0000\u0000\u0000&"", string0);
}","/**
 * Helper for non-Writer usage.
 * @param input CharSequence to be translated
 * @return String output of translation
 */"
