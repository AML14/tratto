focal_method,test_prefix,docstring
"//-----------------------------------------------------------------------
/**
 * <p>Gets the time zone display name, using a cache for performance.</p>
 *
 * @param tz  the zone to query
 * @param daylight  true if daylight savings
 * @param style  the style to use <code>TimeZone.LONG</code>
 *  or <code>TimeZone.SHORT</code>
 * @param locale  the locale to use
 * @return the textual name of the time zone
 */
static synchronized String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {
    Object key = new TimeZoneDisplayKey(tz, daylight, style, locale);
    String value = cTimeZoneDisplayCache.get(key);
    if (value == null) {
        // This is a very slow call, so cache the results.
        value = tz.getDisplayName(daylight, style, locale);
        cTimeZoneDisplayCache.put(key, value);
    }
    return value;
}","public void test009() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.CHINA;
    // Undeclared exception!
    try {
        FastDateFormat.getTimeZoneDisplay(timeZone0, true, (-1745), locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal style: -1745
        //
        verifyException(""java.util.TimeZone"", e);
    }
}",""
"public static FastDateFormat getTimeInstance(int style, Locale locale) {
    return getTimeInstance(style, null, locale);
}","public void test0117() throws Throwable {
    Locale locale0 = Locale.forLanguageTag(""6"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, locale0);
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Gets a time formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0127() throws Throwable {
    Locale locale0 = Locale.forLanguageTag(""6"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, locale0);
    assertEquals(18, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0128() throws Throwable {
    Locale locale0 = Locale.forLanguageTag(""6"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0129() throws Throwable {
    Locale locale0 = Locale.forLanguageTag(""6"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, locale0);
    assertEquals(""h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"protected void init() {
    List<Rule> rulesList = parsePattern();
    mRules = rulesList.toArray(new Rule[rulesList.size()]);
    int len = 0;
    for (int i = mRules.length; --i >= 0; ) {
        len += mRules[i].estimateLength();
    }
    mMaxLengthEstimate = len;
}","public void test0131() throws Throwable {
    Locale locale0 = Locale.forLanguageTag(""6"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, locale0);
    fastDateFormat0.init();
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Initializes the instance for first use.</p>
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0141() throws Throwable {
    Locale locale0 = Locale.forLanguageTag(""6"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, locale0);
    fastDateFormat0.init();
    assertEquals(18, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0142() throws Throwable {
    Locale locale0 = Locale.forLanguageTag(""6"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, locale0);
    fastDateFormat0.init();
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0143() throws Throwable {
    Locale locale0 = Locale.forLanguageTag(""6"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, locale0);
    fastDateFormat0.init();
    assertEquals(""h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Gets a date formatter instance using the specified style in the
 * default time zone and locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getDateInstance(int style) {
    return getDateInstance(style, null, null);
}","public void test0244() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0);
    assertEquals(2, FastDateFormat.MEDIUM);
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0248() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0);
    assertEquals(31, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0249() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0);
    assertEquals(""EEEE, MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0250() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"protected String parseToken(String pattern, int[] indexRef) {
    StringBuilder buf = new StringBuilder();
    int i = indexRef[0];
    int length = pattern.length();
    char c = pattern.charAt(i);
    if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {
        // Scan a run of the same character, which indicates a time
        // pattern.
        buf.append(c);
        while (i + 1 < length) {
            char peek = pattern.charAt(i + 1);
            if (peek == c) {
                buf.append(c);
                i++;
            } else {
                break;
            }
        }
    } else {
        // This will identify token as text.
        buf.append('\'');
        boolean inLiteral = false;
        for (; i < length; i++) {
            c = pattern.charAt(i);
            if (c == '\'') {
                if (i + 1 < length && pattern.charAt(i + 1) == '\'') {
                    // '' is treated as escaped '
                    i++;
                    buf.append(c);
                } else {
                    inLiteral = !inLiteral;
                }
            } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {
                i--;
                break;
            } else {
                buf.append(c);
            }
        }
    }
    indexRef[0] = i;
    return buf.toString();
}","public void test0252() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0);
    int[] intArray0 = new int[7];
    String string0 = fastDateFormat0.parseToken(""Urk}#"", intArray0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Performs the parsing of tokens.</p>
 *
 * @param pattern  the pattern
 * @param indexRef  index references
 * @return parsed token
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0256() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0);
    int[] intArray0 = new int[7];
    String string0 = fastDateFormat0.parseToken(""Urk}#"", intArray0);
    assertEquals(31, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0257() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0);
    int[] intArray0 = new int[7];
    String string0 = fastDateFormat0.parseToken(""Urk}#"", intArray0);
    assertEquals(""EEEE, MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0258() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0);
    int[] intArray0 = new int[7];
    String string0 = fastDateFormat0.parseToken(""Urk}#"", intArray0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test0370() throws Throwable {
    Locale locale0 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0380() throws Throwable {
    Locale locale0 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0381() throws Throwable {
    Locale locale0 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0382() throws Throwable {
    Locale locale0 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0384() throws Throwable {
    Locale locale0 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    boolean boolean0 = fastDateFormat0.getTimeZoneOverridesCalendar();
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0394() throws Throwable {
    Locale locale0 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    boolean boolean0 = fastDateFormat0.getTimeZoneOverridesCalendar();
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0395() throws Throwable {
    Locale locale0 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    boolean boolean0 = fastDateFormat0.getTimeZoneOverridesCalendar();
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0396() throws Throwable {
    Locale locale0 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    boolean boolean0 = fastDateFormat0.getTimeZoneOverridesCalendar();
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets the time zone display name, using a cache for performance.</p>
 *
 * @param tz  the zone to query
 * @param daylight  true if daylight savings
 * @param style  the style to use <code>TimeZone.LONG</code>
 *  or <code>TimeZone.SHORT</code>
 * @param locale  the locale to use
 * @return the textual name of the time zone
 */
static synchronized String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {
    Object key = new TimeZoneDisplayKey(tz, daylight, style, locale);
    String value = cTimeZoneDisplayCache.get(key);
    if (value == null) {
        // This is a very slow call, so cache the results.
        value = tz.getDisplayName(daylight, style, locale);
        cTimeZoneDisplayCache.put(key, value);
    }
    return value;
}","public void test04114() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.CANADA_FRENCH;
    String string0 = FastDateFormat.getTimeZoneDisplay(timeZone0, false, 1, locale0);
    assertEquals(""Heure de Greenwich"", string0);
}",""
"public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = Integer.valueOf(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale != null) {
        key = new Pair(key, locale);
    }
    FastDateFormat format = cTimeInstanceCache.get(key);
    if (format == null) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getTimeInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cTimeInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test05123() throws Throwable {
    Locale locale0 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) null, locale0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets a time formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted time
 * @param locale  optional locale, overrides system locale
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test05133() throws Throwable {
    Locale locale0 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) null, locale0);
    assertEquals(""h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test05134() throws Throwable {
    Locale locale0 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) null, locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test05135() throws Throwable {
    Locale locale0 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) null, locale0);
    assertEquals(18, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = Integer.valueOf(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale != null) {
        key = new Pair(key, locale);
    }
    FastDateFormat format = cTimeInstanceCache.get(key);
    if (format == null) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getTimeInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cTimeInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test06146() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.ITALY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0, locale0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a time formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted time
 * @param locale  optional locale, overrides system locale
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test06157() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.ITALY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0, locale0);
    assertEquals(14, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test06158() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.ITALY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0, locale0);
    assertEquals(""H.mm.ss z"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test06159() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.ITALY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0, locale0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test06161() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.ITALY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0, locale0);
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test06172() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.ITALY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0, locale0);
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    assertEquals(14, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test06173() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.ITALY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0, locale0);
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    assertEquals(""H.mm.ss z"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test06174() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.ITALY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0, locale0);
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test07183() throws Throwable {
    Locale locale0 = Locale.US;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test07193() throws Throwable {
    Locale locale0 = Locale.US;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test07194() throws Throwable {
    Locale locale0 = Locale.US;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test07195() throws Throwable {
    Locale locale0 = Locale.US;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test08206() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""6/1/10"", timeZone0, locale0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test08217() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""6/1/10"", timeZone0, locale0);
    assertEquals(6, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test08218() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""6/1/10"", timeZone0, locale0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test08219() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""6/1/10"", timeZone0, locale0);
    assertEquals(""6/1/10"", fastDateFormat0.getPattern());
}",""
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test09221() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null);
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test09225() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test09226() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test09227() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public TimeZone getTimeZone() {
    return mTimeZone;
}","public void test10237() throws Throwable {
    DateFormatSymbols dateFormatSymbols0 = new DateFormatSymbols();
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat(""@,0"", dateFormatSymbols0);
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    assertNotNull(timeZone0);
}","/**
 * <p>Gets the time zone used by this formatter.</p>
 *
 * <p>This zone is always used for <code>Date</code> formatting.
 * If a <code>Calendar</code> is passed in to be formatted, the
 * time zone on that may be used depending on
 * {@link #getTimeZoneOverridesCalendar()}.</p>
 *
 * @return the time zone
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test10238() throws Throwable {
    DateFormatSymbols dateFormatSymbols0 = new DateFormatSymbols();
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat(""@,0"", dateFormatSymbols0);
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""@,0"", timeZone0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test10247() throws Throwable {
    DateFormatSymbols dateFormatSymbols0 = new DateFormatSymbols();
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat(""@,0"", dateFormatSymbols0);
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""@,0"", timeZone0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test10248() throws Throwable {
    DateFormatSymbols dateFormatSymbols0 = new DateFormatSymbols();
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat(""@,0"", dateFormatSymbols0);
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""@,0"", timeZone0);
    assertEquals(""@,0"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test10249() throws Throwable {
    DateFormatSymbols dateFormatSymbols0 = new DateFormatSymbols();
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat(""@,0"", dateFormatSymbols0);
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""@,0"", timeZone0);
    assertEquals(3, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {
    return getDateInstance(style, timeZone, null);
}","public void test11251() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) null);
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test11255() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) null);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test11256() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) null);
    assertEquals(""EEEE, MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test11257() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) null);
    assertEquals(31, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test12261() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test12266() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test12267() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test12268() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public StringBuffer format(Date date, StringBuffer buf) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, buf);
}","public void test12274() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    MockDate mockDate0 = new MockDate(3, 89, 1, 4, 648);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Formats a <code>Date</code> object into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param date  the date to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test12279() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    MockDate mockDate0 = new MockDate(3, 89, 1, 4, 648);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test12280() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    MockDate mockDate0 = new MockDate(3, 89, 1, 4, 648);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test12281() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    MockDate mockDate0 = new MockDate(3, 89, 1, 4, 648);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test12282() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    MockDate mockDate0 = new MockDate(3, 89, 1, 4, 648);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertEquals(""Wed Jun 01 14:48:00 GMT 1910"", mockDate0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test13299() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.GERMAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test13310() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.GERMAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test13311() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.GERMAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test13312() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.GERMAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public String format(Date date) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test13315() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.GERMAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    MockDate mockDate0 = new MockDate((-2848), 1, 284, (-2305), (-2305), 1916);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Formats a <code>Date</code> object.</p>
 *
 * @param date  the date to format
 * @return the formatted string
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test13326() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.GERMAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    MockDate mockDate0 = new MockDate((-2848), 1, 284, (-2305), (-2305), 1916);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test13327() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.GERMAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    MockDate mockDate0 = new MockDate((-2848), 1, 284, (-2305), (-2305), 1916);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test13328() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.GERMAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    MockDate mockDate0 = new MockDate((-2848), 1, 284, (-2305), (-2305), 1916);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test13329() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.GERMAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    MockDate mockDate0 = new MockDate((-2848), 1, 284, (-2305), (-2305), 1916);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals(""Mon Aug 04 09:06:56 GMT 949"", mockDate0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test14332() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (Locale) null);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test14336() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (Locale) null);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test14337() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (Locale) null);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test14338() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (Locale) null);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public TimeZone getTimeZone() {
    return mTimeZone;
}","public void test14345() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (Locale) null);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""");
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    assertNotNull(timeZone0);
}","/**
 * <p>Gets the time zone used by this formatter.</p>
 *
 * <p>This zone is always used for <code>Date</code> formatting.
 * If a <code>Calendar</code> is passed in to be formatted, the
 * time zone on that may be used depending on
 * {@link #getTimeZoneOverridesCalendar()}.</p>
 *
 * @return the time zone
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test14354() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (Locale) null);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""");
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    Calendar calendar0 = MockCalendar.getInstance(timeZone0);
    assertNotNull(calendar0);
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public String format(Calendar calendar) {
    return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test14355() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (Locale) null);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""");
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    Calendar calendar0 = MockCalendar.getInstance(timeZone0);
    String string0 = fastDateFormat0.format(calendar0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Formats a <code>Calendar</code> object.</p>
 *
 * @param calendar  the calendar to format
 * @return the formatted string
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test14359() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (Locale) null);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""");
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    Calendar calendar0 = MockCalendar.getInstance(timeZone0);
    String string0 = fastDateFormat0.format(calendar0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test14360() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (Locale) null);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""");
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    Calendar calendar0 = MockCalendar.getInstance(timeZone0);
    String string0 = fastDateFormat0.format(calendar0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test14361() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (Locale) null);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""");
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    Calendar calendar0 = MockCalendar.getInstance(timeZone0);
    String string0 = fastDateFormat0.format(calendar0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"protected String parseToken(String pattern, int[] indexRef) {
    StringBuilder buf = new StringBuilder();
    int i = indexRef[0];
    int length = pattern.length();
    char c = pattern.charAt(i);
    if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {
        // Scan a run of the same character, which indicates a time
        // pattern.
        buf.append(c);
        while (i + 1 < length) {
            char peek = pattern.charAt(i + 1);
            if (peek == c) {
                buf.append(c);
                i++;
            } else {
                break;
            }
        }
    } else {
        // This will identify token as text.
        buf.append('\'');
        boolean inLiteral = false;
        for (; i < length; i++) {
            c = pattern.charAt(i);
            if (c == '\'') {
                if (i + 1 < length && pattern.charAt(i + 1) == '\'') {
                    // '' is treated as escaped '
                    i++;
                    buf.append(c);
                } else {
                    inLiteral = !inLiteral;
                }
            } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {
                i--;
                break;
            } else {
                buf.append(c);
            }
        }
    }
    indexRef[0] = i;
    return buf.toString();
}","public void test15380() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (Locale) null);
    int[] intArray0 = new int[5];
    // Undeclared exception!
    try {
        fastDateFormat0.parseToken("""", intArray0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * <p>Performs the parsing of tokens.</p>
 *
 * @param pattern  the pattern
 * @param indexRef  index references
 * @return parsed token
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a date formatter instance using the specified style in the
 * default time zone and locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getDateInstance(int style) {
    return getDateInstance(style, null, null);
}","public void test16381() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(1);
    assertEquals(2, FastDateFormat.MEDIUM);
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test16385() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(1);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test16386() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(1);
    assertEquals(20, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test16387() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(1);
    assertEquals(""MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"protected String parseToken(String pattern, int[] indexRef) {
    StringBuilder buf = new StringBuilder();
    int i = indexRef[0];
    int length = pattern.length();
    char c = pattern.charAt(i);
    if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {
        // Scan a run of the same character, which indicates a time
        // pattern.
        buf.append(c);
        while (i + 1 < length) {
            char peek = pattern.charAt(i + 1);
            if (peek == c) {
                buf.append(c);
                i++;
            } else {
                break;
            }
        }
    } else {
        // This will identify token as text.
        buf.append('\'');
        boolean inLiteral = false;
        for (; i < length; i++) {
            c = pattern.charAt(i);
            if (c == '\'') {
                if (i + 1 < length && pattern.charAt(i + 1) == '\'') {
                    // '' is treated as escaped '
                    i++;
                    buf.append(c);
                } else {
                    inLiteral = !inLiteral;
                }
            } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {
                i--;
                break;
            } else {
                buf.append(c);
            }
        }
    }
    indexRef[0] = i;
    return buf.toString();
}","public void test16389() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(1);
    int[] intArray0 = new int[4];
    // Undeclared exception!
    try {
        fastDateFormat0.parseToken((String) null, intArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Performs the parsing of tokens.</p>
 *
 * @param pattern  the pattern
 * @param indexRef  index references
 * @return parsed token
 */"
"// Constructor
//-----------------------------------------------------------------------
/**
 * <p>Constructs a new FastDateFormat.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  time zone to use, <code>null</code> means use
 *  default for <code>Date</code> and value within for
 *  <code>Calendar</code>
 * @param locale  locale, <code>null</code> means use system
 *  default
 * @throws IllegalArgumentException if pattern is invalid or
 *  <code>null</code>
 */
protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {
    super();
    if (pattern == null) {
        throw new IllegalArgumentException(""The pattern must not be null"");
    }
    mPattern = pattern;
    mTimeZoneForced = (timeZone != null);
    if (timeZone == null) {
        timeZone = TimeZone.getDefault();
    }
    mTimeZone = timeZone;
    mLocaleForced = (locale != null);
    if (locale == null) {
        locale = Locale.getDefault();
    }
    mLocale = locale;
}","public void test17403() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3, """");
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", simpleTimeZone0, locale0);
    assertEquals(3, FastDateFormat.SHORT);
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test17418() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3, """");
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", simpleTimeZone0, locale0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test17419() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3, """");
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", simpleTimeZone0, locale0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test17420() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3, """");
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", simpleTimeZone0, locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Parsing
//-----------------------------------------------------------------------
/**
 * <p>Parsing is not supported.</p>
 *
 * @param source  the string to parse
 * @param pos  the parsing position
 * @return <code>null</code> as not supported
 */
@Override
public Object parseObject(String source, ParsePosition pos) {
    pos.setIndex(0);
    pos.setErrorIndex(0);
    return null;
}","public void test17422() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3, """");
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", simpleTimeZone0, locale0);
    // Undeclared exception!
    try {
        fastDateFormat0.parseObject(""2;Og@Nt"", (ParsePosition) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Gets the time zone display name, using a cache for performance.</p>
 *
 * @param tz  the zone to query
 * @param daylight  true if daylight savings
 * @param style  the style to use <code>TimeZone.LONG</code>
 *  or <code>TimeZone.SHORT</code>
 * @param locale  the locale to use
 * @return the textual name of the time zone
 */
static synchronized String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {
    Object key = new TimeZoneDisplayKey(tz, daylight, style, locale);
    String value = cTimeZoneDisplayCache.get(key);
    if (value == null) {
        // This is a very slow call, so cache the results.
        value = tz.getDisplayName(daylight, style, locale);
        cTimeZoneDisplayCache.put(key, value);
    }
    return value;
}","public void test18429() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3673, """");
    // Undeclared exception!
    try {
        FastDateFormat.getTimeZoneDisplay(simpleTimeZone0, true, 3673, (Locale) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat$TimeZoneDisplayKey"", e);
    }
}",""
"public static FastDateFormat getTimeInstance(int style, TimeZone timeZone) {
    return getTimeInstance(style, timeZone, null);
}","public void test19432() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    // Undeclared exception!
    try {
        FastDateFormat.getTimeInstance(1390, timeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style 1390
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a time formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted time
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */"
"public static FastDateFormat getTimeInstance(int style, Locale locale) {
    return getTimeInstance(style, null, locale);
}","public void test20433() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getTimeInstance(518, (Locale) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style 518
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a time formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a time formatter instance using the specified style in the
 * default time zone and locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getTimeInstance(int style) {
    return getTimeInstance(style, null, null);
}","public void test21434() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getTimeInstance((-438));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style -438
        //
        verifyException(""java.text.DateFormat"", e);
    }
}",""
"public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone) {
    return getDateTimeInstance(dateStyle, timeStyle, timeZone, null);
}","public void test22435() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getDateTimeInstance(276, 276, (TimeZone) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style 276
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date/time formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */"
"public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, Locale locale) {
    return getDateTimeInstance(dateStyle, timeStyle, null, locale);
}","public void test23443() throws Throwable {
    Locale locale0 = Locale.CANADA;
    // Undeclared exception!
    try {
        FastDateFormat.getDateTimeInstance((-750), (-750), locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style -750
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date/time formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a date/time formatter instance using the specified style
 * in the default time zone and locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle) {
    return getDateTimeInstance(dateStyle, timeStyle, null, null);
}","public void test24444() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getDateTimeInstance(11, 3);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style 11
        //
        verifyException(""java.text.DateFormat"", e);
    }
}",""
"public static FastDateFormat getDateInstance(int style, Locale locale) {
    return getDateInstance(style, null, locale);
}","public void test25452() throws Throwable {
    Locale locale0 = Locale.CHINESE;
    // Undeclared exception!
    try {
        FastDateFormat.getDateInstance(122, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style 122
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a date formatter instance using the specified style in the
 * default time zone and locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getDateInstance(int style) {
    return getDateInstance(style, null, null);
}","public void test26453() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getDateInstance(1559);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style 1559
        //
        verifyException(""java.text.DateFormat"", e);
    }
}",""
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test27454() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test27458() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test27459() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test27460() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public String format(Date date) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test27462() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    // Undeclared exception!
    try {
        fastDateFormat0.format((Date) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.Calendar"", e);
    }
}","/**
 * <p>Formats a <code>Date</code> object.</p>
 *
 * @param date  the date to format
 * @return the formatted string
 */"
"// Constructor
//-----------------------------------------------------------------------
/**
 * <p>Constructs a new FastDateFormat.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  time zone to use, <code>null</code> means use
 *  default for <code>Date</code> and value within for
 *  <code>Calendar</code>
 * @param locale  locale, <code>null</code> means use system
 *  default
 * @throws IllegalArgumentException if pattern is invalid or
 *  <code>null</code>
 */
protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {
    super();
    if (pattern == null) {
        throw new IllegalArgumentException(""The pattern must not be null"");
    }
    mPattern = pattern;
    mTimeZoneForced = (timeZone != null);
    if (timeZone == null) {
        timeZone = TimeZone.getDefault();
    }
    mTimeZone = timeZone;
    mLocaleForced = (locale != null);
    if (locale == null) {
        locale = Locale.getDefault();
    }
    mLocale = locale;
}","public void test28470() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = new FastDateFormat(""9]Y~%Db~VyH"", (TimeZone) null, locale0);
    assertEquals(1, FastDateFormat.LONG);
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test28480() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = new FastDateFormat(""9]Y~%Db~VyH"", (TimeZone) null, locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test28481() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = new FastDateFormat(""9]Y~%Db~VyH"", (TimeZone) null, locale0);
    assertEquals(""9]Y~%Db~VyH"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test28482() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = new FastDateFormat(""9]Y~%Db~VyH"", (TimeZone) null, locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public StringBuffer format(Calendar calendar, StringBuffer buf) {
    if (mTimeZoneForced) {
        /// LANG-538
        calendar.getTimeInMillis();
        calendar = (Calendar) calendar.clone();
        calendar.setTimeZone(mTimeZone);
    }
    return applyRules(calendar, buf);
}","public void test28485() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = new FastDateFormat(""9]Y~%Db~VyH"", (TimeZone) null, locale0);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(1, 1, 0, 0, 3);
    // Undeclared exception!
    try {
        fastDateFormat0.format((Calendar) mockGregorianCalendar0, (StringBuffer) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Formats a <code>Calendar</code> object into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param calendar  the calendar to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a time formatter instance using the specified style in the
 * default time zone and locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getTimeInstance(int style) {
    return getTimeInstance(style, null, null);
}","public void test29486() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1);
    assertEquals(2, FastDateFormat.MEDIUM);
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test29490() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test29491() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1);
    assertEquals(18, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test29492() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1);
    assertEquals(""h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"// Format methods
//-----------------------------------------------------------------------
/**
 * <p>Formats a <code>Date</code>, <code>Calendar</code> or
 * <code>Long</code> (milliseconds) object.</p>
 *
 * @param obj  the object to format
 * @param toAppendTo  the buffer to append to
 * @param pos  the position - ignored
 * @return the buffer passed in
 */
@Override
public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
    if (obj instanceof Date) {
        return format((Date) obj, toAppendTo);
    } else if (obj instanceof Calendar) {
        return format((Calendar) obj, toAppendTo);
    } else if (obj instanceof Long) {
        return format(((Long) obj).longValue(), toAppendTo);
    } else {
        throw new IllegalArgumentException(""Unknown class: "" + (obj == null ? ""<null>"" : obj.getClass().getName()));
    }
}","public void test29499() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(1, (-2571), 1713, 1604, 1, (-1));
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    // Undeclared exception!
    try {
        fastDateFormat0.format((Object) mockGregorianCalendar0, (StringBuffer) null, fieldPosition0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat$UnpaddedNumberField"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Gets a formatter instance using the default pattern in the
 * default locale.</p>
 *
 * @return a date/time formatter
 */
public static FastDateFormat getInstance() {
    return getInstance(getDefaultPattern(), null, null);
}","public void test30500() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    assertEquals(3, FastDateFormat.SHORT);
}",""
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test30504() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test30505() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test30506() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public StringBuffer format(long millis, StringBuffer buf) {
    return format(new Date(millis), buf);
}","public void test30508() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    // Undeclared exception!
    try {
        fastDateFormat0.format(1L, (StringBuffer) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat$UnpaddedMonthField"", e);
    }
}","/**
 * <p>Formats a milliseond <code>long</code> value into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param millis  the millisecond value to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 * @since 2.1
 */"
"// Constructor
//-----------------------------------------------------------------------
/**
 * <p>Constructs a new FastDateFormat.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  time zone to use, <code>null</code> means use
 *  default for <code>Date</code> and value within for
 *  <code>Calendar</code>
 * @param locale  locale, <code>null</code> means use system
 *  default
 * @throws IllegalArgumentException if pattern is invalid or
 *  <code>null</code>
 */
protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {
    super();
    if (pattern == null) {
        throw new IllegalArgumentException(""The pattern must not be null"");
    }
    mPattern = pattern;
    mTimeZoneForced = (timeZone != null);
    if (timeZone == null) {
        timeZone = TimeZone.getDefault();
    }
    mTimeZone = timeZone;
    mLocaleForced = (locale != null);
    if (locale == null) {
        locale = Locale.getDefault();
    }
    mLocale = locale;
}","public void test31518() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""org.apache.commons.lang3.time.FastDateFormat$TimeZoneDisplayKey"");
    Locale locale0 = Locale.ITALY;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    assertEquals(0, FastDateFormat.FULL);
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test31529() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""org.apache.commons.lang3.time.FastDateFormat$TimeZoneDisplayKey"");
    Locale locale0 = Locale.ITALY;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test31530() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""org.apache.commons.lang3.time.FastDateFormat$TimeZoneDisplayKey"");
    Locale locale0 = Locale.ITALY;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test31531() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""org.apache.commons.lang3.time.FastDateFormat$TimeZoneDisplayKey"");
    Locale locale0 = Locale.ITALY;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public String format(long millis) {
    return format(new Date(millis));
}","public void test31533() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""org.apache.commons.lang3.time.FastDateFormat$TimeZoneDisplayKey"");
    Locale locale0 = Locale.ITALY;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    // Undeclared exception!
    try {
        fastDateFormat0.format(0L);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Formats a millisecond <code>long</code> value.</p>
 *
 * @param millis  the millisecond value to format
 * @return the formatted string
 * @since 2.1
 */"
"@Override
public int hashCode() {
    int total = 0;
    total += mPattern.hashCode();
    total += mTimeZone.hashCode();
    total += (mTimeZoneForced ? 1 : 0);
    total += mLocale.hashCode();
    total += (mLocaleForced ? 1 : 0);
    return total;
}","public void test32542() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    fastDateFormat0.hashCode();
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Returns a hashcode compatible with equals.</p>
 *
 * @return a hashcode compatible with equals
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test32546() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    fastDateFormat0.hashCode();
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test32547() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    fastDateFormat0.hashCode();
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test32548() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    fastDateFormat0.hashCode();
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"@Override
public int hashCode() {
    int total = 0;
    total += mPattern.hashCode();
    total += mTimeZone.hashCode();
    total += (mTimeZoneForced ? 1 : 0);
    total += mLocale.hashCode();
    total += (mLocaleForced ? 1 : 0);
    return total;
}","public void test33557() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0);
    fastDateFormat0.hashCode();
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Returns a hashcode compatible with equals.</p>
 *
 * @return a hashcode compatible with equals
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test33561() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0);
    fastDateFormat0.hashCode();
    assertEquals(31, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test33562() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0);
    fastDateFormat0.hashCode();
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test33563() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0);
    fastDateFormat0.hashCode();
    assertEquals(""EEEE, MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Gets a date/time formatter instance using the specified style
 * in the default time zone and locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle) {
    return getDateTimeInstance(dateStyle, timeStyle, null, null);
}","public void test34564() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    assertEquals(1, FastDateFormat.LONG);
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test34568() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    assertEquals(50, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test34569() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test34570() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    assertEquals(""EEEE, MMMM d, yyyy h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test34572() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat0);
    assertEquals(1, FastDateFormat.LONG);
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test34576() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat0);
    assertEquals(50, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test34577() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test34578() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat0);
    assertEquals(""EEEE, MMMM d, yyyy h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public StringBuffer format(Calendar calendar, StringBuffer buf) {
    if (mTimeZoneForced) {
        /// LANG-538
        calendar.getTimeInMillis();
        calendar = (Calendar) calendar.clone();
        calendar.setTimeZone(mTimeZone);
    }
    return applyRules(calendar, buf);
}","public void test35619() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 1, (-2177), 0, 0, 54);
    char[] charArray0 = new char[4];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Calendar) mockGregorianCalendar0, stringBuffer0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Formats a <code>Calendar</code> object into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param calendar  the calendar to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test35623() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 1, (-2177), 0, 0, 54);
    char[] charArray0 = new char[4];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Calendar) mockGregorianCalendar0, stringBuffer0);
    assertEquals(50, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test35624() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 1, (-2177), 0, 0, 54);
    char[] charArray0 = new char[4];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Calendar) mockGregorianCalendar0, stringBuffer0);
    assertEquals(""EEEE, MMMM d, yyyy h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test35625() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 1, (-2177), 0, 0, 54);
    char[] charArray0 = new char[4];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Calendar) mockGregorianCalendar0, stringBuffer0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test35629() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 1, (-2177), 0, 0, 54);
    char[] charArray0 = new char[4];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Calendar) mockGregorianCalendar0, stringBuffer0);
    assertEquals(""org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=-62352892746000,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\""GMT\"",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=0,YEAR=7,MONTH=1,WEEK_OF_YEAR=7,WEEK_OF_MONTH=2,DAY_OF_MONTH=14,DAY_OF_YEAR=45,DAY_OF_WEEK=7,DAY_OF_WEEK_IN_MONTH=2,AM_PM=0,HOUR=0,HOUR_OF_DAY=0,MINUTE=0,SECOND=54,MILLISECOND=0,ZONE_OFFSET=0,DST_OFFSET=0]"", mockGregorianCalendar0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test36831() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    TimeZone.setDefault(timeZone0);
    Locale locale0 = Locale.CANADA_FRENCH;
    String string0 = timeZone0.getDisplayName(false, 0, locale0);
    String string1 = timeZone0.getDisplayName(false, 0, locale0);
    Long long0 = new Long(1L);
    boolean boolean0 = timeZone0.observesDaylightTime();
    DecimalFormat decimalFormat0 = (DecimalFormat) NumberFormat.getPercentInstance(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""GMT"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = decimalFormat0.format(0.0, stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer2 = stringBuffer0.append((CharSequence) ""GMT"");
    StringBuffer stringBuffer3 = stringBuffer1.insert(0, true);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
    StringBuffer stringBuffer4 = stringBuffer1.append((Object) mockGregorianCalendar0);
    assertEquals(""org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=1392409281320,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\""GMT\"",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2014,MONTH=1,WEEK_OF_YEAR=7,WEEK_OF_MONTH=3,DAY_OF_MONTH=14,DAY_OF_YEAR=45,DAY_OF_WEEK=6,DAY_OF_WEEK_IN_MONTH=2,AM_PM=1,HOUR=8,HOUR_OF_DAY=20,MINUTE=21,SECOND=21,MILLISECOND=320,ZONE_OFFSET=0,DST_OFFSET=0]"", mockGregorianCalendar0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = Integer.valueOf(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale == null) {
        locale = Locale.getDefault();
    }
    key = new Pair(key, locale);
    FastDateFormat format = cDateInstanceCache.get(key);
    if (format == null) {
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cDateInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test36848() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    TimeZone.setDefault(timeZone0);
    Locale locale0 = Locale.CANADA_FRENCH;
    String string0 = timeZone0.getDisplayName(false, 0, locale0);
    String string1 = timeZone0.getDisplayName(false, 0, locale0);
    Long long0 = new Long(1L);
    boolean boolean0 = timeZone0.observesDaylightTime();
    DecimalFormat decimalFormat0 = (DecimalFormat) NumberFormat.getPercentInstance(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""GMT"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = decimalFormat0.format(0.0, stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer2 = stringBuffer0.append((CharSequence) ""GMT"");
    StringBuffer stringBuffer3 = stringBuffer1.insert(0, true);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
    StringBuffer stringBuffer4 = stringBuffer1.append((Object) mockGregorianCalendar0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(2, timeZone0, locale0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a date formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test36852() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    TimeZone.setDefault(timeZone0);
    Locale locale0 = Locale.CANADA_FRENCH;
    String string0 = timeZone0.getDisplayName(false, 0, locale0);
    String string1 = timeZone0.getDisplayName(false, 0, locale0);
    Long long0 = new Long(1L);
    boolean boolean0 = timeZone0.observesDaylightTime();
    DecimalFormat decimalFormat0 = (DecimalFormat) NumberFormat.getPercentInstance(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""GMT"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = decimalFormat0.format(0.0, stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer2 = stringBuffer0.append((CharSequence) ""GMT"");
    StringBuffer stringBuffer3 = stringBuffer1.insert(0, true);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
    StringBuffer stringBuffer4 = stringBuffer1.append((Object) mockGregorianCalendar0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(2, timeZone0, locale0);
    assertEquals(""yyyy-MM-dd"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test36853() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    TimeZone.setDefault(timeZone0);
    Locale locale0 = Locale.CANADA_FRENCH;
    String string0 = timeZone0.getDisplayName(false, 0, locale0);
    String string1 = timeZone0.getDisplayName(false, 0, locale0);
    Long long0 = new Long(1L);
    boolean boolean0 = timeZone0.observesDaylightTime();
    DecimalFormat decimalFormat0 = (DecimalFormat) NumberFormat.getPercentInstance(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""GMT"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = decimalFormat0.format(0.0, stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer2 = stringBuffer0.append((CharSequence) ""GMT"");
    StringBuffer stringBuffer3 = stringBuffer1.insert(0, true);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
    StringBuffer stringBuffer4 = stringBuffer1.append((Object) mockGregorianCalendar0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(2, timeZone0, locale0);
    assertEquals(10, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test36854() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    TimeZone.setDefault(timeZone0);
    Locale locale0 = Locale.CANADA_FRENCH;
    String string0 = timeZone0.getDisplayName(false, 0, locale0);
    String string1 = timeZone0.getDisplayName(false, 0, locale0);
    Long long0 = new Long(1L);
    boolean boolean0 = timeZone0.observesDaylightTime();
    DecimalFormat decimalFormat0 = (DecimalFormat) NumberFormat.getPercentInstance(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""GMT"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = decimalFormat0.format(0.0, stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer2 = stringBuffer0.append((CharSequence) ""GMT"");
    StringBuffer stringBuffer3 = stringBuffer1.insert(0, true);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
    StringBuffer stringBuffer4 = stringBuffer1.append((Object) mockGregorianCalendar0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(2, timeZone0, locale0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone, Locale locale) {
    Object key = new Pair(Integer.valueOf(dateStyle), Integer.valueOf(timeStyle));
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale == null) {
        locale = Locale.getDefault();
    }
    key = new Pair(key, locale);
    FastDateFormat format = cDateTimeInstanceCache.get(key);
    if (format == null) {
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cDateTimeInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date time pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test37869() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    // Undeclared exception!
    try {
        FastDateFormat.getDateTimeInstance(0, (-1548), (TimeZone) simpleTimeZone0, (Locale) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style -1548
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date/time formatter instance using the specified style,
 * time zone and locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 */"
"public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone, Locale locale) {
    Object key = new Pair(Integer.valueOf(dateStyle), Integer.valueOf(timeStyle));
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale == null) {
        locale = Locale.getDefault();
    }
    key = new Pair(key, locale);
    FastDateFormat format = cDateTimeInstanceCache.get(key);
    if (format == null) {
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cDateTimeInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date time pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test38877() throws Throwable {
    Locale locale0 = Locale.CHINESE;
    // Undeclared exception!
    try {
        FastDateFormat.getDateTimeInstance(801, 2210, (TimeZone) null, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style 2210
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date/time formatter instance using the specified style,
 * time zone and locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 */"
"public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = Integer.valueOf(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale != null) {
        key = new Pair(key, locale);
    }
    FastDateFormat format = cTimeInstanceCache.get(key);
    if (format == null) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getTimeInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cTimeInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test39880() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""org.apache.commons.lang3.time.FastDateFormat$TimeZoneDisplayKey"");
    // Undeclared exception!
    try {
        FastDateFormat.getTimeInstance((-978), timeZone0, (Locale) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style -978
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a time formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted time
 * @param locale  optional locale, overrides system locale
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 */"
"public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = Integer.valueOf(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale != null) {
        key = new Pair(key, locale);
    }
    FastDateFormat format = cTimeInstanceCache.get(key);
    if (format == null) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getTimeInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cTimeInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test40888() throws Throwable {
    Locale locale0 = Locale.GERMANY;
    // Undeclared exception!
    try {
        FastDateFormat.getTimeInstance(2883, (TimeZone) null, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style 2883
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a time formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted time
 * @param locale  optional locale, overrides system locale
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 */"
"public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = Integer.valueOf(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale == null) {
        locale = Locale.getDefault();
    }
    key = new Pair(key, locale);
    FastDateFormat format = cDateInstanceCache.get(key);
    if (format == null) {
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cDateInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test41898() throws Throwable {
    Locale locale0 = Locale.ENGLISH;
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0, locale0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a date formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test41909() throws Throwable {
    Locale locale0 = Locale.ENGLISH;
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0, locale0);
    assertEquals(31, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test41910() throws Throwable {
    Locale locale0 = Locale.ENGLISH;
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0, locale0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test41911() throws Throwable {
    Locale locale0 = Locale.ENGLISH;
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0, locale0);
    assertEquals(""EEEE, MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = Integer.valueOf(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale == null) {
        locale = Locale.getDefault();
    }
    key = new Pair(key, locale);
    FastDateFormat format = cDateInstanceCache.get(key);
    if (format == null) {
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cDateInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test42913() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getDateInstance(65, (TimeZone) null, (Locale) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style 65
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 */"
"public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {
    return getDateInstance(style, timeZone, null);
}","public void test43916() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(3, timeZone0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test43921() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(3, timeZone0);
    assertEquals(""M/d/yy"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test43922() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(3, timeZone0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test43923() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(3, timeZone0);
    assertEquals(10, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public String format(Date date) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test43926() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 89, 1, 4, 648);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Formats a <code>Date</code> object.</p>
 *
 * @param date  the date to format
 * @return the formatted string
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test43931() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 89, 1, 4, 648);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals(""M/d/yy"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test43932() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 89, 1, 4, 648);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test43933() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 89, 1, 4, 648);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals(10, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test43934() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 89, 1, 4, 648);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals(""Wed Jun 01 14:48:00 GMT 1910"", mockDate0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test44944() throws Throwable {
    Locale locale0 = Locale.ENGLISH;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test44954() throws Throwable {
    Locale locale0 = Locale.ENGLISH;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test44955() throws Throwable {
    Locale locale0 = Locale.ENGLISH;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test44956() throws Throwable {
    Locale locale0 = Locale.ENGLISH;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test45976() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance("""", locale0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test45986() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance("""", locale0);
    assertEquals("""", fastDateFormat1.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test45987() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance("""", locale0);
    assertFalse(fastDateFormat1.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test45988() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance("""", locale0);
    assertEquals(0, fastDateFormat1.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test45989() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance("""", locale0);
    assertFalse(fastDateFormat1.equals((Object) fastDateFormat0));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test45992() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance("""", locale0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat1);
    assertEquals(2, FastDateFormat.MEDIUM);
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test451001() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance("""", locale0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat1);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test451002() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance("""", locale0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat1);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test451003() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance("""", locale0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat1);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test451010() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance("""", locale0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat1);
    assertEquals("""", fastDateFormat1.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test451011() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance("""", locale0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat1);
    assertFalse(fastDateFormat1.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test451012() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance("""", locale0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat1);
    assertEquals(0, fastDateFormat1.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test451013() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance("""", locale0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat1);
    assertFalse(fastDateFormat0.equals((Object) fastDateFormat1));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test451014() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance("""", locale0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat1);
    assertFalse(fastDateFormat1.equals((Object) fastDateFormat0));
}",""
"public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {
    return getDateInstance(style, timeZone, null);
}","public void test461024() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test461033() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test461034() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    assertEquals(31, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test461035() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    assertEquals(""EEEE, MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"// Parsing
//-----------------------------------------------------------------------
/**
 * <p>Parsing is not supported.</p>
 *
 * @param source  the string to parse
 * @param pos  the parsing position
 * @return <code>null</code> as not supported
 */
@Override
public Object parseObject(String source, ParsePosition pos) {
    pos.setIndex(0);
    pos.setErrorIndex(0);
    return null;
}","public void test461044() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    assertEquals(2, FastDateFormat.MEDIUM);
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test461053() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test461054() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    assertEquals(31, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test461055() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    assertEquals(""EEEE, MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"public StringBuffer format(long millis, StringBuffer buf) {
    return format(new Date(millis), buf);
}","public void test461067() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(48L, stringBuffer0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Formats a milliseond <code>long</code> value into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param millis  the millisecond value to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 * @since 2.1
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test461076() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(48L, stringBuffer0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test461077() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(48L, stringBuffer0);
    assertEquals(31, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test461078() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(48L, stringBuffer0);
    assertEquals(""EEEE, MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"@Override
public int hashCode() {
    int total = 0;
    total += mPattern.hashCode();
    total += mTimeZone.hashCode();
    total += (mTimeZoneForced ? 1 : 0);
    total += mLocale.hashCode();
    total += (mLocaleForced ? 1 : 0);
    return total;
}","public void test461088() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(48L, stringBuffer0);
    fastDateFormat0.hashCode();
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Returns a hashcode compatible with equals.</p>
 *
 * @return a hashcode compatible with equals
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test461097() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(48L, stringBuffer0);
    fastDateFormat0.hashCode();
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test461098() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(48L, stringBuffer0);
    fastDateFormat0.hashCode();
    assertEquals(31, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test461099() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(48L, stringBuffer0);
    fastDateFormat0.hashCode();
    assertEquals(""EEEE, MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = Integer.valueOf(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale != null) {
        key = new Pair(key, locale);
    }
    FastDateFormat format = cTimeInstanceCache.get(key);
    if (format == null) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getTimeInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cTimeInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test461107() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(48L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a time formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted time
 * @param locale  optional locale, overrides system locale
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test461122() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(48L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    assertTrue(fastDateFormat1.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test461123() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(48L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    assertEquals(19, fastDateFormat1.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test461124() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(48L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    assertEquals(""HH:mm' Uhr 'z"", fastDateFormat1.getPattern());
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test461125() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(48L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    assertFalse(fastDateFormat1.equals((Object) fastDateFormat0));
}",""
"// Format methods
//-----------------------------------------------------------------------
/**
 * <p>Formats a <code>Date</code>, <code>Calendar</code> or
 * <code>Long</code> (milliseconds) object.</p>
 *
 * @param obj  the object to format
 * @param toAppendTo  the buffer to append to
 * @param pos  the position - ignored
 * @return the buffer passed in
 */
@Override
public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
    if (obj instanceof Date) {
        return format((Date) obj, toAppendTo);
    } else if (obj instanceof Calendar) {
        return format((Calendar) obj, toAppendTo);
    } else if (obj instanceof Long) {
        return format(((Long) obj).longValue(), toAppendTo);
    } else {
        throw new IllegalArgumentException(""Unknown class: "" + (obj == null ? ""<null>"" : obj.getClass().getName()));
    }
}","public void test461164() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(48L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 2);
    // Undeclared exception!
    try {
        fastDateFormat0.format((Object) mockSimpleDateFormat0, stringBuffer1, fieldPosition0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unknown class: org.evosuite.runtime.mock.java.text.MockSimpleDateFormat
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test471175() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    Long long0 = new Long(1951L);
    boolean boolean0 = fastDateFormat0.equals(long0);
    assertEquals(1, FastDateFormat.LONG);
}",""
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test471179() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    Long long0 = new Long(1951L);
    boolean boolean0 = fastDateFormat0.equals(long0);
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test471180() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    Long long0 = new Long(1951L);
    boolean boolean0 = fastDateFormat0.equals(long0);
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test471181() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    Long long0 = new Long(1951L);
    boolean boolean0 = fastDateFormat0.equals(long0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {
    return getDateInstance(style, timeZone, null);
}","public void test491194() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test491199() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0);
    assertEquals(31, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test491200() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0);
    assertEquals(""EEEE, MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test491201() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Format methods
//-----------------------------------------------------------------------
/**
 * <p>Formats a <code>Date</code>, <code>Calendar</code> or
 * <code>Long</code> (milliseconds) object.</p>
 *
 * @param obj  the object to format
 * @param toAppendTo  the buffer to append to
 * @param pos  the position - ignored
 * @return the buffer passed in
 */
@Override
public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
    if (obj instanceof Date) {
        return format((Date) obj, toAppendTo);
    } else if (obj instanceof Calendar) {
        return format((Calendar) obj, toAppendTo);
    } else if (obj instanceof Long) {
        return format(((Long) obj).longValue(), toAppendTo);
    } else {
        throw new IllegalArgumentException(""Unknown class: "" + (obj == null ? ""<null>"" : obj.getClass().getName()));
    }
}","public void test491212() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0);
    Long long0 = new Long(1L);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""GMT"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Object) long0, stringBuffer0, fieldPosition0);
    assertEquals(2, FastDateFormat.MEDIUM);
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test491217() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0);
    Long long0 = new Long(1L);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""GMT"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Object) long0, stringBuffer0, fieldPosition0);
    assertEquals(31, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test491218() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0);
    Long long0 = new Long(1L);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""GMT"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Object) long0, stringBuffer0, fieldPosition0);
    assertEquals(""EEEE, MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test491219() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0);
    Long long0 = new Long(1L);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""GMT"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Object) long0, stringBuffer0, fieldPosition0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test501239() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test501249() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test501250() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    assertEquals(3, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test501251() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    assertEquals(""E"", fastDateFormat0.getPattern());
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Gets a date formatter instance using the specified style in the
 * default time zone and locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getDateInstance(int style) {
    return getDateInstance(style, null, null);
}","public void test501257() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    assertEquals(3, FastDateFormat.SHORT);
}",""
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test501261() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    assertEquals(""MMMM d, yyyy"", fastDateFormat1.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test501262() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    assertEquals(20, fastDateFormat1.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test501263() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    assertFalse(fastDateFormat1.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501264() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    assertFalse(fastDateFormat1.equals((Object) fastDateFormat0));
}",""
"public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, Locale locale) {
    return getDateTimeInstance(dateStyle, timeStyle, null, locale);
}","public void test501285() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Gets a date/time formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test501295() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    assertFalse(fastDateFormat2.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test501296() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    assertEquals(""dd/MM/yy h:mm:ss z a"", fastDateFormat2.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test501297() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    assertEquals(27, fastDateFormat2.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501299() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    assertFalse(fastDateFormat2.equals((Object) fastDateFormat1));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501300() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    assertFalse(fastDateFormat2.equals((Object) fastDateFormat0));
}",""
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test501305() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    assertEquals(0, FastDateFormat.FULL);
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test501315() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test501316() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    assertEquals(3, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test501317() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    assertEquals(""E"", fastDateFormat0.getPattern());
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501319() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    assertFalse(fastDateFormat0.equals((Object) fastDateFormat1));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501320() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    assertFalse(fastDateFormat0.equals((Object) fastDateFormat2));
}",""
"public TimeZone getTimeZone() {
    return mTimeZone;
}","public void test501327() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets the time zone used by this formatter.</p>
 *
 * <p>This zone is always used for <code>Date</code> formatting.
 * If a <code>Calendar</code> is passed in to be formatted, the
 * time zone on that may be used depending on
 * {@link #getTimeZoneOverridesCalendar()}.</p>
 *
 * @return the time zone
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test501337() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test501338() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    assertEquals(3, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test501339() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    assertEquals(""E"", fastDateFormat0.getPattern());
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501342() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    assertFalse(fastDateFormat0.equals((Object) fastDateFormat1));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501343() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    assertFalse(fastDateFormat0.equals((Object) fastDateFormat2));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501344() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    assertTrue(timeZone1.equals((Object) timeZone0));
}",""
"public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {
    return getDateInstance(style, timeZone, null);
}","public void test501350() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test501355() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    assertEquals(""M/d/yy"", fastDateFormat3.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test501356() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    assertTrue(fastDateFormat3.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test501357() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    assertEquals(10, fastDateFormat3.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501358() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    assertTrue(timeZone0.equals((Object) timeZone1));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501359() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    assertFalse(fastDateFormat3.equals((Object) fastDateFormat0));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501360() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    assertFalse(fastDateFormat3.equals((Object) fastDateFormat2));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501361() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    assertFalse(fastDateFormat3.equals((Object) fastDateFormat1));
}",""
"public String format(Date date) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test501368() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Formats a <code>Date</code> object.</p>
 *
 * @param date  the date to format
 * @return the formatted string
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test501373() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    assertEquals(""M/d/yy"", fastDateFormat3.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test501374() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    assertTrue(fastDateFormat3.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test501375() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    assertEquals(10, fastDateFormat3.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test501376() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    assertEquals(""Tue Dec 01 14:48:00 GMT 1908"", mockDate0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501377() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    assertTrue(timeZone0.equals((Object) timeZone1));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501378() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    assertFalse(fastDateFormat3.equals((Object) fastDateFormat0));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501379() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    assertFalse(fastDateFormat3.equals((Object) fastDateFormat2));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501380() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    assertFalse(fastDateFormat3.equals((Object) fastDateFormat1));
}",""
"// Parsing
//-----------------------------------------------------------------------
/**
 * <p>Parsing is not supported.</p>
 *
 * @param source  the string to parse
 * @param pos  the parsing position
 * @return <code>null</code> as not supported
 */
@Override
public Object parseObject(String source, ParsePosition pos) {
    pos.setIndex(0);
    pos.setErrorIndex(0);
    return null;
}","public void test501393() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat2.parseObject("""", parsePosition0);
    assertEquals(1, FastDateFormat.LONG);
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test501403() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat2.parseObject("""", parsePosition0);
    assertFalse(fastDateFormat2.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test501404() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat2.parseObject("""", parsePosition0);
    assertEquals(""dd/MM/yy h:mm:ss z a"", fastDateFormat2.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test501405() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat2.parseObject("""", parsePosition0);
    assertEquals(27, fastDateFormat2.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501410() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat2.parseObject("""", parsePosition0);
    assertFalse(fastDateFormat2.equals((Object) fastDateFormat3));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501411() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat2.parseObject("""", parsePosition0);
    assertFalse(fastDateFormat2.equals((Object) fastDateFormat1));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501412() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat2.parseObject("""", parsePosition0);
    assertFalse(fastDateFormat2.equals((Object) fastDateFormat0));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501418() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat2.parseObject("""", parsePosition0);
    MockDate mockDate1 = new MockDate(0, 1, 2, 3, (-888), 0);
    assertFalse(mockDate1.equals((Object) mockDate0));
}",""
"public StringBuffer format(Date date, StringBuffer buf) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, buf);
}","public void test501483() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat2.parseObject("""", parsePosition0);
    MockDate mockDate1 = new MockDate(0, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer(""E"");
    StringBuffer stringBuffer1 = stringBuffer0.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(1);
    StringBuffer stringBuffer2 = decimalFormat0.format((-1837L), stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer3 = fastDateFormat2.format((Date) mockDate1, stringBuffer2);
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Formats a <code>Date</code> object into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param date  the date to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test501487() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat2.parseObject("""", parsePosition0);
    MockDate mockDate1 = new MockDate(0, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer(""E"");
    StringBuffer stringBuffer1 = stringBuffer0.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(1);
    StringBuffer stringBuffer2 = decimalFormat0.format((-1837L), stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer3 = fastDateFormat2.format((Date) mockDate1, stringBuffer2);
    assertEquals(""Thu Feb 01 12:12:00 GMT 1900"", mockDate1.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test501521() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat2.parseObject("""", parsePosition0);
    MockDate mockDate1 = new MockDate(0, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer(""E"");
    StringBuffer stringBuffer1 = stringBuffer0.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(1);
    StringBuffer stringBuffer2 = decimalFormat0.format((-1837L), stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer3 = fastDateFormat2.format((Date) mockDate1, stringBuffer2);
    assertFalse(fastDateFormat2.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test501522() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat2.parseObject("""", parsePosition0);
    MockDate mockDate1 = new MockDate(0, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer(""E"");
    StringBuffer stringBuffer1 = stringBuffer0.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(1);
    StringBuffer stringBuffer2 = decimalFormat0.format((-1837L), stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer3 = fastDateFormat2.format((Date) mockDate1, stringBuffer2);
    assertEquals(""dd/MM/yy h:mm:ss z a"", fastDateFormat2.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test501523() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat2.parseObject("""", parsePosition0);
    MockDate mockDate1 = new MockDate(0, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer(""E"");
    StringBuffer stringBuffer1 = stringBuffer0.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(1);
    StringBuffer stringBuffer2 = decimalFormat0.format((-1837L), stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer3 = fastDateFormat2.format((Date) mockDate1, stringBuffer2);
    assertEquals(27, fastDateFormat2.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501524() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat2.parseObject("""", parsePosition0);
    MockDate mockDate1 = new MockDate(0, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer(""E"");
    StringBuffer stringBuffer1 = stringBuffer0.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(1);
    StringBuffer stringBuffer2 = decimalFormat0.format((-1837L), stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer3 = fastDateFormat2.format((Date) mockDate1, stringBuffer2);
    assertFalse(mockDate1.equals((Object) mockDate0));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501526() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat2.parseObject("""", parsePosition0);
    MockDate mockDate1 = new MockDate(0, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer(""E"");
    StringBuffer stringBuffer1 = stringBuffer0.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(1);
    StringBuffer stringBuffer2 = decimalFormat0.format((-1837L), stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer3 = fastDateFormat2.format((Date) mockDate1, stringBuffer2);
    assertFalse(fastDateFormat2.equals((Object) fastDateFormat3));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501527() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat2.parseObject("""", parsePosition0);
    MockDate mockDate1 = new MockDate(0, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer(""E"");
    StringBuffer stringBuffer1 = stringBuffer0.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(1);
    StringBuffer stringBuffer2 = decimalFormat0.format((-1837L), stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer3 = fastDateFormat2.format((Date) mockDate1, stringBuffer2);
    assertFalse(fastDateFormat2.equals((Object) fastDateFormat1));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501528() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat2.parseObject("""", parsePosition0);
    MockDate mockDate1 = new MockDate(0, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer(""E"");
    StringBuffer stringBuffer1 = stringBuffer0.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(1);
    StringBuffer stringBuffer2 = decimalFormat0.format((-1837L), stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer3 = fastDateFormat2.format((Date) mockDate1, stringBuffer2);
    assertFalse(fastDateFormat2.equals((Object) fastDateFormat0));
}",""
"// Parsing
//-----------------------------------------------------------------------
/**
 * <p>Parsing is not supported.</p>
 *
 * @param source  the string to parse
 * @param pos  the parsing position
 * @return <code>null</code> as not supported
 */
@Override
public Object parseObject(String source, ParsePosition pos) {
    pos.setIndex(0);
    pos.setErrorIndex(0);
    return null;
}","public void test501544() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat2.parseObject("""", parsePosition0);
    MockDate mockDate1 = new MockDate(0, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer(""E"");
    StringBuffer stringBuffer1 = stringBuffer0.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(1);
    StringBuffer stringBuffer2 = decimalFormat0.format((-1837L), stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer3 = fastDateFormat2.format((Date) mockDate1, stringBuffer2);
    Object object1 = fastDateFormat2.parseObject(""I+iH4"", parsePosition0);
    assertEquals(1, FastDateFormat.LONG);
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test501554() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat2.parseObject("""", parsePosition0);
    MockDate mockDate1 = new MockDate(0, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer(""E"");
    StringBuffer stringBuffer1 = stringBuffer0.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(1);
    StringBuffer stringBuffer2 = decimalFormat0.format((-1837L), stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer3 = fastDateFormat2.format((Date) mockDate1, stringBuffer2);
    Object object1 = fastDateFormat2.parseObject(""I+iH4"", parsePosition0);
    assertFalse(fastDateFormat2.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test501555() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat2.parseObject("""", parsePosition0);
    MockDate mockDate1 = new MockDate(0, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer(""E"");
    StringBuffer stringBuffer1 = stringBuffer0.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(1);
    StringBuffer stringBuffer2 = decimalFormat0.format((-1837L), stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer3 = fastDateFormat2.format((Date) mockDate1, stringBuffer2);
    Object object1 = fastDateFormat2.parseObject(""I+iH4"", parsePosition0);
    assertEquals(""dd/MM/yy h:mm:ss z a"", fastDateFormat2.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test501556() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat2.parseObject("""", parsePosition0);
    MockDate mockDate1 = new MockDate(0, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer(""E"");
    StringBuffer stringBuffer1 = stringBuffer0.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(1);
    StringBuffer stringBuffer2 = decimalFormat0.format((-1837L), stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer3 = fastDateFormat2.format((Date) mockDate1, stringBuffer2);
    Object object1 = fastDateFormat2.parseObject(""I+iH4"", parsePosition0);
    assertEquals(27, fastDateFormat2.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501561() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat2.parseObject("""", parsePosition0);
    MockDate mockDate1 = new MockDate(0, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer(""E"");
    StringBuffer stringBuffer1 = stringBuffer0.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(1);
    StringBuffer stringBuffer2 = decimalFormat0.format((-1837L), stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer3 = fastDateFormat2.format((Date) mockDate1, stringBuffer2);
    Object object1 = fastDateFormat2.parseObject(""I+iH4"", parsePosition0);
    assertFalse(fastDateFormat2.equals((Object) fastDateFormat3));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501562() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat2.parseObject("""", parsePosition0);
    MockDate mockDate1 = new MockDate(0, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer(""E"");
    StringBuffer stringBuffer1 = stringBuffer0.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(1);
    StringBuffer stringBuffer2 = decimalFormat0.format((-1837L), stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer3 = fastDateFormat2.format((Date) mockDate1, stringBuffer2);
    Object object1 = fastDateFormat2.parseObject(""I+iH4"", parsePosition0);
    assertFalse(fastDateFormat2.equals((Object) fastDateFormat1));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501563() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat2.parseObject("""", parsePosition0);
    MockDate mockDate1 = new MockDate(0, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer(""E"");
    StringBuffer stringBuffer1 = stringBuffer0.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(1);
    StringBuffer stringBuffer2 = decimalFormat0.format((-1837L), stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer3 = fastDateFormat2.format((Date) mockDate1, stringBuffer2);
    Object object1 = fastDateFormat2.parseObject(""I+iH4"", parsePosition0);
    assertFalse(fastDateFormat2.equals((Object) fastDateFormat0));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501570() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat2.parseObject("""", parsePosition0);
    MockDate mockDate1 = new MockDate(0, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer(""E"");
    StringBuffer stringBuffer1 = stringBuffer0.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(1);
    StringBuffer stringBuffer2 = decimalFormat0.format((-1837L), stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer3 = fastDateFormat2.format((Date) mockDate1, stringBuffer2);
    Object object1 = fastDateFormat2.parseObject(""I+iH4"", parsePosition0);
    TimeZone timeZone2 = TimeZone.getTimeZone(""Greenwich Mean Time"");
    assertTrue(timeZone2.equals((Object) timeZone0));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501571() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""E"", locale0);
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(1);
    String string0 = timeZone0.getDisplayName(locale0);
    Locale locale1 = Locale.forLanguageTag(""E"");
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(3, timeZone0);
    MockDate mockDate0 = new MockDate(3, 71, 1, 4, 648);
    String string2 = fastDateFormat3.format((Date) mockDate0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat2.parseObject("""", parsePosition0);
    MockDate mockDate1 = new MockDate(0, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer(""E"");
    StringBuffer stringBuffer1 = stringBuffer0.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(1);
    StringBuffer stringBuffer2 = decimalFormat0.format((-1837L), stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer3 = fastDateFormat2.format((Date) mockDate1, stringBuffer2);
    Object object1 = fastDateFormat2.parseObject(""I+iH4"", parsePosition0);
    TimeZone timeZone2 = TimeZone.getTimeZone(""Greenwich Mean Time"");
    assertTrue(timeZone2.equals((Object) timeZone1));
}",""
"public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = Integer.valueOf(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale == null) {
        locale = Locale.getDefault();
    }
    key = new Pair(key, locale);
    FastDateFormat format = cDateInstanceCache.get(key);
    if (format == null) {
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cDateInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test511584() throws Throwable {
    String string0 = """";
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.ROOT;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(2, timeZone0, locale0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a date formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test511595() throws Throwable {
    String string0 = """";
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.ROOT;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(2, timeZone0, locale0);
    assertEquals(""MMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test511596() throws Throwable {
    String string0 = """";
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.ROOT;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(2, timeZone0, locale0);
    assertEquals(14, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test511597() throws Throwable {
    String string0 = """";
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.ROOT;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(2, timeZone0, locale0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test511599() throws Throwable {
    String string0 = """";
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.ROOT;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(2, timeZone0, locale0);
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""CjY3mZ!-QI }(r"", timeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: C
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test521603() throws Throwable {
    ZoneId zoneId0 = ZoneId.systemDefault();
    TimeZone timeZone0 = TimeZone.getTimeZone(zoneId0);
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""u%F=Jb{Fk6<5bi1LAQ"", timeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: u
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test531611() throws Throwable {
    Locale locale0 = Locale.ITALIAN;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""htC+iAsdS2#%*>BG"", (TimeZone) null, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: t
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public TimeZone getTimeZone() {
    return mTimeZone;
}","public void test541617() throws Throwable {
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    assertNotNull(timeZone0);
}","/**
 * <p>Gets the time zone used by this formatter.</p>
 *
 * <p>This zone is always used for <code>Date</code> formatting.
 * If a <code>Calendar</code> is passed in to be formatted, the
 * time zone on that may be used depending on
 * {@link #getTimeZoneOverridesCalendar()}.</p>
 *
 * @return the time zone
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test541618() throws Throwable {
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""`r`JjOw"", timeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: r
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test551619() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""@H(d*8qNRb\u0001$;g;eW"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: q
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test561629() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.US;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""<null>"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: n
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test571639() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.ITALY;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""iWKU+]K\""-?:et/0,"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: i
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test581647() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""gl#+/t~.LgR_d%q"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: g
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test591661() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(408, """");
    Locale locale0 = new Locale("""");
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""];fP>%Q\""w"", (TimeZone) simpleTimeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: f
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test601669() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance("">WK6e]DBk"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: e
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test611676() throws Throwable {
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""cu+&Tf&53r^xfe!*`l@"", timeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: c
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test621684() throws Throwable {
    Locale locale0 = Locale.ROOT;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""-b>/gir%,"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: b
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test631685() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""3(Wd<XHT"", (TimeZone) null, (Locale) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: X
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test641692() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    // Undeclared exception!
    try {
        FastDateFormat.getInstance("":Uhxdjbv"", (TimeZone) simpleTimeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: U
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test651693() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""FTo'rGr4$NMLbEI2U\"""");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: T
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test661701() throws Throwable {
    Locale locale0 = Locale.FRENCH;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""w$RV7HWI "", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: R
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test671702() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""sP`u+I ,=U*"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: P
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test681710() throws Throwable {
    Locale locale0 = Locale.JAPANESE;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""Nl"", (TimeZone) null, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: N
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test691720() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.CANADA;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance("".L$D&HvPb"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: L
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test701728() throws Throwable {
    Locale locale0 = Locale.CHINA;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""[#K.lmr7["", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: l
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test711732() throws Throwable {
    ZoneId zoneId0 = ZoneId.systemDefault();
    TimeZone timeZone0 = TimeZone.getTimeZone(zoneId0);
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""#%F=JFk6A5Dbi1LAQ"", timeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: J
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = Integer.valueOf(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale != null) {
        key = new Pair(key, locale);
    }
    FastDateFormat format = cTimeInstanceCache.get(key);
    if (format == null) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getTimeInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cTimeInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test721810() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(48L, stringBuffer0);
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Gets a time formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted time
 * @param locale  optional locale, overrides system locale
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test721825() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(48L, stringBuffer0);
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    assertEquals(""HH:mm' Uhr 'z"", fastDateFormat1.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test721826() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(48L, stringBuffer0);
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    assertEquals(19, fastDateFormat1.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test721827() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(48L, stringBuffer0);
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    assertTrue(fastDateFormat1.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test721828() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(48L, stringBuffer0);
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    assertFalse(fastDateFormat1.equals((Object) fastDateFormat0));
}",""
"public static FastDateFormat getDateInstance(int style, Locale locale) {
    return getDateInstance(style, null, locale);
}","public void test721863() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(48L, stringBuffer0);
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(0, locale1);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test721873() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(48L, stringBuffer0);
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(0, locale1);
    assertFalse(fastDateFormat2.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test721874() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(48L, stringBuffer0);
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(0, locale1);
    assertEquals(""yyyy'\u5E74'M'\u6708'd'\u65E5' EEEE"", fastDateFormat2.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test721875() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(48L, stringBuffer0);
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(0, locale1);
    assertEquals(17, fastDateFormat2.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test721877() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(48L, stringBuffer0);
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(0, locale1);
    assertFalse(fastDateFormat2.equals((Object) fastDateFormat1));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test721878() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(48L, stringBuffer0);
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(0, locale1);
    assertFalse(fastDateFormat2.equals((Object) fastDateFormat0));
}",""
"// Format methods
//-----------------------------------------------------------------------
/**
 * <p>Formats a <code>Date</code>, <code>Calendar</code> or
 * <code>Long</code> (milliseconds) object.</p>
 *
 * @param obj  the object to format
 * @param toAppendTo  the buffer to append to
 * @param pos  the position - ignored
 * @return the buffer passed in
 */
@Override
public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
    if (obj instanceof Date) {
        return format((Date) obj, toAppendTo);
    } else if (obj instanceof Calendar) {
        return format((Calendar) obj, toAppendTo);
    } else if (obj instanceof Long) {
        return format(((Long) obj).longValue(), toAppendTo);
    } else {
        throw new IllegalArgumentException(""Unknown class: "" + (obj == null ? ""<null>"" : obj.getClass().getName()));
    }
}","public void test721887() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(48L, stringBuffer0);
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(0, locale1);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 2);
    // Undeclared exception!
    try {
        fastDateFormat0.format((Object) mockSimpleDateFormat0, stringBuffer1, fieldPosition0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unknown class: org.evosuite.runtime.mock.java.text.MockSimpleDateFormat
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}",""
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test731888() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""9GIgE-"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: I
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test741896() throws Throwable {
    Locale locale0 = Locale.GERMAN;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""z}FWDo."", (TimeZone) null, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: o
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test751897() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""ZzBMHX.Xs,:pO[wVvQ"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: B
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test761898() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance((String) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The pattern must not be null
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"// Format methods
//-----------------------------------------------------------------------
/**
 * <p>Formats a <code>Date</code>, <code>Calendar</code> or
 * <code>Long</code> (milliseconds) object.</p>
 *
 * @param obj  the object to format
 * @param toAppendTo  the buffer to append to
 * @param pos  the position - ignored
 * @return the buffer passed in
 */
@Override
public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
    if (obj instanceof Date) {
        return format((Date) obj, toAppendTo);
    } else if (obj instanceof Calendar) {
        return format((Calendar) obj, toAppendTo);
    } else if (obj instanceof Long) {
        return format(((Long) obj).longValue(), toAppendTo);
    } else {
        throw new IllegalArgumentException(""Unknown class: "" + (obj == null ? ""<null>"" : obj.getClass().getName()));
    }
}","public void test771899() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""org.apache.commons.lang3.time.FastDateFormat$UnpaddedMonthField"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, (TimeZone) simpleTimeZone0);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 0, 0, 3, (-49), 0);
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    StringBuffer stringBuffer0 = new StringBuffer(""7t2Z)Umk`.3en(twdW3"");
    mockGregorianCalendar0.setFirstDayOfWeek(1693);
    StringBuffer stringBuffer1 = stringBuffer0.insert(0, ""org.apache.commons.lang3.time.FastDateFormat$TwentyFourHourField"");
    StringBuffer stringBuffer2 = fastDateFormat0.applyRules(mockGregorianCalendar0, stringBuffer0);
    Locale locale0 = Locale.CHINESE;
    locale0.getScript();
    Locale.forLanguageTag("""");
    FastDateFormat.getDateInstance(0, locale0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(0, locale0);
    locale0.getDisplayCountry();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(0, 3, (TimeZone) simpleTimeZone0, locale0);
    fastDateFormat2.applyRules(mockGregorianCalendar0, stringBuffer2);
    StringBuffer stringBuffer3 = fastDateFormat0.format((-2903L), stringBuffer1);
    fastDateFormat1.applyRules(mockGregorianCalendar0, stringBuffer3);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    // Undeclared exception!
    try {
        fastDateFormat1.format((Object) stringBuffer0, stringBuffer0, fieldPosition0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unknown class: java.lang.StringBuffer
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}",""
"public String format(long millis) {
    return format(new Date(millis));
}","public void test791901() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, (Locale) null);
    String string0 = fastDateFormat0.format(0L);
    assertEquals(""Thursday, January 1, 1970 12:00:00 AM GMT"", string0);
}","/**
 * <p>Formats a millisecond <code>long</code> value.</p>
 *
 * @param millis  the millisecond value to format
 * @return the formatted string
 * @since 2.1
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test801902() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""\""\""v!j.#"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: v
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test811903() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    boolean boolean0 = fastDateFormat0.getTimeZoneOverridesCalendar();
    assertTrue(boolean0);
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public String format(Calendar calendar) {
    return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test821904() throws Throwable {
    Locale locale0 = new Locale(""T{X#,(0"", ""T{X#,(0"", ""T{X#,(0"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, locale0);
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone((-1), ""oI\""g!s`4Dh3d9"");
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(simpleTimeZone0);
    String string0 = fastDateFormat0.format((Calendar) mockGregorianCalendar0);
    assertEquals(""Friday, February 14, 2014"", string0);
}","/**
 * <p>Formats a <code>Calendar</code> object.</p>
 *
 * @param calendar  the calendar to format
 * @return the formatted string
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a formatter instance using the default pattern in the
 * default locale.</p>
 *
 * @return a date/time formatter
 */
public static FastDateFormat getInstance() {
    return getInstance(getDefaultPattern(), null, null);
}","public void test831905() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance();
    assertNotSame(fastDateFormat1, fastDateFormat0);
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test831906() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance();
    assertEquals(21, fastDateFormat1.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test841908() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test841909() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    assertEquals(0, int0);
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test851910() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (Locale) null);
    String string0 = fastDateFormat0.toString();
    assertEquals(""FastDateFormat[]"", string0);
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test851911() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (Locale) null);
    String string0 = fastDateFormat0.toString();
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test871913() throws Throwable {
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""");
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    fastDateFormat0.getLocale();
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test881914() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(3, (TimeZone) null);
    assertEquals(""h:mm a"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test891915() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    fastDateFormat0.getPattern();
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {
    return getDateInstance(style, timeZone, null);
}","public void test901916() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 1, (-2177), 0, 0, 54);
    char[] charArray0 = new char[4];
    charArray0[0] = '^';
    charArray0[1] = 'j';
    charArray0[2] = '|';
    charArray0[3] = 'Q';
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 2178);
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(0);
    fastDateFormat0.equals(fastDateFormat1);
    FastDateFormat.getDateTimeInstance(0, 1);
    TimeZone timeZone0 = TimeZone.getDefault();
    // Undeclared exception!
    try {
        FastDateFormat.getDateInstance((-2650), timeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style -2650
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
