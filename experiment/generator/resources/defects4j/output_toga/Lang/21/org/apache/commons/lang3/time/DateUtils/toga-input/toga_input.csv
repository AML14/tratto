focal_method,test_prefix,docstring
"public static boolean truncatedEquals(Date date1, Date date2, int field) {
    return truncatedCompareTo(date1, date2, field) == 0;
}","public void test0000() throws Throwable {
    String[] stringArray0 = new String[4];
    stringArray0[0] = """";
    Date date0 = DateUtils.parseDateStrictly("""", stringArray0);
    Date date1 = DateUtils.ceiling((Object) date0, 0);
    boolean boolean0 = DateUtils.truncatedEquals(date0, date1, 0);
    assertFalse(boolean0);
}","/**
 * Determines if two dates are equal up to no more than the specified
 * most significant field.
 *
 * @param date1 the first date, not <code>null</code>
 * @param date2 the second date, not <code>null</code>
 * @param field the field from <code>Calendar</code>
 * @return <code>true</code> if equal; otherwise <code>false</code>
 * @throws IllegalArgumentException if any argument is <code>null</code>
 * @see #truncate(Date, int)
 * @see #truncatedEquals(Calendar, Calendar, int)
 * @since 3.0
 */"
"public static Calendar round(Calendar date, int field) {
    if (date == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    Calendar rounded = (Calendar) date.clone();
    modify(rounded, field, MODIFY_ROUND);
    return rounded;
}","public void test0011() throws Throwable {
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar((-3124), 870, 0, 0, (-3124), 870);
    // Undeclared exception!
    try {
        DateUtils.round((Calendar) mockGregorianCalendar0, (-3124));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The field -3124 is not supported
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Round this date, leaving the field specified as the most
 * significant field.</p>
 *
 * <p>For example, if you had the datetime of 28 Mar 2002
 * 13:45:01.231, if this was passed with HOUR, it would return
 * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it
 * would return 1 April 2002 0:00:00.000.</p>
 *
 * <p>For a date in a timezone that handles the change to daylight
 * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.
 * Suppose daylight saving time begins at 02:00 on March 30. Rounding a
 * date that crosses this time would produce the following values:
 * <ul>
 * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>
 * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>
 * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>
 * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>
 * </ul>
 * </p>
 *
 * @param date  the date to work with
 * @param field  the field from <code>Calendar</code>
 *  or <code>SEMI_MONTH</code>
 * @return the rounded date (a different object)
 * @throws IllegalArgumentException if the date is <code>null</code>
 * @throws ArithmeticException if the year is over 280 million
 */"
"public static boolean isSameInstant(Calendar cal1, Calendar cal2) {
    if (cal1 == null || cal2 == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    return cal1.getTime().getTime() == cal2.getTime().getTime();
}","public void test0023() throws Throwable {
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 0, 0);
    mockGregorianCalendar0.setTimeInMillis(451L);
    Calendar calendar0 = DateUtils.round((Calendar) mockGregorianCalendar0, 0);
    DateUtils.DateIterator dateUtils_DateIterator0 = new DateUtils.DateIterator(mockGregorianCalendar0, mockGregorianCalendar0);
    boolean boolean0 = DateUtils.isSameInstant(calendar0, (Calendar) mockGregorianCalendar0);
    assertFalse(boolean0);
}","/**
 * <p>Checks if two calendar objects represent the same instant in time.</p>
 *
 * <p>This method compares the long millisecond time of the two objects.</p>
 *
 * @param cal1  the first calendar, not altered, not null
 * @param cal2  the second calendar, not altered, not null
 * @return true if they represent the same millisecond instant
 * @throws IllegalArgumentException if either date is <code>null</code>
 * @since 2.1
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Checks if two date objects represent the same instant in time.</p>
 *
 * <p>This method compares the long millisecond time of the two objects.</p>
 *
 * @param date1  the first date, not altered, not null
 * @param date2  the second date, not altered, not null
 * @return true if they represent the same millisecond instant
 * @throws IllegalArgumentException if either date is <code>null</code>
 * @since 2.1
 */
public static boolean isSameInstant(Date date1, Date date2) {
    if (date1 == null || date2 == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    return date1.getTime() == date2.getTime();
}","public void test0035() throws Throwable {
    String[] stringArray0 = new String[4];
    stringArray0[0] = """";
    Date date0 = DateUtils.parseDateStrictly("""", stringArray0);
    Date date1 = DateUtils.ceiling((Object) date0, 0);
    boolean boolean0 = DateUtils.isSameInstant(date0, date1);
    assertFalse(boolean0);
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Checks if two date objects are on the same day ignoring time.</p>
 *
 * <p>28 Mar 2002 13:45 and 28 Mar 2002 06:01 would return true.
 * 28 Mar 2002 13:45 and 12 Mar 2002 13:45 would return false.
 * </p>
 *
 * @param date1  the first date, not altered, not null
 * @param date2  the second date, not altered, not null
 * @return true if they represent the same day
 * @throws IllegalArgumentException if either date is <code>null</code>
 * @since 2.1
 */
public static boolean isSameDay(Date date1, Date date2) {
    if (date1 == null || date2 == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    Calendar cal1 = Calendar.getInstance();
    cal1.setTime(date1);
    Calendar cal2 = Calendar.getInstance();
    cal2.setTime(date2);
    return isSameDay(cal1, cal2);
}","public void test0046() throws Throwable {
    String[] stringArray0 = new String[4];
    stringArray0[0] = """";
    Date date0 = DateUtils.parseDateStrictly("""", stringArray0);
    Date date1 = DateUtils.ceiling(date0, 2);
    boolean boolean0 = DateUtils.isSameDay(date0, date1);
    assertFalse(boolean0);
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Checks if two date objects are on the same day ignoring time.</p>
 *
 * <p>28 Mar 2002 13:45 and 28 Mar 2002 06:01 would return true.
 * 28 Mar 2002 13:45 and 12 Mar 2002 13:45 would return false.
 * </p>
 *
 * @param date1  the first date, not altered, not null
 * @param date2  the second date, not altered, not null
 * @return true if they represent the same day
 * @throws IllegalArgumentException if either date is <code>null</code>
 * @since 2.1
 */
public static boolean isSameDay(Date date1, Date date2) {
    if (date1 == null || date2 == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    Calendar cal1 = Calendar.getInstance();
    cal1.setTime(date1);
    Calendar cal2 = Calendar.getInstance();
    cal2.setTime(date2);
    return isSameDay(cal1, cal2);
}","public void test0059() throws Throwable {
    String[] stringArray0 = new String[4];
    stringArray0[0] = """";
    Date date0 = DateUtils.parseDateStrictly("""", stringArray0);
    Date date1 = DateUtils.ceiling((Object) date0, 0);
    boolean boolean0 = DateUtils.isSameDay(date0, date1);
    assertFalse(boolean0);
}",""
"public static int truncatedCompareTo(Date date1, Date date2, int field) {
    Date truncatedDate1 = truncate(date1, field);
    Date truncatedDate2 = truncate(date2, field);
    return truncatedDate1.compareTo(truncatedDate2);
}","public void test00712() throws Throwable {
    MockDate mockDate0 = new MockDate((-1756), 2482, 1, 1891, 1);
    Date date0 = DateUtils.addWeeks(mockDate0, 828);
    mockDate0.setTime(1);
    int int0 = DateUtils.truncatedCompareTo((Date) mockDate0, date0, 1);
    assertEquals(1, int0);
}","/**
 * Determines how two dates compare up to no more than the specified
 * most significant field.
 *
 * @param date1 the first date, not <code>null</code>
 * @param date2 the second date, not <code>null</code>
 * @param field the field from <code>Calendar</code>
 * @return a negative integer, zero, or a positive integer as the first
 * date is less than, equal to, or greater than the second.
 * @throws IllegalArgumentException if any argument is <code>null</code>
 * @see #truncate(Calendar, int)
 * @see #truncatedCompareTo(Date, Date, int)
 * @since 3.0
 */"
"public static int truncatedCompareTo(Date date1, Date date2, int field) {
    Date truncatedDate1 = truncate(date1, field);
    Date truncatedDate2 = truncate(date2, field);
    return truncatedDate1.compareTo(truncatedDate2);
}","public void test00813() throws Throwable {
    MockDate mockDate0 = new MockDate((-1756), 2482, 1, 1891, 1);
    Date date0 = DateUtils.addWeeks(mockDate0, 828);
    int int0 = DateUtils.truncatedCompareTo((Date) mockDate0, date0, 1);
    assertEquals((-1), int0);
}","/**
 * Determines how two dates compare up to no more than the specified
 * most significant field.
 *
 * @param date1 the first date, not <code>null</code>
 * @param date2 the second date, not <code>null</code>
 * @param field the field from <code>Calendar</code>
 * @return a negative integer, zero, or a positive integer as the first
 * date is less than, equal to, or greater than the second.
 * @throws IllegalArgumentException if any argument is <code>null</code>
 * @see #truncate(Calendar, int)
 * @see #truncatedCompareTo(Date, Date, int)
 * @since 3.0
 */"
"public static int truncatedCompareTo(Calendar cal1, Calendar cal2, int field) {
    Calendar truncatedCal1 = truncate(cal1, field);
    Calendar truncatedCal2 = truncate(cal2, field);
    return truncatedCal1.compareTo(truncatedCal2);
}","public void test00915() throws Throwable {
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar();
    MockGregorianCalendar mockGregorianCalendar1 = new MockGregorianCalendar(2, (-250), (-1835));
    int int0 = DateUtils.truncatedCompareTo((Calendar) mockGregorianCalendar0, (Calendar) mockGregorianCalendar1, 12);
    assertEquals(1, int0);
}","/**
 * Determines how two calendars compare up to no more than the specified
 * most significant field.
 *
 * @param cal1 the first calendar, not <code>null</code>
 * @param cal2 the second calendar, not <code>null</code>
 * @param field the field from <code>Calendar</code>
 * @return a negative integer, zero, or a positive integer as the first
 * calendar is less than, equal to, or greater than the second.
 * @throws IllegalArgumentException if any argument is <code>null</code>
 * @see #truncate(Calendar, int)
 * @see #truncatedCompareTo(Date, Date, int)
 * @since 3.0
 */"
"public static long getFragmentInSeconds(Date date, int fragment) {
    return getFragment(date, fragment, Calendar.SECOND);
}","public void test01622() throws Throwable {
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(12, 12, 12);
    Date date0 = mockGregorianCalendar0.getGregorianChange();
    long long0 = DateUtils.getFragmentInSeconds(date0, 12);
    assertEquals(0L, long0);
}","/**
 * <p>Returns the number of seconds within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the seconds of any date will only return the number of seconds
 * of the current minute (resulting in a number between 0 and 59). This
 * method will retrieve the number of seconds for any fragment.
 * For example, if you want to calculate the number of seconds past today,
 * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will
 * be all seconds of the past hour(s) and minutes(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a SECOND field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10
 *   (equivalent to deprecated date.getSeconds())</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10
 *   (equivalent to deprecated date.getSeconds())</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 26110
 *   (7*3600 + 15*60 + 10)</li>
 *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in seconds)</li>
 * </ul>
 * </p>
 *
 * @param date the date to work with, not null
 * @param fragment the Calendar field part of date to calculate
 * @return number of seconds within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"public static long getFragmentInMinutes(Calendar calendar, int fragment) {
    return getFragment(calendar, fragment, Calendar.MINUTE);
}","public void test01723() throws Throwable {
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar();
    long long0 = DateUtils.getFragmentInMinutes((Calendar) mockGregorianCalendar0, 14);
    assertEquals(0L, long0);
}","/**
 * <p>Returns the number of minutes within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the minutes of any date will only return the number of minutes
 * of the current hour (resulting in a number between 0 and 59). This
 * method will retrieve the number of minutes for any fragment.
 * For example, if you want to calculate the number of minutes past this month,
 * your fragment is Calendar.MONTH. The result will be all minutes of the
 * past day(s) and hour(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a MINUTE field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15
 *   (equivalent to calendar.get(Calendar.MINUTES))</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15
 *   (equivalent to calendar.get(Calendar.MINUTES))</li>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 15</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 435 (7*60 + 15)</li>
 *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in minutes)</li>
 * </ul>
 * </p>
 *
 * @param calendar the calendar to work with, not null
 * @param fragment the Calendar field part of calendar to calculate
 * @return number of minutes within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"public static long getFragmentInMinutes(Calendar calendar, int fragment) {
    return getFragment(calendar, fragment, Calendar.MINUTE);
}","public void test01824() throws Throwable {
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(3486, 1, 1618, 1618, (-1826), 2260);
    long long0 = DateUtils.getFragmentInMinutes((Calendar) mockGregorianCalendar0, 1);
    assertEquals(366011L, long0);
}","/**
 * <p>Returns the number of minutes within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the minutes of any date will only return the number of minutes
 * of the current hour (resulting in a number between 0 and 59). This
 * method will retrieve the number of minutes for any fragment.
 * For example, if you want to calculate the number of minutes past this month,
 * your fragment is Calendar.MONTH. The result will be all minutes of the
 * past day(s) and hour(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a MINUTE field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15
 *   (equivalent to calendar.get(Calendar.MINUTES))</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15
 *   (equivalent to calendar.get(Calendar.MINUTES))</li>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 15</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 435 (7*60 + 15)</li>
 *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in minutes)</li>
 * </ul>
 * </p>
 *
 * @param calendar the calendar to work with, not null
 * @param fragment the Calendar field part of calendar to calculate
 * @return number of minutes within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"public static long getFragmentInMilliseconds(Date date, int fragment) {
    return getFragment(date, fragment, Calendar.MILLISECOND);
}","public void test01925() throws Throwable {
    MockDate mockDate0 = new MockDate(6, 6, 6);
    long long0 = DateUtils.getFragmentInMilliseconds((Date) mockDate0, 6);
    assertEquals(0L, long0);
}","/**
 * <p>Returns the number of milliseconds within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the milliseconds of any date will only return the number of milliseconds
 * of the current second (resulting in a number between 0 and 999). This
 * method will retrieve the number of milliseconds for any fragment.
 * For example, if you want to calculate the number of milliseconds past today,
 * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will
 * be all milliseconds of the past hour(s), minutes(s) and second(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a SECOND field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10538 (10*1000 + 538)</li>
 *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in milliseconds)</li>
 * </ul>
 * </p>
 *
 * @param date the date to work with, not null
 * @param fragment the Calendar field part of date to calculate
 * @return number of milliseconds within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"public static long getFragmentInMilliseconds(Date date, int fragment) {
    return getFragment(date, fragment, Calendar.MILLISECOND);
}","public void test02026() throws Throwable {
    MockDate mockDate0 = new MockDate((-1756), 2482, 1, 1891, 1);
    long long0 = DateUtils.getFragmentInMilliseconds((Date) mockDate0, 1);
    assertEquals(1623660000L, long0);
}","/**
 * <p>Returns the number of milliseconds within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the milliseconds of any date will only return the number of milliseconds
 * of the current second (resulting in a number between 0 and 999). This
 * method will retrieve the number of milliseconds for any fragment.
 * For example, if you want to calculate the number of milliseconds past today,
 * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will
 * be all milliseconds of the past hour(s), minutes(s) and second(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a SECOND field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10538 (10*1000 + 538)</li>
 *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in milliseconds)</li>
 * </ul>
 * </p>
 *
 * @param date the date to work with, not null
 * @param fragment the Calendar field part of date to calculate
 * @return number of milliseconds within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"public static long getFragmentInDays(Date date, int fragment) {
    return getFragment(date, fragment, Calendar.DAY_OF_YEAR);
}","public void test02127() throws Throwable {
    MockDate mockDate0 = new MockDate();
    long long0 = DateUtils.getFragmentInDays((Date) mockDate0, 13);
    assertEquals(0L, long0);
}","/**
 * <p>Returns the number of days within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the days of any date will only return the number of days
 * of the current month (resulting in a number between 1 and 31). This
 * method will retrieve the number of days for any fragment.
 * For example, if you want to calculate the number of days past this year,
 * your fragment is Calendar.YEAR. The result will be all days of the
 * past month(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a DAY field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 28, 2008 with Calendar.MONTH as fragment will return 28
 *   (equivalent to deprecated date.getDay())</li>
 *  <li>February 28, 2008 with Calendar.MONTH as fragment will return 28
 *   (equivalent to deprecated date.getDay())</li>
 *  <li>January 28, 2008 with Calendar.YEAR as fragment will return 28</li>
 *  <li>February 28, 2008 with Calendar.YEAR as fragment will return 59</li>
 *  <li>January 28, 2008 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in days)</li>
 * </ul>
 * </p>
 *
 * @param date the date to work with, not null
 * @param fragment the Calendar field part of date to calculate
 * @return number of days  within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"public static long getFragmentInDays(Calendar calendar, int fragment) {
    return getFragment(calendar, fragment, Calendar.DAY_OF_YEAR);
}","public void test02228() throws Throwable {
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 1, 1);
    long long0 = DateUtils.getFragmentInDays((Calendar) mockGregorianCalendar0, 1);
    assertEquals(32L, long0);
}","/**
 * <p>Returns the number of days within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the days of any date will only return the number of days
 * of the current month (resulting in a number between 1 and 31). This
 * method will retrieve the number of days for any fragment.
 * For example, if you want to calculate the number of days past this year,
 * your fragment is Calendar.YEAR. The result will be all days of the
 * past month(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a DAY field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 28, 2008 with Calendar.MONTH as fragment will return 28
 *   (equivalent to calendar.get(Calendar.DAY_OF_MONTH))</li>
 *  <li>February 28, 2008 with Calendar.MONTH as fragment will return 28
 *   (equivalent to calendar.get(Calendar.DAY_OF_MONTH))</li>
 *  <li>January 28, 2008 with Calendar.YEAR as fragment will return 28
 *   (equivalent to calendar.get(Calendar.DAY_OF_YEAR))</li>
 *  <li>February 28, 2008 with Calendar.YEAR as fragment will return 59
 *   (equivalent to calendar.get(Calendar.DAY_OF_YEAR))</li>
 *  <li>January 28, 2008 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in days)</li>
 * </ul>
 * </p>
 *
 * @param calendar the calendar to work with, not null
 * @param fragment the Calendar field part of calendar to calculate
 * @return number of days within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"//-----------------------------------------------------------------------
/**
 * Adds a number of months to a date returning a new object.
 * The original date object is unchanged.
 *
 * @param date  the date, not null
 * @param amount  the amount to add, may be negative
 * @return the new date object with the amount added
 * @throws IllegalArgumentException if the date is null
 */
public static Date addMonths(Date date, int amount) {
    return add(date, Calendar.MONTH, amount);
}","public void test02329() throws Throwable {
    Instant instant0 = MockInstant.ofEpochSecond(1L);
    Date date0 = Date.from(instant0);
    Date date1 = DateUtils.addMonths(date0, 0);
    assertNotSame(date0, date1);
}",""
"public static int truncatedCompareTo(Date date1, Date date2, int field) {
    Date truncatedDate1 = truncate(date1, field);
    Date truncatedDate2 = truncate(date2, field);
    return truncatedDate1.compareTo(truncatedDate2);
}","public void test02430() throws Throwable {
    MockDate mockDate0 = new MockDate(1, 1, 0, 2940, (-2659));
    // Undeclared exception!
    try {
        DateUtils.truncatedCompareTo((Date) mockDate0, (Date) null, (-15));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The field -15 is not supported
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * Determines how two dates compare up to no more than the specified
 * most significant field.
 *
 * @param date1 the first date, not <code>null</code>
 * @param date2 the second date, not <code>null</code>
 * @param field the field from <code>Calendar</code>
 * @return a negative integer, zero, or a positive integer as the first
 * date is less than, equal to, or greater than the second.
 * @throws IllegalArgumentException if any argument is <code>null</code>
 * @see #truncate(Calendar, int)
 * @see #truncatedCompareTo(Date, Date, int)
 * @since 3.0
 */"
"public static int truncatedCompareTo(Calendar cal1, Calendar cal2, int field) {
    Calendar truncatedCal1 = truncate(cal1, field);
    Calendar truncatedCal2 = truncate(cal2, field);
    return truncatedCal1.compareTo(truncatedCal2);
}","public void test02531() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
    // Undeclared exception!
    try {
        DateUtils.truncatedCompareTo((Calendar) mockGregorianCalendar0, (Calendar) mockGregorianCalendar0, (-1170));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The field -1170 is not supported
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * Determines how two calendars compare up to no more than the specified
 * most significant field.
 *
 * @param cal1 the first calendar, not <code>null</code>
 * @param cal2 the second calendar, not <code>null</code>
 * @param field the field from <code>Calendar</code>
 * @return a negative integer, zero, or a positive integer as the first
 * calendar is less than, equal to, or greater than the second.
 * @throws IllegalArgumentException if any argument is <code>null</code>
 * @see #truncate(Calendar, int)
 * @see #truncatedCompareTo(Date, Date, int)
 * @since 3.0
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Truncate this date, leaving the field specified as the most
 * significant field.</p>
 *
 * <p>For example, if you had the datetime of 28 Mar 2002
 * 13:45:01.231, if you passed with HOUR, it would return 28 Mar
 * 2002 13:00:00.000.  If this was passed with MONTH, it would
 * return 1 Mar 2002 0:00:00.000.</p>
 *
 * @param date  the date to work with
 * @param field  the field from <code>Calendar</code>
 *  or <code>SEMI_MONTH</code>
 * @return the rounded date
 * @throws IllegalArgumentException if the date is <code>null</code>
 * @throws ArithmeticException if the year is over 280 million
 */
public static Date truncate(Date date, int field) {
    if (date == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    Calendar gval = Calendar.getInstance();
    gval.setTime(date);
    modify(gval, field, MODIFY_TRUNCATE);
    return gval.getTime();
}","public void test02632() throws Throwable {
    ZoneInfo zoneInfo0 = (ZoneInfo) DateUtils.UTC_TIME_ZONE;
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(zoneInfo0);
    ZonedDateTime zonedDateTime0 = mockGregorianCalendar0.toZonedDateTime();
    GregorianCalendar gregorianCalendar0 = MockGregorianCalendar.from(zonedDateTime0);
    Date date0 = gregorianCalendar0.getGregorianChange();
    // Undeclared exception!
    try {
        DateUtils.truncate(date0, 3);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Calendar value too large for accurate calculations
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Convert a Date into a Calendar object.
 *
 * @param date the date to convert to a Calendar
 * @return the created Calendar
 * @throws NullPointerException if null is passed in
 * @since 3.0
 */
public static Calendar toCalendar(Date date) {
    Calendar c = Calendar.getInstance();
    c.setTime(date);
    return c;
}","public void test02733() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.toCalendar((Date) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Sets the years field to a date returning a new object.
 * The original date object is unchanged.
 *
 * @param date  the date, not null
 * @param amount the amount to set
 * @return a new Date object set with the specified value
 * @throws IllegalArgumentException if the date is null
 * @since 2.4
 */
public static Date setYears(Date date, int amount) {
    return set(date, Calendar.YEAR, amount);
}","public void test02834() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.setYears((Date) null, 1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Sets the seconds field to a date returning a new object.
 * The original date object is unchanged.
 *
 * @param date  the date, not null
 * @param amount the amount to set
 * @return a new Date object set with the specified value
 * @throws IllegalArgumentException if the date is null
 * @since 2.4
 */
public static Date setSeconds(Date date, int amount) {
    return set(date, Calendar.SECOND, amount);
}","public void test02935() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.setSeconds((Date) null, 1215);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Sets the months field to a date returning a new object.
 * The original date object is unchanged.
 *
 * @param date  the date, not null
 * @param amount the amount to set
 * @return a new Date object set with the specified value
 * @throws IllegalArgumentException if the date is null
 * @since 2.4
 */
public static Date setMonths(Date date, int amount) {
    return set(date, Calendar.MONTH, amount);
}","public void test03036() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.setMonths((Date) null, 673);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Sets the minute field to a date returning a new object.
 * The original date object is unchanged.
 *
 * @param date  the date, not null
 * @param amount the amount to set
 * @return a new Date object set with the specified value
 * @throws IllegalArgumentException if the date is null
 * @since 2.4
 */
public static Date setMinutes(Date date, int amount) {
    return set(date, Calendar.MINUTE, amount);
}","public void test03137() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.setMinutes((Date) null, (-2516));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Sets the hours field to a date returning a new object.  Hours range
 * from  0-23.
 * The original date object is unchanged.
 *
 * @param date  the date, not null
 * @param amount the amount to set
 * @return a new Date object set with the specified value
 * @throws IllegalArgumentException if the date is null
 * @since 2.4
 */
public static Date setHours(Date date, int amount) {
    return set(date, Calendar.HOUR_OF_DAY, amount);
}","public void test03238() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.setHours((Date) null, 30);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Sets the day of month field to a date returning a new object.
 * The original date object is unchanged.
 *
 * @param date  the date, not null
 * @param amount the amount to set
 * @return a new Date object set with the specified value
 * @throws IllegalArgumentException if the date is null
 * @since 2.4
 */
public static Date setDays(Date date, int amount) {
    return set(date, Calendar.DAY_OF_MONTH, amount);
}","public void test03339() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.setDays((Date) null, (-1429));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Round this date, leaving the field specified as the most
 * significant field.</p>
 *
 * <p>For example, if you had the datetime of 28 Mar 2002
 * 13:45:01.231, if this was passed with HOUR, it would return
 * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it
 * would return 1 April 2002 0:00:00.000.</p>
 *
 * <p>For a date in a timezone that handles the change to daylight
 * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.
 * Suppose daylight saving time begins at 02:00 on March 30. Rounding a
 * date that crosses this time would produce the following values:
 * <ul>
 * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>
 * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>
 * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>
 * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>
 * </ul>
 * </p>
 *
 * @param date  the date to work with
 * @param field  the field from <code>Calendar</code>
 *  or <code>SEMI_MONTH</code>
 * @return the rounded date
 * @throws IllegalArgumentException if the date is <code>null</code>
 * @throws ArithmeticException if the year is over 280 million
 */
public static Date round(Date date, int field) {
    if (date == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    Calendar gval = Calendar.getInstance();
    gval.setTime(date);
    modify(gval, field, MODIFY_ROUND);
    return gval.getTime();
}","public void test03440() throws Throwable {
    MockDate mockDate0 = new MockDate(280000000, 2, 280000000, 3, 1810, 1138);
    // Undeclared exception!
    try {
        DateUtils.round((Date) mockDate0, 1810);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Calendar value too large for accurate calculations
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Parses a string representing a date by trying a variety of different parsers.</p>
 *
 * <p>The parse will try each parse pattern in turn.
 * A parse is only deemed successful if it parses the whole of the input string.
 * If no parse patterns match, a ParseException is thrown.</p>
 * The parser parses strictly - it does not allow for dates such as ""February 942, 1996"".
 *
 * @param str  the date to parse, not null
 * @param parsePatterns  the date format patterns to use, see SimpleDateFormat, not null
 * @return the parsed date
 * @throws IllegalArgumentException if the date string or pattern array is null
 * @throws ParseException if none of the date patterns were suitable
 * @since 2.5
 */
public static Date parseDateStrictly(String str, String... parsePatterns) throws ParseException {
    return parseDateWithLeniency(str, parsePatterns, false);
}","public void test03541() throws Throwable {
    String[] stringArray0 = new String[0];
    try {
        DateUtils.parseDateStrictly(""8"", stringArray0);
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Unable to parse the date: 8
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Parses a string representing a date by trying a variety of different parsers.</p>
 *
 * <p>The parse will try each parse pattern in turn.
 * A parse is only deemed successful if it parses the whole of the input string.
 * If no parse patterns match, a ParseException is thrown.</p>
 * The parser parses strictly - it does not allow for dates such as ""February 942, 1996"".
 *
 * @param str  the date to parse, not null
 * @param parsePatterns  the date format patterns to use, see SimpleDateFormat, not null
 * @return the parsed date
 * @throws IllegalArgumentException if the date string or pattern array is null
 * @throws ParseException if none of the date patterns were suitable
 * @since 2.5
 */
public static Date parseDateStrictly(String str, String... parsePatterns) throws ParseException {
    return parseDateWithLeniency(str, parsePatterns, false);
}","public void test03642() throws Throwable {
    String[] stringArray0 = new String[4];
    stringArray0[0] = ""QO%s&W+ZZ"";
    // Undeclared exception!
    try {
        DateUtils.parseDateStrictly(""QO%s&W+ZZ"", stringArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern character 'Q'
        //
        verifyException(""java.text.SimpleDateFormat"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Parses a string representing a date by trying a variety of different parsers.</p>
 *
 * <p>The parse will try each parse pattern in turn.
 * A parse is only deemed successful if it parses the whole of the input string.
 * If no parse patterns match, a ParseException is thrown.</p>
 * The parser will be lenient toward the parsed date.
 *
 * @param str  the date to parse, not null
 * @param parsePatterns  the date format patterns to use, see SimpleDateFormat, not null
 * @return the parsed date
 * @throws IllegalArgumentException if the date string or pattern array is null
 * @throws ParseException if none of the date patterns were suitable (or there were none)
 */
public static Date parseDate(String str, String... parsePatterns) throws ParseException {
    return parseDateWithLeniency(str, parsePatterns, true);
}","public void test03743() throws Throwable {
    String[] stringArray0 = new String[4];
    stringArray0[0] = ""Could not iterate based on "";
    // Undeclared exception!
    try {
        DateUtils.parseDate(""Could not iterate based on "", stringArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern character 'C'
        //
        verifyException(""java.text.SimpleDateFormat"", e);
    }
}",""
"public static long getFragmentInMinutes(Date date, int fragment) {
    return getFragment(date, fragment, Calendar.MINUTE);
}","public void test03844() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.getFragmentInMinutes((Date) null, 10);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Returns the number of minutes within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the minutes of any date will only return the number of minutes
 * of the current hour (resulting in a number between 0 and 59). This
 * method will retrieve the number of minutes for any fragment.
 * For example, if you want to calculate the number of minutes past this month,
 * your fragment is Calendar.MONTH. The result will be all minutes of the
 * past day(s) and hour(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a MINUTE field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15
 *   (equivalent to deprecated date.getMinutes())</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15
 *   (equivalent to deprecated date.getMinutes())</li>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 15</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 435 (7*60 + 15)</li>
 *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in minutes)</li>
 * </ul>
 * </p>
 *
 * @param date the date to work with, not null
 * @param fragment the Calendar field part of date to calculate
 * @return number of minutes within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"public static long getFragmentInHours(Calendar calendar, int fragment) {
    return getFragment(calendar, fragment, Calendar.HOUR_OF_DAY);
}","public void test03945() throws Throwable {
    Locale locale0 = Locale.ITALY;
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(locale0);
    // Undeclared exception!
    try {
        DateUtils.getFragmentInHours((Calendar) mockGregorianCalendar0, 4);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The fragment 4 is not supported
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Returns the number of hours within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the hours of any date will only return the number of hours
 * of the current day (resulting in a number between 0 and 23). This
 * method will retrieve the number of hours for any fragment.
 * For example, if you want to calculate the number of hours past this month,
 * your fragment is Calendar.MONTH. The result will be all hours of the
 * past day(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a HOUR field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7
 *   (equivalent to calendar.get(Calendar.HOUR_OF_DAY))</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7
 *   (equivalent to calendar.get(Calendar.HOUR_OF_DAY))</li>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 7</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 127 (5*24 + 7)</li>
 *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in hours)</li>
 * </ul>
 * </p>
 *
 * @param calendar the calendar to work with, not null
 * @param fragment the Calendar field part of calendar to calculate
 * @return number of hours within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"public static long getFragmentInDays(Date date, int fragment) {
    return getFragment(date, fragment, Calendar.DAY_OF_YEAR);
}","public void test04046() throws Throwable {
    MockDate mockDate0 = new MockDate();
    // Undeclared exception!
    try {
        DateUtils.getFragmentInDays((Date) mockDate0, (-1));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The fragment -1 is not supported
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Returns the number of days within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the days of any date will only return the number of days
 * of the current month (resulting in a number between 1 and 31). This
 * method will retrieve the number of days for any fragment.
 * For example, if you want to calculate the number of days past this year,
 * your fragment is Calendar.YEAR. The result will be all days of the
 * past month(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a DAY field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 28, 2008 with Calendar.MONTH as fragment will return 28
 *   (equivalent to deprecated date.getDay())</li>
 *  <li>February 28, 2008 with Calendar.MONTH as fragment will return 28
 *   (equivalent to deprecated date.getDay())</li>
 *  <li>January 28, 2008 with Calendar.YEAR as fragment will return 28</li>
 *  <li>February 28, 2008 with Calendar.YEAR as fragment will return 59</li>
 *  <li>January 28, 2008 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in days)</li>
 * </ul>
 * </p>
 *
 * @param date the date to work with, not null
 * @param fragment the Calendar field part of date to calculate
 * @return number of days  within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"//-----------------------------------------------------------------------
/**
 * Adds a number of years to a date returning a new object.
 * The original date object is unchanged.
 *
 * @param date  the date, not null
 * @param amount  the amount to add, may be negative
 * @return the new date object with the amount added
 * @throws IllegalArgumentException if the date is null
 */
public static Date addYears(Date date, int amount) {
    return add(date, Calendar.YEAR, amount);
}","public void test04147() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.addYears((Date) null, 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Adds a number of weeks to a date returning a new object.
 * The original date object is unchanged.
 *
 * @param date  the date, not null
 * @param amount  the amount to add, may be negative
 * @return the new date object with the amount added
 * @throws IllegalArgumentException if the date is null
 */
public static Date addWeeks(Date date, int amount) {
    return add(date, Calendar.WEEK_OF_YEAR, amount);
}","public void test04248() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.addWeeks((Date) null, 2485);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Adds a number of seconds to a date returning a new object.
 * The original date object is unchanged.
 *
 * @param date  the date, not null
 * @param amount  the amount to add, may be negative
 * @return the new date object with the amount added
 * @throws IllegalArgumentException if the date is null
 */
public static Date addSeconds(Date date, int amount) {
    return add(date, Calendar.SECOND, amount);
}","public void test04349() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.addSeconds((Date) null, 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Adds a number of minutes to a date returning a new object.
 * The original date object is unchanged.
 *
 * @param date  the date, not null
 * @param amount  the amount to add, may be negative
 * @return the new date object with the amount added
 * @throws IllegalArgumentException if the date is null
 */
public static Date addMinutes(Date date, int amount) {
    return add(date, Calendar.MINUTE, amount);
}","public void test04450() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.addMinutes((Date) null, 1584);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Adds a number of milliseconds to a date returning a new object.
 * The original date object is unchanged.
 *
 * @param date  the date, not null
 * @param amount  the amount to add, may be negative
 * @return the new date object with the amount added
 * @throws IllegalArgumentException if the date is null
 */
public static Date addMilliseconds(Date date, int amount) {
    return add(date, Calendar.MILLISECOND, amount);
}","public void test04551() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.addMilliseconds((Date) null, (-1239));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Adds a number of hours to a date returning a new object.
 * The original date object is unchanged.
 *
 * @param date  the date, not null
 * @param amount  the amount to add, may be negative
 * @return the new date object with the amount added
 * @throws IllegalArgumentException if the date is null
 */
public static Date addHours(Date date, int amount) {
    return add(date, Calendar.HOUR_OF_DAY, amount);
}","public void test04652() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.addHours((Date) null, 5352);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * Adds a number of days to a date returning a new object.
 * The original date object is unchanged.
 *
 * @param date  the date, not null
 * @param amount  the amount to add, may be negative
 * @return the new date object with the amount added
 * @throws IllegalArgumentException if the date is null
 */
public static Date addDays(Date date, int amount) {
    return add(date, Calendar.DAY_OF_MONTH, amount);
}","public void test04753() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.addDays((Date) null, (-1));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"public static Iterator<Calendar> iterator(Calendar focus, int rangeStyle) {
    if (focus == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    Calendar start = null;
    Calendar end = null;
    int startCutoff = Calendar.SUNDAY;
    int endCutoff = Calendar.SATURDAY;
    switch(rangeStyle) {
        case RANGE_MONTH_SUNDAY:
        case RANGE_MONTH_MONDAY:
            //Set start to the first of the month
            start = truncate(focus, Calendar.MONTH);
            //Set end to the last of the month
            end = (Calendar) start.clone();
            end.add(Calendar.MONTH, 1);
            end.add(Calendar.DATE, -1);
            //Loop start back to the previous sunday or monday
            if (rangeStyle == RANGE_MONTH_MONDAY) {
                startCutoff = Calendar.MONDAY;
                endCutoff = Calendar.SUNDAY;
            }
            break;
        case RANGE_WEEK_SUNDAY:
        case RANGE_WEEK_MONDAY:
        case RANGE_WEEK_RELATIVE:
        case RANGE_WEEK_CENTER:
            //Set start and end to the current date
            start = truncate(focus, Calendar.DATE);
            end = truncate(focus, Calendar.DATE);
            switch(rangeStyle) {
                case RANGE_WEEK_SUNDAY:
                    //already set by default
                    break;
                case RANGE_WEEK_MONDAY:
                    startCutoff = Calendar.MONDAY;
                    endCutoff = Calendar.SUNDAY;
                    break;
                case RANGE_WEEK_RELATIVE:
                    startCutoff = focus.get(Calendar.DAY_OF_WEEK);
                    endCutoff = startCutoff - 1;
                    break;
                case RANGE_WEEK_CENTER:
                    startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3;
                    endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3;
                    break;
            }
            break;
        default:
            throw new IllegalArgumentException(""The range style "" + rangeStyle + "" is not valid."");
    }
    if (startCutoff < Calendar.SUNDAY) {
        startCutoff += 7;
    }
    if (startCutoff > Calendar.SATURDAY) {
        startCutoff -= 7;
    }
    if (endCutoff < Calendar.SUNDAY) {
        endCutoff += 7;
    }
    if (endCutoff > Calendar.SATURDAY) {
        endCutoff -= 7;
    }
    while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) {
        start.add(Calendar.DATE, -1);
    }
    while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) {
        end.add(Calendar.DATE, 1);
    }
    return new DateIterator(start, end);
}","public void test04854() throws Throwable {
    DateUtils dateUtils0 = new DateUtils();
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(dateUtils0.UTC_TIME_ZONE);
    // Undeclared exception!
    try {
        DateUtils.iterator((Calendar) mockGregorianCalendar0, 1001);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The range style 1001 is not valid.
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>This constructs an <code>Iterator</code> over each day in a date
 * range defined by a focus date and range style.</p>
 *
 * <p>For instance, passing Thursday, July 4, 2002 and a
 * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>
 * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,
 * 2002, returning a Calendar instance for each intermediate day.</p>
 *
 * <p>This method provides an iterator that returns Calendar objects.
 * The days are progressed using {@link Calendar#add(int, int)}.</p>
 *
 * @param focus  the date to work with
 * @param rangeStyle  the style constant to use. Must be one of
 * {@link DateUtils#RANGE_MONTH_SUNDAY},
 * {@link DateUtils#RANGE_MONTH_MONDAY},
 * {@link DateUtils#RANGE_WEEK_SUNDAY},
 * {@link DateUtils#RANGE_WEEK_MONDAY},
 * {@link DateUtils#RANGE_WEEK_RELATIVE},
 * {@link DateUtils#RANGE_WEEK_CENTER}
 * @return the date iterator
 * @throws IllegalArgumentException if the date is <code>null</code>
 * @throws IllegalArgumentException if the rangeStyle is invalid
 */"
"public static boolean truncatedEquals(Date date1, Date date2, int field) {
    return truncatedCompareTo(date1, date2, field) == 0;
}","public void test04955() throws Throwable {
    MockDate mockDate0 = new MockDate(1448L);
    boolean boolean0 = DateUtils.truncatedEquals((Date) mockDate0, (Date) mockDate0, 9);
    assertTrue(boolean0);
}","/**
 * Determines if two dates are equal up to no more than the specified
 * most significant field.
 *
 * @param date1 the first date, not <code>null</code>
 * @param date2 the second date, not <code>null</code>
 * @param field the field from <code>Calendar</code>
 * @return <code>true</code> if equal; otherwise <code>false</code>
 * @throws IllegalArgumentException if any argument is <code>null</code>
 * @see #truncate(Date, int)
 * @see #truncatedEquals(Calendar, Calendar, int)
 * @since 3.0
 */"
"public static Calendar truncate(Calendar date, int field) {
    if (date == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    Calendar truncated = (Calendar) date.clone();
    modify(truncated, field, MODIFY_TRUNCATE);
    return truncated;
}","public void test05056() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.truncate((Calendar) null, 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Truncate this date, leaving the field specified as the most
 * significant field.</p>
 *
 * <p>For example, if you had the datetime of 28 Mar 2002
 * 13:45:01.231, if you passed with HOUR, it would return 28 Mar
 * 2002 13:00:00.000.  If this was passed with MONTH, it would
 * return 1 Mar 2002 0:00:00.000.</p>
 *
 * @param date  the date to work with
 * @param field  the field from <code>Calendar</code>
 *  or <code>SEMI_MONTH</code>
 * @return the rounded date (a different object)
 * @throws IllegalArgumentException if the date is <code>null</code>
 * @throws ArithmeticException if the year is over 280 million
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Truncate this date, leaving the field specified as the most
 * significant field.</p>
 *
 * <p>For example, if you had the datetime of 28 Mar 2002
 * 13:45:01.231, if you passed with HOUR, it would return 28 Mar
 * 2002 13:00:00.000.  If this was passed with MONTH, it would
 * return 1 Mar 2002 0:00:00.000.</p>
 *
 * @param date  the date to work with
 * @param field  the field from <code>Calendar</code>
 *  or <code>SEMI_MONTH</code>
 * @return the rounded date
 * @throws IllegalArgumentException if the date is <code>null</code>
 * @throws ArithmeticException if the year is over 280 million
 */
public static Date truncate(Date date, int field) {
    if (date == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    Calendar gval = Calendar.getInstance();
    gval.setTime(date);
    modify(gval, field, MODIFY_TRUNCATE);
    return gval.getTime();
}","public void test05258() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.truncate((Date) null, 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"public static boolean isSameDay(Calendar cal1, Calendar cal2) {
    if (cal1 == null || cal2 == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));
}","public void test05359() throws Throwable {
    Calendar calendar0 = MockCalendar.getInstance();
    boolean boolean0 = DateUtils.isSameDay(calendar0, calendar0);
    assertTrue(boolean0);
}","/**
 * <p>Checks if two calendar objects are on the same day ignoring time.</p>
 *
 * <p>28 Mar 2002 13:45 and 28 Mar 2002 06:01 would return true.
 * 28 Mar 2002 13:45 and 12 Mar 2002 13:45 would return false.
 * </p>
 *
 * @param cal1  the first calendar, not altered, not null
 * @param cal2  the second calendar, not altered, not null
 * @return true if they represent the same day
 * @throws IllegalArgumentException if either calendar is <code>null</code>
 * @since 2.1
 */"
"public static int truncatedCompareTo(Calendar cal1, Calendar cal2, int field) {
    Calendar truncatedCal1 = truncate(cal1, field);
    Calendar truncatedCal2 = truncate(cal2, field);
    return truncatedCal1.compareTo(truncatedCal2);
}","public void test05460() throws Throwable {
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(280000000, 1, 1, 1, (-1));
    int int0 = DateUtils.truncatedCompareTo((Calendar) mockGregorianCalendar0, (Calendar) mockGregorianCalendar0, 5);
    assertEquals(0, int0);
}","/**
 * Determines how two calendars compare up to no more than the specified
 * most significant field.
 *
 * @param cal1 the first calendar, not <code>null</code>
 * @param cal2 the second calendar, not <code>null</code>
 * @param field the field from <code>Calendar</code>
 * @return a negative integer, zero, or a positive integer as the first
 * calendar is less than, equal to, or greater than the second.
 * @throws IllegalArgumentException if any argument is <code>null</code>
 * @see #truncate(Calendar, int)
 * @see #truncatedCompareTo(Date, Date, int)
 * @since 3.0
 */"
"public static int truncatedCompareTo(Date date1, Date date2, int field) {
    Date truncatedDate1 = truncate(date1, field);
    Date truncatedDate2 = truncate(date2, field);
    return truncatedDate1.compareTo(truncatedDate2);
}","public void test05561() throws Throwable {
    MockDate mockDate0 = new MockDate((-1756), 2482, 1, 1891, 1);
    int int0 = DateUtils.truncatedCompareTo((Date) mockDate0, (Date) mockDate0, 1);
    assertEquals(0, int0);
}","/**
 * Determines how two dates compare up to no more than the specified
 * most significant field.
 *
 * @param date1 the first date, not <code>null</code>
 * @param date2 the second date, not <code>null</code>
 * @param field the field from <code>Calendar</code>
 * @return a negative integer, zero, or a positive integer as the first
 * date is less than, equal to, or greater than the second.
 * @throws IllegalArgumentException if any argument is <code>null</code>
 * @see #truncate(Calendar, int)
 * @see #truncatedCompareTo(Date, Date, int)
 * @since 3.0
 */"
"public static boolean truncatedEquals(Date date1, Date date2, int field) {
    return truncatedCompareTo(date1, date2, field) == 0;
}","public void test05865() throws Throwable {
    MockDate mockDate0 = new MockDate(0, 1, 1, (-1), 1001);
    Date date0 = DateUtils.ceiling((Date) mockDate0, 2);
    boolean boolean0 = DateUtils.truncatedEquals(date0, (Date) mockDate0, 5);
    assertFalse(boolean0);
}","/**
 * Determines if two dates are equal up to no more than the specified
 * most significant field.
 *
 * @param date1 the first date, not <code>null</code>
 * @param date2 the second date, not <code>null</code>
 * @param field the field from <code>Calendar</code>
 * @return <code>true</code> if equal; otherwise <code>false</code>
 * @throws IllegalArgumentException if any argument is <code>null</code>
 * @see #truncate(Date, int)
 * @see #truncatedEquals(Calendar, Calendar, int)
 * @since 3.0
 */"
"public static boolean truncatedEquals(Calendar cal1, Calendar cal2, int field) {
    return truncatedCompareTo(cal1, cal2, field) == 0;
}","public void test05967() throws Throwable {
    Calendar calendar0 = MockCalendar.getInstance();
    boolean boolean0 = DateUtils.truncatedEquals(calendar0, calendar0, 0);
    assertTrue(boolean0);
}","/**
 * Determines if two calendars are equal up to no more than the specified
 * most significant field.
 *
 * @param cal1 the first calendar, not <code>null</code>
 * @param cal2 the second calendar, not <code>null</code>
 * @param field the field from <code>Calendar</code>
 * @return <code>true</code> if equal; otherwise <code>false</code>
 * @throws IllegalArgumentException if any argument is <code>null</code>
 * @see #truncate(Calendar, int)
 * @see #truncatedEquals(Date, Date, int)
 * @since 3.0
 */"
"public static boolean truncatedEquals(Calendar cal1, Calendar cal2, int field) {
    return truncatedCompareTo(cal1, cal2, field) == 0;
}","public void test06068() throws Throwable {
    Locale locale0 = new Locale("""", """");
    Calendar calendar0 = MockCalendar.getInstance(locale0);
    Calendar calendar1 = DateUtils.ceiling(calendar0, 0);
    boolean boolean0 = DateUtils.truncatedEquals(calendar1, calendar0, 14);
    assertFalse(boolean0);
}","/**
 * Determines if two calendars are equal up to no more than the specified
 * most significant field.
 *
 * @param cal1 the first calendar, not <code>null</code>
 * @param cal2 the second calendar, not <code>null</code>
 * @param field the field from <code>Calendar</code>
 * @return <code>true</code> if equal; otherwise <code>false</code>
 * @throws IllegalArgumentException if any argument is <code>null</code>
 * @see #truncate(Calendar, int)
 * @see #truncatedEquals(Date, Date, int)
 * @since 3.0
 */"
"public static long getFragmentInMilliseconds(Calendar calendar, int fragment) {
    return getFragment(calendar, fragment, Calendar.MILLISECOND);
}","public void test06170() throws Throwable {
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar();
    long long0 = DateUtils.getFragmentInMilliseconds((Calendar) mockGregorianCalendar0, 14);
    assertEquals(0L, long0);
}","/**
 * <p>Returns the number of milliseconds within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the milliseconds of any date will only return the number of milliseconds
 * of the current second (resulting in a number between 0 and 999). This
 * method will retrieve the number of milliseconds for any fragment.
 * For example, if you want to calculate the number of seconds past today,
 * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will
 * be all seconds of the past hour(s), minutes(s) and second(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a MILLISECOND field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538
 *   (equivalent to calendar.get(Calendar.MILLISECOND))</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538
 *   (equivalent to calendar.get(Calendar.MILLISECOND))</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10538
 *   (10*1000 + 538)</li>
 *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in milliseconds)</li>
 * </ul>
 * </p>
 *
 * @param calendar the calendar to work with, not null
 * @param fragment the Calendar field part of calendar to calculate
 * @return number of milliseconds within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"public static long getFragmentInDays(Calendar calendar, int fragment) {
    return getFragment(calendar, fragment, Calendar.DAY_OF_YEAR);
}","public void test06271() throws Throwable {
    DateUtils dateUtils0 = new DateUtils();
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(dateUtils0.UTC_TIME_ZONE);
    long long0 = DateUtils.getFragmentInDays((Calendar) mockGregorianCalendar0, 13);
    assertEquals(0L, long0);
}","/**
 * <p>Returns the number of days within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the days of any date will only return the number of days
 * of the current month (resulting in a number between 1 and 31). This
 * method will retrieve the number of days for any fragment.
 * For example, if you want to calculate the number of days past this year,
 * your fragment is Calendar.YEAR. The result will be all days of the
 * past month(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a DAY field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 28, 2008 with Calendar.MONTH as fragment will return 28
 *   (equivalent to calendar.get(Calendar.DAY_OF_MONTH))</li>
 *  <li>February 28, 2008 with Calendar.MONTH as fragment will return 28
 *   (equivalent to calendar.get(Calendar.DAY_OF_MONTH))</li>
 *  <li>January 28, 2008 with Calendar.YEAR as fragment will return 28
 *   (equivalent to calendar.get(Calendar.DAY_OF_YEAR))</li>
 *  <li>February 28, 2008 with Calendar.YEAR as fragment will return 59
 *   (equivalent to calendar.get(Calendar.DAY_OF_YEAR))</li>
 *  <li>January 28, 2008 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in days)</li>
 * </ul>
 * </p>
 *
 * @param calendar the calendar to work with, not null
 * @param fragment the Calendar field part of calendar to calculate
 * @return number of days within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"public static long getFragmentInMinutes(Date date, int fragment) {
    return getFragment(date, fragment, Calendar.MINUTE);
}","public void test06372() throws Throwable {
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 0, 0);
    Date date0 = mockGregorianCalendar0.getGregorianChange();
    long long0 = DateUtils.getFragmentInMinutes(date0, 12);
    assertEquals(0L, long0);
}","/**
 * <p>Returns the number of minutes within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the minutes of any date will only return the number of minutes
 * of the current hour (resulting in a number between 0 and 59). This
 * method will retrieve the number of minutes for any fragment.
 * For example, if you want to calculate the number of minutes past this month,
 * your fragment is Calendar.MONTH. The result will be all minutes of the
 * past day(s) and hour(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a MINUTE field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15
 *   (equivalent to deprecated date.getMinutes())</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15
 *   (equivalent to deprecated date.getMinutes())</li>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 15</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 435 (7*60 + 15)</li>
 *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in minutes)</li>
 * </ul>
 * </p>
 *
 * @param date the date to work with, not null
 * @param fragment the Calendar field part of date to calculate
 * @return number of minutes within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"public static long getFragmentInMilliseconds(Date date, int fragment) {
    return getFragment(date, fragment, Calendar.MILLISECOND);
}","public void test06473() throws Throwable {
    MockDate mockDate0 = new MockDate(10, 10, 10, 10, 10);
    // Undeclared exception!
    try {
        DateUtils.getFragmentInMilliseconds((Date) mockDate0, 10);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The fragment 10 is not supported
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Returns the number of milliseconds within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the milliseconds of any date will only return the number of milliseconds
 * of the current second (resulting in a number between 0 and 999). This
 * method will retrieve the number of milliseconds for any fragment.
 * For example, if you want to calculate the number of milliseconds past today,
 * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will
 * be all milliseconds of the past hour(s), minutes(s) and second(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a SECOND field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10538 (10*1000 + 538)</li>
 *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in milliseconds)</li>
 * </ul>
 * </p>
 *
 * @param date the date to work with, not null
 * @param fragment the Calendar field part of date to calculate
 * @return number of milliseconds within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"public static long getFragmentInSeconds(Calendar calendar, int fragment) {
    return getFragment(calendar, fragment, Calendar.SECOND);
}","public void test06574() throws Throwable {
    Calendar calendar0 = MockCalendar.getInstance();
    // Undeclared exception!
    try {
        DateUtils.getFragmentInSeconds(calendar0, 9);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The fragment 9 is not supported
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Returns the number of seconds within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the seconds of any date will only return the number of seconds
 * of the current minute (resulting in a number between 0 and 59). This
 * method will retrieve the number of seconds for any fragment.
 * For example, if you want to calculate the number of seconds past today,
 * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will
 * be all seconds of the past hour(s) and minutes(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a SECOND field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10
 *   (equivalent to calendar.get(Calendar.SECOND))</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10
 *   (equivalent to calendar.get(Calendar.SECOND))</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 26110
 *   (7*3600 + 15*60 + 10)</li>
 *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in seconds)</li>
 * </ul>
 * </p>
 *
 * @param calendar the calendar to work with, not null
 * @param fragment the Calendar field part of calendar to calculate
 * @return number of seconds within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"public static long getFragmentInHours(Date date, int fragment) {
    return getFragment(date, fragment, Calendar.HOUR_OF_DAY);
}","public void test06675() throws Throwable {
    MockDate mockDate0 = new MockDate();
    long long0 = DateUtils.getFragmentInHours((Date) mockDate0, 5);
    assertEquals(20L, long0);
}","/**
 * <p>Returns the number of hours within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the hours of any date will only return the number of hours
 * of the current day (resulting in a number between 0 and 23). This
 * method will retrieve the number of hours for any fragment.
 * For example, if you want to calculate the number of hours past this month,
 * your fragment is Calendar.MONTH. The result will be all hours of the
 * past day(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a HOUR field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7
 *   (equivalent to deprecated date.getHours())</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7
 *   (equivalent to deprecated date.getHours())</li>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 7</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 127 (5*24 + 7)</li>
 *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in hours)</li>
 * </ul>
 * </p>
 *
 * @param date the date to work with, not null
 * @param fragment the Calendar field part of date to calculate
 * @return number of hours within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"public static long getFragmentInMilliseconds(Calendar calendar, int fragment) {
    return getFragment(calendar, fragment, Calendar.MILLISECOND);
}","public void test06776() throws Throwable {
    DateUtils dateUtils0 = new DateUtils();
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(dateUtils0.UTC_TIME_ZONE);
    // Undeclared exception!
    try {
        DateUtils.getFragmentInMilliseconds((Calendar) mockGregorianCalendar0, 4);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The fragment 4 is not supported
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Returns the number of milliseconds within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the milliseconds of any date will only return the number of milliseconds
 * of the current second (resulting in a number between 0 and 999). This
 * method will retrieve the number of milliseconds for any fragment.
 * For example, if you want to calculate the number of seconds past today,
 * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will
 * be all seconds of the past hour(s), minutes(s) and second(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a MILLISECOND field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538
 *   (equivalent to calendar.get(Calendar.MILLISECOND))</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538
 *   (equivalent to calendar.get(Calendar.MILLISECOND))</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10538
 *   (10*1000 + 538)</li>
 *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in milliseconds)</li>
 * </ul>
 * </p>
 *
 * @param calendar the calendar to work with, not null
 * @param fragment the Calendar field part of calendar to calculate
 * @return number of milliseconds within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"public static long getFragmentInSeconds(Date date, int fragment) {
    return getFragment(date, fragment, Calendar.SECOND);
}","public void test06877() throws Throwable {
    MockDate mockDate0 = new MockDate(403L);
    // Undeclared exception!
    try {
        DateUtils.getFragmentInSeconds((Date) mockDate0, 3);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The fragment 3 is not supported
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Returns the number of seconds within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the seconds of any date will only return the number of seconds
 * of the current minute (resulting in a number between 0 and 59). This
 * method will retrieve the number of seconds for any fragment.
 * For example, if you want to calculate the number of seconds past today,
 * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will
 * be all seconds of the past hour(s) and minutes(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a SECOND field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10
 *   (equivalent to deprecated date.getSeconds())</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10
 *   (equivalent to deprecated date.getSeconds())</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 26110
 *   (7*3600 + 15*60 + 10)</li>
 *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in seconds)</li>
 * </ul>
 * </p>
 *
 * @param date the date to work with, not null
 * @param fragment the Calendar field part of date to calculate
 * @return number of seconds within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"public static long getFragmentInMinutes(Calendar calendar, int fragment) {
    return getFragment(calendar, fragment, Calendar.MINUTE);
}","public void test06978() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.getFragmentInMinutes((Calendar) null, 1229);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Returns the number of minutes within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the minutes of any date will only return the number of minutes
 * of the current hour (resulting in a number between 0 and 59). This
 * method will retrieve the number of minutes for any fragment.
 * For example, if you want to calculate the number of minutes past this month,
 * your fragment is Calendar.MONTH. The result will be all minutes of the
 * past day(s) and hour(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a MINUTE field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15
 *   (equivalent to calendar.get(Calendar.MINUTES))</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15
 *   (equivalent to calendar.get(Calendar.MINUTES))</li>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 15</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 435 (7*60 + 15)</li>
 *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in minutes)</li>
 * </ul>
 * </p>
 *
 * @param calendar the calendar to work with, not null
 * @param fragment the Calendar field part of calendar to calculate
 * @return number of minutes within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"public static long getFragmentInHours(Date date, int fragment) {
    return getFragment(date, fragment, Calendar.HOUR_OF_DAY);
}","public void test07079() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.getFragmentInHours((Date) null, (-1166));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Returns the number of hours within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the hours of any date will only return the number of hours
 * of the current day (resulting in a number between 0 and 23). This
 * method will retrieve the number of hours for any fragment.
 * For example, if you want to calculate the number of hours past this month,
 * your fragment is Calendar.MONTH. The result will be all hours of the
 * past day(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a HOUR field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7
 *   (equivalent to deprecated date.getHours())</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7
 *   (equivalent to deprecated date.getHours())</li>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 7</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 127 (5*24 + 7)</li>
 *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in hours)</li>
 * </ul>
 * </p>
 *
 * @param date the date to work with, not null
 * @param fragment the Calendar field part of date to calculate
 * @return number of hours within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"public static Iterator<?> iterator(Object focus, int rangeStyle) {
    if (focus == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    if (focus instanceof Date) {
        return iterator((Date) focus, rangeStyle);
    } else if (focus instanceof Calendar) {
        return iterator((Calendar) focus, rangeStyle);
    } else {
        throw new ClassCastException(""Could not iterate based on "" + focus);
    }
}","public void test07180() throws Throwable {
    Object object0 = new Object();
    // Undeclared exception!
    try {
        DateUtils.iterator(object0, 0);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // Could not iterate based on java.lang.Object@3659b77
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>This constructs an <code>Iterator</code> over each day in a date
 * range defined by a focus date and range style.</p>
 *
 * <p>For instance, passing Thursday, July 4, 2002 and a
 * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>
 * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,
 * 2002, returning a Calendar instance for each intermediate day.</p>
 *
 * @param focus  the date to work with, either
 *  <code>Date</code> or <code>Calendar</code>
 * @param rangeStyle  the style constant to use. Must be one of the range
 * styles listed for the {@link #iterator(Calendar, int)} method.
 * @return the date iterator
 * @throws IllegalArgumentException if the date
 *  is <code>null</code>
 * @throws ClassCastException if the object type is
 *  not a <code>Date</code> or <code>Calendar</code>
 */"
"public static Iterator<?> iterator(Object focus, int rangeStyle) {
    if (focus == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    if (focus instanceof Date) {
        return iterator((Date) focus, rangeStyle);
    } else if (focus instanceof Calendar) {
        return iterator((Calendar) focus, rangeStyle);
    } else {
        throw new ClassCastException(""Could not iterate based on "" + focus);
    }
}","public void test07281() throws Throwable {
    MockDate mockDate0 = new MockDate();
    // Undeclared exception!
    try {
        DateUtils.iterator((Object) mockDate0, 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The range style 0 is not valid.
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>This constructs an <code>Iterator</code> over each day in a date
 * range defined by a focus date and range style.</p>
 *
 * <p>For instance, passing Thursday, July 4, 2002 and a
 * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>
 * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,
 * 2002, returning a Calendar instance for each intermediate day.</p>
 *
 * @param focus  the date to work with, either
 *  <code>Date</code> or <code>Calendar</code>
 * @param rangeStyle  the style constant to use. Must be one of the range
 * styles listed for the {@link #iterator(Calendar, int)} method.
 * @return the date iterator
 * @throws IllegalArgumentException if the date
 *  is <code>null</code>
 * @throws ClassCastException if the object type is
 *  not a <code>Date</code> or <code>Calendar</code>
 */"
"public static Iterator<?> iterator(Object focus, int rangeStyle) {
    if (focus == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    if (focus instanceof Date) {
        return iterator((Date) focus, rangeStyle);
    } else if (focus instanceof Calendar) {
        return iterator((Calendar) focus, rangeStyle);
    } else {
        throw new ClassCastException(""Could not iterate based on "" + focus);
    }
}","public void test07382() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.iterator((Object) null, (-4149));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>This constructs an <code>Iterator</code> over each day in a date
 * range defined by a focus date and range style.</p>
 *
 * <p>For instance, passing Thursday, July 4, 2002 and a
 * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>
 * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,
 * 2002, returning a Calendar instance for each intermediate day.</p>
 *
 * @param focus  the date to work with, either
 *  <code>Date</code> or <code>Calendar</code>
 * @param rangeStyle  the style constant to use. Must be one of the range
 * styles listed for the {@link #iterator(Calendar, int)} method.
 * @return the date iterator
 * @throws IllegalArgumentException if the date
 *  is <code>null</code>
 * @throws ClassCastException if the object type is
 *  not a <code>Date</code> or <code>Calendar</code>
 */"
"public static Iterator<?> iterator(Object focus, int rangeStyle) {
    if (focus == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    if (focus instanceof Date) {
        return iterator((Date) focus, rangeStyle);
    } else if (focus instanceof Calendar) {
        return iterator((Calendar) focus, rangeStyle);
    } else {
        throw new ClassCastException(""Could not iterate based on "" + focus);
    }
}","public void test07483() throws Throwable {
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 0, 0);
    // Undeclared exception!
    try {
        DateUtils.iterator((Object) mockGregorianCalendar0, 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The range style 0 is not valid.
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>This constructs an <code>Iterator</code> over each day in a date
 * range defined by a focus date and range style.</p>
 *
 * <p>For instance, passing Thursday, July 4, 2002 and a
 * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>
 * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,
 * 2002, returning a Calendar instance for each intermediate day.</p>
 *
 * @param focus  the date to work with, either
 *  <code>Date</code> or <code>Calendar</code>
 * @param rangeStyle  the style constant to use. Must be one of the range
 * styles listed for the {@link #iterator(Calendar, int)} method.
 * @return the date iterator
 * @throws IllegalArgumentException if the date
 *  is <code>null</code>
 * @throws ClassCastException if the object type is
 *  not a <code>Date</code> or <code>Calendar</code>
 */"
"//-----------------------------------------------------------------------
/**
 * <p>This constructs an <code>Iterator</code> over each day in a date
 * range defined by a focus date and range style.</p>
 *
 * <p>For instance, passing Thursday, July 4, 2002 and a
 * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>
 * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,
 * 2002, returning a Calendar instance for each intermediate day.</p>
 *
 * <p>This method provides an iterator that returns Calendar objects.
 * The days are progressed using {@link Calendar#add(int, int)}.</p>
 *
 * @param focus  the date to work with, not null
 * @param rangeStyle  the style constant to use. Must be one of
 * {@link DateUtils#RANGE_MONTH_SUNDAY},
 * {@link DateUtils#RANGE_MONTH_MONDAY},
 * {@link DateUtils#RANGE_WEEK_SUNDAY},
 * {@link DateUtils#RANGE_WEEK_MONDAY},
 * {@link DateUtils#RANGE_WEEK_RELATIVE},
 * {@link DateUtils#RANGE_WEEK_CENTER}
 * @return the date iterator, which always returns Calendar instances
 * @throws IllegalArgumentException if the date is <code>null</code>
 * @throws IllegalArgumentException if the rangeStyle is invalid
 */
public static Iterator<Calendar> iterator(Date focus, int rangeStyle) {
    if (focus == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    Calendar gval = Calendar.getInstance();
    gval.setTime(focus);
    return iterator(gval, rangeStyle);
}","public void test07584() throws Throwable {
    MockDate mockDate0 = new MockDate(0, 0, 0);
    Iterator<Calendar> iterator0 = DateUtils.iterator((Date) mockDate0, 4);
    assertNotNull(iterator0);
}",""
"//-----------------------------------------------------------------------
/**
 * <p>This constructs an <code>Iterator</code> over each day in a date
 * range defined by a focus date and range style.</p>
 *
 * <p>For instance, passing Thursday, July 4, 2002 and a
 * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>
 * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,
 * 2002, returning a Calendar instance for each intermediate day.</p>
 *
 * <p>This method provides an iterator that returns Calendar objects.
 * The days are progressed using {@link Calendar#add(int, int)}.</p>
 *
 * @param focus  the date to work with, not null
 * @param rangeStyle  the style constant to use. Must be one of
 * {@link DateUtils#RANGE_MONTH_SUNDAY},
 * {@link DateUtils#RANGE_MONTH_MONDAY},
 * {@link DateUtils#RANGE_WEEK_SUNDAY},
 * {@link DateUtils#RANGE_WEEK_MONDAY},
 * {@link DateUtils#RANGE_WEEK_RELATIVE},
 * {@link DateUtils#RANGE_WEEK_CENTER}
 * @return the date iterator, which always returns Calendar instances
 * @throws IllegalArgumentException if the date is <code>null</code>
 * @throws IllegalArgumentException if the rangeStyle is invalid
 */
public static Iterator<Calendar> iterator(Date focus, int rangeStyle) {
    if (focus == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    Calendar gval = Calendar.getInstance();
    gval.setTime(focus);
    return iterator(gval, rangeStyle);
}","public void test07786() throws Throwable {
    MockDate mockDate0 = new MockDate();
    Iterator<Calendar> iterator0 = DateUtils.iterator((Date) mockDate0, 4);
    assertNotNull(iterator0);
}",""
"//-----------------------------------------------------------------------
/**
 * <p>This constructs an <code>Iterator</code> over each day in a date
 * range defined by a focus date and range style.</p>
 *
 * <p>For instance, passing Thursday, July 4, 2002 and a
 * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>
 * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,
 * 2002, returning a Calendar instance for each intermediate day.</p>
 *
 * <p>This method provides an iterator that returns Calendar objects.
 * The days are progressed using {@link Calendar#add(int, int)}.</p>
 *
 * @param focus  the date to work with, not null
 * @param rangeStyle  the style constant to use. Must be one of
 * {@link DateUtils#RANGE_MONTH_SUNDAY},
 * {@link DateUtils#RANGE_MONTH_MONDAY},
 * {@link DateUtils#RANGE_WEEK_SUNDAY},
 * {@link DateUtils#RANGE_WEEK_MONDAY},
 * {@link DateUtils#RANGE_WEEK_RELATIVE},
 * {@link DateUtils#RANGE_WEEK_CENTER}
 * @return the date iterator, which always returns Calendar instances
 * @throws IllegalArgumentException if the date is <code>null</code>
 * @throws IllegalArgumentException if the rangeStyle is invalid
 */
public static Iterator<Calendar> iterator(Date focus, int rangeStyle) {
    if (focus == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    Calendar gval = Calendar.getInstance();
    gval.setTime(focus);
    return iterator(gval, rangeStyle);
}","public void test07887() throws Throwable {
    MockDate mockDate0 = new MockDate();
    Iterator<Calendar> iterator0 = DateUtils.iterator((Date) mockDate0, 3);
    assertNotNull(iterator0);
}",""
"public static Iterator<Calendar> iterator(Calendar focus, int rangeStyle) {
    if (focus == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    Calendar start = null;
    Calendar end = null;
    int startCutoff = Calendar.SUNDAY;
    int endCutoff = Calendar.SATURDAY;
    switch(rangeStyle) {
        case RANGE_MONTH_SUNDAY:
        case RANGE_MONTH_MONDAY:
            //Set start to the first of the month
            start = truncate(focus, Calendar.MONTH);
            //Set end to the last of the month
            end = (Calendar) start.clone();
            end.add(Calendar.MONTH, 1);
            end.add(Calendar.DATE, -1);
            //Loop start back to the previous sunday or monday
            if (rangeStyle == RANGE_MONTH_MONDAY) {
                startCutoff = Calendar.MONDAY;
                endCutoff = Calendar.SUNDAY;
            }
            break;
        case RANGE_WEEK_SUNDAY:
        case RANGE_WEEK_MONDAY:
        case RANGE_WEEK_RELATIVE:
        case RANGE_WEEK_CENTER:
            //Set start and end to the current date
            start = truncate(focus, Calendar.DATE);
            end = truncate(focus, Calendar.DATE);
            switch(rangeStyle) {
                case RANGE_WEEK_SUNDAY:
                    //already set by default
                    break;
                case RANGE_WEEK_MONDAY:
                    startCutoff = Calendar.MONDAY;
                    endCutoff = Calendar.SUNDAY;
                    break;
                case RANGE_WEEK_RELATIVE:
                    startCutoff = focus.get(Calendar.DAY_OF_WEEK);
                    endCutoff = startCutoff - 1;
                    break;
                case RANGE_WEEK_CENTER:
                    startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3;
                    endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3;
                    break;
            }
            break;
        default:
            throw new IllegalArgumentException(""The range style "" + rangeStyle + "" is not valid."");
    }
    if (startCutoff < Calendar.SUNDAY) {
        startCutoff += 7;
    }
    if (startCutoff > Calendar.SATURDAY) {
        startCutoff -= 7;
    }
    if (endCutoff < Calendar.SUNDAY) {
        endCutoff += 7;
    }
    if (endCutoff > Calendar.SATURDAY) {
        endCutoff -= 7;
    }
    while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) {
        start.add(Calendar.DATE, -1);
    }
    while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) {
        end.add(Calendar.DATE, 1);
    }
    return new DateIterator(start, end);
}","public void test08089() throws Throwable {
    ZoneInfo zoneInfo0 = (ZoneInfo) DateUtils.UTC_TIME_ZONE;
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(zoneInfo0);
    Iterator<Calendar> iterator0 = DateUtils.iterator((Calendar) mockGregorianCalendar0, 1);
    assertNotNull(iterator0);
}","/**
 * <p>This constructs an <code>Iterator</code> over each day in a date
 * range defined by a focus date and range style.</p>
 *
 * <p>For instance, passing Thursday, July 4, 2002 and a
 * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>
 * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,
 * 2002, returning a Calendar instance for each intermediate day.</p>
 *
 * <p>This method provides an iterator that returns Calendar objects.
 * The days are progressed using {@link Calendar#add(int, int)}.</p>
 *
 * @param focus  the date to work with
 * @param rangeStyle  the style constant to use. Must be one of
 * {@link DateUtils#RANGE_MONTH_SUNDAY},
 * {@link DateUtils#RANGE_MONTH_MONDAY},
 * {@link DateUtils#RANGE_WEEK_SUNDAY},
 * {@link DateUtils#RANGE_WEEK_MONDAY},
 * {@link DateUtils#RANGE_WEEK_RELATIVE},
 * {@link DateUtils#RANGE_WEEK_CENTER}
 * @return the date iterator
 * @throws IllegalArgumentException if the date is <code>null</code>
 * @throws IllegalArgumentException if the rangeStyle is invalid
 */"
"public static Iterator<Calendar> iterator(Calendar focus, int rangeStyle) {
    if (focus == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    Calendar start = null;
    Calendar end = null;
    int startCutoff = Calendar.SUNDAY;
    int endCutoff = Calendar.SATURDAY;
    switch(rangeStyle) {
        case RANGE_MONTH_SUNDAY:
        case RANGE_MONTH_MONDAY:
            //Set start to the first of the month
            start = truncate(focus, Calendar.MONTH);
            //Set end to the last of the month
            end = (Calendar) start.clone();
            end.add(Calendar.MONTH, 1);
            end.add(Calendar.DATE, -1);
            //Loop start back to the previous sunday or monday
            if (rangeStyle == RANGE_MONTH_MONDAY) {
                startCutoff = Calendar.MONDAY;
                endCutoff = Calendar.SUNDAY;
            }
            break;
        case RANGE_WEEK_SUNDAY:
        case RANGE_WEEK_MONDAY:
        case RANGE_WEEK_RELATIVE:
        case RANGE_WEEK_CENTER:
            //Set start and end to the current date
            start = truncate(focus, Calendar.DATE);
            end = truncate(focus, Calendar.DATE);
            switch(rangeStyle) {
                case RANGE_WEEK_SUNDAY:
                    //already set by default
                    break;
                case RANGE_WEEK_MONDAY:
                    startCutoff = Calendar.MONDAY;
                    endCutoff = Calendar.SUNDAY;
                    break;
                case RANGE_WEEK_RELATIVE:
                    startCutoff = focus.get(Calendar.DAY_OF_WEEK);
                    endCutoff = startCutoff - 1;
                    break;
                case RANGE_WEEK_CENTER:
                    startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3;
                    endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3;
                    break;
            }
            break;
        default:
            throw new IllegalArgumentException(""The range style "" + rangeStyle + "" is not valid."");
    }
    if (startCutoff < Calendar.SUNDAY) {
        startCutoff += 7;
    }
    if (startCutoff > Calendar.SATURDAY) {
        startCutoff -= 7;
    }
    if (endCutoff < Calendar.SUNDAY) {
        endCutoff += 7;
    }
    if (endCutoff > Calendar.SATURDAY) {
        endCutoff -= 7;
    }
    while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) {
        start.add(Calendar.DATE, -1);
    }
    while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) {
        end.add(Calendar.DATE, 1);
    }
    return new DateIterator(start, end);
}","public void test08190() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.iterator((Calendar) null, 12);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>This constructs an <code>Iterator</code> over each day in a date
 * range defined by a focus date and range style.</p>
 *
 * <p>For instance, passing Thursday, July 4, 2002 and a
 * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>
 * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,
 * 2002, returning a Calendar instance for each intermediate day.</p>
 *
 * <p>This method provides an iterator that returns Calendar objects.
 * The days are progressed using {@link Calendar#add(int, int)}.</p>
 *
 * @param focus  the date to work with
 * @param rangeStyle  the style constant to use. Must be one of
 * {@link DateUtils#RANGE_MONTH_SUNDAY},
 * {@link DateUtils#RANGE_MONTH_MONDAY},
 * {@link DateUtils#RANGE_WEEK_SUNDAY},
 * {@link DateUtils#RANGE_WEEK_MONDAY},
 * {@link DateUtils#RANGE_WEEK_RELATIVE},
 * {@link DateUtils#RANGE_WEEK_CENTER}
 * @return the date iterator
 * @throws IllegalArgumentException if the date is <code>null</code>
 * @throws IllegalArgumentException if the rangeStyle is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * <p>This constructs an <code>Iterator</code> over each day in a date
 * range defined by a focus date and range style.</p>
 *
 * <p>For instance, passing Thursday, July 4, 2002 and a
 * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>
 * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,
 * 2002, returning a Calendar instance for each intermediate day.</p>
 *
 * <p>This method provides an iterator that returns Calendar objects.
 * The days are progressed using {@link Calendar#add(int, int)}.</p>
 *
 * @param focus  the date to work with, not null
 * @param rangeStyle  the style constant to use. Must be one of
 * {@link DateUtils#RANGE_MONTH_SUNDAY},
 * {@link DateUtils#RANGE_MONTH_MONDAY},
 * {@link DateUtils#RANGE_WEEK_SUNDAY},
 * {@link DateUtils#RANGE_WEEK_MONDAY},
 * {@link DateUtils#RANGE_WEEK_RELATIVE},
 * {@link DateUtils#RANGE_WEEK_CENTER}
 * @return the date iterator, which always returns Calendar instances
 * @throws IllegalArgumentException if the date is <code>null</code>
 * @throws IllegalArgumentException if the rangeStyle is invalid
 */
public static Iterator<Calendar> iterator(Date focus, int rangeStyle) {
    if (focus == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    Calendar gval = Calendar.getInstance();
    gval.setTime(focus);
    return iterator(gval, rangeStyle);
}","public void test08291() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.iterator((Date) null, 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Ceil this date, leaving the field specified as the most
 * significant field.</p>
 *
 * <p>For example, if you had the datetime of 28 Mar 2002
 * 13:45:01.231, if you passed with HOUR, it would return 28 Mar
 * 2002 14:00:00.000.  If this was passed with MONTH, it would
 * return 1 Apr 2002 0:00:00.000.</p>
 *
 * @param date  the date to work with
 * @param field  the field from <code>Calendar</code>
 *  or <code>SEMI_MONTH</code>
 * @return the rounded date
 * @throws IllegalArgumentException if the date is <code>null</code>
 * @throws ArithmeticException if the year is over 280 million
 * @since 2.5
 */
public static Date ceiling(Date date, int field) {
    if (date == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    Calendar gval = Calendar.getInstance();
    gval.setTime(date);
    modify(gval, field, MODIFY_CEILING);
    return gval.getTime();
}","public void test08798() throws Throwable {
    ZoneInfo zoneInfo0 = (ZoneInfo) DateUtils.UTC_TIME_ZONE;
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(zoneInfo0);
    ZonedDateTime zonedDateTime0 = mockGregorianCalendar0.toZonedDateTime();
    GregorianCalendar gregorianCalendar0 = MockGregorianCalendar.from(zonedDateTime0);
    Date date0 = gregorianCalendar0.getGregorianChange();
    // Undeclared exception!
    try {
        DateUtils.ceiling(date0, (-608));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Calendar value too large for accurate calculations
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"public static Date ceiling(Object date, int field) {
    if (date == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    if (date instanceof Date) {
        return ceiling((Date) date, field);
    } else if (date instanceof Calendar) {
        return ceiling((Calendar) date, field).getTime();
    } else {
        throw new ClassCastException(""Could not find ceiling of for type: "" + date.getClass());
    }
}","public void test08899() throws Throwable {
    Locale locale0 = Locale.GERMAN;
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(locale0);
    // Undeclared exception!
    try {
        DateUtils.ceiling((Object) mockGregorianCalendar0, 8);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The field 8 is not supported
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Ceil this date, leaving the field specified as the most
 * significant field.</p>
 *
 * <p>For example, if you had the datetime of 28 Mar 2002
 * 13:45:01.231, if you passed with HOUR, it would return 28 Mar
 * 2002 13:00:00.000.  If this was passed with MONTH, it would
 * return 1 Mar 2002 0:00:00.000.</p>
 *
 * @param date  the date to work with, either <code>Date</code>
 *  or <code>Calendar</code>
 * @param field  the field from <code>Calendar</code>
 *  or <code>SEMI_MONTH</code>
 * @return the rounded date
 * @throws IllegalArgumentException if the date
 *  is <code>null</code>
 * @throws ClassCastException if the object type is not a
 *  <code>Date</code> or <code>Calendar</code>
 * @throws ArithmeticException if the year is over 280 million
 * @since 2.5
 */"
"public static Date ceiling(Object date, int field) {
    if (date == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    if (date instanceof Date) {
        return ceiling((Date) date, field);
    } else if (date instanceof Calendar) {
        return ceiling((Calendar) date, field).getTime();
    } else {
        throw new ClassCastException(""Could not find ceiling of for type: "" + date.getClass());
    }
}","public void test089100() throws Throwable {
    Object object0 = new Object();
    // Undeclared exception!
    try {
        DateUtils.ceiling(object0, 0);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // Could not find ceiling of for type: class java.lang.Object
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Ceil this date, leaving the field specified as the most
 * significant field.</p>
 *
 * <p>For example, if you had the datetime of 28 Mar 2002
 * 13:45:01.231, if you passed with HOUR, it would return 28 Mar
 * 2002 13:00:00.000.  If this was passed with MONTH, it would
 * return 1 Mar 2002 0:00:00.000.</p>
 *
 * @param date  the date to work with, either <code>Date</code>
 *  or <code>Calendar</code>
 * @param field  the field from <code>Calendar</code>
 *  or <code>SEMI_MONTH</code>
 * @return the rounded date
 * @throws IllegalArgumentException if the date
 *  is <code>null</code>
 * @throws ClassCastException if the object type is not a
 *  <code>Date</code> or <code>Calendar</code>
 * @throws ArithmeticException if the year is over 280 million
 * @since 2.5
 */"
"public static Date ceiling(Object date, int field) {
    if (date == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    if (date instanceof Date) {
        return ceiling((Date) date, field);
    } else if (date instanceof Calendar) {
        return ceiling((Calendar) date, field).getTime();
    } else {
        throw new ClassCastException(""Could not find ceiling of for type: "" + date.getClass());
    }
}","public void test090101() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.ceiling((Object) null, 763);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Ceil this date, leaving the field specified as the most
 * significant field.</p>
 *
 * <p>For example, if you had the datetime of 28 Mar 2002
 * 13:45:01.231, if you passed with HOUR, it would return 28 Mar
 * 2002 13:00:00.000.  If this was passed with MONTH, it would
 * return 1 Mar 2002 0:00:00.000.</p>
 *
 * @param date  the date to work with, either <code>Date</code>
 *  or <code>Calendar</code>
 * @param field  the field from <code>Calendar</code>
 *  or <code>SEMI_MONTH</code>
 * @return the rounded date
 * @throws IllegalArgumentException if the date
 *  is <code>null</code>
 * @throws ClassCastException if the object type is not a
 *  <code>Date</code> or <code>Calendar</code>
 * @throws ArithmeticException if the year is over 280 million
 * @since 2.5
 */"
"public static Calendar ceiling(Calendar date, int field) {
    if (date == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    Calendar ceiled = (Calendar) date.clone();
    modify(ceiled, field, MODIFY_CEILING);
    return ceiled;
}","public void test091102() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.ceiling((Calendar) null, 4119);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Ceil this date, leaving the field specified as the most
 * significant field.</p>
 *
 * <p>For example, if you had the datetime of 28 Mar 2002
 * 13:45:01.231, if you passed with HOUR, it would return 28 Mar
 * 2002 13:00:00.000.  If this was passed with MONTH, it would
 * return 1 Mar 2002 0:00:00.000.</p>
 *
 * @param date  the date to work with
 * @param field  the field from <code>Calendar</code>
 *  or <code>SEMI_MONTH</code>
 * @return the rounded date (a different object)
 * @throws IllegalArgumentException if the date is <code>null</code>
 * @throws ArithmeticException if the year is over 280 million
 * @since 2.5
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Ceil this date, leaving the field specified as the most
 * significant field.</p>
 *
 * <p>For example, if you had the datetime of 28 Mar 2002
 * 13:45:01.231, if you passed with HOUR, it would return 28 Mar
 * 2002 14:00:00.000.  If this was passed with MONTH, it would
 * return 1 Apr 2002 0:00:00.000.</p>
 *
 * @param date  the date to work with
 * @param field  the field from <code>Calendar</code>
 *  or <code>SEMI_MONTH</code>
 * @return the rounded date
 * @throws IllegalArgumentException if the date is <code>null</code>
 * @throws ArithmeticException if the year is over 280 million
 * @since 2.5
 */
public static Date ceiling(Date date, int field) {
    if (date == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    Calendar gval = Calendar.getInstance();
    gval.setTime(date);
    modify(gval, field, MODIFY_CEILING);
    return gval.getTime();
}","public void test092103() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.ceiling((Date) null, 723);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"public static Date truncate(Object date, int field) {
    if (date == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    if (date instanceof Date) {
        return truncate((Date) date, field);
    } else if (date instanceof Calendar) {
        return truncate((Calendar) date, field).getTime();
    } else {
        throw new ClassCastException(""Could not truncate "" + date);
    }
}","public void test093104() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.truncate((Object) ""Could not find ceiling of for type: "", 8);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // Could not truncate Could not find ceiling of for type:
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Truncate this date, leaving the field specified as the most
 * significant field.</p>
 *
 * <p>For example, if you had the datetime of 28 Mar 2002
 * 13:45:01.231, if you passed with HOUR, it would return 28 Mar
 * 2002 13:00:00.000.  If this was passed with MONTH, it would
 * return 1 Mar 2002 0:00:00.000.</p>
 *
 * @param date  the date to work with, either <code>Date</code>
 *  or <code>Calendar</code>
 * @param field  the field from <code>Calendar</code>
 *  or <code>SEMI_MONTH</code>
 * @return the rounded date
 * @throws IllegalArgumentException if the date
 *  is <code>null</code>
 * @throws ClassCastException if the object type is not a
 *  <code>Date</code> or <code>Calendar</code>
 * @throws ArithmeticException if the year is over 280 million
 */"
"public static Date truncate(Object date, int field) {
    if (date == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    if (date instanceof Date) {
        return truncate((Date) date, field);
    } else if (date instanceof Calendar) {
        return truncate((Calendar) date, field).getTime();
    } else {
        throw new ClassCastException(""Could not truncate "" + date);
    }
}","public void test094105() throws Throwable {
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(1824, 1824, 1824, 1824, 1824);
    // Undeclared exception!
    try {
        DateUtils.truncate((Object) mockGregorianCalendar0, 1824);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The field 1824 is not supported
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Truncate this date, leaving the field specified as the most
 * significant field.</p>
 *
 * <p>For example, if you had the datetime of 28 Mar 2002
 * 13:45:01.231, if you passed with HOUR, it would return 28 Mar
 * 2002 13:00:00.000.  If this was passed with MONTH, it would
 * return 1 Mar 2002 0:00:00.000.</p>
 *
 * @param date  the date to work with, either <code>Date</code>
 *  or <code>Calendar</code>
 * @param field  the field from <code>Calendar</code>
 *  or <code>SEMI_MONTH</code>
 * @return the rounded date
 * @throws IllegalArgumentException if the date
 *  is <code>null</code>
 * @throws ClassCastException if the object type is not a
 *  <code>Date</code> or <code>Calendar</code>
 * @throws ArithmeticException if the year is over 280 million
 */"
"public static Date truncate(Object date, int field) {
    if (date == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    if (date instanceof Date) {
        return truncate((Date) date, field);
    } else if (date instanceof Calendar) {
        return truncate((Calendar) date, field).getTime();
    } else {
        throw new ClassCastException(""Could not truncate "" + date);
    }
}","public void test095106() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.truncate((Object) null, 3598);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Truncate this date, leaving the field specified as the most
 * significant field.</p>
 *
 * <p>For example, if you had the datetime of 28 Mar 2002
 * 13:45:01.231, if you passed with HOUR, it would return 28 Mar
 * 2002 13:00:00.000.  If this was passed with MONTH, it would
 * return 1 Mar 2002 0:00:00.000.</p>
 *
 * @param date  the date to work with, either <code>Date</code>
 *  or <code>Calendar</code>
 * @param field  the field from <code>Calendar</code>
 *  or <code>SEMI_MONTH</code>
 * @return the rounded date
 * @throws IllegalArgumentException if the date
 *  is <code>null</code>
 * @throws ClassCastException if the object type is not a
 *  <code>Date</code> or <code>Calendar</code>
 * @throws ArithmeticException if the year is over 280 million
 */"
"public static Date truncate(Object date, int field) {
    if (date == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    if (date instanceof Date) {
        return truncate((Date) date, field);
    } else if (date instanceof Calendar) {
        return truncate((Calendar) date, field).getTime();
    } else {
        throw new ClassCastException(""Could not truncate "" + date);
    }
}","public void test096107() throws Throwable {
    MockDate mockDate0 = new MockDate(0, 0, (-1698), 0, 280000000);
    // Undeclared exception!
    try {
        DateUtils.truncate((Object) mockDate0, 30);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The field 30 is not supported
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Truncate this date, leaving the field specified as the most
 * significant field.</p>
 *
 * <p>For example, if you had the datetime of 28 Mar 2002
 * 13:45:01.231, if you passed with HOUR, it would return 28 Mar
 * 2002 13:00:00.000.  If this was passed with MONTH, it would
 * return 1 Mar 2002 0:00:00.000.</p>
 *
 * @param date  the date to work with, either <code>Date</code>
 *  or <code>Calendar</code>
 * @param field  the field from <code>Calendar</code>
 *  or <code>SEMI_MONTH</code>
 * @return the rounded date
 * @throws IllegalArgumentException if the date
 *  is <code>null</code>
 * @throws ClassCastException if the object type is not a
 *  <code>Date</code> or <code>Calendar</code>
 * @throws ArithmeticException if the year is over 280 million
 */"
"public static boolean truncatedEquals(Date date1, Date date2, int field) {
    return truncatedCompareTo(date1, date2, field) == 0;
}","public void test097108() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.truncatedEquals((Date) null, (Date) null, 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * Determines if two dates are equal up to no more than the specified
 * most significant field.
 *
 * @param date1 the first date, not <code>null</code>
 * @param date2 the second date, not <code>null</code>
 * @param field the field from <code>Calendar</code>
 * @return <code>true</code> if equal; otherwise <code>false</code>
 * @throws IllegalArgumentException if any argument is <code>null</code>
 * @see #truncate(Date, int)
 * @see #truncatedEquals(Calendar, Calendar, int)
 * @since 3.0
 */"
"public static Date round(Object date, int field) {
    if (date == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    if (date instanceof Date) {
        return round((Date) date, field);
    } else if (date instanceof Calendar) {
        return round((Calendar) date, field).getTime();
    } else {
        throw new ClassCastException(""Could not round "" + date);
    }
}","public void test098109() throws Throwable {
    Object object0 = new Object();
    // Undeclared exception!
    try {
        DateUtils.round(object0, 111);
        fail(""Expecting exception: ClassCastException"");
    } catch (ClassCastException e) {
        //
        // Could not round java.lang.Object@9249ea
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Round this date, leaving the field specified as the most
 * significant field.</p>
 *
 * <p>For example, if you had the datetime of 28 Mar 2002
 * 13:45:01.231, if this was passed with HOUR, it would return
 * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it
 * would return 1 April 2002 0:00:00.000.</p>
 *
 * <p>For a date in a timezone that handles the change to daylight
 * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.
 * Suppose daylight saving time begins at 02:00 on March 30. Rounding a
 * date that crosses this time would produce the following values:
 * <ul>
 * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>
 * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>
 * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>
 * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>
 * </ul>
 * </p>
 *
 * @param date  the date to work with, either Date or Calendar
 * @param field  the field from <code>Calendar</code>
 *  or <code>SEMI_MONTH</code>
 * @return the rounded date
 * @throws IllegalArgumentException if the date is <code>null</code>
 * @throws ClassCastException if the object type is not a <code>Date</code>
 *  or <code>Calendar</code>
 * @throws ArithmeticException if the year is over 280 million
 */"
"public static Date round(Object date, int field) {
    if (date == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    if (date instanceof Date) {
        return round((Date) date, field);
    } else if (date instanceof Calendar) {
        return round((Calendar) date, field).getTime();
    } else {
        throw new ClassCastException(""Could not round "" + date);
    }
}","public void test099110() throws Throwable {
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar();
    // Undeclared exception!
    try {
        DateUtils.round((Object) mockGregorianCalendar0, 1581);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The field 1581 is not supported
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Round this date, leaving the field specified as the most
 * significant field.</p>
 *
 * <p>For example, if you had the datetime of 28 Mar 2002
 * 13:45:01.231, if this was passed with HOUR, it would return
 * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it
 * would return 1 April 2002 0:00:00.000.</p>
 *
 * <p>For a date in a timezone that handles the change to daylight
 * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.
 * Suppose daylight saving time begins at 02:00 on March 30. Rounding a
 * date that crosses this time would produce the following values:
 * <ul>
 * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>
 * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>
 * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>
 * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>
 * </ul>
 * </p>
 *
 * @param date  the date to work with, either Date or Calendar
 * @param field  the field from <code>Calendar</code>
 *  or <code>SEMI_MONTH</code>
 * @return the rounded date
 * @throws IllegalArgumentException if the date is <code>null</code>
 * @throws ClassCastException if the object type is not a <code>Date</code>
 *  or <code>Calendar</code>
 * @throws ArithmeticException if the year is over 280 million
 */"
"public static Date round(Object date, int field) {
    if (date == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    if (date instanceof Date) {
        return round((Date) date, field);
    } else if (date instanceof Calendar) {
        return round((Calendar) date, field).getTime();
    } else {
        throw new ClassCastException(""Could not round "" + date);
    }
}","public void test100111() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.round((Object) null, 10);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Round this date, leaving the field specified as the most
 * significant field.</p>
 *
 * <p>For example, if you had the datetime of 28 Mar 2002
 * 13:45:01.231, if this was passed with HOUR, it would return
 * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it
 * would return 1 April 2002 0:00:00.000.</p>
 *
 * <p>For a date in a timezone that handles the change to daylight
 * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.
 * Suppose daylight saving time begins at 02:00 on March 30. Rounding a
 * date that crosses this time would produce the following values:
 * <ul>
 * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>
 * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>
 * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>
 * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>
 * </ul>
 * </p>
 *
 * @param date  the date to work with, either Date or Calendar
 * @param field  the field from <code>Calendar</code>
 *  or <code>SEMI_MONTH</code>
 * @return the rounded date
 * @throws IllegalArgumentException if the date is <code>null</code>
 * @throws ClassCastException if the object type is not a <code>Date</code>
 *  or <code>Calendar</code>
 * @throws ArithmeticException if the year is over 280 million
 */"
"public static Date round(Object date, int field) {
    if (date == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    if (date instanceof Date) {
        return round((Date) date, field);
    } else if (date instanceof Calendar) {
        return round((Calendar) date, field).getTime();
    } else {
        throw new ClassCastException(""Could not round "" + date);
    }
}","public void test101112() throws Throwable {
    MockDate mockDate0 = new MockDate();
    // Undeclared exception!
    try {
        DateUtils.round((Object) mockDate0, 3);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The field 3 is not supported
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Round this date, leaving the field specified as the most
 * significant field.</p>
 *
 * <p>For example, if you had the datetime of 28 Mar 2002
 * 13:45:01.231, if this was passed with HOUR, it would return
 * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it
 * would return 1 April 2002 0:00:00.000.</p>
 *
 * <p>For a date in a timezone that handles the change to daylight
 * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.
 * Suppose daylight saving time begins at 02:00 on March 30. Rounding a
 * date that crosses this time would produce the following values:
 * <ul>
 * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>
 * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>
 * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>
 * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>
 * </ul>
 * </p>
 *
 * @param date  the date to work with, either Date or Calendar
 * @param field  the field from <code>Calendar</code>
 *  or <code>SEMI_MONTH</code>
 * @return the rounded date
 * @throws IllegalArgumentException if the date is <code>null</code>
 * @throws ClassCastException if the object type is not a <code>Date</code>
 *  or <code>Calendar</code>
 * @throws ArithmeticException if the year is over 280 million
 */"
"public static Calendar round(Calendar date, int field) {
    if (date == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    Calendar rounded = (Calendar) date.clone();
    modify(rounded, field, MODIFY_ROUND);
    return rounded;
}","public void test102113() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.round((Calendar) null, 1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Round this date, leaving the field specified as the most
 * significant field.</p>
 *
 * <p>For example, if you had the datetime of 28 Mar 2002
 * 13:45:01.231, if this was passed with HOUR, it would return
 * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it
 * would return 1 April 2002 0:00:00.000.</p>
 *
 * <p>For a date in a timezone that handles the change to daylight
 * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.
 * Suppose daylight saving time begins at 02:00 on March 30. Rounding a
 * date that crosses this time would produce the following values:
 * <ul>
 * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>
 * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>
 * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>
 * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>
 * </ul>
 * </p>
 *
 * @param date  the date to work with
 * @param field  the field from <code>Calendar</code>
 *  or <code>SEMI_MONTH</code>
 * @return the rounded date (a different object)
 * @throws IllegalArgumentException if the date is <code>null</code>
 * @throws ArithmeticException if the year is over 280 million
 */"
"public static boolean isSameDay(Calendar cal1, Calendar cal2) {
    if (cal1 == null || cal2 == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));
}","public void test103115() throws Throwable {
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 0, 0);
    Calendar calendar0 = DateUtils.round((Calendar) mockGregorianCalendar0, 1);
    boolean boolean0 = DateUtils.isSameDay(calendar0, (Calendar) mockGregorianCalendar0);
    assertFalse(boolean0);
}","/**
 * <p>Checks if two calendar objects are on the same day ignoring time.</p>
 *
 * <p>28 Mar 2002 13:45 and 28 Mar 2002 06:01 would return true.
 * 28 Mar 2002 13:45 and 12 Mar 2002 13:45 would return false.
 * </p>
 *
 * @param cal1  the first calendar, not altered, not null
 * @param cal2  the second calendar, not altered, not null
 * @return true if they represent the same day
 * @throws IllegalArgumentException if either calendar is <code>null</code>
 * @since 2.1
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Round this date, leaving the field specified as the most
 * significant field.</p>
 *
 * <p>For example, if you had the datetime of 28 Mar 2002
 * 13:45:01.231, if this was passed with HOUR, it would return
 * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it
 * would return 1 April 2002 0:00:00.000.</p>
 *
 * <p>For a date in a timezone that handles the change to daylight
 * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.
 * Suppose daylight saving time begins at 02:00 on March 30. Rounding a
 * date that crosses this time would produce the following values:
 * <ul>
 * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>
 * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>
 * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>
 * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>
 * </ul>
 * </p>
 *
 * @param date  the date to work with
 * @param field  the field from <code>Calendar</code>
 *  or <code>SEMI_MONTH</code>
 * @return the rounded date
 * @throws IllegalArgumentException if the date is <code>null</code>
 * @throws ArithmeticException if the year is over 280 million
 */
public static Date round(Date date, int field) {
    if (date == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    Calendar gval = Calendar.getInstance();
    gval.setTime(date);
    modify(gval, field, MODIFY_ROUND);
    return gval.getTime();
}","public void test104116() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.round((Date) null, (-2836));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"public static long getFragmentInHours(Date date, int fragment) {
    return getFragment(date, fragment, Calendar.HOUR_OF_DAY);
}","public void test105118() throws Throwable {
    MockDate mockDate0 = new MockDate();
    Date date0 = DateUtils.round((Date) mockDate0, 5);
    long long0 = DateUtils.getFragmentInHours(date0, 5);
    assertEquals(0L, long0);
}","/**
 * <p>Returns the number of hours within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the hours of any date will only return the number of hours
 * of the current day (resulting in a number between 0 and 23). This
 * method will retrieve the number of hours for any fragment.
 * For example, if you want to calculate the number of hours past this month,
 * your fragment is Calendar.MONTH. The result will be all hours of the
 * past day(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a HOUR field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7
 *   (equivalent to deprecated date.getHours())</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7
 *   (equivalent to deprecated date.getHours())</li>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 7</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 127 (5*24 + 7)</li>
 *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in hours)</li>
 * </ul>
 * </p>
 *
 * @param date the date to work with, not null
 * @param fragment the Calendar field part of date to calculate
 * @return number of hours within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"//-----------------------------------------------------------------------
/**
 * Sets the miliseconds field to a date returning a new object.
 * The original date object is unchanged.
 *
 * @param date  the date, not null
 * @param amount the amount to set
 * @return a new Date object set with the specified value
 * @throws IllegalArgumentException if the date is null
 * @since 2.4
 */
public static Date setMilliseconds(Date date, int amount) {
    return set(date, Calendar.MILLISECOND, amount);
}","public void test106119() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.setMilliseconds((Date) null, 1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Parses a string representing a date by trying a variety of different parsers.</p>
 *
 * <p>The parse will try each parse pattern in turn.
 * A parse is only deemed successful if it parses the whole of the input string.
 * If no parse patterns match, a ParseException is thrown.</p>
 * The parser will be lenient toward the parsed date.
 *
 * @param str  the date to parse, not null
 * @param parsePatterns  the date format patterns to use, see SimpleDateFormat, not null
 * @return the parsed date
 * @throws IllegalArgumentException if the date string or pattern array is null
 * @throws ParseException if none of the date patterns were suitable (or there were none)
 */
public static Date parseDate(String str, String... parsePatterns) throws ParseException {
    return parseDateWithLeniency(str, parsePatterns, true);
}","public void test107120() throws Throwable {
    String[] stringArray0 = new String[9];
    stringArray0[0] = """";
    // Undeclared exception!
    try {
        DateUtils.parseDate(""$9-u,a2M&{ w8H].w"", stringArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Parses a string representing a date by trying a variety of different parsers.</p>
 *
 * <p>The parse will try each parse pattern in turn.
 * A parse is only deemed successful if it parses the whole of the input string.
 * If no parse patterns match, a ParseException is thrown.</p>
 * The parser will be lenient toward the parsed date.
 *
 * @param str  the date to parse, not null
 * @param parsePatterns  the date format patterns to use, see SimpleDateFormat, not null
 * @return the parsed date
 * @throws IllegalArgumentException if the date string or pattern array is null
 * @throws ParseException if none of the date patterns were suitable (or there were none)
 */
public static Date parseDate(String str, String... parsePatterns) throws ParseException {
    return parseDateWithLeniency(str, parsePatterns, true);
}","public void test108121() throws Throwable {
    String[] stringArray0 = new String[8];
    stringArray0[0] = ""ZZ"";
    stringArray0[1] = ""ZZ"";
    stringArray0[2] = ""ZZ"";
    stringArray0[3] = ""ZZ"";
    stringArray0[4] = ""ZZ"";
    stringArray0[5] = ""ZZ"";
    stringArray0[6] = ""ZZ"";
    stringArray0[7] = ""ZZ"";
    try {
        DateUtils.parseDate(""ZZ"", stringArray0);
        fail(""Expecting exception: ParseException"");
    } catch (ParseException e) {
        //
        // Unable to parse the date: ZZ
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Parses a string representing a date by trying a variety of different parsers.</p>
 *
 * <p>The parse will try each parse pattern in turn.
 * A parse is only deemed successful if it parses the whole of the input string.
 * If no parse patterns match, a ParseException is thrown.</p>
 * The parser will be lenient toward the parsed date.
 *
 * @param str  the date to parse, not null
 * @param parsePatterns  the date format patterns to use, see SimpleDateFormat, not null
 * @return the parsed date
 * @throws IllegalArgumentException if the date string or pattern array is null
 * @throws ParseException if none of the date patterns were suitable (or there were none)
 */
public static Date parseDate(String str, String... parsePatterns) throws ParseException {
    return parseDateWithLeniency(str, parsePatterns, true);
}","public void test109122() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.parseDate("""", (String[]) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Date and Patterns must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Parses a string representing a date by trying a variety of different parsers.</p>
 *
 * <p>The parse will try each parse pattern in turn.
 * A parse is only deemed successful if it parses the whole of the input string.
 * If no parse patterns match, a ParseException is thrown.</p>
 * The parser parses strictly - it does not allow for dates such as ""February 942, 1996"".
 *
 * @param str  the date to parse, not null
 * @param parsePatterns  the date format patterns to use, see SimpleDateFormat, not null
 * @return the parsed date
 * @throws IllegalArgumentException if the date string or pattern array is null
 * @throws ParseException if none of the date patterns were suitable
 * @since 2.5
 */
public static Date parseDateStrictly(String str, String... parsePatterns) throws ParseException {
    return parseDateWithLeniency(str, parsePatterns, false);
}","public void test110123() throws Throwable {
    String[] stringArray0 = new String[6];
    // Undeclared exception!
    try {
        DateUtils.parseDateStrictly((String) null, stringArray0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Date and Patterns must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Checks if two calendar objects represent the same local time.</p>
 *
 * <p>This method compares the values of the fields of the two objects.
 * In addition, both calendars must be the same of the same type.</p>
 *
 * @param cal1  the first calendar, not altered, not null
 * @param cal2  the second calendar, not altered, not null
 * @return true if they represent the same millisecond instant
 * @throws IllegalArgumentException if either date is <code>null</code>
 * @since 2.1
 */
public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {
    if (cal1 == null || cal2 == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass());
}","public void test111124() throws Throwable {
    Locale locale0 = Locale.JAPAN;
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(locale0);
    MockGregorianCalendar mockGregorianCalendar1 = new MockGregorianCalendar(0, (-3412), 1);
    boolean boolean0 = DateUtils.isSameLocalTime(mockGregorianCalendar0, mockGregorianCalendar1);
    assertFalse(boolean0);
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Checks if two calendar objects represent the same local time.</p>
 *
 * <p>This method compares the values of the fields of the two objects.
 * In addition, both calendars must be the same of the same type.</p>
 *
 * @param cal1  the first calendar, not altered, not null
 * @param cal2  the second calendar, not altered, not null
 * @return true if they represent the same millisecond instant
 * @throws IllegalArgumentException if either date is <code>null</code>
 * @since 2.1
 */
public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {
    if (cal1 == null || cal2 == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass());
}","public void test112125() throws Throwable {
    Locale locale0 = Locale.JAPAN;
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(locale0);
    boolean boolean0 = DateUtils.isSameLocalTime(mockGregorianCalendar0, mockGregorianCalendar0);
    assertTrue(boolean0);
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Checks if two calendar objects represent the same local time.</p>
 *
 * <p>This method compares the values of the fields of the two objects.
 * In addition, both calendars must be the same of the same type.</p>
 *
 * @param cal1  the first calendar, not altered, not null
 * @param cal2  the second calendar, not altered, not null
 * @return true if they represent the same millisecond instant
 * @throws IllegalArgumentException if either date is <code>null</code>
 * @since 2.1
 */
public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {
    if (cal1 == null || cal2 == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass());
}","public void test113126() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.isSameLocalTime((Calendar) null, (Calendar) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"public static boolean isSameInstant(Calendar cal1, Calendar cal2) {
    if (cal1 == null || cal2 == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    return cal1.getTime().getTime() == cal2.getTime().getTime();
}","public void test114128() throws Throwable {
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar();
    Calendar calendar0 = DateUtils.ceiling((Calendar) mockGregorianCalendar0, 12);
    boolean boolean0 = DateUtils.isSameInstant((Calendar) mockGregorianCalendar0, calendar0);
    assertFalse(boolean0);
}","/**
 * <p>Checks if two calendar objects represent the same instant in time.</p>
 *
 * <p>This method compares the long millisecond time of the two objects.</p>
 *
 * @param cal1  the first calendar, not altered, not null
 * @param cal2  the second calendar, not altered, not null
 * @return true if they represent the same millisecond instant
 * @throws IllegalArgumentException if either date is <code>null</code>
 * @since 2.1
 */"
"public static boolean isSameInstant(Calendar cal1, Calendar cal2) {
    if (cal1 == null || cal2 == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    return cal1.getTime().getTime() == cal2.getTime().getTime();
}","public void test115129() throws Throwable {
    Calendar calendar0 = MockCalendar.getInstance();
    // Undeclared exception!
    try {
        DateUtils.isSameInstant(calendar0, (Calendar) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Checks if two calendar objects represent the same instant in time.</p>
 *
 * <p>This method compares the long millisecond time of the two objects.</p>
 *
 * @param cal1  the first calendar, not altered, not null
 * @param cal2  the second calendar, not altered, not null
 * @return true if they represent the same millisecond instant
 * @throws IllegalArgumentException if either date is <code>null</code>
 * @since 2.1
 */"
"public static boolean isSameInstant(Calendar cal1, Calendar cal2) {
    if (cal1 == null || cal2 == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    return cal1.getTime().getTime() == cal2.getTime().getTime();
}","public void test116130() throws Throwable {
    Calendar calendar0 = MockCalendar.getInstance();
    boolean boolean0 = DateUtils.isSameInstant(calendar0, calendar0);
    assertTrue(boolean0);
}","/**
 * <p>Checks if two calendar objects represent the same instant in time.</p>
 *
 * <p>This method compares the long millisecond time of the two objects.</p>
 *
 * @param cal1  the first calendar, not altered, not null
 * @param cal2  the second calendar, not altered, not null
 * @return true if they represent the same millisecond instant
 * @throws IllegalArgumentException if either date is <code>null</code>
 * @since 2.1
 */"
"public static boolean isSameInstant(Calendar cal1, Calendar cal2) {
    if (cal1 == null || cal2 == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    return cal1.getTime().getTime() == cal2.getTime().getTime();
}","public void test117131() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.isSameInstant((Calendar) null, (Calendar) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Checks if two calendar objects represent the same instant in time.</p>
 *
 * <p>This method compares the long millisecond time of the two objects.</p>
 *
 * @param cal1  the first calendar, not altered, not null
 * @param cal2  the second calendar, not altered, not null
 * @return true if they represent the same millisecond instant
 * @throws IllegalArgumentException if either date is <code>null</code>
 * @since 2.1
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Checks if two date objects represent the same instant in time.</p>
 *
 * <p>This method compares the long millisecond time of the two objects.</p>
 *
 * @param date1  the first date, not altered, not null
 * @param date2  the second date, not altered, not null
 * @return true if they represent the same millisecond instant
 * @throws IllegalArgumentException if either date is <code>null</code>
 * @since 2.1
 */
public static boolean isSameInstant(Date date1, Date date2) {
    if (date1 == null || date2 == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    return date1.getTime() == date2.getTime();
}","public void test118133() throws Throwable {
    String[] stringArray0 = new String[4];
    stringArray0[0] = """";
    Date date0 = DateUtils.parseDateStrictly("""", stringArray0);
    Date date1 = DateUtils.ceiling((Object) date0, 0);
    boolean boolean0 = DateUtils.isSameInstant(date1, date0);
    assertFalse(boolean0);
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Checks if two date objects represent the same instant in time.</p>
 *
 * <p>This method compares the long millisecond time of the two objects.</p>
 *
 * @param date1  the first date, not altered, not null
 * @param date2  the second date, not altered, not null
 * @return true if they represent the same millisecond instant
 * @throws IllegalArgumentException if either date is <code>null</code>
 * @since 2.1
 */
public static boolean isSameInstant(Date date1, Date date2) {
    if (date1 == null || date2 == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    return date1.getTime() == date2.getTime();
}","public void test119134() throws Throwable {
    String[] stringArray0 = new String[4];
    stringArray0[0] = """";
    Date date0 = DateUtils.parseDateStrictly("""", stringArray0);
    boolean boolean0 = DateUtils.isSameInstant(date0, date0);
    assertTrue(boolean0);
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Checks if two date objects represent the same instant in time.</p>
 *
 * <p>This method compares the long millisecond time of the two objects.</p>
 *
 * @param date1  the first date, not altered, not null
 * @param date2  the second date, not altered, not null
 * @return true if they represent the same millisecond instant
 * @throws IllegalArgumentException if either date is <code>null</code>
 * @since 2.1
 */
public static boolean isSameInstant(Date date1, Date date2) {
    if (date1 == null || date2 == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    return date1.getTime() == date2.getTime();
}","public void test120135() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.isSameInstant((Date) null, (Date) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Checks if two date objects are on the same day ignoring time.</p>
 *
 * <p>28 Mar 2002 13:45 and 28 Mar 2002 06:01 would return true.
 * 28 Mar 2002 13:45 and 12 Mar 2002 13:45 would return false.
 * </p>
 *
 * @param date1  the first date, not altered, not null
 * @param date2  the second date, not altered, not null
 * @return true if they represent the same day
 * @throws IllegalArgumentException if either date is <code>null</code>
 * @since 2.1
 */
public static boolean isSameDay(Date date1, Date date2) {
    if (date1 == null || date2 == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    Calendar cal1 = Calendar.getInstance();
    cal1.setTime(date1);
    Calendar cal2 = Calendar.getInstance();
    cal2.setTime(date2);
    return isSameDay(cal1, cal2);
}","public void test121137() throws Throwable {
    String[] stringArray0 = new String[4];
    stringArray0[0] = """";
    Date date0 = DateUtils.parseDateStrictly("""", stringArray0);
    Date date1 = DateUtils.ceiling((Object) date0, 1001);
    boolean boolean0 = DateUtils.isSameDay(date0, date1);
    assertFalse(boolean0);
}",""
"public static boolean isSameDay(Calendar cal1, Calendar cal2) {
    if (cal1 == null || cal2 == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));
}","public void test122138() throws Throwable {
    Locale locale0 = Locale.JAPAN;
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(locale0);
    MockGregorianCalendar mockGregorianCalendar1 = new MockGregorianCalendar(0, (-3412), 1);
    boolean boolean0 = DateUtils.isSameDay((Calendar) mockGregorianCalendar0, (Calendar) mockGregorianCalendar1);
    assertFalse(boolean0);
}","/**
 * <p>Checks if two calendar objects are on the same day ignoring time.</p>
 *
 * <p>28 Mar 2002 13:45 and 28 Mar 2002 06:01 would return true.
 * 28 Mar 2002 13:45 and 12 Mar 2002 13:45 would return false.
 * </p>
 *
 * @param cal1  the first calendar, not altered, not null
 * @param cal2  the second calendar, not altered, not null
 * @return true if they represent the same day
 * @throws IllegalArgumentException if either calendar is <code>null</code>
 * @since 2.1
 */"
"public static boolean isSameDay(Calendar cal1, Calendar cal2) {
    if (cal1 == null || cal2 == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));
}","public void test123139() throws Throwable {
    ZoneInfo zoneInfo0 = (ZoneInfo) DateUtils.UTC_TIME_ZONE;
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(zoneInfo0);
    // Undeclared exception!
    try {
        DateUtils.isSameDay((Calendar) mockGregorianCalendar0, (Calendar) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Checks if two calendar objects are on the same day ignoring time.</p>
 *
 * <p>28 Mar 2002 13:45 and 28 Mar 2002 06:01 would return true.
 * 28 Mar 2002 13:45 and 12 Mar 2002 13:45 would return false.
 * </p>
 *
 * @param cal1  the first calendar, not altered, not null
 * @param cal2  the second calendar, not altered, not null
 * @return true if they represent the same day
 * @throws IllegalArgumentException if either calendar is <code>null</code>
 * @since 2.1
 */"
"public static boolean isSameDay(Calendar cal1, Calendar cal2) {
    if (cal1 == null || cal2 == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));
}","public void test124140() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.isSameDay((Calendar) null, (Calendar) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Checks if two calendar objects are on the same day ignoring time.</p>
 *
 * <p>28 Mar 2002 13:45 and 28 Mar 2002 06:01 would return true.
 * 28 Mar 2002 13:45 and 12 Mar 2002 13:45 would return false.
 * </p>
 *
 * @param cal1  the first calendar, not altered, not null
 * @param cal2  the second calendar, not altered, not null
 * @return true if they represent the same day
 * @throws IllegalArgumentException if either calendar is <code>null</code>
 * @since 2.1
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Checks if two date objects are on the same day ignoring time.</p>
 *
 * <p>28 Mar 2002 13:45 and 28 Mar 2002 06:01 would return true.
 * 28 Mar 2002 13:45 and 12 Mar 2002 13:45 would return false.
 * </p>
 *
 * @param date1  the first date, not altered, not null
 * @param date2  the second date, not altered, not null
 * @return true if they represent the same day
 * @throws IllegalArgumentException if either date is <code>null</code>
 * @since 2.1
 */
public static boolean isSameDay(Date date1, Date date2) {
    if (date1 == null || date2 == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    Calendar cal1 = Calendar.getInstance();
    cal1.setTime(date1);
    Calendar cal2 = Calendar.getInstance();
    cal2.setTime(date2);
    return isSameDay(cal1, cal2);
}","public void test125141() throws Throwable {
    String[] stringArray0 = new String[4];
    stringArray0[0] = """";
    Date date0 = DateUtils.parseDateStrictly("""", stringArray0);
    boolean boolean0 = DateUtils.isSameDay(date0, date0);
    assertTrue(boolean0);
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Checks if two date objects are on the same day ignoring time.</p>
 *
 * <p>28 Mar 2002 13:45 and 28 Mar 2002 06:01 would return true.
 * 28 Mar 2002 13:45 and 12 Mar 2002 13:45 would return false.
 * </p>
 *
 * @param date1  the first date, not altered, not null
 * @param date2  the second date, not altered, not null
 * @return true if they represent the same day
 * @throws IllegalArgumentException if either date is <code>null</code>
 * @since 2.1
 */
public static boolean isSameDay(Date date1, Date date2) {
    if (date1 == null || date2 == null) {
        throw new IllegalArgumentException(""The date must not be null"");
    }
    Calendar cal1 = Calendar.getInstance();
    cal1.setTime(date1);
    Calendar cal2 = Calendar.getInstance();
    cal2.setTime(date2);
    return isSameDay(cal1, cal2);
}","public void test126142() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.isSameDay((Date) null, (Date) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"public static long getFragmentInMinutes(Calendar calendar, int fragment) {
    return getFragment(calendar, fragment, Calendar.MINUTE);
}","public void test129145() throws Throwable {
    MockDate mockDate0 = new MockDate(0, 0, 1090, (-1), 1090, 597);
    Calendar calendar0 = DateUtils.toCalendar(mockDate0);
    // Undeclared exception!
    try {
        DateUtils.getFragmentInMinutes(calendar0, (-1443));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The fragment -1443 is not supported
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Returns the number of minutes within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the minutes of any date will only return the number of minutes
 * of the current hour (resulting in a number between 0 and 59). This
 * method will retrieve the number of minutes for any fragment.
 * For example, if you want to calculate the number of minutes past this month,
 * your fragment is Calendar.MONTH. The result will be all minutes of the
 * past day(s) and hour(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a MINUTE field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15
 *   (equivalent to calendar.get(Calendar.MINUTES))</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15
 *   (equivalent to calendar.get(Calendar.MINUTES))</li>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 15</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 435 (7*60 + 15)</li>
 *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in minutes)</li>
 * </ul>
 * </p>
 *
 * @param calendar the calendar to work with, not null
 * @param fragment the Calendar field part of calendar to calculate
 * @return number of minutes within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"public static long getFragmentInHours(Calendar calendar, int fragment) {
    return getFragment(calendar, fragment, Calendar.HOUR_OF_DAY);
}","public void test130146() throws Throwable {
    DateUtils dateUtils0 = new DateUtils();
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(dateUtils0.UTC_TIME_ZONE);
    long long0 = DateUtils.getFragmentInHours((Calendar) mockGregorianCalendar0, 2);
    assertEquals(356L, long0);
}","/**
 * <p>Returns the number of hours within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the hours of any date will only return the number of hours
 * of the current day (resulting in a number between 0 and 23). This
 * method will retrieve the number of hours for any fragment.
 * For example, if you want to calculate the number of hours past this month,
 * your fragment is Calendar.MONTH. The result will be all hours of the
 * past day(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a HOUR field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7
 *   (equivalent to calendar.get(Calendar.HOUR_OF_DAY))</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7
 *   (equivalent to calendar.get(Calendar.HOUR_OF_DAY))</li>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 7</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 127 (5*24 + 7)</li>
 *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in hours)</li>
 * </ul>
 * </p>
 *
 * @param calendar the calendar to work with, not null
 * @param fragment the Calendar field part of calendar to calculate
 * @return number of hours within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"public static boolean truncatedEquals(Calendar cal1, Calendar cal2, int field) {
    return truncatedCompareTo(cal1, cal2, field) == 0;
}","public void test132148() throws Throwable {
    DateUtils dateUtils0 = new DateUtils();
    Calendar calendar0 = MockCalendar.getInstance(dateUtils0.UTC_TIME_ZONE);
    // Undeclared exception!
    try {
        DateUtils.truncatedEquals((Calendar) null, calendar0, 44);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * Determines if two calendars are equal up to no more than the specified
 * most significant field.
 *
 * @param cal1 the first calendar, not <code>null</code>
 * @param cal2 the second calendar, not <code>null</code>
 * @param field the field from <code>Calendar</code>
 * @return <code>true</code> if equal; otherwise <code>false</code>
 * @throws IllegalArgumentException if any argument is <code>null</code>
 * @see #truncate(Calendar, int)
 * @see #truncatedEquals(Date, Date, int)
 * @since 3.0
 */"
"public static long getFragmentInMinutes(Date date, int fragment) {
    return getFragment(date, fragment, Calendar.MINUTE);
}","public void test136152() throws Throwable {
    MockDate mockDate0 = new MockDate();
    long long0 = DateUtils.getFragmentInMinutes((Date) mockDate0, 1);
    assertEquals(66021L, long0);
}","/**
 * <p>Returns the number of minutes within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the minutes of any date will only return the number of minutes
 * of the current hour (resulting in a number between 0 and 59). This
 * method will retrieve the number of minutes for any fragment.
 * For example, if you want to calculate the number of minutes past this month,
 * your fragment is Calendar.MONTH. The result will be all minutes of the
 * past day(s) and hour(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a MINUTE field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15
 *   (equivalent to deprecated date.getMinutes())</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15
 *   (equivalent to deprecated date.getMinutes())</li>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 15</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 435 (7*60 + 15)</li>
 *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in minutes)</li>
 * </ul>
 * </p>
 *
 * @param date the date to work with, not null
 * @param fragment the Calendar field part of date to calculate
 * @return number of minutes within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"//-----------------------------------------------------------------------
/**
 * Adds a number of months to a date returning a new object.
 * The original date object is unchanged.
 *
 * @param date  the date, not null
 * @param amount  the amount to add, may be negative
 * @return the new date object with the amount added
 * @throws IllegalArgumentException if the date is null
 */
public static Date addMonths(Date date, int amount) {
    return add(date, Calendar.MONTH, amount);
}","public void test138154() throws Throwable {
    // Undeclared exception!
    try {
        DateUtils.addMonths((Date) null, 0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The date must not be null
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}",""
"public static long getFragmentInDays(Date date, int fragment) {
    return getFragment(date, fragment, Calendar.DAY_OF_YEAR);
}","public void test139155() throws Throwable {
    MockDate mockDate0 = new MockDate();
    long long0 = DateUtils.getFragmentInDays((Date) mockDate0, 2);
    assertEquals(14L, long0);
}","/**
 * <p>Returns the number of days within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the days of any date will only return the number of days
 * of the current month (resulting in a number between 1 and 31). This
 * method will retrieve the number of days for any fragment.
 * For example, if you want to calculate the number of days past this year,
 * your fragment is Calendar.YEAR. The result will be all days of the
 * past month(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a DAY field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 28, 2008 with Calendar.MONTH as fragment will return 28
 *   (equivalent to deprecated date.getDay())</li>
 *  <li>February 28, 2008 with Calendar.MONTH as fragment will return 28
 *   (equivalent to deprecated date.getDay())</li>
 *  <li>January 28, 2008 with Calendar.YEAR as fragment will return 28</li>
 *  <li>February 28, 2008 with Calendar.YEAR as fragment will return 59</li>
 *  <li>January 28, 2008 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in days)</li>
 * </ul>
 * </p>
 *
 * @param date the date to work with, not null
 * @param fragment the Calendar field part of date to calculate
 * @return number of days  within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"public static long getFragmentInDays(Calendar calendar, int fragment) {
    return getFragment(calendar, fragment, Calendar.DAY_OF_YEAR);
}","public void test140156() throws Throwable {
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar((-1868), (-1868), 2140793667, (-2338), 0);
    // Undeclared exception!
    try {
        DateUtils.getFragmentInDays((Calendar) mockGregorianCalendar0, 2950);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The fragment 2950 is not supported
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Returns the number of days within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the days of any date will only return the number of days
 * of the current month (resulting in a number between 1 and 31). This
 * method will retrieve the number of days for any fragment.
 * For example, if you want to calculate the number of days past this year,
 * your fragment is Calendar.YEAR. The result will be all days of the
 * past month(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a DAY field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 28, 2008 with Calendar.MONTH as fragment will return 28
 *   (equivalent to calendar.get(Calendar.DAY_OF_MONTH))</li>
 *  <li>February 28, 2008 with Calendar.MONTH as fragment will return 28
 *   (equivalent to calendar.get(Calendar.DAY_OF_MONTH))</li>
 *  <li>January 28, 2008 with Calendar.YEAR as fragment will return 28
 *   (equivalent to calendar.get(Calendar.DAY_OF_YEAR))</li>
 *  <li>February 28, 2008 with Calendar.YEAR as fragment will return 59
 *   (equivalent to calendar.get(Calendar.DAY_OF_YEAR))</li>
 *  <li>January 28, 2008 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in days)</li>
 * </ul>
 * </p>
 *
 * @param calendar the calendar to work with, not null
 * @param fragment the Calendar field part of calendar to calculate
 * @return number of days within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"public static long getFragmentInMilliseconds(Calendar calendar, int fragment) {
    return getFragment(calendar, fragment, Calendar.MILLISECOND);
}","public void test142158() throws Throwable {
    DateUtils dateUtils0 = new DateUtils();
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(dateUtils0.UTC_TIME_ZONE);
    long long0 = DateUtils.getFragmentInMilliseconds((Calendar) mockGregorianCalendar0, 6);
    assertEquals(73281320L, long0);
}","/**
 * <p>Returns the number of milliseconds within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the milliseconds of any date will only return the number of milliseconds
 * of the current second (resulting in a number between 0 and 999). This
 * method will retrieve the number of milliseconds for any fragment.
 * For example, if you want to calculate the number of seconds past today,
 * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will
 * be all seconds of the past hour(s), minutes(s) and second(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a MILLISECOND field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538
 *   (equivalent to calendar.get(Calendar.MILLISECOND))</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538
 *   (equivalent to calendar.get(Calendar.MILLISECOND))</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10538
 *   (10*1000 + 538)</li>
 *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in milliseconds)</li>
 * </ul>
 * </p>
 *
 * @param calendar the calendar to work with, not null
 * @param fragment the Calendar field part of calendar to calculate
 * @return number of milliseconds within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"public static long getFragmentInSeconds(Date date, int fragment) {
    return getFragment(date, fragment, Calendar.SECOND);
}","public void test143159() throws Throwable {
    MockDate mockDate0 = new MockDate();
    long long0 = DateUtils.getFragmentInSeconds((Date) mockDate0, 1);
    assertEquals(3961281L, long0);
}","/**
 * <p>Returns the number of seconds within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the seconds of any date will only return the number of seconds
 * of the current minute (resulting in a number between 0 and 59). This
 * method will retrieve the number of seconds for any fragment.
 * For example, if you want to calculate the number of seconds past today,
 * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will
 * be all seconds of the past hour(s) and minutes(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a SECOND field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10
 *   (equivalent to deprecated date.getSeconds())</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10
 *   (equivalent to deprecated date.getSeconds())</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 26110
 *   (7*3600 + 15*60 + 10)</li>
 *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in seconds)</li>
 * </ul>
 * </p>
 *
 * @param date the date to work with, not null
 * @param fragment the Calendar field part of date to calculate
 * @return number of seconds within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Parses a string representing a date by trying a variety of different parsers.</p>
 *
 * <p>The parse will try each parse pattern in turn.
 * A parse is only deemed successful if it parses the whole of the input string.
 * If no parse patterns match, a ParseException is thrown.</p>
 * The parser parses strictly - it does not allow for dates such as ""February 942, 1996"".
 *
 * @param str  the date to parse, not null
 * @param parsePatterns  the date format patterns to use, see SimpleDateFormat, not null
 * @return the parsed date
 * @throws IllegalArgumentException if the date string or pattern array is null
 * @throws ParseException if none of the date patterns were suitable
 * @since 2.5
 */
public static Date parseDateStrictly(String str, String... parsePatterns) throws ParseException {
    return parseDateWithLeniency(str, parsePatterns, false);
}","public void test146162() throws Throwable {
    String[] stringArray0 = new String[4];
    // Undeclared exception!
    try {
        DateUtils.parseDateStrictly("""", stringArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"public static long getFragmentInMilliseconds(Date date, int fragment) {
    return getFragment(date, fragment, Calendar.MILLISECOND);
}","public void test147163() throws Throwable {
    MockDate mockDate0 = new MockDate(1433, 1433, (-155), 7, 0, 0);
    // Undeclared exception!
    try {
        DateUtils.getFragmentInMilliseconds((Date) mockDate0, 7);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The fragment 7 is not supported
        //
        verifyException(""org.apache.commons.lang3.time.DateUtils"", e);
    }
}","/**
 * <p>Returns the number of milliseconds within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the milliseconds of any date will only return the number of milliseconds
 * of the current second (resulting in a number between 0 and 999). This
 * method will retrieve the number of milliseconds for any fragment.
 * For example, if you want to calculate the number of milliseconds past today,
 * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will
 * be all milliseconds of the past hour(s), minutes(s) and second(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a SECOND field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10538 (10*1000 + 538)</li>
 *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in milliseconds)</li>
 * </ul>
 * </p>
 *
 * @param date the date to work with, not null
 * @param fragment the Calendar field part of date to calculate
 * @return number of milliseconds within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
"public static long getFragmentInSeconds(Calendar calendar, int fragment) {
    return getFragment(calendar, fragment, Calendar.SECOND);
}","public void test148164() throws Throwable {
    Calendar calendar0 = MockCalendar.getInstance();
    long long0 = DateUtils.getFragmentInSeconds(calendar0, 11);
    assertEquals(1281L, long0);
}","/**
 * <p>Returns the number of seconds within the
 * fragment. All datefields greater than the fragment will be ignored.</p>
 *
 * <p>Asking the seconds of any date will only return the number of seconds
 * of the current minute (resulting in a number between 0 and 59). This
 * method will retrieve the number of seconds for any fragment.
 * For example, if you want to calculate the number of seconds past today,
 * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will
 * be all seconds of the past hour(s) and minutes(s).</p>
 *
 * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both
 * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY,
 * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND
 * A fragment less than or equal to a SECOND field will return 0.</p>
 *
 * <p>
 * <ul>
 *  <li>January 1, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10
 *   (equivalent to calendar.get(Calendar.SECOND))</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10
 *   (equivalent to calendar.get(Calendar.SECOND))</li>
 *  <li>January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 26110
 *   (7*3600 + 15*60 + 10)</li>
 *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0
 *   (a millisecond cannot be split in seconds)</li>
 * </ul>
 * </p>
 *
 * @param calendar the calendar to work with, not null
 * @param fragment the Calendar field part of calendar to calculate
 * @return number of seconds within the fragment of date
 * @throws IllegalArgumentException if the date is <code>null</code> or
 * fragment is not supported
 * @since 2.4
 */"
