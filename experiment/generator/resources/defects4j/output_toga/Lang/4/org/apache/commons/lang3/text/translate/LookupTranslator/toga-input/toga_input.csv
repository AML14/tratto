focal_method,test_prefix,docstring
"@Override
public int translate(final CharSequence input, final int index, final Writer out) throws IOException {
    int max = longest;
    if (index + longest > input.length()) {
        max = input.length() - index;
    }
    // descend so as to get a greedy algorithm
    for (int i = max; i >= shortest; i--) {
        final CharSequence subSeq = input.subSequence(index, index + i);
        final CharSequence result = lookupMap.get(subSeq);
        if (result != null) {
            out.write(result.toString());
            return i;
        }
    }
    return 0;
}","public void test00() throws Throwable {
    CharSequence[][] charSequenceArray0 = new CharSequence[7][9];
    CharSequence[] charSequenceArray1 = new CharSequence[3];
    CharBuffer charBuffer0 = CharBuffer.allocate(2426);
    CharBuffer charBuffer1 = CharBuffer.wrap((CharSequence) charBuffer0, 16, 2426);
    charSequenceArray1[0] = (CharSequence) charBuffer1;
    charSequenceArray1[1] = (CharSequence) charBuffer0;
    charSequenceArray0[0] = charSequenceArray1;
    CharSequence[] charSequenceArray2 = new CharSequence[9];
    charSequenceArray2[0] = (CharSequence) charBuffer0;
    charSequenceArray0[1] = charSequenceArray2;
    charSequenceArray0[2] = charSequenceArray1;
    charSequenceArray0[3] = charSequenceArray0[2];
    charSequenceArray0[4] = charSequenceArray0[2];
    charSequenceArray0[5] = charSequenceArray0[0];
    charSequenceArray0[6] = charSequenceArray0[2];
    LookupTranslator lookupTranslator0 = new LookupTranslator(charSequenceArray0);
    StringWriter stringWriter0 = new StringWriter();
    int int0 = lookupTranslator0.translate((CharSequence) charBuffer0, 4, (Writer) stringWriter0);
    assertEquals(2410, int0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public int translate(final CharSequence input, final int index, final Writer out) throws IOException {
    int max = longest;
    if (index + longest > input.length()) {
        max = input.length() - index;
    }
    // descend so as to get a greedy algorithm
    for (int i = max; i >= shortest; i--) {
        final CharSequence subSeq = input.subSequence(index, index + i);
        final CharSequence result = lookupMap.get(subSeq);
        if (result != null) {
            out.write(result.toString());
            return i;
        }
    }
    return 0;
}","public void test11() throws Throwable {
    CharSequence[][] charSequenceArray0 = new CharSequence[3][9];
    CharSequence[] charSequenceArray1 = new CharSequence[4];
    charSequenceArray1[0] = (CharSequence) ""0"";
    StringWriter stringWriter0 = new StringWriter();
    CharBuffer charBuffer0 = CharBuffer.wrap(charSequenceArray1[0], 0, 0);
    charSequenceArray1[2] = (CharSequence) charBuffer0;
    charSequenceArray0[0] = charSequenceArray1;
    charSequenceArray0[1] = charSequenceArray1;
    charSequenceArray0[2] = charSequenceArray0[0];
    LookupTranslator lookupTranslator0 = new LookupTranslator(charSequenceArray0);
    int int0 = lookupTranslator0.translate(charSequenceArray1[2], 1345, (Writer) stringWriter0);
    assertEquals(0, int0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public int translate(final CharSequence input, final int index, final Writer out) throws IOException {
    int max = longest;
    if (index + longest > input.length()) {
        max = input.length() - index;
    }
    // descend so as to get a greedy algorithm
    for (int i = max; i >= shortest; i--) {
        final CharSequence subSeq = input.subSequence(index, index + i);
        final CharSequence result = lookupMap.get(subSeq);
        if (result != null) {
            out.write(result.toString());
            return i;
        }
    }
    return 0;
}","public void test22() throws Throwable {
    CharSequence[][] charSequenceArray0 = new CharSequence[3][9];
    CharSequence[] charSequenceArray1 = new CharSequence[4];
    charSequenceArray1[0] = (CharSequence) ""0"";
    StringWriter stringWriter0 = new StringWriter(0);
    charSequenceArray0[0] = charSequenceArray1;
    charSequenceArray0[1] = charSequenceArray0[0];
    charSequenceArray0[2] = charSequenceArray0[0];
    LookupTranslator lookupTranslator0 = new LookupTranslator(charSequenceArray0);
    // Undeclared exception!
    try {
        lookupTranslator0.translate((CharSequence) ""5E0"", (-2505), (Writer) stringWriter0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public int translate(final CharSequence input, final int index, final Writer out) throws IOException {
    int max = longest;
    if (index + longest > input.length()) {
        max = input.length() - index;
    }
    // descend so as to get a greedy algorithm
    for (int i = max; i >= shortest; i--) {
        final CharSequence subSeq = input.subSequence(index, index + i);
        final CharSequence result = lookupMap.get(subSeq);
        if (result != null) {
            out.write(result.toString());
            return i;
        }
    }
    return 0;
}","public void test33() throws Throwable {
    CharSequence[][] charSequenceArray0 = new CharSequence[3][9];
    CharSequence[] charSequenceArray1 = new CharSequence[4];
    charSequenceArray1[0] = (CharSequence) ""0"";
    StringWriter stringWriter0 = new StringWriter(0);
    charSequenceArray0[0] = charSequenceArray1;
    charSequenceArray0[1] = charSequenceArray0[0];
    charSequenceArray0[2] = charSequenceArray0[0];
    LookupTranslator lookupTranslator0 = new LookupTranslator(charSequenceArray0);
    // Undeclared exception!
    try {
        lookupTranslator0.translate(charSequenceArray1[1], 1504, (Writer) stringWriter0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.text.translate.LookupTranslator"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"@Override
public int translate(final CharSequence input, final int index, final Writer out) throws IOException {
    int max = longest;
    if (index + longest > input.length()) {
        max = input.length() - index;
    }
    // descend so as to get a greedy algorithm
    for (int i = max; i >= shortest; i--) {
        final CharSequence subSeq = input.subSequence(index, index + i);
        final CharSequence result = lookupMap.get(subSeq);
        if (result != null) {
            out.write(result.toString());
            return i;
        }
    }
    return 0;
}","public void test44() throws Throwable {
    CharSequence[] charSequenceArray0 = new CharSequence[4];
    StringWriter stringWriter0 = new StringWriter(0);
    StringBuffer stringBuffer0 = stringWriter0.getBuffer();
    charSequenceArray0[0] = (CharSequence) stringBuffer0;
    CharBuffer charBuffer0 = CharBuffer.wrap(charSequenceArray0[0], 0, 0);
    CharSequence[][] charSequenceArray1 = new CharSequence[5][4];
    charSequenceArray1[0] = charSequenceArray0;
    charSequenceArray1[1] = charSequenceArray0;
    charSequenceArray1[2] = charSequenceArray0;
    charSequenceArray1[3] = charSequenceArray0;
    charSequenceArray1[4] = charSequenceArray0;
    LookupTranslator lookupTranslator0 = new LookupTranslator(charSequenceArray1);
    // Undeclared exception!
    try {
        lookupTranslator0.translate((CharSequence) charBuffer0, (-3585), (Writer) stringWriter0);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.nio.Buffer"", e);
    }
}","/**
 * {@inheritDoc}
 */"
"public LookupTranslator(final CharSequence[]... lookup) {
    lookupMap = new HashMap<CharSequence, CharSequence>();
    int _shortest = Integer.MAX_VALUE;
    int _longest = 0;
    if (lookup != null) {
        for (final CharSequence[] seq : lookup) {
            this.lookupMap.put(seq[0], seq[1]);
            final int sz = seq[0].length();
            if (sz < _shortest) {
                _shortest = sz;
            }
            if (sz > _longest) {
                _longest = sz;
            }
        }
    }
    shortest = _shortest;
    longest = _longest;
}","public void test55() throws Throwable {
    CharSequence[][] charSequenceArray0 = new CharSequence[9][3];
    LookupTranslator lookupTranslator0 = null;
    try {
        lookupTranslator0 = new LookupTranslator(charSequenceArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.text.translate.LookupTranslator"", e);
    }
}","/**
 * Define the lookup table to be used in translation
 *
 * Note that, as of Lang 3.1, the key to the lookup table is converted to a
 * java.lang.String, while the value remains as a java.lang.CharSequence.
 * This is because we need the key to support hashCode and equals(Object),
 * allowing it to be the key for a HashMap. See LANG-882.
 *
 * @param lookup CharSequence[][] table of size [*][2]
 */"
"public LookupTranslator(final CharSequence[]... lookup) {
    lookupMap = new HashMap<CharSequence, CharSequence>();
    int _shortest = Integer.MAX_VALUE;
    int _longest = 0;
    if (lookup != null) {
        for (final CharSequence[] seq : lookup) {
            this.lookupMap.put(seq[0], seq[1]);
            final int sz = seq[0].length();
            if (sz < _shortest) {
                _shortest = sz;
            }
            if (sz > _longest) {
                _longest = sz;
            }
        }
    }
    shortest = _shortest;
    longest = _longest;
}","public void test66() throws Throwable {
    CharSequence[][] charSequenceArray0 = new CharSequence[2][9];
    CharSequence[] charSequenceArray1 = new CharSequence[2];
    char[] charArray0 = new char[3];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    charSequenceArray1[0] = (CharSequence) charBuffer0;
    CharBuffer charBuffer1 = CharBuffer.wrap((CharSequence) charBuffer0);
    charBuffer0.get();
    charSequenceArray0[0] = charSequenceArray1;
    CharSequence[] charSequenceArray2 = new CharSequence[3];
    charSequenceArray2[0] = (CharSequence) charBuffer1;
    charSequenceArray0[1] = charSequenceArray2;
    LookupTranslator lookupTranslator0 = null;
    try {
        lookupTranslator0 = new LookupTranslator(charSequenceArray0);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.nio.Buffer"", e);
    }
}","/**
 * Define the lookup table to be used in translation
 *
 * Note that, as of Lang 3.1, the key to the lookup table is converted to a
 * java.lang.String, while the value remains as a java.lang.CharSequence.
 * This is because we need the key to support hashCode and equals(Object),
 * allowing it to be the key for a HashMap. See LANG-882.
 *
 * @param lookup CharSequence[][] table of size [*][2]
 */"
"@Override
public int translate(final CharSequence input, final int index, final Writer out) throws IOException {
    int max = longest;
    if (index + longest > input.length()) {
        max = input.length() - index;
    }
    // descend so as to get a greedy algorithm
    for (int i = max; i >= shortest; i--) {
        final CharSequence subSeq = input.subSequence(index, index + i);
        final CharSequence result = lookupMap.get(subSeq);
        if (result != null) {
            out.write(result.toString());
            return i;
        }
    }
    return 0;
}","public void test77() throws Throwable {
    CharSequence[] charSequenceArray0 = new CharSequence[13];
    StringWriter stringWriter0 = new StringWriter();
    StringBuffer stringBuffer0 = stringWriter0.getBuffer();
    charSequenceArray0[0] = (CharSequence) stringBuffer0;
    CharBuffer charBuffer0 = CharBuffer.allocate(0);
    CharSequence[] charSequenceArray1 = new CharSequence[30];
    charSequenceArray1[0] = (CharSequence) ""0"";
    charSequenceArray1[1] = (CharSequence) charBuffer0;
    charSequenceArray1[4] = (CharSequence) ""0"";
    CharSequence[][] charSequenceArray2 = new CharSequence[2][1];
    charSequenceArray2[0] = charSequenceArray0;
    charSequenceArray2[1] = charSequenceArray1;
    LookupTranslator lookupTranslator0 = new LookupTranslator(charSequenceArray2);
    int int0 = lookupTranslator0.translate(charSequenceArray1[4], 0, (Writer) stringWriter0);
    assertEquals(1, int0);
}","/**
 * {@inheritDoc}
 */"
"public LookupTranslator(final CharSequence[]... lookup) {
    lookupMap = new HashMap<CharSequence, CharSequence>();
    int _shortest = Integer.MAX_VALUE;
    int _longest = 0;
    if (lookup != null) {
        for (final CharSequence[] seq : lookup) {
            this.lookupMap.put(seq[0], seq[1]);
            final int sz = seq[0].length();
            if (sz < _shortest) {
                _shortest = sz;
            }
            if (sz > _longest) {
                _longest = sz;
            }
        }
    }
    shortest = _shortest;
    longest = _longest;
}","public void test89() throws Throwable {
    CharSequence[][] charSequenceArray0 = new CharSequence[2][1];
    LookupTranslator lookupTranslator0 = null;
    try {
        lookupTranslator0 = new LookupTranslator(charSequenceArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Define the lookup table to be used in translation
 *
 * Note that, as of Lang 3.1, the key to the lookup table is converted to a
 * java.lang.String, while the value remains as a java.lang.CharSequence.
 * This is because we need the key to support hashCode and equals(Object),
 * allowing it to be the key for a HashMap. See LANG-882.
 *
 * @param lookup CharSequence[][] table of size [*][2]
 */"
"public LookupTranslator(final CharSequence[]... lookup) {
    lookupMap = new HashMap<CharSequence, CharSequence>();
    int _shortest = Integer.MAX_VALUE;
    int _longest = 0;
    if (lookup != null) {
        for (final CharSequence[] seq : lookup) {
            this.lookupMap.put(seq[0], seq[1]);
            final int sz = seq[0].length();
            if (sz < _shortest) {
                _shortest = sz;
            }
            if (sz > _longest) {
                _longest = sz;
            }
        }
    }
    shortest = _shortest;
    longest = _longest;
}","public void test910() throws Throwable {
    LookupTranslator lookupTranslator0 = new LookupTranslator((CharSequence[][]) null);
}","/**
 * Define the lookup table to be used in translation
 *
 * Note that, as of Lang 3.1, the key to the lookup table is converted to a
 * java.lang.String, while the value remains as a java.lang.CharSequence.
 * This is because we need the key to support hashCode and equals(Object),
 * allowing it to be the key for a HashMap. See LANG-882.
 *
 * @param lookup CharSequence[][] table of size [*][2]
 */"
