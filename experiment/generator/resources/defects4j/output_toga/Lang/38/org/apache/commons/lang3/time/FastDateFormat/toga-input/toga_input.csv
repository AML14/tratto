focal_method,test_prefix,docstring
"//-----------------------------------------------------------------------
/**
 * <p>Gets a formatter instance using the default pattern in the
 * default locale.</p>
 *
 * @return a date/time formatter
 */
public static FastDateFormat getInstance() {
    return getInstance(getDefaultPattern(), null, null);
}","public void test000() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    assertEquals(0, FastDateFormat.FULL);
}",""
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test005() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test006() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test007() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test0016() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    MockGregorianCalendar mockGregorianCalendar0 = (MockGregorianCalendar) mockSimpleDateFormat0.getCalendar();
    assertEquals(""org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=1392409281320,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\""GMT\"",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2014,MONTH=1,WEEK_OF_YEAR=7,WEEK_OF_MONTH=3,DAY_OF_MONTH=14,DAY_OF_YEAR=45,DAY_OF_WEEK=6,DAY_OF_WEEK_IN_MONTH=2,AM_PM=1,HOUR=8,HOUR_OF_DAY=20,MINUTE=21,SECOND=21,MILLISECOND=320,ZONE_OFFSET=0,DST_OFFSET=0]"", mockGregorianCalendar0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test0024() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    MockGregorianCalendar mockGregorianCalendar0 = (MockGregorianCalendar) mockSimpleDateFormat0.getCalendar();
    Date date0 = mockGregorianCalendar0.getGregorianChange();
    assertEquals(""org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=1392409281320,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\""GMT\"",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2014,MONTH=1,WEEK_OF_YEAR=7,WEEK_OF_MONTH=3,DAY_OF_MONTH=14,DAY_OF_YEAR=45,DAY_OF_WEEK=6,DAY_OF_WEEK_IN_MONTH=2,AM_PM=1,HOUR=8,HOUR_OF_DAY=20,MINUTE=21,SECOND=21,MILLISECOND=320,ZONE_OFFSET=0,DST_OFFSET=0]"", mockGregorianCalendar0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public StringBuffer format(Date date, StringBuffer buf) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, buf);
}","public void test0029() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    MockGregorianCalendar mockGregorianCalendar0 = (MockGregorianCalendar) mockSimpleDateFormat0.getCalendar();
    Date date0 = mockGregorianCalendar0.getGregorianChange();
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""B:>]S[=_Pv8oQ"");
    StringBuffer stringBuffer1 = fastDateFormat0.format(date0, stringBuffer0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Formats a <code>Date</code> object into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param date  the date to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0036() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    MockGregorianCalendar mockGregorianCalendar0 = (MockGregorianCalendar) mockSimpleDateFormat0.getCalendar();
    Date date0 = mockGregorianCalendar0.getGregorianChange();
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""B:>]S[=_Pv8oQ"");
    StringBuffer stringBuffer1 = fastDateFormat0.format(date0, stringBuffer0);
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0037() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    MockGregorianCalendar mockGregorianCalendar0 = (MockGregorianCalendar) mockSimpleDateFormat0.getCalendar();
    Date date0 = mockGregorianCalendar0.getGregorianChange();
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""B:>]S[=_Pv8oQ"");
    StringBuffer stringBuffer1 = fastDateFormat0.format(date0, stringBuffer0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0038() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    MockGregorianCalendar mockGregorianCalendar0 = (MockGregorianCalendar) mockSimpleDateFormat0.getCalendar();
    Date date0 = mockGregorianCalendar0.getGregorianChange();
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""B:>]S[=_Pv8oQ"");
    StringBuffer stringBuffer1 = fastDateFormat0.format(date0, stringBuffer0);
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test0045() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    MockGregorianCalendar mockGregorianCalendar0 = (MockGregorianCalendar) mockSimpleDateFormat0.getCalendar();
    Date date0 = mockGregorianCalendar0.getGregorianChange();
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""B:>]S[=_Pv8oQ"");
    StringBuffer stringBuffer1 = fastDateFormat0.format(date0, stringBuffer0);
    assertEquals(""org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=1392409281320,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\""GMT\"",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2014,MONTH=1,WEEK_OF_YEAR=7,WEEK_OF_MONTH=3,DAY_OF_MONTH=14,DAY_OF_YEAR=45,DAY_OF_WEEK=6,DAY_OF_WEEK_IN_MONTH=2,AM_PM=1,HOUR=8,HOUR_OF_DAY=20,MINUTE=21,SECOND=21,MILLISECOND=320,ZONE_OFFSET=0,DST_OFFSET=0]"", mockGregorianCalendar0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public String format(Calendar calendar) {
    return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test0160() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar((-1), 1, 16, (-359), 1992, 3);
    String string0 = fastDateFormat0.format((Calendar) mockGregorianCalendar0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Formats a <code>Calendar</code> object.</p>
 *
 * @param calendar  the calendar to format
 * @return the formatted string
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0166() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar((-1), 1, 16, (-359), 1992, 3);
    String string0 = fastDateFormat0.format((Calendar) mockGregorianCalendar0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0167() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar((-1), 1, 16, (-359), 1992, 3);
    String string0 = fastDateFormat0.format((Calendar) mockGregorianCalendar0);
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0168() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar((-1), 1, 16, (-359), 1992, 3);
    String string0 = fastDateFormat0.format((Calendar) mockGregorianCalendar0);
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test0169() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar((-1), 1, 16, (-359), 1992, 3);
    String string0 = fastDateFormat0.format((Calendar) mockGregorianCalendar0);
    assertEquals(""org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=-62196126477000,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\""GMT\"",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=0,YEAR=2,MONTH=1,WEEK_OF_YEAR=6,WEEK_OF_MONTH=2,DAY_OF_MONTH=2,DAY_OF_YEAR=33,DAY_OF_WEEK=1,DAY_OF_WEEK_IN_MONTH=1,AM_PM=0,HOUR=10,HOUR_OF_DAY=10,MINUTE=12,SECOND=3,MILLISECOND=0,ZONE_OFFSET=0,DST_OFFSET=0]"", mockGregorianCalendar0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public static FastDateFormat getTimeInstance(int style, Locale locale) {
    return getTimeInstance(style, null, locale);
}","public void test0280() throws Throwable {
    Locale locale0 = Locale.forLanguageTag(""6"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, locale0);
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Gets a time formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0291() throws Throwable {
    Locale locale0 = Locale.forLanguageTag(""6"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, locale0);
    assertEquals(""h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0292() throws Throwable {
    Locale locale0 = Locale.forLanguageTag(""6"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, locale0);
    assertEquals(18, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0293() throws Throwable {
    Locale locale0 = Locale.forLanguageTag(""6"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"protected void init() {
    List<Rule> rulesList = parsePattern();
    mRules = rulesList.toArray(new Rule[rulesList.size()]);
    int len = 0;
    for (int i = mRules.length; --i >= 0; ) {
        len += mRules[i].estimateLength();
    }
    mMaxLengthEstimate = len;
}","public void test0294() throws Throwable {
    Locale locale0 = Locale.forLanguageTag(""6"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, locale0);
    fastDateFormat0.init();
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Initializes the instance for first use.</p>
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test02104() throws Throwable {
    Locale locale0 = Locale.forLanguageTag(""6"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, locale0);
    fastDateFormat0.init();
    assertEquals(""h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test02105() throws Throwable {
    Locale locale0 = Locale.forLanguageTag(""6"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, locale0);
    fastDateFormat0.init();
    assertEquals(18, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test02106() throws Throwable {
    Locale locale0 = Locale.forLanguageTag(""6"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, locale0);
    fastDateFormat0.init();
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a date formatter instance using the specified style in the
 * default time zone and locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getDateInstance(int style) {
    return getDateInstance(style, null, null);
}","public void test03107() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0);
    assertEquals(2, FastDateFormat.MEDIUM);
}",""
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test03112() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0);
    assertEquals(""EEEE, MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test03113() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test03114() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0);
    assertEquals(31, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"protected String parseToken(String pattern, int[] indexRef) {
    StringBuilder buf = new StringBuilder();
    int i = indexRef[0];
    int length = pattern.length();
    char c = pattern.charAt(i);
    if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {
        // Scan a run of the same character, which indicates a time
        // pattern.
        buf.append(c);
        while (i + 1 < length) {
            char peek = pattern.charAt(i + 1);
            if (peek == c) {
                buf.append(c);
                i++;
            } else {
                break;
            }
        }
    } else {
        // This will identify token as text.
        buf.append('\'');
        boolean inLiteral = false;
        for (; i < length; i++) {
            c = pattern.charAt(i);
            if (c == '\'') {
                if (i + 1 < length && pattern.charAt(i + 1) == '\'') {
                    // '' is treated as escaped '
                    i++;
                    buf.append(c);
                } else {
                    inLiteral = !inLiteral;
                }
            } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {
                i--;
                break;
            } else {
                buf.append(c);
            }
        }
    }
    indexRef[0] = i;
    return buf.toString();
}","public void test03115() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0);
    int[] intArray0 = new int[7];
    String string0 = fastDateFormat0.parseToken(""Urk}#"", intArray0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Performs the parsing of tokens.</p>
 *
 * @param pattern  the pattern
 * @param indexRef  index references
 * @return parsed token
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test03122() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0);
    int[] intArray0 = new int[7];
    String string0 = fastDateFormat0.parseToken(""Urk}#"", intArray0);
    assertEquals(""EEEE, MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test03123() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0);
    int[] intArray0 = new int[7];
    String string0 = fastDateFormat0.parseToken(""Urk}#"", intArray0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test03124() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0);
    int[] intArray0 = new int[7];
    String string0 = fastDateFormat0.parseToken(""Urk}#"", intArray0);
    assertEquals(31, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test04133() throws Throwable {
    Locale locale0 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test04144() throws Throwable {
    Locale locale0 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test04145() throws Throwable {
    Locale locale0 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test04146() throws Throwable {
    Locale locale0 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test04147() throws Throwable {
    Locale locale0 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    boolean boolean0 = fastDateFormat0.getTimeZoneOverridesCalendar();
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test04158() throws Throwable {
    Locale locale0 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    boolean boolean0 = fastDateFormat0.getTimeZoneOverridesCalendar();
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test04159() throws Throwable {
    Locale locale0 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    boolean boolean0 = fastDateFormat0.getTimeZoneOverridesCalendar();
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test04160() throws Throwable {
    Locale locale0 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    boolean boolean0 = fastDateFormat0.getTimeZoneOverridesCalendar();
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public TimeZone getTimeZone() {
    return mTimeZone;
}","public void test05162() throws Throwable {
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    assertNotNull(timeZone0);
}","/**
 * <p>Gets the time zone used by this formatter.</p>
 *
 * <p>This zone is always used for <code>Date</code> formatting.
 * If a <code>Calendar</code> is passed in to be formatted, the
 * time zone on that may be used depending on
 * {@link #getTimeZoneOverridesCalendar()}.</p>
 *
 * @return the time zone
 */"
"public static FastDateFormat getTimeInstance(int style, TimeZone timeZone) {
    return getTimeInstance(style, timeZone, null);
}","public void test05167() throws Throwable {
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(3, timeZone0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets a time formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted time
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test05176() throws Throwable {
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(3, timeZone0);
    assertEquals(10, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test05177() throws Throwable {
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(3, timeZone0);
    assertEquals(""h:mm a"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test05178() throws Throwable {
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(3, timeZone0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = Integer.valueOf(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale != null) {
        key = new Pair(key, locale);
    }
    FastDateFormat format = cTimeInstanceCache.get(key);
    if (format == null) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getTimeInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cTimeInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test06188() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.ITALY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0, locale0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a time formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted time
 * @param locale  optional locale, overrides system locale
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test06200() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.ITALY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0, locale0);
    assertEquals(""H.mm.ss z"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test06201() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.ITALY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0, locale0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test06202() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.ITALY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0, locale0);
    assertEquals(14, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test06203() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.ITALY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0, locale0);
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test06215() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.ITALY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0, locale0);
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    assertEquals(""H.mm.ss z"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test06216() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.ITALY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0, locale0);
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test06217() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.ITALY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0, locale0);
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    assertEquals(14, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test07225() throws Throwable {
    Locale locale0 = Locale.US;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test07236() throws Throwable {
    Locale locale0 = Locale.US;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test07237() throws Throwable {
    Locale locale0 = Locale.US;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test07238() throws Throwable {
    Locale locale0 = Locale.US;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public TimeZone getTimeZone() {
    return mTimeZone;
}","public void test08247() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    assertNotNull(timeZone0);
}","/**
 * <p>Gets the time zone used by this formatter.</p>
 *
 * <p>This zone is always used for <code>Date</code> formatting.
 * If a <code>Calendar</code> is passed in to be formatted, the
 * time zone on that may be used depending on
 * {@link #getTimeZoneOverridesCalendar()}.</p>
 *
 * @return the time zone
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test08252() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""&'C"", timeZone0, locale0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test08267() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""&'C"", timeZone0, locale0);
    assertEquals(2, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test08268() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""&'C"", timeZone0, locale0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test08269() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""&'C"", timeZone0, locale0);
    assertEquals(""&'C"", fastDateFormat0.getPattern());
}",""
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test09270() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test09275() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test09276() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test09277() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test10285() throws Throwable {
    Locale locale0 = Locale.ITALY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""&."", locale0);
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test10296() throws Throwable {
    Locale locale0 = Locale.ITALY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""&."", locale0);
    assertEquals(2, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test10297() throws Throwable {
    Locale locale0 = Locale.ITALY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""&."", locale0);
    assertEquals(""&."", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test10298() throws Throwable {
    Locale locale0 = Locale.ITALY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""&."", locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test11299() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""'L[d"");
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test11304() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""'L[d"");
    assertEquals(""'L[d"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test11305() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""'L[d"");
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test11306() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""'L[d"");
    assertEquals(3, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone) {
    return getDateTimeInstance(dateStyle, timeStyle, timeZone, null);
}","public void test12307() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(1, 1, (TimeZone) null);
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Gets a date/time formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test12312() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(1, 1, (TimeZone) null);
    assertEquals(""MMMM d, yyyy h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test12313() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(1, 1, (TimeZone) null);
    assertEquals(39, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test12314() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(1, 1, (TimeZone) null);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {
    return getDateInstance(style, timeZone, null);
}","public void test13315() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) null);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test13320() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) null);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test13321() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) null);
    assertEquals(""EEEE, MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test13322() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) null);
    assertEquals(31, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test14325() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test14331() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test14332() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test14333() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public StringBuffer format(Date date, StringBuffer buf) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, buf);
}","public void test14338() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    MockDate mockDate0 = new MockDate(3, 89, 1, 4, 648);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Formats a <code>Date</code> object into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param date  the date to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test14346() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    MockDate mockDate0 = new MockDate(3, 89, 1, 4, 648);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test14347() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    MockDate mockDate0 = new MockDate(3, 89, 1, 4, 648);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test14348() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    MockDate mockDate0 = new MockDate(3, 89, 1, 4, 648);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test14349() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    MockDate mockDate0 = new MockDate(3, 89, 1, 4, 648);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertEquals(""Wed Jun 01 14:48:00 GMT 1910"", mockDate0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test15363() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.GERMAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test15375() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.GERMAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test15376() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.GERMAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test15377() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.GERMAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public String format(Date date) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test15379() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.GERMAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    MockDate mockDate0 = new MockDate((-2848), 1, 284, (-2305), (-2305), 1916);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Formats a <code>Date</code> object.</p>
 *
 * @param date  the date to format
 * @return the formatted string
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test15392() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.GERMAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    MockDate mockDate0 = new MockDate((-2848), 1, 284, (-2305), (-2305), 1916);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test15393() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.GERMAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    MockDate mockDate0 = new MockDate((-2848), 1, 284, (-2305), (-2305), 1916);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test15394() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.GERMAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    MockDate mockDate0 = new MockDate((-2848), 1, 284, (-2305), (-2305), 1916);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test15395() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.GERMAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    MockDate mockDate0 = new MockDate((-2848), 1, 284, (-2305), (-2305), 1916);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals(""Mon Aug 04 09:06:56 GMT 949"", mockDate0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test16396() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (Locale) null);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test16401() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (Locale) null);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test16402() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (Locale) null);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test16403() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (Locale) null);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public TimeZone getTimeZone() {
    return mTimeZone;
}","public void test16405() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (Locale) null);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""");
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    assertNotNull(timeZone0);
}","/**
 * <p>Gets the time zone used by this formatter.</p>
 *
 * <p>This zone is always used for <code>Date</code> formatting.
 * If a <code>Calendar</code> is passed in to be formatted, the
 * time zone on that may be used depending on
 * {@link #getTimeZoneOverridesCalendar()}.</p>
 *
 * @return the time zone
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test16410() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (Locale) null);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""");
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    Calendar calendar0 = MockCalendar.getInstance(timeZone0);
    assertNotNull(calendar0);
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public String format(Calendar calendar) {
    return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test16419() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (Locale) null);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""");
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    Calendar calendar0 = MockCalendar.getInstance(timeZone0);
    String string0 = fastDateFormat0.format(calendar0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Formats a <code>Calendar</code> object.</p>
 *
 * @param calendar  the calendar to format
 * @return the formatted string
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test16425() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (Locale) null);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""");
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    Calendar calendar0 = MockCalendar.getInstance(timeZone0);
    String string0 = fastDateFormat0.format(calendar0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test16426() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (Locale) null);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""");
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    Calendar calendar0 = MockCalendar.getInstance(timeZone0);
    String string0 = fastDateFormat0.format(calendar0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test16427() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (Locale) null);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""");
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    Calendar calendar0 = MockCalendar.getInstance(timeZone0);
    String string0 = fastDateFormat0.format(calendar0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public StringBuffer format(long millis, StringBuffer buf) {
    return format(new Date(millis), buf);
}","public void test17450() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((long) 3, stringBuffer0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Formats a milliseond <code>long</code> value into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param millis  the millisecond value to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 * @since 2.1
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test17458() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((long) 3, stringBuffer0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test17459() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((long) 3, stringBuffer0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test17460() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((long) 3, stringBuffer0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {
    Rule[] rules = mRules;
    int len = mRules.length;
    for (int i = 0; i < len; i++) {
        rules[i].appendTo(buf, calendar);
    }
    return buf;
}","public void test18485() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    Calendar calendar0 = mockSimpleDateFormat0.getCalendar();
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""B:>]S[=_Pv8oQ"");
    StringBuffer stringBuffer1 = fastDateFormat0.applyRules(calendar0, stringBuffer0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Performs the formatting by applying the rules to the
 * specified calendar.</p>
 *
 * @param calendar  the calendar to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test18492() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    Calendar calendar0 = mockSimpleDateFormat0.getCalendar();
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""B:>]S[=_Pv8oQ"");
    StringBuffer stringBuffer1 = fastDateFormat0.applyRules(calendar0, stringBuffer0);
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test18493() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    Calendar calendar0 = mockSimpleDateFormat0.getCalendar();
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""B:>]S[=_Pv8oQ"");
    StringBuffer stringBuffer1 = fastDateFormat0.applyRules(calendar0, stringBuffer0);
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test18494() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    Calendar calendar0 = mockSimpleDateFormat0.getCalendar();
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""B:>]S[=_Pv8oQ"");
    StringBuffer stringBuffer1 = fastDateFormat0.applyRules(calendar0, stringBuffer0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"protected String parseToken(String pattern, int[] indexRef) {
    StringBuilder buf = new StringBuilder();
    int i = indexRef[0];
    int length = pattern.length();
    char c = pattern.charAt(i);
    if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {
        // Scan a run of the same character, which indicates a time
        // pattern.
        buf.append(c);
        while (i + 1 < length) {
            char peek = pattern.charAt(i + 1);
            if (peek == c) {
                buf.append(c);
                i++;
            } else {
                break;
            }
        }
    } else {
        // This will identify token as text.
        buf.append('\'');
        boolean inLiteral = false;
        for (; i < length; i++) {
            c = pattern.charAt(i);
            if (c == '\'') {
                if (i + 1 < length && pattern.charAt(i + 1) == '\'') {
                    // '' is treated as escaped '
                    i++;
                    buf.append(c);
                } else {
                    inLiteral = !inLiteral;
                }
            } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {
                i--;
                break;
            } else {
                buf.append(c);
            }
        }
    }
    indexRef[0] = i;
    return buf.toString();
}","public void test19514() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (Locale) null);
    int[] intArray0 = new int[5];
    // Undeclared exception!
    try {
        fastDateFormat0.parseToken("""", intArray0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * <p>Performs the parsing of tokens.</p>
 *
 * @param pattern  the pattern
 * @param indexRef  index references
 * @return parsed token
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a date/time formatter instance using the specified style
 * in the default time zone and locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle) {
    return getDateTimeInstance(dateStyle, timeStyle, null, null);
}","public void test20515() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    assertEquals(2, FastDateFormat.MEDIUM);
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test20520() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    assertEquals(50, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test20521() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test20522() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    assertEquals(""EEEE, MMMM d, yyyy h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"protected String parseToken(String pattern, int[] indexRef) {
    StringBuilder buf = new StringBuilder();
    int i = indexRef[0];
    int length = pattern.length();
    char c = pattern.charAt(i);
    if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {
        // Scan a run of the same character, which indicates a time
        // pattern.
        buf.append(c);
        while (i + 1 < length) {
            char peek = pattern.charAt(i + 1);
            if (peek == c) {
                buf.append(c);
                i++;
            } else {
                break;
            }
        }
    } else {
        // This will identify token as text.
        buf.append('\'');
        boolean inLiteral = false;
        for (; i < length; i++) {
            c = pattern.charAt(i);
            if (c == '\'') {
                if (i + 1 < length && pattern.charAt(i + 1) == '\'') {
                    // '' is treated as escaped '
                    i++;
                    buf.append(c);
                } else {
                    inLiteral = !inLiteral;
                }
            } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {
                i--;
                break;
            } else {
                buf.append(c);
            }
        }
    }
    indexRef[0] = i;
    return buf.toString();
}","public void test20523() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    int[] intArray0 = new int[6];
    // Undeclared exception!
    try {
        fastDateFormat0.parseToken((String) null, intArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Performs the parsing of tokens.</p>
 *
 * @param pattern  the pattern
 * @param indexRef  index references
 * @return parsed token
 */"
"protected String parseToken(String pattern, int[] indexRef) {
    StringBuilder buf = new StringBuilder();
    int i = indexRef[0];
    int length = pattern.length();
    char c = pattern.charAt(i);
    if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {
        // Scan a run of the same character, which indicates a time
        // pattern.
        buf.append(c);
        while (i + 1 < length) {
            char peek = pattern.charAt(i + 1);
            if (peek == c) {
                buf.append(c);
                i++;
            } else {
                break;
            }
        }
    } else {
        // This will identify token as text.
        buf.append('\'');
        boolean inLiteral = false;
        for (; i < length; i++) {
            c = pattern.charAt(i);
            if (c == '\'') {
                if (i + 1 < length && pattern.charAt(i + 1) == '\'') {
                    // '' is treated as escaped '
                    i++;
                    buf.append(c);
                } else {
                    inLiteral = !inLiteral;
                }
            } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {
                i--;
                break;
            } else {
                buf.append(c);
            }
        }
    }
    indexRef[0] = i;
    return buf.toString();
}","public void test21532() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    int[] intArray0 = new int[0];
    // Undeclared exception!
    try {
        fastDateFormat0.parseToken(""u+drihRG.lY\""~6"", intArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Performs the parsing of tokens.</p>
 *
 * @param pattern  the pattern
 * @param indexRef  index references
 * @return parsed token
 */"
"// Constructor
//-----------------------------------------------------------------------
/**
 * <p>Constructs a new FastDateFormat.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  time zone to use, <code>null</code> means use
 *  default for <code>Date</code> and value within for
 *  <code>Calendar</code>
 * @param locale  locale, <code>null</code> means use system
 *  default
 * @throws IllegalArgumentException if pattern is invalid or
 *  <code>null</code>
 */
protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {
    super();
    if (pattern == null) {
        throw new IllegalArgumentException(""The pattern must not be null"");
    }
    mPattern = pattern;
    mTimeZoneForced = (timeZone != null);
    if (timeZone == null) {
        timeZone = TimeZone.getDefault();
    }
    mTimeZone = timeZone;
    mLocaleForced = (locale != null);
    if (locale == null) {
        locale = Locale.getDefault();
    }
    mLocale = locale;
}","public void test22546() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3, """");
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", simpleTimeZone0, locale0);
    assertEquals(0, FastDateFormat.FULL);
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test22562() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3, """");
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", simpleTimeZone0, locale0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test22563() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3, """");
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", simpleTimeZone0, locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test22564() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3, """");
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", simpleTimeZone0, locale0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"// Parsing
//-----------------------------------------------------------------------
/**
 * <p>Parsing is not supported.</p>
 *
 * @param source  the string to parse
 * @param pos  the parsing position
 * @return <code>null</code> as not supported
 */
@Override
public Object parseObject(String source, ParsePosition pos) {
    pos.setIndex(0);
    pos.setErrorIndex(0);
    return null;
}","public void test22565() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3, """");
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", simpleTimeZone0, locale0);
    // Undeclared exception!
    try {
        fastDateFormat0.parseObject(""2;Og@Nt"", (ParsePosition) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Gets the time zone display name, using a cache for performance.</p>
 *
 * @param tz  the zone to query
 * @param daylight  true if daylight savings
 * @param style  the style to use <code>TimeZone.LONG</code>
 *  or <code>TimeZone.SHORT</code>
 * @param locale  the locale to use
 * @return the textual name of the time zone
 */
static synchronized String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {
    Object key = new TimeZoneDisplayKey(tz, daylight, style, locale);
    String value = cTimeZoneDisplayCache.get(key);
    if (value == null) {
        // This is a very slow call, so cache the results.
        value = tz.getDisplayName(daylight, style, locale);
        cTimeZoneDisplayCache.put(key, value);
    }
    return value;
}","public void test23572() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3673, """");
    // Undeclared exception!
    try {
        FastDateFormat.getTimeZoneDisplay(simpleTimeZone0, true, 3673, (Locale) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat$TimeZoneDisplayKey"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Gets the time zone display name, using a cache for performance.</p>
 *
 * @param tz  the zone to query
 * @param daylight  true if daylight savings
 * @param style  the style to use <code>TimeZone.LONG</code>
 *  or <code>TimeZone.SHORT</code>
 * @param locale  the locale to use
 * @return the textual name of the time zone
 */
static synchronized String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {
    Object key = new TimeZoneDisplayKey(tz, daylight, style, locale);
    String value = cTimeZoneDisplayCache.get(key);
    if (value == null) {
        // This is a very slow call, so cache the results.
        value = tz.getDisplayName(daylight, style, locale);
        cTimeZoneDisplayCache.put(key, value);
    }
    return value;
}","public void test24586() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""org.apache.commons.lang3.time.FastDateFormat$TextField"");
    Locale locale0 = Locale.KOREA;
    // Undeclared exception!
    try {
        FastDateFormat.getTimeZoneDisplay(simpleTimeZone0, true, 122, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal style: 122
        //
        verifyException(""java.util.TimeZone"", e);
    }
}",""
"public static FastDateFormat getTimeInstance(int style, TimeZone timeZone) {
    return getTimeInstance(style, timeZone, null);
}","public void test25589() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    // Undeclared exception!
    try {
        FastDateFormat.getTimeInstance(1390, timeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style 1390
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a time formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted time
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */"
"public static FastDateFormat getTimeInstance(int style, Locale locale) {
    return getTimeInstance(style, null, locale);
}","public void test26590() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getTimeInstance(518, (Locale) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style 518
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a time formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a time formatter instance using the specified style in the
 * default time zone and locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getTimeInstance(int style) {
    return getTimeInstance(style, null, null);
}","public void test27591() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getTimeInstance((-438));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style -438
        //
        verifyException(""java.text.DateFormat"", e);
    }
}",""
"public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone) {
    return getDateTimeInstance(dateStyle, timeStyle, timeZone, null);
}","public void test28592() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getDateTimeInstance(276, 276, (TimeZone) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style 276
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date/time formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */"
"public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, Locale locale) {
    return getDateTimeInstance(dateStyle, timeStyle, null, locale);
}","public void test29600() throws Throwable {
    Locale locale0 = Locale.CANADA;
    // Undeclared exception!
    try {
        FastDateFormat.getDateTimeInstance((-750), (-750), locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style -750
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date/time formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a date/time formatter instance using the specified style
 * in the default time zone and locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle) {
    return getDateTimeInstance(dateStyle, timeStyle, null, null);
}","public void test30601() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getDateTimeInstance(11, 3);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style 11
        //
        verifyException(""java.text.DateFormat"", e);
    }
}",""
"public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {
    return getDateInstance(style, timeZone, null);
}","public void test31604() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    // Undeclared exception!
    try {
        FastDateFormat.getDateInstance((-2650), timeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style -2650
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"public static FastDateFormat getDateInstance(int style, Locale locale) {
    return getDateInstance(style, null, locale);
}","public void test32612() throws Throwable {
    Locale locale0 = Locale.ENGLISH;
    // Undeclared exception!
    try {
        FastDateFormat.getDateInstance(43, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style 43
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a date formatter instance using the specified style in the
 * default time zone and locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getDateInstance(int style) {
    return getDateInstance(style, null, null);
}","public void test33613() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getDateInstance(1559);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style 1559
        //
        verifyException(""java.text.DateFormat"", e);
    }
}",""
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test34614() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test34619() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test34620() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test34621() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public String format(Date date) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test34622() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    // Undeclared exception!
    try {
        fastDateFormat0.format((Date) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.Calendar"", e);
    }
}","/**
 * <p>Formats a <code>Date</code> object.</p>
 *
 * @param date  the date to format
 * @return the formatted string
 */"
"// Constructor
//-----------------------------------------------------------------------
/**
 * <p>Constructs a new FastDateFormat.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  time zone to use, <code>null</code> means use
 *  default for <code>Date</code> and value within for
 *  <code>Calendar</code>
 * @param locale  locale, <code>null</code> means use system
 *  default
 * @throws IllegalArgumentException if pattern is invalid or
 *  <code>null</code>
 */
protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {
    super();
    if (pattern == null) {
        throw new IllegalArgumentException(""The pattern must not be null"");
    }
    mPattern = pattern;
    mTimeZoneForced = (timeZone != null);
    if (timeZone == null) {
        timeZone = TimeZone.getDefault();
    }
    mTimeZone = timeZone;
    mLocaleForced = (locale != null);
    if (locale == null) {
        locale = Locale.getDefault();
    }
    mLocale = locale;
}","public void test35630() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = new FastDateFormat(""9]Y~%Db~VyH"", (TimeZone) null, locale0);
    assertEquals(0, FastDateFormat.FULL);
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test35641() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = new FastDateFormat(""9]Y~%Db~VyH"", (TimeZone) null, locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test35642() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = new FastDateFormat(""9]Y~%Db~VyH"", (TimeZone) null, locale0);
    assertEquals(""9]Y~%Db~VyH"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test35643() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = new FastDateFormat(""9]Y~%Db~VyH"", (TimeZone) null, locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public StringBuffer format(Calendar calendar, StringBuffer buf) {
    if (mTimeZoneForced) {
        calendar = (Calendar) calendar.clone();
        calendar.setTimeZone(mTimeZone);
    }
    return applyRules(calendar, buf);
}","public void test35645() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = new FastDateFormat(""9]Y~%Db~VyH"", (TimeZone) null, locale0);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(1, 1, 0, 0, 3);
    // Undeclared exception!
    try {
        fastDateFormat0.format((Calendar) mockGregorianCalendar0, (StringBuffer) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Formats a <code>Calendar</code> object into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param calendar  the calendar to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, Locale locale) {
    return getDateTimeInstance(dateStyle, timeStyle, null, locale);
}","public void test36653() throws Throwable {
    Locale locale0 = Locale.ROOT;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a date/time formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test36664() throws Throwable {
    Locale locale0 = Locale.ROOT;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test36665() throws Throwable {
    Locale locale0 = Locale.ROOT;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    assertEquals(""EEEE, MMMM d, yyyy h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test36666() throws Throwable {
    Locale locale0 = Locale.ROOT;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    assertEquals(50, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public StringBuffer format(long millis, StringBuffer buf) {
    return format(new Date(millis), buf);
}","public void test36667() throws Throwable {
    Locale locale0 = Locale.ROOT;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    // Undeclared exception!
    try {
        fastDateFormat0.format((-2437L), (StringBuffer) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat$TextField"", e);
    }
}","/**
 * <p>Formats a milliseond <code>long</code> value into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param millis  the millisecond value to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 * @since 2.1
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test37676() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat0);
    assertEquals(2, FastDateFormat.MEDIUM);
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test37681() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat0);
    assertEquals(50, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test37682() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat0);
    assertEquals(""EEEE, MMMM d, yyyy h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test37683() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public StringBuffer format(Calendar calendar, StringBuffer buf) {
    if (mTimeZoneForced) {
        calendar = (Calendar) calendar.clone();
        calendar.setTimeZone(mTimeZone);
    }
    return applyRules(calendar, buf);
}","public void test38723() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 1, (-2177), 0, 0, 54);
    char[] charArray0 = new char[4];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Calendar) mockGregorianCalendar0, stringBuffer0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Formats a <code>Calendar</code> object into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param calendar  the calendar to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test38731() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 1, (-2177), 0, 0, 54);
    char[] charArray0 = new char[4];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Calendar) mockGregorianCalendar0, stringBuffer0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test38732() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 1, (-2177), 0, 0, 54);
    char[] charArray0 = new char[4];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Calendar) mockGregorianCalendar0, stringBuffer0);
    assertEquals(""EEEE, MMMM d, yyyy h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test38733() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 1, (-2177), 0, 0, 54);
    char[] charArray0 = new char[4];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Calendar) mockGregorianCalendar0, stringBuffer0);
    assertEquals(50, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test38737() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 1, (-2177), 0, 0, 54);
    char[] charArray0 = new char[4];
    CharBuffer charBuffer0 = CharBuffer.wrap(charArray0);
    StringBuffer stringBuffer0 = new StringBuffer(charBuffer0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Calendar) mockGregorianCalendar0, stringBuffer0);
    assertEquals(""org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=-62352892746000,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\""GMT\"",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=0,YEAR=7,MONTH=1,WEEK_OF_YEAR=7,WEEK_OF_MONTH=2,DAY_OF_MONTH=14,DAY_OF_YEAR=45,DAY_OF_WEEK=7,DAY_OF_WEEK_IN_MONTH=2,AM_PM=0,HOUR=0,HOUR_OF_DAY=0,MINUTE=0,SECOND=54,MILLISECOND=0,ZONE_OFFSET=0,DST_OFFSET=0]"", mockGregorianCalendar0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test39756() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test39762() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test39763() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    assertEquals(""k"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test39764() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    assertEquals(4, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test39785() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    assertEquals(3, FastDateFormat.SHORT);
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test39791() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test39792() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    assertEquals(""k"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test39793() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    assertEquals(4, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, Locale locale) {
    return getDateTimeInstance(dateStyle, timeStyle, null, locale);
}","public void test39804() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Gets a date/time formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test39817() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    assertFalse(fastDateFormat1.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test39818() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    assertEquals(27, fastDateFormat1.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test39819() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    assertEquals(""dd/MM/yy h:mm:ss z a"", fastDateFormat1.getPattern());
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test39821() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    assertFalse(fastDateFormat1.equals((Object) fastDateFormat0));
}",""
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test39822() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    assertEquals(3, FastDateFormat.SHORT);
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test39830() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test39831() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    assertEquals(""k"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test39832() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    assertEquals(4, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test39833() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    assertFalse(fastDateFormat0.equals((Object) fastDateFormat1));
}",""
"public TimeZone getTimeZone() {
    return mTimeZone;
}","public void test39835() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets the time zone used by this formatter.</p>
 *
 * <p>This zone is always used for <code>Date</code> formatting.
 * If a <code>Calendar</code> is passed in to be formatted, the
 * time zone on that may be used depending on
 * {@link #getTimeZoneOverridesCalendar()}.</p>
 *
 * @return the time zone
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test39844() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test39845() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    assertEquals(""k"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test39846() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    assertEquals(4, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test39848() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    assertFalse(fastDateFormat0.equals((Object) fastDateFormat1));
}",""
"public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {
    return getDateInstance(style, timeZone, null);
}","public void test39849() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test39858() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    assertEquals(""M/d/yy"", fastDateFormat2.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test39859() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    assertEquals(10, fastDateFormat2.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test39860() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    assertTrue(fastDateFormat2.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test39861() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    assertFalse(fastDateFormat2.equals((Object) fastDateFormat1));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test39862() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    assertFalse(fastDateFormat2.equals((Object) fastDateFormat0));
}",""
"// Parsing
//-----------------------------------------------------------------------
/**
 * <p>Parsing is not supported.</p>
 *
 * @param source  the string to parse
 * @param pos  the parsing position
 * @return <code>null</code> as not supported
 */
@Override
public Object parseObject(String source, ParsePosition pos) {
    pos.setIndex(0);
    pos.setErrorIndex(0);
    return null;
}","public void test39867() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    assertEquals(1, FastDateFormat.LONG);
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test39881() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    assertFalse(fastDateFormat1.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test39882() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    assertEquals(27, fastDateFormat1.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test39883() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    assertEquals(""dd/MM/yy h:mm:ss z a"", fastDateFormat1.getPattern());
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test39888() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    assertFalse(fastDateFormat1.equals((Object) fastDateFormat0));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test39889() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    assertFalse(fastDateFormat1.equals((Object) fastDateFormat2));
}",""
"public StringBuffer format(Date date, StringBuffer buf) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, buf);
}","public void test39924() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Formats a <code>Date</code> object into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param date  the date to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test39937() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test39938() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertEquals(""k"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test39939() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertEquals(4, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test39942() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertEquals(""Sat Feb 01 12:12:00 GMT 1902"", mockDate0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test39943() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertFalse(fastDateFormat0.equals((Object) fastDateFormat1));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test39944() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertFalse(fastDateFormat0.equals((Object) fastDateFormat2));
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test39962() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test39963() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    assertEquals(""k"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test39964() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    assertEquals(4, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test39969() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    assertEquals(""Sat Feb 01 12:12:00 GMT 1902"", mockDate0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test39970() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    assertFalse(fastDateFormat0.equals((Object) fastDateFormat1));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test39971() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    assertFalse(fastDateFormat0.equals((Object) fastDateFormat2));
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test391014() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(945);
    StringBuffer stringBuffer3 = decimalFormat0.format((-1837L), stringBuffer1, fieldPosition0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test391015() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(945);
    StringBuffer stringBuffer3 = decimalFormat0.format((-1837L), stringBuffer1, fieldPosition0);
    assertEquals(""k"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test391016() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(945);
    StringBuffer stringBuffer3 = decimalFormat0.format((-1837L), stringBuffer1, fieldPosition0);
    assertEquals(4, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test391025() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(945);
    StringBuffer stringBuffer3 = decimalFormat0.format((-1837L), stringBuffer1, fieldPosition0);
    assertEquals(""Sat Feb 01 12:12:00 GMT 1902"", mockDate0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test391026() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(945);
    StringBuffer stringBuffer3 = decimalFormat0.format((-1837L), stringBuffer1, fieldPosition0);
    assertFalse(fastDateFormat0.equals((Object) fastDateFormat1));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test391027() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(945);
    StringBuffer stringBuffer3 = decimalFormat0.format((-1837L), stringBuffer1, fieldPosition0);
    assertFalse(fastDateFormat0.equals((Object) fastDateFormat2));
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test391072() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(945);
    StringBuffer stringBuffer3 = decimalFormat0.format((-1837L), stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer4 = stringBuffer3.append(""%#AZm[miAtF$[5E-"");
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test391073() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(945);
    StringBuffer stringBuffer3 = decimalFormat0.format((-1837L), stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer4 = stringBuffer3.append(""%#AZm[miAtF$[5E-"");
    assertEquals(""k"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test391074() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(945);
    StringBuffer stringBuffer3 = decimalFormat0.format((-1837L), stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer4 = stringBuffer3.append(""%#AZm[miAtF$[5E-"");
    assertEquals(4, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test391085() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(945);
    StringBuffer stringBuffer3 = decimalFormat0.format((-1837L), stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer4 = stringBuffer3.append(""%#AZm[miAtF$[5E-"");
    assertEquals(""Sat Feb 01 12:12:00 GMT 1902"", mockDate0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test391086() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(945);
    StringBuffer stringBuffer3 = decimalFormat0.format((-1837L), stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer4 = stringBuffer3.append(""%#AZm[miAtF$[5E-"");
    assertFalse(fastDateFormat0.equals((Object) fastDateFormat1));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test391087() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(945);
    StringBuffer stringBuffer3 = decimalFormat0.format((-1837L), stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer4 = stringBuffer3.append(""%#AZm[miAtF$[5E-"");
    assertFalse(fastDateFormat0.equals((Object) fastDateFormat2));
}",""
"public StringBuffer format(Date date, StringBuffer buf) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, buf);
}","public void test391088() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(945);
    StringBuffer stringBuffer3 = decimalFormat0.format((-1837L), stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer4 = stringBuffer3.append(""%#AZm[miAtF$[5E-"");
    StringBuffer stringBuffer5 = fastDateFormat1.format((Date) mockDate0, stringBuffer3);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Formats a <code>Date</code> object into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param date  the date to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test391143() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(945);
    StringBuffer stringBuffer3 = decimalFormat0.format((-1837L), stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer4 = stringBuffer3.append(""%#AZm[miAtF$[5E-"");
    StringBuffer stringBuffer5 = fastDateFormat1.format((Date) mockDate0, stringBuffer3);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test391144() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(945);
    StringBuffer stringBuffer3 = decimalFormat0.format((-1837L), stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer4 = stringBuffer3.append(""%#AZm[miAtF$[5E-"");
    StringBuffer stringBuffer5 = fastDateFormat1.format((Date) mockDate0, stringBuffer3);
    assertEquals(""k"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test391145() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(945);
    StringBuffer stringBuffer3 = decimalFormat0.format((-1837L), stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer4 = stringBuffer3.append(""%#AZm[miAtF$[5E-"");
    StringBuffer stringBuffer5 = fastDateFormat1.format((Date) mockDate0, stringBuffer3);
    assertEquals(4, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test391162() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(945);
    StringBuffer stringBuffer3 = decimalFormat0.format((-1837L), stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer4 = stringBuffer3.append(""%#AZm[miAtF$[5E-"");
    StringBuffer stringBuffer5 = fastDateFormat1.format((Date) mockDate0, stringBuffer3);
    assertFalse(fastDateFormat1.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test391163() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(945);
    StringBuffer stringBuffer3 = decimalFormat0.format((-1837L), stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer4 = stringBuffer3.append(""%#AZm[miAtF$[5E-"");
    StringBuffer stringBuffer5 = fastDateFormat1.format((Date) mockDate0, stringBuffer3);
    assertEquals(27, fastDateFormat1.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test391164() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(945);
    StringBuffer stringBuffer3 = decimalFormat0.format((-1837L), stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer4 = stringBuffer3.append(""%#AZm[miAtF$[5E-"");
    StringBuffer stringBuffer5 = fastDateFormat1.format((Date) mockDate0, stringBuffer3);
    assertEquals(""dd/MM/yy h:mm:ss z a"", fastDateFormat1.getPattern());
}",""
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test391165() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(945);
    StringBuffer stringBuffer3 = decimalFormat0.format((-1837L), stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer4 = stringBuffer3.append(""%#AZm[miAtF$[5E-"");
    StringBuffer stringBuffer5 = fastDateFormat1.format((Date) mockDate0, stringBuffer3);
    assertEquals(""Sat Feb 01 12:12:00 GMT 1902"", mockDate0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test391166() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(945);
    StringBuffer stringBuffer3 = decimalFormat0.format((-1837L), stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer4 = stringBuffer3.append(""%#AZm[miAtF$[5E-"");
    StringBuffer stringBuffer5 = fastDateFormat1.format((Date) mockDate0, stringBuffer3);
    assertFalse(fastDateFormat0.equals((Object) fastDateFormat1));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test391167() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(945);
    StringBuffer stringBuffer3 = decimalFormat0.format((-1837L), stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer4 = stringBuffer3.append(""%#AZm[miAtF$[5E-"");
    StringBuffer stringBuffer5 = fastDateFormat1.format((Date) mockDate0, stringBuffer3);
    assertFalse(fastDateFormat0.equals((Object) fastDateFormat2));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test391169() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(945);
    StringBuffer stringBuffer3 = decimalFormat0.format((-1837L), stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer4 = stringBuffer3.append(""%#AZm[miAtF$[5E-"");
    StringBuffer stringBuffer5 = fastDateFormat1.format((Date) mockDate0, stringBuffer3);
    assertFalse(fastDateFormat1.equals((Object) fastDateFormat0));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test391170() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""k"", timeZone0);
    Locale locale0 = Locale.CANADA;
    ZoneId zoneId0 = timeZone0.toZoneId();
    boolean boolean0 = timeZone0.observesDaylightTime();
    String string0 = timeZone0.getDisplayName(locale0);
    boolean boolean1 = fastDateFormat0.equals((Object) null);
    Locale locale1 = Locale.forLanguageTag("""");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 1, locale0);
    String string1 = fastDateFormat0.getPattern();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateInstance(3, timeZone0);
    ParsePosition parsePosition0 = new ParsePosition((-888));
    Object object0 = fastDateFormat1.parseObject("""", parsePosition0);
    String string2 = locale1.getDisplayName();
    MockDate mockDate0 = new MockDate(2, 1, 2, 3, (-888), 0);
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    StringBuffer stringBuffer2 = stringBuffer1.append(0);
    FieldPosition fieldPosition0 = new FieldPosition(945);
    StringBuffer stringBuffer3 = decimalFormat0.format((-1837L), stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer4 = stringBuffer3.append(""%#AZm[miAtF$[5E-"");
    StringBuffer stringBuffer5 = fastDateFormat1.format((Date) mockDate0, stringBuffer3);
    assertFalse(fastDateFormat1.equals((Object) fastDateFormat2));
}",""
"public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone, Locale locale) {
    Object key = new Pair(Integer.valueOf(dateStyle), Integer.valueOf(timeStyle));
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale == null) {
        locale = Locale.getDefault();
    }
    key = new Pair(key, locale);
    FastDateFormat format = cDateTimeInstanceCache.get(key);
    if (format == null) {
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cDateTimeInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date time pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test401183() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone((-1907), ""$(@RsifXZVY_3`"");
    Locale locale0 = new Locale(""0|@e(WN#v="", """", ""0|@e(WN#v="");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, (TimeZone) simpleTimeZone0, locale0);
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Gets a date/time formatter instance using the specified style,
 * time zone and locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test401198() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone((-1907), ""$(@RsifXZVY_3`"");
    Locale locale0 = new Locale(""0|@e(WN#v="", """", ""0|@e(WN#v="");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, (TimeZone) simpleTimeZone0, locale0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test401199() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone((-1907), ""$(@RsifXZVY_3`"");
    Locale locale0 = new Locale(""0|@e(WN#v="", """", ""0|@e(WN#v="");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, (TimeZone) simpleTimeZone0, locale0);
    assertEquals(55, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test401200() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone((-1907), ""$(@RsifXZVY_3`"");
    Locale locale0 = new Locale(""0|@e(WN#v="", """", ""0|@e(WN#v="");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, (TimeZone) simpleTimeZone0, locale0);
    assertEquals(""EEEE, MMMM d, yyyy h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone, Locale locale) {
    Object key = new Pair(Integer.valueOf(dateStyle), Integer.valueOf(timeStyle));
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale == null) {
        locale = Locale.getDefault();
    }
    key = new Pair(key, locale);
    FastDateFormat format = cDateTimeInstanceCache.get(key);
    if (format == null) {
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cDateTimeInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date time pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test411208() throws Throwable {
    Locale locale0 = Locale.CHINESE;
    // Undeclared exception!
    try {
        FastDateFormat.getDateTimeInstance(801, 2210, (TimeZone) null, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style 2210
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date/time formatter instance using the specified style,
 * time zone and locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 */"
"public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = Integer.valueOf(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale != null) {
        key = new Pair(key, locale);
    }
    FastDateFormat format = cTimeInstanceCache.get(key);
    if (format == null) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getTimeInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cTimeInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test421211() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""org.apache.commons.lang3.time.FastDateFormat$TimeZoneDisplayKey"");
    // Undeclared exception!
    try {
        FastDateFormat.getTimeInstance((-978), timeZone0, (Locale) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style -978
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a time formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted time
 * @param locale  optional locale, overrides system locale
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 */"
"public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = Integer.valueOf(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale == null) {
        locale = Locale.getDefault();
    }
    key = new Pair(key, locale);
    FastDateFormat format = cDateInstanceCache.get(key);
    if (format == null) {
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cDateInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test431221() throws Throwable {
    Locale locale0 = Locale.ENGLISH;
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0, locale0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets a date formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test431233() throws Throwable {
    Locale locale0 = Locale.ENGLISH;
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0, locale0);
    assertEquals(""EEEE, MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test431234() throws Throwable {
    Locale locale0 = Locale.ENGLISH;
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0, locale0);
    assertEquals(31, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test431235() throws Throwable {
    Locale locale0 = Locale.ENGLISH;
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0, locale0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = Integer.valueOf(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale == null) {
        locale = Locale.getDefault();
    }
    key = new Pair(key, locale);
    FastDateFormat format = cDateInstanceCache.get(key);
    if (format == null) {
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cDateInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test441236() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getDateInstance(65, (TimeZone) null, (Locale) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style 65
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 */"
"public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {
    return getDateInstance(style, timeZone, null);
}","public void test451265() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    TimeZone.setDefault(timeZone0);
    Locale locale0 = Locale.CANADA_FRENCH;
    String string0 = timeZone0.getDisplayName(false, 0, locale0);
    String string1 = timeZone0.getDisplayName(false, 0, locale0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test451271() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    TimeZone.setDefault(timeZone0);
    Locale locale0 = Locale.CANADA_FRENCH;
    String string0 = timeZone0.getDisplayName(false, 0, locale0);
    String string1 = timeZone0.getDisplayName(false, 0, locale0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test451272() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    TimeZone.setDefault(timeZone0);
    Locale locale0 = Locale.CANADA_FRENCH;
    String string0 = timeZone0.getDisplayName(false, 0, locale0);
    String string1 = timeZone0.getDisplayName(false, 0, locale0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0);
    assertEquals(""EEEE, MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test451273() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    TimeZone.setDefault(timeZone0);
    Locale locale0 = Locale.CANADA_FRENCH;
    String string0 = timeZone0.getDisplayName(false, 0, locale0);
    String string1 = timeZone0.getDisplayName(false, 0, locale0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0);
    assertEquals(31, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test451440() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    TimeZone.setDefault(timeZone0);
    Locale locale0 = Locale.CANADA_FRENCH;
    String string0 = timeZone0.getDisplayName(false, 0, locale0);
    String string1 = timeZone0.getDisplayName(false, 0, locale0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0);
    Long long0 = new Long(1L);
    boolean boolean0 = timeZone0.observesDaylightTime();
    DecimalFormat decimalFormat0 = (DecimalFormat) NumberFormat.getPercentInstance(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""GMT"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = decimalFormat0.format(0.0, stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer2 = stringBuffer0.append((CharSequence) ""GMT"");
    StringBuffer stringBuffer3 = stringBuffer1.insert(0, true);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
    StringBuffer stringBuffer4 = stringBuffer1.append((Object) mockGregorianCalendar0);
    assertEquals(""org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=1392409281320,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\""GMT\"",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2014,MONTH=1,WEEK_OF_YEAR=7,WEEK_OF_MONTH=3,DAY_OF_MONTH=14,DAY_OF_YEAR=45,DAY_OF_WEEK=6,DAY_OF_WEEK_IN_MONTH=2,AM_PM=1,HOUR=8,HOUR_OF_DAY=20,MINUTE=21,SECOND=21,MILLISECOND=320,ZONE_OFFSET=0,DST_OFFSET=0]"", mockGregorianCalendar0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"// Format methods
//-----------------------------------------------------------------------
/**
 * <p>Formats a <code>Date</code>, <code>Calendar</code> or
 * <code>Long</code> (milliseconds) object.</p>
 *
 * @param obj  the object to format
 * @param toAppendTo  the buffer to append to
 * @param pos  the position - ignored
 * @return the buffer passed in
 */
@Override
public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
    if (obj instanceof Date) {
        return format((Date) obj, toAppendTo);
    } else if (obj instanceof Calendar) {
        return format((Calendar) obj, toAppendTo);
    } else if (obj instanceof Long) {
        return format(((Long) obj).longValue(), toAppendTo);
    } else {
        throw new IllegalArgumentException(""Unknown class: "" + (obj == null ? ""<null>"" : obj.getClass().getName()));
    }
}","public void test451444() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    TimeZone.setDefault(timeZone0);
    Locale locale0 = Locale.CANADA_FRENCH;
    String string0 = timeZone0.getDisplayName(false, 0, locale0);
    String string1 = timeZone0.getDisplayName(false, 0, locale0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0);
    Long long0 = new Long(1L);
    boolean boolean0 = timeZone0.observesDaylightTime();
    DecimalFormat decimalFormat0 = (DecimalFormat) NumberFormat.getPercentInstance(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""GMT"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = decimalFormat0.format(0.0, stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer2 = stringBuffer0.append((CharSequence) ""GMT"");
    StringBuffer stringBuffer3 = stringBuffer1.insert(0, true);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
    StringBuffer stringBuffer4 = stringBuffer1.append((Object) mockGregorianCalendar0);
    StringBuffer stringBuffer5 = fastDateFormat0.format((Object) long0, stringBuffer1, fieldPosition0);
    assertEquals(3, FastDateFormat.SHORT);
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test451473() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    TimeZone.setDefault(timeZone0);
    Locale locale0 = Locale.CANADA_FRENCH;
    String string0 = timeZone0.getDisplayName(false, 0, locale0);
    String string1 = timeZone0.getDisplayName(false, 0, locale0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0);
    Long long0 = new Long(1L);
    boolean boolean0 = timeZone0.observesDaylightTime();
    DecimalFormat decimalFormat0 = (DecimalFormat) NumberFormat.getPercentInstance(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""GMT"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = decimalFormat0.format(0.0, stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer2 = stringBuffer0.append((CharSequence) ""GMT"");
    StringBuffer stringBuffer3 = stringBuffer1.insert(0, true);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
    StringBuffer stringBuffer4 = stringBuffer1.append((Object) mockGregorianCalendar0);
    StringBuffer stringBuffer5 = fastDateFormat0.format((Object) long0, stringBuffer1, fieldPosition0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test451474() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    TimeZone.setDefault(timeZone0);
    Locale locale0 = Locale.CANADA_FRENCH;
    String string0 = timeZone0.getDisplayName(false, 0, locale0);
    String string1 = timeZone0.getDisplayName(false, 0, locale0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0);
    Long long0 = new Long(1L);
    boolean boolean0 = timeZone0.observesDaylightTime();
    DecimalFormat decimalFormat0 = (DecimalFormat) NumberFormat.getPercentInstance(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""GMT"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = decimalFormat0.format(0.0, stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer2 = stringBuffer0.append((CharSequence) ""GMT"");
    StringBuffer stringBuffer3 = stringBuffer1.insert(0, true);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
    StringBuffer stringBuffer4 = stringBuffer1.append((Object) mockGregorianCalendar0);
    StringBuffer stringBuffer5 = fastDateFormat0.format((Object) long0, stringBuffer1, fieldPosition0);
    assertEquals(""EEEE, MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test451475() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    TimeZone.setDefault(timeZone0);
    Locale locale0 = Locale.CANADA_FRENCH;
    String string0 = timeZone0.getDisplayName(false, 0, locale0);
    String string1 = timeZone0.getDisplayName(false, 0, locale0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0);
    Long long0 = new Long(1L);
    boolean boolean0 = timeZone0.observesDaylightTime();
    DecimalFormat decimalFormat0 = (DecimalFormat) NumberFormat.getPercentInstance(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""GMT"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = decimalFormat0.format(0.0, stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer2 = stringBuffer0.append((CharSequence) ""GMT"");
    StringBuffer stringBuffer3 = stringBuffer1.insert(0, true);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
    StringBuffer stringBuffer4 = stringBuffer1.append((Object) mockGregorianCalendar0);
    StringBuffer stringBuffer5 = fastDateFormat0.format((Object) long0, stringBuffer1, fieldPosition0);
    assertEquals(31, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Format methods
//-----------------------------------------------------------------------
/**
 * <p>Formats a <code>Date</code>, <code>Calendar</code> or
 * <code>Long</code> (milliseconds) object.</p>
 *
 * @param obj  the object to format
 * @param toAppendTo  the buffer to append to
 * @param pos  the position - ignored
 * @return the buffer passed in
 */
@Override
public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
    if (obj instanceof Date) {
        return format((Date) obj, toAppendTo);
    } else if (obj instanceof Calendar) {
        return format((Calendar) obj, toAppendTo);
    } else if (obj instanceof Long) {
        return format(((Long) obj).longValue(), toAppendTo);
    } else {
        throw new IllegalArgumentException(""Unknown class: "" + (obj == null ? ""<null>"" : obj.getClass().getName()));
    }
}","public void test451500() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    TimeZone.setDefault(timeZone0);
    Locale locale0 = Locale.CANADA_FRENCH;
    String string0 = timeZone0.getDisplayName(false, 0, locale0);
    String string1 = timeZone0.getDisplayName(false, 0, locale0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0);
    Long long0 = new Long(1L);
    boolean boolean0 = timeZone0.observesDaylightTime();
    DecimalFormat decimalFormat0 = (DecimalFormat) NumberFormat.getPercentInstance(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""GMT"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = decimalFormat0.format(0.0, stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer2 = stringBuffer0.append((CharSequence) ""GMT"");
    StringBuffer stringBuffer3 = stringBuffer1.insert(0, true);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
    StringBuffer stringBuffer4 = stringBuffer1.append((Object) mockGregorianCalendar0);
    StringBuffer stringBuffer5 = fastDateFormat0.format((Object) long0, stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer6 = fastDateFormat0.format((Object) long0, stringBuffer5, fieldPosition0);
    assertEquals(3, FastDateFormat.SHORT);
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test451540() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    TimeZone.setDefault(timeZone0);
    Locale locale0 = Locale.CANADA_FRENCH;
    String string0 = timeZone0.getDisplayName(false, 0, locale0);
    String string1 = timeZone0.getDisplayName(false, 0, locale0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0);
    Long long0 = new Long(1L);
    boolean boolean0 = timeZone0.observesDaylightTime();
    DecimalFormat decimalFormat0 = (DecimalFormat) NumberFormat.getPercentInstance(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""GMT"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = decimalFormat0.format(0.0, stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer2 = stringBuffer0.append((CharSequence) ""GMT"");
    StringBuffer stringBuffer3 = stringBuffer1.insert(0, true);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
    StringBuffer stringBuffer4 = stringBuffer1.append((Object) mockGregorianCalendar0);
    StringBuffer stringBuffer5 = fastDateFormat0.format((Object) long0, stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer6 = fastDateFormat0.format((Object) long0, stringBuffer5, fieldPosition0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test451541() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    TimeZone.setDefault(timeZone0);
    Locale locale0 = Locale.CANADA_FRENCH;
    String string0 = timeZone0.getDisplayName(false, 0, locale0);
    String string1 = timeZone0.getDisplayName(false, 0, locale0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0);
    Long long0 = new Long(1L);
    boolean boolean0 = timeZone0.observesDaylightTime();
    DecimalFormat decimalFormat0 = (DecimalFormat) NumberFormat.getPercentInstance(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""GMT"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = decimalFormat0.format(0.0, stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer2 = stringBuffer0.append((CharSequence) ""GMT"");
    StringBuffer stringBuffer3 = stringBuffer1.insert(0, true);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
    StringBuffer stringBuffer4 = stringBuffer1.append((Object) mockGregorianCalendar0);
    StringBuffer stringBuffer5 = fastDateFormat0.format((Object) long0, stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer6 = fastDateFormat0.format((Object) long0, stringBuffer5, fieldPosition0);
    assertEquals(""EEEE, MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test451542() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    TimeZone.setDefault(timeZone0);
    Locale locale0 = Locale.CANADA_FRENCH;
    String string0 = timeZone0.getDisplayName(false, 0, locale0);
    String string1 = timeZone0.getDisplayName(false, 0, locale0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0);
    Long long0 = new Long(1L);
    boolean boolean0 = timeZone0.observesDaylightTime();
    DecimalFormat decimalFormat0 = (DecimalFormat) NumberFormat.getPercentInstance(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""GMT"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = decimalFormat0.format(0.0, stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer2 = stringBuffer0.append((CharSequence) ""GMT"");
    StringBuffer stringBuffer3 = stringBuffer1.insert(0, true);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
    StringBuffer stringBuffer4 = stringBuffer1.append((Object) mockGregorianCalendar0);
    StringBuffer stringBuffer5 = fastDateFormat0.format((Object) long0, stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer6 = fastDateFormat0.format((Object) long0, stringBuffer5, fieldPosition0);
    assertEquals(31, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = Integer.valueOf(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale == null) {
        locale = Locale.getDefault();
    }
    key = new Pair(key, locale);
    FastDateFormat format = cDateInstanceCache.get(key);
    if (format == null) {
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cDateInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test451567() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    TimeZone.setDefault(timeZone0);
    Locale locale0 = Locale.CANADA_FRENCH;
    String string0 = timeZone0.getDisplayName(false, 0, locale0);
    String string1 = timeZone0.getDisplayName(false, 0, locale0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0);
    Long long0 = new Long(1L);
    boolean boolean0 = timeZone0.observesDaylightTime();
    DecimalFormat decimalFormat0 = (DecimalFormat) NumberFormat.getPercentInstance(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""GMT"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = decimalFormat0.format(0.0, stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer2 = stringBuffer0.append((CharSequence) ""GMT"");
    StringBuffer stringBuffer3 = stringBuffer1.insert(0, true);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
    StringBuffer stringBuffer4 = stringBuffer1.append((Object) mockGregorianCalendar0);
    StringBuffer stringBuffer5 = fastDateFormat0.format((Object) long0, stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer6 = fastDateFormat0.format((Object) long0, stringBuffer5, fieldPosition0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(2, timeZone0, locale0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets a date formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test451580() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    TimeZone.setDefault(timeZone0);
    Locale locale0 = Locale.CANADA_FRENCH;
    String string0 = timeZone0.getDisplayName(false, 0, locale0);
    String string1 = timeZone0.getDisplayName(false, 0, locale0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0);
    Long long0 = new Long(1L);
    boolean boolean0 = timeZone0.observesDaylightTime();
    DecimalFormat decimalFormat0 = (DecimalFormat) NumberFormat.getPercentInstance(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""GMT"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = decimalFormat0.format(0.0, stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer2 = stringBuffer0.append((CharSequence) ""GMT"");
    StringBuffer stringBuffer3 = stringBuffer1.insert(0, true);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
    StringBuffer stringBuffer4 = stringBuffer1.append((Object) mockGregorianCalendar0);
    StringBuffer stringBuffer5 = fastDateFormat0.format((Object) long0, stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer6 = fastDateFormat0.format((Object) long0, stringBuffer5, fieldPosition0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(2, timeZone0, locale0);
    assertEquals(10, fastDateFormat1.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test451581() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    TimeZone.setDefault(timeZone0);
    Locale locale0 = Locale.CANADA_FRENCH;
    String string0 = timeZone0.getDisplayName(false, 0, locale0);
    String string1 = timeZone0.getDisplayName(false, 0, locale0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0);
    Long long0 = new Long(1L);
    boolean boolean0 = timeZone0.observesDaylightTime();
    DecimalFormat decimalFormat0 = (DecimalFormat) NumberFormat.getPercentInstance(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""GMT"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = decimalFormat0.format(0.0, stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer2 = stringBuffer0.append((CharSequence) ""GMT"");
    StringBuffer stringBuffer3 = stringBuffer1.insert(0, true);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
    StringBuffer stringBuffer4 = stringBuffer1.append((Object) mockGregorianCalendar0);
    StringBuffer stringBuffer5 = fastDateFormat0.format((Object) long0, stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer6 = fastDateFormat0.format((Object) long0, stringBuffer5, fieldPosition0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(2, timeZone0, locale0);
    assertEquals(""yyyy-MM-dd"", fastDateFormat1.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test451582() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    TimeZone.setDefault(timeZone0);
    Locale locale0 = Locale.CANADA_FRENCH;
    String string0 = timeZone0.getDisplayName(false, 0, locale0);
    String string1 = timeZone0.getDisplayName(false, 0, locale0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0);
    Long long0 = new Long(1L);
    boolean boolean0 = timeZone0.observesDaylightTime();
    DecimalFormat decimalFormat0 = (DecimalFormat) NumberFormat.getPercentInstance(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""GMT"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = decimalFormat0.format(0.0, stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer2 = stringBuffer0.append((CharSequence) ""GMT"");
    StringBuffer stringBuffer3 = stringBuffer1.insert(0, true);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
    StringBuffer stringBuffer4 = stringBuffer1.append((Object) mockGregorianCalendar0);
    StringBuffer stringBuffer5 = fastDateFormat0.format((Object) long0, stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer6 = fastDateFormat0.format((Object) long0, stringBuffer5, fieldPosition0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(2, timeZone0, locale0);
    assertTrue(fastDateFormat1.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test451583() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    TimeZone.setDefault(timeZone0);
    Locale locale0 = Locale.CANADA_FRENCH;
    String string0 = timeZone0.getDisplayName(false, 0, locale0);
    String string1 = timeZone0.getDisplayName(false, 0, locale0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0);
    Long long0 = new Long(1L);
    boolean boolean0 = timeZone0.observesDaylightTime();
    DecimalFormat decimalFormat0 = (DecimalFormat) NumberFormat.getPercentInstance(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""GMT"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = decimalFormat0.format(0.0, stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer2 = stringBuffer0.append((CharSequence) ""GMT"");
    StringBuffer stringBuffer3 = stringBuffer1.insert(0, true);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
    StringBuffer stringBuffer4 = stringBuffer1.append((Object) mockGregorianCalendar0);
    StringBuffer stringBuffer5 = fastDateFormat0.format((Object) long0, stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer6 = fastDateFormat0.format((Object) long0, stringBuffer5, fieldPosition0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(2, timeZone0, locale0);
    assertFalse(fastDateFormat1.equals((Object) fastDateFormat0));
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Gets the time zone display name, using a cache for performance.</p>
 *
 * @param tz  the zone to query
 * @param daylight  true if daylight savings
 * @param style  the style to use <code>TimeZone.LONG</code>
 *  or <code>TimeZone.SHORT</code>
 * @param locale  the locale to use
 * @return the textual name of the time zone
 */
static synchronized String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {
    Object key = new TimeZoneDisplayKey(tz, daylight, style, locale);
    String value = cTimeZoneDisplayCache.get(key);
    if (value == null) {
        // This is a very slow call, so cache the results.
        value = tz.getDisplayName(daylight, style, locale);
        cTimeZoneDisplayCache.put(key, value);
    }
    return value;
}","public void test451584() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    TimeZone.setDefault(timeZone0);
    Locale locale0 = Locale.CANADA_FRENCH;
    String string0 = timeZone0.getDisplayName(false, 0, locale0);
    String string1 = timeZone0.getDisplayName(false, 0, locale0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0);
    Long long0 = new Long(1L);
    boolean boolean0 = timeZone0.observesDaylightTime();
    DecimalFormat decimalFormat0 = (DecimalFormat) NumberFormat.getPercentInstance(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""GMT"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = decimalFormat0.format(0.0, stringBuffer0, fieldPosition0);
    StringBuffer stringBuffer2 = stringBuffer0.append((CharSequence) ""GMT"");
    StringBuffer stringBuffer3 = stringBuffer1.insert(0, true);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(timeZone0);
    StringBuffer stringBuffer4 = stringBuffer1.append((Object) mockGregorianCalendar0);
    StringBuffer stringBuffer5 = fastDateFormat0.format((Object) long0, stringBuffer1, fieldPosition0);
    StringBuffer stringBuffer6 = fastDateFormat0.format((Object) long0, stringBuffer5, fieldPosition0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(2, timeZone0, locale0);
    String string2 = FastDateFormat.getTimeZoneDisplay(timeZone0, false, 1, locale0);
    assertNotNull(string2);
}",""
"public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {
    return getDateInstance(style, timeZone, null);
}","public void test461601() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test461611() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    assertEquals(31, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test461612() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test461613() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    assertEquals(""EEEE, MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"// Parsing
//-----------------------------------------------------------------------
/**
 * <p>Parsing is not supported.</p>
 *
 * @param source  the string to parse
 * @param pos  the parsing position
 * @return <code>null</code> as not supported
 */
@Override
public Object parseObject(String source, ParsePosition pos) {
    pos.setIndex(0);
    pos.setErrorIndex(0);
    return null;
}","public void test461621() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    assertEquals(1, FastDateFormat.LONG);
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test461631() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    assertEquals(31, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test461632() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test461633() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    assertEquals(""EEEE, MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"public StringBuffer format(long millis, StringBuffer buf) {
    return format(new Date(millis), buf);
}","public void test461644() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Formats a milliseond <code>long</code> value into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param millis  the millisecond value to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 * @since 2.1
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test461658() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    assertEquals(31, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test461659() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test461660() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    assertEquals(""EEEE, MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"@Override
public int hashCode() {
    int total = 0;
    total += mPattern.hashCode();
    total += mTimeZone.hashCode();
    total += (mTimeZoneForced ? 1 : 0);
    total += mLocale.hashCode();
    total += (mLocaleForced ? 1 : 0);
    return total;
}","public void test461665() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Returns a hashcode compatible with equals.</p>
 *
 * @return a hashcode compatible with equals
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test461674() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    assertEquals(31, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test461675() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test461676() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    assertEquals(""EEEE, MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone) {
    return getDateTimeInstance(dateStyle, timeStyle, timeZone, null);
}","public void test461708() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a date/time formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test461719() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    assertEquals(""M/d/yy h:mm:ss a z"", fastDateFormat1.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test461720() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    assertTrue(fastDateFormat1.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test461721() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    assertEquals(34, fastDateFormat1.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test461722() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    assertFalse(fastDateFormat1.equals((Object) fastDateFormat0));
}",""
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test461731() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0, locale1);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test461739() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0, locale1);
    assertEquals(0, fastDateFormat2.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test461740() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0, locale1);
    assertEquals("""", fastDateFormat2.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test461741() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0, locale1);
    assertTrue(fastDateFormat2.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test461753() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0, locale1);
    assertFalse(fastDateFormat2.equals((Object) fastDateFormat1));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test461754() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0, locale1);
    assertFalse(fastDateFormat2.equals((Object) fastDateFormat0));
}",""
"public static FastDateFormat getDateInstance(int style, Locale locale) {
    return getDateInstance(style, null, locale);
}","public void test461756() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0, locale1);
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(0, locale1);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test461765() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0, locale1);
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(0, locale1);
    assertEquals(17, fastDateFormat3.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test461766() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0, locale1);
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(0, locale1);
    assertEquals(""yyyy'\u5E74'M'\u6708'd'\u65E5' EEEE"", fastDateFormat3.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test461767() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0, locale1);
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(0, locale1);
    assertFalse(fastDateFormat3.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test461774() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0, locale1);
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(0, locale1);
    assertFalse(fastDateFormat3.equals((Object) fastDateFormat1));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test461775() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0, locale1);
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(0, locale1);
    assertFalse(fastDateFormat3.equals((Object) fastDateFormat0));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test461776() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0, locale1);
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(0, locale1);
    assertFalse(fastDateFormat3.equals((Object) fastDateFormat2));
}",""
"public String format(Date date) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test461783() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0, locale1);
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(0, locale1);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 2);
    MockDate mockDate0 = new MockDate(1, 221, 2250, (-2050), 116);
    String string0 = fastDateFormat3.format((Date) mockDate0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Formats a <code>Date</code> object.</p>
 *
 * @param date  the date to format
 * @return the formatted string
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test461793() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0, locale1);
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(0, locale1);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 2);
    MockDate mockDate0 = new MockDate(1, 221, 2250, (-2050), 116);
    String string0 = fastDateFormat3.format((Date) mockDate0);
    assertEquals(17, fastDateFormat3.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test461794() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0, locale1);
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(0, locale1);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 2);
    MockDate mockDate0 = new MockDate(1, 221, 2250, (-2050), 116);
    String string0 = fastDateFormat3.format((Date) mockDate0);
    assertEquals(""yyyy'\u5E74'M'\u6708'd'\u65E5' EEEE"", fastDateFormat3.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test461795() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0, locale1);
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(0, locale1);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 2);
    MockDate mockDate0 = new MockDate(1, 221, 2250, (-2050), 116);
    String string0 = fastDateFormat3.format((Date) mockDate0);
    assertFalse(fastDateFormat3.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test461796() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0, locale1);
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(0, locale1);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 2);
    MockDate mockDate0 = new MockDate(1, 221, 2250, (-2050), 116);
    String string0 = fastDateFormat3.format((Date) mockDate0);
    assertEquals(""Sun May 03 15:56:00 GMT 1925"", mockDate0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test461803() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0, locale1);
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(0, locale1);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 2);
    MockDate mockDate0 = new MockDate(1, 221, 2250, (-2050), 116);
    String string0 = fastDateFormat3.format((Date) mockDate0);
    assertFalse(fastDateFormat3.equals((Object) fastDateFormat1));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test461804() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0, locale1);
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(0, locale1);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 2);
    MockDate mockDate0 = new MockDate(1, 221, 2250, (-2050), 116);
    String string0 = fastDateFormat3.format((Date) mockDate0);
    assertFalse(fastDateFormat3.equals((Object) fastDateFormat0));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test461805() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0, locale1);
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(0, locale1);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 2);
    MockDate mockDate0 = new MockDate(1, 221, 2250, (-2050), 116);
    String string0 = fastDateFormat3.format((Date) mockDate0);
    assertFalse(fastDateFormat3.equals((Object) fastDateFormat2));
}",""
"// Format methods
//-----------------------------------------------------------------------
/**
 * <p>Formats a <code>Date</code>, <code>Calendar</code> or
 * <code>Long</code> (milliseconds) object.</p>
 *
 * @param obj  the object to format
 * @param toAppendTo  the buffer to append to
 * @param pos  the position - ignored
 * @return the buffer passed in
 */
@Override
public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
    if (obj instanceof Date) {
        return format((Date) obj, toAppendTo);
    } else if (obj instanceof Calendar) {
        return format((Calendar) obj, toAppendTo);
    } else if (obj instanceof Long) {
        return format(((Long) obj).longValue(), toAppendTo);
    } else {
        throw new IllegalArgumentException(""Unknown class: "" + (obj == null ? ""<null>"" : obj.getClass().getName()));
    }
}","public void test461807() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    Object object0 = fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    StringBuffer stringBuffer2 = fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    Locale locale2 = Locale.lookup(linkedList0, list0);
    FastDateFormat fastDateFormat2 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0, locale1);
    FastDateFormat fastDateFormat3 = FastDateFormat.getDateInstance(0, locale1);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 2);
    MockDate mockDate0 = new MockDate(1, 221, 2250, (-2050), 116);
    String string0 = fastDateFormat3.format((Date) mockDate0);
    // Undeclared exception!
    try {
        fastDateFormat0.format((Object) mockSimpleDateFormat0, stringBuffer1, fieldPosition0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unknown class: org.evosuite.runtime.mock.java.text.MockSimpleDateFormat
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}",""
"public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, Locale locale) {
    return getDateTimeInstance(dateStyle, timeStyle, null, locale);
}","public void test481824() throws Throwable {
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a date/time formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test481835() throws Throwable {
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    assertEquals(""EEEE, MMMM d, yyyy h:mm:ss 'o''clock' a z"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test481836() throws Throwable {
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    assertEquals(58, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test481837() throws Throwable {
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public static FastDateFormat getDateInstance(int style, Locale locale) {
    return getDateInstance(style, null, locale);
}","public void test491846() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(1, locale0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test491857() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(1, locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test491858() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(1, locale0);
    assertEquals(""yyyy'\u5E74'M'\u6708'd'\u65E5'"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test491859() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(1, locale0);
    assertEquals(13, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone) {
    return getDateTimeInstance(dateStyle, timeStyle, timeZone, null);
}","public void test501888() throws Throwable {
    String string0 = """";
    Locale locale0 = Locale.ENGLISH;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedList<Locale> linkedList1 = new LinkedList<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedList1);
    Locale locale1 = Locale.lookup(linkedList0, list0);
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(2, 2, timeZone0);
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Gets a date/time formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test501894() throws Throwable {
    String string0 = """";
    Locale locale0 = Locale.ENGLISH;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedList<Locale> linkedList1 = new LinkedList<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedList1);
    Locale locale1 = Locale.lookup(linkedList0, list0);
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(2, 2, timeZone0);
    assertEquals(""MMM d, yyyy h:mm:ss a"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test501895() throws Throwable {
    String string0 = """";
    Locale locale0 = Locale.ENGLISH;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedList<Locale> linkedList1 = new LinkedList<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedList1);
    Locale locale1 = Locale.lookup(linkedList0, list0);
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(2, 2, timeZone0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test501896() throws Throwable {
    String string0 = """";
    Locale locale0 = Locale.ENGLISH;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedList<Locale> linkedList1 = new LinkedList<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedList1);
    Locale locale1 = Locale.lookup(linkedList0, list0);
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(2, 2, timeZone0);
    assertEquals(28, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = Integer.valueOf(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale == null) {
        locale = Locale.getDefault();
    }
    key = new Pair(key, locale);
    FastDateFormat format = cDateInstanceCache.get(key);
    if (format == null) {
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cDateInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test501897() throws Throwable {
    String string0 = """";
    Locale locale0 = Locale.ENGLISH;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedList<Locale> linkedList1 = new LinkedList<Locale>();
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedList1);
    Locale locale1 = Locale.lookup(linkedList0, list0);
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(2, 2, timeZone0);
    // Undeclared exception!
    try {
        FastDateFormat.getDateInstance(73, timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style 73
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test511898() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""xY=@f&dA]Vt8U`&4|]"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: x
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test521899() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""und"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: u
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test531907() throws Throwable {
    Locale locale0 = Locale.ITALIAN;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""htC+iAsdS2#%*>BG"", (TimeZone) null, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: t
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test541908() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""@H(d*8qNRb\u0001$;g;eW"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: q
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test551918() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.US;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""<null>"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: n
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test561926() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""gl#+/t~.LgR_d%q"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: g
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test571940() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(408, """");
    Locale locale0 = new Locale("""");
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""];fP>%Q\""w"", (TimeZone) simpleTimeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: f
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test581947() throws Throwable {
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    TimeZone timeZone0 = mockSimpleDateFormat0.getTimeZone();
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""cu+&Tf&53r^xfe!*`l@"", timeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: c
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test591955() throws Throwable {
    Locale locale0 = Locale.ROOT;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""-b>/gir%,"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: b
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test601956() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""ZzBMHX.Xs,:pO[wVvQ"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: B
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test611964() throws Throwable {
    Locale locale0 = Locale.GERMANY;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""YW*-M"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: Y
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test621965() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""#@:VG&p4("");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: V
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test631966() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    // Undeclared exception!
    try {
        FastDateFormat.getInstance("":Uhxdjbv"", (TimeZone) simpleTimeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: U
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test641967() throws Throwable {
    Locale locale0 = Locale.ITALIAN;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""Tis`#pMDw.`n~_g|U"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: T
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test651968() throws Throwable {
    Locale locale0 = Locale.FRENCH;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""w$RV7HWI "", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: R
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test661969() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""sP`u+I ,=U*"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: P
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test671970() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""k"");
    Locale locale0 = Locale.CANADA;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance("".L$D&HvPb"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: L
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test681971() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance("">WK6e]DBk"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: e
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test691972() throws Throwable {
    ZoneId zoneId0 = ZoneId.systemDefault();
    TimeZone timeZone0 = TimeZone.getTimeZone(zoneId0);
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""#%F=JFk6A5Dbi1LAQ"", timeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: J
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test701973() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""9GIgE-"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: I
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test711974() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""G66}%5!O?u@7"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: O
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test721975() throws Throwable {
    Locale locale0 = Locale.GERMAN;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""z}FWDo."", (TimeZone) null, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: o
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test731976() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""C8Ktk@{OLOnR"", timeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: C
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test741977() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    Locale locale0 = Locale.ENGLISH;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""AL+YIJ6T*8\""x"", (TimeZone) simpleTimeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: A
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test751978() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance((String) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The pattern must not be null
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"// Format methods
//-----------------------------------------------------------------------
/**
 * <p>Formats a <code>Date</code>, <code>Calendar</code> or
 * <code>Long</code> (milliseconds) object.</p>
 *
 * @param obj  the object to format
 * @param toAppendTo  the buffer to append to
 * @param pos  the position - ignored
 * @return the buffer passed in
 */
@Override
public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
    if (obj instanceof Date) {
        return format((Date) obj, toAppendTo);
    } else if (obj instanceof Calendar) {
        return format((Calendar) obj, toAppendTo);
    } else if (obj instanceof Long) {
        return format(((Long) obj).longValue(), toAppendTo);
    } else {
        throw new IllegalArgumentException(""Unknown class: "" + (obj == null ? ""<null>"" : obj.getClass().getName()));
    }
}","public void test761979() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    StringBuffer stringBuffer0 = new StringBuffer("""");
    ParsePosition parsePosition0 = new ParsePosition((-2803));
    fastDateFormat0.parseObject(""YW*-M"", parsePosition0);
    StringBuffer stringBuffer1 = stringBuffer0.append((Object) null);
    fastDateFormat0.format(45L, stringBuffer0);
    fastDateFormat0.hashCode();
    Locale locale0 = Locale.GERMANY;
    FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat("""", locale0);
    Locale locale1 = Locale.CHINA;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    LinkedList<Locale> linkedList1 = new LinkedList<Locale>();
    FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    Locale.lookup(linkedList0, linkedList1);
    FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0, locale1);
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(2);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 2);
    MockDate mockDate0 = new MockDate(1, 221, 2250, (-2050), 116);
    fastDateFormat1.format((Date) mockDate0);
    // Undeclared exception!
    try {
        fastDateFormat0.format((Object) mockSimpleDateFormat0, stringBuffer1, fieldPosition0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unknown class: org.evosuite.runtime.mock.java.text.MockSimpleDateFormat
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}",""
"public String format(long millis) {
    return format(new Date(millis));
}","public void test771980() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    String string0 = fastDateFormat0.format((-1796L));
    assertEquals(""12/31/69 11:59:58 PM GMT+00:00"", string0);
}","/**
 * <p>Formats a millisecond <code>long</code> value.</p>
 *
 * @param millis  the millisecond value to format
 * @return the formatted string
 * @since 2.1
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test781981() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""\""\""v!j.#"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: v
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test791982() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """");
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    boolean boolean0 = fastDateFormat0.getTimeZoneOverridesCalendar();
    assertTrue(boolean0);
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test801983() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance();
    assertEquals(21, fastDateFormat1.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a formatter instance using the default pattern in the
 * default locale.</p>
 *
 * @return a date/time formatter
 */
public static FastDateFormat getInstance() {
    return getInstance(getDefaultPattern(), null, null);
}","public void test801984() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance();
    assertNotSame(fastDateFormat1, fastDateFormat0);
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test811986() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    assertEquals(0, int0);
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test811987() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test821988() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (Locale) null);
    String string0 = fastDateFormat0.toString();
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test821989() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (Locale) null);
    String string0 = fastDateFormat0.toString();
    assertEquals(""FastDateFormat[]"", string0);
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"// Format methods
//-----------------------------------------------------------------------
/**
 * <p>Formats a <code>Date</code>, <code>Calendar</code> or
 * <code>Long</code> (milliseconds) object.</p>
 *
 * @param obj  the object to format
 * @param toAppendTo  the buffer to append to
 * @param pos  the position - ignored
 * @return the buffer passed in
 */
@Override
public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
    if (obj instanceof Date) {
        return format((Date) obj, toAppendTo);
    } else if (obj instanceof Calendar) {
        return format((Calendar) obj, toAppendTo);
    } else if (obj instanceof Long) {
        return format(((Long) obj).longValue(), toAppendTo);
    } else {
        throw new IllegalArgumentException(""Unknown class: "" + (obj == null ? ""<null>"" : obj.getClass().getName()));
    }
}","public void test831990() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(1, (-2571), 1713, 1, 1, 20);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    // Undeclared exception!
    try {
        fastDateFormat0.format((Object) mockGregorianCalendar0, (StringBuffer) null, fieldPosition0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat$UnpaddedNumberField"", e);
    }
}",""
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test851992() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(3, (TimeZone) null);
    assertEquals(""h:mm a"", fastDateFormat0.getPattern());
}",""
