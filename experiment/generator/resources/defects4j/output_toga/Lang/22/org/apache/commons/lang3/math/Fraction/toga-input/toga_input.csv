focal_method,test_prefix,docstring
"public int compareTo(Fraction other) {
    if (this == other) {
        return 0;
    }
    if (numerator == other.numerator && denominator == other.denominator) {
        return 0;
    }
    // otherwise see which is less
    long first = (long) numerator * (long) other.denominator;
    long second = (long) other.numerator * (long) denominator;
    if (first == second) {
        return 0;
    } else if (first < second) {
        return -1;
    } else {
        return 1;
    }
}","public void test0000() throws Throwable {
    Fraction fraction0 = Fraction.ONE_THIRD;
    Fraction fraction1 = Fraction.ONE_HALF;
    int int0 = fraction0.compareTo(fraction1);
    assertEquals((-1), int0);
}","/**
 * <p>Compares this object to another based on size.</p>
 *
 * <p>Note: this class has a natural ordering that is inconsistent
 * with equals, because, for example, equals treats 1/2 and 2/4 as
 * different, whereas compareTo treats them as equal.
 *
 * @param other  the object to compare to
 * @return -1 if this is less, 0 if equal, +1 if greater
 * @throws ClassCastException if the object is not a <code>Fraction</code>
 * @throws NullPointerException if the object is <code>null</code>
 */"
"public int compareTo(Fraction other) {
    if (this == other) {
        return 0;
    }
    if (numerator == other.numerator && denominator == other.denominator) {
        return 0;
    }
    // otherwise see which is less
    long first = (long) numerator * (long) other.denominator;
    long second = (long) other.numerator * (long) denominator;
    if (first == second) {
        return 0;
    } else if (first < second) {
        return -1;
    } else {
        return 1;
    }
}","public void test0011() throws Throwable {
    Fraction fraction0 = Fraction.ONE_FIFTH;
    Fraction fraction1 = Fraction.ZERO;
    int int0 = fraction1.compareTo(fraction0);
    assertEquals((-1), int0);
}","/**
 * <p>Compares this object to another based on size.</p>
 *
 * <p>Note: this class has a natural ordering that is inconsistent
 * with equals, because, for example, equals treats 1/2 and 2/4 as
 * different, whereas compareTo treats them as equal.
 *
 * @param other  the object to compare to
 * @return -1 if this is less, 0 if equal, +1 if greater
 * @throws ClassCastException if the object is not a <code>Fraction</code>
 * @throws NullPointerException if the object is <code>null</code>
 */"
"public int getDenominator() {
    return denominator;
}","public void test0022() throws Throwable {
    Fraction fraction0 = Fraction.getFraction((-3579.9143379));
    fraction0.hashCode();
    fraction0.hashCode();
    assertEquals(5475, fraction0.getDenominator());
}","/**
 * <p>Gets the denominator part of the fraction.</p>
 *
 * @return the denominator fraction part
 */"
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test0023() throws Throwable {
    Fraction fraction0 = Fraction.getFraction((-3579.9143379));
    fraction0.hashCode();
    fraction0.hashCode();
    assertEquals((-3579.914337899543), fraction0.doubleValue(), 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"// Accessors
//-------------------------------------------------------------------
/**
 * <p>Gets the numerator part of the fraction.</p>
 *
 * <p>This method may return a value greater than the denominator, an
 * improper fraction, such as the seven in 7/4.</p>
 *
 * @return the numerator fraction part
 */
public int getNumerator() {
    return numerator;
}","public void test0024() throws Throwable {
    Fraction fraction0 = Fraction.getFraction((-3579.9143379));
    fraction0.hashCode();
    fraction0.hashCode();
    assertEquals((-19600031), fraction0.getNumerator());
}",""
"// Accessors
//-------------------------------------------------------------------
/**
 * <p>Gets the numerator part of the fraction.</p>
 *
 * <p>This method may return a value greater than the denominator, an
 * improper fraction, such as the seven in 7/4.</p>
 *
 * @return the numerator fraction part
 */
public int getNumerator() {
    return numerator;
}","public void test0035() throws Throwable {
    Fraction fraction0 = Fraction.THREE_QUARTERS;
    Fraction fraction1 = Fraction.ONE_HALF;
    boolean boolean0 = fraction0.equals(fraction1);
    assertEquals(1, fraction1.getNumerator());
}",""
"// Basics
//-------------------------------------------------------------------
/**
 * <p>Compares this fraction to another object to test if they are equal.</p>.
 *
 * <p>To be equal, both values must be equal. Thus 2/4 is not equal to 1/2.</p>
 *
 * @param obj the reference object with which to compare
 * @return <code>true</code> if this object is equal
 */
@Override
public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (obj instanceof Fraction == false) {
        return false;
    }
    Fraction other = (Fraction) obj;
    return (getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator());
}","public void test0036() throws Throwable {
    Fraction fraction0 = Fraction.THREE_QUARTERS;
    Fraction fraction1 = Fraction.ONE_HALF;
    boolean boolean0 = fraction0.equals(fraction1);
    assertFalse(boolean0);
}",""
"public Fraction subtract(Fraction fraction) {
    return addSub(fraction, false);
}","public void test0047() throws Throwable {
    Fraction fraction0 = Fraction.getFraction(Integer.MAX_VALUE, Integer.MAX_VALUE);
    // Undeclared exception!
    try {
        fraction0.ONE_QUARTER.subtract(fraction0);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: mul
        //
        verifyException(""org.apache.commons.lang3.math.Fraction"", e);
    }
}","/**
 * <p>Subtracts the value of another fraction from the value of this one,
 * returning the result in reduced form.</p>
 *
 * @param fraction  the fraction to subtract, must not be <code>null</code>
 * @return a <code>Fraction</code> instance with the resulting values
 * @throws IllegalArgumentException if the fraction is <code>null</code>
 * @throws ArithmeticException if the resulting numerator or denominator
 *   cannot be represented in an <code>int</code>.
 */"
"public int getProperNumerator() {
    return Math.abs(numerator % denominator);
}","public void test0058() throws Throwable {
    Fraction fraction0 = Fraction.getFraction(25, 25);
    Fraction fraction1 = fraction0.reduce();
    assertEquals(0, fraction1.getProperNumerator());
}","/**
 * <p>Gets the proper numerator, always positive.</p>
 *
 * <p>An improper fraction 7/4 can be resolved into a proper one, 1 3/4.
 * This method returns the 3 from the proper fraction.</p>
 *
 * <p>If the fraction is negative such as -7/4, it can be resolved into
 * -1 3/4, so this method returns the positive proper numerator, 3.</p>
 *
 * @return the numerator fraction part of a proper fraction, always positive
 */"
"public int getProperWhole() {
    return numerator / denominator;
}","public void test0059() throws Throwable {
    Fraction fraction0 = Fraction.getFraction(25, 25);
    Fraction fraction1 = fraction0.reduce();
    assertEquals(1, fraction0.getProperWhole());
}","/**
 * <p>Gets the proper whole part of the fraction.</p>
 *
 * <p>An improper fraction 7/4 can be resolved into a proper one, 1 3/4.
 * This method returns the 1 from the proper fraction.</p>
 *
 * <p>If the fraction is negative such as -7/4, it can be resolved into
 * -1 3/4, so this method returns the positive whole part -1.</p>
 *
 * @return the whole fraction part of a proper fraction, that includes the sign
 */"
"// Accessors
//-------------------------------------------------------------------
/**
 * <p>Gets the numerator part of the fraction.</p>
 *
 * <p>This method may return a value greater than the denominator, an
 * improper fraction, such as the seven in 7/4.</p>
 *
 * @return the numerator fraction part
 */
public int getNumerator() {
    return numerator;
}","public void test00510() throws Throwable {
    Fraction fraction0 = Fraction.getFraction(25, 25);
    Fraction fraction1 = fraction0.reduce();
    assertEquals(1, fraction1.getNumerator());
}",""
"public static Fraction getFraction(String str) {
    if (str == null) {
        throw new IllegalArgumentException(""The string must not be null"");
    }
    // parse double format
    int pos = str.indexOf('.');
    if (pos >= 0) {
        return getFraction(Double.parseDouble(str));
    }
    // parse X Y/Z format
    pos = str.indexOf(' ');
    if (pos > 0) {
        int whole = Integer.parseInt(str.substring(0, pos));
        str = str.substring(pos + 1);
        pos = str.indexOf('/');
        if (pos < 0) {
            throw new NumberFormatException(""The fraction could not be parsed as the format X Y/Z"");
        } else {
            int numer = Integer.parseInt(str.substring(0, pos));
            int denom = Integer.parseInt(str.substring(pos + 1));
            return getFraction(whole, numer, denom);
        }
    }
    // parse Y/Z format
    pos = str.indexOf('/');
    if (pos < 0) {
        // simple whole number
        return getFraction(Integer.parseInt(str), 1);
    } else {
        int numer = Integer.parseInt(str.substring(0, pos));
        int denom = Integer.parseInt(str.substring(pos + 1));
        return getFraction(numer, denom);
    }
}","public void test00611() throws Throwable {
    // Undeclared exception!
    try {
        Fraction.getFraction("" Hwz3~N"");
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
        //
        // For input string: \"" Hwz3~N\""
        //
        verifyException(""java.lang.NumberFormatException"", e);
    }
}","/**
 * <p>Creates a Fraction from a <code>String</code>.</p>
 *
 * <p>The formats accepted are:</p>
 *
 * <ol>
 *  <li><code>double</code> String containing a dot</li>
 *  <li>'X Y/Z'</li>
 *  <li>'Y/Z'</li>
 *  <li>'X' (a simple whole number)</li>
 * </ol>
 * and a .</p>
 *
 * @param str  the string to parse, must not be <code>null</code>
 * @return the new <code>Fraction</code> instance
 * @throws IllegalArgumentException if the string is <code>null</code>
 * @throws NumberFormatException if the number format is invalid
 */"
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test00712() throws Throwable {
    Fraction fraction0 = Fraction.getFraction(0.0);
    assertEquals(0.0, fraction0.doubleValue(), 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"public int getDenominator() {
    return denominator;
}","public void test00813() throws Throwable {
    Fraction fraction0 = Fraction.THREE_FIFTHS;
    Fraction fraction1 = fraction0.subtract(fraction0);
    assertEquals(1, fraction1.getDenominator());
}","/**
 * <p>Gets the denominator part of the fraction.</p>
 *
 * @return the denominator fraction part
 */"
"@Override
public float floatValue() {
    return ((float) numerator) / ((float) denominator);
}","public void test00914() throws Throwable {
    Fraction fraction0 = Fraction.FOUR_FIFTHS;
    Fraction fraction1 = Fraction.getFraction(4188.5);
    Fraction fraction2 = fraction1.subtract(fraction0);
    assertEquals(4187.7F, fraction2.floatValue(), 0.01F);
}","/**
 * <p>Gets the fraction as a <code>float</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>float</code>
 */"
"// Calculations
//-------------------------------------------------------------------
/**
 * <p>Reduce the fraction to the smallest values for the numerator and
 * denominator, returning the result.</p>
 *
 * <p>For example, if this fraction represents 2/4, then the result
 * will be 1/2.</p>
 *
 * @return a new reduced fraction instance, or this if no simplification possible
 */
public Fraction reduce() {
    if (numerator == 0) {
        return equals(ZERO) ? this : ZERO;
    }
    int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
    if (gcd == 1) {
        return this;
    }
    return Fraction.getFraction(numerator / gcd, denominator / gcd);
}","public void test01015() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    Fraction fraction1 = fraction0.reduce();
    assertSame(fraction1, fraction0);
}",""
"@Override
public float floatValue() {
    return ((float) numerator) / ((float) denominator);
}","public void test01116() throws Throwable {
    Fraction fraction0 = Fraction.getFraction((-870.279420099903));
    Fraction fraction1 = fraction0.reduce();
    assertEquals((-870.2794F), fraction1.floatValue(), 0.01F);
}","/**
 * <p>Gets the fraction as a <code>float</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>float</code>
 */"
"// Calculations
//-------------------------------------------------------------------
/**
 * <p>Reduce the fraction to the smallest values for the numerator and
 * denominator, returning the result.</p>
 *
 * <p>For example, if this fraction represents 2/4, then the result
 * will be 1/2.</p>
 *
 * @return a new reduced fraction instance, or this if no simplification possible
 */
public Fraction reduce() {
    if (numerator == 0) {
        return equals(ZERO) ? this : ZERO;
    }
    int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
    if (gcd == 1) {
        return this;
    }
    return Fraction.getFraction(numerator / gcd, denominator / gcd);
}","public void test01117() throws Throwable {
    Fraction fraction0 = Fraction.getFraction((-870.279420099903));
    Fraction fraction1 = fraction0.reduce();
    assertSame(fraction1, fraction0);
}",""
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test01218() throws Throwable {
    Fraction fraction0 = Fraction.ONE_QUARTER;
    Fraction fraction1 = fraction0.ZERO.pow(4);
    assertEquals(0.0, fraction1.doubleValue(), 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"public Fraction pow(int power) {
    if (power == 1) {
        return this;
    } else if (power == 0) {
        return ONE;
    } else if (power < 0) {
        if (power == Integer.MIN_VALUE) {
            // MIN_VALUE can't be negated.
            return this.invert().pow(2).pow(-(power / 2));
        }
        return this.invert().pow(-power);
    } else {
        Fraction f = this.multiplyBy(this);
        if ((power % 2) == 0) {
            // if even...
            return f.pow(power / 2);
        } else {
            // if odd...
            return f.pow(power / 2).multiplyBy(this);
        }
    }
}","public void test01319() throws Throwable {
    Fraction fraction0 = Fraction.getFraction((double) (-1));
    Fraction fraction1 = fraction0.pow(3);
    assertNotSame(fraction1, fraction0);
}","/**
 * <p>Gets a fraction that is raised to the passed in power.</p>
 *
 * <p>The returned fraction is in reduced form.</p>
 *
 * @param power  the power to raise the fraction to
 * @return <code>this</code> if the power is one, <code>ONE</code> if the power
 * is zero (even if the fraction equals ZERO) or a new fraction instance
 * raised to the appropriate power
 * @throws ArithmeticException if the resulting numerator or denominator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"@Override
public float floatValue() {
    return ((float) numerator) / ((float) denominator);
}","public void test01320() throws Throwable {
    Fraction fraction0 = Fraction.getFraction((double) (-1));
    Fraction fraction1 = fraction0.pow(3);
    assertEquals((-1.0F), fraction1.floatValue(), 0.01F);
}","/**
 * <p>Gets the fraction as a <code>float</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>float</code>
 */"
"public int getDenominator() {
    return denominator;
}","public void test01321() throws Throwable {
    Fraction fraction0 = Fraction.getFraction((double) (-1));
    Fraction fraction1 = fraction0.pow(3);
    assertEquals(1, fraction0.getDenominator());
}","/**
 * <p>Gets the denominator part of the fraction.</p>
 *
 * @return the denominator fraction part
 */"
"@Override
public float floatValue() {
    return ((float) numerator) / ((float) denominator);
}","public void test01422() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction(1218, 3);
    Fraction fraction1 = fraction0.pow(3);
    assertEquals(406.0F, fraction0.floatValue(), 0.01F);
}","/**
 * <p>Gets the fraction as a <code>float</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>float</code>
 */"
"// Accessors
//-------------------------------------------------------------------
/**
 * <p>Gets the numerator part of the fraction.</p>
 *
 * <p>This method may return a value greater than the denominator, an
 * improper fraction, such as the seven in 7/4.</p>
 *
 * @return the numerator fraction part
 */
public int getNumerator() {
    return numerator;
}","public void test01423() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction(1218, 3);
    Fraction fraction1 = fraction0.pow(3);
    assertEquals(66923416, fraction1.getNumerator());
}",""
"// Basics
//-------------------------------------------------------------------
/**
 * <p>Compares this fraction to another object to test if they are equal.</p>.
 *
 * <p>To be equal, both values must be equal. Thus 2/4 is not equal to 1/2.</p>
 *
 * @param obj the reference object with which to compare
 * @return <code>true</code> if this object is equal
 */
@Override
public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (obj instanceof Fraction == false) {
        return false;
    }
    Fraction other = (Fraction) obj;
    return (getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator());
}","public void test01524() throws Throwable {
    Fraction fraction0 = Fraction.ZERO;
    Fraction fraction1 = fraction0.negate();
    assertTrue(fraction1.equals((Object) fraction0));
}",""
"@Override
public float floatValue() {
    return ((float) numerator) / ((float) denominator);
}","public void test01625() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    Fraction fraction1 = fraction0.negate();
    fraction1.negate();
    assertEquals((-1.0F), fraction1.floatValue(), 0.01F);
}","/**
 * <p>Gets the fraction as a <code>float</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>float</code>
 */"
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test01726() throws Throwable {
    Fraction fraction0 = Fraction.ONE_HALF;
    Fraction fraction1 = Fraction.getFraction((-811.22));
    Fraction fraction2 = fraction1.multiplyBy(fraction0);
    assertEquals((-405.61), fraction2.doubleValue(), 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"// Number methods
//-------------------------------------------------------------------
/**
 * <p>Gets the fraction as an <code>int</code>. This returns the whole number
 * part of the fraction.</p>
 *
 * @return the whole number fraction part
 */
@Override
public int intValue() {
    return numerator / denominator;
}","public void test01727() throws Throwable {
    Fraction fraction0 = Fraction.ONE_HALF;
    Fraction fraction1 = Fraction.getFraction((-811.22));
    Fraction fraction2 = fraction1.multiplyBy(fraction0);
    assertEquals((-811), fraction1.intValue());
}",""
"@Override
public long longValue() {
    return (long) numerator / denominator;
}","public void test01828() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    long long0 = fraction0.longValue();
    assertEquals(1L, long0);
}","/**
 * <p>Gets the fraction as a <code>long</code>. This returns the whole number
 * part of the fraction.</p>
 *
 * @return the whole number fraction part
 */"
"// Accessors
//-------------------------------------------------------------------
/**
 * <p>Gets the numerator part of the fraction.</p>
 *
 * <p>This method may return a value greater than the denominator, an
 * improper fraction, such as the seven in 7/4.</p>
 *
 * @return the numerator fraction part
 */
public int getNumerator() {
    return numerator;
}","public void test01929() throws Throwable {
    Fraction fraction0 = Fraction.getFraction((-4909), 0, 286);
    long long0 = fraction0.longValue();
    assertEquals((-1403974), fraction0.getNumerator());
}",""
"@Override
public long longValue() {
    return (long) numerator / denominator;
}","public void test01930() throws Throwable {
    Fraction fraction0 = Fraction.getFraction((-4909), 0, 286);
    long long0 = fraction0.longValue();
    assertEquals((-4909L), long0);
}","/**
 * <p>Gets the fraction as a <code>long</code>. This returns the whole number
 * part of the fraction.</p>
 *
 * @return the whole number fraction part
 */"
"// Accessors
//-------------------------------------------------------------------
/**
 * <p>Gets the numerator part of the fraction.</p>
 *
 * <p>This method may return a value greater than the denominator, an
 * improper fraction, such as the seven in 7/4.</p>
 *
 * @return the numerator fraction part
 */
public int getNumerator() {
    return numerator;
}","public void test02031() throws Throwable {
    Fraction fraction0 = Fraction.THREE_QUARTERS;
    Fraction fraction1 = fraction0.add(fraction0);
    Fraction fraction2 = fraction1.invert();
    assertEquals(2, fraction2.getNumerator());
}",""
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test02032() throws Throwable {
    Fraction fraction0 = Fraction.THREE_QUARTERS;
    Fraction fraction1 = fraction0.add(fraction0);
    Fraction fraction2 = fraction1.invert();
    assertEquals(1.5, fraction1.doubleValue(), 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"// Number methods
//-------------------------------------------------------------------
/**
 * <p>Gets the fraction as an <code>int</code>. This returns the whole number
 * part of the fraction.</p>
 *
 * @return the whole number fraction part
 */
@Override
public int intValue() {
    return numerator / denominator;
}","public void test02133() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    int int0 = fraction0.intValue();
    assertEquals(1, int0);
}",""
"// Number methods
//-------------------------------------------------------------------
/**
 * <p>Gets the fraction as an <code>int</code>. This returns the whole number
 * part of the fraction.</p>
 *
 * @return the whole number fraction part
 */
@Override
public int intValue() {
    return numerator / denominator;
}","public void test02234() throws Throwable {
    Fraction fraction0 = Fraction.getFraction((-472.68686588506665));
    int int0 = fraction0.intValue();
    assertEquals((-472), int0);
}",""
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test02235() throws Throwable {
    Fraction fraction0 = Fraction.getFraction((-472.68686588506665));
    int int0 = fraction0.intValue();
    assertEquals((-472.6868658790827), fraction0.doubleValue(), 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"public int getDenominator() {
    return denominator;
}","public void test02236() throws Throwable {
    Fraction fraction0 = Fraction.getFraction((-472.68686588506665));
    int int0 = fraction0.intValue();
    assertEquals(7195, fraction0.getDenominator());
}","/**
 * <p>Gets the denominator part of the fraction.</p>
 *
 * @return the denominator fraction part
 */"
"public int getProperWhole() {
    return numerator / denominator;
}","public void test02337() throws Throwable {
    Fraction fraction0 = Fraction.ONE_FIFTH;
    int int0 = fraction0.getProperWhole();
    assertEquals(0, int0);
}","/**
 * <p>Gets the proper whole part of the fraction.</p>
 *
 * <p>An improper fraction 7/4 can be resolved into a proper one, 1 3/4.
 * This method returns the 1 from the proper fraction.</p>
 *
 * <p>If the fraction is negative such as -7/4, it can be resolved into
 * -1 3/4, so this method returns the positive whole part -1.</p>
 *
 * @return the whole fraction part of a proper fraction, that includes the sign
 */"
"// Accessors
//-------------------------------------------------------------------
/**
 * <p>Gets the numerator part of the fraction.</p>
 *
 * <p>This method may return a value greater than the denominator, an
 * improper fraction, such as the seven in 7/4.</p>
 *
 * @return the numerator fraction part
 */
public int getNumerator() {
    return numerator;
}","public void test02438() throws Throwable {
    Fraction fraction0 = Fraction.getFraction(718, 718);
    int int0 = fraction0.getProperWhole();
    assertEquals(718, fraction0.getNumerator());
}",""
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test02439() throws Throwable {
    Fraction fraction0 = Fraction.getFraction(718, 718);
    int int0 = fraction0.getProperWhole();
    assertEquals(1.0, fraction0.doubleValue(), 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"public int getProperWhole() {
    return numerator / denominator;
}","public void test02440() throws Throwable {
    Fraction fraction0 = Fraction.getFraction(718, 718);
    int int0 = fraction0.getProperWhole();
    assertEquals(1, int0);
}","/**
 * <p>Gets the proper whole part of the fraction.</p>
 *
 * <p>An improper fraction 7/4 can be resolved into a proper one, 1 3/4.
 * This method returns the 1 from the proper fraction.</p>
 *
 * <p>If the fraction is negative such as -7/4, it can be resolved into
 * -1 3/4, so this method returns the positive whole part -1.</p>
 *
 * @return the whole fraction part of a proper fraction, that includes the sign
 */"
"// Accessors
//-------------------------------------------------------------------
/**
 * <p>Gets the numerator part of the fraction.</p>
 *
 * <p>This method may return a value greater than the denominator, an
 * improper fraction, such as the seven in 7/4.</p>
 *
 * @return the numerator fraction part
 */
public int getNumerator() {
    return numerator;
}","public void test02541() throws Throwable {
    Fraction fraction0 = Fraction.ONE_QUARTER;
    Fraction fraction1 = fraction0.invert();
    int int0 = fraction1.getProperNumerator();
    assertEquals(4, fraction1.getNumerator());
}",""
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test02542() throws Throwable {
    Fraction fraction0 = Fraction.ONE_QUARTER;
    Fraction fraction1 = fraction0.invert();
    int int0 = fraction1.getProperNumerator();
    assertEquals(4.0, fraction1.doubleValue(), 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"public int getProperNumerator() {
    return Math.abs(numerator % denominator);
}","public void test02543() throws Throwable {
    Fraction fraction0 = Fraction.ONE_QUARTER;
    Fraction fraction1 = fraction0.invert();
    int int0 = fraction1.getProperNumerator();
    assertEquals(0, int0);
}","/**
 * <p>Gets the proper numerator, always positive.</p>
 *
 * <p>An improper fraction 7/4 can be resolved into a proper one, 1 3/4.
 * This method returns the 3 from the proper fraction.</p>
 *
 * <p>If the fraction is negative such as -7/4, it can be resolved into
 * -1 3/4, so this method returns the positive proper numerator, 3.</p>
 *
 * @return the numerator fraction part of a proper fraction, always positive
 */"
"// Accessors
//-------------------------------------------------------------------
/**
 * <p>Gets the numerator part of the fraction.</p>
 *
 * <p>This method may return a value greater than the denominator, an
 * improper fraction, such as the seven in 7/4.</p>
 *
 * @return the numerator fraction part
 */
public int getNumerator() {
    return numerator;
}","public void test02644() throws Throwable {
    Fraction fraction0 = Fraction.ZERO;
    int int0 = fraction0.getNumerator();
    assertEquals(0, int0);
}",""
"// Accessors
//-------------------------------------------------------------------
/**
 * <p>Gets the numerator part of the fraction.</p>
 *
 * <p>This method may return a value greater than the denominator, an
 * improper fraction, such as the seven in 7/4.</p>
 *
 * @return the numerator fraction part
 */
public int getNumerator() {
    return numerator;
}","public void test02745() throws Throwable {
    Fraction fraction0 = Fraction.TWO_THIRDS;
    Fraction fraction1 = fraction0.negate();
    int int0 = fraction1.getNumerator();
    assertEquals((-2), int0);
}",""
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test02746() throws Throwable {
    Fraction fraction0 = Fraction.TWO_THIRDS;
    Fraction fraction1 = fraction0.negate();
    int int0 = fraction1.getNumerator();
    assertEquals((-0.6666666666666666), fraction1.doubleValue(), 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"public int getDenominator() {
    return denominator;
}","public void test02847() throws Throwable {
    Fraction fraction0 = Fraction.getFraction(""0"");
    assertEquals(1, fraction0.getDenominator());
}","/**
 * <p>Gets the denominator part of the fraction.</p>
 *
 * @return the denominator fraction part
 */"
"@Override
public float floatValue() {
    return ((float) numerator) / ((float) denominator);
}","public void test02848() throws Throwable {
    Fraction fraction0 = Fraction.getFraction(""0"");
    assertEquals(0.0F, fraction0.floatValue(), 0.01F);
}","/**
 * <p>Gets the fraction as a <code>float</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>float</code>
 */"
"public int getDenominator() {
    return denominator;
}","public void test02949() throws Throwable {
    Fraction fraction0 = Fraction.getFraction(""-1"");
    assertEquals(1, fraction0.getDenominator());
}","/**
 * <p>Gets the denominator part of the fraction.</p>
 *
 * @return the denominator fraction part
 */"
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test02950() throws Throwable {
    Fraction fraction0 = Fraction.getFraction(""-1"");
    assertEquals((-1.0), fraction0.doubleValue(), 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"public int getDenominator() {
    return denominator;
}","public void test03051() throws Throwable {
    Fraction fraction0 = Fraction.getFraction(0, 0, 10000);
    assertEquals(10000, fraction0.getDenominator());
}","/**
 * <p>Gets the denominator part of the fraction.</p>
 *
 * @return the denominator fraction part
 */"
"@Override
public float floatValue() {
    return ((float) numerator) / ((float) denominator);
}","public void test03052() throws Throwable {
    Fraction fraction0 = Fraction.getFraction(0, 0, 10000);
    assertEquals(0.0F, fraction0.floatValue(), 0.01F);
}","/**
 * <p>Gets the fraction as a <code>float</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>float</code>
 */"
"@Override
public float floatValue() {
    return ((float) numerator) / ((float) denominator);
}","public void test03153() throws Throwable {
    Fraction fraction0 = Fraction.getFraction(0, 1);
    assertEquals(0.0F, fraction0.floatValue(), 0.01F);
}","/**
 * <p>Gets the fraction as a <code>float</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>float</code>
 */"
"public int getDenominator() {
    return denominator;
}","public void test03154() throws Throwable {
    Fraction fraction0 = Fraction.getFraction(0, 1);
    assertEquals(1, fraction0.getDenominator());
}","/**
 * <p>Gets the denominator part of the fraction.</p>
 *
 * @return the denominator fraction part
 */"
"public int getDenominator() {
    return denominator;
}","public void test03255() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction(0, 2456);
    float float0 = fraction0.floatValue();
    assertEquals(1, fraction0.getDenominator());
}","/**
 * <p>Gets the denominator part of the fraction.</p>
 *
 * @return the denominator fraction part
 */"
"@Override
public float floatValue() {
    return ((float) numerator) / ((float) denominator);
}","public void test03256() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction(0, 2456);
    float float0 = fraction0.floatValue();
    assertEquals(0.0F, float0, 0.01F);
}","/**
 * <p>Gets the fraction as a <code>float</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>float</code>
 */"
"@Override
public float floatValue() {
    return ((float) numerator) / ((float) denominator);
}","public void test03357() throws Throwable {
    Fraction fraction0 = Fraction.TWO_THIRDS;
    Fraction fraction1 = fraction0.negate();
    float float0 = fraction1.floatValue();
    assertEquals((-0.6666667F), float0, 0.01F);
}","/**
 * <p>Gets the fraction as a <code>float</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>float</code>
 */"
"public int getDenominator() {
    return denominator;
}","public void test03458() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction(0, (-249));
    double double0 = fraction0.doubleValue();
    assertEquals(1, fraction0.getDenominator());
}","/**
 * <p>Gets the denominator part of the fraction.</p>
 *
 * @return the denominator fraction part
 */"
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test03459() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction(0, (-249));
    double double0 = fraction0.doubleValue();
    assertEquals(0.0, double0, 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test03560() throws Throwable {
    Fraction fraction0 = Fraction.THREE_QUARTERS;
    Fraction fraction1 = fraction0.THREE_QUARTERS.negate();
    double double0 = fraction1.doubleValue();
    assertEquals((-0.75), double0, 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test03661() throws Throwable {
    Fraction fraction0 = Fraction.ONE_HALF;
    Fraction fraction1 = fraction0.THREE_FIFTHS.negate();
    Fraction fraction2 = fraction1.divideBy(fraction0);
    assertEquals((-1.2), fraction2.doubleValue(), 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"@Override
public long longValue() {
    return (long) numerator / denominator;
}","public void test03762() throws Throwable {
    Fraction fraction0 = Fraction.FOUR_FIFTHS;
    Fraction fraction1 = fraction0.ZERO.abs();
    assertEquals(0L, fraction1.longValue());
}","/**
 * <p>Gets the fraction as a <code>long</code>. This returns the whole number
 * part of the fraction.</p>
 *
 * @return the whole number fraction part
 */"
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test03863() throws Throwable {
    Fraction fraction0 = Fraction.getFraction(2.147483647E9);
    Fraction fraction1 = fraction0.abs();
    assertEquals(2.147483647E9, fraction0.doubleValue(), 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test03864() throws Throwable {
    Fraction fraction0 = Fraction.getFraction(2.147483647E9);
    Fraction fraction1 = fraction0.abs();
    assertEquals(2.147483647E9, fraction1.doubleValue(), 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"public Fraction subtract(Fraction fraction) {
    return addSub(fraction, false);
}","public void test03965() throws Throwable {
    Fraction fraction0 = Fraction.ONE_HALF;
    // Undeclared exception!
    try {
        fraction0.FOUR_FIFTHS.subtract((Fraction) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The fraction must not be null
        //
        verifyException(""org.apache.commons.lang3.math.Fraction"", e);
    }
}","/**
 * <p>Subtracts the value of another fraction from the value of this one,
 * returning the result in reduced form.</p>
 *
 * @param fraction  the fraction to subtract, must not be <code>null</code>
 * @return a <code>Fraction</code> instance with the resulting values
 * @throws IllegalArgumentException if the fraction is <code>null</code>
 * @throws ArithmeticException if the resulting numerator or denominator
 *   cannot be represented in an <code>int</code>.
 */"
"public Fraction subtract(Fraction fraction) {
    return addSub(fraction, false);
}","public void test04066() throws Throwable {
    Fraction fraction0 = Fraction.getFraction((-3579.914338));
    Fraction fraction1 = Fraction.getFraction((-1140), (-2147483593));
    // Undeclared exception!
    try {
        fraction0.subtract(fraction1);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: mul
        //
        verifyException(""org.apache.commons.lang3.math.Fraction"", e);
    }
}","/**
 * <p>Subtracts the value of another fraction from the value of this one,
 * returning the result in reduced form.</p>
 *
 * @param fraction  the fraction to subtract, must not be <code>null</code>
 * @return a <code>Fraction</code> instance with the resulting values
 * @throws IllegalArgumentException if the fraction is <code>null</code>
 * @throws ArithmeticException if the resulting numerator or denominator
 *   cannot be represented in an <code>int</code>.
 */"
"public Fraction multiplyBy(Fraction fraction) {
    if (fraction == null) {
        throw new IllegalArgumentException(""The fraction must not be null"");
    }
    if (numerator == 0 || fraction.numerator == 0) {
        return ZERO;
    }
    // knuth 4.5.1
    // make sure we don't overflow unless the result *must* overflow.
    int d1 = greatestCommonDivisor(numerator, fraction.denominator);
    int d2 = greatestCommonDivisor(fraction.numerator, denominator);
    return getReducedFraction(mulAndCheck(numerator / d1, fraction.numerator / d2), mulPosAndCheck(denominator / d2, fraction.denominator / d1));
}","public void test04167() throws Throwable {
    Fraction fraction0 = Fraction.getFraction(2.147483647E9);
    // Undeclared exception!
    try {
        fraction0.multiplyBy(fraction0);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: mul
        //
        verifyException(""org.apache.commons.lang3.math.Fraction"", e);
    }
}","/**
 * <p>Multiplies the value of this fraction by another, returning the
 * result in reduced form.</p>
 *
 * @param fraction  the fraction to multiply by, must not be <code>null</code>
 * @return a <code>Fraction</code> instance with the resulting values
 * @throws IllegalArgumentException if the fraction is <code>null</code>
 * @throws ArithmeticException if the resulting numerator or denominator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"public int compareTo(Fraction other) {
    if (this == other) {
        return 0;
    }
    if (numerator == other.numerator && denominator == other.denominator) {
        return 0;
    }
    // otherwise see which is less
    long first = (long) numerator * (long) other.denominator;
    long second = (long) other.numerator * (long) denominator;
    if (first == second) {
        return 0;
    } else if (first < second) {
        return -1;
    } else {
        return 1;
    }
}","public void test04268() throws Throwable {
    Fraction fraction0 = Fraction.getFraction((-1081), 2152, 2152);
    // Undeclared exception!
    try {
        fraction0.compareTo((Fraction) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.math.Fraction"", e);
    }
}","/**
 * <p>Compares this object to another based on size.</p>
 *
 * <p>Note: this class has a natural ordering that is inconsistent
 * with equals, because, for example, equals treats 1/2 and 2/4 as
 * different, whereas compareTo treats them as equal.
 *
 * @param other  the object to compare to
 * @return -1 if this is less, 0 if equal, +1 if greater
 * @throws ClassCastException if the object is not a <code>Fraction</code>
 * @throws NullPointerException if the object is <code>null</code>
 */"
"public Fraction add(Fraction fraction) {
    return addSub(fraction, true);
}","public void test04369() throws Throwable {
    Fraction fraction0 = Fraction.ONE_HALF;
    Fraction fraction1 = Fraction.getFraction(2144467519, 277);
    // Undeclared exception!
    try {
        fraction0.add(fraction1);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: mul
        //
        verifyException(""org.apache.commons.lang3.math.Fraction"", e);
    }
}","/**
 * <p>Adds the value of this fraction to another, returning the result in reduced form.
 * The algorithm follows Knuth, 4.5.1.</p>
 *
 * @param fraction  the fraction to add, must not be <code>null</code>
 * @return a <code>Fraction</code> instance with the resulting values
 * @throws IllegalArgumentException if the fraction is <code>null</code>
 * @throws ArithmeticException if the resulting numerator or denominator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"// Basics
//-------------------------------------------------------------------
/**
 * <p>Compares this fraction to another object to test if they are equal.</p>.
 *
 * <p>To be equal, both values must be equal. Thus 2/4 is not equal to 1/2.</p>
 *
 * @param obj the reference object with which to compare
 * @return <code>true</code> if this object is equal
 */
@Override
public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (obj instanceof Fraction == false) {
        return false;
    }
    Fraction other = (Fraction) obj;
    return (getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator());
}","public void test04470() throws Throwable {
    Fraction fraction0 = Fraction.ONE_HALF;
    Fraction fraction1 = Fraction.getFraction(""1/5"");
    boolean boolean0 = fraction0.equals(fraction1);
    assertFalse(fraction1.equals((Object) fraction0));
}",""
"public int getDenominator() {
    return denominator;
}","public void test04471() throws Throwable {
    Fraction fraction0 = Fraction.ONE_HALF;
    Fraction fraction1 = Fraction.getFraction(""1/5"");
    boolean boolean0 = fraction0.equals(fraction1);
    assertEquals(2, fraction0.getDenominator());
}","/**
 * <p>Gets the denominator part of the fraction.</p>
 *
 * @return the denominator fraction part
 */"
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test04472() throws Throwable {
    Fraction fraction0 = Fraction.ONE_HALF;
    Fraction fraction1 = Fraction.getFraction(""1/5"");
    boolean boolean0 = fraction0.equals(fraction1);
    assertEquals(0.2, fraction1.doubleValue(), 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"// Basics
//-------------------------------------------------------------------
/**
 * <p>Compares this fraction to another object to test if they are equal.</p>.
 *
 * <p>To be equal, both values must be equal. Thus 2/4 is not equal to 1/2.</p>
 *
 * @param obj the reference object with which to compare
 * @return <code>true</code> if this object is equal
 */
@Override
public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (obj instanceof Fraction == false) {
        return false;
    }
    Fraction other = (Fraction) obj;
    return (getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator());
}","public void test04473() throws Throwable {
    Fraction fraction0 = Fraction.ONE_HALF;
    Fraction fraction1 = Fraction.getFraction(""1/5"");
    boolean boolean0 = fraction0.equals(fraction1);
    assertFalse(boolean0);
}",""
"// Accessors
//-------------------------------------------------------------------
/**
 * <p>Gets the numerator part of the fraction.</p>
 *
 * <p>This method may return a value greater than the denominator, an
 * improper fraction, such as the seven in 7/4.</p>
 *
 * @return the numerator fraction part
 */
public int getNumerator() {
    return numerator;
}","public void test04474() throws Throwable {
    Fraction fraction0 = Fraction.ONE_HALF;
    Fraction fraction1 = Fraction.getFraction(""1/5"");
    boolean boolean0 = fraction0.equals(fraction1);
    assertEquals(1, fraction1.getNumerator());
}",""
"// Accessors
//-------------------------------------------------------------------
/**
 * <p>Gets the numerator part of the fraction.</p>
 *
 * <p>This method may return a value greater than the denominator, an
 * improper fraction, such as the seven in 7/4.</p>
 *
 * @return the numerator fraction part
 */
public int getNumerator() {
    return numerator;
}","public void test04575() throws Throwable {
    Fraction fraction0 = Fraction.TWO_QUARTERS;
    Fraction fraction1 = fraction0.ZERO.multiplyBy(fraction0);
    assertEquals(0, fraction1.getNumerator());
}",""
"// Accessors
//-------------------------------------------------------------------
/**
 * <p>Gets the numerator part of the fraction.</p>
 *
 * <p>This method may return a value greater than the denominator, an
 * improper fraction, such as the seven in 7/4.</p>
 *
 * @return the numerator fraction part
 */
public int getNumerator() {
    return numerator;
}","public void test04676() throws Throwable {
    Fraction fraction0 = Fraction.FOUR_FIFTHS;
    Fraction fraction1 = Fraction.getFraction(1094, 1094, 1094);
    Fraction fraction2 = fraction0.TWO_FIFTHS.multiplyBy(fraction1);
    Fraction fraction3 = fraction2.subtract(fraction0);
    assertEquals(2186, fraction3.getNumerator());
}",""
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test04777() throws Throwable {
    Fraction fraction0 = Fraction.ONE_QUARTER;
    Fraction fraction1 = fraction0.TWO_THIRDS.divideBy(fraction0);
    assertEquals(2.6666666666666665, fraction1.doubleValue(), 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"public int getDenominator() {
    return denominator;
}","public void test04778() throws Throwable {
    Fraction fraction0 = Fraction.ONE_QUARTER;
    Fraction fraction1 = fraction0.TWO_THIRDS.divideBy(fraction0);
    assertEquals(3, fraction1.getDenominator());
}","/**
 * <p>Gets the denominator part of the fraction.</p>
 *
 * @return the denominator fraction part
 */"
"public Fraction pow(int power) {
    if (power == 1) {
        return this;
    } else if (power == 0) {
        return ONE;
    } else if (power < 0) {
        if (power == Integer.MIN_VALUE) {
            // MIN_VALUE can't be negated.
            return this.invert().pow(2).pow(-(power / 2));
        }
        return this.invert().pow(-power);
    } else {
        Fraction f = this.multiplyBy(this);
        if ((power % 2) == 0) {
            // if even...
            return f.pow(power / 2);
        } else {
            // if odd...
            return f.pow(power / 2).multiplyBy(this);
        }
    }
}","public void test04879() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    Fraction fraction1 = fraction0.pow(3878);
    assertNotSame(fraction1, fraction0);
}","/**
 * <p>Gets a fraction that is raised to the passed in power.</p>
 *
 * <p>The returned fraction is in reduced form.</p>
 *
 * @param power  the power to raise the fraction to
 * @return <code>this</code> if the power is one, <code>ONE</code> if the power
 * is zero (even if the fraction equals ZERO) or a new fraction instance
 * raised to the appropriate power
 * @throws ArithmeticException if the resulting numerator or denominator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"// Number methods
//-------------------------------------------------------------------
/**
 * <p>Gets the fraction as an <code>int</code>. This returns the whole number
 * part of the fraction.</p>
 *
 * @return the whole number fraction part
 */
@Override
public int intValue() {
    return numerator / denominator;
}","public void test04880() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    Fraction fraction1 = fraction0.pow(3878);
    assertEquals(1, fraction1.intValue());
}",""
"public Fraction pow(int power) {
    if (power == 1) {
        return this;
    } else if (power == 0) {
        return ONE;
    } else if (power < 0) {
        if (power == Integer.MIN_VALUE) {
            // MIN_VALUE can't be negated.
            return this.invert().pow(2).pow(-(power / 2));
        }
        return this.invert().pow(-power);
    } else {
        Fraction f = this.multiplyBy(this);
        if ((power % 2) == 0) {
            // if even...
            return f.pow(power / 2);
        } else {
            // if odd...
            return f.pow(power / 2).multiplyBy(this);
        }
    }
}","public void test04981() throws Throwable {
    Fraction fraction0 = Fraction.ONE_HALF;
    Fraction fraction1 = fraction0.pow(1);
    assertSame(fraction1, fraction0);
}","/**
 * <p>Gets a fraction that is raised to the passed in power.</p>
 *
 * <p>The returned fraction is in reduced form.</p>
 *
 * @param power  the power to raise the fraction to
 * @return <code>this</code> if the power is one, <code>ONE</code> if the power
 * is zero (even if the fraction equals ZERO) or a new fraction instance
 * raised to the appropriate power
 * @throws ArithmeticException if the resulting numerator or denominator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"@Override
public float floatValue() {
    return ((float) numerator) / ((float) denominator);
}","public void test05082() throws Throwable {
    Fraction fraction0 = Fraction.getFraction(718, 718);
    int int0 = fraction0.getNumerator();
    assertEquals(1.0F, fraction0.floatValue(), 0.01F);
}","/**
 * <p>Gets the fraction as a <code>float</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>float</code>
 */"
"// Accessors
//-------------------------------------------------------------------
/**
 * <p>Gets the numerator part of the fraction.</p>
 *
 * <p>This method may return a value greater than the denominator, an
 * improper fraction, such as the seven in 7/4.</p>
 *
 * @return the numerator fraction part
 */
public int getNumerator() {
    return numerator;
}","public void test05083() throws Throwable {
    Fraction fraction0 = Fraction.getFraction(718, 718);
    int int0 = fraction0.getNumerator();
    assertEquals(718, int0);
}",""
"public int getProperWhole() {
    return numerator / denominator;
}","public void test05184() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction((-77), 4);
    int int0 = fraction0.getProperWhole();
    assertEquals((-19), int0);
}","/**
 * <p>Gets the proper whole part of the fraction.</p>
 *
 * <p>An improper fraction 7/4 can be resolved into a proper one, 1 3/4.
 * This method returns the 1 from the proper fraction.</p>
 *
 * <p>If the fraction is negative such as -7/4, it can be resolved into
 * -1 3/4, so this method returns the positive whole part -1.</p>
 *
 * @return the whole fraction part of a proper fraction, that includes the sign
 */"
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test05185() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction((-77), 4);
    int int0 = fraction0.getProperWhole();
    assertEquals((-19.25), fraction0.doubleValue(), 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"// Accessors
//-------------------------------------------------------------------
/**
 * <p>Gets the numerator part of the fraction.</p>
 *
 * <p>This method may return a value greater than the denominator, an
 * improper fraction, such as the seven in 7/4.</p>
 *
 * @return the numerator fraction part
 */
public int getNumerator() {
    return numerator;
}","public void test05186() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction((-77), 4);
    int int0 = fraction0.getProperWhole();
    assertEquals((-77), fraction0.getNumerator());
}",""
"public int getDenominator() {
    return denominator;
}","public void test05287() throws Throwable {
    Fraction fraction0 = Fraction.ONE_QUARTER;
    Fraction fraction1 = fraction0.invert();
    String string0 = fraction1.toProperString();
    assertEquals(1, fraction1.getDenominator());
}","/**
 * <p>Gets the denominator part of the fraction.</p>
 *
 * @return the denominator fraction part
 */"
"public int getProperNumerator() {
    return Math.abs(numerator % denominator);
}","public void test05288() throws Throwable {
    Fraction fraction0 = Fraction.ONE_QUARTER;
    Fraction fraction1 = fraction0.invert();
    String string0 = fraction1.toProperString();
    assertEquals(1, fraction0.getProperNumerator());
}","/**
 * <p>Gets the proper numerator, always positive.</p>
 *
 * <p>An improper fraction 7/4 can be resolved into a proper one, 1 3/4.
 * This method returns the 3 from the proper fraction.</p>
 *
 * <p>If the fraction is negative such as -7/4, it can be resolved into
 * -1 3/4, so this method returns the positive proper numerator, 3.</p>
 *
 * @return the numerator fraction part of a proper fraction, always positive
 */"
"public int getProperWhole() {
    return numerator / denominator;
}","public void test05289() throws Throwable {
    Fraction fraction0 = Fraction.ONE_QUARTER;
    Fraction fraction1 = fraction0.invert();
    String string0 = fraction1.toProperString();
    assertEquals(0, fraction0.getProperWhole());
}","/**
 * <p>Gets the proper whole part of the fraction.</p>
 *
 * <p>An improper fraction 7/4 can be resolved into a proper one, 1 3/4.
 * This method returns the 1 from the proper fraction.</p>
 *
 * <p>If the fraction is negative such as -7/4, it can be resolved into
 * -1 3/4, so this method returns the positive whole part -1.</p>
 *
 * @return the whole fraction part of a proper fraction, that includes the sign
 */"
"public String toProperString() {
    if (toProperString == null) {
        if (numerator == 0) {
            toProperString = ""0"";
        } else if (numerator == denominator) {
            toProperString = ""1"";
        } else if (numerator == -1 * denominator) {
            toProperString = ""-1"";
        } else if ((numerator > 0 ? -numerator : numerator) < -denominator) {
            // note that we do the magnitude comparison test above with
            // NEGATIVE (not positive) numbers, since negative numbers
            // have a larger range.  otherwise numerator==Integer.MIN_VALUE
            // is handled incorrectly.
            int properNumerator = getProperNumerator();
            if (properNumerator == 0) {
                toProperString = Integer.toString(getProperWhole());
            } else {
                toProperString = new StringBuilder(32).append(getProperWhole()).append(' ').append(properNumerator).append('/').append(getDenominator()).toString();
            }
        } else {
            toProperString = new StringBuilder(32).append(getNumerator()).append('/').append(getDenominator()).toString();
        }
    }
    return toProperString;
}","public void test05290() throws Throwable {
    Fraction fraction0 = Fraction.ONE_QUARTER;
    Fraction fraction1 = fraction0.invert();
    String string0 = fraction1.toProperString();
    assertEquals(""4"", string0);
}","/**
 * <p>Gets the fraction as a proper <code>String</code> in the format X Y/Z.</p>
 *
 * <p>The format used in '<i>wholeNumber</i> <i>numerator</i>/<i>denominator</i>'.
 * If the whole number is zero it will be ommitted. If the numerator is zero,
 * only the whole number is returned.</p>
 *
 * @return a <code>String</code> form of the fraction
 */"
"public String toProperString() {
    if (toProperString == null) {
        if (numerator == 0) {
            toProperString = ""0"";
        } else if (numerator == denominator) {
            toProperString = ""1"";
        } else if (numerator == -1 * denominator) {
            toProperString = ""-1"";
        } else if ((numerator > 0 ? -numerator : numerator) < -denominator) {
            // note that we do the magnitude comparison test above with
            // NEGATIVE (not positive) numbers, since negative numbers
            // have a larger range.  otherwise numerator==Integer.MIN_VALUE
            // is handled incorrectly.
            int properNumerator = getProperNumerator();
            if (properNumerator == 0) {
                toProperString = Integer.toString(getProperWhole());
            } else {
                toProperString = new StringBuilder(32).append(getProperWhole()).append(' ').append(properNumerator).append('/').append(getDenominator()).toString();
            }
        } else {
            toProperString = new StringBuilder(32).append(getNumerator()).append('/').append(getDenominator()).toString();
        }
    }
    return toProperString;
}","public void test05392() throws Throwable {
    Fraction fraction0 = Fraction.ONE_FIFTH;
    String string0 = fraction0.toProperString();
    assertEquals(""1/5"", string0);
}","/**
 * <p>Gets the fraction as a proper <code>String</code> in the format X Y/Z.</p>
 *
 * <p>The format used in '<i>wholeNumber</i> <i>numerator</i>/<i>denominator</i>'.
 * If the whole number is zero it will be ommitted. If the numerator is zero,
 * only the whole number is returned.</p>
 *
 * @return a <code>String</code> form of the fraction
 */"
"// Accessors
//-------------------------------------------------------------------
/**
 * <p>Gets the numerator part of the fraction.</p>
 *
 * <p>This method may return a value greater than the denominator, an
 * improper fraction, such as the seven in 7/4.</p>
 *
 * @return the numerator fraction part
 */
public int getNumerator() {
    return numerator;
}","public void test05493() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction((-77), 4);
    String string0 = fraction0.toProperString();
    assertEquals((-77), fraction0.getNumerator());
}",""
"public String toProperString() {
    if (toProperString == null) {
        if (numerator == 0) {
            toProperString = ""0"";
        } else if (numerator == denominator) {
            toProperString = ""1"";
        } else if (numerator == -1 * denominator) {
            toProperString = ""-1"";
        } else if ((numerator > 0 ? -numerator : numerator) < -denominator) {
            // note that we do the magnitude comparison test above with
            // NEGATIVE (not positive) numbers, since negative numbers
            // have a larger range.  otherwise numerator==Integer.MIN_VALUE
            // is handled incorrectly.
            int properNumerator = getProperNumerator();
            if (properNumerator == 0) {
                toProperString = Integer.toString(getProperWhole());
            } else {
                toProperString = new StringBuilder(32).append(getProperWhole()).append(' ').append(properNumerator).append('/').append(getDenominator()).toString();
            }
        } else {
            toProperString = new StringBuilder(32).append(getNumerator()).append('/').append(getDenominator()).toString();
        }
    }
    return toProperString;
}","public void test05494() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction((-77), 4);
    String string0 = fraction0.toProperString();
    assertEquals(""-19 1/4"", string0);
}","/**
 * <p>Gets the fraction as a proper <code>String</code> in the format X Y/Z.</p>
 *
 * <p>The format used in '<i>wholeNumber</i> <i>numerator</i>/<i>denominator</i>'.
 * If the whole number is zero it will be ommitted. If the numerator is zero,
 * only the whole number is returned.</p>
 *
 * @return a <code>String</code> form of the fraction
 */"
"public static Fraction getFraction(int whole, int numerator, int denominator) {
    if (denominator == 0) {
        throw new ArithmeticException(""The denominator must not be zero"");
    }
    if (denominator < 0) {
        throw new ArithmeticException(""The denominator must not be negative"");
    }
    if (numerator < 0) {
        throw new ArithmeticException(""The numerator must not be negative"");
    }
    long numeratorValue;
    if (whole < 0) {
        numeratorValue = whole * (long) denominator - numerator;
    } else {
        numeratorValue = whole * (long) denominator + numerator;
    }
    if (numeratorValue < Integer.MIN_VALUE || numeratorValue > Integer.MAX_VALUE) {
        throw new ArithmeticException(""Numerator too large to represent as an Integer."");
    }
    return new Fraction((int) numeratorValue, denominator);
}","public void test05595() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction(0, 664);
    fraction0.toProperString();
    // Undeclared exception!
    try {
        Fraction.getFraction(664, 0, 0);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // The denominator must not be zero
        //
        verifyException(""org.apache.commons.lang3.math.Fraction"", e);
    }
}","/**
 * <p>Creates a <code>Fraction</code> instance with the 3 parts
 * of a fraction X Y/Z.</p>
 *
 * <p>The negative sign must be passed in on the whole number part.</p>
 *
 * @param whole  the whole number, for example the one in 'one and three sevenths'
 * @param numerator  the numerator, for example the three in 'one and three sevenths'
 * @param denominator  the denominator, for example the seven in 'one and three sevenths'
 * @return a new fraction instance
 * @throws ArithmeticException if the denominator is <code>zero</code>
 * @throws ArithmeticException if the denominator is negative
 * @throws ArithmeticException if the numerator is negative
 * @throws ArithmeticException if the resulting numerator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"public int getDenominator() {
    return denominator;
}","public void test05696() throws Throwable {
    Fraction fraction0 = Fraction.ONE_FIFTH;
    Fraction fraction1 = Fraction.getReducedFraction(0, 664);
    String string0 = fraction1.toProperString();
    assertEquals(1, fraction1.getDenominator());
}","/**
 * <p>Gets the denominator part of the fraction.</p>
 *
 * @return the denominator fraction part
 */"
"public String toProperString() {
    if (toProperString == null) {
        if (numerator == 0) {
            toProperString = ""0"";
        } else if (numerator == denominator) {
            toProperString = ""1"";
        } else if (numerator == -1 * denominator) {
            toProperString = ""-1"";
        } else if ((numerator > 0 ? -numerator : numerator) < -denominator) {
            // note that we do the magnitude comparison test above with
            // NEGATIVE (not positive) numbers, since negative numbers
            // have a larger range.  otherwise numerator==Integer.MIN_VALUE
            // is handled incorrectly.
            int properNumerator = getProperNumerator();
            if (properNumerator == 0) {
                toProperString = Integer.toString(getProperWhole());
            } else {
                toProperString = new StringBuilder(32).append(getProperWhole()).append(' ').append(properNumerator).append('/').append(getDenominator()).toString();
            }
        } else {
            toProperString = new StringBuilder(32).append(getNumerator()).append('/').append(getDenominator()).toString();
        }
    }
    return toProperString;
}","public void test05697() throws Throwable {
    Fraction fraction0 = Fraction.ONE_FIFTH;
    Fraction fraction1 = Fraction.getReducedFraction(0, 664);
    String string0 = fraction1.toProperString();
    assertEquals(""0"", string0);
}","/**
 * <p>Gets the fraction as a proper <code>String</code> in the format X Y/Z.</p>
 *
 * <p>The format used in '<i>wholeNumber</i> <i>numerator</i>/<i>denominator</i>'.
 * If the whole number is zero it will be ommitted. If the numerator is zero,
 * only the whole number is returned.</p>
 *
 * @return a <code>String</code> form of the fraction
 */"
"public static Fraction getFraction(int whole, int numerator, int denominator) {
    if (denominator == 0) {
        throw new ArithmeticException(""The denominator must not be zero"");
    }
    if (denominator < 0) {
        throw new ArithmeticException(""The denominator must not be negative"");
    }
    if (numerator < 0) {
        throw new ArithmeticException(""The numerator must not be negative"");
    }
    long numeratorValue;
    if (whole < 0) {
        numeratorValue = whole * (long) denominator - numerator;
    } else {
        numeratorValue = whole * (long) denominator + numerator;
    }
    if (numeratorValue < Integer.MIN_VALUE || numeratorValue > Integer.MAX_VALUE) {
        throw new ArithmeticException(""Numerator too large to represent as an Integer."");
    }
    return new Fraction((int) numeratorValue, denominator);
}","public void test05798() throws Throwable {
    Fraction fraction0 = Fraction.getFraction((-1.0));
    Fraction fraction1 = Fraction.getFraction(2, 2);
    Fraction fraction2 = fraction1.invert();
    Fraction fraction3 = fraction2.ONE.negate();
    Fraction fraction4 = Fraction.FOUR_FIFTHS;
    Fraction fraction5 = fraction2.ONE.multiplyBy(fraction0);
    Fraction fraction6 = fraction3.ONE_FIFTH.divideBy(fraction2);
    Fraction.getReducedFraction(2, 2);
    fraction3.TWO_THIRDS.toString();
    fraction3.TWO_THIRDS.subtract(fraction1);
    fraction1.equals(fraction2);
    fraction1.multiplyBy(fraction0);
    Fraction fraction7 = Fraction.getFraction(2, 2);
    Fraction fraction8 = Fraction.getFraction(""2/3"");
    fraction8.ONE_HALF.abs();
    fraction1.toProperString();
    Fraction fraction9 = Fraction.ONE;
    fraction7.ONE_HALF.abs();
    fraction0.subtract(fraction1);
    Fraction fraction10 = fraction3.add(fraction7);
    fraction5.getDenominator();
    fraction10.toString();
    fraction6.getDenominator();
    // Undeclared exception!
    try {
        Fraction.getFraction((-2544), (-2544), 2153);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // The numerator must not be negative
        //
        verifyException(""org.apache.commons.lang3.math.Fraction"", e);
    }
}","/**
 * <p>Creates a <code>Fraction</code> instance with the 3 parts
 * of a fraction X Y/Z.</p>
 *
 * <p>The negative sign must be passed in on the whole number part.</p>
 *
 * @param whole  the whole number, for example the one in 'one and three sevenths'
 * @param numerator  the numerator, for example the three in 'one and three sevenths'
 * @param denominator  the denominator, for example the seven in 'one and three sevenths'
 * @return a new fraction instance
 * @throws ArithmeticException if the denominator is <code>zero</code>
 * @throws ArithmeticException if the denominator is negative
 * @throws ArithmeticException if the numerator is negative
 * @throws ArithmeticException if the resulting numerator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"public int compareTo(Fraction other) {
    if (this == other) {
        return 0;
    }
    if (numerator == other.numerator && denominator == other.denominator) {
        return 0;
    }
    // otherwise see which is less
    long first = (long) numerator * (long) other.denominator;
    long second = (long) other.numerator * (long) denominator;
    if (first == second) {
        return 0;
    } else if (first < second) {
        return -1;
    } else {
        return 1;
    }
}","public void test05899() throws Throwable {
    Fraction fraction0 = Fraction.TWO_QUARTERS;
    Fraction fraction1 = Fraction.ONE_HALF;
    int int0 = fraction0.compareTo(fraction1);
    assertEquals(0, int0);
}","/**
 * <p>Compares this object to another based on size.</p>
 *
 * <p>Note: this class has a natural ordering that is inconsistent
 * with equals, because, for example, equals treats 1/2 and 2/4 as
 * different, whereas compareTo treats them as equal.
 *
 * @param other  the object to compare to
 * @return -1 if this is less, 0 if equal, +1 if greater
 * @throws ClassCastException if the object is not a <code>Fraction</code>
 * @throws NullPointerException if the object is <code>null</code>
 */"
"// Basics
//-------------------------------------------------------------------
/**
 * <p>Compares this fraction to another object to test if they are equal.</p>.
 *
 * <p>To be equal, both values must be equal. Thus 2/4 is not equal to 1/2.</p>
 *
 * @param obj the reference object with which to compare
 * @return <code>true</code> if this object is equal
 */
@Override
public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (obj instanceof Fraction == false) {
        return false;
    }
    Fraction other = (Fraction) obj;
    return (getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator());
}","public void test059100() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    Fraction fraction1 = Fraction.getFraction(""1/1"");
    int int0 = fraction0.compareTo(fraction1);
    assertTrue(fraction1.equals((Object) fraction0));
}",""
"public int compareTo(Fraction other) {
    if (this == other) {
        return 0;
    }
    if (numerator == other.numerator && denominator == other.denominator) {
        return 0;
    }
    // otherwise see which is less
    long first = (long) numerator * (long) other.denominator;
    long second = (long) other.numerator * (long) denominator;
    if (first == second) {
        return 0;
    } else if (first < second) {
        return -1;
    } else {
        return 1;
    }
}","public void test059101() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    Fraction fraction1 = Fraction.getFraction(""1/1"");
    int int0 = fraction0.compareTo(fraction1);
    assertEquals(0, int0);
}","/**
 * <p>Compares this object to another based on size.</p>
 *
 * <p>Note: this class has a natural ordering that is inconsistent
 * with equals, because, for example, equals treats 1/2 and 2/4 as
 * different, whereas compareTo treats them as equal.
 *
 * @param other  the object to compare to
 * @return -1 if this is less, 0 if equal, +1 if greater
 * @throws ClassCastException if the object is not a <code>Fraction</code>
 * @throws NullPointerException if the object is <code>null</code>
 */"
"public int compareTo(Fraction other) {
    if (this == other) {
        return 0;
    }
    if (numerator == other.numerator && denominator == other.denominator) {
        return 0;
    }
    // otherwise see which is less
    long first = (long) numerator * (long) other.denominator;
    long second = (long) other.numerator * (long) denominator;
    if (first == second) {
        return 0;
    } else if (first < second) {
        return -1;
    } else {
        return 1;
    }
}","public void test060102() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    Fraction fraction1 = Fraction.ONE_QUARTER;
    int int0 = fraction0.compareTo(fraction1);
    assertEquals(1, int0);
}","/**
 * <p>Compares this object to another based on size.</p>
 *
 * <p>Note: this class has a natural ordering that is inconsistent
 * with equals, because, for example, equals treats 1/2 and 2/4 as
 * different, whereas compareTo treats them as equal.
 *
 * @param other  the object to compare to
 * @return -1 if this is less, 0 if equal, +1 if greater
 * @throws ClassCastException if the object is not a <code>Fraction</code>
 * @throws NullPointerException if the object is <code>null</code>
 */"
"public int compareTo(Fraction other) {
    if (this == other) {
        return 0;
    }
    if (numerator == other.numerator && denominator == other.denominator) {
        return 0;
    }
    // otherwise see which is less
    long first = (long) numerator * (long) other.denominator;
    long second = (long) other.numerator * (long) denominator;
    if (first == second) {
        return 0;
    } else if (first < second) {
        return -1;
    } else {
        return 1;
    }
}","public void test061103() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    int int0 = fraction0.compareTo(fraction0);
    assertEquals(0, int0);
}","/**
 * <p>Compares this object to another based on size.</p>
 *
 * <p>Note: this class has a natural ordering that is inconsistent
 * with equals, because, for example, equals treats 1/2 and 2/4 as
 * different, whereas compareTo treats them as equal.
 *
 * @param other  the object to compare to
 * @return -1 if this is less, 0 if equal, +1 if greater
 * @throws ClassCastException if the object is not a <code>Fraction</code>
 * @throws NullPointerException if the object is <code>null</code>
 */"
"public int getDenominator() {
    return denominator;
}","public void test062104() throws Throwable {
    Fraction fraction0 = Fraction.ZERO;
    fraction0.FOUR_FIFTHS.hashCode();
    assertEquals(1, fraction0.getDenominator());
}","/**
 * <p>Gets the denominator part of the fraction.</p>
 *
 * @return the denominator fraction part
 */"
"// Accessors
//-------------------------------------------------------------------
/**
 * <p>Gets the numerator part of the fraction.</p>
 *
 * <p>This method may return a value greater than the denominator, an
 * improper fraction, such as the seven in 7/4.</p>
 *
 * @return the numerator fraction part
 */
public int getNumerator() {
    return numerator;
}","public void test062105() throws Throwable {
    Fraction fraction0 = Fraction.ZERO;
    fraction0.FOUR_FIFTHS.hashCode();
    assertEquals(0, fraction0.getNumerator());
}",""
"// Accessors
//-------------------------------------------------------------------
/**
 * <p>Gets the numerator part of the fraction.</p>
 *
 * <p>This method may return a value greater than the denominator, an
 * improper fraction, such as the seven in 7/4.</p>
 *
 * @return the numerator fraction part
 */
public int getNumerator() {
    return numerator;
}","public void test063106() throws Throwable {
    Fraction fraction0 = Fraction.ONE_FIFTH;
    Fraction fraction1 = fraction0.TWO_THIRDS.reduce();
    fraction0.equals(fraction1);
    assertEquals(2, fraction1.getNumerator());
}",""
"public int getDenominator() {
    return denominator;
}","public void test063107() throws Throwable {
    Fraction fraction0 = Fraction.ONE_FIFTH;
    Fraction fraction1 = fraction0.TWO_THIRDS.reduce();
    fraction0.equals(fraction1);
    assertEquals(3, fraction1.getDenominator());
}","/**
 * <p>Gets the denominator part of the fraction.</p>
 *
 * @return the denominator fraction part
 */"
"// Basics
//-------------------------------------------------------------------
/**
 * <p>Compares this fraction to another object to test if they are equal.</p>.
 *
 * <p>To be equal, both values must be equal. Thus 2/4 is not equal to 1/2.</p>
 *
 * @param obj the reference object with which to compare
 * @return <code>true</code> if this object is equal
 */
@Override
public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (obj instanceof Fraction == false) {
        return false;
    }
    Fraction other = (Fraction) obj;
    return (getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator());
}","public void test064108() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction(0, 2506);
    Object object0 = new Object();
    boolean boolean0 = fraction0.equals(object0);
    assertFalse(boolean0);
}",""
"public int getDenominator() {
    return denominator;
}","public void test064109() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction(0, 2506);
    Object object0 = new Object();
    boolean boolean0 = fraction0.equals(object0);
    assertEquals(1, fraction0.getDenominator());
}","/**
 * <p>Gets the denominator part of the fraction.</p>
 *
 * @return the denominator fraction part
 */"
"public Fraction divideBy(Fraction fraction) {
    if (fraction == null) {
        throw new IllegalArgumentException(""The fraction must not be null"");
    }
    if (fraction.numerator == 0) {
        throw new ArithmeticException(""The fraction to divide by must not be zero"");
    }
    return multiplyBy(fraction.invert());
}","public void test065111() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction(0, 2506);
    // Undeclared exception!
    try {
        fraction0.divideBy(fraction0);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // The fraction to divide by must not be zero
        //
        verifyException(""org.apache.commons.lang3.math.Fraction"", e);
    }
}","/**
 * <p>Divide the value of this fraction by another.</p>
 *
 * @param fraction  the fraction to divide by, must not be <code>null</code>
 * @return a <code>Fraction</code> instance with the resulting values
 * @throws IllegalArgumentException if the fraction is <code>null</code>
 * @throws ArithmeticException if the fraction to divide by is zero
 * @throws ArithmeticException if the resulting numerator or denominator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"public Fraction divideBy(Fraction fraction) {
    if (fraction == null) {
        throw new IllegalArgumentException(""The fraction must not be null"");
    }
    if (fraction.numerator == 0) {
        throw new ArithmeticException(""The fraction to divide by must not be zero"");
    }
    return multiplyBy(fraction.invert());
}","public void test066112() throws Throwable {
    Fraction fraction0 = Fraction.TWO_THIRDS;
    // Undeclared exception!
    try {
        fraction0.THREE_FIFTHS.divideBy((Fraction) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The fraction must not be null
        //
        verifyException(""org.apache.commons.lang3.math.Fraction"", e);
    }
}","/**
 * <p>Divide the value of this fraction by another.</p>
 *
 * @param fraction  the fraction to divide by, must not be <code>null</code>
 * @return a <code>Fraction</code> instance with the resulting values
 * @throws IllegalArgumentException if the fraction is <code>null</code>
 * @throws ArithmeticException if the fraction to divide by is zero
 * @throws ArithmeticException if the resulting numerator or denominator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test067113() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction((-77), 4);
    Fraction fraction1 = fraction0.ZERO.divideBy(fraction0);
    assertEquals(0.0, fraction1.doubleValue(), 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"@Override
public float floatValue() {
    return ((float) numerator) / ((float) denominator);
}","public void test067114() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction((-77), 4);
    Fraction fraction1 = fraction0.ZERO.divideBy(fraction0);
    assertEquals((-19.25F), fraction0.floatValue(), 0.01F);
}","/**
 * <p>Gets the fraction as a <code>float</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>float</code>
 */"
"public int getDenominator() {
    return denominator;
}","public void test067115() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction((-77), 4);
    Fraction fraction1 = fraction0.ZERO.divideBy(fraction0);
    assertEquals(4, fraction0.getDenominator());
}","/**
 * <p>Gets the denominator part of the fraction.</p>
 *
 * @return the denominator fraction part
 */"
"public Fraction multiplyBy(Fraction fraction) {
    if (fraction == null) {
        throw new IllegalArgumentException(""The fraction must not be null"");
    }
    if (numerator == 0 || fraction.numerator == 0) {
        return ZERO;
    }
    // knuth 4.5.1
    // make sure we don't overflow unless the result *must* overflow.
    int d1 = greatestCommonDivisor(numerator, fraction.denominator);
    int d2 = greatestCommonDivisor(fraction.numerator, denominator);
    return getReducedFraction(mulAndCheck(numerator / d1, fraction.numerator / d2), mulPosAndCheck(denominator / d2, fraction.denominator / d1));
}","public void test068116() throws Throwable {
    Fraction fraction0 = Fraction.ONE_FIFTH;
    // Undeclared exception!
    try {
        fraction0.multiplyBy((Fraction) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The fraction must not be null
        //
        verifyException(""org.apache.commons.lang3.math.Fraction"", e);
    }
}","/**
 * <p>Multiplies the value of this fraction by another, returning the
 * result in reduced form.</p>
 *
 * @param fraction  the fraction to multiply by, must not be <code>null</code>
 * @return a <code>Fraction</code> instance with the resulting values
 * @throws IllegalArgumentException if the fraction is <code>null</code>
 * @throws ArithmeticException if the resulting numerator or denominator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"public int getDenominator() {
    return denominator;
}","public void test069117() throws Throwable {
    Fraction fraction0 = Fraction.getFraction((-3579.9143379));
    Fraction fraction1 = Fraction.getFraction((-1727.3956));
    Fraction fraction2 = fraction0.ONE_HALF.subtract(fraction1);
    assertEquals(5475, fraction0.getDenominator());
}","/**
 * <p>Gets the denominator part of the fraction.</p>
 *
 * @return the denominator fraction part
 */"
"// Accessors
//-------------------------------------------------------------------
/**
 * <p>Gets the numerator part of the fraction.</p>
 *
 * <p>This method may return a value greater than the denominator, an
 * improper fraction, such as the seven in 7/4.</p>
 *
 * @return the numerator fraction part
 */
public int getNumerator() {
    return numerator;
}","public void test069118() throws Throwable {
    Fraction fraction0 = Fraction.getFraction((-3579.9143379));
    Fraction fraction1 = Fraction.getFraction((-1727.3956));
    Fraction fraction2 = fraction0.ONE_HALF.subtract(fraction1);
    assertEquals(4319739, fraction2.getNumerator());
}",""
"public Fraction subtract(Fraction fraction) {
    return addSub(fraction, false);
}","public void test070120() throws Throwable {
    Fraction fraction0 = Fraction.TWO_QUARTERS;
    Fraction fraction1 = Fraction.ZERO;
    Fraction fraction2 = fraction0.subtract(fraction1);
    assertSame(fraction2, fraction0);
}","/**
 * <p>Subtracts the value of another fraction from the value of this one,
 * returning the result in reduced form.</p>
 *
 * @param fraction  the fraction to subtract, must not be <code>null</code>
 * @return a <code>Fraction</code> instance with the resulting values
 * @throws IllegalArgumentException if the fraction is <code>null</code>
 * @throws ArithmeticException if the resulting numerator or denominator
 *   cannot be represented in an <code>int</code>.
 */"
"@Override
public float floatValue() {
    return ((float) numerator) / ((float) denominator);
}","public void test071121() throws Throwable {
    Fraction fraction0 = Fraction.THREE_QUARTERS;
    Fraction fraction1 = fraction0.ZERO.subtract(fraction0);
    assertEquals((-0.75F), fraction1.floatValue(), 0.01F);
}","/**
 * <p>Gets the fraction as a <code>float</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>float</code>
 */"
"// Accessors
//-------------------------------------------------------------------
/**
 * <p>Gets the numerator part of the fraction.</p>
 *
 * <p>This method may return a value greater than the denominator, an
 * improper fraction, such as the seven in 7/4.</p>
 *
 * @return the numerator fraction part
 */
public int getNumerator() {
    return numerator;
}","public void test072122() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction((-77), 4);
    Fraction fraction1 = fraction0.ZERO.add(fraction0);
    assertEquals((-77), fraction1.getNumerator());
}",""
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test072123() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction((-77), 4);
    Fraction fraction1 = fraction0.ZERO.add(fraction0);
    assertEquals((-19.25), fraction1.doubleValue(), 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"public Fraction add(Fraction fraction) {
    return addSub(fraction, true);
}","public void test073124() throws Throwable {
    Fraction fraction0 = Fraction.ONE_THIRD;
    // Undeclared exception!
    try {
        fraction0.add((Fraction) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The fraction must not be null
        //
        verifyException(""org.apache.commons.lang3.math.Fraction"", e);
    }
}","/**
 * <p>Adds the value of this fraction to another, returning the result in reduced form.
 * The algorithm follows Knuth, 4.5.1.</p>
 *
 * @param fraction  the fraction to add, must not be <code>null</code>
 * @return a <code>Fraction</code> instance with the resulting values
 * @throws IllegalArgumentException if the fraction is <code>null</code>
 * @throws ArithmeticException if the resulting numerator or denominator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"public Fraction pow(int power) {
    if (power == 1) {
        return this;
    } else if (power == 0) {
        return ONE;
    } else if (power < 0) {
        if (power == Integer.MIN_VALUE) {
            // MIN_VALUE can't be negated.
            return this.invert().pow(2).pow(-(power / 2));
        }
        return this.invert().pow(-power);
    } else {
        Fraction f = this.multiplyBy(this);
        if ((power % 2) == 0) {
            // if even...
            return f.pow(power / 2);
        } else {
            // if odd...
            return f.pow(power / 2).multiplyBy(this);
        }
    }
}","public void test074125() throws Throwable {
    Fraction fraction0 = Fraction.ONE_QUARTER;
    // Undeclared exception!
    try {
        fraction0.THREE_FIFTHS.pow(103);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: mulPos
        //
        verifyException(""org.apache.commons.lang3.math.Fraction"", e);
    }
}","/**
 * <p>Gets a fraction that is raised to the passed in power.</p>
 *
 * <p>The returned fraction is in reduced form.</p>
 *
 * @param power  the power to raise the fraction to
 * @return <code>this</code> if the power is one, <code>ONE</code> if the power
 * is zero (even if the fraction equals ZERO) or a new fraction instance
 * raised to the appropriate power
 * @throws ArithmeticException if the resulting numerator or denominator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"public Fraction divideBy(Fraction fraction) {
    if (fraction == null) {
        throw new IllegalArgumentException(""The fraction must not be null"");
    }
    if (fraction.numerator == 0) {
        throw new ArithmeticException(""The fraction to divide by must not be zero"");
    }
    return multiplyBy(fraction.invert());
}","public void test075126() throws Throwable {
    Fraction fraction0 = Fraction.THREE_FIFTHS;
    Fraction fraction1 = Fraction.getReducedFraction(586, Integer.MIN_VALUE);
    // Undeclared exception!
    try {
        fraction0.divideBy(fraction1);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: mul
        //
        verifyException(""org.apache.commons.lang3.math.Fraction"", e);
    }
}","/**
 * <p>Divide the value of this fraction by another.</p>
 *
 * @param fraction  the fraction to divide by, must not be <code>null</code>
 * @return a <code>Fraction</code> instance with the resulting values
 * @throws IllegalArgumentException if the fraction is <code>null</code>
 * @throws ArithmeticException if the fraction to divide by is zero
 * @throws ArithmeticException if the resulting numerator or denominator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"public Fraction pow(int power) {
    if (power == 1) {
        return this;
    } else if (power == 0) {
        return ONE;
    } else if (power < 0) {
        if (power == Integer.MIN_VALUE) {
            // MIN_VALUE can't be negated.
            return this.invert().pow(2).pow(-(power / 2));
        }
        return this.invert().pow(-power);
    } else {
        Fraction f = this.multiplyBy(this);
        if ((power % 2) == 0) {
            // if even...
            return f.pow(power / 2);
        } else {
            // if odd...
            return f.pow(power / 2).multiplyBy(this);
        }
    }
}","public void test076127() throws Throwable {
    Fraction fraction0 = Fraction.getFraction((-3579.91434));
    // Undeclared exception!
    try {
        fraction0.THREE_FIFTHS.pow(Integer.MIN_VALUE);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: mul
        //
        verifyException(""org.apache.commons.lang3.math.Fraction"", e);
    }
}","/**
 * <p>Gets a fraction that is raised to the passed in power.</p>
 *
 * <p>The returned fraction is in reduced form.</p>
 *
 * @param power  the power to raise the fraction to
 * @return <code>this</code> if the power is one, <code>ONE</code> if the power
 * is zero (even if the fraction equals ZERO) or a new fraction instance
 * raised to the appropriate power
 * @throws ArithmeticException if the resulting numerator or denominator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"@Override
public long longValue() {
    return (long) numerator / denominator;
}","public void test077128() throws Throwable {
    Fraction fraction0 = Fraction.ONE;
    Fraction fraction1 = fraction0.pow((-13));
    assertEquals(1L, fraction1.longValue());
}","/**
 * <p>Gets the fraction as a <code>long</code>. This returns the whole number
 * part of the fraction.</p>
 *
 * @return the whole number fraction part
 */"
"@Override
public float floatValue() {
    return ((float) numerator) / ((float) denominator);
}","public void test078129() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction((-77), 4);
    Fraction fraction1 = fraction0.abs();
    assertEquals((-19.25F), fraction0.floatValue(), 0.01F);
}","/**
 * <p>Gets the fraction as a <code>float</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>float</code>
 */"
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test078130() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction((-77), 4);
    Fraction fraction1 = fraction0.abs();
    assertEquals(19.25, fraction1.doubleValue(), 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"public Fraction invert() {
    if (numerator == 0) {
        throw new ArithmeticException(""Unable to invert zero."");
    }
    if (numerator == Integer.MIN_VALUE) {
        throw new ArithmeticException(""overflow: can't negate numerator"");
    }
    if (numerator < 0) {
        return new Fraction(-denominator, -numerator);
    } else {
        return new Fraction(denominator, numerator);
    }
}","public void test079131() throws Throwable {
    Fraction fraction0 = Fraction.ZERO;
    // Undeclared exception!
    try {
        fraction0.invert();
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Unable to invert zero.
        //
        verifyException(""org.apache.commons.lang3.math.Fraction"", e);
    }
}","/**
 * <p>Gets a fraction that is the inverse (1/fraction) of this one.</p>
 *
 * <p>The returned fraction is not reduced.</p>
 *
 * @return a new fraction instance with the numerator and denominator
 *         inverted.
 * @throws ArithmeticException if the fraction represents zero.
 */"
"// Basics
//-------------------------------------------------------------------
/**
 * <p>Compares this fraction to another object to test if they are equal.</p>.
 *
 * <p>To be equal, both values must be equal. Thus 2/4 is not equal to 1/2.</p>
 *
 * @param obj the reference object with which to compare
 * @return <code>true</code> if this object is equal
 */
@Override
public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (obj instanceof Fraction == false) {
        return false;
    }
    Fraction other = (Fraction) obj;
    return (getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator());
}","public void test080132() throws Throwable {
    Fraction fraction0 = Fraction.getFraction((-1.0));
    Fraction fraction1 = fraction0.invert();
    boolean boolean0 = fraction0.equals(fraction1);
    assertTrue(boolean0);
}",""
"public int getDenominator() {
    return denominator;
}","public void test080133() throws Throwable {
    Fraction fraction0 = Fraction.getFraction((-1.0));
    Fraction fraction1 = fraction0.invert();
    boolean boolean0 = fraction0.equals(fraction1);
    assertEquals(1, fraction1.getDenominator());
}","/**
 * <p>Gets the denominator part of the fraction.</p>
 *
 * @return the denominator fraction part
 */"
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test080134() throws Throwable {
    Fraction fraction0 = Fraction.getFraction((-1.0));
    Fraction fraction1 = fraction0.invert();
    boolean boolean0 = fraction0.equals(fraction1);
    assertEquals((-1.0), fraction0.doubleValue(), 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"public int getDenominator() {
    return denominator;
}","public void test081135() throws Throwable {
    Fraction fraction0 = Fraction.TWO_THIRDS;
    Fraction fraction1 = Fraction.getFraction((-1), 0, 3);
    Fraction fraction2 = fraction0.pow(0);
    Fraction fraction3 = fraction2.add(fraction1);
    Fraction fraction4 = fraction3.reduce();
    assertEquals(3, fraction3.getDenominator());
}","/**
 * <p>Gets the denominator part of the fraction.</p>
 *
 * @return the denominator fraction part
 */"
"// Basics
//-------------------------------------------------------------------
/**
 * <p>Compares this fraction to another object to test if they are equal.</p>.
 *
 * <p>To be equal, both values must be equal. Thus 2/4 is not equal to 1/2.</p>
 *
 * @param obj the reference object with which to compare
 * @return <code>true</code> if this object is equal
 */
@Override
public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (obj instanceof Fraction == false) {
        return false;
    }
    Fraction other = (Fraction) obj;
    return (getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator());
}","public void test081136() throws Throwable {
    Fraction fraction0 = Fraction.TWO_THIRDS;
    Fraction fraction1 = Fraction.getFraction((-1), 0, 3);
    Fraction fraction2 = fraction0.pow(0);
    Fraction fraction3 = fraction2.add(fraction1);
    Fraction fraction4 = fraction3.reduce();
    assertFalse(fraction4.equals((Object) fraction2));
}",""
"public int getDenominator() {
    return denominator;
}","public void test081137() throws Throwable {
    Fraction fraction0 = Fraction.TWO_THIRDS;
    Fraction fraction1 = Fraction.getFraction((-1), 0, 3);
    Fraction fraction2 = fraction0.pow(0);
    Fraction fraction3 = fraction2.add(fraction1);
    Fraction fraction4 = fraction3.reduce();
    assertEquals(1, fraction4.getDenominator());
}","/**
 * <p>Gets the denominator part of the fraction.</p>
 *
 * @return the denominator fraction part
 */"
"@Override
public float floatValue() {
    return ((float) numerator) / ((float) denominator);
}","public void test081138() throws Throwable {
    Fraction fraction0 = Fraction.TWO_THIRDS;
    Fraction fraction1 = Fraction.getFraction((-1), 0, 3);
    Fraction fraction2 = fraction0.pow(0);
    Fraction fraction3 = fraction2.add(fraction1);
    Fraction fraction4 = fraction3.reduce();
    assertEquals(0.0F, fraction4.floatValue(), 0.01F);
}","/**
 * <p>Gets the fraction as a <code>float</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>float</code>
 */"
"// Basics
//-------------------------------------------------------------------
/**
 * <p>Compares this fraction to another object to test if they are equal.</p>.
 *
 * <p>To be equal, both values must be equal. Thus 2/4 is not equal to 1/2.</p>
 *
 * @param obj the reference object with which to compare
 * @return <code>true</code> if this object is equal
 */
@Override
public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (obj instanceof Fraction == false) {
        return false;
    }
    Fraction other = (Fraction) obj;
    return (getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator());
}","public void test081139() throws Throwable {
    Fraction fraction0 = Fraction.TWO_THIRDS;
    Fraction fraction1 = Fraction.getFraction((-1), 0, 3);
    Fraction fraction2 = fraction0.pow(0);
    Fraction fraction3 = fraction2.add(fraction1);
    Fraction fraction4 = fraction3.reduce();
    assertFalse(fraction0.equals((Object) fraction1));
}",""
"// Basics
//-------------------------------------------------------------------
/**
 * <p>Compares this fraction to another object to test if they are equal.</p>.
 *
 * <p>To be equal, both values must be equal. Thus 2/4 is not equal to 1/2.</p>
 *
 * @param obj the reference object with which to compare
 * @return <code>true</code> if this object is equal
 */
@Override
public boolean equals(Object obj) {
    if (obj == this) {
        return true;
    }
    if (obj instanceof Fraction == false) {
        return false;
    }
    Fraction other = (Fraction) obj;
    return (getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator());
}","public void test081140() throws Throwable {
    Fraction fraction0 = Fraction.TWO_THIRDS;
    Fraction fraction1 = Fraction.getFraction((-1), 0, 3);
    Fraction fraction2 = fraction0.pow(0);
    Fraction fraction3 = fraction2.add(fraction1);
    Fraction fraction4 = fraction3.reduce();
    assertFalse(fraction4.equals((Object) fraction3));
}",""
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test083142() throws Throwable {
    Fraction fraction0 = Fraction.getFraction(""1 2/13"");
    assertEquals(1.1538461538461537, fraction0.doubleValue(), 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"public static Fraction getFraction(String str) {
    if (str == null) {
        throw new IllegalArgumentException(""The string must not be null"");
    }
    // parse double format
    int pos = str.indexOf('.');
    if (pos >= 0) {
        return getFraction(Double.parseDouble(str));
    }
    // parse X Y/Z format
    pos = str.indexOf(' ');
    if (pos > 0) {
        int whole = Integer.parseInt(str.substring(0, pos));
        str = str.substring(pos + 1);
        pos = str.indexOf('/');
        if (pos < 0) {
            throw new NumberFormatException(""The fraction could not be parsed as the format X Y/Z"");
        } else {
            int numer = Integer.parseInt(str.substring(0, pos));
            int denom = Integer.parseInt(str.substring(pos + 1));
            return getFraction(whole, numer, denom);
        }
    }
    // parse Y/Z format
    pos = str.indexOf('/');
    if (pos < 0) {
        // simple whole number
        return getFraction(Integer.parseInt(str), 1);
    } else {
        int numer = Integer.parseInt(str.substring(0, pos));
        int denom = Integer.parseInt(str.substring(pos + 1));
        return getFraction(numer, denom);
    }
}","public void test084143() throws Throwable {
    // Undeclared exception!
    try {
        Fraction.getFraction("">NLE6w."");
        fail(""Expecting exception: NumberFormatException"");
    } catch (NumberFormatException e) {
    }
}","/**
 * <p>Creates a Fraction from a <code>String</code>.</p>
 *
 * <p>The formats accepted are:</p>
 *
 * <ol>
 *  <li><code>double</code> String containing a dot</li>
 *  <li>'X Y/Z'</li>
 *  <li>'Y/Z'</li>
 *  <li>'X' (a simple whole number)</li>
 * </ol>
 * and a .</p>
 *
 * @param str  the string to parse, must not be <code>null</code>
 * @return the new <code>Fraction</code> instance
 * @throws IllegalArgumentException if the string is <code>null</code>
 * @throws NumberFormatException if the number format is invalid
 */"
"public static Fraction getFraction(String str) {
    if (str == null) {
        throw new IllegalArgumentException(""The string must not be null"");
    }
    // parse double format
    int pos = str.indexOf('.');
    if (pos >= 0) {
        return getFraction(Double.parseDouble(str));
    }
    // parse X Y/Z format
    pos = str.indexOf(' ');
    if (pos > 0) {
        int whole = Integer.parseInt(str.substring(0, pos));
        str = str.substring(pos + 1);
        pos = str.indexOf('/');
        if (pos < 0) {
            throw new NumberFormatException(""The fraction could not be parsed as the format X Y/Z"");
        } else {
            int numer = Integer.parseInt(str.substring(0, pos));
            int denom = Integer.parseInt(str.substring(pos + 1));
            return getFraction(whole, numer, denom);
        }
    }
    // parse Y/Z format
    pos = str.indexOf('/');
    if (pos < 0) {
        // simple whole number
        return getFraction(Integer.parseInt(str), 1);
    } else {
        int numer = Integer.parseInt(str.substring(0, pos));
        int denom = Integer.parseInt(str.substring(pos + 1));
        return getFraction(numer, denom);
    }
}","public void test085144() throws Throwable {
    // Undeclared exception!
    try {
        Fraction.getFraction((String) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The string must not be null
        //
        verifyException(""org.apache.commons.lang3.math.Fraction"", e);
    }
}","/**
 * <p>Creates a Fraction from a <code>String</code>.</p>
 *
 * <p>The formats accepted are:</p>
 *
 * <ol>
 *  <li><code>double</code> String containing a dot</li>
 *  <li>'X Y/Z'</li>
 *  <li>'Y/Z'</li>
 *  <li>'X' (a simple whole number)</li>
 * </ol>
 * and a .</p>
 *
 * @param str  the string to parse, must not be <code>null</code>
 * @return the new <code>Fraction</code> instance
 * @throws IllegalArgumentException if the string is <code>null</code>
 * @throws NumberFormatException if the number format is invalid
 */"
"public static Fraction getFraction(double value) {
    int sign = (value < 0 ? -1 : 1);
    value = Math.abs(value);
    if (value > Integer.MAX_VALUE || Double.isNaN(value)) {
        throw new ArithmeticException(""The value must not be greater than Integer.MAX_VALUE or NaN"");
    }
    int wholeNumber = (int) value;
    value -= wholeNumber;
    // the pre-previous
    int numer0 = 0;
    // the pre-previous
    int denom0 = 1;
    // the previous
    int numer1 = 1;
    // the previous
    int denom1 = 0;
    // the current, setup in calculation
    int numer2 = 0;
    // the current, setup in calculation
    int denom2 = 0;
    int a1 = (int) value;
    int a2 = 0;
    double x1 = 1;
    double x2 = 0;
    double y1 = value - a1;
    double y2 = 0;
    double delta1, delta2 = Double.MAX_VALUE;
    double fraction;
    int i = 1;
    //        System.out.println(""---"");
    do {
        delta1 = delta2;
        a2 = (int) (x1 / y1);
        x2 = y1;
        y2 = x1 - a2 * y1;
        numer2 = a1 * numer1 + numer0;
        denom2 = a1 * denom1 + denom0;
        fraction = (double) numer2 / (double) denom2;
        delta2 = Math.abs(value - fraction);
        //            System.out.println(numer2 + "" "" + denom2 + "" "" + fraction + "" "" + delta2 + "" "" + y1);
        a1 = a2;
        x1 = x2;
        y1 = y2;
        numer0 = numer1;
        denom0 = denom1;
        numer1 = numer2;
        denom1 = denom2;
        i++;
        //            System.out.println("">>"" + delta1 +"" ""+ delta2+"" ""+(delta1 > delta2)+"" ""+i+"" ""+denom2);
    } while ((delta1 > delta2) && (denom2 <= 10000) && (denom2 > 0) && (i < 25));
    if (i == 25) {
        throw new ArithmeticException(""Unable to convert double to fraction"");
    }
    return getReducedFraction((numer0 + wholeNumber * denom0) * sign, denom0);
}","public void test086145() throws Throwable {
    // Undeclared exception!
    try {
        Fraction.getFraction(1.7976931348623157E308);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // The value must not be greater than Integer.MAX_VALUE or NaN
        //
        verifyException(""org.apache.commons.lang3.math.Fraction"", e);
    }
}","/**
 * <p>Creates a <code>Fraction</code> instance from a <code>double</code> value.</p>
 *
 * <p>This method uses the <a href=""http://archives.math.utk.edu/articles/atuyl/confrac/"">
 *  continued fraction algorithm</a>, computing a maximum of
 *  25 convergents and bounding the denominator by 10,000.</p>
 *
 * @param value  the double value to convert
 * @return a new fraction instance that is close to the value
 * @throws ArithmeticException if <code>|value| > Integer.MAX_VALUE</code>
 *  or <code>value = NaN</code>
 * @throws ArithmeticException if the calculated denominator is <code>zero</code>
 * @throws ArithmeticException if the the algorithm does not converge
 */"
"public static Fraction getReducedFraction(int numerator, int denominator) {
    if (denominator == 0) {
        throw new ArithmeticException(""The denominator must not be zero"");
    }
    if (numerator == 0) {
        // normalize zero.
        return ZERO;
    }
    // allow 2^k/-2^31 as a valid fraction (where k>0)
    if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {
        numerator /= 2;
        denominator /= 2;
    }
    if (denominator < 0) {
        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {
            throw new ArithmeticException(""overflow: can't negate"");
        }
        numerator = -numerator;
        denominator = -denominator;
    }
    // simplify fraction.
    int gcd = greatestCommonDivisor(numerator, denominator);
    numerator /= gcd;
    denominator /= gcd;
    return new Fraction(numerator, denominator);
}","public void test087146() throws Throwable {
    // Undeclared exception!
    try {
        Fraction.getReducedFraction(Integer.MIN_VALUE, (-1698));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: can't negate
        //
        verifyException(""org.apache.commons.lang3.math.Fraction"", e);
    }
}","/**
 * <p>Creates a reduced <code>Fraction</code> instance with the 2 parts
 * of a fraction Y/Z.</p>
 *
 * <p>For example, if the input parameters represent 2/4, then the created
 * fraction will be 1/2.</p>
 *
 * <p>Any negative signs are resolved to be on the numerator.</p>
 *
 * @param numerator  the numerator, for example the three in 'three sevenths'
 * @param denominator  the denominator, for example the seven in 'three sevenths'
 * @return a new fraction instance, with the numerator and denominator reduced
 * @throws ArithmeticException if the denominator is <code>zero</code>
 */"
"public static Fraction getReducedFraction(int numerator, int denominator) {
    if (denominator == 0) {
        throw new ArithmeticException(""The denominator must not be zero"");
    }
    if (numerator == 0) {
        // normalize zero.
        return ZERO;
    }
    // allow 2^k/-2^31 as a valid fraction (where k>0)
    if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {
        numerator /= 2;
        denominator /= 2;
    }
    if (denominator < 0) {
        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {
            throw new ArithmeticException(""overflow: can't negate"");
        }
        numerator = -numerator;
        denominator = -denominator;
    }
    // simplify fraction.
    int gcd = greatestCommonDivisor(numerator, denominator);
    numerator /= gcd;
    denominator /= gcd;
    return new Fraction(numerator, denominator);
}","public void test088147() throws Throwable {
    // Undeclared exception!
    try {
        Fraction.getReducedFraction((-3399), Integer.MIN_VALUE);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: can't negate
        //
        verifyException(""org.apache.commons.lang3.math.Fraction"", e);
    }
}","/**
 * <p>Creates a reduced <code>Fraction</code> instance with the 2 parts
 * of a fraction Y/Z.</p>
 *
 * <p>For example, if the input parameters represent 2/4, then the created
 * fraction will be 1/2.</p>
 *
 * <p>Any negative signs are resolved to be on the numerator.</p>
 *
 * @param numerator  the numerator, for example the three in 'three sevenths'
 * @param denominator  the denominator, for example the seven in 'three sevenths'
 * @return a new fraction instance, with the numerator and denominator reduced
 * @throws ArithmeticException if the denominator is <code>zero</code>
 */"
"public Fraction multiplyBy(Fraction fraction) {
    if (fraction == null) {
        throw new IllegalArgumentException(""The fraction must not be null"");
    }
    if (numerator == 0 || fraction.numerator == 0) {
        return ZERO;
    }
    // knuth 4.5.1
    // make sure we don't overflow unless the result *must* overflow.
    int d1 = greatestCommonDivisor(numerator, fraction.denominator);
    int d2 = greatestCommonDivisor(fraction.numerator, denominator);
    return getReducedFraction(mulAndCheck(numerator / d1, fraction.numerator / d2), mulPosAndCheck(denominator / d2, fraction.denominator / d1));
}","public void test089148() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction(0, 2506);
    Fraction fraction1 = fraction0.ONE_THIRD.invert();
    Fraction fraction2 = fraction1.multiplyBy(fraction0);
    assertSame(fraction2, fraction0);
}","/**
 * <p>Multiplies the value of this fraction by another, returning the
 * result in reduced form.</p>
 *
 * @param fraction  the fraction to multiply by, must not be <code>null</code>
 * @return a <code>Fraction</code> instance with the resulting values
 * @throws IllegalArgumentException if the fraction is <code>null</code>
 * @throws ArithmeticException if the resulting numerator or denominator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"public int getDenominator() {
    return denominator;
}","public void test089149() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction(0, 2506);
    Fraction fraction1 = fraction0.ONE_THIRD.invert();
    Fraction fraction2 = fraction1.multiplyBy(fraction0);
    assertEquals(1, fraction1.getDenominator());
}","/**
 * <p>Gets the denominator part of the fraction.</p>
 *
 * @return the denominator fraction part
 */"
"@Override
public float floatValue() {
    return ((float) numerator) / ((float) denominator);
}","public void test089150() throws Throwable {
    Fraction fraction0 = Fraction.getReducedFraction(0, 2506);
    Fraction fraction1 = fraction0.ONE_THIRD.invert();
    Fraction fraction2 = fraction1.multiplyBy(fraction0);
    assertEquals(3.0F, fraction1.floatValue(), 0.01F);
}","/**
 * <p>Gets the fraction as a <code>float</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>float</code>
 */"
"public static Fraction getReducedFraction(int numerator, int denominator) {
    if (denominator == 0) {
        throw new ArithmeticException(""The denominator must not be zero"");
    }
    if (numerator == 0) {
        // normalize zero.
        return ZERO;
    }
    // allow 2^k/-2^31 as a valid fraction (where k>0)
    if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {
        numerator /= 2;
        denominator /= 2;
    }
    if (denominator < 0) {
        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {
            throw new ArithmeticException(""overflow: can't negate"");
        }
        numerator = -numerator;
        denominator = -denominator;
    }
    // simplify fraction.
    int gcd = greatestCommonDivisor(numerator, denominator);
    numerator /= gcd;
    denominator /= gcd;
    return new Fraction(numerator, denominator);
}","public void test090151() throws Throwable {
    // Undeclared exception!
    try {
        Fraction.getReducedFraction(0, 0);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // The denominator must not be zero
        //
        verifyException(""org.apache.commons.lang3.math.Fraction"", e);
    }
}","/**
 * <p>Creates a reduced <code>Fraction</code> instance with the 2 parts
 * of a fraction Y/Z.</p>
 *
 * <p>For example, if the input parameters represent 2/4, then the created
 * fraction will be 1/2.</p>
 *
 * <p>Any negative signs are resolved to be on the numerator.</p>
 *
 * @param numerator  the numerator, for example the three in 'three sevenths'
 * @param denominator  the denominator, for example the seven in 'three sevenths'
 * @return a new fraction instance, with the numerator and denominator reduced
 * @throws ArithmeticException if the denominator is <code>zero</code>
 */"
"public static Fraction getFraction(int whole, int numerator, int denominator) {
    if (denominator == 0) {
        throw new ArithmeticException(""The denominator must not be zero"");
    }
    if (denominator < 0) {
        throw new ArithmeticException(""The denominator must not be negative"");
    }
    if (numerator < 0) {
        throw new ArithmeticException(""The numerator must not be negative"");
    }
    long numeratorValue;
    if (whole < 0) {
        numeratorValue = whole * (long) denominator - numerator;
    } else {
        numeratorValue = whole * (long) denominator + numerator;
    }
    if (numeratorValue < Integer.MIN_VALUE || numeratorValue > Integer.MAX_VALUE) {
        throw new ArithmeticException(""Numerator too large to represent as an Integer."");
    }
    return new Fraction((int) numeratorValue, denominator);
}","public void test091152() throws Throwable {
    // Undeclared exception!
    try {
        Fraction.getFraction(Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Numerator too large to represent as an Integer.
        //
        verifyException(""org.apache.commons.lang3.math.Fraction"", e);
    }
}","/**
 * <p>Creates a <code>Fraction</code> instance with the 3 parts
 * of a fraction X Y/Z.</p>
 *
 * <p>The negative sign must be passed in on the whole number part.</p>
 *
 * @param whole  the whole number, for example the one in 'one and three sevenths'
 * @param numerator  the numerator, for example the three in 'one and three sevenths'
 * @param denominator  the denominator, for example the seven in 'one and three sevenths'
 * @return a new fraction instance
 * @throws ArithmeticException if the denominator is <code>zero</code>
 * @throws ArithmeticException if the denominator is negative
 * @throws ArithmeticException if the numerator is negative
 * @throws ArithmeticException if the resulting numerator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"public static Fraction getFraction(int whole, int numerator, int denominator) {
    if (denominator == 0) {
        throw new ArithmeticException(""The denominator must not be zero"");
    }
    if (denominator < 0) {
        throw new ArithmeticException(""The denominator must not be negative"");
    }
    if (numerator < 0) {
        throw new ArithmeticException(""The numerator must not be negative"");
    }
    long numeratorValue;
    if (whole < 0) {
        numeratorValue = whole * (long) denominator - numerator;
    } else {
        numeratorValue = whole * (long) denominator + numerator;
    }
    if (numeratorValue < Integer.MIN_VALUE || numeratorValue > Integer.MAX_VALUE) {
        throw new ArithmeticException(""Numerator too large to represent as an Integer."");
    }
    return new Fraction((int) numeratorValue, denominator);
}","public void test092153() throws Throwable {
    // Undeclared exception!
    try {
        Fraction.getFraction(Integer.MIN_VALUE, 47, 47);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // Numerator too large to represent as an Integer.
        //
        verifyException(""org.apache.commons.lang3.math.Fraction"", e);
    }
}","/**
 * <p>Creates a <code>Fraction</code> instance with the 3 parts
 * of a fraction X Y/Z.</p>
 *
 * <p>The negative sign must be passed in on the whole number part.</p>
 *
 * @param whole  the whole number, for example the one in 'one and three sevenths'
 * @param numerator  the numerator, for example the three in 'one and three sevenths'
 * @param denominator  the denominator, for example the seven in 'one and three sevenths'
 * @return a new fraction instance
 * @throws ArithmeticException if the denominator is <code>zero</code>
 * @throws ArithmeticException if the denominator is negative
 * @throws ArithmeticException if the numerator is negative
 * @throws ArithmeticException if the resulting numerator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"@Override
public float floatValue() {
    return ((float) numerator) / ((float) denominator);
}","public void test093154() throws Throwable {
    Fraction fraction0 = Fraction.getFraction(0, 105, 2506);
    assertEquals(0.041899443F, fraction0.floatValue(), 0.01F);
}","/**
 * <p>Gets the fraction as a <code>float</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>float</code>
 */"
"public static Fraction getFraction(int whole, int numerator, int denominator) {
    if (denominator == 0) {
        throw new ArithmeticException(""The denominator must not be zero"");
    }
    if (denominator < 0) {
        throw new ArithmeticException(""The denominator must not be negative"");
    }
    if (numerator < 0) {
        throw new ArithmeticException(""The numerator must not be negative"");
    }
    long numeratorValue;
    if (whole < 0) {
        numeratorValue = whole * (long) denominator - numerator;
    } else {
        numeratorValue = whole * (long) denominator + numerator;
    }
    if (numeratorValue < Integer.MIN_VALUE || numeratorValue > Integer.MAX_VALUE) {
        throw new ArithmeticException(""Numerator too large to represent as an Integer."");
    }
    return new Fraction((int) numeratorValue, denominator);
}","public void test094155() throws Throwable {
    // Undeclared exception!
    try {
        Fraction.getFraction(25, (-4144), (-4));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // The denominator must not be negative
        //
        verifyException(""org.apache.commons.lang3.math.Fraction"", e);
    }
}","/**
 * <p>Creates a <code>Fraction</code> instance with the 3 parts
 * of a fraction X Y/Z.</p>
 *
 * <p>The negative sign must be passed in on the whole number part.</p>
 *
 * @param whole  the whole number, for example the one in 'one and three sevenths'
 * @param numerator  the numerator, for example the three in 'one and three sevenths'
 * @param denominator  the denominator, for example the seven in 'one and three sevenths'
 * @return a new fraction instance
 * @throws ArithmeticException if the denominator is <code>zero</code>
 * @throws ArithmeticException if the denominator is negative
 * @throws ArithmeticException if the numerator is negative
 * @throws ArithmeticException if the resulting numerator exceeds
 *  <code>Integer.MAX_VALUE</code>
 */"
"public int getDenominator() {
    return denominator;
}","public void test095156() throws Throwable {
    Fraction fraction0 = Fraction.getFraction((-1), 0, 3);
    String string0 = fraction0.toProperString();
    assertEquals(3, fraction0.getDenominator());
}","/**
 * <p>Gets the denominator part of the fraction.</p>
 *
 * @return the denominator fraction part
 */"
"public String toProperString() {
    if (toProperString == null) {
        if (numerator == 0) {
            toProperString = ""0"";
        } else if (numerator == denominator) {
            toProperString = ""1"";
        } else if (numerator == -1 * denominator) {
            toProperString = ""-1"";
        } else if ((numerator > 0 ? -numerator : numerator) < -denominator) {
            // note that we do the magnitude comparison test above with
            // NEGATIVE (not positive) numbers, since negative numbers
            // have a larger range.  otherwise numerator==Integer.MIN_VALUE
            // is handled incorrectly.
            int properNumerator = getProperNumerator();
            if (properNumerator == 0) {
                toProperString = Integer.toString(getProperWhole());
            } else {
                toProperString = new StringBuilder(32).append(getProperWhole()).append(' ').append(properNumerator).append('/').append(getDenominator()).toString();
            }
        } else {
            toProperString = new StringBuilder(32).append(getNumerator()).append('/').append(getDenominator()).toString();
        }
    }
    return toProperString;
}","public void test095157() throws Throwable {
    Fraction fraction0 = Fraction.getFraction((-1), 0, 3);
    String string0 = fraction0.toProperString();
    assertEquals(""-1"", string0);
}","/**
 * <p>Gets the fraction as a proper <code>String</code> in the format X Y/Z.</p>
 *
 * <p>The format used in '<i>wholeNumber</i> <i>numerator</i>/<i>denominator</i>'.
 * If the whole number is zero it will be ommitted. If the numerator is zero,
 * only the whole number is returned.</p>
 *
 * @return a <code>String</code> form of the fraction
 */"
"public static Fraction getFraction(int numerator, int denominator) {
    if (denominator == 0) {
        throw new ArithmeticException(""The denominator must not be zero"");
    }
    if (denominator < 0) {
        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {
            throw new ArithmeticException(""overflow: can't negate"");
        }
        numerator = -numerator;
        denominator = -denominator;
    }
    return new Fraction(numerator, denominator);
}","public void test096159() throws Throwable {
    // Undeclared exception!
    try {
        Fraction.getFraction(9440, Integer.MIN_VALUE);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: can't negate
        //
        verifyException(""org.apache.commons.lang3.math.Fraction"", e);
    }
}","/**
 * <p>Creates a <code>Fraction</code> instance with the 2 parts
 * of a fraction Y/Z.</p>
 *
 * <p>Any negative signs are resolved to be on the numerator.</p>
 *
 * @param numerator  the numerator, for example the three in 'three sevenths'
 * @param denominator  the denominator, for example the seven in 'three sevenths'
 * @return a new fraction instance
 * @throws ArithmeticException if the denominator is <code>zero</code>
 * or the denominator is {@code negative} and the numerator is {@code Integer#MIN_VALUE}
 */"
"public static Fraction getFraction(int numerator, int denominator) {
    if (denominator == 0) {
        throw new ArithmeticException(""The denominator must not be zero"");
    }
    if (denominator < 0) {
        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {
            throw new ArithmeticException(""overflow: can't negate"");
        }
        numerator = -numerator;
        denominator = -denominator;
    }
    return new Fraction(numerator, denominator);
}","public void test097160() throws Throwable {
    // Undeclared exception!
    try {
        Fraction.getFraction(Integer.MIN_VALUE, (-1140));
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // overflow: can't negate
        //
        verifyException(""org.apache.commons.lang3.math.Fraction"", e);
    }
}","/**
 * <p>Creates a <code>Fraction</code> instance with the 2 parts
 * of a fraction Y/Z.</p>
 *
 * <p>Any negative signs are resolved to be on the numerator.</p>
 *
 * @param numerator  the numerator, for example the three in 'three sevenths'
 * @param denominator  the denominator, for example the seven in 'three sevenths'
 * @return a new fraction instance
 * @throws ArithmeticException if the denominator is <code>zero</code>
 * or the denominator is {@code negative} and the numerator is {@code Integer#MIN_VALUE}
 */"
"// Accessors
//-------------------------------------------------------------------
/**
 * <p>Gets the numerator part of the fraction.</p>
 *
 * <p>This method may return a value greater than the denominator, an
 * improper fraction, such as the seven in 7/4.</p>
 *
 * @return the numerator fraction part
 */
public int getNumerator() {
    return numerator;
}","public void test098161() throws Throwable {
    Fraction fraction0 = Fraction.getFraction(1, (-165));
    assertEquals((-1), fraction0.getNumerator());
}",""
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test098162() throws Throwable {
    Fraction fraction0 = Fraction.getFraction(1, (-165));
    assertEquals((-0.006060606060606061), fraction0.doubleValue(), 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"public static Fraction getFraction(int numerator, int denominator) {
    if (denominator == 0) {
        throw new ArithmeticException(""The denominator must not be zero"");
    }
    if (denominator < 0) {
        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {
            throw new ArithmeticException(""overflow: can't negate"");
        }
        numerator = -numerator;
        denominator = -denominator;
    }
    return new Fraction(numerator, denominator);
}","public void test099163() throws Throwable {
    // Undeclared exception!
    try {
        Fraction.getFraction(0, 0);
        fail(""Expecting exception: ArithmeticException"");
    } catch (ArithmeticException e) {
        //
        // The denominator must not be zero
        //
        verifyException(""org.apache.commons.lang3.math.Fraction"", e);
    }
}","/**
 * <p>Creates a <code>Fraction</code> instance with the 2 parts
 * of a fraction Y/Z.</p>
 *
 * <p>Any negative signs are resolved to be on the numerator.</p>
 *
 * @param numerator  the numerator, for example the three in 'three sevenths'
 * @param denominator  the denominator, for example the seven in 'three sevenths'
 * @return a new fraction instance
 * @throws ArithmeticException if the denominator is <code>zero</code>
 * or the denominator is {@code negative} and the numerator is {@code Integer#MIN_VALUE}
 */"
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test100164() throws Throwable {
    Fraction fraction0 = Fraction.TWO_THIRDS;
    double double0 = fraction0.doubleValue();
    assertEquals(0.6666666666666666, double0, 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"@Override
public long longValue() {
    return (long) numerator / denominator;
}","public void test101165() throws Throwable {
    Fraction fraction0 = Fraction.TWO_THIRDS;
    long long0 = fraction0.longValue();
    assertEquals(0L, long0);
}","/**
 * <p>Gets the fraction as a <code>long</code>. This returns the whole number
 * part of the fraction.</p>
 *
 * @return the whole number fraction part
 */"
"@Override
public float floatValue() {
    return ((float) numerator) / ((float) denominator);
}","public void test102166() throws Throwable {
    Fraction fraction0 = Fraction.TWO_QUARTERS;
    float float0 = fraction0.floatValue();
    assertEquals(0.5F, float0, 0.01F);
}","/**
 * <p>Gets the fraction as a <code>float</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>float</code>
 */"
"// Accessors
//-------------------------------------------------------------------
/**
 * <p>Gets the numerator part of the fraction.</p>
 *
 * <p>This method may return a value greater than the denominator, an
 * improper fraction, such as the seven in 7/4.</p>
 *
 * @return the numerator fraction part
 */
public int getNumerator() {
    return numerator;
}","public void test103167() throws Throwable {
    Fraction fraction0 = Fraction.FOUR_FIFTHS;
    Fraction fraction1 = Fraction.TWO_THIRDS;
    Fraction fraction2 = Fraction.THREE_QUARTERS;
    Fraction fraction3 = Fraction.getReducedFraction(Integer.MIN_VALUE, Integer.MIN_VALUE);
    int int0 = fraction1.compareTo(fraction3);
    assertEquals(1, fraction3.getNumerator());
}",""
"public int compareTo(Fraction other) {
    if (this == other) {
        return 0;
    }
    if (numerator == other.numerator && denominator == other.denominator) {
        return 0;
    }
    // otherwise see which is less
    long first = (long) numerator * (long) other.denominator;
    long second = (long) other.numerator * (long) denominator;
    if (first == second) {
        return 0;
    } else if (first < second) {
        return -1;
    } else {
        return 1;
    }
}","public void test103168() throws Throwable {
    Fraction fraction0 = Fraction.FOUR_FIFTHS;
    Fraction fraction1 = Fraction.TWO_THIRDS;
    Fraction fraction2 = Fraction.THREE_QUARTERS;
    Fraction fraction3 = Fraction.getReducedFraction(Integer.MIN_VALUE, Integer.MIN_VALUE);
    int int0 = fraction1.compareTo(fraction3);
    assertEquals((-1), int0);
}","/**
 * <p>Compares this object to another based on size.</p>
 *
 * <p>Note: this class has a natural ordering that is inconsistent
 * with equals, because, for example, equals treats 1/2 and 2/4 as
 * different, whereas compareTo treats them as equal.
 *
 * @param other  the object to compare to
 * @return -1 if this is less, 0 if equal, +1 if greater
 * @throws ClassCastException if the object is not a <code>Fraction</code>
 * @throws NullPointerException if the object is <code>null</code>
 */"
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test103169() throws Throwable {
    Fraction fraction0 = Fraction.FOUR_FIFTHS;
    Fraction fraction1 = Fraction.TWO_THIRDS;
    Fraction fraction2 = Fraction.THREE_QUARTERS;
    Fraction fraction3 = Fraction.getReducedFraction(Integer.MIN_VALUE, Integer.MIN_VALUE);
    int int0 = fraction1.compareTo(fraction3);
    Fraction fraction4 = Fraction.getFraction((-2145), 34);
    Fraction fraction5 = fraction0.ONE_FIFTH.multiplyBy(fraction1);
    assertEquals(0.13333333333333333, fraction5.doubleValue(), 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test103170() throws Throwable {
    Fraction fraction0 = Fraction.FOUR_FIFTHS;
    Fraction fraction1 = Fraction.TWO_THIRDS;
    Fraction fraction2 = Fraction.THREE_QUARTERS;
    Fraction fraction3 = Fraction.getReducedFraction(Integer.MIN_VALUE, Integer.MIN_VALUE);
    int int0 = fraction1.compareTo(fraction3);
    Fraction fraction4 = Fraction.getFraction((-2145), 34);
    Fraction fraction5 = fraction0.ONE_FIFTH.multiplyBy(fraction1);
    Fraction fraction6 = Fraction.TWO_THIRDS;
    fraction0.ONE_THIRD.hashCode();
    Fraction fraction7 = fraction1.TWO_THIRDS.add(fraction0);
    Fraction fraction8 = Fraction.getFraction((-199.6492926809913));
    assertEquals((-199.6492926284438), fraction8.doubleValue(), 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"@Override
public float floatValue() {
    return ((float) numerator) / ((float) denominator);
}","public void test103171() throws Throwable {
    Fraction fraction0 = Fraction.FOUR_FIFTHS;
    Fraction fraction1 = Fraction.TWO_THIRDS;
    Fraction fraction2 = Fraction.THREE_QUARTERS;
    Fraction fraction3 = Fraction.getReducedFraction(Integer.MIN_VALUE, Integer.MIN_VALUE);
    int int0 = fraction1.compareTo(fraction3);
    Fraction fraction4 = Fraction.getFraction((-2145), 34);
    Fraction fraction5 = fraction0.ONE_FIFTH.multiplyBy(fraction1);
    Fraction fraction6 = Fraction.TWO_THIRDS;
    fraction0.ONE_THIRD.hashCode();
    Fraction fraction7 = fraction1.TWO_THIRDS.add(fraction0);
    Fraction fraction8 = Fraction.getFraction((-199.6492926809913));
    Fraction fraction9 = fraction7.TWO_QUARTERS.subtract(fraction1);
    assertEquals((-0.16666667F), fraction9.floatValue(), 0.01F);
}","/**
 * <p>Gets the fraction as a <code>float</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>float</code>
 */"
"@Override
public double doubleValue() {
    return ((double) numerator) / ((double) denominator);
}","public void test103172() throws Throwable {
    Fraction fraction0 = Fraction.FOUR_FIFTHS;
    Fraction fraction1 = Fraction.TWO_THIRDS;
    Fraction fraction2 = Fraction.THREE_QUARTERS;
    Fraction fraction3 = Fraction.getReducedFraction(Integer.MIN_VALUE, Integer.MIN_VALUE);
    int int0 = fraction1.compareTo(fraction3);
    Fraction fraction4 = Fraction.getFraction((-2145), 34);
    Fraction fraction5 = fraction0.ONE_FIFTH.multiplyBy(fraction1);
    Fraction fraction6 = Fraction.TWO_THIRDS;
    fraction0.ONE_THIRD.hashCode();
    Fraction fraction7 = fraction1.TWO_THIRDS.add(fraction0);
    Fraction fraction8 = Fraction.getFraction((-199.6492926809913));
    Fraction fraction9 = fraction7.TWO_QUARTERS.subtract(fraction1);
    assertEquals(1.4666666666666666, fraction7.doubleValue(), 0.01);
}","/**
 * <p>Gets the fraction as a <code>double</code>. This calculates the fraction
 * as the numerator divided by denominator.</p>
 *
 * @return the fraction as a <code>double</code>
 */"
"public int getProperNumerator() {
    return Math.abs(numerator % denominator);
}","public void test103174() throws Throwable {
    Fraction fraction0 = Fraction.FOUR_FIFTHS;
    Fraction fraction1 = Fraction.TWO_THIRDS;
    Fraction fraction2 = Fraction.THREE_QUARTERS;
    Fraction fraction3 = Fraction.getReducedFraction(Integer.MIN_VALUE, Integer.MIN_VALUE);
    int int0 = fraction1.compareTo(fraction3);
    Fraction fraction4 = Fraction.getFraction((-2145), 34);
    Fraction fraction5 = fraction0.ONE_FIFTH.multiplyBy(fraction1);
    Fraction fraction6 = Fraction.TWO_THIRDS;
    fraction0.ONE_THIRD.hashCode();
    Fraction fraction7 = fraction1.TWO_THIRDS.add(fraction0);
    Fraction fraction8 = Fraction.getFraction((-199.6492926809913));
    Fraction fraction9 = fraction7.TWO_QUARTERS.subtract(fraction1);
    int int1 = fraction4.getProperNumerator();
    assertEquals(3, int1);
}","/**
 * <p>Gets the proper numerator, always positive.</p>
 *
 * <p>An improper fraction 7/4 can be resolved into a proper one, 1 3/4.
 * This method returns the 3 from the proper fraction.</p>
 *
 * <p>If the fraction is negative such as -7/4, it can be resolved into
 * -1 3/4, so this method returns the positive proper numerator, 3.</p>
 *
 * @return the numerator fraction part of a proper fraction, always positive
 */"
"// Number methods
//-------------------------------------------------------------------
/**
 * <p>Gets the fraction as an <code>int</code>. This returns the whole number
 * part of the fraction.</p>
 *
 * @return the whole number fraction part
 */
@Override
public int intValue() {
    return numerator / denominator;
}","public void test104175() throws Throwable {
    Fraction fraction0 = Fraction.ONE_FIFTH;
    int int0 = fraction0.intValue();
    assertEquals(0, int0);
}",""
