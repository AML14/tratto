focal_method,test_prefix,docstring
"public boolean isEquals() {
    return this.isEquals;
}","public void test0000() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    assertTrue(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test0001() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    boolean[] booleanArray0 = new boolean[0];
    boolean[] booleanArray1 = new boolean[5];
    equalsBuilder0.append(booleanArray0, booleanArray1);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test0013() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    float[] floatArray0 = new float[7];
    float[] floatArray1 = new float[3];
    equalsBuilder0.append(floatArray0, floatArray1);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test0025() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    double[] doubleArray0 = new double[7];
    double[] doubleArray1 = new double[2];
    equalsBuilder0.append(doubleArray0, doubleArray1);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test0037() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    byte[] byteArray0 = new byte[8];
    byte[] byteArray1 = new byte[21];
    equalsBuilder0.append(byteArray0, byteArray1);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test0049() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    short[] shortArray0 = new short[0];
    short[] shortArray1 = new short[5];
    equalsBuilder0.append(shortArray0, shortArray1);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test00511() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    int[] intArray0 = new int[7];
    int[] intArray1 = new int[0];
    equalsBuilder0.append(intArray0, intArray1);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test00613() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    long[] longArray0 = new long[5];
    long[] longArray1 = new long[7];
    equalsBuilder0.append(longArray0, longArray1);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test00715() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    Object[] objectArray0 = new Object[4];
    Object[] objectArray1 = new Object[8];
    equalsBuilder0.append(objectArray0, objectArray1);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test00817() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    char[] charArray0 = new char[3];
    char[] charArray1 = new char[3];
    charArray1[0] = '3';
    equalsBuilder0.append(charArray0, charArray1);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test00919() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    equalsBuilder0.setEquals(false);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public static boolean reflectionEquals(Object lhs, Object rhs, String[] excludeFields) {
    return reflectionEquals(lhs, rhs, false, null, excludeFields);
}","public void test01020() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    Object object0 = new Object();
    String[] stringArray0 = new String[6];
    stringArray0[5] = ""isEquals"";
    boolean boolean0 = EqualsBuilder.reflectionEquals(object0, (Object) equalsBuilder0, stringArray0);
    assertTrue(boolean0);
}","/**
 * <p>This method uses reflection to determine if the two <code>Object</code>s
 * are equal.</p>
 *
 * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private
 * fields. This means that it will throw a security exception if run under
 * a security manager, if the permissions are not set up correctly. It is also
 * not as efficient as testing explicitly.</p>
 *
 * <p>Transient members will be not be tested, as they are likely derived
 * fields, and not part of the value of the Object.</p>
 *
 * <p>Static fields will not be tested. Superclass fields will be included.</p>
 *
 * @param lhs  <code>this</code> object
 * @param rhs  the other object
 * @param excludeFields  array of field names to exclude from testing
 * @return <code>true</code> if the two Objects have tested equals.
 */"
"public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class reflectUpToClass) {
    return reflectionEquals(lhs, rhs, testTransients, reflectUpToClass, null);
}","public void test01121() throws Throwable {
    Class<Object> class0 = Object.class;
    boolean boolean0 = EqualsBuilder.reflectionEquals((Object) ""D9@sfO!7"", (Object) ""D9@sfO!7"", false, (Class) class0);
    assertTrue(boolean0);
}","/**
 * <p>This method uses reflection to determine if the two <code>Object</code>s
 * are equal.</p>
 *
 * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private
 * fields. This means that it will throw a security exception if run under
 * a security manager, if the permissions are not set up correctly. It is also
 * not as efficient as testing explicitly.</p>
 *
 * <p>If the testTransients parameter is set to <code>true</code>, transient
 * members will be tested, otherwise they are ignored, as they are likely
 * derived fields, and not part of the value of the <code>Object</code>.</p>
 *
 * <p>Static fields will not be included. Superclass fields will be appended
 * up to and including the specified superclass. A null superclass is treated
 * as java.lang.Object.</p>
 *
 * @param lhs  <code>this</code> object
 * @param rhs  the other object
 * @param testTransients  whether to include transient fields
 * @param reflectUpToClass  the superclass to reflect up to (inclusive),
 *  may be <code>null</code>
 * @return <code>true</code> if the two Objects have tested equals.
 * @since 2.0
 */"
"public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients) {
    return reflectionEquals(lhs, rhs, testTransients, null, null);
}","public void test01222() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    boolean boolean0 = EqualsBuilder.reflectionEquals((Object) equalsBuilder0, (Object) equalsBuilder0, false);
    assertTrue(boolean0);
}","/**
 * <p>This method uses reflection to determine if the two <code>Object</code>s
 * are equal.</p>
 *
 * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private
 * fields. This means that it will throw a security exception if run under
 * a security manager, if the permissions are not set up correctly. It is also
 * not as efficient as testing explicitly.</p>
 *
 * <p>If the TestTransients parameter is set to <code>true</code>, transient
 * members will be tested, otherwise they are ignored, as they are likely
 * derived fields, and not part of the value of the <code>Object</code>.</p>
 *
 * <p>Static fields will not be tested. Superclass fields will be included.</p>
 *
 * @param lhs  <code>this</code> object
 * @param rhs  the other object
 * @param testTransients  whether to include transient fields
 * @return <code>true</code> if the two Objects have tested equals.
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test01223() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    boolean boolean0 = EqualsBuilder.reflectionEquals((Object) equalsBuilder0, (Object) equalsBuilder0, false);
    assertTrue(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test01324() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    boolean boolean0 = EqualsBuilder.reflectionEquals((Object) """", (Object) equalsBuilder0);
    assertTrue(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"//-------------------------------------------------------------------------
/**
 * <p>This method uses reflection to determine if the two <code>Object</code>s
 * are equal.</p>
 *
 * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private
 * fields. This means that it will throw a security exception if run under
 * a security manager, if the permissions are not set up correctly. It is also
 * not as efficient as testing explicitly.</p>
 *
 * <p>Transient members will be not be tested, as they are likely derived
 * fields, and not part of the value of the Object.</p>
 *
 * <p>Static fields will not be tested. Superclass fields will be included.</p>
 *
 * @param lhs  <code>this</code> object
 * @param rhs  the other object
 * @return <code>true</code> if the two Objects have tested equals.
 */
public static boolean reflectionEquals(Object lhs, Object rhs) {
    return reflectionEquals(lhs, rhs, false, null, null);
}","public void test01325() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    boolean boolean0 = EqualsBuilder.reflectionEquals((Object) """", (Object) equalsBuilder0);
    assertFalse(boolean0);
}",""
"public boolean isEquals() {
    return this.isEquals;
}","public void test01426() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    EqualsBuilder equalsBuilder1 = equalsBuilder0.appendSuper(true);
    assertTrue(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test01527() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    char[] charArray0 = new char[3];
    charArray0[0] = '3';
    charArray0[1] = 'm';
    char[] charArray1 = new char[3];
    charArray1[0] = '3';
    charArray1[1] = 'm';
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append(charArray0, charArray1);
    assertTrue(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test01629() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    char[] charArray0 = new char[3];
    char[] charArray1 = new char[9];
    equalsBuilder0.append(charArray0, charArray1);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test01731() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    equalsBuilder0.append('m', '_');
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test01832() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append('$', '$');
    assertTrue(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test01934() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    equalsBuilder0.append((-1), (-30));
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test02035() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append((-516), (-516));
    assertTrue(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test02136() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append((long) (short) (-2756), (long) (short) (-2756));
    assertTrue(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test02238() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    equalsBuilder0.append((Object) null, (Object) ""f"");
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test02339() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append((Object) equalsBuilder0, (Object) equalsBuilder0);
    assertTrue(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class reflectUpToClass, String[] excludeFields) {
    if (lhs == rhs) {
        return true;
    }
    if (lhs == null || rhs == null) {
        return false;
    }
    // Find the leaf class since there may be transients in the leaf
    // class or in classes between the leaf and root.
    // If we are not testing transients or a subclass has no ivars,
    // then a subclass can test equals to a superclass.
    Class lhsClass = lhs.getClass();
    Class rhsClass = rhs.getClass();
    Class testClass;
    if (lhsClass.isInstance(rhs)) {
        testClass = lhsClass;
        if (!rhsClass.isInstance(lhs)) {
            // rhsClass is a subclass of lhsClass
            testClass = rhsClass;
        }
    } else if (rhsClass.isInstance(lhs)) {
        testClass = rhsClass;
        if (!lhsClass.isInstance(rhs)) {
            // lhsClass is a subclass of rhsClass
            testClass = lhsClass;
        }
    } else {
        // The two classes are not related.
        return false;
    }
    EqualsBuilder equalsBuilder = new EqualsBuilder();
    try {
        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);
        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {
            testClass = testClass.getSuperclass();
            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);
        }
    } catch (IllegalArgumentException e) {
        // In this case, we tried to test a subclass vs. a superclass and
        // the subclass has ivars or the ivars are transient and
        // we are testing transients.
        // If a subclass has ivars that we are trying to test them, we get an
        // exception and we know that the objects are not equal.
        return false;
    }
    return equalsBuilder.isEquals();
}","public void test02440() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    Class<Object> class0 = Object.class;
    String[] stringArray0 = new String[7];
    boolean boolean0 = EqualsBuilder.reflectionEquals((Object) """", (Object) equalsBuilder0, false, (Class) class0, stringArray0);
    assertFalse(boolean0);
}","/**
 * <p>This method uses reflection to determine if the two <code>Object</code>s
 * are equal.</p>
 *
 * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private
 * fields. This means that it will throw a security exception if run under
 * a security manager, if the permissions are not set up correctly. It is also
 * not as efficient as testing explicitly.</p>
 *
 * <p>If the testTransients parameter is set to <code>true</code>, transient
 * members will be tested, otherwise they are ignored, as they are likely
 * derived fields, and not part of the value of the <code>Object</code>.</p>
 *
 * <p>Static fields will not be included. Superclass fields will be appended
 * up to and including the specified superclass. A null superclass is treated
 * as java.lang.Object.</p>
 *
 * @param lhs  <code>this</code> object
 * @param rhs  the other object
 * @param testTransients  whether to include transient fields
 * @param reflectUpToClass  the superclass to reflect up to (inclusive),
 *  may be <code>null</code>
 * @param excludeFields  array of field names to exclude from testing
 * @return <code>true</code> if the two Objects have tested equals.
 * @since 2.0
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test02441() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    Class<Object> class0 = Object.class;
    String[] stringArray0 = new String[7];
    boolean boolean0 = EqualsBuilder.reflectionEquals((Object) """", (Object) equalsBuilder0, false, (Class) class0, stringArray0);
    assertTrue(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class reflectUpToClass, String[] excludeFields) {
    if (lhs == rhs) {
        return true;
    }
    if (lhs == null || rhs == null) {
        return false;
    }
    // Find the leaf class since there may be transients in the leaf
    // class or in classes between the leaf and root.
    // If we are not testing transients or a subclass has no ivars,
    // then a subclass can test equals to a superclass.
    Class lhsClass = lhs.getClass();
    Class rhsClass = rhs.getClass();
    Class testClass;
    if (lhsClass.isInstance(rhs)) {
        testClass = lhsClass;
        if (!rhsClass.isInstance(lhs)) {
            // rhsClass is a subclass of lhsClass
            testClass = rhsClass;
        }
    } else if (rhsClass.isInstance(lhs)) {
        testClass = rhsClass;
        if (!lhsClass.isInstance(rhs)) {
            // lhsClass is a subclass of rhsClass
            testClass = lhsClass;
        }
    } else {
        // The two classes are not related.
        return false;
    }
    EqualsBuilder equalsBuilder = new EqualsBuilder();
    try {
        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);
        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {
            testClass = testClass.getSuperclass();
            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);
        }
    } catch (IllegalArgumentException e) {
        // In this case, we tried to test a subclass vs. a superclass and
        // the subclass has ivars or the ivars are transient and
        // we are testing transients.
        // If a subclass has ivars that we are trying to test them, we get an
        // exception and we know that the objects are not equal.
        return false;
    }
    return equalsBuilder.isEquals();
}","public void test02542() throws Throwable {
    Object object0 = new Object();
    Class<Object> class0 = Object.class;
    String[] stringArray0 = new String[5];
    boolean boolean0 = EqualsBuilder.reflectionEquals(object0, (Object) ""D9@sfO!7"", true, (Class) class0, stringArray0);
    assertFalse(boolean0);
}","/**
 * <p>This method uses reflection to determine if the two <code>Object</code>s
 * are equal.</p>
 *
 * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private
 * fields. This means that it will throw a security exception if run under
 * a security manager, if the permissions are not set up correctly. It is also
 * not as efficient as testing explicitly.</p>
 *
 * <p>If the testTransients parameter is set to <code>true</code>, transient
 * members will be tested, otherwise they are ignored, as they are likely
 * derived fields, and not part of the value of the <code>Object</code>.</p>
 *
 * <p>Static fields will not be included. Superclass fields will be appended
 * up to and including the specified superclass. A null superclass is treated
 * as java.lang.Object.</p>
 *
 * @param lhs  <code>this</code> object
 * @param rhs  the other object
 * @param testTransients  whether to include transient fields
 * @param reflectUpToClass  the superclass to reflect up to (inclusive),
 *  may be <code>null</code>
 * @param excludeFields  array of field names to exclude from testing
 * @return <code>true</code> if the two Objects have tested equals.
 * @since 2.0
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test02643() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    boolean boolean0 = equalsBuilder0.isEquals();
    assertTrue(boolean0);
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test02745() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    boolean[] booleanArray0 = new boolean[5];
    boolean[] booleanArray1 = new boolean[1];
    equalsBuilder0.append(booleanArray0, booleanArray1);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test02846() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    boolean[] booleanArray0 = new boolean[2];
    boolean[] booleanArray1 = new boolean[2];
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append(booleanArray0, booleanArray1);
    assertTrue(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test02948() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    boolean[] booleanArray0 = new boolean[6];
    equalsBuilder0.append((boolean[]) null, booleanArray0);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test03050() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    boolean[] booleanArray0 = new boolean[9];
    equalsBuilder0.append(booleanArray0, (boolean[]) null);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test03152() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    equalsBuilder0.append(0.0F, (-1.0F));
    boolean[] booleanArray0 = new boolean[3];
    equalsBuilder0.append(booleanArray0, booleanArray0);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test03253() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append((boolean[]) null, (boolean[]) null);
    assertTrue(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test03355() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    float[] floatArray0 = new float[4];
    floatArray0[0] = 1.0F;
    float[] floatArray1 = new float[4];
    equalsBuilder0.append(floatArray0, floatArray1);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test03457() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    float[] floatArray0 = new float[6];
    float[] floatArray1 = new float[7];
    equalsBuilder0.append(floatArray0, floatArray1);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test03558() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    float[] floatArray0 = new float[4];
    float[] floatArray1 = new float[4];
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append(floatArray0, floatArray1);
    assertTrue(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test03660() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    float[] floatArray0 = new float[3];
    equalsBuilder0.append(floatArray0, (float[]) null);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test03762() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append((Object) ""1q.76CH;&YeR(]cmJ"", (Object) equalsBuilder0);
    equalsBuilder1.append((float[]) null, (float[]) null);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test03863() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    float[] floatArray0 = new float[9];
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append(floatArray0, floatArray0);
    assertTrue(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test03965() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    double[] doubleArray0 = new double[9];
    equalsBuilder0.append((double[]) null, doubleArray0);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test04067() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    double[] doubleArray0 = new double[0];
    double[] doubleArray1 = new double[6];
    equalsBuilder0.append(doubleArray0, doubleArray1);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test04169() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    Object[] objectArray0 = new Object[2];
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append((Object[]) null, objectArray0);
    double[] doubleArray0 = new double[4];
    equalsBuilder1.append(doubleArray0, doubleArray0);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test04270() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append((double[]) null, (double[]) null);
    assertTrue(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test04372() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    byte[] byteArray0 = new byte[4];
    byteArray0[0] = (byte) 78;
    byte[] byteArray1 = new byte[4];
    equalsBuilder0.append(byteArray0, byteArray1);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test04474() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    byte[] byteArray0 = new byte[8];
    byte[] byteArray1 = new byte[4];
    equalsBuilder0.append(byteArray0, byteArray1);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test04576() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    byte[] byteArray0 = new byte[5];
    equalsBuilder0.append(byteArray0, (byte[]) null);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test04677() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    byte[] byteArray0 = new byte[4];
    byte[] byteArray1 = new byte[4];
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append(byteArray0, byteArray1);
    assertTrue(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test04779() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append(704L, (-2214L));
    byte[] byteArray0 = new byte[5];
    equalsBuilder1.append(byteArray0, byteArray0);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test04880() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    byte[] byteArray0 = new byte[4];
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append(byteArray0, byteArray0);
    assertTrue(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test04982() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    char[] charArray0 = new char[0];
    equalsBuilder0.append(charArray0, (char[]) null);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test05084() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    char[] charArray0 = new char[6];
    equalsBuilder0.append((char[]) null, charArray0);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test05185() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    char[] charArray0 = new char[0];
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append(charArray0, charArray0);
    assertTrue(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test05287() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    int[] intArray0 = new int[5];
    intArray0[2] = (-452);
    int[] intArray1 = new int[5];
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append(intArray0, intArray1);
    char[] charArray0 = new char[0];
    equalsBuilder1.append(charArray0, charArray0);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test05389() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    short[] shortArray0 = new short[5];
    shortArray0[0] = (short) 512;
    short[] shortArray1 = new short[5];
    equalsBuilder0.append(shortArray0, shortArray1);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test05490() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    short[] shortArray0 = new short[5];
    short[] shortArray1 = new short[5];
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append(shortArray0, shortArray1);
    assertTrue(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test05592() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    short[] shortArray0 = new short[5];
    equalsBuilder0.append(shortArray0, (short[]) null);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test05694() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    short[] shortArray0 = new short[5];
    equalsBuilder0.append((short[]) null, shortArray0);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test05796() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    short[] shortArray0 = new short[9];
    short[] shortArray1 = new short[3];
    equalsBuilder0.append(shortArray0, shortArray1);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test05898() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append(704L, (-2214L));
    short[] shortArray0 = new short[0];
    equalsBuilder1.append(shortArray0, shortArray0);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test05999() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    short[] shortArray0 = new short[0];
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append(shortArray0, shortArray0);
    assertTrue(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test060101() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    int[] intArray0 = new int[1];
    int[] intArray1 = new int[7];
    equalsBuilder0.append(intArray0, intArray1);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test061103() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    int[] intArray0 = new int[6];
    equalsBuilder0.append(intArray0, (int[]) null);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test062105() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    int[] intArray0 = new int[4];
    equalsBuilder0.append((int[]) null, intArray0);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test063106() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    int[] intArray0 = new int[9];
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append(intArray0, intArray0);
    assertTrue(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test064108() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    equalsBuilder0.append((Object) ""1q.76CH;&YeR(]cmJ"", (Object) equalsBuilder0);
    int[] intArray0 = new int[6];
    equalsBuilder0.append(intArray0, intArray0);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test065110() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    long[] longArray0 = new long[9];
    longArray0[0] = 1922L;
    long[] longArray1 = new long[9];
    equalsBuilder0.append(longArray0, longArray1);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test066111() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    long[] longArray0 = new long[9];
    long[] longArray1 = new long[9];
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append(longArray0, longArray1);
    assertTrue(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test067113() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    long[] longArray0 = new long[6];
    equalsBuilder0.append(longArray0, (long[]) null);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test068115() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    long[] longArray0 = new long[8];
    long[] longArray1 = new long[6];
    equalsBuilder0.append(longArray0, longArray1);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test069116() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    long[] longArray0 = new long[0];
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append(longArray0, longArray0);
    assertTrue(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test070117() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    Object[] objectArray0 = new Object[7];
    objectArray0[0] = (Object) equalsBuilder0;
    objectArray0[1] = (Object) equalsBuilder0;
    objectArray0[2] = (Object) equalsBuilder0;
    objectArray0[3] = (Object) equalsBuilder0;
    objectArray0[4] = (Object) equalsBuilder0;
    objectArray0[5] = (Object) equalsBuilder0;
    Object[] objectArray1 = new Object[7];
    objectArray1[0] = (Object) equalsBuilder0;
    objectArray1[1] = objectArray0[3];
    objectArray1[2] = (Object) equalsBuilder0;
    objectArray1[3] = objectArray0[2];
    objectArray1[4] = (Object) equalsBuilder0;
    objectArray1[5] = objectArray0[1];
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append(objectArray0, objectArray1);
    assertTrue(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test071119() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    Object[] objectArray0 = new Object[7];
    Object[] objectArray1 = new Object[4];
    equalsBuilder0.append(objectArray0, objectArray1);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test072121() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    Object[] objectArray0 = new Object[6];
    equalsBuilder0.append(objectArray0, (Object[]) null);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test073123() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    Object[] objectArray0 = new Object[2];
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append((Object[]) null, objectArray0);
    long[] longArray0 = new long[8];
    equalsBuilder1.append(longArray0, longArray0);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test074124() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    Object[] objectArray0 = new Object[4];
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append(objectArray0, objectArray0);
    assertTrue(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test075126() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append(0.0F, (-1.0F));
    Object[] objectArray0 = new Object[2];
    equalsBuilder1.append(objectArray0, objectArray0);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test076127() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append(false, false);
    assertTrue(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public EqualsBuilder append(boolean lhs, boolean rhs) {
    if (isEquals == false) {
        return this;
    }
    isEquals = (lhs == rhs);
    return this;
}","public void test077128() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append(704L, (-2214L));
    EqualsBuilder equalsBuilder2 = equalsBuilder1.append(true, false);
    assertSame(equalsBuilder2, equalsBuilder1);
}","/**
 * <p>Test if two <code>booleans</code>s are equal.</p>
 *
 * @param lhs  the left hand <code>boolean</code>
 * @param rhs  the right hand <code>boolean</code>
 * @return EqualsBuilder - used to chain calls.
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test078130() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append(false, true);
    boolean boolean0 = equalsBuilder1.isEquals();
    assertFalse(boolean0);
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test079131() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    equalsBuilder0.append((short) (-4113), (short) (-1));
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append((float) (-4113), (float) (short) (-1));
    assertFalse(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test080132() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    equalsBuilder0.append((short) (-4113), (short) (-1));
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append(0.0, (double) (-4113));
    assertFalse(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test081134() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    equalsBuilder0.append((byte) 9, (byte) 57);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test082136() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    int[] intArray0 = new int[5];
    intArray0[2] = (-452);
    int[] intArray1 = new int[5];
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append(intArray0, intArray1);
    equalsBuilder1.append((byte) (-97), (byte) (-97));
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test083137() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append((byte) 1, (byte) 1);
    assertTrue(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test084138() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append((short) 680, (short) 680);
    assertTrue(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test085140() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append((short) (-4113), (short) (-1));
    equalsBuilder1.append((short) 0, (short) (-2303));
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test086142() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    int[] intArray0 = new int[5];
    intArray0[2] = (-452);
    int[] intArray1 = new int[5];
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append(intArray0, intArray1);
    equalsBuilder1.append('\""', '\""');
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public EqualsBuilder append(int lhs, int rhs) {
    if (isEquals == false) {
        return this;
    }
    isEquals = (lhs == rhs);
    return this;
}","public void test087143() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append((short) (-3567), (short) 1009);
    EqualsBuilder equalsBuilder2 = equalsBuilder1.append((int) (short) (-3567), (int) (byte) 0);
    assertSame(equalsBuilder2, equalsBuilder1);
}","/**
 * <p>Test if two <code>int</code>s are equal.</p>
 *
 * @param lhs  the left hand <code>int</code>
 * @param rhs  the right hand <code>int</code>
 * @return EqualsBuilder - used to chain calls.
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test088144() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append(0.0F, 0.0F);
    assertTrue(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test089145() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append((-392.5242693624174), (-392.5242693624174));
    assertTrue(equalsBuilder1.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public EqualsBuilder append(long lhs, long rhs) {
    if (isEquals == false) {
        return this;
    }
    isEquals = (lhs == rhs);
    return this;
}","public void test090146() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    equalsBuilder0.append((short) (-4113), (short) (-1));
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append((long) (short) (-4113), 1L);
    assertSame(equalsBuilder1, equalsBuilder0);
}","/**
 * <p>
 * Test if two <code>long</code> s are equal.
 * </p>
 *
 * @param lhs
 *                  the left hand <code>long</code>
 * @param rhs
 *                  the right hand <code>long</code>
 * @return EqualsBuilder - used to chain calls.
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test091148() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    equalsBuilder0.append(0.0, 685.2);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test092150() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    equalsBuilder0.append((Object) ""The Array must not be null"", (Object) null);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test093152() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    Object[] objectArray0 = new Object[7];
    Object[] objectArray1 = new Object[7];
    objectArray1[0] = (Object) equalsBuilder0;
    equalsBuilder0.append(objectArray0, objectArray1);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"//-------------------------------------------------------------------------
/**
 * <p>Test if two <code>Object</code>s are equal using their
 * <code>equals</code> method.</p>
 *
 * @param lhs  the left hand object
 * @param rhs  the right hand object
 * @return EqualsBuilder - used to chain calls.
 */
public EqualsBuilder append(Object lhs, Object rhs) {
    if (isEquals == false) {
        return this;
    }
    if (lhs == rhs) {
        return this;
    }
    if (lhs == null || rhs == null) {
        this.setEquals(false);
        return this;
    }
    Class lhsClass = lhs.getClass();
    if (!lhsClass.isArray()) {
        // The simple case, not an array, just test the element
        isEquals = lhs.equals(rhs);
    } else if (lhs.getClass() != rhs.getClass()) {
        // Here when we compare different dimensions, for example: a boolean[][] to a boolean[]
        this.setEquals(false);
    } else // 'Switch' on type of array, to dispatch to the correct handler
    // This handles multi dimensional arrays of the same depth
    if (lhs instanceof long[]) {
        append((long[]) lhs, (long[]) rhs);
    } else if (lhs instanceof int[]) {
        append((int[]) lhs, (int[]) rhs);
    } else if (lhs instanceof short[]) {
        append((short[]) lhs, (short[]) rhs);
    } else if (lhs instanceof char[]) {
        append((char[]) lhs, (char[]) rhs);
    } else if (lhs instanceof byte[]) {
        append((byte[]) lhs, (byte[]) rhs);
    } else if (lhs instanceof double[]) {
        append((double[]) lhs, (double[]) rhs);
    } else if (lhs instanceof float[]) {
        append((float[]) lhs, (float[]) rhs);
    } else if (lhs instanceof boolean[]) {
        append((boolean[]) lhs, (boolean[]) rhs);
    } else {
        // Not an array of primitives
        append((Object[]) lhs, (Object[]) rhs);
    }
    return this;
}","public void test094153() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append((short) (-4113), (short) (-1));
    Object object0 = new Object();
    EqualsBuilder equalsBuilder2 = equalsBuilder0.append(object0, (Object) """");
    assertSame(equalsBuilder2, equalsBuilder1);
}",""
"//-------------------------------------------------------------------------
/**
 * <p>Adds the result of <code>super.equals()</code> to this builder.</p>
 *
 * @param superEquals  the result of calling <code>super.equals()</code>
 * @return EqualsBuilder - used to chain calls.
 * @since 2.0
 */
public EqualsBuilder appendSuper(boolean superEquals) {
    if (isEquals == false) {
        return this;
    }
    isEquals = superEquals;
    return this;
}","public void test095154() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    EqualsBuilder equalsBuilder1 = equalsBuilder0.append((short) (-4113), (short) (-1));
    EqualsBuilder equalsBuilder2 = equalsBuilder1.appendSuper(false);
    assertSame(equalsBuilder0, equalsBuilder2);
}",""
"//-------------------------------------------------------------------------
/**
 * <p>This method uses reflection to determine if the two <code>Object</code>s
 * are equal.</p>
 *
 * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private
 * fields. This means that it will throw a security exception if run under
 * a security manager, if the permissions are not set up correctly. It is also
 * not as efficient as testing explicitly.</p>
 *
 * <p>Transient members will be not be tested, as they are likely derived
 * fields, and not part of the value of the Object.</p>
 *
 * <p>Static fields will not be tested. Superclass fields will be included.</p>
 *
 * @param lhs  <code>this</code> object
 * @param rhs  the other object
 * @return <code>true</code> if the two Objects have tested equals.
 */
public static boolean reflectionEquals(Object lhs, Object rhs) {
    return reflectionEquals(lhs, rhs, false, null, null);
}","public void test096155() throws Throwable {
    Object object0 = new Object();
    Class<String> class0 = String.class;
    boolean boolean0 = EqualsBuilder.reflectionEquals(object0, (Object) class0);
    assertTrue(boolean0);
}",""
"public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class reflectUpToClass) {
    return reflectionEquals(lhs, rhs, testTransients, reflectUpToClass, null);
}","public void test097156() throws Throwable {
    Class<String> class0 = String.class;
    boolean boolean0 = EqualsBuilder.reflectionEquals((Object) ""org.apache.commons.lang.builder.ToStringStyle$DefaultToStringStyle"", (Object) ""Sj;Krg'fne*ZNR7y^o"", false, (Class) class0);
    assertFalse(boolean0);
}","/**
 * <p>This method uses reflection to determine if the two <code>Object</code>s
 * are equal.</p>
 *
 * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private
 * fields. This means that it will throw a security exception if run under
 * a security manager, if the permissions are not set up correctly. It is also
 * not as efficient as testing explicitly.</p>
 *
 * <p>If the testTransients parameter is set to <code>true</code>, transient
 * members will be tested, otherwise they are ignored, as they are likely
 * derived fields, and not part of the value of the <code>Object</code>.</p>
 *
 * <p>Static fields will not be included. Superclass fields will be appended
 * up to and including the specified superclass. A null superclass is treated
 * as java.lang.Object.</p>
 *
 * @param lhs  <code>this</code> object
 * @param rhs  the other object
 * @param testTransients  whether to include transient fields
 * @param reflectUpToClass  the superclass to reflect up to (inclusive),
 *  may be <code>null</code>
 * @return <code>true</code> if the two Objects have tested equals.
 * @since 2.0
 */"
"public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class reflectUpToClass, String[] excludeFields) {
    if (lhs == rhs) {
        return true;
    }
    if (lhs == null || rhs == null) {
        return false;
    }
    // Find the leaf class since there may be transients in the leaf
    // class or in classes between the leaf and root.
    // If we are not testing transients or a subclass has no ivars,
    // then a subclass can test equals to a superclass.
    Class lhsClass = lhs.getClass();
    Class rhsClass = rhs.getClass();
    Class testClass;
    if (lhsClass.isInstance(rhs)) {
        testClass = lhsClass;
        if (!rhsClass.isInstance(lhs)) {
            // rhsClass is a subclass of lhsClass
            testClass = rhsClass;
        }
    } else if (rhsClass.isInstance(lhs)) {
        testClass = rhsClass;
        if (!lhsClass.isInstance(rhs)) {
            // lhsClass is a subclass of rhsClass
            testClass = lhsClass;
        }
    } else {
        // The two classes are not related.
        return false;
    }
    EqualsBuilder equalsBuilder = new EqualsBuilder();
    try {
        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);
        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {
            testClass = testClass.getSuperclass();
            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);
        }
    } catch (IllegalArgumentException e) {
        // In this case, we tried to test a subclass vs. a superclass and
        // the subclass has ivars or the ivars are transient and
        // we are testing transients.
        // If a subclass has ivars that we are trying to test them, we get an
        // exception and we know that the objects are not equal.
        return false;
    }
    return equalsBuilder.isEquals();
}","public void test098157() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    Object object0 = new Object();
    Class<Integer> class0 = Integer.class;
    String[] stringArray0 = new String[7];
    stringArray0[2] = ""isEquals"";
    boolean boolean0 = EqualsBuilder.reflectionEquals((Object) equalsBuilder0, object0, true, (Class) class0, stringArray0);
    assertTrue(boolean0);
}","/**
 * <p>This method uses reflection to determine if the two <code>Object</code>s
 * are equal.</p>
 *
 * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private
 * fields. This means that it will throw a security exception if run under
 * a security manager, if the permissions are not set up correctly. It is also
 * not as efficient as testing explicitly.</p>
 *
 * <p>If the testTransients parameter is set to <code>true</code>, transient
 * members will be tested, otherwise they are ignored, as they are likely
 * derived fields, and not part of the value of the <code>Object</code>.</p>
 *
 * <p>Static fields will not be included. Superclass fields will be appended
 * up to and including the specified superclass. A null superclass is treated
 * as java.lang.Object.</p>
 *
 * @param lhs  <code>this</code> object
 * @param rhs  the other object
 * @param testTransients  whether to include transient fields
 * @param reflectUpToClass  the superclass to reflect up to (inclusive),
 *  may be <code>null</code>
 * @param excludeFields  array of field names to exclude from testing
 * @return <code>true</code> if the two Objects have tested equals.
 * @since 2.0
 */"
"public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class reflectUpToClass, String[] excludeFields) {
    if (lhs == rhs) {
        return true;
    }
    if (lhs == null || rhs == null) {
        return false;
    }
    // Find the leaf class since there may be transients in the leaf
    // class or in classes between the leaf and root.
    // If we are not testing transients or a subclass has no ivars,
    // then a subclass can test equals to a superclass.
    Class lhsClass = lhs.getClass();
    Class rhsClass = rhs.getClass();
    Class testClass;
    if (lhsClass.isInstance(rhs)) {
        testClass = lhsClass;
        if (!rhsClass.isInstance(lhs)) {
            // rhsClass is a subclass of lhsClass
            testClass = rhsClass;
        }
    } else if (rhsClass.isInstance(lhs)) {
        testClass = rhsClass;
        if (!lhsClass.isInstance(rhs)) {
            // lhsClass is a subclass of rhsClass
            testClass = lhsClass;
        }
    } else {
        // The two classes are not related.
        return false;
    }
    EqualsBuilder equalsBuilder = new EqualsBuilder();
    try {
        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);
        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {
            testClass = testClass.getSuperclass();
            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);
        }
    } catch (IllegalArgumentException e) {
        // In this case, we tried to test a subclass vs. a superclass and
        // the subclass has ivars or the ivars are transient and
        // we are testing transients.
        // If a subclass has ivars that we are trying to test them, we get an
        // exception and we know that the objects are not equal.
        return false;
    }
    return equalsBuilder.isEquals();
}","public void test099158() throws Throwable {
    Class<String> class0 = String.class;
    String[] stringArray0 = new String[2];
    boolean boolean0 = EqualsBuilder.reflectionEquals((Object) ""Index: "", (Object) ""Index: "", true, (Class) class0, stringArray0);
    assertTrue(boolean0);
}","/**
 * <p>This method uses reflection to determine if the two <code>Object</code>s
 * are equal.</p>
 *
 * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private
 * fields. This means that it will throw a security exception if run under
 * a security manager, if the permissions are not set up correctly. It is also
 * not as efficient as testing explicitly.</p>
 *
 * <p>If the testTransients parameter is set to <code>true</code>, transient
 * members will be tested, otherwise they are ignored, as they are likely
 * derived fields, and not part of the value of the <code>Object</code>.</p>
 *
 * <p>Static fields will not be included. Superclass fields will be appended
 * up to and including the specified superclass. A null superclass is treated
 * as java.lang.Object.</p>
 *
 * @param lhs  <code>this</code> object
 * @param rhs  the other object
 * @param testTransients  whether to include transient fields
 * @param reflectUpToClass  the superclass to reflect up to (inclusive),
 *  may be <code>null</code>
 * @param excludeFields  array of field names to exclude from testing
 * @return <code>true</code> if the two Objects have tested equals.
 * @since 2.0
 */"
"public static boolean reflectionEquals(Object lhs, Object rhs, String[] excludeFields) {
    return reflectionEquals(lhs, rhs, false, null, excludeFields);
}","public void test100159() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    String[] stringArray0 = new String[5];
    boolean boolean0 = EqualsBuilder.reflectionEquals((Object) equalsBuilder0, (Object) ""org.apache.commons.lang.builder.ToStringStyle$DefaultToStringStyle"", stringArray0);
    assertFalse(boolean0);
}","/**
 * <p>This method uses reflection to determine if the two <code>Object</code>s
 * are equal.</p>
 *
 * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private
 * fields. This means that it will throw a security exception if run under
 * a security manager, if the permissions are not set up correctly. It is also
 * not as efficient as testing explicitly.</p>
 *
 * <p>Transient members will be not be tested, as they are likely derived
 * fields, and not part of the value of the Object.</p>
 *
 * <p>Static fields will not be tested. Superclass fields will be included.</p>
 *
 * @param lhs  <code>this</code> object
 * @param rhs  the other object
 * @param excludeFields  array of field names to exclude from testing
 * @return <code>true</code> if the two Objects have tested equals.
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test100160() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    String[] stringArray0 = new String[5];
    boolean boolean0 = EqualsBuilder.reflectionEquals((Object) equalsBuilder0, (Object) ""org.apache.commons.lang.builder.ToStringStyle$DefaultToStringStyle"", stringArray0);
    assertTrue(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class reflectUpToClass, String[] excludeFields) {
    if (lhs == rhs) {
        return true;
    }
    if (lhs == null || rhs == null) {
        return false;
    }
    // Find the leaf class since there may be transients in the leaf
    // class or in classes between the leaf and root.
    // If we are not testing transients or a subclass has no ivars,
    // then a subclass can test equals to a superclass.
    Class lhsClass = lhs.getClass();
    Class rhsClass = rhs.getClass();
    Class testClass;
    if (lhsClass.isInstance(rhs)) {
        testClass = lhsClass;
        if (!rhsClass.isInstance(lhs)) {
            // rhsClass is a subclass of lhsClass
            testClass = rhsClass;
        }
    } else if (rhsClass.isInstance(lhs)) {
        testClass = rhsClass;
        if (!lhsClass.isInstance(rhs)) {
            // lhsClass is a subclass of rhsClass
            testClass = lhsClass;
        }
    } else {
        // The two classes are not related.
        return false;
    }
    EqualsBuilder equalsBuilder = new EqualsBuilder();
    try {
        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);
        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {
            testClass = testClass.getSuperclass();
            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);
        }
    } catch (IllegalArgumentException e) {
        // In this case, we tried to test a subclass vs. a superclass and
        // the subclass has ivars or the ivars are transient and
        // we are testing transients.
        // If a subclass has ivars that we are trying to test them, we get an
        // exception and we know that the objects are not equal.
        return false;
    }
    return equalsBuilder.isEquals();
}","public void test101161() throws Throwable {
    Object object0 = new Object();
    Class<Object> class0 = Object.class;
    String[] stringArray0 = new String[1];
    boolean boolean0 = EqualsBuilder.reflectionEquals(object0, (Object) null, false, class0, stringArray0);
    assertFalse(boolean0);
}","/**
 * <p>This method uses reflection to determine if the two <code>Object</code>s
 * are equal.</p>
 *
 * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private
 * fields. This means that it will throw a security exception if run under
 * a security manager, if the permissions are not set up correctly. It is also
 * not as efficient as testing explicitly.</p>
 *
 * <p>If the testTransients parameter is set to <code>true</code>, transient
 * members will be tested, otherwise they are ignored, as they are likely
 * derived fields, and not part of the value of the <code>Object</code>.</p>
 *
 * <p>Static fields will not be included. Superclass fields will be appended
 * up to and including the specified superclass. A null superclass is treated
 * as java.lang.Object.</p>
 *
 * @param lhs  <code>this</code> object
 * @param rhs  the other object
 * @param testTransients  whether to include transient fields
 * @param reflectUpToClass  the superclass to reflect up to (inclusive),
 *  may be <code>null</code>
 * @param excludeFields  array of field names to exclude from testing
 * @return <code>true</code> if the two Objects have tested equals.
 * @since 2.0
 */"
"public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class reflectUpToClass, String[] excludeFields) {
    if (lhs == rhs) {
        return true;
    }
    if (lhs == null || rhs == null) {
        return false;
    }
    // Find the leaf class since there may be transients in the leaf
    // class or in classes between the leaf and root.
    // If we are not testing transients or a subclass has no ivars,
    // then a subclass can test equals to a superclass.
    Class lhsClass = lhs.getClass();
    Class rhsClass = rhs.getClass();
    Class testClass;
    if (lhsClass.isInstance(rhs)) {
        testClass = lhsClass;
        if (!rhsClass.isInstance(lhs)) {
            // rhsClass is a subclass of lhsClass
            testClass = rhsClass;
        }
    } else if (rhsClass.isInstance(lhs)) {
        testClass = rhsClass;
        if (!lhsClass.isInstance(rhs)) {
            // lhsClass is a subclass of rhsClass
            testClass = lhsClass;
        }
    } else {
        // The two classes are not related.
        return false;
    }
    EqualsBuilder equalsBuilder = new EqualsBuilder();
    try {
        reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);
        while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {
            testClass = testClass.getSuperclass();
            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);
        }
    } catch (IllegalArgumentException e) {
        // In this case, we tried to test a subclass vs. a superclass and
        // the subclass has ivars or the ivars are transient and
        // we are testing transients.
        // If a subclass has ivars that we are trying to test them, we get an
        // exception and we know that the objects are not equal.
        return false;
    }
    return equalsBuilder.isEquals();
}","public void test102162() throws Throwable {
    Class<String> class0 = String.class;
    String[] stringArray0 = new String[2];
    boolean boolean0 = EqualsBuilder.reflectionEquals((Object) null, (Object) ""Index: "", true, (Class) class0, stringArray0);
    assertFalse(boolean0);
}","/**
 * <p>This method uses reflection to determine if the two <code>Object</code>s
 * are equal.</p>
 *
 * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private
 * fields. This means that it will throw a security exception if run under
 * a security manager, if the permissions are not set up correctly. It is also
 * not as efficient as testing explicitly.</p>
 *
 * <p>If the testTransients parameter is set to <code>true</code>, transient
 * members will be tested, otherwise they are ignored, as they are likely
 * derived fields, and not part of the value of the <code>Object</code>.</p>
 *
 * <p>Static fields will not be included. Superclass fields will be appended
 * up to and including the specified superclass. A null superclass is treated
 * as java.lang.Object.</p>
 *
 * @param lhs  <code>this</code> object
 * @param rhs  the other object
 * @param testTransients  whether to include transient fields
 * @param reflectUpToClass  the superclass to reflect up to (inclusive),
 *  may be <code>null</code>
 * @param excludeFields  array of field names to exclude from testing
 * @return <code>true</code> if the two Objects have tested equals.
 * @since 2.0
 */"
"public static boolean reflectionEquals(Object lhs, Object rhs, Collection /*String*/
excludeFields) {
    return reflectionEquals(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));
}","public void test103163() throws Throwable {
    Object object0 = new Object();
    Object object1 = new Object();
    LinkedList<String> linkedList0 = new LinkedList<String>();
    boolean boolean0 = EqualsBuilder.reflectionEquals(object0, object1, (Collection) linkedList0);
    assertTrue(boolean0);
}","/**
 * <p>This method uses reflection to determine if the two <code>Object</code>s
 * are equal.</p>
 *
 * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private
 * fields. This means that it will throw a security exception if run under
 * a security manager, if the permissions are not set up correctly. It is also
 * not as efficient as testing explicitly.</p>
 *
 * <p>Transient members will be not be tested, as they are likely derived
 * fields, and not part of the value of the Object.</p>
 *
 * <p>Static fields will not be tested. Superclass fields will be included.</p>
 *
 * @param lhs  <code>this</code> object
 * @param rhs  the other object
 * @param excludeFields  Collection of String field names to exclude from testing
 * @return <code>true</code> if the two Objects have tested equals.
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test104165() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    long[] longArray0 = new long[2];
    equalsBuilder0.append((long[]) null, longArray0);
    assertFalse(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
"public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients) {
    return reflectionEquals(lhs, rhs, testTransients, null, null);
}","public void test105166() throws Throwable {
    Object object0 = new Object();
    Integer integer0 = new Integer((-2145552456));
    boolean boolean0 = EqualsBuilder.reflectionEquals(object0, (Object) integer0, false);
    assertFalse(boolean0);
}","/**
 * <p>This method uses reflection to determine if the two <code>Object</code>s
 * are equal.</p>
 *
 * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private
 * fields. This means that it will throw a security exception if run under
 * a security manager, if the permissions are not set up correctly. It is also
 * not as efficient as testing explicitly.</p>
 *
 * <p>If the TestTransients parameter is set to <code>true</code>, transient
 * members will be tested, otherwise they are ignored, as they are likely
 * derived fields, and not part of the value of the <code>Object</code>.</p>
 *
 * <p>Static fields will not be tested. Superclass fields will be included.</p>
 *
 * @param lhs  <code>this</code> object
 * @param rhs  the other object
 * @param testTransients  whether to include transient fields
 * @return <code>true</code> if the two Objects have tested equals.
 */"
"public static boolean reflectionEquals(Object lhs, Object rhs, Collection /*String*/
excludeFields) {
    return reflectionEquals(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));
}","public void test106167() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    Object object0 = new Object();
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    boolean boolean0 = EqualsBuilder.reflectionEquals((Object) equalsBuilder0, object0, (Collection) linkedList0);
    assertFalse(boolean0);
}","/**
 * <p>This method uses reflection to determine if the two <code>Object</code>s
 * are equal.</p>
 *
 * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private
 * fields. This means that it will throw a security exception if run under
 * a security manager, if the permissions are not set up correctly. It is also
 * not as efficient as testing explicitly.</p>
 *
 * <p>Transient members will be not be tested, as they are likely derived
 * fields, and not part of the value of the Object.</p>
 *
 * <p>Static fields will not be tested. Superclass fields will be included.</p>
 *
 * @param lhs  <code>this</code> object
 * @param rhs  the other object
 * @param excludeFields  Collection of String field names to exclude from testing
 * @return <code>true</code> if the two Objects have tested equals.
 */"
"public boolean isEquals() {
    return this.isEquals;
}","public void test106168() throws Throwable {
    EqualsBuilder equalsBuilder0 = new EqualsBuilder();
    Object object0 = new Object();
    LinkedList<Object> linkedList0 = new LinkedList<Object>();
    boolean boolean0 = EqualsBuilder.reflectionEquals((Object) equalsBuilder0, object0, (Collection) linkedList0);
    assertTrue(equalsBuilder0.isEquals());
}","/**
 * <p>Returns <code>true</code> if the fields that have been checked
 * are all equal.</p>
 *
 * @return boolean
 */"
