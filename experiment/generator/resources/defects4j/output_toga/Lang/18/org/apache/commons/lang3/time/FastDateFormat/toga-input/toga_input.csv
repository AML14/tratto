focal_method,test_prefix,docstring
"//-----------------------------------------------------------------------
/**
 * <p>Gets the time zone display name, using a cache for performance.</p>
 *
 * @param tz  the zone to query
 * @param daylight  true if daylight savings
 * @param style  the style to use {@code TimeZone.LONG} or {@code TimeZone.SHORT}
 * @param locale  the locale to use
 * @return the textual name of the time zone
 */
static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {
    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);
    String value = cTimeZoneDisplayCache.get(key);
    if (value == null) {
        // This is a very slow call, so cache the results.
        value = tz.getDisplayName(daylight, style, locale);
        String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);
        if (prior != null) {
            value = prior;
        }
    }
    return value;
}","public void test009() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""a3i%lC&UrL#\""u8FX"");
    Locale locale0 = Locale.ENGLISH;
    // Undeclared exception!
    try {
        FastDateFormat.getTimeZoneDisplay(timeZone0, true, (-13), locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal style: -13
        //
        verifyException(""java.util.TimeZone"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Gets the time zone display name, using a cache for performance.</p>
 *
 * @param tz  the zone to query
 * @param daylight  true if daylight savings
 * @param style  the style to use {@code TimeZone.LONG} or {@code TimeZone.SHORT}
 * @param locale  the locale to use
 * @return the textual name of the time zone
 */
static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {
    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);
    String value = cTimeZoneDisplayCache.get(key);
    if (value == null) {
        // This is a very slow call, so cache the results.
        value = tz.getDisplayName(daylight, style, locale);
        String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);
        if (prior != null) {
            value = prior;
        }
    }
    return value;
}","public void test0119() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""a3i%lC&UrL#\""u8FX"");
    Locale locale0 = Locale.ENGLISH;
    String string0 = FastDateFormat.getTimeZoneDisplay(timeZone0, true, 0, locale0);
    assertEquals(""GMT"", string0);
}",""
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0252() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone((-237), ""}63CIv2"");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0, locale0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0253() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone((-237), ""}63CIv2"");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0, locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    return cache.getInstance(pattern, timeZone, locale);
}","public void test0254() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone((-237), ""}63CIv2"");
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0, locale0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or {@code null}
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0359() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""H,'-ra^I)"", (TimeZone) null);
    assertEquals(11, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0360() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""H,'-ra^I)"", (TimeZone) null);
    assertEquals(""H,'-ra^I)"", fastDateFormat0.getPattern());
}",""
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return cache.getInstance(pattern, timeZone, null);
}","public void test0361() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""H,'-ra^I)"", (TimeZone) null);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0479() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""|"", locale0);
    assertEquals(1, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0480() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""|"", locale0);
    assertEquals(""|"", fastDateFormat0.getPattern());
}",""
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return cache.getInstance(pattern, null, locale);
}","public void test0481() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""|"", locale0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0586() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""h:mm a"");
    assertEquals(10, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0587() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""h:mm a"");
    assertEquals(""h:mm a"", fastDateFormat0.getPattern());
}",""
"public static FastDateFormat getInstance(String pattern) {
    return cache.getInstance(pattern, null, null);
}","public void test0588() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""h:mm a"");
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test06100() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(2, ""z@9R#W8%Q&dA}l\"""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(2, (TimeZone) simpleTimeZone0);
    assertEquals(""MMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test06101() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(2, ""z@9R#W8%Q&dA}l\"""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(2, (TimeZone) simpleTimeZone0);
    assertEquals(14, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {
    return cache.getDateTimeInstance(style, null, timeZone, null);
}","public void test06102() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(2, ""z@9R#W8%Q&dA}l\"""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(2, (TimeZone) simpleTimeZone0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test07107() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test07108() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Gets a formatter instance using the default pattern in the
 * default locale.</p>
 *
 * @return a date/time formatter
 */
public static FastDateFormat getInstance() {
    return cache.getDateTimeInstance(SHORT, SHORT, null, null);
}","public void test07109() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    assertEquals(0, FastDateFormat.FULL);
}",""
"public StringBuffer format(Date date, StringBuffer buf) {
    // hard code GregorianCalendar
    Calendar c = new GregorianCalendar(mTimeZone, mLocale);
    c.setTime(date);
    return applyRules(c, buf);
}","public void test07118() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    StringBuffer stringBuffer0 = new StringBuffer();
    MockDate mockDate0 = new MockDate(2, 90, 3, 58, 1, 2623);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertSame(stringBuffer0, stringBuffer1);
}","/**
 * <p>Formats a {@code Date} object into the
 * supplied {@code StringBuffer} using a {@code GregorianCalendar}.</p>
 *
 * @param date  the date to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test07120() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    StringBuffer stringBuffer0 = new StringBuffer();
    MockDate mockDate0 = new MockDate(2, 90, 3, 58, 1, 2623);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test07121() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    StringBuffer stringBuffer0 = new StringBuffer();
    MockDate mockDate0 = new MockDate(2, 90, 3, 58, 1, 2623);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test07124() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    StringBuffer stringBuffer0 = new StringBuffer();
    MockDate mockDate0 = new MockDate(2, 90, 3, 58, 1, 2623);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertEquals(""Mon Jul 05 10:44:43 GMT 1909"", mockDate0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test08132() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test08133() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static FastDateFormat getInstance(String pattern) {
    return cache.getInstance(pattern, null, null);
}","public void test08134() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public String format(Date date) {
    // hard code GregorianCalendar
    Calendar c = new GregorianCalendar(mTimeZone, mLocale);
    c.setTime(date);
    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test08140() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    MockDate mockDate0 = new MockDate((-845), 1, 2605, 2605, 13, 1);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals("""", string0);
}","/**
 * <p>Formats a {@code Date} object using a {@code GregorianCalendar}.</p>
 *
 * @param date  the date to format
 * @return the formatted string
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test08141() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    MockDate mockDate0 = new MockDate((-845), 1, 2605, 2605, 13, 1);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test08142() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    MockDate mockDate0 = new MockDate((-845), 1, 2605, 2605, 13, 1);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test08143() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    MockDate mockDate0 = new MockDate((-845), 1, 2605, 2605, 13, 1);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals(""Sat Jul 06 13:13:01 GMT 1062"", mockDate0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test09152() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test09153() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return cache.getInstance(pattern, timeZone, null);
}","public void test09154() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public String format(Calendar calendar) {
    return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test09159() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    String string0 = fastDateFormat0.format((Calendar) null);
    assertEquals("""", string0);
}","/**
 * <p>Formats a {@code Calendar} object.</p>
 *
 * @param calendar  the calendar to format
 * @return the formatted string
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test09161() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    String string0 = fastDateFormat0.format((Calendar) null);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test09162() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0);
    String string0 = fastDateFormat0.format((Calendar) null);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"// Format methods
//-----------------------------------------------------------------------
/**
 * <p>Formats a {@code Date}, {@code Calendar} or
 * {@code Long} (milliseconds) object.</p>
 *
 * @param obj  the object to format
 * @param toAppendTo  the buffer to append to
 * @param pos  the position - ignored
 * @return the buffer passed in
 */
@Override
public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
    if (obj instanceof Date) {
        return format((Date) obj, toAppendTo);
    } else if (obj instanceof Calendar) {
        return format((Calendar) obj, toAppendTo);
    } else if (obj instanceof Long) {
        return format(((Long) obj).longValue(), toAppendTo);
    } else {
        throw new IllegalArgumentException(""Unknown class: "" + (obj == null ? ""<null>"" : obj.getClass().getName()));
    }
}","public void test10190() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    StringBuffer stringBuffer0 = new StringBuffer();
    Locale locale0 = Locale.TAIWAN;
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(locale0);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 2);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Object) mockGregorianCalendar0, stringBuffer0, fieldPosition0);
    assertSame(stringBuffer0, stringBuffer1);
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test10192() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    StringBuffer stringBuffer0 = new StringBuffer();
    Locale locale0 = Locale.TAIWAN;
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(locale0);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 2);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Object) mockGregorianCalendar0, stringBuffer0, fieldPosition0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test10193() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    StringBuffer stringBuffer0 = new StringBuffer();
    Locale locale0 = Locale.TAIWAN;
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(locale0);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 2);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Object) mockGregorianCalendar0, stringBuffer0, fieldPosition0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test10202() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    StringBuffer stringBuffer0 = new StringBuffer();
    Locale locale0 = Locale.TAIWAN;
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(locale0);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 2);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Object) mockGregorianCalendar0, stringBuffer0, fieldPosition0);
    assertEquals(""org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=1392409281320,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\""GMT\"",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2014,MONTH=1,WEEK_OF_YEAR=7,WEEK_OF_MONTH=3,DAY_OF_MONTH=14,DAY_OF_YEAR=45,DAY_OF_WEEK=6,DAY_OF_WEEK_IN_MONTH=2,AM_PM=1,HOUR=8,HOUR_OF_DAY=20,MINUTE=21,SECOND=21,MILLISECOND=320,ZONE_OFFSET=0,DST_OFFSET=0]"", mockGregorianCalendar0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public StringBuffer format(long millis, StringBuffer buf) {
    return format(new Date(millis), buf);
}","public void test11226() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    StringBuffer stringBuffer0 = new StringBuffer();
    StringBuffer stringBuffer1 = fastDateFormat0.format(0L, stringBuffer0);
    assertSame(stringBuffer0, stringBuffer1);
}","/**
 * <p>Formats a milliseond {@code long} value into the
 * supplied {@code StringBuffer}.</p>
 *
 * @param millis  the millisecond value to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 * @since 2.1
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test11228() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    StringBuffer stringBuffer0 = new StringBuffer();
    StringBuffer stringBuffer1 = fastDateFormat0.format(0L, stringBuffer0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test11229() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    StringBuffer stringBuffer0 = new StringBuffer();
    StringBuffer stringBuffer1 = fastDateFormat0.format(0L, stringBuffer0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test12252() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test12253() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return cache.getInstance(pattern, null, locale);
}","public void test12254() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public String format(long millis) {
    return format(new Date(millis));
}","public void test12259() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    String string0 = fastDateFormat0.format(1L);
    assertEquals("""", string0);
}","/**
 * <p>Formats a millisecond {@code long} value.</p>
 *
 * @param millis  the millisecond value to format
 * @return the formatted string
 * @since 2.1
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test12266() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    String string0 = fastDateFormat0.format(1L);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test12267() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    String string0 = fastDateFormat0.format(1L);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test13286() throws Throwable {
    Locale locale0 = Locale.GERMAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test13287() throws Throwable {
    Locale locale0 = Locale.GERMAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return cache.getInstance(pattern, null, locale);
}","public void test13288() throws Throwable {
    Locale locale0 = Locale.GERMAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a formatter instance using the default pattern in the
 * default locale.</p>
 *
 * @return a date/time formatter
 */
public static FastDateFormat getInstance() {
    return cache.getDateTimeInstance(SHORT, SHORT, null, null);
}","public void test13297() throws Throwable {
    Locale locale0 = Locale.GERMAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    Calendar calendar0 = MockCalendar.getInstance();
    assertNotNull(calendar0);
}",""
"protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {
    for (Rule rule : mRules) {
        rule.appendTo(buf, calendar);
    }
    return buf;
}","public void test13304() throws Throwable {
    Locale locale0 = Locale.GERMAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    Calendar calendar0 = MockCalendar.getInstance();
    StringWriter stringWriter0 = new StringWriter(87);
    StringBuffer stringBuffer0 = stringWriter0.getBuffer();
    StringBuffer stringBuffer1 = fastDateFormat0.applyRules(calendar0, stringBuffer0);
    assertSame(stringBuffer0, stringBuffer1);
}","/**
 * <p>Performs the formatting by applying the rules to the
 * specified calendar.</p>
 *
 * @param calendar  the calendar to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test13312() throws Throwable {
    Locale locale0 = Locale.GERMAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    Calendar calendar0 = MockCalendar.getInstance();
    StringWriter stringWriter0 = new StringWriter(87);
    StringBuffer stringBuffer0 = stringWriter0.getBuffer();
    StringBuffer stringBuffer1 = fastDateFormat0.applyRules(calendar0, stringBuffer0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test13313() throws Throwable {
    Locale locale0 = Locale.GERMAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    Calendar calendar0 = MockCalendar.getInstance();
    StringWriter stringWriter0 = new StringWriter(87);
    StringBuffer stringBuffer0 = stringWriter0.getBuffer();
    StringBuffer stringBuffer1 = fastDateFormat0.applyRules(calendar0, stringBuffer0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test14328() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0);
    assertEquals(31, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test14329() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0);
    assertEquals(""EEEE, MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Gets a date formatter instance using the specified style in the
 * default time zone and locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getDateInstance(int style) {
    return cache.getDateTimeInstance(style, null, null, null);
}","public void test14330() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0);
    assertEquals(0, FastDateFormat.FULL);
}",""
"protected String parseToken(String pattern, int[] indexRef) {
    StringBuilder buf = new StringBuilder();
    int i = indexRef[0];
    int length = pattern.length();
    char c = pattern.charAt(i);
    if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {
        // Scan a run of the same character, which indicates a time
        // pattern.
        buf.append(c);
        while (i + 1 < length) {
            char peek = pattern.charAt(i + 1);
            if (peek == c) {
                buf.append(c);
                i++;
            } else {
                break;
            }
        }
    } else {
        // This will identify token as text.
        buf.append('\'');
        boolean inLiteral = false;
        for (; i < length; i++) {
            c = pattern.charAt(i);
            if (c == '\'') {
                if (i + 1 < length && pattern.charAt(i + 1) == '\'') {
                    // '' is treated as escaped '
                    i++;
                    buf.append(c);
                } else {
                    inLiteral = !inLiteral;
                }
            } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {
                i--;
                break;
            } else {
                buf.append(c);
            }
        }
    }
    indexRef[0] = i;
    return buf.toString();
}","public void test14335() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0);
    int[] intArray0 = new int[4];
    // Undeclared exception!
    try {
        fastDateFormat0.parseToken("""", intArray0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * <p>Performs the parsing of tokens.</p>
 *
 * @param pattern  the pattern
 * @param indexRef  index references
 * @return parsed token
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test15349() throws Throwable {
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    assertEquals(""yyyy'\u5E74'M'\u6708'd'\u65E5' H'\u6642'mm'\u5206'ss'\u79D2' z"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test15350() throws Throwable {
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    assertEquals(29, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, Locale locale) {
    return cache.getDateTimeInstance(dateStyle, timeStyle, null, locale);
}","public void test15351() throws Throwable {
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a date/time formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */"
"protected String parseToken(String pattern, int[] indexRef) {
    StringBuilder buf = new StringBuilder();
    int i = indexRef[0];
    int length = pattern.length();
    char c = pattern.charAt(i);
    if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {
        // Scan a run of the same character, which indicates a time
        // pattern.
        buf.append(c);
        while (i + 1 < length) {
            char peek = pattern.charAt(i + 1);
            if (peek == c) {
                buf.append(c);
                i++;
            } else {
                break;
            }
        }
    } else {
        // This will identify token as text.
        buf.append('\'');
        boolean inLiteral = false;
        for (; i < length; i++) {
            c = pattern.charAt(i);
            if (c == '\'') {
                if (i + 1 < length && pattern.charAt(i + 1) == '\'') {
                    // '' is treated as escaped '
                    i++;
                    buf.append(c);
                } else {
                    inLiteral = !inLiteral;
                }
            } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {
                i--;
                break;
            } else {
                buf.append(c);
            }
        }
    }
    indexRef[0] = i;
    return buf.toString();
}","public void test15356() throws Throwable {
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    int[] intArray0 = new int[2];
    // Undeclared exception!
    try {
        fastDateFormat0.parseToken((String) null, intArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Performs the parsing of tokens.</p>
 *
 * @param pattern  the pattern
 * @param indexRef  index references
 * @return parsed token
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test16370() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, locale0);
    assertEquals(""yyyy'\uB144' M'\uC6D4' d'\uC77C' EEEE"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test16371() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, locale0);
    assertEquals(19, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static FastDateFormat getDateInstance(int style, Locale locale) {
    return cache.getDateTimeInstance(style, null, null, locale);
}","public void test16372() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, locale0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"protected String parseToken(String pattern, int[] indexRef) {
    StringBuilder buf = new StringBuilder();
    int i = indexRef[0];
    int length = pattern.length();
    char c = pattern.charAt(i);
    if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {
        // Scan a run of the same character, which indicates a time
        // pattern.
        buf.append(c);
        while (i + 1 < length) {
            char peek = pattern.charAt(i + 1);
            if (peek == c) {
                buf.append(c);
                i++;
            } else {
                break;
            }
        }
    } else {
        // This will identify token as text.
        buf.append('\'');
        boolean inLiteral = false;
        for (; i < length; i++) {
            c = pattern.charAt(i);
            if (c == '\'') {
                if (i + 1 < length && pattern.charAt(i + 1) == '\'') {
                    // '' is treated as escaped '
                    i++;
                    buf.append(c);
                } else {
                    inLiteral = !inLiteral;
                }
            } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {
                i--;
                break;
            } else {
                buf.append(c);
            }
        }
    }
    indexRef[0] = i;
    return buf.toString();
}","public void test16377() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, locale0);
    int[] intArray0 = new int[0];
    // Undeclared exception!
    try {
        fastDateFormat0.parseToken("""", intArray0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // 0
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Performs the parsing of tokens.</p>
 *
 * @param pattern  the pattern
 * @param indexRef  index references
 * @return parsed token
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets the time zone display name, using a cache for performance.</p>
 *
 * @param tz  the zone to query
 * @param daylight  true if daylight savings
 * @param style  the style to use {@code TimeZone.LONG} or {@code TimeZone.SHORT}
 * @param locale  the locale to use
 * @return the textual name of the time zone
 */
static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {
    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);
    String value = cTimeZoneDisplayCache.get(key);
    if (value == null) {
        // This is a very slow call, so cache the results.
        value = tz.getDisplayName(daylight, style, locale);
        String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);
        if (prior != null) {
            value = prior;
        }
    }
    return value;
}","public void test17385() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    // Undeclared exception!
    try {
        FastDateFormat.getTimeZoneDisplay((TimeZone) null, false, 0, locale0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}",""
"public static FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {
    return cache.getDateTimeInstance(null, style, timeZone, locale);
}","public void test18395() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.forLanguageTag("""");
    // Undeclared exception!
    try {
        FastDateFormat.getTimeInstance(1342, timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style 1342
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a time formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted time
 * @param locale  optional locale, overrides system locale
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 */"
"public static FastDateFormat getTimeInstance(int style, TimeZone timeZone) {
    return cache.getDateTimeInstance(null, style, timeZone, null);
}","public void test19402() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(2598, ""pl$GK}pCq!vdu)CCY]"");
    // Undeclared exception!
    try {
        FastDateFormat.getTimeInstance(15, (TimeZone) simpleTimeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style 15
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a time formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted time
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */"
"public static FastDateFormat getTimeInstance(int style, Locale locale) {
    return cache.getDateTimeInstance(null, style, null, locale);
}","public void test20410() throws Throwable {
    Locale locale0 = Locale.ITALIAN;
    // Undeclared exception!
    try {
        FastDateFormat.getTimeInstance(137, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style 137
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a time formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a time formatter instance using the specified style in the
 * default time zone and locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getTimeInstance(int style) {
    return cache.getDateTimeInstance(null, style, null, null);
}","public void test21411() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getTimeInstance(1437);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style 1437
        //
        verifyException(""java.text.DateFormat"", e);
    }
}",""
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    return cache.getInstance(pattern, timeZone, locale);
}","public void test22419() throws Throwable {
    Locale locale0 = Locale.forLanguageTag(""xc)7)F1UEw)DV[lb"");
    // Undeclared exception!
    try {
        FastDateFormat.getInstance((String) null, (TimeZone) null, locale0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // pattern must not be null
        //
        verifyException(""org.apache.commons.lang3.time.FormatCache"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or {@code null}
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return cache.getInstance(pattern, timeZone, null);
}","public void test23426() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""dy{;4>3.*"");
    // Undeclared exception!
    try {
        FastDateFormat.getInstance((String) null, (TimeZone) simpleTimeZone0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // pattern must not be null
        //
        verifyException(""org.apache.commons.lang3.time.FormatCache"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return cache.getInstance(pattern, null, locale);
}","public void test24434() throws Throwable {
    Locale locale0 = Locale.ENGLISH;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance((String) null, locale0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // pattern must not be null
        //
        verifyException(""org.apache.commons.lang3.time.FormatCache"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return cache.getInstance(pattern, null, null);
}","public void test25435() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // pattern must not be null
        //
        verifyException(""org.apache.commons.lang3.time.FormatCache"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone, Locale locale) {
    return cache.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale);
}","public void test26449() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(1314, ""No date time pattern for locale: "");
    Locale locale0 = Locale.KOREAN;
    // Undeclared exception!
    try {
        FastDateFormat.getDateTimeInstance(3, 830, (TimeZone) simpleTimeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style 830
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date/time formatter instance using the specified style,
 * time zone and locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 */"
"public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, Locale locale) {
    return cache.getDateTimeInstance(dateStyle, timeStyle, null, locale);
}","public void test27457() throws Throwable {
    Locale locale0 = Locale.ITALIAN;
    // Undeclared exception!
    try {
        FastDateFormat.getDateTimeInstance(6, 6, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style 6
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date/time formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a date/time formatter instance using the specified style
 * in the default time zone and locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle) {
    return cache.getDateTimeInstance(dateStyle, timeStyle, null, null);
}","public void test28458() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getDateTimeInstance((-761), (-761));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style -761
        //
        verifyException(""java.text.DateFormat"", e);
    }
}",""
"public static FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {
    return cache.getDateTimeInstance(style, null, timeZone, locale);
}","public void test29468() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    TimeZone timeZone0 = TimeZone.getTimeZone(""pattern must not be null"");
    // Undeclared exception!
    try {
        FastDateFormat.getDateInstance(1270, timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style 1270
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 */"
"public static FastDateFormat getDateInstance(int style, Locale locale) {
    return cache.getDateTimeInstance(style, null, null, locale);
}","public void test30476() throws Throwable {
    Locale locale0 = Locale.CANADA;
    // Undeclared exception!
    try {
        FastDateFormat.getDateInstance(92, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style 92
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a date formatter instance using the specified style in the
 * default time zone and locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getDateInstance(int style) {
    return cache.getDateTimeInstance(style, null, null, null);
}","public void test31477() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getDateInstance(3153);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style 3153
        //
        verifyException(""java.text.DateFormat"", e);
    }
}",""
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test32491() throws Throwable {
    Locale locale0 = Locale.ENGLISH;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, locale0);
    assertEquals(""h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test32492() throws Throwable {
    Locale locale0 = Locale.ENGLISH;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, locale0);
    assertEquals(17, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static FastDateFormat getTimeInstance(int style, Locale locale) {
    return cache.getDateTimeInstance(null, style, null, locale);
}","public void test32493() throws Throwable {
    Locale locale0 = Locale.ENGLISH;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, locale0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets a time formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */"
"public StringBuffer format(Date date, StringBuffer buf) {
    // hard code GregorianCalendar
    Calendar c = new GregorianCalendar(mTimeZone, mLocale);
    c.setTime(date);
    return applyRules(c, buf);
}","public void test32499() throws Throwable {
    Locale locale0 = Locale.ENGLISH;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, locale0);
    MockDate mockDate0 = new MockDate(0, 0, (-892), (-1777), 0);
    // Undeclared exception!
    try {
        fastDateFormat0.format((Date) mockDate0, (StringBuffer) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat$UnpaddedNumberField"", e);
    }
}","/**
 * <p>Formats a {@code Date} object into the
 * supplied {@code StringBuffer} using a {@code GregorianCalendar}.</p>
 *
 * @param date  the date to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"public String format(Date date) {
    // hard code GregorianCalendar
    Calendar c = new GregorianCalendar(mTimeZone, mLocale);
    c.setTime(date);
    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test33520() throws Throwable {
    Locale locale0 = Locale.GERMAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    // Undeclared exception!
    try {
        fastDateFormat0.format((Date) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.Calendar"", e);
    }
}","/**
 * <p>Formats a {@code Date} object using a {@code GregorianCalendar}.</p>
 *
 * @param date  the date to format
 * @return the formatted string
 */"
"public StringBuffer format(Calendar calendar, StringBuffer buf) {
    return applyRules(calendar, buf);
}","public void test34531() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""G(XT"");
    // Undeclared exception!
    try {
        fastDateFormat0.format((Calendar) null, stringBuffer0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat$UnpaddedMonthField"", e);
    }
}","/**
 * <p>Formats a {@code Calendar} object into the
 * supplied {@code StringBuffer}.</p>
 *
 * @param calendar  the calendar to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"public StringBuffer format(long millis, StringBuffer buf) {
    return format(new Date(millis), buf);
}","public void test35539() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    // Undeclared exception!
    try {
        fastDateFormat0.format((long) 43, (StringBuffer) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat$UnpaddedMonthField"", e);
    }
}","/**
 * <p>Formats a milliseond {@code long} value into the
 * supplied {@code StringBuffer}.</p>
 *
 * @param millis  the millisecond value to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 * @since 2.1
 */"
"protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {
    for (Rule rule : mRules) {
        rule.appendTo(buf, calendar);
    }
    return buf;
}","public void test36550() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    StringBuffer stringBuffer0 = new StringBuffer();
    // Undeclared exception!
    try {
        fastDateFormat0.applyRules((Calendar) null, stringBuffer0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat$UnpaddedMonthField"", e);
    }
}","/**
 * <p>Performs the formatting by applying the rules to the
 * specified calendar.</p>
 *
 * @param calendar  the calendar to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"// Constructor
//-----------------------------------------------------------------------
/**
 * <p>Constructs a new FastDateFormat.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible pattern
 * @param timeZone  non-null time zone to use
 * @param locale  non-null locale to use
 * @throws NullPointerException if pattern, timeZone, or locale is null.
 */
protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {
    mPattern = pattern;
    mTimeZone = timeZone;
    mLocale = locale;
    init();
}","public void test37553() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat0 = null;
    try {
        fastDateFormat0 = new FastDateFormat(""kzU*z"", timeZone0, (Locale) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"public StringBuffer format(Date date, StringBuffer buf) {
    // hard code GregorianCalendar
    Calendar c = new GregorianCalendar(mTimeZone, mLocale);
    c.setTime(date);
    return applyRules(c, buf);
}","public void test38565() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    MockDate mockDate0 = new MockDate((-2233), 2, 0);
    StringBuffer stringBuffer0 = new StringBuffer();
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertSame(stringBuffer0, stringBuffer1);
}","/**
 * <p>Formats a {@code Date} object into the
 * supplied {@code StringBuffer} using a {@code GregorianCalendar}.</p>
 *
 * @param date  the date to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test38567() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    MockDate mockDate0 = new MockDate((-2233), 2, 0);
    StringBuffer stringBuffer0 = new StringBuffer();
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test38568() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    MockDate mockDate0 = new MockDate((-2233), 2, 0);
    StringBuffer stringBuffer0 = new StringBuffer();
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test38569() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    MockDate mockDate0 = new MockDate((-2233), 2, 0);
    StringBuffer stringBuffer0 = new StringBuffer();
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertEquals(""Wed Feb 28 00:00:00 GMT 334"", mockDate0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public static FastDateFormat getTimeInstance(int style, TimeZone timeZone) {
    return cache.getDateTimeInstance(null, style, timeZone, null);
}","public void test39588() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(3, timeZone0);
    assertNotSame(fastDateFormat1, fastDateFormat0);
}","/**
 * <p>Gets a time formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted time
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test39590() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(3, timeZone0);
    assertEquals(10, fastDateFormat1.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test39591() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(3, timeZone0);
    assertEquals(""h:mm a"", fastDateFormat1.getPattern());
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return {@code true} if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale);
}","public void test39596() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(3, timeZone0);
    assertFalse(fastDateFormat1.equals((Object) fastDateFormat0));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return {@code true} if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale);
}","public void test39598() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(3, timeZone0);
    boolean boolean0 = fastDateFormat1.equals(fastDateFormat0);
    assertNotSame(fastDateFormat0, fastDateFormat1);
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test39601() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(3, timeZone0);
    boolean boolean0 = fastDateFormat1.equals(fastDateFormat0);
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test39602() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(3, timeZone0);
    boolean boolean0 = fastDateFormat1.equals(fastDateFormat0);
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test39604() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(3, timeZone0);
    boolean boolean0 = fastDateFormat1.equals(fastDateFormat0);
    assertEquals(10, fastDateFormat1.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test39605() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(3, timeZone0);
    boolean boolean0 = fastDateFormat1.equals(fastDateFormat0);
    assertEquals(""h:mm a"", fastDateFormat1.getPattern());
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return {@code true} if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale);
}","public void test39614() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(3, timeZone0);
    boolean boolean0 = fastDateFormat1.equals(fastDateFormat0);
    assertFalse(fastDateFormat0.equals((Object) fastDateFormat1));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return {@code true} if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale);
}","public void test39615() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat1 = FastDateFormat.getTimeInstance(3, timeZone0);
    boolean boolean0 = fastDateFormat1.equals(fastDateFormat0);
    assertFalse(fastDateFormat1.equals((Object) fastDateFormat0));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return {@code true} if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale);
}","public void test40623() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat0);
    assertTrue(boolean0);
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test40624() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat0);
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test40625() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat0);
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"// Format methods
//-----------------------------------------------------------------------
/**
 * <p>Formats a {@code Date}, {@code Calendar} or
 * {@code Long} (milliseconds) object.</p>
 *
 * @param obj  the object to format
 * @param toAppendTo  the buffer to append to
 * @param pos  the position - ignored
 * @return the buffer passed in
 */
@Override
public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
    if (obj instanceof Date) {
        return format((Date) obj, toAppendTo);
    } else if (obj instanceof Calendar) {
        return format((Calendar) obj, toAppendTo);
    } else if (obj instanceof Long) {
        return format(((Long) obj).longValue(), toAppendTo);
    } else {
        throw new IllegalArgumentException(""Unknown class: "" + (obj == null ? ""<null>"" : obj.getClass().getName()));
    }
}","public void test41645() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0);
    StringBuffer stringBuffer0 = new StringBuffer(2);
    FieldPosition fieldPosition0 = new FieldPosition(3);
    // Undeclared exception!
    try {
        fastDateFormat0.format((Object) null, stringBuffer0, fieldPosition0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unknown class: <null>
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}",""
"// Format methods
//-----------------------------------------------------------------------
/**
 * <p>Formats a {@code Date}, {@code Calendar} or
 * {@code Long} (milliseconds) object.</p>
 *
 * @param obj  the object to format
 * @param toAppendTo  the buffer to append to
 * @param pos  the position - ignored
 * @return the buffer passed in
 */
@Override
public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
    if (obj instanceof Date) {
        return format((Date) obj, toAppendTo);
    } else if (obj instanceof Calendar) {
        return format((Calendar) obj, toAppendTo);
    } else if (obj instanceof Long) {
        return format(((Long) obj).longValue(), toAppendTo);
    } else {
        throw new IllegalArgumentException(""Unknown class: "" + (obj == null ? ""<null>"" : obj.getClass().getName()));
    }
}","public void test42662() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    Long long0 = new Long(0);
    StringBuffer stringBuffer0 = new StringBuffer();
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 1084);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Object) long0, stringBuffer0, fieldPosition0);
    assertSame(stringBuffer0, stringBuffer1);
}",""
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test42664() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    Long long0 = new Long(0);
    StringBuffer stringBuffer0 = new StringBuffer();
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 1084);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Object) long0, stringBuffer0, fieldPosition0);
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test42665() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    Long long0 = new Long(0);
    StringBuffer stringBuffer0 = new StringBuffer();
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 1084);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Object) long0, stringBuffer0, fieldPosition0);
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Format methods
//-----------------------------------------------------------------------
/**
 * <p>Formats a {@code Date}, {@code Calendar} or
 * {@code Long} (milliseconds) object.</p>
 *
 * @param obj  the object to format
 * @param toAppendTo  the buffer to append to
 * @param pos  the position - ignored
 * @return the buffer passed in
 */
@Override
public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
    if (obj instanceof Date) {
        return format((Date) obj, toAppendTo);
    } else if (obj instanceof Calendar) {
        return format((Calendar) obj, toAppendTo);
    } else if (obj instanceof Long) {
        return format(((Long) obj).longValue(), toAppendTo);
    } else {
        throw new IllegalArgumentException(""Unknown class: "" + (obj == null ? ""<null>"" : obj.getClass().getName()));
    }
}","public void test43697() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    ParsePosition parsePosition0 = new ParsePosition(3);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""WoF"");
    FieldPosition fieldPosition0 = new FieldPosition(0);
    // Undeclared exception!
    try {
        fastDateFormat0.format((Object) parsePosition0, stringBuffer0, fieldPosition0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unknown class: java.text.ParsePosition
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}",""
"// Format methods
//-----------------------------------------------------------------------
/**
 * <p>Formats a {@code Date}, {@code Calendar} or
 * {@code Long} (milliseconds) object.</p>
 *
 * @param obj  the object to format
 * @param toAppendTo  the buffer to append to
 * @param pos  the position - ignored
 * @return the buffer passed in
 */
@Override
public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
    if (obj instanceof Date) {
        return format((Date) obj, toAppendTo);
    } else if (obj instanceof Calendar) {
        return format((Calendar) obj, toAppendTo);
    } else if (obj instanceof Long) {
        return format(((Long) obj).longValue(), toAppendTo);
    } else {
        throw new IllegalArgumentException(""Unknown class: "" + (obj == null ? ""<null>"" : obj.getClass().getName()));
    }
}","public void test44713() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate();
    StringBuffer stringBuffer0 = new StringBuffer(97);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Object) mockDate0, stringBuffer0, fieldPosition0);
    assertSame(stringBuffer0, stringBuffer1);
}",""
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test44715() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate();
    StringBuffer stringBuffer0 = new StringBuffer(97);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Object) mockDate0, stringBuffer0, fieldPosition0);
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test44716() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate();
    StringBuffer stringBuffer0 = new StringBuffer(97);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Object) mockDate0, stringBuffer0, fieldPosition0);
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test44717() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate();
    StringBuffer stringBuffer0 = new StringBuffer(97);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Object) mockDate0, stringBuffer0, fieldPosition0);
    assertEquals(""Fri Feb 14 20:21:21 GMT 2014"", mockDate0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"protected String parseToken(String pattern, int[] indexRef) {
    StringBuilder buf = new StringBuilder();
    int i = indexRef[0];
    int length = pattern.length();
    char c = pattern.charAt(i);
    if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {
        // Scan a run of the same character, which indicates a time
        // pattern.
        buf.append(c);
        while (i + 1 < length) {
            char peek = pattern.charAt(i + 1);
            if (peek == c) {
                buf.append(c);
                i++;
            } else {
                break;
            }
        }
    } else {
        // This will identify token as text.
        buf.append('\'');
        boolean inLiteral = false;
        for (; i < length; i++) {
            c = pattern.charAt(i);
            if (c == '\'') {
                if (i + 1 < length && pattern.charAt(i + 1) == '\'') {
                    // '' is treated as escaped '
                    i++;
                    buf.append(c);
                } else {
                    inLiteral = !inLiteral;
                }
            } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {
                i--;
                break;
            } else {
                buf.append(c);
            }
        }
    }
    indexRef[0] = i;
    return buf.toString();
}","public void test45737() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    int[] intArray0 = new int[9];
    String string0 = fastDateFormat0.parseToken(""United Kingdom"", intArray0);
    assertArrayEquals(new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0 }, intArray0);
}","/**
 * <p>Performs the parsing of tokens.</p>
 *
 * @param pattern  the pattern
 * @param indexRef  index references
 * @return parsed token
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test45740() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    int[] intArray0 = new int[9];
    String string0 = fastDateFormat0.parseToken(""United Kingdom"", intArray0);
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test45741() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    int[] intArray0 = new int[9];
    String string0 = fastDateFormat0.parseToken(""United Kingdom"", intArray0);
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test46771() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    String string0 = locale0.getScript();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(1, 0, timeZone0, locale0);
    assertEquals(""yyyy'\u5E74'M'\u6708'd'\u65E5' ahh'\u6642'mm'\u5206'ss'\u79D2' z"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test46772() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    String string0 = locale0.getScript();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(1, 0, timeZone0, locale0);
    assertEquals(29, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone, Locale locale) {
    return cache.getDateTimeInstance(dateStyle, timeStyle, timeZone, locale);
}","public void test46773() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    String string0 = locale0.getScript();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(1, 0, timeZone0, locale0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a date/time formatter instance using the specified style,
 * time zone and locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test46787() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    String string0 = locale0.getScript();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(1, 0, timeZone0, locale0);
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    assertEquals(""yyyy'\u5E74'M'\u6708'd'\u65E5' ahh'\u6642'mm'\u5206'ss'\u79D2' z"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test46788() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    String string0 = locale0.getScript();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(1, 0, timeZone0, locale0);
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    assertEquals(29, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test46789() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    String string0 = locale0.getScript();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(1, 0, timeZone0, locale0);
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    assertEquals(""yyyy'\u5E74'M'\u6708'd'\u65E5' ahh'\u6642'mm'\u5206'ss'\u79D2' z"", fastDateFormat1.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test46790() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    String string0 = locale0.getScript();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(1, 0, timeZone0, locale0);
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    assertEquals(29, fastDateFormat1.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return {@code true} if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale);
}","public void test46799() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    String string0 = locale0.getScript();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(1, 0, timeZone0, locale0);
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    assertTrue(fastDateFormat1.equals((Object) fastDateFormat0));
}",""
"public static FastDateFormat getTimeInstance(int style, Locale locale) {
    return cache.getDateTimeInstance(null, style, null, locale);
}","public void test46801() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    String string0 = locale0.getScript();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(1, 0, timeZone0, locale0);
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getTimeInstance(2, locale0);
    assertNotSame(fastDateFormat2, fastDateFormat0);
}","/**
 * <p>Gets a time formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test46809() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    String string0 = locale0.getScript();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(1, 0, timeZone0, locale0);
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getTimeInstance(2, locale0);
    assertEquals(11, fastDateFormat2.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test46810() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    String string0 = locale0.getScript();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(1, 0, timeZone0, locale0);
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getTimeInstance(2, locale0);
    assertEquals(""a hh:mm:ss"", fastDateFormat2.getPattern());
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return {@code true} if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale);
}","public void test46815() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    String string0 = locale0.getScript();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(1, 0, timeZone0, locale0);
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getTimeInstance(2, locale0);
    assertFalse(fastDateFormat2.equals((Object) fastDateFormat0));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return {@code true} if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale);
}","public void test46816() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    String string0 = locale0.getScript();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(1, 0, timeZone0, locale0);
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getTimeInstance(2, locale0);
    assertFalse(fastDateFormat2.equals((Object) fastDateFormat1));
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Gets a formatter instance using the default pattern in the
 * default locale.</p>
 *
 * @return a date/time formatter
 */
public static FastDateFormat getInstance() {
    return cache.getDateTimeInstance(SHORT, SHORT, null, null);
}","public void test46818() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    String string0 = locale0.getScript();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(1, 0, timeZone0, locale0);
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getTimeInstance(2, locale0);
    FastDateFormat fastDateFormat3 = FastDateFormat.getInstance();
    assertNotSame(fastDateFormat3, fastDateFormat0);
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test46821() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    String string0 = locale0.getScript();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(1, 0, timeZone0, locale0);
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getTimeInstance(2, locale0);
    FastDateFormat fastDateFormat3 = FastDateFormat.getInstance();
    assertEquals(21, fastDateFormat3.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test46822() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    String string0 = locale0.getScript();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(1, 0, timeZone0, locale0);
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getTimeInstance(2, locale0);
    FastDateFormat fastDateFormat3 = FastDateFormat.getInstance();
    assertEquals(""M/d/yy h:mm a"", fastDateFormat3.getPattern());
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return {@code true} if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale);
}","public void test46827() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    String string0 = locale0.getScript();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(1, 0, timeZone0, locale0);
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getTimeInstance(2, locale0);
    FastDateFormat fastDateFormat3 = FastDateFormat.getInstance();
    assertFalse(fastDateFormat3.equals((Object) fastDateFormat0));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return {@code true} if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale);
}","public void test46828() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    String string0 = locale0.getScript();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(1, 0, timeZone0, locale0);
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getTimeInstance(2, locale0);
    FastDateFormat fastDateFormat3 = FastDateFormat.getInstance();
    assertFalse(fastDateFormat3.equals((Object) fastDateFormat2));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return {@code true} if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale);
}","public void test46829() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    String string0 = locale0.getScript();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(1, 0, timeZone0, locale0);
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getTimeInstance(2, locale0);
    FastDateFormat fastDateFormat3 = FastDateFormat.getInstance();
    assertFalse(fastDateFormat3.equals((Object) fastDateFormat1));
}",""
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test47847() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test47848() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Constructor
//-----------------------------------------------------------------------
/**
 * <p>Constructs a new FastDateFormat.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible pattern
 * @param timeZone  non-null time zone to use
 * @param locale  non-null locale to use
 * @throws NullPointerException if pattern, timeZone, or locale is null.
 */
protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {
    mPattern = pattern;
    mTimeZone = timeZone;
    mLocale = locale;
    init();
}","public void test47849() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    assertEquals(3, FastDateFormat.SHORT);
}",""
"@Override
public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test47862() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    assertEquals(""FastDateFormat[]"", string1);
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test47870() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test47871() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test47878() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    assertEquals(0, int0);
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test47886() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test47887() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public TimeZone getTimeZone() {
    return mTimeZone;
}","public void test47892() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    assertSame(timeZone0, timeZone1);
}","/**
 * <p>Gets the time zone used by this formatter.</p>
 *
 * <p>This zone is always used for {@code Date} formatting. </p>
 *
 * @return the time zone
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test47901() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test47902() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test47919() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test47920() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test47921() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    assertEquals(0, fastDateFormat1.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test47922() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    assertEquals("""", fastDateFormat1.getPattern());
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return {@code true} if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale);
}","public void test47931() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    assertTrue(fastDateFormat1.equals((Object) fastDateFormat0));
}",""
"public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone) {
    return getDateTimeInstance(dateStyle, timeStyle, timeZone, null);
}","public void test47933() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(1, 0, timeZone1);
    assertSame(timeZone0, timeZone1);
}","/**
 * <p>Gets a date/time formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test47946() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(1, 0, timeZone1);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test47947() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(1, 0, timeZone1);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test47949() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(1, 0, timeZone1);
    assertEquals(38, fastDateFormat2.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test47950() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(1, 0, timeZone1);
    assertEquals(""MMMM d, yyyy h:mm:ss a z"", fastDateFormat2.getPattern());
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return {@code true} if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale);
}","public void test47959() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(1, 0, timeZone1);
    assertTrue(fastDateFormat0.equals((Object) fastDateFormat1));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return {@code true} if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale);
}","public void test47960() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(1, 0, timeZone1);
    assertFalse(fastDateFormat2.equals((Object) fastDateFormat0));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return {@code true} if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale);
}","public void test47961() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(1, 0, timeZone1);
    assertFalse(fastDateFormat2.equals((Object) fastDateFormat1));
}",""
"public static FastDateFormat getTimeInstance(int style, Locale locale) {
    return cache.getDateTimeInstance(null, style, null, locale);
}","public void test47963() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(1, 0, timeZone1);
    FastDateFormat fastDateFormat3 = FastDateFormat.getTimeInstance(2, locale0);
    assertNotSame(fastDateFormat3, fastDateFormat2);
}","/**
 * <p>Gets a time formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test47972() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(1, 0, timeZone1);
    FastDateFormat fastDateFormat3 = FastDateFormat.getTimeInstance(2, locale0);
    assertEquals(11, fastDateFormat3.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test47973() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(1, 0, timeZone1);
    FastDateFormat fastDateFormat3 = FastDateFormat.getTimeInstance(2, locale0);
    assertEquals(""a hh:mm:ss"", fastDateFormat3.getPattern());
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return {@code true} if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale);
}","public void test47978() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(1, 0, timeZone1);
    FastDateFormat fastDateFormat3 = FastDateFormat.getTimeInstance(2, locale0);
    assertFalse(fastDateFormat3.equals((Object) fastDateFormat2));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return {@code true} if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale);
}","public void test47979() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(1, 0, timeZone1);
    FastDateFormat fastDateFormat3 = FastDateFormat.getTimeInstance(2, locale0);
    assertFalse(fastDateFormat3.equals((Object) fastDateFormat1));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return {@code true} if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale);
}","public void test47980() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(1, 0, timeZone1);
    FastDateFormat fastDateFormat3 = FastDateFormat.getTimeInstance(2, locale0);
    assertFalse(fastDateFormat3.equals((Object) fastDateFormat0));
}",""
"public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone) {
    return getDateTimeInstance(dateStyle, timeStyle, timeZone, null);
}","public void test47982() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    String string0 = locale0.getScript();
    String string1 = fastDateFormat0.toString();
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    TimeZone timeZone1 = fastDateFormat0.getTimeZone();
    FastDateFormat fastDateFormat1 = (FastDateFormat) fastDateFormat0.clone();
    FastDateFormat fastDateFormat2 = FastDateFormat.getDateTimeInstance(1, 0, timeZone1);
    FastDateFormat fastDateFormat3 = FastDateFormat.getTimeInstance(2, locale0);
    // Undeclared exception!
    try {
        FastDateFormat.getDateTimeInstance((-5153), 0, timeZone1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style -5153
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date/time formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */"
"public static FastDateFormat getInstance(String pattern) {
    return cache.getInstance(pattern, null, null);
}","public void test48983() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""2vUxJS?<+8SQ/ZS"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: v
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    return cache.getInstance(pattern, timeZone, locale);
}","public void test49990() throws Throwable {
    Locale locale0 = new Locale(""rbcKCO;btHtobV3tIOd"");
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""rbcKCO;btHtobV3tIOd"", (TimeZone) null, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: r
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or {@code null}
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return cache.getInstance(pattern, null, locale);
}","public void test50998() throws Throwable {
    Locale locale0 = Locale.CANADA_FRENCH;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""3zq"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: q
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return cache.getInstance(pattern, null, null);
}","public void test51999() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""(mplnD"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: p
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return cache.getInstance(pattern, null, locale);
}","public void test521007() throws Throwable {
    Locale locale0 = Locale.CANADA;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""org.apache.commons.lang3.time.FastDateFormat$TimeZoneNumberRule"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: o
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return cache.getInstance(pattern, null, locale);
}","public void test531015() throws Throwable {
    Locale locale0 = Locale.FRENCH;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance("";Ml6wz"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: l
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return cache.getInstance(pattern, null, null);
}","public void test541016() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""giapponese"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: g
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    return cache.getInstance(pattern, timeZone, locale);
}","public void test551024() throws Throwable {
    Locale locale0 = Locale.US;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance("">fSxx"", (TimeZone) null, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: f
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or {@code null}
 */"
"public static FastDateFormat getInstance(String pattern) {
    return cache.getInstance(pattern, null, null);
}","public void test561025() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""c{Di8!]]p>|"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: c
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return cache.getInstance(pattern, timeZone, null);
}","public void test571032() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(1, ""HbP.1v0?>bzM"", 1, 1, 0, 1, 0, 0, 0, 956);
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""HbP.1v0?>bzM"", (TimeZone) simpleTimeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: b
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return cache.getInstance(pattern, null, null);
}","public void test581033() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""Wednesday, April 16, 0346 4:01:00 PM"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: e
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"// Constructor
//-----------------------------------------------------------------------
/**
 * <p>Constructs a new FastDateFormat.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible pattern
 * @param timeZone  non-null time zone to use
 * @param locale  non-null locale to use
 * @throws NullPointerException if pattern, timeZone, or locale is null.
 */
protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {
    mPattern = pattern;
    mTimeZone = timeZone;
    mLocale = locale;
    init();
}","public void test591043() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = null;
    try {
        fastDateFormat0 = new FastDateFormat("".H)`V"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: V
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}",""
"public static FastDateFormat getInstance(String pattern) {
    return cache.getInstance(pattern, null, null);
}","public void test601044() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""U Pf@n!++9`AT0]l?"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: U
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return cache.getInstance(pattern, null, locale);
}","public void test611052() throws Throwable {
    Locale locale0 = Locale.UK;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""%TKcuHDi?gj>n"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: T
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return cache.getInstance(pattern, null, null);
}","public void test621053() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""s:dSe.[_"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: e
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return cache.getInstance(pattern, null, locale);
}","public void test631061() throws Throwable {
    Locale locale0 = Locale.TAIWAN;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""Run?r}#/T=HiSX/:5"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: R
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return cache.getInstance(pattern, null, null);
}","public void test641062() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""11:59:59 PM"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: P
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return cache.getInstance(pattern, null, locale);
}","public void test651063() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""Ohs"", (Locale) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: O
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    return cache.getInstance(pattern, timeZone, locale);
}","public void test661067() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""No date time pattern for locale: "", timeZone0, (Locale) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: N
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or {@code null}
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return cache.getInstance(pattern, null, locale);
}","public void test671075() throws Throwable {
    Locale locale0 = Locale.GERMAN;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""LNFm7E%BIjN"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: L
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return cache.getInstance(pattern, null, locale);
}","public void test681083() throws Throwable {
    Locale locale0 = Locale.JAPANESE;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""4Ki^Y$-|AR[0?\""0"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: i
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return cache.getInstance(pattern, timeZone, null);
}","public void test691086() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""No date time pattern for locale: "");
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""JS@oDv3U,B "", timeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: J
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return cache.getInstance(pattern, null, null);
}","public void test701087() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""I"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: I
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return cache.getInstance(pattern, null, null);
}","public void test711088() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""G(XT"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: X
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    return cache.getInstance(pattern, timeZone, locale);
}","public void test721098() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""FastDateFormat[h:mm a]"");
    Locale locale0 = Locale.FRANCE;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""FastDateFormat[h:mm a]"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: t
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or {@code null}
 */"
"public static FastDateFormat getInstance(String pattern) {
    return cache.getInstance(pattern, null, null);
}","public void test731099() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""`yEj]PggJm<c[*}8F"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: j
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"// Constructor
//-----------------------------------------------------------------------
/**
 * <p>Constructs a new FastDateFormat.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible pattern
 * @param timeZone  non-null time zone to use
 * @param locale  non-null locale to use
 * @throws NullPointerException if pattern, timeZone, or locale is null.
 */
protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {
    mPattern = pattern;
    mTimeZone = timeZone;
    mLocale = locale;
    init();
}","public void test741100() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = null;
    try {
        fastDateFormat0 = new FastDateFormat(""M|BT^1J4O~QX"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: B
        //
        verifyException(""org.apache.commons.lang3.time.FastDateFormat"", e);
    }
}",""
"public String format(long millis) {
    return format(new Date(millis));
}","public void test751101() throws Throwable {
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    String string0 = fastDateFormat0.format((long) 42);
    assertEquals(""1970\u5E741\u67081\u65E5 0\u664200\u520600\u79D2 GMT"", string0);
}","/**
 * <p>Formats a millisecond {@code long} value.</p>
 *
 * @param millis  the millisecond value to format
 * @return the formatted string
 * @since 2.1
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test761102() throws Throwable {
    Locale locale0 = Locale.JAPANESE;
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""#,]@?B>:d+4"", 1, 0, 2, 0, 3, 2, 3, 2, 2);
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(3, (TimeZone) simpleTimeZone0, locale0);
    assertEquals(7, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test771103() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(1, 0);
    assertEquals(""MMMM d, yyyy h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public String format(Calendar calendar) {
    return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test781104() throws Throwable {
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(2, 3536, 42);
    String string0 = fastDateFormat0.format((Calendar) mockGregorianCalendar0);
    assertEquals(""0296\u5E7410\u670812\u65E5 0\u664200\u520600\u79D2 GMT"", string0);
}","/**
 * <p>Formats a {@code Calendar} object.</p>
 *
 * @param calendar  the calendar to format
 * @return the formatted string
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test791105() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    TimeZone timeZone0 = TimeZone.getTimeZone(""2014\uB144 2\uC6D4 14\uC77C \uAE08\uC694\uC77C"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, timeZone0, locale0);
    assertEquals(""yyyy'\uB144' M'\uC6D4' d'\uC77C' EEEE"", fastDateFormat0.getPattern());
}",""
"public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {
    return cache.getDateTimeInstance(style, null, timeZone, null);
}","public void test801106() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone((-900), """");
    // Undeclared exception!
    try {
        FastDateFormat.getDateInstance(1745, (TimeZone) simpleTimeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style 1745
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return {@code true} if equal
 */
@Override
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale);
}","public void test811107() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    Long long0 = new Long(1333L);
    boolean boolean0 = fastDateFormat0.equals(long0);
    assertFalse(boolean0);
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test821108() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    fastDateFormat0.hashCode();
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test841111() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    assertEquals(21, int0);
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test871115() throws Throwable {
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    fastDateFormat0.getLocale();
    assertEquals(29, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test881117() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    ParsePosition parsePosition0 = new ParsePosition((-503));
    fastDateFormat0.parseObject(""1/1/70 12:00 AM"", parsePosition0);
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test891118() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    String string0 = fastDateFormat0.getPattern();
    assertEquals(""M/d/yy h:mm a"", string0);
}",""
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    return cache.getInstance(pattern, timeZone, locale);
}","public void test901119() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    TimeZone timeZone0 = TimeZone.getTimeZone(""2014\uB144 2\uC6D4 14\uC77C \uAE08\uC694\uC77C"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""2014\uB144 2\uC6D4 14\uC77C \uAE08\uC694\uC77C"", timeZone0, locale0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or {@code null}
 */"
"public String format(Date date) {
    // hard code GregorianCalendar
    Calendar c = new GregorianCalendar(mTimeZone, mLocale);
    c.setTime(date);
    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test911120() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""1/1/70 12:00 AM"");
    Locale locale0 = Locale.ITALY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(3, 1, timeZone0, locale0);
    MockDate mockDate0 = new MockDate();
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals(""14/02/14 20.21.21 GMT"", string0);
}","/**
 * <p>Formats a {@code Date} object using a {@code GregorianCalendar}.</p>
 *
 * @param date  the date to format
 * @return the formatted string
 */"
