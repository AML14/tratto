focal_method,test_prefix,docstring
"public static Class<?> getClass(String className, boolean initialize) throws ClassNotFoundException {
    ClassLoader contextCL = Thread.currentThread().getContextClassLoader();
    ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;
    return getClass(loader, className, initialize);
}","public void test0000() throws Throwable {
    try {
        ClassUtils.getClass(""Object[]"", true);
        fail(""Expecting exception: ClassNotFoundException"");
    } catch (ClassNotFoundException e) {
    }
}","/**
 * Returns the class represented by <code>className</code> using the
 * current thread's context class loader. This implementation supports
 * names like ""<code>java.lang.String[]</code>"" as well as
 * ""<code>[Ljava.lang.String;</code>"".
 *
 * @param className  the class name
 * @param initialize  whether the class must be initialized
 * @return the class represented by <code>className</code> using the current thread's context class loader
 * @throws ClassNotFoundException if the class is not found
 */"
"public static String getShortClassName(String className) {
    if (className == null) {
        return StringUtils.EMPTY;
    }
    if (className.length() == 0) {
        return StringUtils.EMPTY;
    }
    StringBuilder arrayPrefix = new StringBuilder();
    // Handle array encoding
    if (className.startsWith(""["")) {
        while (className.charAt(0) == '[') {
            className = className.substring(1);
            arrayPrefix.append(""[]"");
        }
        // Strip Object type encoding
        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
            className = className.substring(1, className.length() - 1);
        }
    }
    if (reverseAbbreviationMap.containsKey(className)) {
        className = reverseAbbreviationMap.get(className);
    }
    int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);
    String out = className.substring(lastDotIdx + 1);
    if (innerIdx != -1) {
        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
    }
    return out + arrayPrefix;
}","public void test0011() throws Throwable {
    String string0 = ClassUtils.getShortClassName(""[:*|3>z24"");
    assertEquals("":*|3>z24[]"", string0);
}","/**
 * <p>Gets the class name minus the package name from a String.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 *
 * @param className  the className to get the short name for
 * @return the class name of the class without the package name or an empty string
 */"
"// Convert list
// ----------------------------------------------------------------------
/**
 * <p>Given a <code>List</code> of class names, this method converts them into classes.</p>
 *
 * <p>A new <code>List</code> is returned. If the class name cannot be found, <code>null</code>
 * is stored in the <code>List</code>. If the class name in the <code>List</code> is
 * <code>null</code>, <code>null</code> is stored in the output <code>List</code>.</p>
 *
 * @param classNames  the classNames to change
 * @return a <code>List</code> of Class objects corresponding to the class names,
 *  <code>null</code> if null input
 * @throws ClassCastException if classNames contains a non String entry
 */
public static List<Class<?>> convertClassNamesToClasses(List<String> classNames) {
    if (classNames == null) {
        return null;
    }
    List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size());
    for (String className : classNames) {
        try {
            classes.add(Class.forName(className));
        } catch (Exception ex) {
            classes.add(null);
        }
    }
    return classes;
}","public void test0022() throws Throwable {
    Class<Integer> class0 = Integer.class;
    List<Class<?>> list0 = ClassUtils.getAllInterfaces(class0);
    List<String> list1 = ClassUtils.convertClassesToClassNames(list0);
    List<Class<?>> list2 = ClassUtils.convertClassNamesToClasses(list1);
    assertNotNull(list2);
}",""
"public static Class<?> wrapperToPrimitive(Class<?> cls) {
    return wrapperPrimitiveMap.get(cls);
}","public void test0035() throws Throwable {
    Class<ClassUtils> class0 = ClassUtils.class;
    Class<?> class1 = ClassUtils.wrapperToPrimitive(class0);
    assertNull(class1);
}","/**
 * <p>Converts the specified wrapper class to its corresponding primitive
 * class.</p>
 *
 * <p>This method is the counter part of <code>primitiveToWrapper()</code>.
 * If the passed in class is a wrapper class for a primitive type, this
 * primitive type will be returned (e.g. <code>Integer.TYPE</code> for
 * <code>Integer.class</code>). For other classes, or if the parameter is
 * <b>null</b>, the return value is <b>null</b>.</p>
 *
 * @param cls the class to convert, may be <b>null</b>
 * @return the corresponding primitive type if <code>cls</code> is a
 * wrapper class, <b>null</b> otherwise
 * @see #primitiveToWrapper(Class)
 * @since 2.4
 */"
"// Is assignable
// ----------------------------------------------------------------------
/**
 * <p>Checks if an array of Classes can be assigned to another array of Classes.</p>
 *
 * <p>This method calls {@link #isAssignable(Class, Class) isAssignable} for each
 * Class pair in the input arrays. It can be used to check if a set of arguments
 * (the first parameter) are suitably compatible with a set of method parameter types
 * (the second parameter).</p>
 *
 * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this
 * method takes into account widenings of primitive classes and
 * <code>null</code>s.</p>
 *
 * <p>Primitive widenings allow an int to be assigned to a <code>long</code>,
 * <code>float</code> or <code>double</code>. This method returns the correct
 * result for these cases.</p>
 *
 * <p><code>Null</code> may be assigned to any reference type. This method will
 * return <code>true</code> if <code>null</code> is passed in and the toClass is
 * non-primitive.</p>
 *
 * <p>Specifically, this method tests whether the type represented by the
 * specified <code>Class</code> parameter can be converted to the type
 * represented by this <code>Class</code> object via an identity conversion
 * widening primitive or widening reference conversion. See
 * <em><a href=""http://java.sun.com/docs/books/jls/"">The Java Language Specification</a></em>,
 * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>
 *
 * <p><strong>Since Lang 3.0,</strong> this method will default behavior for
 * calculating assignability between primitive and wrapper types <em>corresponding
 * to the running Java version</em>; i.e. autoboxing will be the default
 * behavior in VMs running Java versions >= 1.5.</p>
 *
 * @param classArray  the array of Classes to check, may be <code>null</code>
 * @param toClassArray  the array of Classes to try to assign into, may be <code>null</code>
 * @return <code>true</code> if assignment possible
 */
public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray) {
    return isAssignable(classArray, toClassArray, SystemUtils.isJavaVersionAtLeast(1.5f));
}","public void test0046() throws Throwable {
    Class<String>[] classArray0 = (Class<String>[]) Array.newInstance(Class.class, 9);
    Class<String> class0 = String.class;
    classArray0[0] = class0;
    classArray0[1] = classArray0[0];
    classArray0[2] = classArray0[0];
    classArray0[3] = classArray0[1];
    classArray0[4] = classArray0[0];
    classArray0[5] = class0;
    classArray0[6] = class0;
    classArray0[7] = classArray0[4];
    classArray0[8] = classArray0[1];
    boolean boolean0 = ClassUtils.isAssignable(classArray0, classArray0);
    assertTrue(boolean0);
}",""
"// Short class name
// ----------------------------------------------------------------------
/**
 * <p>Gets the class name minus the package name for an <code>Object</code>.</p>
 *
 * @param object  the class to get the short name for, may be null
 * @param valueIfNull  the value to return if null
 * @return the class name of the object without the package name, or the null value
 */
public static String getShortClassName(Object object, String valueIfNull) {
    if (object == null) {
        return valueIfNull;
    }
    return getShortClassName(object.getClass());
}","public void test0057() throws Throwable {
    String string0 = ClassUtils.getShortClassName((Object) null, (String) null);
    assertNull(string0);
}",""
"// Short class name
// ----------------------------------------------------------------------
/**
 * <p>Gets the class name minus the package name for an <code>Object</code>.</p>
 *
 * @param object  the class to get the short name for, may be null
 * @param valueIfNull  the value to return if null
 * @return the class name of the object without the package name, or the null value
 */
public static String getShortClassName(Object object, String valueIfNull) {
    if (object == null) {
        return valueIfNull;
    }
    return getShortClassName(object.getClass());
}","public void test0068() throws Throwable {
    String string0 = ClassUtils.getShortClassName((Object) null, """");
    assertEquals("""", string0);
}",""
"// Short canonical name
// ----------------------------------------------------------------------
/**
 * <p>Gets the canonical name minus the package name for an <code>Object</code>.</p>
 *
 * @param object  the class to get the short name for, may be null
 * @param valueIfNull  the value to return if null
 * @return the canonical name of the object without the package name, or the null value
 * @since 2.4
 */
public static String getShortCanonicalName(Object object, String valueIfNull) {
    if (object == null) {
        return valueIfNull;
    }
    return getShortCanonicalName(object.getClass().getName());
}","public void test0079() throws Throwable {
    String string0 = ClassUtils.getShortCanonicalName((Object) null, (String) null);
    assertNull(string0);
}",""
"// Short canonical name
// ----------------------------------------------------------------------
/**
 * <p>Gets the canonical name minus the package name for an <code>Object</code>.</p>
 *
 * @param object  the class to get the short name for, may be null
 * @param valueIfNull  the value to return if null
 * @return the canonical name of the object without the package name, or the null value
 * @since 2.4
 */
public static String getShortCanonicalName(Object object, String valueIfNull) {
    if (object == null) {
        return valueIfNull;
    }
    return getShortCanonicalName(object.getClass().getName());
}","public void test00810() throws Throwable {
    String string0 = ClassUtils.getShortCanonicalName((Object) null, """");
    assertEquals("""", string0);
}",""
"// Package name
// ----------------------------------------------------------------------
/**
 * <p>Gets the package name of an <code>Object</code>.</p>
 *
 * @param object  the class to get the package name for, may be null
 * @param valueIfNull  the value to return if null
 * @return the package name of the object, or the null value
 */
public static String getPackageName(Object object, String valueIfNull) {
    if (object == null) {
        return valueIfNull;
    }
    return getPackageName(object.getClass());
}","public void test00911() throws Throwable {
    String string0 = ClassUtils.getPackageName((Object) null, (String) null);
    assertNull(string0);
}",""
"// Package name
// ----------------------------------------------------------------------
/**
 * <p>Gets the package name of an <code>Object</code>.</p>
 *
 * @param object  the class to get the package name for, may be null
 * @param valueIfNull  the value to return if null
 * @return the package name of the object, or the null value
 */
public static String getPackageName(Object object, String valueIfNull) {
    if (object == null) {
        return valueIfNull;
    }
    return getPackageName(object.getClass());
}","public void test01012() throws Throwable {
    String string0 = ClassUtils.getPackageName((Object) null, """");
    assertEquals("""", string0);
}",""
"public static String getPackageName(Class<?> cls) {
    if (cls == null) {
        return StringUtils.EMPTY;
    }
    return getPackageName(cls.getName());
}","public void test01113() throws Throwable {
    Class<Boolean> class0 = Boolean.class;
    String string0 = ClassUtils.getPackageName(class0);
    assertEquals(""java.lang"", string0);
}","/**
 * <p>Gets the package name of a <code>Class</code>.</p>
 *
 * @param cls  the class to get the package name for, may be <code>null</code>.
 * @return the package name or an empty string
 */"
"public static String getPackageCanonicalName(String canonicalName) {
    return ClassUtils.getPackageName(getCanonicalName(canonicalName));
}","public void test01214() throws Throwable {
    String string0 = ClassUtils.getPackageCanonicalName(""'; the SystemUtils property value will default to null."");
    assertEquals(""';theSystemUtilspropertyvaluewilldefaulttonull"", string0);
}","/**
 * <p>Gets the package name from the canonical name. </p>
 *
 * <p>The string passed in is assumed to be a canonical name - it is not checked.</p>
 * <p>If the class is unpackaged, return an empty string.</p>
 *
 * @param canonicalName  the canonical name to get the package name for, may be <code>null</code>
 * @return the package name or an empty string
 * @since 2.4
 */"
"public static String getPackageCanonicalName(Class<?> cls) {
    if (cls == null) {
        return StringUtils.EMPTY;
    }
    return getPackageCanonicalName(cls.getName());
}","public void test01315() throws Throwable {
    Class<Object> class0 = Object.class;
    String string0 = ClassUtils.getPackageCanonicalName(class0);
    assertEquals(""java.lang"", string0);
}","/**
 * <p>Gets the package name from the canonical name of a <code>Class</code>.</p>
 *
 * @param cls  the class to get the package name for, may be <code>null</code>.
 * @return the package name or an empty string
 * @since 2.4
 */"
"public static Class<?>[] toClass(Object[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return ArrayUtils.EMPTY_CLASS_ARRAY;
    }
    Class<?>[] classes = new Class[array.length];
    for (int i = 0; i < array.length; i++) {
        classes[i] = array[i].getClass();
    }
    return classes;
}","public void test02426() throws Throwable {
    Object[] objectArray0 = new Object[6];
    // Undeclared exception!
    try {
        ClassUtils.toClass(objectArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.ClassUtils"", e);
    }
}","/**
 * <p>Converts an array of <code>Object</code> in to an array of <code>Class</code> objects.
 * If any of these objects is null, a null element will be inserted into the array.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array an <code>Object</code> array
 * @return a <code>Class</code> array, <code>null</code> if null array input
 * @since 2.4
 */"
"public static String getShortClassName(String className) {
    if (className == null) {
        return StringUtils.EMPTY;
    }
    if (className.length() == 0) {
        return StringUtils.EMPTY;
    }
    StringBuilder arrayPrefix = new StringBuilder();
    // Handle array encoding
    if (className.startsWith(""["")) {
        while (className.charAt(0) == '[') {
            className = className.substring(1);
            arrayPrefix.append(""[]"");
        }
        // Strip Object type encoding
        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
            className = className.substring(1, className.length() - 1);
        }
    }
    if (reverseAbbreviationMap.containsKey(className)) {
        className = reverseAbbreviationMap.get(className);
    }
    int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);
    String out = className.substring(lastDotIdx + 1);
    if (innerIdx != -1) {
        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
    }
    return out + arrayPrefix;
}","public void test02527() throws Throwable {
    // Undeclared exception!
    try {
        ClassUtils.getShortClassName(""["");
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * <p>Gets the class name minus the package name from a String.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 *
 * @param className  the className to get the short name for
 * @return the class name of the class without the package name or an empty string
 */"
"// Public method
// ----------------------------------------------------------------------
/**
 * <p>Returns the desired Method much like <code>Class.getMethod</code>, however
 * it ensures that the returned Method is from a public class or interface and not
 * from an anonymous inner class. This means that the Method is invokable and
 * doesn't fall foul of Java bug
 * <a href=""http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4071957"">4071957</a>).
 *
 *  <code><pre>Set set = Collections.unmodifiableSet(...);
 *  Method method = ClassUtils.getPublicMethod(set.getClass(), ""isEmpty"",  new Class[0]);
 *  Object result = method.invoke(set, new Object[]);</pre></code>
 * </p>
 *
 * @param cls  the class to check, not null
 * @param methodName  the name of the method
 * @param parameterTypes  the list of parameters
 * @return the method
 * @throws NullPointerException if the class is null
 * @throws SecurityException if a a security violation occured
 * @throws NoSuchMethodException if the method is not found in the given class
 *  or if the metothod doen't conform with the requirements
 */
public static Method getPublicMethod(Class<?> cls, String methodName, Class<?>[] parameterTypes) throws SecurityException, NoSuchMethodException {
    Method declaredMethod = cls.getMethod(methodName, parameterTypes);
    if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) {
        return declaredMethod;
    }
    List<Class<?>> candidateClasses = new ArrayList<Class<?>>();
    candidateClasses.addAll(getAllInterfaces(cls));
    candidateClasses.addAll(getAllSuperclasses(cls));
    for (Class<?> candidateClass : candidateClasses) {
        if (!Modifier.isPublic(candidateClass.getModifiers())) {
            continue;
        }
        Method candidateMethod;
        try {
            candidateMethod = candidateClass.getMethod(methodName, parameterTypes);
        } catch (NoSuchMethodException ex) {
            continue;
        }
        if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) {
            return candidateMethod;
        }
    }
    throw new NoSuchMethodException(""Can't find a public method for "" + methodName + "" "" + ArrayUtils.toString(parameterTypes));
}","public void test02628() throws Throwable {
    Class<Double>[] classArray0 = (Class<Double>[]) Array.newInstance(Class.class, 5);
    Class<Object> class0 = Object.class;
    // Undeclared exception!
    try {
        ClassUtils.getPublicMethod(class0, (String) null, classArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"// Public method
// ----------------------------------------------------------------------
/**
 * <p>Returns the desired Method much like <code>Class.getMethod</code>, however
 * it ensures that the returned Method is from a public class or interface and not
 * from an anonymous inner class. This means that the Method is invokable and
 * doesn't fall foul of Java bug
 * <a href=""http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4071957"">4071957</a>).
 *
 *  <code><pre>Set set = Collections.unmodifiableSet(...);
 *  Method method = ClassUtils.getPublicMethod(set.getClass(), ""isEmpty"",  new Class[0]);
 *  Object result = method.invoke(set, new Object[]);</pre></code>
 * </p>
 *
 * @param cls  the class to check, not null
 * @param methodName  the name of the method
 * @param parameterTypes  the list of parameters
 * @return the method
 * @throws NullPointerException if the class is null
 * @throws SecurityException if a a security violation occured
 * @throws NoSuchMethodException if the method is not found in the given class
 *  or if the metothod doen't conform with the requirements
 */
public static Method getPublicMethod(Class<?> cls, String methodName, Class<?>[] parameterTypes) throws SecurityException, NoSuchMethodException {
    Method declaredMethod = cls.getMethod(methodName, parameterTypes);
    if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) {
        return declaredMethod;
    }
    List<Class<?>> candidateClasses = new ArrayList<Class<?>>();
    candidateClasses.addAll(getAllInterfaces(cls));
    candidateClasses.addAll(getAllSuperclasses(cls));
    for (Class<?> candidateClass : candidateClasses) {
        if (!Modifier.isPublic(candidateClass.getModifiers())) {
            continue;
        }
        Method candidateMethod;
        try {
            candidateMethod = candidateClass.getMethod(methodName, parameterTypes);
        } catch (NoSuchMethodException ex) {
            continue;
        }
        if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) {
            return candidateMethod;
        }
    }
    throw new NoSuchMethodException(""Can't find a public method for "" + methodName + "" "" + ArrayUtils.toString(parameterTypes));
}","public void test02729() throws Throwable {
    Class<Character>[] classArray0 = (Class<Character>[]) Array.newInstance(Class.class, 5);
    Class<ClassUtils> class0 = ClassUtils.class;
    try {
        ClassUtils.getPublicMethod(class0, ""*6m?M%s)uy{"", classArray0);
        fail(""Expecting exception: NoSuchMethodException"");
    } catch (NoSuchMethodException e) {
    }
}",""
"public static String getPackageName(String className) {
    if (className == null || className.length() == 0) {
        return StringUtils.EMPTY;
    }
    // Strip array encoding
    while (className.charAt(0) == '[') {
        className = className.substring(1);
    }
    // Strip Object type encoding
    if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
        className = className.substring(1);
    }
    int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    if (i == -1) {
        return StringUtils.EMPTY;
    }
    return className.substring(0, i);
}","public void test02830() throws Throwable {
    // Undeclared exception!
    try {
        ClassUtils.getPackageName(""[["");
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * <p>Gets the package name from a <code>String</code>.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 * <p>If the class is unpackaged, return an empty string.</p>
 *
 * @param className  the className to get the package name for, may be <code>null</code>
 * @return the package name or an empty string
 */"
"public static String getPackageCanonicalName(String canonicalName) {
    return ClassUtils.getPackageName(getCanonicalName(canonicalName));
}","public void test02931() throws Throwable {
    // Undeclared exception!
    try {
        ClassUtils.getPackageCanonicalName(""[java.lang"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
    }
}","/**
 * <p>Gets the package name from the canonical name. </p>
 *
 * <p>The string passed in is assumed to be a canonical name - it is not checked.</p>
 * <p>If the class is unpackaged, return an empty string.</p>
 *
 * @param canonicalName  the canonical name to get the package name for, may be <code>null</code>
 * @return the package name or an empty string
 * @since 2.4
 */"
"public static Class<?> getClass(String className) throws ClassNotFoundException {
    return getClass(className, true);
}","public void test03032() throws Throwable {
    // Undeclared exception!
    try {
        ClassUtils.getClass((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // className must not be null.
        //
        verifyException(""org.apache.commons.lang3.ClassUtils"", e);
    }
}","/**
 * Returns the (initialized) class represented by <code>className</code>
 * using the current thread's context class loader. This implementation
 * supports names like ""<code>java.lang.String[]</code>"" as well as
 * ""<code>[Ljava.lang.String;</code>"".
 *
 * @param className  the class name
 * @return the class represented by <code>className</code> using the current thread's context class loader
 * @throws ClassNotFoundException if the class is not found
 */"
"public static Class<?> getClass(String className) throws ClassNotFoundException {
    return getClass(className, true);
}","public void test03133() throws Throwable {
    try {
        ClassUtils.getClass(""The stripAccents(String) method is not supported until Java 1.6"");
        fail(""Expecting exception: ClassNotFoundException"");
    } catch (ClassNotFoundException e) {
    }
}","/**
 * Returns the (initialized) class represented by <code>className</code>
 * using the current thread's context class loader. This implementation
 * supports names like ""<code>java.lang.String[]</code>"" as well as
 * ""<code>[Ljava.lang.String;</code>"".
 *
 * @param className  the class name
 * @return the class represented by <code>className</code> using the current thread's context class loader
 * @throws ClassNotFoundException if the class is not found
 */"
"// Class loading
// ----------------------------------------------------------------------
/**
 * Returns the class represented by <code>className</code> using the
 * <code>classLoader</code>.  This implementation supports names like
 * ""<code>java.lang.String[]</code>"" as well as ""<code>[Ljava.lang.String;</code>"".
 *
 * @param classLoader  the class loader to use to load the class
 * @param className  the class name
 * @param initialize  whether the class must be initialized
 * @return the class represented by <code>className</code> using the <code>classLoader</code>
 * @throws ClassNotFoundException if the class is not found
 */
public static Class<?> getClass(ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException {
    Class<?> clazz;
    if (abbreviationMap.containsKey(className)) {
        String clsName = ""["" + abbreviationMap.get(className);
        clazz = Class.forName(clsName, initialize, classLoader).getComponentType();
    } else {
        clazz = Class.forName(toCanonicalName(className), initialize, classLoader);
    }
    return clazz;
}","public void test03234() throws Throwable {
    ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
    // Undeclared exception!
    try {
        ClassUtils.getClass(classLoader0, (String) null, false);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // className must not be null.
        //
        verifyException(""org.apache.commons.lang3.ClassUtils"", e);
    }
}",""
"public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException {
    return getClass(classLoader, className, true);
}","public void test03335() throws Throwable {
    ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
    // Undeclared exception!
    try {
        ClassUtils.getClass(classLoader0, (String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // className must not be null.
        //
        verifyException(""org.apache.commons.lang3.ClassUtils"", e);
    }
}","/**
 * Returns the (initialized) class represented by <code>className</code>
 * using the <code>classLoader</code>.  This implementation supports names
 * like ""<code>java.lang.String[]</code>"" as well as
 * ""<code>[Ljava.lang.String;</code>"".
 *
 * @param classLoader  the class loader to use to load the class
 * @param className  the class name
 * @return the class represented by <code>className</code> using the <code>classLoader</code>
 * @throws ClassNotFoundException if the class is not found
 */"
"public static Class<?> primitiveToWrapper(Class<?> cls) {
    Class<?> convertedClass = cls;
    if (cls != null && cls.isPrimitive()) {
        convertedClass = primitiveWrapperMap.get(cls);
    }
    return convertedClass;
}","public void test03537() throws Throwable {
    Class<?> class0 = ClassUtils.primitiveToWrapper((Class<?>) null);
    assertNull(class0);
}","/**
 * <p>Converts the specified primitive Class object to its corresponding
 * wrapper Class object.</p>
 *
 * <p>NOTE: From v2.2, this method handles <code>Void.TYPE</code>,
 * returning <code>Void.TYPE</code>.</p>
 *
 * @param cls  the class to convert, may be null
 * @return the wrapper class for <code>cls</code> or <code>cls</code> if
 * <code>cls</code> is not a primitive. <code>null</code> if null input.
 * @since 2.1
 */"
"public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {
    if (toClass == null) {
        return false;
    }
    // have to check for null, as isAssignableFrom doesn't
    if (cls == null) {
        return !(toClass.isPrimitive());
    }
    //autoboxing:
    if (autoboxing) {
        if (cls.isPrimitive() && !toClass.isPrimitive()) {
            cls = primitiveToWrapper(cls);
            if (cls == null) {
                return false;
            }
        }
        if (toClass.isPrimitive() && !cls.isPrimitive()) {
            cls = wrapperToPrimitive(cls);
            if (cls == null) {
                return false;
            }
        }
    }
    if (cls.equals(toClass)) {
        return true;
    }
    if (cls.isPrimitive()) {
        if (toClass.isPrimitive() == false) {
            return false;
        }
        if (Integer.TYPE.equals(cls)) {
            return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Long.TYPE.equals(cls)) {
            return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Boolean.TYPE.equals(cls)) {
            return false;
        }
        if (Double.TYPE.equals(cls)) {
            return false;
        }
        if (Float.TYPE.equals(cls)) {
            return Double.TYPE.equals(toClass);
        }
        if (Character.TYPE.equals(cls)) {
            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Short.TYPE.equals(cls)) {
            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Byte.TYPE.equals(cls)) {
            return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        // should never get here
        return false;
    }
    return toClass.isAssignableFrom(cls);
}","public void test03739() throws Throwable {
    Class<Byte> class0 = Byte.TYPE;
    Class<Integer> class1 = Integer.class;
    boolean boolean0 = ClassUtils.isAssignable(class1, class0, true);
    assertFalse(boolean0);
}","/**
 * <p>Checks if one <code>Class</code> can be assigned to a variable of
 * another <code>Class</code>.</p>
 *
 * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,
 * this method takes into account widenings of primitive classes and
 * <code>null</code>s.</p>
 *
 * <p>Primitive widenings allow an int to be assigned to a long, float or
 * double. This method returns the correct result for these cases.</p>
 *
 * <p><code>Null</code> may be assigned to any reference type. This method
 * will return <code>true</code> if <code>null</code> is passed in and the
 * toClass is non-primitive.</p>
 *
 * <p>Specifically, this method tests whether the type represented by the
 * specified <code>Class</code> parameter can be converted to the type
 * represented by this <code>Class</code> object via an identity conversion
 * widening primitive or widening reference conversion. See
 * <em><a href=""http://java.sun.com/docs/books/jls/"">The Java Language Specification</a></em>,
 * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>
 *
 * @param cls  the Class to check, may be null
 * @param toClass  the Class to try to assign into, returns false if null
 * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers
 * @return <code>true</code> if assignment possible
 */"
"public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {
    if (toClass == null) {
        return false;
    }
    // have to check for null, as isAssignableFrom doesn't
    if (cls == null) {
        return !(toClass.isPrimitive());
    }
    //autoboxing:
    if (autoboxing) {
        if (cls.isPrimitive() && !toClass.isPrimitive()) {
            cls = primitiveToWrapper(cls);
            if (cls == null) {
                return false;
            }
        }
        if (toClass.isPrimitive() && !cls.isPrimitive()) {
            cls = wrapperToPrimitive(cls);
            if (cls == null) {
                return false;
            }
        }
    }
    if (cls.equals(toClass)) {
        return true;
    }
    if (cls.isPrimitive()) {
        if (toClass.isPrimitive() == false) {
            return false;
        }
        if (Integer.TYPE.equals(cls)) {
            return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Long.TYPE.equals(cls)) {
            return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Boolean.TYPE.equals(cls)) {
            return false;
        }
        if (Double.TYPE.equals(cls)) {
            return false;
        }
        if (Float.TYPE.equals(cls)) {
            return Double.TYPE.equals(toClass);
        }
        if (Character.TYPE.equals(cls)) {
            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Short.TYPE.equals(cls)) {
            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Byte.TYPE.equals(cls)) {
            return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        // should never get here
        return false;
    }
    return toClass.isAssignableFrom(cls);
}","public void test03840() throws Throwable {
    Class<Integer> class0 = Integer.TYPE;
    boolean boolean0 = ClassUtils.isAssignable(class0, class0, true);
    assertTrue(boolean0);
}","/**
 * <p>Checks if one <code>Class</code> can be assigned to a variable of
 * another <code>Class</code>.</p>
 *
 * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,
 * this method takes into account widenings of primitive classes and
 * <code>null</code>s.</p>
 *
 * <p>Primitive widenings allow an int to be assigned to a long, float or
 * double. This method returns the correct result for these cases.</p>
 *
 * <p><code>Null</code> may be assigned to any reference type. This method
 * will return <code>true</code> if <code>null</code> is passed in and the
 * toClass is non-primitive.</p>
 *
 * <p>Specifically, this method tests whether the type represented by the
 * specified <code>Class</code> parameter can be converted to the type
 * represented by this <code>Class</code> object via an identity conversion
 * widening primitive or widening reference conversion. See
 * <em><a href=""http://java.sun.com/docs/books/jls/"">The Java Language Specification</a></em>,
 * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>
 *
 * @param cls  the Class to check, may be null
 * @param toClass  the Class to try to assign into, returns false if null
 * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers
 * @return <code>true</code> if assignment possible
 */"
"public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {
    if (toClass == null) {
        return false;
    }
    // have to check for null, as isAssignableFrom doesn't
    if (cls == null) {
        return !(toClass.isPrimitive());
    }
    //autoboxing:
    if (autoboxing) {
        if (cls.isPrimitive() && !toClass.isPrimitive()) {
            cls = primitiveToWrapper(cls);
            if (cls == null) {
                return false;
            }
        }
        if (toClass.isPrimitive() && !cls.isPrimitive()) {
            cls = wrapperToPrimitive(cls);
            if (cls == null) {
                return false;
            }
        }
    }
    if (cls.equals(toClass)) {
        return true;
    }
    if (cls.isPrimitive()) {
        if (toClass.isPrimitive() == false) {
            return false;
        }
        if (Integer.TYPE.equals(cls)) {
            return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Long.TYPE.equals(cls)) {
            return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Boolean.TYPE.equals(cls)) {
            return false;
        }
        if (Double.TYPE.equals(cls)) {
            return false;
        }
        if (Float.TYPE.equals(cls)) {
            return Double.TYPE.equals(toClass);
        }
        if (Character.TYPE.equals(cls)) {
            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Short.TYPE.equals(cls)) {
            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Byte.TYPE.equals(cls)) {
            return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        // should never get here
        return false;
    }
    return toClass.isAssignableFrom(cls);
}","public void test03941() throws Throwable {
    Class<Integer> class0 = Integer.TYPE;
    Class<String> class1 = String.class;
    boolean boolean0 = ClassUtils.isAssignable(class0, class1, true);
    assertFalse(boolean0);
}","/**
 * <p>Checks if one <code>Class</code> can be assigned to a variable of
 * another <code>Class</code>.</p>
 *
 * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,
 * this method takes into account widenings of primitive classes and
 * <code>null</code>s.</p>
 *
 * <p>Primitive widenings allow an int to be assigned to a long, float or
 * double. This method returns the correct result for these cases.</p>
 *
 * <p><code>Null</code> may be assigned to any reference type. This method
 * will return <code>true</code> if <code>null</code> is passed in and the
 * toClass is non-primitive.</p>
 *
 * <p>Specifically, this method tests whether the type represented by the
 * specified <code>Class</code> parameter can be converted to the type
 * represented by this <code>Class</code> object via an identity conversion
 * widening primitive or widening reference conversion. See
 * <em><a href=""http://java.sun.com/docs/books/jls/"">The Java Language Specification</a></em>,
 * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>
 *
 * @param cls  the Class to check, may be null
 * @param toClass  the Class to try to assign into, returns false if null
 * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers
 * @return <code>true</code> if assignment possible
 */"
"public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {
    if (toClass == null) {
        return false;
    }
    // have to check for null, as isAssignableFrom doesn't
    if (cls == null) {
        return !(toClass.isPrimitive());
    }
    //autoboxing:
    if (autoboxing) {
        if (cls.isPrimitive() && !toClass.isPrimitive()) {
            cls = primitiveToWrapper(cls);
            if (cls == null) {
                return false;
            }
        }
        if (toClass.isPrimitive() && !cls.isPrimitive()) {
            cls = wrapperToPrimitive(cls);
            if (cls == null) {
                return false;
            }
        }
    }
    if (cls.equals(toClass)) {
        return true;
    }
    if (cls.isPrimitive()) {
        if (toClass.isPrimitive() == false) {
            return false;
        }
        if (Integer.TYPE.equals(cls)) {
            return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Long.TYPE.equals(cls)) {
            return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Boolean.TYPE.equals(cls)) {
            return false;
        }
        if (Double.TYPE.equals(cls)) {
            return false;
        }
        if (Float.TYPE.equals(cls)) {
            return Double.TYPE.equals(toClass);
        }
        if (Character.TYPE.equals(cls)) {
            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Short.TYPE.equals(cls)) {
            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Byte.TYPE.equals(cls)) {
            return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        // should never get here
        return false;
    }
    return toClass.isAssignableFrom(cls);
}","public void test04042() throws Throwable {
    Class<Double>[] classArray0 = (Class<Double>[]) Array.newInstance(Class.class, 5);
    Class<Double> class0 = Double.class;
    boolean boolean0 = ClassUtils.isAssignable(classArray0[1], class0, true);
    assertTrue(boolean0);
}","/**
 * <p>Checks if one <code>Class</code> can be assigned to a variable of
 * another <code>Class</code>.</p>
 *
 * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,
 * this method takes into account widenings of primitive classes and
 * <code>null</code>s.</p>
 *
 * <p>Primitive widenings allow an int to be assigned to a long, float or
 * double. This method returns the correct result for these cases.</p>
 *
 * <p><code>Null</code> may be assigned to any reference type. This method
 * will return <code>true</code> if <code>null</code> is passed in and the
 * toClass is non-primitive.</p>
 *
 * <p>Specifically, this method tests whether the type represented by the
 * specified <code>Class</code> parameter can be converted to the type
 * represented by this <code>Class</code> object via an identity conversion
 * widening primitive or widening reference conversion. See
 * <em><a href=""http://java.sun.com/docs/books/jls/"">The Java Language Specification</a></em>,
 * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>
 *
 * @param cls  the Class to check, may be null
 * @param toClass  the Class to try to assign into, returns false if null
 * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers
 * @return <code>true</code> if assignment possible
 */"
"public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {
    if (toClass == null) {
        return false;
    }
    // have to check for null, as isAssignableFrom doesn't
    if (cls == null) {
        return !(toClass.isPrimitive());
    }
    //autoboxing:
    if (autoboxing) {
        if (cls.isPrimitive() && !toClass.isPrimitive()) {
            cls = primitiveToWrapper(cls);
            if (cls == null) {
                return false;
            }
        }
        if (toClass.isPrimitive() && !cls.isPrimitive()) {
            cls = wrapperToPrimitive(cls);
            if (cls == null) {
                return false;
            }
        }
    }
    if (cls.equals(toClass)) {
        return true;
    }
    if (cls.isPrimitive()) {
        if (toClass.isPrimitive() == false) {
            return false;
        }
        if (Integer.TYPE.equals(cls)) {
            return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Long.TYPE.equals(cls)) {
            return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Boolean.TYPE.equals(cls)) {
            return false;
        }
        if (Double.TYPE.equals(cls)) {
            return false;
        }
        if (Float.TYPE.equals(cls)) {
            return Double.TYPE.equals(toClass);
        }
        if (Character.TYPE.equals(cls)) {
            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Short.TYPE.equals(cls)) {
            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Byte.TYPE.equals(cls)) {
            return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        // should never get here
        return false;
    }
    return toClass.isAssignableFrom(cls);
}","public void test04143() throws Throwable {
    Class<Short>[] classArray0 = (Class<Short>[]) Array.newInstance(Class.class, 2);
    Class<Integer> class0 = Integer.class;
    boolean boolean0 = ClassUtils.isAssignable(class0, classArray0[0], false);
    assertFalse(boolean0);
}","/**
 * <p>Checks if one <code>Class</code> can be assigned to a variable of
 * another <code>Class</code>.</p>
 *
 * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,
 * this method takes into account widenings of primitive classes and
 * <code>null</code>s.</p>
 *
 * <p>Primitive widenings allow an int to be assigned to a long, float or
 * double. This method returns the correct result for these cases.</p>
 *
 * <p><code>Null</code> may be assigned to any reference type. This method
 * will return <code>true</code> if <code>null</code> is passed in and the
 * toClass is non-primitive.</p>
 *
 * <p>Specifically, this method tests whether the type represented by the
 * specified <code>Class</code> parameter can be converted to the type
 * represented by this <code>Class</code> object via an identity conversion
 * widening primitive or widening reference conversion. See
 * <em><a href=""http://java.sun.com/docs/books/jls/"">The Java Language Specification</a></em>,
 * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>
 *
 * @param cls  the Class to check, may be null
 * @param toClass  the Class to try to assign into, returns false if null
 * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers
 * @return <code>true</code> if assignment possible
 */"
"public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) {
    if (ArrayUtils.isSameLength(classArray, toClassArray) == false) {
        return false;
    }
    if (classArray == null) {
        classArray = ArrayUtils.EMPTY_CLASS_ARRAY;
    }
    if (toClassArray == null) {
        toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY;
    }
    for (int i = 0; i < classArray.length; i++) {
        if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) {
            return false;
        }
    }
    return true;
}","public void test04244() throws Throwable {
    Class<Double>[] classArray0 = (Class<Double>[]) Array.newInstance(Class.class, 5);
    boolean boolean0 = ClassUtils.isAssignable(classArray0, classArray0, true);
    assertFalse(boolean0);
}","/**
 * <p>Checks if an array of Classes can be assigned to another array of Classes.</p>
 *
 * <p>This method calls {@link #isAssignable(Class, Class) isAssignable} for each
 * Class pair in the input arrays. It can be used to check if a set of arguments
 * (the first parameter) are suitably compatible with a set of method parameter types
 * (the second parameter).</p>
 *
 * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this
 * method takes into account widenings of primitive classes and
 * <code>null</code>s.</p>
 *
 * <p>Primitive widenings allow an int to be assigned to a <code>long</code>,
 * <code>float</code> or <code>double</code>. This method returns the correct
 * result for these cases.</p>
 *
 * <p><code>Null</code> may be assigned to any reference type. This method will
 * return <code>true</code> if <code>null</code> is passed in and the toClass is
 * non-primitive.</p>
 *
 * <p>Specifically, this method tests whether the type represented by the
 * specified <code>Class</code> parameter can be converted to the type
 * represented by this <code>Class</code> object via an identity conversion
 * widening primitive or widening reference conversion. See
 * <em><a href=""http://java.sun.com/docs/books/jls/"">The Java Language Specification</a></em>,
 * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>
 *
 * @param classArray  the array of Classes to check, may be <code>null</code>
 * @param toClassArray  the array of Classes to try to assign into, may be <code>null</code>
 * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers
 * @return <code>true</code> if assignment possible
 */"
"public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) {
    if (ArrayUtils.isSameLength(classArray, toClassArray) == false) {
        return false;
    }
    if (classArray == null) {
        classArray = ArrayUtils.EMPTY_CLASS_ARRAY;
    }
    if (toClassArray == null) {
        toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY;
    }
    for (int i = 0; i < classArray.length; i++) {
        if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) {
            return false;
        }
    }
    return true;
}","public void test04345() throws Throwable {
    Class<Object>[] classArray0 = (Class<Object>[]) Array.newInstance(Class.class, 9);
    boolean boolean0 = ClassUtils.isAssignable((Class<?>[]) null, classArray0, false);
    assertFalse(boolean0);
}","/**
 * <p>Checks if an array of Classes can be assigned to another array of Classes.</p>
 *
 * <p>This method calls {@link #isAssignable(Class, Class) isAssignable} for each
 * Class pair in the input arrays. It can be used to check if a set of arguments
 * (the first parameter) are suitably compatible with a set of method parameter types
 * (the second parameter).</p>
 *
 * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this
 * method takes into account widenings of primitive classes and
 * <code>null</code>s.</p>
 *
 * <p>Primitive widenings allow an int to be assigned to a <code>long</code>,
 * <code>float</code> or <code>double</code>. This method returns the correct
 * result for these cases.</p>
 *
 * <p><code>Null</code> may be assigned to any reference type. This method will
 * return <code>true</code> if <code>null</code> is passed in and the toClass is
 * non-primitive.</p>
 *
 * <p>Specifically, this method tests whether the type represented by the
 * specified <code>Class</code> parameter can be converted to the type
 * represented by this <code>Class</code> object via an identity conversion
 * widening primitive or widening reference conversion. See
 * <em><a href=""http://java.sun.com/docs/books/jls/"">The Java Language Specification</a></em>,
 * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>
 *
 * @param classArray  the array of Classes to check, may be <code>null</code>
 * @param toClassArray  the array of Classes to try to assign into, may be <code>null</code>
 * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers
 * @return <code>true</code> if assignment possible
 */"
"public static String getPackageName(String className) {
    if (className == null || className.length() == 0) {
        return StringUtils.EMPTY;
    }
    // Strip array encoding
    while (className.charAt(0) == '[') {
        className = className.substring(1);
    }
    // Strip Object type encoding
    if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
        className = className.substring(1);
    }
    int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    if (i == -1) {
        return StringUtils.EMPTY;
    }
    return className.substring(0, i);
}","public void test04446() throws Throwable {
    String string0 = ClassUtils.getPackageName(""[[L"");
    assertEquals("""", string0);
}","/**
 * <p>Gets the package name from a <code>String</code>.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 * <p>If the class is unpackaged, return an empty string.</p>
 *
 * @param className  the className to get the package name for, may be <code>null</code>
 * @return the package name or an empty string
 */"
"public static String getPackageName(String className) {
    if (className == null || className.length() == 0) {
        return StringUtils.EMPTY;
    }
    // Strip array encoding
    while (className.charAt(0) == '[') {
        className = className.substring(1);
    }
    // Strip Object type encoding
    if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
        className = className.substring(1);
    }
    int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    if (i == -1) {
        return StringUtils.EMPTY;
    }
    return className.substring(0, i);
}","public void test04547() throws Throwable {
    String string0 = ClassUtils.getPackageName(""L;"");
    assertEquals("""", string0);
}","/**
 * <p>Gets the package name from a <code>String</code>.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 * <p>If the class is unpackaged, return an empty string.</p>
 *
 * @param className  the className to get the package name for, may be <code>null</code>
 * @return the package name or an empty string
 */"
"public static String getShortClassName(String className) {
    if (className == null) {
        return StringUtils.EMPTY;
    }
    if (className.length() == 0) {
        return StringUtils.EMPTY;
    }
    StringBuilder arrayPrefix = new StringBuilder();
    // Handle array encoding
    if (className.startsWith(""["")) {
        while (className.charAt(0) == '[') {
            className = className.substring(1);
            arrayPrefix.append(""[]"");
        }
        // Strip Object type encoding
        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
            className = className.substring(1, className.length() - 1);
        }
    }
    if (reverseAbbreviationMap.containsKey(className)) {
        className = reverseAbbreviationMap.get(className);
    }
    int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);
    String out = className.substring(lastDotIdx + 1);
    if (innerIdx != -1) {
        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
    }
    return out + arrayPrefix;
}","public void test04648() throws Throwable {
    String string0 = ClassUtils.getShortClassName(""org.apache.commons.lang3.builder.ToStringStyle$ShortPrefixToStringStyle"");
    assertEquals(""ToStringStyle.ShortPrefixToStringStyle"", string0);
}","/**
 * <p>Gets the class name minus the package name from a String.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 *
 * @param className  the className to get the short name for
 * @return the class name of the class without the package name or an empty string
 */"
"public static String getShortClassName(Class<?> cls) {
    if (cls == null) {
        return StringUtils.EMPTY;
    }
    return getShortClassName(cls.getName());
}","public void test04749() throws Throwable {
    Class<Byte> class0 = Byte.class;
    String string0 = ClassUtils.getShortClassName(class0);
    assertEquals(""Byte"", string0);
}","/**
 * <p>Gets the class name minus the package name from a <code>Class</code>.</p>
 *
 * @param cls  the class to get the short name for.
 * @return the class name without the package name or an empty string
 */"
"public static String getShortCanonicalName(String canonicalName) {
    return ClassUtils.getShortClassName(getCanonicalName(canonicalName));
}","public void test04850() throws Throwable {
    String string0 = ClassUtils.getShortCanonicalName(""["");
    assertEquals(""][]"", string0);
}","/**
 * <p>Gets the canonical name minus the package name from a String.</p>
 *
 * <p>The string passed in is assumed to be a canonical name - it is not checked.</p>
 *
 * @param canonicalName  the class name to get the short name for
 * @return the canonical name of the class without the package name or an empty string
 * @since 2.4
 */"
"public static String getPackageCanonicalName(String canonicalName) {
    return ClassUtils.getPackageName(getCanonicalName(canonicalName));
}","public void test04951() throws Throwable {
    String string0 = ClassUtils.getPackageCanonicalName(""[L"");
    assertEquals("""", string0);
}","/**
 * <p>Gets the package name from the canonical name. </p>
 *
 * <p>The string passed in is assumed to be a canonical name - it is not checked.</p>
 * <p>If the class is unpackaged, return an empty string.</p>
 *
 * @param canonicalName  the canonical name to get the package name for, may be <code>null</code>
 * @return the package name or an empty string
 * @since 2.4
 */"
"public static String getShortCanonicalName(String canonicalName) {
    return ClassUtils.getShortClassName(getCanonicalName(canonicalName));
}","public void test05052() throws Throwable {
    // Undeclared exception!
    try {
        ClassUtils.getShortCanonicalName(""[]"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
    }
}","/**
 * <p>Gets the canonical name minus the package name from a String.</p>
 *
 * <p>The string passed in is assumed to be a canonical name - it is not checked.</p>
 *
 * @param canonicalName  the class name to get the short name for
 * @return the canonical name of the class without the package name or an empty string
 * @since 2.4
 */"
"public static String getShortCanonicalName(String canonicalName) {
    return ClassUtils.getShortClassName(getCanonicalName(canonicalName));
}","public void test05153() throws Throwable {
    String string0 = ClassUtils.getShortCanonicalName((String) null);
    assertEquals("""", string0);
}","/**
 * <p>Gets the canonical name minus the package name from a String.</p>
 *
 * <p>The string passed in is assumed to be a canonical name - it is not checked.</p>
 *
 * @param canonicalName  the class name to get the short name for
 * @return the canonical name of the class without the package name or an empty string
 * @since 2.4
 */"
"public static String getPackageCanonicalName(Class<?> cls) {
    if (cls == null) {
        return StringUtils.EMPTY;
    }
    return getPackageCanonicalName(cls.getName());
}","public void test05254() throws Throwable {
    Class<String>[] classArray0 = (Class<String>[]) Array.newInstance(Class.class, 7);
    String string0 = ClassUtils.getPackageCanonicalName(classArray0[2]);
    assertEquals("""", string0);
}","/**
 * <p>Gets the package name from the canonical name of a <code>Class</code>.</p>
 *
 * @param cls  the class to get the package name for, may be <code>null</code>.
 * @return the package name or an empty string
 * @since 2.4
 */"
"// Package name
// ----------------------------------------------------------------------
/**
 * <p>Gets the package name from the canonical name of an <code>Object</code>.</p>
 *
 * @param object  the class to get the package name for, may be null
 * @param valueIfNull  the value to return if null
 * @return the package name of the object, or the null value
 * @since 2.4
 */
public static String getPackageCanonicalName(Object object, String valueIfNull) {
    if (object == null) {
        return valueIfNull;
    }
    return getPackageCanonicalName(object.getClass().getName());
}","public void test05355() throws Throwable {
    String string0 = ClassUtils.getPackageCanonicalName((Object) null, ""PreferencesFactory"");
    assertEquals(""PreferencesFactory"", string0);
}",""
"// Package name
// ----------------------------------------------------------------------
/**
 * <p>Gets the package name from the canonical name of an <code>Object</code>.</p>
 *
 * @param object  the class to get the package name for, may be null
 * @param valueIfNull  the value to return if null
 * @return the package name of the object, or the null value
 * @since 2.4
 */
public static String getPackageCanonicalName(Object object, String valueIfNull) {
    if (object == null) {
        return valueIfNull;
    }
    return getPackageCanonicalName(object.getClass().getName());
}","public void test05456() throws Throwable {
    String string0 = ClassUtils.getPackageCanonicalName((Object) "":*|3>z24"", ""52)3"");
    assertEquals(""java.lang"", string0);
}",""
"public static String getShortCanonicalName(Class<?> cls) {
    if (cls == null) {
        return StringUtils.EMPTY;
    }
    return getShortCanonicalName(cls.getName());
}","public void test05557() throws Throwable {
    String string0 = ClassUtils.getShortCanonicalName((Class<?>) null);
    assertEquals("""", string0);
}","/**
 * <p>Gets the canonical name minus the package name from a <code>Class</code>.</p>
 *
 * @param cls  the class to get the short name for.
 * @return the canonical name without the package name or an empty string
 * @since 2.4
 */"
"public static String getShortCanonicalName(Class<?> cls) {
    if (cls == null) {
        return StringUtils.EMPTY;
    }
    return getShortCanonicalName(cls.getName());
}","public void test05658() throws Throwable {
    Class<?> class0 = ClassUtils.getClass(""boolean"");
    String string0 = ClassUtils.getShortCanonicalName(class0);
    assertEquals(""boolean"", string0);
}","/**
 * <p>Gets the canonical name minus the package name from a <code>Class</code>.</p>
 *
 * @param cls  the class to get the short name for.
 * @return the canonical name without the package name or an empty string
 * @since 2.4
 */"
"// Short canonical name
// ----------------------------------------------------------------------
/**
 * <p>Gets the canonical name minus the package name for an <code>Object</code>.</p>
 *
 * @param object  the class to get the short name for, may be null
 * @param valueIfNull  the value to return if null
 * @return the canonical name of the object without the package name, or the null value
 * @since 2.4
 */
public static String getShortCanonicalName(Object object, String valueIfNull) {
    if (object == null) {
        return valueIfNull;
    }
    return getShortCanonicalName(object.getClass().getName());
}","public void test05759() throws Throwable {
    String string0 = ClassUtils.getShortCanonicalName((Object) null, ""S4"");
    assertEquals(""S4"", string0);
}",""
"// Short canonical name
// ----------------------------------------------------------------------
/**
 * <p>Gets the canonical name minus the package name for an <code>Object</code>.</p>
 *
 * @param object  the class to get the short name for, may be null
 * @param valueIfNull  the value to return if null
 * @return the canonical name of the object without the package name, or the null value
 * @since 2.4
 */
public static String getShortCanonicalName(Object object, String valueIfNull) {
    if (object == null) {
        return valueIfNull;
    }
    return getShortCanonicalName(object.getClass().getName());
}","public void test05860() throws Throwable {
    Class<Double>[] classArray0 = (Class<Double>[]) Array.newInstance(Class.class, 5);
    Class<Double> class0 = Double.class;
    classArray0[0] = class0;
    classArray0[2] = classArray0[0];
    String string0 = ClassUtils.getShortCanonicalName((Object) classArray0[2], """");
    assertEquals(""Class"", string0);
}",""
"public static Class<?>[] toClass(Object[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return ArrayUtils.EMPTY_CLASS_ARRAY;
    }
    Class<?>[] classes = new Class[array.length];
    for (int i = 0; i < array.length; i++) {
        classes[i] = array[i].getClass();
    }
    return classes;
}","public void test05961() throws Throwable {
    Class<Short>[] classArray0 = (Class<Short>[]) Array.newInstance(Class.class, 0);
    Class<?>[] classArray1 = ClassUtils.toClass(classArray0);
    assertEquals(0, classArray1.length);
}","/**
 * <p>Converts an array of <code>Object</code> in to an array of <code>Class</code> objects.
 * If any of these objects is null, a null element will be inserted into the array.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array an <code>Object</code> array
 * @return a <code>Class</code> array, <code>null</code> if null array input
 * @since 2.4
 */"
"public static Class<?>[] toClass(Object[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return ArrayUtils.EMPTY_CLASS_ARRAY;
    }
    Class<?>[] classes = new Class[array.length];
    for (int i = 0; i < array.length; i++) {
        classes[i] = array[i].getClass();
    }
    return classes;
}","public void test06062() throws Throwable {
    Class<?>[] classArray0 = ClassUtils.toClass((Object[]) null);
    assertNull(classArray0);
}","/**
 * <p>Converts an array of <code>Object</code> in to an array of <code>Class</code> objects.
 * If any of these objects is null, a null element will be inserted into the array.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array an <code>Object</code> array
 * @return a <code>Class</code> array, <code>null</code> if null array input
 * @since 2.4
 */"
"// Class loading
// ----------------------------------------------------------------------
/**
 * Returns the class represented by <code>className</code> using the
 * <code>classLoader</code>.  This implementation supports names like
 * ""<code>java.lang.String[]</code>"" as well as ""<code>[Ljava.lang.String;</code>"".
 *
 * @param classLoader  the class loader to use to load the class
 * @param className  the class name
 * @param initialize  whether the class must be initialized
 * @return the class represented by <code>className</code> using the <code>classLoader</code>
 * @throws ClassNotFoundException if the class is not found
 */
public static Class<?> getClass(ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException {
    Class<?> clazz;
    if (abbreviationMap.containsKey(className)) {
        String clsName = ""["" + abbreviationMap.get(className);
        clazz = Class.forName(clsName, initialize, classLoader).getComponentType();
    } else {
        clazz = Class.forName(toCanonicalName(className), initialize, classLoader);
    }
    return clazz;
}","public void test06163() throws Throwable {
    ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
    try {
        ClassUtils.getClass(classLoader0, ""[]"", true);
        fail(""Expecting exception: ClassNotFoundException"");
    } catch (ClassNotFoundException e) {
    }
}",""
"public static Class<?> getClass(String className, boolean initialize) throws ClassNotFoundException {
    ClassLoader contextCL = Thread.currentThread().getContextClassLoader();
    ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;
    return getClass(loader, className, initialize);
}","public void test06264() throws Throwable {
    // Undeclared exception!
    try {
        ClassUtils.getClass((String) null, false);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // className must not be null.
        //
        verifyException(""org.apache.commons.lang3.ClassUtils"", e);
    }
}","/**
 * Returns the class represented by <code>className</code> using the
 * current thread's context class loader. This implementation supports
 * names like ""<code>java.lang.String[]</code>"" as well as
 * ""<code>[Ljava.lang.String;</code>"".
 *
 * @param className  the class name
 * @param initialize  whether the class must be initialized
 * @return the class represented by <code>className</code> using the current thread's context class loader
 * @throws ClassNotFoundException if the class is not found
 */"
"// Inner class
// ----------------------------------------------------------------------
/**
 * <p>Is the specified class an inner class or static nested class.</p>
 *
 * @param cls  the class to check, may be null
 * @return <code>true</code> if the class is an inner or static nested class,
 *  false if not or <code>null</code>
 */
public static boolean isInnerClass(Class<?> cls) {
    if (cls == null) {
        return false;
    }
    return cls.getName().indexOf(INNER_CLASS_SEPARATOR_CHAR) >= 0;
}","public void test06365() throws Throwable {
    boolean boolean0 = ClassUtils.isInnerClass((Class<?>) null);
    assertFalse(boolean0);
}",""
"// Inner class
// ----------------------------------------------------------------------
/**
 * <p>Is the specified class an inner class or static nested class.</p>
 *
 * @param cls  the class to check, may be null
 * @return <code>true</code> if the class is an inner or static nested class,
 *  false if not or <code>null</code>
 */
public static boolean isInnerClass(Class<?> cls) {
    if (cls == null) {
        return false;
    }
    return cls.getName().indexOf(INNER_CLASS_SEPARATOR_CHAR) >= 0;
}","public void test06466() throws Throwable {
    Class<String> class0 = String.class;
    boolean boolean0 = ClassUtils.isInnerClass(class0);
    assertFalse(boolean0);
}",""
"public static Class<?>[] wrappersToPrimitives(Class<?>[] classes) {
    if (classes == null) {
        return null;
    }
    if (classes.length == 0) {
        return classes;
    }
    Class<?>[] convertedClasses = new Class[classes.length];
    for (int i = 0; i < classes.length; i++) {
        convertedClasses[i] = wrapperToPrimitive(classes[i]);
    }
    return convertedClasses;
}","public void test06567() throws Throwable {
    Class<ClassUtils>[] classArray0 = (Class<ClassUtils>[]) Array.newInstance(Class.class, 0);
    Class<?>[] classArray1 = ClassUtils.wrappersToPrimitives(classArray0);
    assertEquals(0, classArray1.length);
}","/**
 * <p>Converts the specified array of wrapper Class objects to an array of
 * its corresponding primitive Class objects.</p>
 *
 * <p>This method invokes <code>wrapperToPrimitive()</code> for each element
 * of the passed in array.</p>
 *
 * @param classes  the class array to convert, may be null or empty
 * @return an array which contains for each given class, the primitive class or
 * <b>null</b> if the original class is not a wrapper class. <code>null</code> if null input.
 * Empty array if an empty array passed in.
 * @see #wrapperToPrimitive(Class)
 * @since 2.4
 */"
"public static Class<?>[] wrappersToPrimitives(Class<?>[] classes) {
    if (classes == null) {
        return null;
    }
    if (classes.length == 0) {
        return classes;
    }
    Class<?>[] convertedClasses = new Class[classes.length];
    for (int i = 0; i < classes.length; i++) {
        convertedClasses[i] = wrapperToPrimitive(classes[i]);
    }
    return convertedClasses;
}","public void test06668() throws Throwable {
    Class<?>[] classArray0 = ClassUtils.wrappersToPrimitives((Class<?>[]) null);
    assertNull(classArray0);
}","/**
 * <p>Converts the specified array of wrapper Class objects to an array of
 * its corresponding primitive Class objects.</p>
 *
 * <p>This method invokes <code>wrapperToPrimitive()</code> for each element
 * of the passed in array.</p>
 *
 * @param classes  the class array to convert, may be null or empty
 * @return an array which contains for each given class, the primitive class or
 * <b>null</b> if the original class is not a wrapper class. <code>null</code> if null input.
 * Empty array if an empty array passed in.
 * @see #wrapperToPrimitive(Class)
 * @since 2.4
 */"
"public static Class<?>[] primitivesToWrappers(Class<?>[] classes) {
    if (classes == null) {
        return null;
    }
    if (classes.length == 0) {
        return classes;
    }
    Class<?>[] convertedClasses = new Class[classes.length];
    for (int i = 0; i < classes.length; i++) {
        convertedClasses[i] = primitiveToWrapper(classes[i]);
    }
    return convertedClasses;
}","public void test06769() throws Throwable {
    Class<Short>[] classArray0 = (Class<Short>[]) Array.newInstance(Class.class, 0);
    Class<?>[] classArray1 = ClassUtils.primitivesToWrappers(classArray0);
    assertEquals(0, classArray1.length);
}","/**
 * <p>Converts the specified array of primitive Class objects to an array of
 * its corresponding wrapper Class objects.</p>
 *
 * @param classes  the class array to convert, may be null or empty
 * @return an array which contains for each given class, the wrapper class or
 * the original class if class is not a primitive. <code>null</code> if null input.
 * Empty array if an empty array passed in.
 * @since 2.1
 */"
"public static Class<?>[] primitivesToWrappers(Class<?>[] classes) {
    if (classes == null) {
        return null;
    }
    if (classes.length == 0) {
        return classes;
    }
    Class<?>[] convertedClasses = new Class[classes.length];
    for (int i = 0; i < classes.length; i++) {
        convertedClasses[i] = primitiveToWrapper(classes[i]);
    }
    return convertedClasses;
}","public void test06870() throws Throwable {
    Class<?>[] classArray0 = ClassUtils.primitivesToWrappers((Class<?>[]) null);
    assertNull(classArray0);
}","/**
 * <p>Converts the specified array of primitive Class objects to an array of
 * its corresponding wrapper Class objects.</p>
 *
 * @param classes  the class array to convert, may be null or empty
 * @return an array which contains for each given class, the wrapper class or
 * the original class if class is not a primitive. <code>null</code> if null input.
 * Empty array if an empty array passed in.
 * @since 2.1
 */"
"public static Class<?>[] primitivesToWrappers(Class<?>[] classes) {
    if (classes == null) {
        return null;
    }
    if (classes.length == 0) {
        return classes;
    }
    Class<?>[] convertedClasses = new Class[classes.length];
    for (int i = 0; i < classes.length; i++) {
        convertedClasses[i] = primitiveToWrapper(classes[i]);
    }
    return convertedClasses;
}","public void test07072() throws Throwable {
    Class<Double>[] classArray0 = (Class<Double>[]) Array.newInstance(Class.class, 5);
    Class<?>[] classArray1 = ClassUtils.primitivesToWrappers(classArray0);
    assertEquals(5, classArray1.length);
}","/**
 * <p>Converts the specified array of primitive Class objects to an array of
 * its corresponding wrapper Class objects.</p>
 *
 * @param classes  the class array to convert, may be null or empty
 * @return an array which contains for each given class, the wrapper class or
 * the original class if class is not a primitive. <code>null</code> if null input.
 * Empty array if an empty array passed in.
 * @since 2.1
 */"
"public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {
    if (toClass == null) {
        return false;
    }
    // have to check for null, as isAssignableFrom doesn't
    if (cls == null) {
        return !(toClass.isPrimitive());
    }
    //autoboxing:
    if (autoboxing) {
        if (cls.isPrimitive() && !toClass.isPrimitive()) {
            cls = primitiveToWrapper(cls);
            if (cls == null) {
                return false;
            }
        }
        if (toClass.isPrimitive() && !cls.isPrimitive()) {
            cls = wrapperToPrimitive(cls);
            if (cls == null) {
                return false;
            }
        }
    }
    if (cls.equals(toClass)) {
        return true;
    }
    if (cls.isPrimitive()) {
        if (toClass.isPrimitive() == false) {
            return false;
        }
        if (Integer.TYPE.equals(cls)) {
            return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Long.TYPE.equals(cls)) {
            return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Boolean.TYPE.equals(cls)) {
            return false;
        }
        if (Double.TYPE.equals(cls)) {
            return false;
        }
        if (Float.TYPE.equals(cls)) {
            return Double.TYPE.equals(toClass);
        }
        if (Character.TYPE.equals(cls)) {
            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Short.TYPE.equals(cls)) {
            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Byte.TYPE.equals(cls)) {
            return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        // should never get here
        return false;
    }
    return toClass.isAssignableFrom(cls);
}","public void test07173() throws Throwable {
    Class<Double> class0 = Double.TYPE;
    Class<Long> class1 = Long.TYPE;
    boolean boolean0 = ClassUtils.isAssignable(class0, class1, false);
    assertFalse(boolean0);
}","/**
 * <p>Checks if one <code>Class</code> can be assigned to a variable of
 * another <code>Class</code>.</p>
 *
 * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,
 * this method takes into account widenings of primitive classes and
 * <code>null</code>s.</p>
 *
 * <p>Primitive widenings allow an int to be assigned to a long, float or
 * double. This method returns the correct result for these cases.</p>
 *
 * <p><code>Null</code> may be assigned to any reference type. This method
 * will return <code>true</code> if <code>null</code> is passed in and the
 * toClass is non-primitive.</p>
 *
 * <p>Specifically, this method tests whether the type represented by the
 * specified <code>Class</code> parameter can be converted to the type
 * represented by this <code>Class</code> object via an identity conversion
 * widening primitive or widening reference conversion. See
 * <em><a href=""http://java.sun.com/docs/books/jls/"">The Java Language Specification</a></em>,
 * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>
 *
 * @param cls  the Class to check, may be null
 * @param toClass  the Class to try to assign into, returns false if null
 * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers
 * @return <code>true</code> if assignment possible
 */"
"public static boolean isAssignable(Class<?> cls, Class<?> toClass) {
    return isAssignable(cls, toClass, SystemUtils.isJavaVersionAtLeast(1.5f));
}","public void test07274() throws Throwable {
    Class<Integer> class0 = Integer.TYPE;
    Class<Byte> class1 = Byte.TYPE;
    boolean boolean0 = ClassUtils.isAssignable(class0, class1);
    assertFalse(boolean0);
}","/**
 * <p>Checks if one <code>Class</code> can be assigned to a variable of
 * another <code>Class</code>.</p>
 *
 * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,
 * this method takes into account widenings of primitive classes and
 * <code>null</code>s.</p>
 *
 * <p>Primitive widenings allow an int to be assigned to a long, float or
 * double. This method returns the correct result for these cases.</p>
 *
 * <p><code>Null</code> may be assigned to any reference type. This method
 * will return <code>true</code> if <code>null</code> is passed in and the
 * toClass is non-primitive.</p>
 *
 * <p>Specifically, this method tests whether the type represented by the
 * specified <code>Class</code> parameter can be converted to the type
 * represented by this <code>Class</code> object via an identity conversion
 * widening primitive or widening reference conversion. See
 * <em><a href=""http://java.sun.com/docs/books/jls/"">The Java Language Specification</a></em>,
 * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>
 *
 * <p><strong>Since Lang 3.0,</strong> this method will default behavior for
 * calculating assignability between primitive and wrapper types <em>corresponding
 * to the running Java version</em>; i.e. autoboxing will be the default
 * behavior in VMs running Java versions >= 1.5.</p>
 *
 * @param cls  the Class to check, may be null
 * @param toClass  the Class to try to assign into, returns false if null
 * @return <code>true</code> if assignment possible
 */"
"public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {
    if (toClass == null) {
        return false;
    }
    // have to check for null, as isAssignableFrom doesn't
    if (cls == null) {
        return !(toClass.isPrimitive());
    }
    //autoboxing:
    if (autoboxing) {
        if (cls.isPrimitive() && !toClass.isPrimitive()) {
            cls = primitiveToWrapper(cls);
            if (cls == null) {
                return false;
            }
        }
        if (toClass.isPrimitive() && !cls.isPrimitive()) {
            cls = wrapperToPrimitive(cls);
            if (cls == null) {
                return false;
            }
        }
    }
    if (cls.equals(toClass)) {
        return true;
    }
    if (cls.isPrimitive()) {
        if (toClass.isPrimitive() == false) {
            return false;
        }
        if (Integer.TYPE.equals(cls)) {
            return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Long.TYPE.equals(cls)) {
            return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Boolean.TYPE.equals(cls)) {
            return false;
        }
        if (Double.TYPE.equals(cls)) {
            return false;
        }
        if (Float.TYPE.equals(cls)) {
            return Double.TYPE.equals(toClass);
        }
        if (Character.TYPE.equals(cls)) {
            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Short.TYPE.equals(cls)) {
            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Byte.TYPE.equals(cls)) {
            return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        // should never get here
        return false;
    }
    return toClass.isAssignableFrom(cls);
}","public void test07375() throws Throwable {
    Class<Double> class0 = Double.TYPE;
    Class<Long> class1 = Long.class;
    boolean boolean0 = ClassUtils.isAssignable(class0, class1, false);
    assertFalse(boolean0);
}","/**
 * <p>Checks if one <code>Class</code> can be assigned to a variable of
 * another <code>Class</code>.</p>
 *
 * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,
 * this method takes into account widenings of primitive classes and
 * <code>null</code>s.</p>
 *
 * <p>Primitive widenings allow an int to be assigned to a long, float or
 * double. This method returns the correct result for these cases.</p>
 *
 * <p><code>Null</code> may be assigned to any reference type. This method
 * will return <code>true</code> if <code>null</code> is passed in and the
 * toClass is non-primitive.</p>
 *
 * <p>Specifically, this method tests whether the type represented by the
 * specified <code>Class</code> parameter can be converted to the type
 * represented by this <code>Class</code> object via an identity conversion
 * widening primitive or widening reference conversion. See
 * <em><a href=""http://java.sun.com/docs/books/jls/"">The Java Language Specification</a></em>,
 * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>
 *
 * @param cls  the Class to check, may be null
 * @param toClass  the Class to try to assign into, returns false if null
 * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers
 * @return <code>true</code> if assignment possible
 */"
"public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {
    if (toClass == null) {
        return false;
    }
    // have to check for null, as isAssignableFrom doesn't
    if (cls == null) {
        return !(toClass.isPrimitive());
    }
    //autoboxing:
    if (autoboxing) {
        if (cls.isPrimitive() && !toClass.isPrimitive()) {
            cls = primitiveToWrapper(cls);
            if (cls == null) {
                return false;
            }
        }
        if (toClass.isPrimitive() && !cls.isPrimitive()) {
            cls = wrapperToPrimitive(cls);
            if (cls == null) {
                return false;
            }
        }
    }
    if (cls.equals(toClass)) {
        return true;
    }
    if (cls.isPrimitive()) {
        if (toClass.isPrimitive() == false) {
            return false;
        }
        if (Integer.TYPE.equals(cls)) {
            return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Long.TYPE.equals(cls)) {
            return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Boolean.TYPE.equals(cls)) {
            return false;
        }
        if (Double.TYPE.equals(cls)) {
            return false;
        }
        if (Float.TYPE.equals(cls)) {
            return Double.TYPE.equals(toClass);
        }
        if (Character.TYPE.equals(cls)) {
            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Short.TYPE.equals(cls)) {
            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Byte.TYPE.equals(cls)) {
            return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        // should never get here
        return false;
    }
    return toClass.isAssignableFrom(cls);
}","public void test07476() throws Throwable {
    Class<Byte> class0 = Byte.TYPE;
    Class<Float> class1 = Float.class;
    boolean boolean0 = ClassUtils.isAssignable(class1, class0, true);
    assertFalse(boolean0);
}","/**
 * <p>Checks if one <code>Class</code> can be assigned to a variable of
 * another <code>Class</code>.</p>
 *
 * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,
 * this method takes into account widenings of primitive classes and
 * <code>null</code>s.</p>
 *
 * <p>Primitive widenings allow an int to be assigned to a long, float or
 * double. This method returns the correct result for these cases.</p>
 *
 * <p><code>Null</code> may be assigned to any reference type. This method
 * will return <code>true</code> if <code>null</code> is passed in and the
 * toClass is non-primitive.</p>
 *
 * <p>Specifically, this method tests whether the type represented by the
 * specified <code>Class</code> parameter can be converted to the type
 * represented by this <code>Class</code> object via an identity conversion
 * widening primitive or widening reference conversion. See
 * <em><a href=""http://java.sun.com/docs/books/jls/"">The Java Language Specification</a></em>,
 * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>
 *
 * @param cls  the Class to check, may be null
 * @param toClass  the Class to try to assign into, returns false if null
 * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers
 * @return <code>true</code> if assignment possible
 */"
"public static boolean isAssignable(Class<?> cls, Class<?> toClass) {
    return isAssignable(cls, toClass, SystemUtils.isJavaVersionAtLeast(1.5f));
}","public void test07577() throws Throwable {
    Class<Integer> class0 = Integer.class;
    Class<?> class1 = ClassUtils.wrapperToPrimitive(class0);
    boolean boolean0 = ClassUtils.isAssignable(class1, class0);
    assertTrue(boolean0);
}","/**
 * <p>Checks if one <code>Class</code> can be assigned to a variable of
 * another <code>Class</code>.</p>
 *
 * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,
 * this method takes into account widenings of primitive classes and
 * <code>null</code>s.</p>
 *
 * <p>Primitive widenings allow an int to be assigned to a long, float or
 * double. This method returns the correct result for these cases.</p>
 *
 * <p><code>Null</code> may be assigned to any reference type. This method
 * will return <code>true</code> if <code>null</code> is passed in and the
 * toClass is non-primitive.</p>
 *
 * <p>Specifically, this method tests whether the type represented by the
 * specified <code>Class</code> parameter can be converted to the type
 * represented by this <code>Class</code> object via an identity conversion
 * widening primitive or widening reference conversion. See
 * <em><a href=""http://java.sun.com/docs/books/jls/"">The Java Language Specification</a></em>,
 * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>
 *
 * <p><strong>Since Lang 3.0,</strong> this method will default behavior for
 * calculating assignability between primitive and wrapper types <em>corresponding
 * to the running Java version</em>; i.e. autoboxing will be the default
 * behavior in VMs running Java versions >= 1.5.</p>
 *
 * @param cls  the Class to check, may be null
 * @param toClass  the Class to try to assign into, returns false if null
 * @return <code>true</code> if assignment possible
 */"
"public static boolean isAssignable(Class<?> cls, Class<?> toClass) {
    return isAssignable(cls, toClass, SystemUtils.isJavaVersionAtLeast(1.5f));
}","public void test07678() throws Throwable {
    Class<Integer> class0 = Integer.TYPE;
    boolean boolean0 = ClassUtils.isAssignable((Class<?>) null, class0);
    assertFalse(boolean0);
}","/**
 * <p>Checks if one <code>Class</code> can be assigned to a variable of
 * another <code>Class</code>.</p>
 *
 * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,
 * this method takes into account widenings of primitive classes and
 * <code>null</code>s.</p>
 *
 * <p>Primitive widenings allow an int to be assigned to a long, float or
 * double. This method returns the correct result for these cases.</p>
 *
 * <p><code>Null</code> may be assigned to any reference type. This method
 * will return <code>true</code> if <code>null</code> is passed in and the
 * toClass is non-primitive.</p>
 *
 * <p>Specifically, this method tests whether the type represented by the
 * specified <code>Class</code> parameter can be converted to the type
 * represented by this <code>Class</code> object via an identity conversion
 * widening primitive or widening reference conversion. See
 * <em><a href=""http://java.sun.com/docs/books/jls/"">The Java Language Specification</a></em>,
 * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>
 *
 * <p><strong>Since Lang 3.0,</strong> this method will default behavior for
 * calculating assignability between primitive and wrapper types <em>corresponding
 * to the running Java version</em>; i.e. autoboxing will be the default
 * behavior in VMs running Java versions >= 1.5.</p>
 *
 * @param cls  the Class to check, may be null
 * @param toClass  the Class to try to assign into, returns false if null
 * @return <code>true</code> if assignment possible
 */"
"public static Class<?>[] wrappersToPrimitives(Class<?>[] classes) {
    if (classes == null) {
        return null;
    }
    if (classes.length == 0) {
        return classes;
    }
    Class<?>[] convertedClasses = new Class[classes.length];
    for (int i = 0; i < classes.length; i++) {
        convertedClasses[i] = wrapperToPrimitive(classes[i]);
    }
    return convertedClasses;
}","public void test07779() throws Throwable {
    Class<Object> class0 = Object.class;
    Object[] objectArray0 = new Object[6];
    objectArray0[0] = (Object) ""Object"";
    objectArray0[1] = (Object) ""\"":d*gb"";
    objectArray0[2] = (Object) class0;
    objectArray0[3] = (Object) ""Object"";
    objectArray0[4] = (Object) ""\"":d*gb"";
    objectArray0[5] = objectArray0[0];
    Class<?>[] classArray0 = ClassUtils.toClass(objectArray0);
    Class<?>[] classArray1 = ClassUtils.wrappersToPrimitives(classArray0);
    assertNotNull(classArray1);
}","/**
 * <p>Converts the specified array of wrapper Class objects to an array of
 * its corresponding primitive Class objects.</p>
 *
 * <p>This method invokes <code>wrapperToPrimitive()</code> for each element
 * of the passed in array.</p>
 *
 * @param classes  the class array to convert, may be null or empty
 * @return an array which contains for each given class, the primitive class or
 * <b>null</b> if the original class is not a wrapper class. <code>null</code> if null input.
 * Empty array if an empty array passed in.
 * @see #wrapperToPrimitive(Class)
 * @since 2.4
 */"
"public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) {
    if (ArrayUtils.isSameLength(classArray, toClassArray) == false) {
        return false;
    }
    if (classArray == null) {
        classArray = ArrayUtils.EMPTY_CLASS_ARRAY;
    }
    if (toClassArray == null) {
        toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY;
    }
    for (int i = 0; i < classArray.length; i++) {
        if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) {
            return false;
        }
    }
    return true;
}","public void test07780() throws Throwable {
    Class<Object> class0 = Object.class;
    Object[] objectArray0 = new Object[6];
    objectArray0[0] = (Object) ""Object"";
    objectArray0[1] = (Object) ""\"":d*gb"";
    objectArray0[2] = (Object) class0;
    objectArray0[3] = (Object) ""Object"";
    objectArray0[4] = (Object) ""\"":d*gb"";
    objectArray0[5] = objectArray0[0];
    Class<?>[] classArray0 = ClassUtils.toClass(objectArray0);
    Class<?>[] classArray1 = ClassUtils.wrappersToPrimitives(classArray0);
    boolean boolean0 = ClassUtils.isAssignable(classArray1, classArray0, false);
    assertNotSame(classArray1, classArray0);
}","/**
 * <p>Checks if an array of Classes can be assigned to another array of Classes.</p>
 *
 * <p>This method calls {@link #isAssignable(Class, Class) isAssignable} for each
 * Class pair in the input arrays. It can be used to check if a set of arguments
 * (the first parameter) are suitably compatible with a set of method parameter types
 * (the second parameter).</p>
 *
 * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this
 * method takes into account widenings of primitive classes and
 * <code>null</code>s.</p>
 *
 * <p>Primitive widenings allow an int to be assigned to a <code>long</code>,
 * <code>float</code> or <code>double</code>. This method returns the correct
 * result for these cases.</p>
 *
 * <p><code>Null</code> may be assigned to any reference type. This method will
 * return <code>true</code> if <code>null</code> is passed in and the toClass is
 * non-primitive.</p>
 *
 * <p>Specifically, this method tests whether the type represented by the
 * specified <code>Class</code> parameter can be converted to the type
 * represented by this <code>Class</code> object via an identity conversion
 * widening primitive or widening reference conversion. See
 * <em><a href=""http://java.sun.com/docs/books/jls/"">The Java Language Specification</a></em>,
 * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>
 *
 * @param classArray  the array of Classes to check, may be <code>null</code>
 * @param toClassArray  the array of Classes to try to assign into, may be <code>null</code>
 * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers
 * @return <code>true</code> if assignment possible
 */"
"public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) {
    if (ArrayUtils.isSameLength(classArray, toClassArray) == false) {
        return false;
    }
    if (classArray == null) {
        classArray = ArrayUtils.EMPTY_CLASS_ARRAY;
    }
    if (toClassArray == null) {
        toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY;
    }
    for (int i = 0; i < classArray.length; i++) {
        if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) {
            return false;
        }
    }
    return true;
}","public void test07882() throws Throwable {
    boolean boolean0 = ClassUtils.isAssignable((Class<?>[]) null, (Class<?>[]) null, false);
    assertTrue(boolean0);
}","/**
 * <p>Checks if an array of Classes can be assigned to another array of Classes.</p>
 *
 * <p>This method calls {@link #isAssignable(Class, Class) isAssignable} for each
 * Class pair in the input arrays. It can be used to check if a set of arguments
 * (the first parameter) are suitably compatible with a set of method parameter types
 * (the second parameter).</p>
 *
 * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this
 * method takes into account widenings of primitive classes and
 * <code>null</code>s.</p>
 *
 * <p>Primitive widenings allow an int to be assigned to a <code>long</code>,
 * <code>float</code> or <code>double</code>. This method returns the correct
 * result for these cases.</p>
 *
 * <p><code>Null</code> may be assigned to any reference type. This method will
 * return <code>true</code> if <code>null</code> is passed in and the toClass is
 * non-primitive.</p>
 *
 * <p>Specifically, this method tests whether the type represented by the
 * specified <code>Class</code> parameter can be converted to the type
 * represented by this <code>Class</code> object via an identity conversion
 * widening primitive or widening reference conversion. See
 * <em><a href=""http://java.sun.com/docs/books/jls/"">The Java Language Specification</a></em>,
 * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>
 *
 * @param classArray  the array of Classes to check, may be <code>null</code>
 * @param toClassArray  the array of Classes to try to assign into, may be <code>null</code>
 * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers
 * @return <code>true</code> if assignment possible
 */"
"// Is assignable
// ----------------------------------------------------------------------
/**
 * <p>Checks if an array of Classes can be assigned to another array of Classes.</p>
 *
 * <p>This method calls {@link #isAssignable(Class, Class) isAssignable} for each
 * Class pair in the input arrays. It can be used to check if a set of arguments
 * (the first parameter) are suitably compatible with a set of method parameter types
 * (the second parameter).</p>
 *
 * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this
 * method takes into account widenings of primitive classes and
 * <code>null</code>s.</p>
 *
 * <p>Primitive widenings allow an int to be assigned to a <code>long</code>,
 * <code>float</code> or <code>double</code>. This method returns the correct
 * result for these cases.</p>
 *
 * <p><code>Null</code> may be assigned to any reference type. This method will
 * return <code>true</code> if <code>null</code> is passed in and the toClass is
 * non-primitive.</p>
 *
 * <p>Specifically, this method tests whether the type represented by the
 * specified <code>Class</code> parameter can be converted to the type
 * represented by this <code>Class</code> object via an identity conversion
 * widening primitive or widening reference conversion. See
 * <em><a href=""http://java.sun.com/docs/books/jls/"">The Java Language Specification</a></em>,
 * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>
 *
 * <p><strong>Since Lang 3.0,</strong> this method will default behavior for
 * calculating assignability between primitive and wrapper types <em>corresponding
 * to the running Java version</em>; i.e. autoboxing will be the default
 * behavior in VMs running Java versions >= 1.5.</p>
 *
 * @param classArray  the array of Classes to check, may be <code>null</code>
 * @param toClassArray  the array of Classes to try to assign into, may be <code>null</code>
 * @return <code>true</code> if assignment possible
 */
public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray) {
    return isAssignable(classArray, toClassArray, SystemUtils.isJavaVersionAtLeast(1.5f));
}","public void test07983() throws Throwable {
    Class<String>[] classArray0 = (Class<String>[]) Array.newInstance(Class.class, 5);
    Class<Boolean>[] classArray1 = (Class<Boolean>[]) Array.newInstance(Class.class, 2);
    boolean boolean0 = ClassUtils.isAssignable(classArray0, classArray1);
    assertFalse(boolean0);
}",""
"public static List<String> convertClassesToClassNames(List<Class<?>> classes) {
    if (classes == null) {
        return null;
    }
    List<String> classNames = new ArrayList<String>(classes.size());
    for (Class<?> cls : classes) {
        if (cls == null) {
            classNames.add(null);
        } else {
            classNames.add(cls.getName());
        }
    }
    return classNames;
}","public void test08185() throws Throwable {
    List<String> list0 = ClassUtils.convertClassesToClassNames((List<Class<?>>) null);
    assertNull(list0);
}","/**
 * <p>Given a <code>List</code> of <code>Class</code> objects, this method converts
 * them into class names.</p>
 *
 * <p>A new <code>List</code> is returned. <code>null</code> objects will be copied into
 * the returned list as <code>null</code>.</p>
 *
 * @param classes  the classes to change
 * @return a <code>List</code> of class names corresponding to the Class objects,
 *  <code>null</code> if null input
 * @throws ClassCastException if <code>classes</code> contains a non-<code>Class</code> entry
 */"
"// Convert list
// ----------------------------------------------------------------------
/**
 * <p>Given a <code>List</code> of class names, this method converts them into classes.</p>
 *
 * <p>A new <code>List</code> is returned. If the class name cannot be found, <code>null</code>
 * is stored in the <code>List</code>. If the class name in the <code>List</code> is
 * <code>null</code>, <code>null</code> is stored in the output <code>List</code>.</p>
 *
 * @param classNames  the classNames to change
 * @return a <code>List</code> of Class objects corresponding to the class names,
 *  <code>null</code> if null input
 * @throws ClassCastException if classNames contains a non String entry
 */
public static List<Class<?>> convertClassNamesToClasses(List<String> classNames) {
    if (classNames == null) {
        return null;
    }
    List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size());
    for (String className : classNames) {
        try {
            classes.add(Class.forName(className));
        } catch (Exception ex) {
            classes.add(null);
        }
    }
    return classes;
}","public void test08286() throws Throwable {
    List<Class<?>> list0 = ClassUtils.convertClassNamesToClasses((List<String>) null);
    assertNull(list0);
}",""
"public static List<Class<?>> getAllInterfaces(Class<?> cls) {
    if (cls == null) {
        return null;
    }
    LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<Class<?>>();
    getAllInterfaces(cls, interfacesFound);
    return new ArrayList<Class<?>>(interfacesFound);
}","public void test08488() throws Throwable {
    List<Class<?>> list0 = ClassUtils.getAllInterfaces((Class<?>) null);
    assertNull(list0);
}","/**
 * <p>Gets a <code>List</code> of all interfaces implemented by the given
 * class and its superclasses.</p>
 *
 * <p>The order is determined by looking through each interface in turn as
 * declared in the source file and following its hierarchy up. Then each
 * superclass is considered in the same way. Later duplicates are ignored,
 * so the order is maintained.</p>
 *
 * @param cls  the class to look up, may be <code>null</code>
 * @return the <code>List</code> of interfaces in order,
 *  <code>null</code> if null input
 */"
"// Superclasses/Superinterfaces
// ----------------------------------------------------------------------
/**
 * <p>Gets a <code>List</code> of superclasses for the given class.</p>
 *
 * @param cls  the class to look up, may be <code>null</code>
 * @return the <code>List</code> of superclasses in order going up from this one
 *  <code>null</code> if null input
 */
public static List<Class<?>> getAllSuperclasses(Class<?> cls) {
    if (cls == null) {
        return null;
    }
    List<Class<?>> classes = new ArrayList<Class<?>>();
    Class<?> superclass = cls.getSuperclass();
    while (superclass != null) {
        classes.add(superclass);
        superclass = superclass.getSuperclass();
    }
    return classes;
}","public void test08589() throws Throwable {
    List<Class<?>> list0 = ClassUtils.getAllSuperclasses((Class<?>) null);
    assertNull(list0);
}",""
"// Superclasses/Superinterfaces
// ----------------------------------------------------------------------
/**
 * <p>Gets a <code>List</code> of superclasses for the given class.</p>
 *
 * @param cls  the class to look up, may be <code>null</code>
 * @return the <code>List</code> of superclasses in order going up from this one
 *  <code>null</code> if null input
 */
public static List<Class<?>> getAllSuperclasses(Class<?> cls) {
    if (cls == null) {
        return null;
    }
    List<Class<?>> classes = new ArrayList<Class<?>>();
    Class<?> superclass = cls.getSuperclass();
    while (superclass != null) {
        classes.add(superclass);
        superclass = superclass.getSuperclass();
    }
    return classes;
}","public void test08691() throws Throwable {
    Class<Byte> class0 = Byte.class;
    List<Class<?>> list0 = ClassUtils.getAllSuperclasses(class0);
    assertNotNull(list0);
}",""
"public static String getPackageName(String className) {
    if (className == null || className.length() == 0) {
        return StringUtils.EMPTY;
    }
    // Strip array encoding
    while (className.charAt(0) == '[') {
        className = className.substring(1);
    }
    // Strip Object type encoding
    if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
        className = className.substring(1);
    }
    int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    if (i == -1) {
        return StringUtils.EMPTY;
    }
    return className.substring(0, i);
}","public void test08792() throws Throwable {
    String string0 = ClassUtils.getPackageName(""[java.lang.Long"");
    assertEquals(""java.lang"", string0);
}","/**
 * <p>Gets the package name from a <code>String</code>.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 * <p>If the class is unpackaged, return an empty string.</p>
 *
 * @param className  the className to get the package name for, may be <code>null</code>
 * @return the package name or an empty string
 */"
"public static String getPackageName(String className) {
    if (className == null || className.length() == 0) {
        return StringUtils.EMPTY;
    }
    // Strip array encoding
    while (className.charAt(0) == '[') {
        className = className.substring(1);
    }
    // Strip Object type encoding
    if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
        className = className.substring(1);
    }
    int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    if (i == -1) {
        return StringUtils.EMPTY;
    }
    return className.substring(0, i);
}","public void test08893() throws Throwable {
    String string0 = ClassUtils.getPackageName("""");
    assertEquals("""", string0);
}","/**
 * <p>Gets the package name from a <code>String</code>.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 * <p>If the class is unpackaged, return an empty string.</p>
 *
 * @param className  the className to get the package name for, may be <code>null</code>
 * @return the package name or an empty string
 */"
"public static String getPackageName(String className) {
    if (className == null || className.length() == 0) {
        return StringUtils.EMPTY;
    }
    // Strip array encoding
    while (className.charAt(0) == '[') {
        className = className.substring(1);
    }
    // Strip Object type encoding
    if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
        className = className.substring(1);
    }
    int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    if (i == -1) {
        return StringUtils.EMPTY;
    }
    return className.substring(0, i);
}","public void test08994() throws Throwable {
    String string0 = ClassUtils.getPackageName((String) null);
    assertEquals("""", string0);
}","/**
 * <p>Gets the package name from a <code>String</code>.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 * <p>If the class is unpackaged, return an empty string.</p>
 *
 * @param className  the className to get the package name for, may be <code>null</code>
 * @return the package name or an empty string
 */"
"public static String getPackageName(Class<?> cls) {
    if (cls == null) {
        return StringUtils.EMPTY;
    }
    return getPackageName(cls.getName());
}","public void test09095() throws Throwable {
    String string0 = ClassUtils.getPackageName((Class<?>) null);
    assertEquals("""", string0);
}","/**
 * <p>Gets the package name of a <code>Class</code>.</p>
 *
 * @param cls  the class to get the package name for, may be <code>null</code>.
 * @return the package name or an empty string
 */"
"// Package name
// ----------------------------------------------------------------------
/**
 * <p>Gets the package name of an <code>Object</code>.</p>
 *
 * @param object  the class to get the package name for, may be null
 * @param valueIfNull  the value to return if null
 * @return the package name of the object, or the null value
 */
public static String getPackageName(Object object, String valueIfNull) {
    if (object == null) {
        return valueIfNull;
    }
    return getPackageName(object.getClass());
}","public void test09196() throws Throwable {
    String string0 = ClassUtils.getPackageName((Object) null, ""("");
    assertEquals(""("", string0);
}",""
"// Package name
// ----------------------------------------------------------------------
/**
 * <p>Gets the package name of an <code>Object</code>.</p>
 *
 * @param object  the class to get the package name for, may be null
 * @param valueIfNull  the value to return if null
 * @return the package name of the object, or the null value
 */
public static String getPackageName(Object object, String valueIfNull) {
    if (object == null) {
        return valueIfNull;
    }
    return getPackageName(object.getClass());
}","public void test09297() throws Throwable {
    Class<Integer> class0 = Integer.TYPE;
    String string0 = ClassUtils.getPackageName((Object) class0, "","");
    assertEquals(""java.lang"", string0);
}",""
"public static String getShortClassName(String className) {
    if (className == null) {
        return StringUtils.EMPTY;
    }
    if (className.length() == 0) {
        return StringUtils.EMPTY;
    }
    StringBuilder arrayPrefix = new StringBuilder();
    // Handle array encoding
    if (className.startsWith(""["")) {
        while (className.charAt(0) == '[') {
            className = className.substring(1);
            arrayPrefix.append(""[]"");
        }
        // Strip Object type encoding
        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
            className = className.substring(1, className.length() - 1);
        }
    }
    if (reverseAbbreviationMap.containsKey(className)) {
        className = reverseAbbreviationMap.get(className);
    }
    int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);
    String out = className.substring(lastDotIdx + 1);
    if (innerIdx != -1) {
        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
    }
    return out + arrayPrefix;
}","public void test09398() throws Throwable {
    String string0 = ClassUtils.getShortClassName(""D"");
    assertEquals(""double"", string0);
}","/**
 * <p>Gets the class name minus the package name from a String.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 *
 * @param className  the className to get the short name for
 * @return the class name of the class without the package name or an empty string
 */"
"public static String getShortClassName(String className) {
    if (className == null) {
        return StringUtils.EMPTY;
    }
    if (className.length() == 0) {
        return StringUtils.EMPTY;
    }
    StringBuilder arrayPrefix = new StringBuilder();
    // Handle array encoding
    if (className.startsWith(""["")) {
        while (className.charAt(0) == '[') {
            className = className.substring(1);
            arrayPrefix.append(""[]"");
        }
        // Strip Object type encoding
        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
            className = className.substring(1, className.length() - 1);
        }
    }
    if (reverseAbbreviationMap.containsKey(className)) {
        className = reverseAbbreviationMap.get(className);
    }
    int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);
    String out = className.substring(lastDotIdx + 1);
    if (innerIdx != -1) {
        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
    }
    return out + arrayPrefix;
}","public void test09499() throws Throwable {
    String string0 = ClassUtils.getShortClassName(""[L"");
    assertEquals(""L[]"", string0);
}","/**
 * <p>Gets the class name minus the package name from a String.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 *
 * @param className  the className to get the short name for
 * @return the class name of the class without the package name or an empty string
 */"
"public static String getShortClassName(String className) {
    if (className == null) {
        return StringUtils.EMPTY;
    }
    if (className.length() == 0) {
        return StringUtils.EMPTY;
    }
    StringBuilder arrayPrefix = new StringBuilder();
    // Handle array encoding
    if (className.startsWith(""["")) {
        while (className.charAt(0) == '[') {
            className = className.substring(1);
            arrayPrefix.append(""[]"");
        }
        // Strip Object type encoding
        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
            className = className.substring(1, className.length() - 1);
        }
    }
    if (reverseAbbreviationMap.containsKey(className)) {
        className = reverseAbbreviationMap.get(className);
    }
    int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);
    String out = className.substring(lastDotIdx + 1);
    if (innerIdx != -1) {
        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
    }
    return out + arrayPrefix;
}","public void test095100() throws Throwable {
    String string0 = ClassUtils.getShortClassName("""");
    assertEquals("""", string0);
}","/**
 * <p>Gets the class name minus the package name from a String.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 *
 * @param className  the className to get the short name for
 * @return the class name of the class without the package name or an empty string
 */"
"public static String getShortClassName(String className) {
    if (className == null) {
        return StringUtils.EMPTY;
    }
    if (className.length() == 0) {
        return StringUtils.EMPTY;
    }
    StringBuilder arrayPrefix = new StringBuilder();
    // Handle array encoding
    if (className.startsWith(""["")) {
        while (className.charAt(0) == '[') {
            className = className.substring(1);
            arrayPrefix.append(""[]"");
        }
        // Strip Object type encoding
        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
            className = className.substring(1, className.length() - 1);
        }
    }
    if (reverseAbbreviationMap.containsKey(className)) {
        className = reverseAbbreviationMap.get(className);
    }
    int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);
    String out = className.substring(lastDotIdx + 1);
    if (innerIdx != -1) {
        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
    }
    return out + arrayPrefix;
}","public void test096101() throws Throwable {
    String string0 = ClassUtils.getShortClassName((String) null);
    assertEquals("""", string0);
}","/**
 * <p>Gets the class name minus the package name from a String.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 *
 * @param className  the className to get the short name for
 * @return the class name of the class without the package name or an empty string
 */"
"public static String getShortClassName(Class<?> cls) {
    if (cls == null) {
        return StringUtils.EMPTY;
    }
    return getShortClassName(cls.getName());
}","public void test097102() throws Throwable {
    String string0 = ClassUtils.getShortClassName((Class<?>) null);
    assertEquals("""", string0);
}","/**
 * <p>Gets the class name minus the package name from a <code>Class</code>.</p>
 *
 * @param cls  the class to get the short name for.
 * @return the class name without the package name or an empty string
 */"
"// Short class name
// ----------------------------------------------------------------------
/**
 * <p>Gets the class name minus the package name for an <code>Object</code>.</p>
 *
 * @param object  the class to get the short name for, may be null
 * @param valueIfNull  the value to return if null
 * @return the class name of the object without the package name, or the null value
 */
public static String getShortClassName(Object object, String valueIfNull) {
    if (object == null) {
        return valueIfNull;
    }
    return getShortClassName(object.getClass());
}","public void test098103() throws Throwable {
    String string0 = ClassUtils.getShortClassName((Object) null, ""[java.lang.Long"");
    assertEquals(""[java.lang.Long"", string0);
}",""
"// Short class name
// ----------------------------------------------------------------------
/**
 * <p>Gets the class name minus the package name for an <code>Object</code>.</p>
 *
 * @param object  the class to get the short name for, may be null
 * @param valueIfNull  the value to return if null
 * @return the class name of the object without the package name, or the null value
 */
public static String getShortClassName(Object object, String valueIfNull) {
    if (object == null) {
        return valueIfNull;
    }
    return getShortClassName(object.getClass());
}","public void test099104() throws Throwable {
    Object object0 = new Object();
    String string0 = ClassUtils.getShortClassName(object0, """");
    assertEquals(""Object"", string0);
}",""
"public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException {
    return getClass(classLoader, className, true);
}","public void test100105() throws Throwable {
    ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
    try {
        ClassUtils.getClass(classLoader0, ""$"");
        fail(""Expecting exception: ClassNotFoundException"");
    } catch (ClassNotFoundException e) {
    }
}","/**
 * Returns the (initialized) class represented by <code>className</code>
 * using the <code>classLoader</code>.  This implementation supports names
 * like ""<code>java.lang.String[]</code>"" as well as
 * ""<code>[Ljava.lang.String;</code>"".
 *
 * @param classLoader  the class loader to use to load the class
 * @param className  the class name
 * @return the class represented by <code>className</code> using the <code>classLoader</code>
 * @throws ClassNotFoundException if the class is not found
 */"
"public ClassUtils() {
    super();
}","public void test101106() throws Throwable {
    ClassUtils classUtils0 = new ClassUtils();
    assertEquals('.', ClassUtils.PACKAGE_SEPARATOR_CHAR);
}","/**
 * <p>ClassUtils instances should NOT be constructed in standard programming.
 * Instead, the class should be used as
 * <code>ClassUtils.getShortClassName(cls)</code>.</p>
 *
 * <p>This constructor is public to permit tools that require a JavaBean
 * instance to operate.</p>
 */"
"public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {
    if (toClass == null) {
        return false;
    }
    // have to check for null, as isAssignableFrom doesn't
    if (cls == null) {
        return !(toClass.isPrimitive());
    }
    //autoboxing:
    if (autoboxing) {
        if (cls.isPrimitive() && !toClass.isPrimitive()) {
            cls = primitiveToWrapper(cls);
            if (cls == null) {
                return false;
            }
        }
        if (toClass.isPrimitive() && !cls.isPrimitive()) {
            cls = wrapperToPrimitive(cls);
            if (cls == null) {
                return false;
            }
        }
    }
    if (cls.equals(toClass)) {
        return true;
    }
    if (cls.isPrimitive()) {
        if (toClass.isPrimitive() == false) {
            return false;
        }
        if (Integer.TYPE.equals(cls)) {
            return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Long.TYPE.equals(cls)) {
            return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Boolean.TYPE.equals(cls)) {
            return false;
        }
        if (Double.TYPE.equals(cls)) {
            return false;
        }
        if (Float.TYPE.equals(cls)) {
            return Double.TYPE.equals(toClass);
        }
        if (Character.TYPE.equals(cls)) {
            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Short.TYPE.equals(cls)) {
            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Byte.TYPE.equals(cls)) {
            return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        // should never get here
        return false;
    }
    return toClass.isAssignableFrom(cls);
}","public void test102107() throws Throwable {
    Class<Long> class0 = Long.TYPE;
    Class<Object> class1 = Object.class;
    boolean boolean0 = ClassUtils.isAssignable(class1, class0, true);
    assertFalse(boolean0);
}","/**
 * <p>Checks if one <code>Class</code> can be assigned to a variable of
 * another <code>Class</code>.</p>
 *
 * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,
 * this method takes into account widenings of primitive classes and
 * <code>null</code>s.</p>
 *
 * <p>Primitive widenings allow an int to be assigned to a long, float or
 * double. This method returns the correct result for these cases.</p>
 *
 * <p><code>Null</code> may be assigned to any reference type. This method
 * will return <code>true</code> if <code>null</code> is passed in and the
 * toClass is non-primitive.</p>
 *
 * <p>Specifically, this method tests whether the type represented by the
 * specified <code>Class</code> parameter can be converted to the type
 * represented by this <code>Class</code> object via an identity conversion
 * widening primitive or widening reference conversion. See
 * <em><a href=""http://java.sun.com/docs/books/jls/"">The Java Language Specification</a></em>,
 * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>
 *
 * @param cls  the Class to check, may be null
 * @param toClass  the Class to try to assign into, returns false if null
 * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers
 * @return <code>true</code> if assignment possible
 */"
