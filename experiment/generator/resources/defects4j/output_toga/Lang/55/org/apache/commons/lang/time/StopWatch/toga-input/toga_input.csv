focal_method,test_prefix,docstring
"public String toString() {
    return DurationFormatUtils.formatDurationHMS(getTime());
}","public void test000() throws Throwable {
    StopWatch stopWatch0 = new StopWatch();
    stopWatch0.start();
    stopWatch0.split();
    stopWatch0.suspend();
    stopWatch0.unsplit();
    String string0 = stopWatch0.toString();
    assertNotNull(string0);
}","/**
 * <p>Gets a summary of the time that the stopwatch recorded as a string.</p>
 *
 * <p>The format used is ISO8601-like,
 * <i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.</p>
 *
 * @return the time as a String
 */"
"public void resume() {
    if (this.runningState != STATE_SUSPENDED) {
        throw new IllegalStateException(""Stopwatch must be suspended to resume. "");
    }
    startTime += (System.currentTimeMillis() - stopTime);
    stopTime = -1;
    this.runningState = STATE_RUNNING;
}","public void test011() throws Throwable {
    StopWatch stopWatch0 = new StopWatch();
    stopWatch0.start();
    stopWatch0.split();
    stopWatch0.suspend();
    stopWatch0.unsplit();
    stopWatch0.resume();
}","/**
 * <p>Resume the stopwatch after a suspend.</p>
 *
 * <p>This method resumes the watch after it was suspended. The watch will not include
 * time between the suspend and resume calls in the total time.</p>
 *
 * @throws IllegalStateException if the StopWatch has not been suspended.
 */"
"public void start() {
    if (this.runningState == STATE_STOPPED) {
        throw new IllegalStateException(""Stopwatch must be reset before being restarted. "");
    }
    if (this.runningState != STATE_UNSTARTED) {
        throw new IllegalStateException(""Stopwatch already started. "");
    }
    stopTime = -1;
    startTime = System.currentTimeMillis();
    this.runningState = STATE_RUNNING;
}","public void test022() throws Throwable {
    StopWatch stopWatch0 = new StopWatch();
    stopWatch0.start();
    stopWatch0.suspend();
    // Undeclared exception!
    try {
        stopWatch0.start();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Stopwatch already started.
        //
        verifyException(""org.apache.commons.lang.time.StopWatch"", e);
    }
}","/**
 * <p>Start the stopwatch.</p>
 *
 * <p>This method starts a new timing session, clearing any previous values.</p>
 *
 * @throws IllegalStateException if the StopWatch is already running.
 */"
"public long getTime() {
    if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) {
        return this.stopTime - this.startTime;
    } else if (this.runningState == STATE_UNSTARTED) {
        return 0;
    } else if (this.runningState == STATE_RUNNING) {
        return System.currentTimeMillis() - this.startTime;
    }
    throw new RuntimeException(""Illegal running state has occured. "");
}","public void test033() throws Throwable {
    StopWatch stopWatch0 = new StopWatch();
    stopWatch0.start();
    System.setCurrentTimeMillis((-503L));
    long long0 = stopWatch0.getTime();
    assertEquals((-1392409281823L), long0);
}","/**
 * <p>Get the time on the stopwatch.</p>
 *
 * <p>This is either the time between the start and the moment this method
 * is called, or the amount of time between start and stop.</p>
 *
 * @return the time in milliseconds
 */"
"public long getSplitTime() {
    if (this.splitState != STATE_SPLIT) {
        throw new IllegalStateException(""Stopwatch must be split to get the split time. "");
    }
    return this.stopTime - this.startTime;
}","public void test044() throws Throwable {
    StopWatch stopWatch0 = new StopWatch();
    stopWatch0.start();
    stopWatch0.split();
    stopWatch0.suspend();
    stopWatch0.resume();
    long long0 = stopWatch0.getSplitTime();
    assertEquals((-1392409281321L), long0);
}","/**
 * <p>Get the split time on the stopwatch.</p>
 *
 * <p>This is the time between start and latest split. </p>
 *
 * @return the split time in milliseconds
 *
 * @throws IllegalStateException if the StopWatch has not yet been split.
 * @since 2.1
 */"
"public long getSplitTime() {
    if (this.splitState != STATE_SPLIT) {
        throw new IllegalStateException(""Stopwatch must be split to get the split time. "");
    }
    return this.stopTime - this.startTime;
}","public void test055() throws Throwable {
    StopWatch stopWatch0 = new StopWatch();
    stopWatch0.start();
    stopWatch0.split();
    long long0 = stopWatch0.getSplitTime();
    assertEquals(0L, long0);
}","/**
 * <p>Get the split time on the stopwatch.</p>
 *
 * <p>This is the time between start and latest split. </p>
 *
 * @return the split time in milliseconds
 *
 * @throws IllegalStateException if the StopWatch has not yet been split.
 * @since 2.1
 */"
"public long getSplitTime() {
    if (this.splitState != STATE_SPLIT) {
        throw new IllegalStateException(""Stopwatch must be split to get the split time. "");
    }
    return this.stopTime - this.startTime;
}","public void test066() throws Throwable {
    StopWatch stopWatch0 = new StopWatch();
    // Undeclared exception!
    try {
        stopWatch0.getSplitTime();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Stopwatch must be split to get the split time.
        //
        verifyException(""org.apache.commons.lang.time.StopWatch"", e);
    }
}","/**
 * <p>Get the split time on the stopwatch.</p>
 *
 * <p>This is the time between start and latest split. </p>
 *
 * @return the split time in milliseconds
 *
 * @throws IllegalStateException if the StopWatch has not yet been split.
 * @since 2.1
 */"
"public long getTime() {
    if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) {
        return this.stopTime - this.startTime;
    } else if (this.runningState == STATE_UNSTARTED) {
        return 0;
    } else if (this.runningState == STATE_RUNNING) {
        return System.currentTimeMillis() - this.startTime;
    }
    throw new RuntimeException(""Illegal running state has occured. "");
}","public void test077() throws Throwable {
    StopWatch stopWatch0 = new StopWatch();
    stopWatch0.start();
    long long0 = stopWatch0.getTime();
    assertEquals(0L, long0);
}","/**
 * <p>Get the time on the stopwatch.</p>
 *
 * <p>This is either the time between the start and the moment this method
 * is called, or the amount of time between start and stop.</p>
 *
 * @return the time in milliseconds
 */"
"public long getTime() {
    if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) {
        return this.stopTime - this.startTime;
    } else if (this.runningState == STATE_UNSTARTED) {
        return 0;
    } else if (this.runningState == STATE_RUNNING) {
        return System.currentTimeMillis() - this.startTime;
    }
    throw new RuntimeException(""Illegal running state has occured. "");
}","public void test088() throws Throwable {
    StopWatch stopWatch0 = new StopWatch();
    stopWatch0.start();
    stopWatch0.stop();
    long long0 = stopWatch0.getTime();
    assertEquals(0L, long0);
}","/**
 * <p>Get the time on the stopwatch.</p>
 *
 * <p>This is either the time between the start and the moment this method
 * is called, or the amount of time between start and stop.</p>
 *
 * @return the time in milliseconds
 */"
"public long getTime() {
    if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) {
        return this.stopTime - this.startTime;
    } else if (this.runningState == STATE_UNSTARTED) {
        return 0;
    } else if (this.runningState == STATE_RUNNING) {
        return System.currentTimeMillis() - this.startTime;
    }
    throw new RuntimeException(""Illegal running state has occured. "");
}","public void test099() throws Throwable {
    StopWatch stopWatch0 = new StopWatch();
    long long0 = stopWatch0.getTime();
    assertEquals(0L, long0);
}","/**
 * <p>Get the time on the stopwatch.</p>
 *
 * <p>This is either the time between the start and the moment this method
 * is called, or the amount of time between start and stop.</p>
 *
 * @return the time in milliseconds
 */"
"public long getTime() {
    if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) {
        return this.stopTime - this.startTime;
    } else if (this.runningState == STATE_UNSTARTED) {
        return 0;
    } else if (this.runningState == STATE_RUNNING) {
        return System.currentTimeMillis() - this.startTime;
    }
    throw new RuntimeException(""Illegal running state has occured. "");
}","public void test1010() throws Throwable {
    StopWatch stopWatch0 = new StopWatch();
    stopWatch0.start();
    stopWatch0.suspend();
    long long0 = stopWatch0.getTime();
    assertEquals(0L, long0);
}","/**
 * <p>Get the time on the stopwatch.</p>
 *
 * <p>This is either the time between the start and the moment this method
 * is called, or the amount of time between start and stop.</p>
 *
 * @return the time in milliseconds
 */"
"public String toSplitString() {
    return DurationFormatUtils.formatDurationHMS(getSplitTime());
}","public void test1111() throws Throwable {
    StopWatch stopWatch0 = new StopWatch();
    stopWatch0.start();
    stopWatch0.split();
    String string0 = stopWatch0.toSplitString();
    assertNotNull(string0);
}","/**
 * <p>Gets a summary of the split time that the stopwatch recorded as a string.</p>
 *
 * <p>The format used is ISO8601-like,
 * <i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.</p>
 *
 * @return the split time as a String
 * @since 2.1
 */"
"public void resume() {
    if (this.runningState != STATE_SUSPENDED) {
        throw new IllegalStateException(""Stopwatch must be suspended to resume. "");
    }
    startTime += (System.currentTimeMillis() - stopTime);
    stopTime = -1;
    this.runningState = STATE_RUNNING;
}","public void test1212() throws Throwable {
    StopWatch stopWatch0 = new StopWatch();
    // Undeclared exception!
    try {
        stopWatch0.resume();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Stopwatch must be suspended to resume.
        //
        verifyException(""org.apache.commons.lang.time.StopWatch"", e);
    }
}","/**
 * <p>Resume the stopwatch after a suspend.</p>
 *
 * <p>This method resumes the watch after it was suspended. The watch will not include
 * time between the suspend and resume calls in the total time.</p>
 *
 * @throws IllegalStateException if the StopWatch has not been suspended.
 */"
"public void suspend() {
    if (this.runningState != STATE_RUNNING) {
        throw new IllegalStateException(""Stopwatch must be running to suspend. "");
    }
    stopTime = System.currentTimeMillis();
    this.runningState = STATE_SUSPENDED;
}","public void test1313() throws Throwable {
    StopWatch stopWatch0 = new StopWatch();
    // Undeclared exception!
    try {
        stopWatch0.suspend();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Stopwatch must be running to suspend.
        //
        verifyException(""org.apache.commons.lang.time.StopWatch"", e);
    }
}","/**
 * <p>Suspend the stopwatch for later resumption.</p>
 *
 * <p>This method suspends the watch until it is resumed. The watch will not include
 * time between the suspend and resume calls in the total time.</p>
 *
 * @throws IllegalStateException if the StopWatch is not currently running.
 */"
"public void unsplit() {
    if (this.splitState != STATE_SPLIT) {
        throw new IllegalStateException(""Stopwatch has not been split. "");
    }
    stopTime = -1;
    this.splitState = STATE_UNSPLIT;
}","public void test1414() throws Throwable {
    StopWatch stopWatch0 = new StopWatch();
    // Undeclared exception!
    try {
        stopWatch0.unsplit();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Stopwatch has not been split.
        //
        verifyException(""org.apache.commons.lang.time.StopWatch"", e);
    }
}","/**
 * <p>Remove a split.</p>
 *
 * <p>This method clears the stop time. The start time is unaffected, enabling
 * timing from the original start point to continue.</p>
 *
 * @throws IllegalStateException if the StopWatch has not been split.
 */"
"public void split() {
    if (this.runningState != STATE_RUNNING) {
        throw new IllegalStateException(""Stopwatch is not running. "");
    }
    stopTime = System.currentTimeMillis();
    this.splitState = STATE_SPLIT;
}","public void test1515() throws Throwable {
    StopWatch stopWatch0 = new StopWatch();
    // Undeclared exception!
    try {
        stopWatch0.split();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Stopwatch is not running.
        //
        verifyException(""org.apache.commons.lang.time.StopWatch"", e);
    }
}","/**
 * <p>Split the time.</p>
 *
 * <p>This method sets the stop time of the watch to allow a time to be extracted.
 * The start time is unaffected, enabling {@link #unsplit()} to continue the
 * timing from the original start point.</p>
 *
 * @throws IllegalStateException if the StopWatch is not running.
 */"
"public void stop() {
    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {
        throw new IllegalStateException(""Stopwatch is not running. "");
    }
    stopTime = System.currentTimeMillis();
    this.runningState = STATE_STOPPED;
}","public void test1616() throws Throwable {
    StopWatch stopWatch0 = new StopWatch();
    stopWatch0.start();
    stopWatch0.suspend();
    stopWatch0.stop();
}","/**
 * <p>Stop the stopwatch.</p>
 *
 * <p>This method ends a new timing session, allowing the time to be retrieved.</p>
 *
 * @throws IllegalStateException if the StopWatch is not running.
 */"
"public void stop() {
    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {
        throw new IllegalStateException(""Stopwatch is not running. "");
    }
    stopTime = System.currentTimeMillis();
    this.runningState = STATE_STOPPED;
}","public void test1717() throws Throwable {
    StopWatch stopWatch0 = new StopWatch();
    // Undeclared exception!
    try {
        stopWatch0.stop();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Stopwatch is not running.
        //
        verifyException(""org.apache.commons.lang.time.StopWatch"", e);
    }
}","/**
 * <p>Stop the stopwatch.</p>
 *
 * <p>This method ends a new timing session, allowing the time to be retrieved.</p>
 *
 * @throws IllegalStateException if the StopWatch is not running.
 */"
"public void start() {
    if (this.runningState == STATE_STOPPED) {
        throw new IllegalStateException(""Stopwatch must be reset before being restarted. "");
    }
    if (this.runningState != STATE_UNSTARTED) {
        throw new IllegalStateException(""Stopwatch already started. "");
    }
    stopTime = -1;
    startTime = System.currentTimeMillis();
    this.runningState = STATE_RUNNING;
}","public void test1818() throws Throwable {
    StopWatch stopWatch0 = new StopWatch();
    stopWatch0.start();
    stopWatch0.stop();
    // Undeclared exception!
    try {
        stopWatch0.start();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Stopwatch must be reset before being restarted.
        //
        verifyException(""org.apache.commons.lang.time.StopWatch"", e);
    }
}","/**
 * <p>Start the stopwatch.</p>
 *
 * <p>This method starts a new timing session, clearing any previous values.</p>
 *
 * @throws IllegalStateException if the StopWatch is already running.
 */"
"public String toSplitString() {
    return DurationFormatUtils.formatDurationHMS(getSplitTime());
}","public void test1919() throws Throwable {
    StopWatch stopWatch0 = new StopWatch();
    // Undeclared exception!
    try {
        stopWatch0.toSplitString();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Stopwatch must be split to get the split time.
        //
        verifyException(""org.apache.commons.lang.time.StopWatch"", e);
    }
}","/**
 * <p>Gets a summary of the split time that the stopwatch recorded as a string.</p>
 *
 * <p>The format used is ISO8601-like,
 * <i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.</p>
 *
 * @return the split time as a String
 * @since 2.1
 */"
"public void reset() {
    this.runningState = STATE_UNSTARTED;
    this.splitState = STATE_UNSPLIT;
    startTime = -1;
    stopTime = -1;
}","public void test2020() throws Throwable {
    StopWatch stopWatch0 = new StopWatch();
    stopWatch0.reset();
}","/**
 * <p>Resets the stopwatch. Stops it if need be. </p>
 *
 * <p>This method clears the internal values to allow the object to be reused.</p>
 */"
