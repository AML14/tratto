focal_method,test_prefix,docstring
"public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) {
    return splitByWholeSeparatorWorker(str, separator, max, true);
}","public void test0000() throws Throwable {
    String[] stringArray0 = StringUtils.splitByWholeSeparatorPreserveAllTokens(""org.apache.commons.lang3.StringUtils"", ""org.apache.commons.lang3.StringUtils"", 1);
    assertEquals(1, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array, separator string specified.
 * Returns a maximum of <code>max</code> substrings.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as separators for empty tokens.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> separator splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *, *)               = null
 * StringUtils.splitByWholeSeparatorPreserveAllTokens("""", *, *)                 = []
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(""ab de fg"", null, 0)      = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(""ab   de fg"", null, 0)    = [""ab"", """", """", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(""ab:cd:ef"", "":"", 2)       = [""ab"", ""cd:ef""]
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(""ab-!-cd-!-ef"", ""-!-"", 5) = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(""ab-!-cd-!-ef"", ""-!-"", 2) = [""ab"", ""cd-!-ef""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @param separator  String containing the String to be used as a delimiter,
 *  <code>null</code> splits on whitespace
 * @param max  the maximum number of elements to include in the returned
 *  array. A zero or negative value implies no limit.
 * @return an array of parsed Strings, <code>null</code> if null String was input
 * @since 2.4
 */"
"public static int indexOfIgnoreCase(String str, String searchStr) {
    return indexOfIgnoreCase(str, searchStr, 0);
}","public void test0012() throws Throwable {
    int int0 = StringUtils.indexOfIgnoreCase(""h#"", """");
    assertEquals(0, int0);
}","/**
 * <p>Case in-sensitive find of the first index within a String.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A negative start position is treated as zero.
 * An empty ("""") search String always matches.
 * A start position greater than the string length only matches
 * an empty search String.</p>
 *
 * <pre>
 * StringUtils.indexOfIgnoreCase(null, *)          = -1
 * StringUtils.indexOfIgnoreCase(*, null)          = -1
 * StringUtils.indexOfIgnoreCase("""", """")           = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""a"")  = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""b"")  = 2
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""ab"") = 1
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @return the first index of the search String,
 *  -1 if no match or <code>null</code> string input
 * @since 2.5
 */"
"public static int length(CharSequence cs) {
    return CharSequenceUtils.length(cs);
}","public void test0023() throws Throwable {
    int int0 = StringUtils.length("""");
    assertEquals(0, int0);
}","/**
 * Gets a CharSequence length or <code>0</code> if the CharSequence is
 * <code>null</code>.
 *
 * @param cs
 *            a CharSequence or <code>null</code>
 * @return CharSequence length or <code>0</code> if the CharSequence is
 *         <code>null</code>.
 * @since 2.4
 * @deprecated See {@link CharSequenceUtils#length(CharSequence)}
 */"
"// endsWith
//-----------------------------------------------------------------------
/**
 * <p>Check if a String ends with a specified suffix.</p>
 *
 * <p><code>null</code>s are handled without exceptions. Two <code>null</code>
 * references are considered to be equal. The comparison is case sensitive.</p>
 *
 * <pre>
 * StringUtils.endsWith(null, null)      = true
 * StringUtils.endsWith(null, ""def"")     = false
 * StringUtils.endsWith(""abcdef"", null)  = false
 * StringUtils.endsWith(""abcdef"", ""def"") = true
 * StringUtils.endsWith(""ABCDEF"", ""def"") = false
 * StringUtils.endsWith(""ABCDEF"", ""cde"") = false
 * </pre>
 *
 * @see java.lang.String#endsWith(String)
 * @param str  the String to check, may be null
 * @param suffix the suffix to find, may be null
 * @return <code>true</code> if the String ends with the suffix, case sensitive, or
 *  both <code>null</code>
 * @since 2.4
 */
public static boolean endsWith(String str, String suffix) {
    return endsWith(str, suffix, false);
}","public void test0034() throws Throwable {
    boolean boolean0 = StringUtils.endsWith((String) null, (String) null);
    assertTrue(boolean0);
}",""
"public StringUtils() {
    super();
}","public void test0045() throws Throwable {
    StringUtils stringUtils0 = new StringUtils();
    assertEquals((-1), StringUtils.INDEX_NOT_FOUND);
}","/**
 * <p><code>StringUtils</code> instances should NOT be constructed in
 * standard programming. Instead, the class should be used as
 * <code>StringUtils.trim("" foo "");</code>.</p>
 *
 * <p>This constructor is public to permit tools that require a JavaBean
 * instance to operate.</p>
 */"
"public static String abbreviate(String str, int offset, int maxWidth) {
    if (str == null) {
        return null;
    }
    if (maxWidth < 4) {
        throw new IllegalArgumentException(""Minimum abbreviation width is 4"");
    }
    if (str.length() <= maxWidth) {
        return str;
    }
    if (offset > str.length()) {
        offset = str.length();
    }
    if ((str.length() - offset) < (maxWidth - 3)) {
        offset = str.length() - (maxWidth - 3);
    }
    final String abrevMarker = ""..."";
    if (offset <= 4) {
        return str.substring(0, maxWidth - 3) + abrevMarker;
    }
    if (maxWidth < 7) {
        throw new IllegalArgumentException(""Minimum abbreviation width with offset is 7"");
    }
    if ((offset + (maxWidth - 3)) < str.length()) {
        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);
    }
    return abrevMarker + str.substring(str.length() - (maxWidth - 3));
}","public void test0056() throws Throwable {
    String string0 = StringUtils.abbreviate("" and replace array lengths don"", 13, 13);
    assertNotNull(string0);
}","/**
 * <p>Abbreviates a String using ellipses. This will turn
 * ""Now is the time for all good men"" into ""...is the time for...""</p>
 *
 * <p>Works like <code>abbreviate(String, int)</code>, but allows you to specify
 * a ""left edge"" offset.  Note that this left edge is not necessarily going to
 * be the leftmost character in the result, or the first character following the
 * ellipses, but it will appear somewhere in the result.
 *
 * <p>In no case will it return a String of length greater than
 * <code>maxWidth</code>.</p>
 *
 * <pre>
 * StringUtils.abbreviate(null, *, *)                = null
 * StringUtils.abbreviate("""", 0, 4)                  = """"
 * StringUtils.abbreviate(""abcdefghijklmno"", -1, 10) = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 0, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 1, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 4, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 5, 10)  = ""...fghi...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 6, 10)  = ""...ghij...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 8, 10)  = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghijklmno"", 10, 10) = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghijklmno"", 12, 10) = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghij"", 0, 3)        = IllegalArgumentException
 * StringUtils.abbreviate(""abcdefghij"", 5, 6)        = IllegalArgumentException
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param offset  left edge of source String
 * @param maxWidth  maximum length of result String, must be at least 4
 * @return abbreviated String, <code>null</code> if null String input
 * @throws IllegalArgumentException if the width is too small
 * @since 2.0
 */"
"public static String[] splitPreserveAllTokens(String str, String separatorChars) {
    return splitWorker(str, separatorChars, -1, true);
}","public void test0068() throws Throwable {
    String[] stringArray0 = StringUtils.splitPreserveAllTokens((String) null, (String) null);
    assertNull(stringArray0);
}","/**
 * <p>Splits the provided text into an array, separators specified,
 * preserving all tokens, including empty tokens created by adjacent
 * separators. This is an alternative to using StringTokenizer.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as separators for empty tokens.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> separatorChars splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.splitPreserveAllTokens(null, *)           = null
 * StringUtils.splitPreserveAllTokens("""", *)             = []
 * StringUtils.splitPreserveAllTokens(""abc def"", null)   = [""abc"", ""def""]
 * StringUtils.splitPreserveAllTokens(""abc def"", "" "")    = [""abc"", ""def""]
 * StringUtils.splitPreserveAllTokens(""abc  def"", "" "")   = [""abc"", """", def""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef"", "":"")   = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef:"", "":"")  = [""ab"", ""cd"", ""ef"", """"]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef::"", "":"") = [""ab"", ""cd"", ""ef"", """", """"]
 * StringUtils.splitPreserveAllTokens(""ab::cd:ef"", "":"")  = [""ab"", """", cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens("":cd:ef"", "":"")     = ["""", cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""::cd:ef"", "":"")    = ["""", """", cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens("":cd:ef:"", "":"")    = ["""", cd"", ""ef"", """"]
 * </pre>
 *
 * @param str  the String to parse, may be <code>null</code>
 * @param separatorChars  the characters used as the delimiters,
 *  <code>null</code> splits on whitespace
 * @return an array of parsed Strings, <code>null</code> if null String input
 * @since 2.1
 */"
"public static String[] splitByWholeSeparator(String str, String separator, int max) {
    return splitByWholeSeparatorWorker(str, separator, max, false);
}","public void test0079() throws Throwable {
    String[] stringArray0 = StringUtils.splitByWholeSeparator(""The character must not be null"", """", 1);
    assertEquals(1, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array, separator string specified.
 * Returns a maximum of <code>max</code> substrings.</p>
 *
 * <p>The separator(s) will not be included in the returned String array.
 * Adjacent separators are treated as one separator.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> separator splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.splitByWholeSeparator(null, *, *)               = null
 * StringUtils.splitByWholeSeparator("""", *, *)                 = []
 * StringUtils.splitByWholeSeparator(""ab de fg"", null, 0)      = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparator(""ab   de fg"", null, 0)    = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparator(""ab:cd:ef"", "":"", 2)       = [""ab"", ""cd:ef""]
 * StringUtils.splitByWholeSeparator(""ab-!-cd-!-ef"", ""-!-"", 5) = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitByWholeSeparator(""ab-!-cd-!-ef"", ""-!-"", 2) = [""ab"", ""cd-!-ef""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @param separator  String containing the String to be used as a delimiter,
 *  <code>null</code> splits on whitespace
 * @param max  the maximum number of elements to include in the returned
 *  array. A zero or negative value implies no limit.
 * @return an array of parsed Strings, <code>null</code> if null String was input
 */"
"public static String removeEndIgnoreCase(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (endsWithIgnoreCase(str, remove)) {
        return str.substring(0, str.length() - remove.length());
    }
    return str;
}","public void test00811() throws Throwable {
    String string0 = StringUtils.removeEndIgnoreCase(""N+U"", ""illegalaccessexception occurred during ]9;w2a8b\""mv}!t codeCannot pad a negative amount: "");
    assertEquals(""N+U"", string0);
}","/**
 * <p>Case insensitive removal of a substring if it is at the end of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A <code>null</code> source string will return <code>null</code>.
 * An empty ("""") source string will return the empty string.
 * A <code>null</code> search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeEndIgnoreCase(null, *)      = null
 * StringUtils.removeEndIgnoreCase("""", *)        = """"
 * StringUtils.removeEndIgnoreCase(*, null)      = *
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", "".com."")  = ""www.domain.com""
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", "".com"")   = ""www.domain""
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeEndIgnoreCase(""abc"", """")    = ""abc""
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", "".COM"") = ""www.domain"")
 * StringUtils.removeEndIgnoreCase(""www.domain.COM"", "".com"") = ""www.domain"")
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for (case insensitive) and remove, may be null
 * @return the substring with the string removed if found,
 *  <code>null</code> if null String input
 * @since 2.4
 */"
"// Centering
//-----------------------------------------------------------------------
/**
 * <p>Centers a String in a larger String of size <code>size</code>
 * using the space character (' ').<p>
 *
 * <p>If the size is less than the String length, the String is returned.
 * A <code>null</code> String returns <code>null</code>.
 * A negative size is treated as zero.</p>
 *
 * <p>Equivalent to <code>center(str, size, "" "")</code>.</p>
 *
 * <pre>
 * StringUtils.center(null, *)   = null
 * StringUtils.center("""", 4)     = ""    ""
 * StringUtils.center(""ab"", -1)  = ""ab""
 * StringUtils.center(""ab"", 4)   = "" ab ""
 * StringUtils.center(""abcd"", 2) = ""abcd""
 * StringUtils.center(""a"", 4)    = "" a  ""
 * </pre>
 *
 * @param str  the String to center, may be null
 * @param size  the int size of new String, negative treated as zero
 * @return centered String, <code>null</code> if null String input
 */
public static String center(String str, int size) {
    return center(str, size, ' ');
}","public void test00912() throws Throwable {
    String string0 = StringUtils.center(""classnotfo#njava.util.locale@00000000016y  backcompatUcode"", 3);
    assertNotNull(string0);
}",""
"// Nested extraction
//-----------------------------------------------------------------------
// Splitting
//-----------------------------------------------------------------------
/**
 * <p>Splits the provided text into an array, using whitespace as the
 * separator.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as one separator.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.split(null)       = null
 * StringUtils.split("""")         = []
 * StringUtils.split(""abc def"")  = [""abc"", ""def""]
 * StringUtils.split(""abc  def"") = [""abc"", ""def""]
 * StringUtils.split("" abc "")    = [""abc""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @return an array of parsed Strings, <code>null</code> if null String input
 */
public static String[] split(String str) {
    return split(str, null, -1);
}","public void test01013() throws Throwable {
    String[] stringArray0 = StringUtils.split("" "");
    assertEquals(0, stringArray0.length);
}",""
"public static String[] splitByCharacterTypeCamelCase(String str) {
    return splitByCharacterType(str, true);
}","public void test01115() throws Throwable {
    String[] stringArray0 = StringUtils.splitByCharacterTypeCamelCase(""org.apache.commPns.:ang3.ObjectUtils$Null"");
    assertNotNull(stringArray0);
}","/**
 * <p>Splits a String by Character type as returned by
 * <code>java.lang.Character.getType(char)</code>. Groups of contiguous
 * characters of the same type are returned as complete tokens, with the
 * following exception: the character of type
 * <code>Character.UPPERCASE_LETTER</code>, if any, immediately
 * preceding a token of type <code>Character.LOWERCASE_LETTER</code>
 * will belong to the following token rather than to the preceding, if any,
 * <code>Character.UPPERCASE_LETTER</code> token.
 * <pre>
 * StringUtils.splitByCharacterTypeCamelCase(null)         = null
 * StringUtils.splitByCharacterTypeCamelCase("""")           = []
 * StringUtils.splitByCharacterTypeCamelCase(""ab de fg"")   = [""ab"", "" "", ""de"", "" "", ""fg""]
 * StringUtils.splitByCharacterTypeCamelCase(""ab   de fg"") = [""ab"", ""   "", ""de"", "" "", ""fg""]
 * StringUtils.splitByCharacterTypeCamelCase(""ab:cd:ef"")   = [""ab"", "":"", ""cd"", "":"", ""ef""]
 * StringUtils.splitByCharacterTypeCamelCase(""number5"")    = [""number"", ""5""]
 * StringUtils.splitByCharacterTypeCamelCase(""fooBar"")     = [""foo"", ""Bar""]
 * StringUtils.splitByCharacterTypeCamelCase(""foo200Bar"")  = [""foo"", ""200"", ""Bar""]
 * StringUtils.splitByCharacterTypeCamelCase(""ASFRules"")   = [""ASF"", ""Rules""]
 * </pre>
 * @param str the String to split, may be <code>null</code>
 * @return an array of parsed Strings, <code>null</code> if null String input
 * @since 2.4
 */"
"// Replacing
//-----------------------------------------------------------------------
/**
 * <p>Replaces a String with another String inside a larger String, once.</p>
 *
 * <p>A <code>null</code> reference passed to this method is a no-op.</p>
 *
 * <pre>
 * StringUtils.replaceOnce(null, *, *)        = null
 * StringUtils.replaceOnce("""", *, *)          = """"
 * StringUtils.replaceOnce(""any"", null, *)    = ""any""
 * StringUtils.replaceOnce(""any"", *, null)    = ""any""
 * StringUtils.replaceOnce(""any"", """", *)      = ""any""
 * StringUtils.replaceOnce(""aba"", ""a"", null)  = ""aba""
 * StringUtils.replaceOnce(""aba"", ""a"", """")    = ""ba""
 * StringUtils.replaceOnce(""aba"", ""a"", ""z"")   = ""zba""
 * </pre>
 *
 * @see #replace(String text, String searchString, String replacement, int max)
 * @param text  text to search and replace in, may be null
 * @param searchString  the String to search for, may be null
 * @param replacement  the String to replace with, may be null
 * @return the text with any replacements processed,
 *  <code>null</code> if null String input
 */
public static String replaceOnce(String text, String searchString, String replacement) {
    return replace(text, searchString, replacement, 1);
}","public void test01217() throws Throwable {
    String string0 = StringUtils.replaceOnce(""T^mot*oLive of "", """", ""T^mot*oLive of "");
    assertEquals(""T^mot*oLive of "", string0);
}",""
"public static String rightPad(String str, int size) {
    return rightPad(str, size, ' ');
}","public void test01318() throws Throwable {
    String string0 = StringUtils.rightPad((String) null, 1058);
    assertNull(string0);
}","/**
 * <p>Right pad a String with spaces (' ').</p>
 *
 * <p>The String is padded to the size of <code>size</code>.</p>
 *
 * <pre>
 * StringUtils.rightPad(null, *)   = null
 * StringUtils.rightPad("""", 3)     = ""   ""
 * StringUtils.rightPad(""bat"", 3)  = ""bat""
 * StringUtils.rightPad(""bat"", 5)  = ""bat  ""
 * StringUtils.rightPad(""bat"", 1)  = ""bat""
 * StringUtils.rightPad(""bat"", -1) = ""bat""
 * </pre>
 *
 * @param str  the String to pad out, may be null
 * @param size  the size to pad to
 * @return right padded String or original String if no padding is necessary,
 *  <code>null</code> if null String input
 */"
"public static String leftPad(String str, int size) {
    return leftPad(str, size, ' ');
}","public void test01419() throws Throwable {
    String string0 = StringUtils.leftPad((String) null, 15);
    assertNull(string0);
}","/**
 * <p>Left pad a String with spaces (' ').</p>
 *
 * <p>The String is padded to the size of <code>size</code>.</p>
 *
 * <pre>
 * StringUtils.leftPad(null, *)   = null
 * StringUtils.leftPad("""", 3)     = ""   ""
 * StringUtils.leftPad(""bat"", 3)  = ""bat""
 * StringUtils.leftPad(""bat"", 5)  = ""  bat""
 * StringUtils.leftPad(""bat"", 1)  = ""bat""
 * StringUtils.leftPad(""bat"", -1) = ""bat""
 * </pre>
 *
 * @param str  the String to pad out, may be null
 * @param size  the size to pad to
 * @return left padded String or original String if no padding is necessary,
 *  <code>null</code> if null String input
 */"
"// Stripping
//-----------------------------------------------------------------------
/**
 * <p>Strips whitespace from the start and end of a String.</p>
 *
 * <p>This is similar to {@link #trim(String)} but removes whitespace.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.strip(null)     = null
 * StringUtils.strip("""")       = """"
 * StringUtils.strip(""   "")    = """"
 * StringUtils.strip(""abc"")    = ""abc""
 * StringUtils.strip(""  abc"")  = ""abc""
 * StringUtils.strip(""abc  "")  = ""abc""
 * StringUtils.strip("" abc "")  = ""abc""
 * StringUtils.strip("" ab c "") = ""ab c""
 * </pre>
 *
 * @param str  the String to remove whitespace from, may be null
 * @return the stripped String, <code>null</code> if null String input
 */
public static String strip(String str) {
    return strip(str, null);
}","public void test01520() throws Throwable {
    String string0 = StringUtils.strip(""&0&HI4YiLq9%}R"");
    assertEquals(""&0&HI4YiLq9%}R"", string0);
}",""
"public static int ordinalIndexOf(String str, String searchStr, int ordinal) {
    return ordinalIndexOf(str, searchStr, ordinal, false);
}","public void test01622() throws Throwable {
    String string0 = StringUtils.repeat(""de}de"", ""de}de"", 810);
    int int0 = StringUtils.ordinalIndexOf(string0, ""de}de"", 810);
    assertEquals(4045, int0);
}","/**
 * <p>Finds the n-th index within a String, handling <code>null</code>.
 * This method uses {@link String#indexOf(String)}.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.ordinalIndexOf(null, *, *)          = -1
 * StringUtils.ordinalIndexOf(*, null, *)          = -1
 * StringUtils.ordinalIndexOf("""", """", *)           = 0
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""a"", 1)  = 0
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""a"", 2)  = 1
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""b"", 1)  = 2
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""b"", 2)  = 5
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""ab"", 1) = 1
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""ab"", 2) = 4
 * StringUtils.ordinalIndexOf(""aabaabaa"", """", 1)   = 0
 * StringUtils.ordinalIndexOf(""aabaabaa"", """", 2)   = 0
 * </pre>
 *
 * <p>Note that 'head(String str, int n)' may be implemented as: </p>
 *
 * <pre>
 *   str.substring(0, lastOrdinalIndexOf(str, ""\n"", n))
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @param ordinal  the n-th <code>searchStr</code> to find
 * @return the n-th index of the search String,
 *  <code>-1</code> (<code>INDEX_NOT_FOUND</code>) if no match or <code>null</code> string input
 * @since 2.1
 */"
"public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) {
    return splitByWholeSeparatorWorker(str, separator, -1, true);
}","public void test01723() throws Throwable {
    String[] stringArray0 = StringUtils.splitByWholeSeparatorPreserveAllTokens(""The character "", """");
    assertNotNull(stringArray0);
}","/**
 * <p>Splits the provided text into an array, separator string specified. </p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as separators for empty tokens.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> separator splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *)               = null
 * StringUtils.splitByWholeSeparatorPreserveAllTokens("""", *)                 = []
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(""ab de fg"", null)      = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(""ab   de fg"", null)    = [""ab"", """", """", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(""ab:cd:ef"", "":"")       = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(""ab-!-cd-!-ef"", ""-!-"") = [""ab"", ""cd"", ""ef""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @param separator  String containing the String to be used as a delimiter,
 *  <code>null</code> splits on whitespace
 * @return an array of parsed Strings, <code>null</code> if null String was input
 * @since 2.4
 */"
"public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {
    return splitWorker(str, separatorChars, max, true);
}","public void test01825() throws Throwable {
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""org.apache.commons.lang3.StringUtils"", ""org.apache.commons.lang3.StringUtils"", 1);
    assertEquals(1, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array with a maximum length,
 * separators specified, preserving all tokens, including empty tokens
 * created by adjacent separators.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as separators for empty tokens.
 * Adjacent separators are treated as one separator.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> separatorChars splits on whitespace.</p>
 *
 * <p>If more than <code>max</code> delimited substrings are found, the last
 * returned string includes all characters after the first <code>max - 1</code>
 * returned strings (including separator characters).</p>
 *
 * <pre>
 * StringUtils.splitPreserveAllTokens(null, *, *)            = null
 * StringUtils.splitPreserveAllTokens("""", *, *)              = []
 * StringUtils.splitPreserveAllTokens(""ab de fg"", null, 0)   = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 0) = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef"", "":"", 0)    = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef"", "":"", 2)    = [""ab"", ""cd:ef""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 2) = [""ab"", ""  de fg""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 3) = [""ab"", """", "" de fg""]
 * StringUtils.splitPreserveAllTokens(""ab   de fg"", null, 4) = [""ab"", """", """", ""de fg""]
 * </pre>
 *
 * @param str  the String to parse, may be <code>null</code>
 * @param separatorChars  the characters used as the delimiters,
 *  <code>null</code> splits on whitespace
 * @param max  the maximum number of elements to include in the
 *  array. A zero or negative value implies no limit
 * @return an array of parsed Strings, <code>null</code> if null String input
 * @since 2.1
 */"
"// StripAll
//-----------------------------------------------------------------------
/**
 * <p>Strips whitespace from the start and end of every String in an array.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <p>A new array is returned each time, except for length zero.
 * A <code>null</code> array will return <code>null</code>.
 * An empty array will return itself.
 * A <code>null</code> array entry will be ignored.</p>
 *
 * <pre>
 * StringUtils.stripAll(null)             = null
 * StringUtils.stripAll([])               = []
 * StringUtils.stripAll([""abc"", ""  abc""]) = [""abc"", ""abc""]
 * StringUtils.stripAll([""abc  "", null])  = [""abc"", null]
 * </pre>
 *
 * @param strs  the array to remove whitespace from, may be null
 * @return the stripped Strings, <code>null</code> if null array input
 */
public static String[] stripAll(String[] strs) {
    return stripAll(strs, null);
}","public void test01926() throws Throwable {
    String[] stringArray0 = StringUtils.stripAll((String[]) null);
    assertNull(stringArray0);
}",""
"public static String removeStartIgnoreCase(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (startsWithIgnoreCase(str, remove)) {
        return str.substring(remove.length());
    }
    return str;
}","public void test02027() throws Throwable {
    String string0 = StringUtils.removeStartIgnoreCase(""YfW@&ZAF"", ""java.ext.dirs"");
    assertEquals(""YfW@&ZAF"", string0);
}","/**
 * <p>Case insensitive removal of a substring if it is at the begining of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A <code>null</code> source string will return <code>null</code>.
 * An empty ("""") source string will return the empty string.
 * A <code>null</code> search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeStartIgnoreCase(null, *)      = null
 * StringUtils.removeStartIgnoreCase("""", *)        = """"
 * StringUtils.removeStartIgnoreCase(*, null)      = *
 * StringUtils.removeStartIgnoreCase(""www.domain.com"", ""www."")   = ""domain.com""
 * StringUtils.removeStartIgnoreCase(""www.domain.com"", ""WWW."")   = ""domain.com""
 * StringUtils.removeStartIgnoreCase(""domain.com"", ""www."")       = ""domain.com""
 * StringUtils.removeStartIgnoreCase(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeStartIgnoreCase(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for (case insensitive) and remove, may be null
 * @return the substring with the string removed if found,
 *  <code>null</code> if null String input
 * @since 2.4
 */"
"// Substring between
//-----------------------------------------------------------------------
/**
 * <p>Gets the String that is nested in between two instances of the
 * same String.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> tag returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.substringBetween(null, *)            = null
 * StringUtils.substringBetween("""", """")             = """"
 * StringUtils.substringBetween("""", ""tag"")          = null
 * StringUtils.substringBetween(""tagabctag"", null)  = null
 * StringUtils.substringBetween(""tagabctag"", """")    = """"
 * StringUtils.substringBetween(""tagabctag"", ""tag"") = ""abc""
 * </pre>
 *
 * @param str  the String containing the substring, may be null
 * @param tag  the String before and after the substring, may be null
 * @return the substring, <code>null</code> if no match
 * @since 2.0
 */
public static String substringBetween(String str, String tag) {
    return substringBetween(str, tag, tag);
}","public void test02128() throws Throwable {
    String string0 = StringUtils.substringBetween(""\u0000lWg]\u0001\u0002J:'h\u0004\u0005\u0007\b\n\u000BJ\u000E1"", ""\u0000lWg]\u0001\u0002J:'h\u0004\u0005\u0007\b\n\u000BJ\u000E1"");
    assertNull(string0);
}",""
"public static String reverseDelimited(String str, char separatorChar) {
    if (str == null) {
        return null;
    }
    // could implement manually, but simple way is to reuse other,
    // probably slower, methods.
    String[] strs = split(str, separatorChar);
    ArrayUtils.reverse(strs);
    return join(strs, separatorChar);
}","public void test02229() throws Throwable {
    String string0 = StringUtils.reverseDelimited(""N^~FYR]O*,@*5Z{D"", '$');
    assertNotNull(string0);
}","/**
 * <p>Reverses a String that is delimited by a specific character.</p>
 *
 * <p>The Strings between the delimiters are not reversed.
 * Thus java.lang.String becomes String.lang.java (if the delimiter
 * is <code>'.'</code>).</p>
 *
 * <pre>
 * StringUtils.reverseDelimited(null, *)      = null
 * StringUtils.reverseDelimited("""", *)        = """"
 * StringUtils.reverseDelimited(""a.b.c"", 'x') = ""a.b.c""
 * StringUtils.reverseDelimited(""a.b.c"", ""."") = ""c.b.a""
 * </pre>
 *
 * @param str  the String to reverse, may be null
 * @param separatorChar  the separator character to use
 * @return the reversed String, <code>null</code> if null String input
 * @since 2.0
 */"
"public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal) {
    return ordinalIndexOf(str, searchStr, ordinal, true);
}","public void test02331() throws Throwable {
    int int0 = StringUtils.lastOrdinalIndexOf("""", ""_o~ihv bn"", 11);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the n-th last index within a String, handling <code>null</code>.
 * This method uses {@link String#lastIndexOf(String)}.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.lastOrdinalIndexOf(null, *, *)          = -1
 * StringUtils.lastOrdinalIndexOf(*, null, *)          = -1
 * StringUtils.lastOrdinalIndexOf("""", """", *)           = 0
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", ""a"", 1)  = 7
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", ""a"", 2)  = 6
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", ""b"", 1)  = 5
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", ""b"", 2)  = 2
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", ""ab"", 1) = 4
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", ""ab"", 2) = 1
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", """", 1)   = 8
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", """", 2)   = 8
 * </pre>
 *
 * <p>Note that 'tail(String str, int n)' may be implemented as: </p>
 *
 * <pre>
 *   str.substring(lastOrdinalIndexOf(str, ""\n"", n) + 1)
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @param ordinal  the n-th last <code>searchStr</code> to find
 * @return the n-th last index of the search String,
 *  <code>-1</code> (<code>INDEX_NOT_FOUND</code>) if no match or <code>null</code> string input
 * @since 2.5
 */"
"public static String replace(String text, String searchString, String replacement) {
    return replace(text, searchString, replacement, -1);
}","public void test02432() throws Throwable {
    String string0 = StringUtils.replace("""", """", """");
    assertEquals("""", string0);
}","/**
 * <p>Replaces all occurrences of a String within another String.</p>
 *
 * <p>A <code>null</code> reference passed to this method is a no-op.</p>
 *
 * <pre>
 * StringUtils.replace(null, *, *)        = null
 * StringUtils.replace("""", *, *)          = """"
 * StringUtils.replace(""any"", null, *)    = ""any""
 * StringUtils.replace(""any"", *, null)    = ""any""
 * StringUtils.replace(""any"", """", *)      = ""any""
 * StringUtils.replace(""aba"", ""a"", null)  = ""aba""
 * StringUtils.replace(""aba"", ""a"", """")    = ""b""
 * StringUtils.replace(""aba"", ""a"", ""z"")   = ""zbz""
 * </pre>
 *
 * @see #replace(String text, String searchString, String replacement, int max)
 * @param text  text to search and replace in, may be null
 * @param searchString  the String to search for, may be null
 * @param replacement  the String to replace it with, may be null
 * @return the text with any replacements processed,
 *  <code>null</code> if null String input
 */"
"public static String[] split(String str, String separatorChars) {
    return splitWorker(str, separatorChars, -1, false);
}","public void test02533() throws Throwable {
    String[] stringArray0 = StringUtils.split(""g"", ""g"");
    assertEquals(0, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array, separators specified.
 * This is an alternative to using StringTokenizer.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as one separator.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> separatorChars splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.split(null, *)         = null
 * StringUtils.split("""", *)           = []
 * StringUtils.split(""abc def"", null) = [""abc"", ""def""]
 * StringUtils.split(""abc def"", "" "")  = [""abc"", ""def""]
 * StringUtils.split(""abc  def"", "" "") = [""abc"", ""def""]
 * StringUtils.split(""ab:cd:ef"", "":"") = [""ab"", ""cd"", ""ef""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @param separatorChars  the characters used as the delimiters,
 *  <code>null</code> splits on whitespace
 * @return an array of parsed Strings, <code>null</code> if null String input
 */"
"public static String[] splitByWholeSeparator(String str, String separator) {
    return splitByWholeSeparatorWorker(str, separator, -1, false);
}","public void test02634() throws Throwable {
    String[] stringArray0 = StringUtils.splitByWholeSeparator(""g"", ""g"");
    assertEquals(1, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array, separator string specified.</p>
 *
 * <p>The separator(s) will not be included in the returned String array.
 * Adjacent separators are treated as one separator.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> separator splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.splitByWholeSeparator(null, *)               = null
 * StringUtils.splitByWholeSeparator("""", *)                 = []
 * StringUtils.splitByWholeSeparator(""ab de fg"", null)      = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparator(""ab   de fg"", null)    = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparator(""ab:cd:ef"", "":"")       = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitByWholeSeparator(""ab-!-cd-!-ef"", ""-!-"") = [""ab"", ""cd"", ""ef""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @param separator  String containing the String to be used as a delimiter,
 *  <code>null</code> splits on whitespace
 * @return an array of parsed Strings, <code>null</code> if null String was input
 */"
"public static boolean isNotEmpty(CharSequence cs) {
    return !StringUtils.isEmpty(cs);
}","public void test02736() throws Throwable {
    boolean boolean0 = StringUtils.isNotEmpty((CharSequence) null);
    assertFalse(boolean0);
}","/**
 * <p>Checks if a CharSequence is not empty ("""") and not null.</p>
 *
 * <pre>
 * StringUtils.isNotEmpty(null)      = false
 * StringUtils.isNotEmpty("""")        = false
 * StringUtils.isNotEmpty("" "")       = true
 * StringUtils.isNotEmpty(""bob"")     = true
 * StringUtils.isNotEmpty(""  bob  "") = true
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if the CharSequence is not empty and not null
 */"
"public static boolean isNotEmpty(CharSequence cs) {
    return !StringUtils.isEmpty(cs);
}","public void test02837() throws Throwable {
    boolean boolean0 = StringUtils.isNotEmpty(""DtF,iMG<ifd\r~"");
    assertTrue(boolean0);
}","/**
 * <p>Checks if a CharSequence is not empty ("""") and not null.</p>
 *
 * <pre>
 * StringUtils.isNotEmpty(null)      = false
 * StringUtils.isNotEmpty("""")        = false
 * StringUtils.isNotEmpty("" "")       = true
 * StringUtils.isNotEmpty(""bob"")     = true
 * StringUtils.isNotEmpty(""  bob  "") = true
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if the CharSequence is not empty and not null
 */"
"public static boolean isBlank(CharSequence cs) {
    int strLen;
    if (cs == null || (strLen = cs.length()) == 0) {
        return true;
    }
    for (int i = 0; i < strLen; i++) {
        if ((Character.isWhitespace(cs.charAt(i)) == false)) {
            return false;
        }
    }
    return true;
}","public void test02938() throws Throwable {
    boolean boolean0 = StringUtils.isBlank("" "");
    assertTrue(boolean0);
}","/**
 * <p>Checks if a CharSequence is whitespace, empty ("""") or null.</p>
 *
 * <pre>
 * StringUtils.isBlank(null)      = true
 * StringUtils.isBlank("""")        = true
 * StringUtils.isBlank("" "")       = true
 * StringUtils.isBlank(""bob"")     = false
 * StringUtils.isBlank(""  bob  "") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if the CharSequence is null, empty or whitespace
 * @since 2.0
 */"
"public static boolean isBlank(CharSequence cs) {
    int strLen;
    if (cs == null || (strLen = cs.length()) == 0) {
        return true;
    }
    for (int i = 0; i < strLen; i++) {
        if ((Character.isWhitespace(cs.charAt(i)) == false)) {
            return false;
        }
    }
    return true;
}","public void test03039() throws Throwable {
    boolean boolean0 = StringUtils.isBlank("""");
    assertTrue(boolean0);
}","/**
 * <p>Checks if a CharSequence is whitespace, empty ("""") or null.</p>
 *
 * <pre>
 * StringUtils.isBlank(null)      = true
 * StringUtils.isBlank("""")        = true
 * StringUtils.isBlank("" "")       = true
 * StringUtils.isBlank(""bob"")     = false
 * StringUtils.isBlank(""  bob  "") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if the CharSequence is null, empty or whitespace
 * @since 2.0
 */"
"public static boolean isNotBlank(CharSequence cs) {
    return !StringUtils.isBlank(cs);
}","public void test03140() throws Throwable {
    boolean boolean0 = StringUtils.isNotBlank((CharSequence) null);
    assertFalse(boolean0);
}","/**
 * <p>Checks if a CharSequence is not empty (""""), not null and not whitespace only.</p>
 *
 * <pre>
 * StringUtils.isNotBlank(null)      = false
 * StringUtils.isNotBlank("""")        = false
 * StringUtils.isNotBlank("" "")       = false
 * StringUtils.isNotBlank(""bob"")     = true
 * StringUtils.isNotBlank(""  bob  "") = true
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if the CharSequence is
 *  not empty and not null and not whitespace
 * @since 2.0
 */"
"public static boolean isNotBlank(CharSequence cs) {
    return !StringUtils.isBlank(cs);
}","public void test03241() throws Throwable {
    boolean boolean0 = StringUtils.isNotBlank(""&hj_Y"");
    assertTrue(boolean0);
}","/**
 * <p>Checks if a CharSequence is not empty (""""), not null and not whitespace only.</p>
 *
 * <pre>
 * StringUtils.isNotBlank(null)      = false
 * StringUtils.isNotBlank("""")        = false
 * StringUtils.isNotBlank("" "")       = false
 * StringUtils.isNotBlank(""bob"")     = true
 * StringUtils.isNotBlank(""  bob  "") = true
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if the CharSequence is
 *  not empty and not null and not whitespace
 * @since 2.0
 */"
"// Trim
//-----------------------------------------------------------------------
/**
 * <p>Removes control characters (char &lt;= 32) from both
 * ends of this String, handling <code>null</code> by returning
 * <code>null</code>.</p>
 *
 * <p>The String is trimmed using {@link String#trim()}.
 * Trim removes start and end characters &lt;= 32.
 * To strip whitespace use {@link #strip(String)}.</p>
 *
 * <p>To trim your choice of characters, use the
 * {@link #strip(String, String)} methods.</p>
 *
 * <pre>
 * StringUtils.trim(null)          = null
 * StringUtils.trim("""")            = """"
 * StringUtils.trim(""     "")       = """"
 * StringUtils.trim(""abc"")         = ""abc""
 * StringUtils.trim(""    abc    "") = ""abc""
 * </pre>
 *
 * @param str  the String to be trimmed, may be null
 * @return the trimmed string, <code>null</code> if null String input
 */
public static String trim(String str) {
    return str == null ? null : str.trim();
}","public void test03342() throws Throwable {
    String string0 = StringUtils.trim((String) null);
    assertNull(string0);
}",""
"public static String trimToNull(String str) {
    String ts = trim(str);
    return isEmpty(ts) ? null : ts;
}","public void test03443() throws Throwable {
    String string0 = StringUtils.trimToNull("":Rsv~`{YDV3ml"");
    assertNotNull(string0);
}","/**
 * <p>Removes control characters (char &lt;= 32) from both
 * ends of this String returning <code>null</code> if the String is
 * empty ("""") after the trim or if it is <code>null</code>.
 *
 * <p>The String is trimmed using {@link String#trim()}.
 * Trim removes start and end characters &lt;= 32.
 * To strip whitespace use {@link #stripToNull(String)}.</p>
 *
 * <pre>
 * StringUtils.trimToNull(null)          = null
 * StringUtils.trimToNull("""")            = null
 * StringUtils.trimToNull(""     "")       = null
 * StringUtils.trimToNull(""abc"")         = ""abc""
 * StringUtils.trimToNull(""    abc    "") = ""abc""
 * </pre>
 *
 * @param str  the String to be trimmed, may be null
 * @return the trimmed String,
 *  <code>null</code> if only chars &lt;= 32, empty or null String input
 * @since 2.0
 */"
"public static String trimToNull(String str) {
    String ts = trim(str);
    return isEmpty(ts) ? null : ts;
}","public void test03545() throws Throwable {
    String string0 = StringUtils.trimToNull("""");
    assertNull(string0);
}","/**
 * <p>Removes control characters (char &lt;= 32) from both
 * ends of this String returning <code>null</code> if the String is
 * empty ("""") after the trim or if it is <code>null</code>.
 *
 * <p>The String is trimmed using {@link String#trim()}.
 * Trim removes start and end characters &lt;= 32.
 * To strip whitespace use {@link #stripToNull(String)}.</p>
 *
 * <pre>
 * StringUtils.trimToNull(null)          = null
 * StringUtils.trimToNull("""")            = null
 * StringUtils.trimToNull(""     "")       = null
 * StringUtils.trimToNull(""abc"")         = ""abc""
 * StringUtils.trimToNull(""    abc    "") = ""abc""
 * </pre>
 *
 * @param str  the String to be trimmed, may be null
 * @return the trimmed String,
 *  <code>null</code> if only chars &lt;= 32, empty or null String input
 * @since 2.0
 */"
"public static String trimToEmpty(String str) {
    return str == null ? EMPTY : str.trim();
}","public void test03646() throws Throwable {
    String string0 = StringUtils.trimToEmpty(""0bhD/uU;3p?[EUn"");
    assertEquals(""0bhD/uU;3p?[EUn"", string0);
}","/**
 * <p>Removes control characters (char &lt;= 32) from both
 * ends of this String returning an empty String ("""") if the String
 * is empty ("""") after the trim or if it is <code>null</code>.
 *
 * <p>The String is trimmed using {@link String#trim()}.
 * Trim removes start and end characters &lt;= 32.
 * To strip whitespace use {@link #stripToEmpty(String)}.</p>
 *
 * <pre>
 * StringUtils.trimToEmpty(null)          = """"
 * StringUtils.trimToEmpty("""")            = """"
 * StringUtils.trimToEmpty(""     "")       = """"
 * StringUtils.trimToEmpty(""abc"")         = ""abc""
 * StringUtils.trimToEmpty(""    abc    "") = ""abc""
 * </pre>
 *
 * @param str  the String to be trimmed, may be null
 * @return the trimmed String, or an empty String if <code>null</code> input
 * @since 2.0
 */"
"public static String trimToEmpty(String str) {
    return str == null ? EMPTY : str.trim();
}","public void test03747() throws Throwable {
    String string0 = StringUtils.trimToEmpty((String) null);
    assertEquals("""", string0);
}","/**
 * <p>Removes control characters (char &lt;= 32) from both
 * ends of this String returning an empty String ("""") if the String
 * is empty ("""") after the trim or if it is <code>null</code>.
 *
 * <p>The String is trimmed using {@link String#trim()}.
 * Trim removes start and end characters &lt;= 32.
 * To strip whitespace use {@link #stripToEmpty(String)}.</p>
 *
 * <pre>
 * StringUtils.trimToEmpty(null)          = """"
 * StringUtils.trimToEmpty("""")            = """"
 * StringUtils.trimToEmpty(""     "")       = """"
 * StringUtils.trimToEmpty(""abc"")         = ""abc""
 * StringUtils.trimToEmpty(""    abc    "") = ""abc""
 * </pre>
 *
 * @param str  the String to be trimmed, may be null
 * @return the trimmed String, or an empty String if <code>null</code> input
 * @since 2.0
 */"
"public static String stripToNull(String str) {
    if (str == null) {
        return null;
    }
    str = strip(str, null);
    return str.length() == 0 ? null : str;
}","public void test03848() throws Throwable {
    String string0 = StringUtils.stripToNull("""");
    assertNull(string0);
}","/**
 * <p>Strips whitespace from the start and end of a String  returning
 * <code>null</code> if the String is empty ("""") after the strip.</p>
 *
 * <p>This is similar to {@link #trimToNull(String)} but removes whitespace.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripToNull(null)     = null
 * StringUtils.stripToNull("""")       = null
 * StringUtils.stripToNull(""   "")    = null
 * StringUtils.stripToNull(""abc"")    = ""abc""
 * StringUtils.stripToNull(""  abc"")  = ""abc""
 * StringUtils.stripToNull(""abc  "")  = ""abc""
 * StringUtils.stripToNull("" abc "")  = ""abc""
 * StringUtils.stripToNull("" ab c "") = ""ab c""
 * </pre>
 *
 * @param str  the String to be stripped, may be null
 * @return the stripped String,
 *  <code>null</code> if whitespace, empty or null String input
 * @since 2.0
 */"
"public static String stripToNull(String str) {
    if (str == null) {
        return null;
    }
    str = strip(str, null);
    return str.length() == 0 ? null : str;
}","public void test03949() throws Throwable {
    String string0 = StringUtils.stripToNull((String) null);
    assertNull(string0);
}","/**
 * <p>Strips whitespace from the start and end of a String  returning
 * <code>null</code> if the String is empty ("""") after the strip.</p>
 *
 * <p>This is similar to {@link #trimToNull(String)} but removes whitespace.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripToNull(null)     = null
 * StringUtils.stripToNull("""")       = null
 * StringUtils.stripToNull(""   "")    = null
 * StringUtils.stripToNull(""abc"")    = ""abc""
 * StringUtils.stripToNull(""  abc"")  = ""abc""
 * StringUtils.stripToNull(""abc  "")  = ""abc""
 * StringUtils.stripToNull("" abc "")  = ""abc""
 * StringUtils.stripToNull("" ab c "") = ""ab c""
 * </pre>
 *
 * @param str  the String to be stripped, may be null
 * @return the stripped String,
 *  <code>null</code> if whitespace, empty or null String input
 * @since 2.0
 */"
"public static String stripToNull(String str) {
    if (str == null) {
        return null;
    }
    str = strip(str, null);
    return str.length() == 0 ? null : str;
}","public void test04050() throws Throwable {
    String string0 = ""\\u000"";
    String string1 = StringUtils.stripToNull(string0);
    assertEquals(""\\u000"", string1);
}","/**
 * <p>Strips whitespace from the start and end of a String  returning
 * <code>null</code> if the String is empty ("""") after the strip.</p>
 *
 * <p>This is similar to {@link #trimToNull(String)} but removes whitespace.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripToNull(null)     = null
 * StringUtils.stripToNull("""")       = null
 * StringUtils.stripToNull(""   "")    = null
 * StringUtils.stripToNull(""abc"")    = ""abc""
 * StringUtils.stripToNull(""  abc"")  = ""abc""
 * StringUtils.stripToNull(""abc  "")  = ""abc""
 * StringUtils.stripToNull("" abc "")  = ""abc""
 * StringUtils.stripToNull("" ab c "") = ""ab c""
 * </pre>
 *
 * @param str  the String to be stripped, may be null
 * @return the stripped String,
 *  <code>null</code> if whitespace, empty or null String input
 * @since 2.0
 */"
"public static String stripToEmpty(String str) {
    return str == null ? EMPTY : strip(str, null);
}","public void test04152() throws Throwable {
    String string0 = StringUtils.stripToEmpty((String) null);
    assertEquals("""", string0);
}","/**
 * <p>Strips whitespace from the start and end of a String  returning
 * an empty String if <code>null</code> input.</p>
 *
 * <p>This is similar to {@link #trimToEmpty(String)} but removes whitespace.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripToEmpty(null)     = """"
 * StringUtils.stripToEmpty("""")       = """"
 * StringUtils.stripToEmpty(""   "")    = """"
 * StringUtils.stripToEmpty(""abc"")    = ""abc""
 * StringUtils.stripToEmpty(""  abc"")  = ""abc""
 * StringUtils.stripToEmpty(""abc  "")  = ""abc""
 * StringUtils.stripToEmpty("" abc "")  = ""abc""
 * StringUtils.stripToEmpty("" ab c "") = ""ab c""
 * </pre>
 *
 * @param str  the String to be stripped, may be null
 * @return the trimmed String, or an empty String if <code>null</code> input
 * @since 2.0
 */"
"public static String stripStart(String str, String stripChars) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    int start = 0;
    if (stripChars == null) {
        while ((start != strLen) && Character.isWhitespace(str.charAt(start))) {
            start++;
        }
    } else if (stripChars.length() == 0) {
        return str;
    } else {
        while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) {
            start++;
        }
    }
    return str.substring(start);
}","public void test04253() throws Throwable {
    String string0 = StringUtils.stripStart((String) null, (String) null);
    assertNull(string0);
}","/**
 * <p>Strips any of a set of characters from the start of a String.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * An empty string ("""") input returns the empty string.</p>
 *
 * <p>If the stripChars String is <code>null</code>, whitespace is
 * stripped as defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripStart(null, *)          = null
 * StringUtils.stripStart("""", *)            = """"
 * StringUtils.stripStart(""abc"", """")        = ""abc""
 * StringUtils.stripStart(""abc"", null)      = ""abc""
 * StringUtils.stripStart(""  abc"", null)    = ""abc""
 * StringUtils.stripStart(""abc  "", null)    = ""abc  ""
 * StringUtils.stripStart("" abc "", null)    = ""abc ""
 * StringUtils.stripStart(""yxabc  "", ""xyz"") = ""abc  ""
 * </pre>
 *
 * @param str  the String to remove characters from, may be null
 * @param stripChars  the characters to remove, null treated as whitespace
 * @return the stripped String, <code>null</code> if null String input
 */"
"public static String stripStart(String str, String stripChars) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    int start = 0;
    if (stripChars == null) {
        while ((start != strLen) && Character.isWhitespace(str.charAt(start))) {
            start++;
        }
    } else if (stripChars.length() == 0) {
        return str;
    } else {
        while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) {
            start++;
        }
    }
    return str.substring(start);
}","public void test04354() throws Throwable {
    String string0 = StringUtils.stripStart("""", """");
    assertEquals("""", string0);
}","/**
 * <p>Strips any of a set of characters from the start of a String.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * An empty string ("""") input returns the empty string.</p>
 *
 * <p>If the stripChars String is <code>null</code>, whitespace is
 * stripped as defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripStart(null, *)          = null
 * StringUtils.stripStart("""", *)            = """"
 * StringUtils.stripStart(""abc"", """")        = ""abc""
 * StringUtils.stripStart(""abc"", null)      = ""abc""
 * StringUtils.stripStart(""  abc"", null)    = ""abc""
 * StringUtils.stripStart(""abc  "", null)    = ""abc  ""
 * StringUtils.stripStart("" abc "", null)    = ""abc ""
 * StringUtils.stripStart(""yxabc  "", ""xyz"") = ""abc  ""
 * </pre>
 *
 * @param str  the String to remove characters from, may be null
 * @param stripChars  the characters to remove, null treated as whitespace
 * @return the stripped String, <code>null</code> if null String input
 */"
"public static String stripStart(String str, String stripChars) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    int start = 0;
    if (stripChars == null) {
        while ((start != strLen) && Character.isWhitespace(str.charAt(start))) {
            start++;
        }
    } else if (stripChars.length() == 0) {
        return str;
    } else {
        while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) {
            start++;
        }
    }
    return str.substring(start);
}","public void test04455() throws Throwable {
    String string0 = StringUtils.stripStart(""replace array lengths donMt ma"", """");
    assertEquals(""replace array lengths donMt ma"", string0);
}","/**
 * <p>Strips any of a set of characters from the start of a String.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * An empty string ("""") input returns the empty string.</p>
 *
 * <p>If the stripChars String is <code>null</code>, whitespace is
 * stripped as defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripStart(null, *)          = null
 * StringUtils.stripStart("""", *)            = """"
 * StringUtils.stripStart(""abc"", """")        = ""abc""
 * StringUtils.stripStart(""abc"", null)      = ""abc""
 * StringUtils.stripStart(""  abc"", null)    = ""abc""
 * StringUtils.stripStart(""abc  "", null)    = ""abc  ""
 * StringUtils.stripStart("" abc "", null)    = ""abc ""
 * StringUtils.stripStart(""yxabc  "", ""xyz"") = ""abc  ""
 * </pre>
 *
 * @param str  the String to remove characters from, may be null
 * @param stripChars  the characters to remove, null treated as whitespace
 * @return the stripped String, <code>null</code> if null String input
 */"
"public static String stripToEmpty(String str) {
    return str == null ? EMPTY : strip(str, null);
}","public void test04556() throws Throwable {
    String string0 = StringUtils.stripToEmpty("" "");
    assertNotNull(string0);
}","/**
 * <p>Strips whitespace from the start and end of a String  returning
 * an empty String if <code>null</code> input.</p>
 *
 * <p>This is similar to {@link #trimToEmpty(String)} but removes whitespace.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripToEmpty(null)     = """"
 * StringUtils.stripToEmpty("""")       = """"
 * StringUtils.stripToEmpty(""   "")    = """"
 * StringUtils.stripToEmpty(""abc"")    = ""abc""
 * StringUtils.stripToEmpty(""  abc"")  = ""abc""
 * StringUtils.stripToEmpty(""abc  "")  = ""abc""
 * StringUtils.stripToEmpty("" abc "")  = ""abc""
 * StringUtils.stripToEmpty("" ab c "") = ""ab c""
 * </pre>
 *
 * @param str  the String to be stripped, may be null
 * @return the trimmed String, or an empty String if <code>null</code> input
 * @since 2.0
 */"
"public static String stripStart(String str, String stripChars) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    int start = 0;
    if (stripChars == null) {
        while ((start != strLen) && Character.isWhitespace(str.charAt(start))) {
            start++;
        }
    } else if (stripChars.length() == 0) {
        return str;
    } else {
        while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) {
            start++;
        }
    }
    return str.substring(start);
}","public void test04658() throws Throwable {
    String string0 = StringUtils.stripStart(""fYsfYd"", ""M$D)\u0006,2=,7a)0"");
    assertEquals(""fYsfYd"", string0);
}","/**
 * <p>Strips any of a set of characters from the start of a String.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * An empty string ("""") input returns the empty string.</p>
 *
 * <p>If the stripChars String is <code>null</code>, whitespace is
 * stripped as defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripStart(null, *)          = null
 * StringUtils.stripStart("""", *)            = """"
 * StringUtils.stripStart(""abc"", """")        = ""abc""
 * StringUtils.stripStart(""abc"", null)      = ""abc""
 * StringUtils.stripStart(""  abc"", null)    = ""abc""
 * StringUtils.stripStart(""abc  "", null)    = ""abc  ""
 * StringUtils.stripStart("" abc "", null)    = ""abc ""
 * StringUtils.stripStart(""yxabc  "", ""xyz"") = ""abc  ""
 * </pre>
 *
 * @param str  the String to remove characters from, may be null
 * @param stripChars  the characters to remove, null treated as whitespace
 * @return the stripped String, <code>null</code> if null String input
 */"
"public static String strip(String str, String stripChars) {
    if (isEmpty(str)) {
        return str;
    }
    str = stripStart(str, stripChars);
    return stripEnd(str, stripChars);
}","public void test04759() throws Throwable {
    String string0 = StringUtils.strip(""search cannot pad a negative amount: t match: "", ""search cannot pad a negative amount: t match: "");
    assertEquals("""", string0);
}","/**
 * <p>Strips any of a set of characters from the start and end of a String.
 * This is similar to {@link String#trim()} but allows the characters
 * to be stripped to be controlled.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * An empty string ("""") input returns the empty string.</p>
 *
 * <p>If the stripChars String is <code>null</code>, whitespace is
 * stripped as defined by {@link Character#isWhitespace(char)}.
 * Alternatively use {@link #strip(String)}.</p>
 *
 * <pre>
 * StringUtils.strip(null, *)          = null
 * StringUtils.strip("""", *)            = """"
 * StringUtils.strip(""abc"", null)      = ""abc""
 * StringUtils.strip(""  abc"", null)    = ""abc""
 * StringUtils.strip(""abc  "", null)    = ""abc""
 * StringUtils.strip("" abc "", null)    = ""abc""
 * StringUtils.strip(""  abcyx"", ""xyz"") = ""  abc""
 * </pre>
 *
 * @param str  the String to remove characters from, may be null
 * @param stripChars  the characters to remove, null treated as whitespace
 * @return the stripped String, <code>null</code> if null String input
 */"
"public static String stripEnd(String str, String stripChars) {
    int end;
    if (str == null || (end = str.length()) == 0) {
        return str;
    }
    if (stripChars == null) {
        while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) {
            end--;
        }
    } else if (stripChars.length() == 0) {
        return str;
    } else {
        while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) {
            end--;
        }
    }
    return str.substring(0, end);
}","public void test04860() throws Throwable {
    String string0 = StringUtils.stripEnd((String) null, (String) null);
    assertNull(string0);
}","/**
 * <p>Strips any of a set of characters from the end of a String.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * An empty string ("""") input returns the empty string.</p>
 *
 * <p>If the stripChars String is <code>null</code>, whitespace is
 * stripped as defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripEnd(null, *)          = null
 * StringUtils.stripEnd("""", *)            = """"
 * StringUtils.stripEnd(""abc"", """")        = ""abc""
 * StringUtils.stripEnd(""abc"", null)      = ""abc""
 * StringUtils.stripEnd(""  abc"", null)    = ""  abc""
 * StringUtils.stripEnd(""abc  "", null)    = ""abc""
 * StringUtils.stripEnd("" abc "", null)    = "" abc""
 * StringUtils.stripEnd(""  abcyx"", ""xyz"") = ""  abc""
 * </pre>
 *
 * @param str  the String to remove characters from, may be null
 * @param stripChars  the characters to remove, null treated as whitespace
 * @return the stripped String, <code>null</code> if null String input
 */"
"public static String stripEnd(String str, String stripChars) {
    int end;
    if (str == null || (end = str.length()) == 0) {
        return str;
    }
    if (stripChars == null) {
        while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) {
            end--;
        }
    } else if (stripChars.length() == 0) {
        return str;
    } else {
        while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) {
            end--;
        }
    }
    return str.substring(0, end);
}","public void test04961() throws Throwable {
    String string0 = StringUtils.stripEnd(""IllegalAccess{xception occurred during%1.6 backcompat code"", ""IllegalAccess{xception occurred during%1.6 backcompat code"");
    assertEquals("""", string0);
}","/**
 * <p>Strips any of a set of characters from the end of a String.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * An empty string ("""") input returns the empty string.</p>
 *
 * <p>If the stripChars String is <code>null</code>, whitespace is
 * stripped as defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripEnd(null, *)          = null
 * StringUtils.stripEnd("""", *)            = """"
 * StringUtils.stripEnd(""abc"", """")        = ""abc""
 * StringUtils.stripEnd(""abc"", null)      = ""abc""
 * StringUtils.stripEnd(""  abc"", null)    = ""  abc""
 * StringUtils.stripEnd(""abc  "", null)    = ""abc""
 * StringUtils.stripEnd("" abc "", null)    = "" abc""
 * StringUtils.stripEnd(""  abcyx"", ""xyz"") = ""  abc""
 * </pre>
 *
 * @param str  the String to remove characters from, may be null
 * @param stripChars  the characters to remove, null treated as whitespace
 * @return the stripped String, <code>null</code> if null String input
 */"
"public static String stripEnd(String str, String stripChars) {
    int end;
    if (str == null || (end = str.length()) == 0) {
        return str;
    }
    if (stripChars == null) {
        while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) {
            end--;
        }
    } else if (stripChars.length() == 0) {
        return str;
    } else {
        while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) {
            end--;
        }
    }
    return str.substring(0, end);
}","public void test05062() throws Throwable {
    String string0 = StringUtils.stripEnd(""                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            "", (String) null);
    assertEquals("""", string0);
}","/**
 * <p>Strips any of a set of characters from the end of a String.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * An empty string ("""") input returns the empty string.</p>
 *
 * <p>If the stripChars String is <code>null</code>, whitespace is
 * stripped as defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripEnd(null, *)          = null
 * StringUtils.stripEnd("""", *)            = """"
 * StringUtils.stripEnd(""abc"", """")        = ""abc""
 * StringUtils.stripEnd(""abc"", null)      = ""abc""
 * StringUtils.stripEnd(""  abc"", null)    = ""  abc""
 * StringUtils.stripEnd(""abc  "", null)    = ""abc""
 * StringUtils.stripEnd("" abc "", null)    = "" abc""
 * StringUtils.stripEnd(""  abcyx"", ""xyz"") = ""  abc""
 * </pre>
 *
 * @param str  the String to remove characters from, may be null
 * @param stripChars  the characters to remove, null treated as whitespace
 * @return the stripped String, <code>null</code> if null String input
 */"
"public static String stripEnd(String str, String stripChars) {
    int end;
    if (str == null || (end = str.length()) == 0) {
        return str;
    }
    if (stripChars == null) {
        while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) {
            end--;
        }
    } else if (stripChars.length() == 0) {
        return str;
    } else {
        while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) {
            end--;
        }
    }
    return str.substring(0, end);
}","public void test05163() throws Throwable {
    String string0 = StringUtils.stripEnd(""NoSuchMethodException occurred during 1.6 backcompat code"", """");
    assertEquals(""NoSuchMethodException occurred during 1.6 backcompat code"", string0);
}","/**
 * <p>Strips any of a set of characters from the end of a String.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * An empty string ("""") input returns the empty string.</p>
 *
 * <p>If the stripChars String is <code>null</code>, whitespace is
 * stripped as defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripEnd(null, *)          = null
 * StringUtils.stripEnd("""", *)            = """"
 * StringUtils.stripEnd(""abc"", """")        = ""abc""
 * StringUtils.stripEnd(""abc"", null)      = ""abc""
 * StringUtils.stripEnd(""  abc"", null)    = ""  abc""
 * StringUtils.stripEnd(""abc  "", null)    = ""abc""
 * StringUtils.stripEnd("" abc "", null)    = "" abc""
 * StringUtils.stripEnd(""  abcyx"", ""xyz"") = ""  abc""
 * </pre>
 *
 * @param str  the String to remove characters from, may be null
 * @param stripChars  the characters to remove, null treated as whitespace
 * @return the stripped String, <code>null</code> if null String input
 */"
"public static String stripEnd(String str, String stripChars) {
    int end;
    if (str == null || (end = str.length()) == 0) {
        return str;
    }
    if (stripChars == null) {
        while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) {
            end--;
        }
    } else if (stripChars.length() == 0) {
        return str;
    } else {
        while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND)) {
            end--;
        }
    }
    return str.substring(0, end);
}","public void test05264() throws Throwable {
    String string0 = StringUtils.stripEnd(""Nq|"", ""search and replcannot pad a negative amount:  "");
    assertEquals(""Nq|"", string0);
}","/**
 * <p>Strips any of a set of characters from the end of a String.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * An empty string ("""") input returns the empty string.</p>
 *
 * <p>If the stripChars String is <code>null</code>, whitespace is
 * stripped as defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripEnd(null, *)          = null
 * StringUtils.stripEnd("""", *)            = """"
 * StringUtils.stripEnd(""abc"", """")        = ""abc""
 * StringUtils.stripEnd(""abc"", null)      = ""abc""
 * StringUtils.stripEnd(""  abc"", null)    = ""  abc""
 * StringUtils.stripEnd(""abc  "", null)    = ""abc""
 * StringUtils.stripEnd("" abc "", null)    = "" abc""
 * StringUtils.stripEnd(""  abcyx"", ""xyz"") = ""  abc""
 * </pre>
 *
 * @param str  the String to remove characters from, may be null
 * @param stripChars  the characters to remove, null treated as whitespace
 * @return the stripped String, <code>null</code> if null String input
 */"
"// StripAll
//-----------------------------------------------------------------------
/**
 * <p>Strips whitespace from the start and end of every String in an array.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <p>A new array is returned each time, except for length zero.
 * A <code>null</code> array will return <code>null</code>.
 * An empty array will return itself.
 * A <code>null</code> array entry will be ignored.</p>
 *
 * <pre>
 * StringUtils.stripAll(null)             = null
 * StringUtils.stripAll([])               = []
 * StringUtils.stripAll([""abc"", ""  abc""]) = [""abc"", ""abc""]
 * StringUtils.stripAll([""abc  "", null])  = [""abc"", null]
 * </pre>
 *
 * @param strs  the array to remove whitespace from, may be null
 * @return the stripped Strings, <code>null</code> if null array input
 */
public static String[] stripAll(String[] strs) {
    return stripAll(strs, null);
}","public void test05365() throws Throwable {
    String[] stringArray0 = new String[1];
    String[] stringArray1 = StringUtils.stripAll(stringArray0);
    assertNotSame(stringArray1, stringArray0);
}",""
"// StripAll
//-----------------------------------------------------------------------
/**
 * <p>Strips whitespace from the start and end of every String in an array.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <p>A new array is returned each time, except for length zero.
 * A <code>null</code> array will return <code>null</code>.
 * An empty array will return itself.
 * A <code>null</code> array entry will be ignored.</p>
 *
 * <pre>
 * StringUtils.stripAll(null)             = null
 * StringUtils.stripAll([])               = []
 * StringUtils.stripAll([""abc"", ""  abc""]) = [""abc"", ""abc""]
 * StringUtils.stripAll([""abc  "", null])  = [""abc"", null]
 * </pre>
 *
 * @param strs  the array to remove whitespace from, may be null
 * @return the stripped Strings, <code>null</code> if null array input
 */
public static String[] stripAll(String[] strs) {
    return stripAll(strs, null);
}","public void test05467() throws Throwable {
    String[] stringArray0 = new String[0];
    String[] stringArray1 = StringUtils.stripAll(stringArray0);
    assertSame(stringArray1, stringArray0);
}",""
"public static String stripAccents(String input) {
    if (input == null) {
        return null;
    }
    if (SystemUtils.isJavaVersionAtLeast(1.6f)) {
        // String decomposed = Normalizer.normalize(input, Normalizer.Form.NFD);
        // START of 1.5 reflection - in 1.6 use the line commented out above
        try {
            // get java.text.Normalizer.Form class
            Class<?> normalizerFormClass = ClassUtils.getClass(""java.text.Normalizer$Form"", false);
            // get Normlizer class
            Class<?> normalizerClass = ClassUtils.getClass(""java.text.Normalizer"", false);
            // get static method on Normalizer
            java.lang.reflect.Method method = normalizerClass.getMethod(""normalize"", CharSequence.class, normalizerFormClass);
            // get Normalizer.NFD field
            java.lang.reflect.Field nfd = normalizerFormClass.getField(""NFD"");
            // invoke method
            String decomposed = (String) method.invoke(null, input, nfd.get(null));
            // END of 1.5 reflection
            java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(""\\p{InCombiningDiacriticalMarks}+"");
            return accentPattern.matcher(decomposed).replaceAll("""");
        } catch (ClassNotFoundException cnfe) {
            throw new RuntimeException(""ClassNotFoundException occurred during 1.6 backcompat code"", cnfe);
        } catch (NoSuchMethodException nsme) {
            throw new RuntimeException(""NoSuchMethodException occurred during 1.6 backcompat code"", nsme);
        } catch (NoSuchFieldException nsfe) {
            throw new RuntimeException(""NoSuchFieldException occurred during 1.6 backcompat code"", nsfe);
        } catch (IllegalAccessException iae) {
            throw new RuntimeException(""IllegalAccessException occurred during 1.6 backcompat code"", iae);
        } catch (IllegalArgumentException iae) {
            throw new RuntimeException(""IllegalArgumentException occurred during 1.6 backcompat code"", iae);
        } catch (java.lang.reflect.InvocationTargetException ite) {
            throw new RuntimeException(""InvocationTargetException occurred during 1.6 backcompat code"", ite);
        } catch (SecurityException se) {
            throw new RuntimeException(""SecurityException occurred during 1.6 backcompat code"", se);
        }
    } else {
        throw new UnsupportedOperationException(""The stripAccents(String) method is not supported until Java 1.6"");
    }
}","public void test05568() throws Throwable {
    String string0 = StringUtils.stripAccents(""A2_<q"");
    assertNotNull(string0);
}","/**
 * <p>Removes the accents from a string. </p>
 * <p>NOTE: This is a JDK 1.6 method, it will fail on JDK 1.5. </p>
 *
 * <pre>
 * StringUtils.stripAccents(null)                = null
 * StringUtils.stripAccents("""")                  = """"
 * StringUtils.stripAccents(""control"")           = ""control""
 * StringUtils.stripAccents(""&ecute;clair"")      = ""eclair""
 * </pre>
 *
 * @param input String to be stripped
 * @return String without accents on the text
 *
 * @since 3.0
 */"
"public static String stripAccents(String input) {
    if (input == null) {
        return null;
    }
    if (SystemUtils.isJavaVersionAtLeast(1.6f)) {
        // String decomposed = Normalizer.normalize(input, Normalizer.Form.NFD);
        // START of 1.5 reflection - in 1.6 use the line commented out above
        try {
            // get java.text.Normalizer.Form class
            Class<?> normalizerFormClass = ClassUtils.getClass(""java.text.Normalizer$Form"", false);
            // get Normlizer class
            Class<?> normalizerClass = ClassUtils.getClass(""java.text.Normalizer"", false);
            // get static method on Normalizer
            java.lang.reflect.Method method = normalizerClass.getMethod(""normalize"", CharSequence.class, normalizerFormClass);
            // get Normalizer.NFD field
            java.lang.reflect.Field nfd = normalizerFormClass.getField(""NFD"");
            // invoke method
            String decomposed = (String) method.invoke(null, input, nfd.get(null));
            // END of 1.5 reflection
            java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(""\\p{InCombiningDiacriticalMarks}+"");
            return accentPattern.matcher(decomposed).replaceAll("""");
        } catch (ClassNotFoundException cnfe) {
            throw new RuntimeException(""ClassNotFoundException occurred during 1.6 backcompat code"", cnfe);
        } catch (NoSuchMethodException nsme) {
            throw new RuntimeException(""NoSuchMethodException occurred during 1.6 backcompat code"", nsme);
        } catch (NoSuchFieldException nsfe) {
            throw new RuntimeException(""NoSuchFieldException occurred during 1.6 backcompat code"", nsfe);
        } catch (IllegalAccessException iae) {
            throw new RuntimeException(""IllegalAccessException occurred during 1.6 backcompat code"", iae);
        } catch (IllegalArgumentException iae) {
            throw new RuntimeException(""IllegalArgumentException occurred during 1.6 backcompat code"", iae);
        } catch (java.lang.reflect.InvocationTargetException ite) {
            throw new RuntimeException(""InvocationTargetException occurred during 1.6 backcompat code"", ite);
        } catch (SecurityException se) {
            throw new RuntimeException(""SecurityException occurred during 1.6 backcompat code"", se);
        }
    } else {
        throw new UnsupportedOperationException(""The stripAccents(String) method is not supported until Java 1.6"");
    }
}","public void test05670() throws Throwable {
    String string0 = StringUtils.stripAccents((String) null);
    assertNull(string0);
}","/**
 * <p>Removes the accents from a string. </p>
 * <p>NOTE: This is a JDK 1.6 method, it will fail on JDK 1.5. </p>
 *
 * <pre>
 * StringUtils.stripAccents(null)                = null
 * StringUtils.stripAccents("""")                  = """"
 * StringUtils.stripAccents(""control"")           = ""control""
 * StringUtils.stripAccents(""&ecute;clair"")      = ""eclair""
 * </pre>
 *
 * @param input String to be stripped
 * @return String without accents on the text
 *
 * @since 3.0
 */"
"// Equals
//-----------------------------------------------------------------------
/**
 * <p>Compares two CharSequences, returning <code>true</code> if they are equal.</p>
 *
 * <p><code>null</code>s are handled without exceptions. Two <code>null</code>
 * references are considered to be equal. The comparison is case sensitive.</p>
 *
 * <pre>
 * StringUtils.equals(null, null)   = true
 * StringUtils.equals(null, ""abc"")  = false
 * StringUtils.equals(""abc"", null)  = false
 * StringUtils.equals(""abc"", ""abc"") = true
 * StringUtils.equals(""abc"", ""ABC"") = false
 * </pre>
 *
 * @see java.lang.String#equals(Object)
 * @param cs1  the first CharSequence, may be null
 * @param cs2  the second CharSequence, may be null
 * @return <code>true</code> if the CharSequences are equal, case sensitive, or
 *  both <code>null</code>
 */
public static boolean equals(CharSequence cs1, CharSequence cs2) {
    return cs1 == null ? cs2 == null : cs1.equals(cs2);
}","public void test05771() throws Throwable {
    boolean boolean0 = StringUtils.equals((CharSequence) ""I"", (CharSequence) ""I"");
    assertTrue(boolean0);
}",""
"// Equals
//-----------------------------------------------------------------------
/**
 * <p>Compares two CharSequences, returning <code>true</code> if they are equal.</p>
 *
 * <p><code>null</code>s are handled without exceptions. Two <code>null</code>
 * references are considered to be equal. The comparison is case sensitive.</p>
 *
 * <pre>
 * StringUtils.equals(null, null)   = true
 * StringUtils.equals(null, ""abc"")  = false
 * StringUtils.equals(""abc"", null)  = false
 * StringUtils.equals(""abc"", ""abc"") = true
 * StringUtils.equals(""abc"", ""ABC"") = false
 * </pre>
 *
 * @see java.lang.String#equals(Object)
 * @param cs1  the first CharSequence, may be null
 * @param cs2  the second CharSequence, may be null
 * @return <code>true</code> if the CharSequences are equal, case sensitive, or
 *  both <code>null</code>
 */
public static boolean equals(CharSequence cs1, CharSequence cs2) {
    return cs1 == null ? cs2 == null : cs1.equals(cs2);
}","public void test05872() throws Throwable {
    boolean boolean0 = StringUtils.equals((CharSequence) null, (CharSequence) null);
    assertTrue(boolean0);
}",""
"// Equals
//-----------------------------------------------------------------------
/**
 * <p>Compares two CharSequences, returning <code>true</code> if they are equal.</p>
 *
 * <p><code>null</code>s are handled without exceptions. Two <code>null</code>
 * references are considered to be equal. The comparison is case sensitive.</p>
 *
 * <pre>
 * StringUtils.equals(null, null)   = true
 * StringUtils.equals(null, ""abc"")  = false
 * StringUtils.equals(""abc"", null)  = false
 * StringUtils.equals(""abc"", ""abc"") = true
 * StringUtils.equals(""abc"", ""ABC"") = false
 * </pre>
 *
 * @see java.lang.String#equals(Object)
 * @param cs1  the first CharSequence, may be null
 * @param cs2  the second CharSequence, may be null
 * @return <code>true</code> if the CharSequences are equal, case sensitive, or
 *  both <code>null</code>
 */
public static boolean equals(CharSequence cs1, CharSequence cs2) {
    return cs1 == null ? cs2 == null : cs1.equals(cs2);
}","public void test05973() throws Throwable {
    boolean boolean0 = StringUtils.equals((CharSequence) null, (CharSequence) ""!4#"");
    assertFalse(boolean0);
}",""
"public static boolean equalsIgnoreCase(String str1, String str2) {
    return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);
}","public void test06074() throws Throwable {
    boolean boolean0 = StringUtils.equalsIgnoreCase(""K{IF"", ""K{IF"");
    assertTrue(boolean0);
}","/**
 * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring
 * the case.</p>
 *
 * <p><code>null</code>s are handled without exceptions. Two <code>null</code>
 * references are considered equal. Comparison is case insensitive.</p>
 *
 * <pre>
 * StringUtils.equalsIgnoreCase(null, null)   = true
 * StringUtils.equalsIgnoreCase(null, ""abc"")  = false
 * StringUtils.equalsIgnoreCase(""abc"", null)  = false
 * StringUtils.equalsIgnoreCase(""abc"", ""abc"") = true
 * StringUtils.equalsIgnoreCase(""abc"", ""ABC"") = true
 * </pre>
 *
 * @see java.lang.String#equalsIgnoreCase(String)
 * @param str1  the first String, may be null
 * @param str2  the second String, may be null
 * @return <code>true</code> if the Strings are equal, case insensitive, or
 *  both <code>null</code>
 */"
"public static boolean equalsIgnoreCase(String str1, String str2) {
    return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);
}","public void test06175() throws Throwable {
    boolean boolean0 = StringUtils.equalsIgnoreCase((String) null, ""illegalaccessexception occurred during ]9;w2a8b\""mv}!t codeCannot pad a negative amount: "");
    assertFalse(boolean0);
}","/**
 * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring
 * the case.</p>
 *
 * <p><code>null</code>s are handled without exceptions. Two <code>null</code>
 * references are considered equal. Comparison is case insensitive.</p>
 *
 * <pre>
 * StringUtils.equalsIgnoreCase(null, null)   = true
 * StringUtils.equalsIgnoreCase(null, ""abc"")  = false
 * StringUtils.equalsIgnoreCase(""abc"", null)  = false
 * StringUtils.equalsIgnoreCase(""abc"", ""abc"") = true
 * StringUtils.equalsIgnoreCase(""abc"", ""ABC"") = true
 * </pre>
 *
 * @see java.lang.String#equalsIgnoreCase(String)
 * @param str1  the first String, may be null
 * @param str2  the second String, may be null
 * @return <code>true</code> if the Strings are equal, case insensitive, or
 *  both <code>null</code>
 */"
"public static boolean equalsIgnoreCase(String str1, String str2) {
    return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);
}","public void test06276() throws Throwable {
    boolean boolean0 = StringUtils.equalsIgnoreCase((String) null, (String) null);
    assertTrue(boolean0);
}","/**
 * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring
 * the case.</p>
 *
 * <p><code>null</code>s are handled without exceptions. Two <code>null</code>
 * references are considered equal. Comparison is case insensitive.</p>
 *
 * <pre>
 * StringUtils.equalsIgnoreCase(null, null)   = true
 * StringUtils.equalsIgnoreCase(null, ""abc"")  = false
 * StringUtils.equalsIgnoreCase(""abc"", null)  = false
 * StringUtils.equalsIgnoreCase(""abc"", ""abc"") = true
 * StringUtils.equalsIgnoreCase(""abc"", ""ABC"") = true
 * </pre>
 *
 * @see java.lang.String#equalsIgnoreCase(String)
 * @param str1  the first String, may be null
 * @param str2  the second String, may be null
 * @return <code>true</code> if the Strings are equal, case insensitive, or
 *  both <code>null</code>
 */"
"// IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the first index within a String, handling <code>null</code>.
 * This method uses {@link String#indexOf(int)}.</p>
 *
 * <p>A <code>null</code> or empty ("""") String will return <code>INDEX_NOT_FOUND (-1)</code>.</p>
 *
 * <pre>
 * StringUtils.indexOf(null, *)         = -1
 * StringUtils.indexOf("""", *)           = -1
 * StringUtils.indexOf(""aabaabaa"", 'a') = 0
 * StringUtils.indexOf(""aabaabaa"", 'b') = 2
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchChar  the character to find
 * @return the first index of the search character,
 *  -1 if no match or <code>null</code> string input
 * @since 2.0
 */
public static int indexOf(String str, char searchChar) {
    if (isEmpty(str)) {
        return INDEX_NOT_FOUND;
    }
    return str.indexOf(searchChar);
}","public void test06377() throws Throwable {
    int int0 = StringUtils.indexOf(""TimeToLive of "", ']');
    assertEquals((-1), int0);
}",""
"// IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the first index within a String, handling <code>null</code>.
 * This method uses {@link String#indexOf(int)}.</p>
 *
 * <p>A <code>null</code> or empty ("""") String will return <code>INDEX_NOT_FOUND (-1)</code>.</p>
 *
 * <pre>
 * StringUtils.indexOf(null, *)         = -1
 * StringUtils.indexOf("""", *)           = -1
 * StringUtils.indexOf(""aabaabaa"", 'a') = 0
 * StringUtils.indexOf(""aabaabaa"", 'b') = 2
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchChar  the character to find
 * @return the first index of the search character,
 *  -1 if no match or <code>null</code> string input
 * @since 2.0
 */
public static int indexOf(String str, char searchChar) {
    if (isEmpty(str)) {
        return INDEX_NOT_FOUND;
    }
    return str.indexOf(searchChar);
}","public void test06478() throws Throwable {
    int int0 = StringUtils.indexOf("""", 'C');
    assertEquals((-1), int0);
}",""
"public static int indexOf(String str, char searchChar, int startPos) {
    if (isEmpty(str)) {
        return INDEX_NOT_FOUND;
    }
    return str.indexOf(searchChar, startPos);
}","public void test06579() throws Throwable {
    int int0 = StringUtils.indexOf(""Cannot pad a negative amount: "", '{', (-332));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the first index within a String from a start position,
 * handling <code>null</code>.
 * This method uses {@link String#indexOf(int, int)}.</p>
 *
 * <p>A <code>null</code> or empty ("""") String will return <code>(INDEX_NOT_FOUND) -1</code>.
 * A negative start position is treated as zero.
 * A start position greater than the string length returns <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.indexOf(null, *, *)          = -1
 * StringUtils.indexOf("""", *, *)            = -1
 * StringUtils.indexOf(""aabaabaa"", 'b', 0)  = 2
 * StringUtils.indexOf(""aabaabaa"", 'b', 3)  = 5
 * StringUtils.indexOf(""aabaabaa"", 'b', 9)  = -1
 * StringUtils.indexOf(""aabaabaa"", 'b', -1) = 2
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchChar  the character to find
 * @param startPos  the start position, negative treated as zero
 * @return the first index of the search character,
 *  -1 if no match or <code>null</code> string input
 * @since 2.0
 */"
"public static int indexOf(String str, char searchChar, int startPos) {
    if (isEmpty(str)) {
        return INDEX_NOT_FOUND;
    }
    return str.indexOf(searchChar, startPos);
}","public void test06680() throws Throwable {
    int int0 = StringUtils.indexOf("""", '\'', (-319));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the first index within a String from a start position,
 * handling <code>null</code>.
 * This method uses {@link String#indexOf(int, int)}.</p>
 *
 * <p>A <code>null</code> or empty ("""") String will return <code>(INDEX_NOT_FOUND) -1</code>.
 * A negative start position is treated as zero.
 * A start position greater than the string length returns <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.indexOf(null, *, *)          = -1
 * StringUtils.indexOf("""", *, *)            = -1
 * StringUtils.indexOf(""aabaabaa"", 'b', 0)  = 2
 * StringUtils.indexOf(""aabaabaa"", 'b', 3)  = 5
 * StringUtils.indexOf(""aabaabaa"", 'b', 9)  = -1
 * StringUtils.indexOf(""aabaabaa"", 'b', -1) = 2
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchChar  the character to find
 * @param startPos  the start position, negative treated as zero
 * @return the first index of the search character,
 *  -1 if no match or <code>null</code> string input
 * @since 2.0
 */"
"public static int indexOf(String str, String searchStr) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    return str.indexOf(searchStr);
}","public void test06781() throws Throwable {
    int int0 = StringUtils.indexOf((String) null, (String) null);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the first index within a String, handling <code>null</code>.
 * This method uses {@link String#indexOf(String)}.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.indexOf(null, *)          = -1
 * StringUtils.indexOf(*, null)          = -1
 * StringUtils.indexOf("""", """")           = 0
 * StringUtils.indexOf("""", *)            = -1 (except when * = """")
 * StringUtils.indexOf(""aabaabaa"", ""a"")  = 0
 * StringUtils.indexOf(""aabaabaa"", ""b"")  = 2
 * StringUtils.indexOf(""aabaabaa"", ""ab"") = 1
 * StringUtils.indexOf(""aabaabaa"", """")   = 0
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @return the first index of the search String,
 *  -1 if no match or <code>null</code> string input
 * @since 2.0
 */"
"public static int indexOf(String str, String searchStr) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    return str.indexOf(searchStr);
}","public void test06882() throws Throwable {
    int int0 = StringUtils.indexOf("""", """");
    assertEquals(0, int0);
}","/**
 * <p>Finds the first index within a String, handling <code>null</code>.
 * This method uses {@link String#indexOf(String)}.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.indexOf(null, *)          = -1
 * StringUtils.indexOf(*, null)          = -1
 * StringUtils.indexOf("""", """")           = 0
 * StringUtils.indexOf("""", *)            = -1 (except when * = """")
 * StringUtils.indexOf(""aabaabaa"", ""a"")  = 0
 * StringUtils.indexOf(""aabaabaa"", ""b"")  = 2
 * StringUtils.indexOf(""aabaabaa"", ""ab"") = 1
 * StringUtils.indexOf(""aabaabaa"", """")   = 0
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @return the first index of the search String,
 *  -1 if no match or <code>null</code> string input
 * @since 2.0
 */"
"public static int indexOf(String str, String searchStr) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    return str.indexOf(searchStr);
}","public void test06983() throws Throwable {
    int int0 = StringUtils.indexOf(""          pyyU%R"", (String) null);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the first index within a String, handling <code>null</code>.
 * This method uses {@link String#indexOf(String)}.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.indexOf(null, *)          = -1
 * StringUtils.indexOf(*, null)          = -1
 * StringUtils.indexOf("""", """")           = 0
 * StringUtils.indexOf("""", *)            = -1 (except when * = """")
 * StringUtils.indexOf(""aabaabaa"", ""a"")  = 0
 * StringUtils.indexOf(""aabaabaa"", ""b"")  = 2
 * StringUtils.indexOf(""aabaabaa"", ""ab"") = 1
 * StringUtils.indexOf(""aabaabaa"", """")   = 0
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @return the first index of the search String,
 *  -1 if no match or <code>null</code> string input
 * @since 2.0
 */"
"public static int indexOf(String str, String searchStr, int startPos) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    return str.indexOf(searchStr, startPos);
}","public void test07084() throws Throwable {
    int int0 = StringUtils.indexOf((String) null, (String) null, (-1));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the first index within a String, handling <code>null</code>.
 * This method uses {@link String#indexOf(String, int)}.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A negative start position is treated as zero.
 * An empty ("""") search String always matches.
 * A start position greater than the string length only matches
 * an empty search String.</p>
 *
 * <pre>
 * StringUtils.indexOf(null, *, *)          = -1
 * StringUtils.indexOf(*, null, *)          = -1
 * StringUtils.indexOf("""", """", 0)           = 0
 * StringUtils.indexOf("""", *, 0)            = -1 (except when * = """")
 * StringUtils.indexOf(""aabaabaa"", ""a"", 0)  = 0
 * StringUtils.indexOf(""aabaabaa"", ""b"", 0)  = 2
 * StringUtils.indexOf(""aabaabaa"", ""ab"", 0) = 1
 * StringUtils.indexOf(""aabaabaa"", ""b"", 3)  = 5
 * StringUtils.indexOf(""aabaabaa"", ""b"", 9)  = -1
 * StringUtils.indexOf(""aabaabaa"", ""b"", -1) = 2
 * StringUtils.indexOf(""aabaabaa"", """", 2)   = 2
 * StringUtils.indexOf(""abc"", """", 9)        = 3
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @param startPos  the start position, negative treated as zero
 * @return the first index of the search String,
 *  -1 if no match or <code>null</code> string input
 * @since 2.0
 */"
"public static int indexOf(String str, String searchStr, int startPos) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    return str.indexOf(searchStr, startPos);
}","public void test07185() throws Throwable {
    int int0 = StringUtils.indexOf(""gN"", ""TimeToLive of "", 342);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the first index within a String, handling <code>null</code>.
 * This method uses {@link String#indexOf(String, int)}.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A negative start position is treated as zero.
 * An empty ("""") search String always matches.
 * A start position greater than the string length only matches
 * an empty search String.</p>
 *
 * <pre>
 * StringUtils.indexOf(null, *, *)          = -1
 * StringUtils.indexOf(*, null, *)          = -1
 * StringUtils.indexOf("""", """", 0)           = 0
 * StringUtils.indexOf("""", *, 0)            = -1 (except when * = """")
 * StringUtils.indexOf(""aabaabaa"", ""a"", 0)  = 0
 * StringUtils.indexOf(""aabaabaa"", ""b"", 0)  = 2
 * StringUtils.indexOf(""aabaabaa"", ""ab"", 0) = 1
 * StringUtils.indexOf(""aabaabaa"", ""b"", 3)  = 5
 * StringUtils.indexOf(""aabaabaa"", ""b"", 9)  = -1
 * StringUtils.indexOf(""aabaabaa"", ""b"", -1) = 2
 * StringUtils.indexOf(""aabaabaa"", """", 2)   = 2
 * StringUtils.indexOf(""abc"", """", 9)        = 3
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @param startPos  the start position, negative treated as zero
 * @return the first index of the search String,
 *  -1 if no match or <code>null</code> string input
 * @since 2.0
 */"
"public static int indexOf(String str, String searchStr, int startPos) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    return str.indexOf(searchStr, startPos);
}","public void test07286() throws Throwable {
    int int0 = StringUtils.indexOf(""Search and Replace array lengths don't match: "", (String) null, (-1));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the first index within a String, handling <code>null</code>.
 * This method uses {@link String#indexOf(String, int)}.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A negative start position is treated as zero.
 * An empty ("""") search String always matches.
 * A start position greater than the string length only matches
 * an empty search String.</p>
 *
 * <pre>
 * StringUtils.indexOf(null, *, *)          = -1
 * StringUtils.indexOf(*, null, *)          = -1
 * StringUtils.indexOf("""", """", 0)           = 0
 * StringUtils.indexOf("""", *, 0)            = -1 (except when * = """")
 * StringUtils.indexOf(""aabaabaa"", ""a"", 0)  = 0
 * StringUtils.indexOf(""aabaabaa"", ""b"", 0)  = 2
 * StringUtils.indexOf(""aabaabaa"", ""ab"", 0) = 1
 * StringUtils.indexOf(""aabaabaa"", ""b"", 3)  = 5
 * StringUtils.indexOf(""aabaabaa"", ""b"", 9)  = -1
 * StringUtils.indexOf(""aabaabaa"", ""b"", -1) = 2
 * StringUtils.indexOf(""aabaabaa"", """", 2)   = 2
 * StringUtils.indexOf(""abc"", """", 9)        = 3
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @param startPos  the start position, negative treated as zero
 * @return the first index of the search String,
 *  -1 if no match or <code>null</code> string input
 * @since 2.0
 */"
"public static int ordinalIndexOf(String str, String searchStr, int ordinal) {
    return ordinalIndexOf(str, searchStr, ordinal, false);
}","public void test07387() throws Throwable {
    int int0 = StringUtils.ordinalIndexOf((String) null, (String) null, (-355));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the n-th index within a String, handling <code>null</code>.
 * This method uses {@link String#indexOf(String)}.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.ordinalIndexOf(null, *, *)          = -1
 * StringUtils.ordinalIndexOf(*, null, *)          = -1
 * StringUtils.ordinalIndexOf("""", """", *)           = 0
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""a"", 1)  = 0
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""a"", 2)  = 1
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""b"", 1)  = 2
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""b"", 2)  = 5
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""ab"", 1) = 1
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""ab"", 2) = 4
 * StringUtils.ordinalIndexOf(""aabaabaa"", """", 1)   = 0
 * StringUtils.ordinalIndexOf(""aabaabaa"", """", 2)   = 0
 * </pre>
 *
 * <p>Note that 'head(String str, int n)' may be implemented as: </p>
 *
 * <pre>
 *   str.substring(0, lastOrdinalIndexOf(str, ""\n"", n))
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @param ordinal  the n-th <code>searchStr</code> to find
 * @return the n-th index of the search String,
 *  <code>-1</code> (<code>INDEX_NOT_FOUND</code>) if no match or <code>null</code> string input
 * @since 2.1
 */"
"public static int ordinalIndexOf(String str, String searchStr, int ordinal) {
    return ordinalIndexOf(str, searchStr, ordinal, false);
}","public void test07488() throws Throwable {
    int int0 = StringUtils.ordinalIndexOf(""#j/N2=]ry%][w"", (String) null, 1639);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the n-th index within a String, handling <code>null</code>.
 * This method uses {@link String#indexOf(String)}.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.ordinalIndexOf(null, *, *)          = -1
 * StringUtils.ordinalIndexOf(*, null, *)          = -1
 * StringUtils.ordinalIndexOf("""", """", *)           = 0
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""a"", 1)  = 0
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""a"", 2)  = 1
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""b"", 1)  = 2
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""b"", 2)  = 5
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""ab"", 1) = 1
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""ab"", 2) = 4
 * StringUtils.ordinalIndexOf(""aabaabaa"", """", 1)   = 0
 * StringUtils.ordinalIndexOf(""aabaabaa"", """", 2)   = 0
 * </pre>
 *
 * <p>Note that 'head(String str, int n)' may be implemented as: </p>
 *
 * <pre>
 *   str.substring(0, lastOrdinalIndexOf(str, ""\n"", n))
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @param ordinal  the n-th <code>searchStr</code> to find
 * @return the n-th index of the search String,
 *  <code>-1</code> (<code>INDEX_NOT_FOUND</code>) if no match or <code>null</code> string input
 * @since 2.1
 */"
"public static int ordinalIndexOf(String str, String searchStr, int ordinal) {
    return ordinalIndexOf(str, searchStr, ordinal, false);
}","public void test07589() throws Throwable {
    int int0 = StringUtils.ordinalIndexOf(""!4#"", ""!4#"", (-1587));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the n-th index within a String, handling <code>null</code>.
 * This method uses {@link String#indexOf(String)}.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.ordinalIndexOf(null, *, *)          = -1
 * StringUtils.ordinalIndexOf(*, null, *)          = -1
 * StringUtils.ordinalIndexOf("""", """", *)           = 0
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""a"", 1)  = 0
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""a"", 2)  = 1
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""b"", 1)  = 2
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""b"", 2)  = 5
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""ab"", 1) = 1
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""ab"", 2) = 4
 * StringUtils.ordinalIndexOf(""aabaabaa"", """", 1)   = 0
 * StringUtils.ordinalIndexOf(""aabaabaa"", """", 2)   = 0
 * </pre>
 *
 * <p>Note that 'head(String str, int n)' may be implemented as: </p>
 *
 * <pre>
 *   str.substring(0, lastOrdinalIndexOf(str, ""\n"", n))
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @param ordinal  the n-th <code>searchStr</code> to find
 * @return the n-th index of the search String,
 *  <code>-1</code> (<code>INDEX_NOT_FOUND</code>) if no match or <code>null</code> string input
 * @since 2.1
 */"
"public static int ordinalIndexOf(String str, String searchStr, int ordinal) {
    return ordinalIndexOf(str, searchStr, ordinal, false);
}","public void test07690() throws Throwable {
    int int0 = StringUtils.ordinalIndexOf("""", """", 14);
    assertEquals(0, int0);
}","/**
 * <p>Finds the n-th index within a String, handling <code>null</code>.
 * This method uses {@link String#indexOf(String)}.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.ordinalIndexOf(null, *, *)          = -1
 * StringUtils.ordinalIndexOf(*, null, *)          = -1
 * StringUtils.ordinalIndexOf("""", """", *)           = 0
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""a"", 1)  = 0
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""a"", 2)  = 1
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""b"", 1)  = 2
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""b"", 2)  = 5
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""ab"", 1) = 1
 * StringUtils.ordinalIndexOf(""aabaabaa"", ""ab"", 2) = 4
 * StringUtils.ordinalIndexOf(""aabaabaa"", """", 1)   = 0
 * StringUtils.ordinalIndexOf(""aabaabaa"", """", 2)   = 0
 * </pre>
 *
 * <p>Note that 'head(String str, int n)' may be implemented as: </p>
 *
 * <pre>
 *   str.substring(0, lastOrdinalIndexOf(str, ""\n"", n))
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @param ordinal  the n-th <code>searchStr</code> to find
 * @return the n-th index of the search String,
 *  <code>-1</code> (<code>INDEX_NOT_FOUND</code>) if no match or <code>null</code> string input
 * @since 2.1
 */"
"public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal) {
    return ordinalIndexOf(str, searchStr, ordinal, true);
}","public void test07791() throws Throwable {
    int int0 = StringUtils.lastOrdinalIndexOf(""g"", """", 57);
    assertEquals(1, int0);
}","/**
 * <p>Finds the n-th last index within a String, handling <code>null</code>.
 * This method uses {@link String#lastIndexOf(String)}.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.lastOrdinalIndexOf(null, *, *)          = -1
 * StringUtils.lastOrdinalIndexOf(*, null, *)          = -1
 * StringUtils.lastOrdinalIndexOf("""", """", *)           = 0
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", ""a"", 1)  = 7
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", ""a"", 2)  = 6
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", ""b"", 1)  = 5
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", ""b"", 2)  = 2
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", ""ab"", 1) = 4
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", ""ab"", 2) = 1
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", """", 1)   = 8
 * StringUtils.lastOrdinalIndexOf(""aabaabaa"", """", 2)   = 8
 * </pre>
 *
 * <p>Note that 'tail(String str, int n)' may be implemented as: </p>
 *
 * <pre>
 *   str.substring(lastOrdinalIndexOf(str, ""\n"", n) + 1)
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @param ordinal  the n-th last <code>searchStr</code> to find
 * @return the n-th last index of the search String,
 *  <code>-1</code> (<code>INDEX_NOT_FOUND</code>) if no match or <code>null</code> string input
 * @since 2.5
 */"
"public static int indexOfIgnoreCase(String str, String searchStr, int startPos) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    if (startPos < 0) {
        startPos = 0;
    }
    int endLimit = (str.length() - searchStr.length()) + 1;
    if (startPos > endLimit) {
        return INDEX_NOT_FOUND;
    }
    if (searchStr.length() == 0) {
        return startPos;
    }
    for (int i = startPos; i < endLimit; i++) {
        if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test07892() throws Throwable {
    int int0 = StringUtils.indexOfIgnoreCase((String) null, ""VX!%v9MhW3"", (-592));
    assertEquals((-1), int0);
}","/**
 * <p>Case in-sensitive find of the first index within a String
 * from the specified position.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A negative start position is treated as zero.
 * An empty ("""") search String always matches.
 * A start position greater than the string length only matches
 * an empty search String.</p>
 *
 * <pre>
 * StringUtils.indexOfIgnoreCase(null, *, *)          = -1
 * StringUtils.indexOfIgnoreCase(*, null, *)          = -1
 * StringUtils.indexOfIgnoreCase("""", """", 0)           = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""A"", 0)  = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", 0)  = 2
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""AB"", 0) = 1
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", 3)  = 5
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", 9)  = -1
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", -1) = 2
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", """", 2)   = 2
 * StringUtils.indexOfIgnoreCase(""abc"", """", 9)        = 3
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @param startPos  the start position, negative treated as zero
 * @return the first index of the search String,
 *  -1 if no match or <code>null</code> string input
 * @since 2.5
 */"
"public static int indexOfIgnoreCase(String str, String searchStr) {
    return indexOfIgnoreCase(str, searchStr, 0);
}","public void test07993() throws Throwable {
    int int0 = StringUtils.indexOfIgnoreCase(""Cu`lmeq! B&XHBPeeM"", (String) null);
    assertEquals((-1), int0);
}","/**
 * <p>Case in-sensitive find of the first index within a String.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A negative start position is treated as zero.
 * An empty ("""") search String always matches.
 * A start position greater than the string length only matches
 * an empty search String.</p>
 *
 * <pre>
 * StringUtils.indexOfIgnoreCase(null, *)          = -1
 * StringUtils.indexOfIgnoreCase(*, null)          = -1
 * StringUtils.indexOfIgnoreCase("""", """")           = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""a"")  = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""b"")  = 2
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""ab"") = 1
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @return the first index of the search String,
 *  -1 if no match or <code>null</code> string input
 * @since 2.5
 */"
"public static int indexOfIgnoreCase(String str, String searchStr, int startPos) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    if (startPos < 0) {
        startPos = 0;
    }
    int endLimit = (str.length() - searchStr.length()) + 1;
    if (startPos > endLimit) {
        return INDEX_NOT_FOUND;
    }
    if (searchStr.length() == 0) {
        return startPos;
    }
    for (int i = startPos; i < endLimit; i++) {
        if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test08094() throws Throwable {
    int int0 = StringUtils.indexOfIgnoreCase("" vs "", "" vs "", (-1059));
    assertEquals(0, int0);
}","/**
 * <p>Case in-sensitive find of the first index within a String
 * from the specified position.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A negative start position is treated as zero.
 * An empty ("""") search String always matches.
 * A start position greater than the string length only matches
 * an empty search String.</p>
 *
 * <pre>
 * StringUtils.indexOfIgnoreCase(null, *, *)          = -1
 * StringUtils.indexOfIgnoreCase(*, null, *)          = -1
 * StringUtils.indexOfIgnoreCase("""", """", 0)           = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""A"", 0)  = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", 0)  = 2
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""AB"", 0) = 1
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", 3)  = 5
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", 9)  = -1
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", -1) = 2
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", """", 2)   = 2
 * StringUtils.indexOfIgnoreCase(""abc"", """", 9)        = 3
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @param startPos  the start position, negative treated as zero
 * @return the first index of the search String,
 *  -1 if no match or <code>null</code> string input
 * @since 2.5
 */"
"public static int indexOfIgnoreCase(String str, String searchStr, int startPos) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    if (startPos < 0) {
        startPos = 0;
    }
    int endLimit = (str.length() - searchStr.length()) + 1;
    if (startPos > endLimit) {
        return INDEX_NOT_FOUND;
    }
    if (searchStr.length() == 0) {
        return startPos;
    }
    for (int i = startPos; i < endLimit; i++) {
        if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test08195() throws Throwable {
    int int0 = StringUtils.indexOfIgnoreCase(""search cannot pad a negative amount: t match:"", ""search cannot pad a negative amount: t match: "", 13);
    assertEquals((-1), int0);
}","/**
 * <p>Case in-sensitive find of the first index within a String
 * from the specified position.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A negative start position is treated as zero.
 * An empty ("""") search String always matches.
 * A start position greater than the string length only matches
 * an empty search String.</p>
 *
 * <pre>
 * StringUtils.indexOfIgnoreCase(null, *, *)          = -1
 * StringUtils.indexOfIgnoreCase(*, null, *)          = -1
 * StringUtils.indexOfIgnoreCase("""", """", 0)           = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""A"", 0)  = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", 0)  = 2
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""AB"", 0) = 1
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", 3)  = 5
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", 9)  = -1
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""B"", -1) = 2
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", """", 2)   = 2
 * StringUtils.indexOfIgnoreCase(""abc"", """", 9)        = 3
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @param startPos  the start position, negative treated as zero
 * @return the first index of the search String,
 *  -1 if no match or <code>null</code> string input
 * @since 2.5
 */"
"public static int indexOfIgnoreCase(String str, String searchStr) {
    return indexOfIgnoreCase(str, searchStr, 0);
}","public void test08296() throws Throwable {
    int int0 = StringUtils.indexOfIgnoreCase(""w4pl{s?cXOG==&MWNy5"", ""C2X"");
    assertEquals((-1), int0);
}","/**
 * <p>Case in-sensitive find of the first index within a String.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A negative start position is treated as zero.
 * An empty ("""") search String always matches.
 * A start position greater than the string length only matches
 * an empty search String.</p>
 *
 * <pre>
 * StringUtils.indexOfIgnoreCase(null, *)          = -1
 * StringUtils.indexOfIgnoreCase(*, null)          = -1
 * StringUtils.indexOfIgnoreCase("""", """")           = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""a"")  = 0
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""b"")  = 2
 * StringUtils.indexOfIgnoreCase(""aabaabaa"", ""ab"") = 1
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @return the first index of the search String,
 *  -1 if no match or <code>null</code> string input
 * @since 2.5
 */"
"// LastIndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the last index within a String, handling <code>null</code>.
 * This method uses {@link String#lastIndexOf(int)}.</p>
 *
 * <p>A <code>null</code> or empty ("""") String will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.lastIndexOf(null, *)         = -1
 * StringUtils.lastIndexOf("""", *)           = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'a') = 7
 * StringUtils.lastIndexOf(""aabaabaa"", 'b') = 5
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchChar  the character to find
 * @return the last index of the search character,
 *  -1 if no match or <code>null</code> string input
 * @since 2.0
 */
public static int lastIndexOf(String str, char searchChar) {
    if (isEmpty(str)) {
        return INDEX_NOT_FOUND;
    }
    return str.lastIndexOf(searchChar);
}","public void test08397() throws Throwable {
    int int0 = StringUtils.lastIndexOf(""ed duriang 1"", 'c');
    assertEquals((-1), int0);
}",""
"// LastIndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the last index within a String, handling <code>null</code>.
 * This method uses {@link String#lastIndexOf(int)}.</p>
 *
 * <p>A <code>null</code> or empty ("""") String will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.lastIndexOf(null, *)         = -1
 * StringUtils.lastIndexOf("""", *)           = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'a') = 7
 * StringUtils.lastIndexOf(""aabaabaa"", 'b') = 5
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchChar  the character to find
 * @return the last index of the search character,
 *  -1 if no match or <code>null</code> string input
 * @since 2.0
 */
public static int lastIndexOf(String str, char searchChar) {
    if (isEmpty(str)) {
        return INDEX_NOT_FOUND;
    }
    return str.lastIndexOf(searchChar);
}","public void test08498() throws Throwable {
    int int0 = StringUtils.lastIndexOf((String) null, 'c');
    assertEquals((-1), int0);
}",""
"public static int lastIndexOf(String str, char searchChar, int startPos) {
    if (isEmpty(str)) {
        return INDEX_NOT_FOUND;
    }
    return str.lastIndexOf(searchChar, startPos);
}","public void test08599() throws Throwable {
    int int0 = StringUtils.lastIndexOf("" vs "", 'B', (-1059));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index within a String from a start position,
 * handling <code>null</code>.
 * This method uses {@link String#lastIndexOf(int, int)}.</p>
 *
 * <p>A <code>null</code> or empty ("""") String will return <code>-1</code>.
 * A negative start position returns <code>-1</code>.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOf(null, *, *)          = -1
 * StringUtils.lastIndexOf("""", *,  *)           = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 8)  = 5
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 4)  = 2
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 0)  = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 9)  = 5
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', -1) = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'a', 0)  = 0
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchChar  the character to find
 * @param startPos  the start position
 * @return the last index of the search character,
 *  -1 if no match or <code>null</code> string input
 * @since 2.0
 */"
"public static int lastIndexOf(String str, char searchChar, int startPos) {
    if (isEmpty(str)) {
        return INDEX_NOT_FOUND;
    }
    return str.lastIndexOf(searchChar, startPos);
}","public void test086100() throws Throwable {
    int int0 = StringUtils.lastIndexOf("""", '5', (int) '5');
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index within a String from a start position,
 * handling <code>null</code>.
 * This method uses {@link String#lastIndexOf(int, int)}.</p>
 *
 * <p>A <code>null</code> or empty ("""") String will return <code>-1</code>.
 * A negative start position returns <code>-1</code>.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOf(null, *, *)          = -1
 * StringUtils.lastIndexOf("""", *,  *)           = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 8)  = 5
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 4)  = 2
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 0)  = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', 9)  = 5
 * StringUtils.lastIndexOf(""aabaabaa"", 'b', -1) = -1
 * StringUtils.lastIndexOf(""aabaabaa"", 'a', 0)  = 0
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchChar  the character to find
 * @param startPos  the start position
 * @return the last index of the search character,
 *  -1 if no match or <code>null</code> string input
 * @since 2.0
 */"
"public static int lastIndexOf(String str, String searchStr) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    return str.lastIndexOf(searchStr);
}","public void test087101() throws Throwable {
    int int0 = StringUtils.lastIndexOf((String) null, ""&hj_Y)"");
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index within a String, handling <code>null</code>.
 * This method uses {@link String#lastIndexOf(String)}.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.lastIndexOf(null, *)          = -1
 * StringUtils.lastIndexOf(*, null)          = -1
 * StringUtils.lastIndexOf("""", """")           = 0
 * StringUtils.lastIndexOf(""aabaabaa"", ""a"")  = 0
 * StringUtils.lastIndexOf(""aabaabaa"", ""b"")  = 2
 * StringUtils.lastIndexOf(""aabaabaa"", ""ab"") = 1
 * StringUtils.lastIndexOf(""aabaabaa"", """")   = 8
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @return the last index of the search String,
 *  -1 if no match or <code>null</code> string input
 * @since 2.0
 */"
"public static int lastIndexOf(String str, String searchStr) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    return str.lastIndexOf(searchStr);
}","public void test088102() throws Throwable {
    int int0 = StringUtils.lastIndexOf(""XCEPTION O"", ""xception o"");
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index within a String, handling <code>null</code>.
 * This method uses {@link String#lastIndexOf(String)}.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.lastIndexOf(null, *)          = -1
 * StringUtils.lastIndexOf(*, null)          = -1
 * StringUtils.lastIndexOf("""", """")           = 0
 * StringUtils.lastIndexOf(""aabaabaa"", ""a"")  = 0
 * StringUtils.lastIndexOf(""aabaabaa"", ""b"")  = 2
 * StringUtils.lastIndexOf(""aabaabaa"", ""ab"") = 1
 * StringUtils.lastIndexOf(""aabaabaa"", """")   = 8
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @return the last index of the search String,
 *  -1 if no match or <code>null</code> string input
 * @since 2.0
 */"
"public static int lastIndexOf(String str, String searchStr) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    return str.lastIndexOf(searchStr);
}","public void test089103() throws Throwable {
    int int0 = StringUtils.lastIndexOf(""&hj_Y)"", (String) null);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index within a String, handling <code>null</code>.
 * This method uses {@link String#lastIndexOf(String)}.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.lastIndexOf(null, *)          = -1
 * StringUtils.lastIndexOf(*, null)          = -1
 * StringUtils.lastIndexOf("""", """")           = 0
 * StringUtils.lastIndexOf(""aabaabaa"", ""a"")  = 0
 * StringUtils.lastIndexOf(""aabaabaa"", ""b"")  = 2
 * StringUtils.lastIndexOf(""aabaabaa"", ""ab"") = 1
 * StringUtils.lastIndexOf(""aabaabaa"", """")   = 8
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @return the last index of the search String,
 *  -1 if no match or <code>null</code> string input
 * @since 2.0
 */"
"public static int lastIndexOf(String str, String searchStr, int startPos) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    return str.lastIndexOf(searchStr, startPos);
}","public void test090104() throws Throwable {
    int int0 = StringUtils.lastIndexOf((String) null, (String) null, (-1));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the first index within a String, handling <code>null</code>.
 * This method uses {@link String#lastIndexOf(String, int)}.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A negative start position returns <code>-1</code>.
 * An empty ("""") search String always matches unless the start position is negative.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOf(null, *, *)          = -1
 * StringUtils.lastIndexOf(*, null, *)          = -1
 * StringUtils.lastIndexOf(""aabaabaa"", ""a"", 8)  = 7
 * StringUtils.lastIndexOf(""aabaabaa"", ""b"", 8)  = 5
 * StringUtils.lastIndexOf(""aabaabaa"", ""ab"", 8) = 4
 * StringUtils.lastIndexOf(""aabaabaa"", ""b"", 9)  = 5
 * StringUtils.lastIndexOf(""aabaabaa"", ""b"", -1) = -1
 * StringUtils.lastIndexOf(""aabaabaa"", ""a"", 0)  = 0
 * StringUtils.lastIndexOf(""aabaabaa"", ""b"", 0)  = -1
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @param startPos  the start position, negative treated as zero
 * @return the first index of the search String,
 *  -1 if no match or <code>null</code> string input
 * @since 2.0
 */"
"public static int lastIndexOf(String str, String searchStr, int startPos) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    return str.lastIndexOf(searchStr, startPos);
}","public void test091105() throws Throwable {
    int int0 = StringUtils.lastIndexOf(""DtF,iMG<ifd\r~"", ""DtF,iMG<ifd\r~"", 0);
    assertEquals(0, int0);
}","/**
 * <p>Finds the first index within a String, handling <code>null</code>.
 * This method uses {@link String#lastIndexOf(String, int)}.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A negative start position returns <code>-1</code>.
 * An empty ("""") search String always matches unless the start position is negative.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOf(null, *, *)          = -1
 * StringUtils.lastIndexOf(*, null, *)          = -1
 * StringUtils.lastIndexOf(""aabaabaa"", ""a"", 8)  = 7
 * StringUtils.lastIndexOf(""aabaabaa"", ""b"", 8)  = 5
 * StringUtils.lastIndexOf(""aabaabaa"", ""ab"", 8) = 4
 * StringUtils.lastIndexOf(""aabaabaa"", ""b"", 9)  = 5
 * StringUtils.lastIndexOf(""aabaabaa"", ""b"", -1) = -1
 * StringUtils.lastIndexOf(""aabaabaa"", ""a"", 0)  = 0
 * StringUtils.lastIndexOf(""aabaabaa"", ""b"", 0)  = -1
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @param startPos  the start position, negative treated as zero
 * @return the first index of the search String,
 *  -1 if no match or <code>null</code> string input
 * @since 2.0
 */"
"public static int lastIndexOf(String str, String searchStr, int startPos) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    return str.lastIndexOf(searchStr, startPos);
}","public void test092106() throws Throwable {
    int int0 = StringUtils.lastIndexOf(""{3oB5"", (String) null, 59);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the first index within a String, handling <code>null</code>.
 * This method uses {@link String#lastIndexOf(String, int)}.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A negative start position returns <code>-1</code>.
 * An empty ("""") search String always matches unless the start position is negative.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOf(null, *, *)          = -1
 * StringUtils.lastIndexOf(*, null, *)          = -1
 * StringUtils.lastIndexOf(""aabaabaa"", ""a"", 8)  = 7
 * StringUtils.lastIndexOf(""aabaabaa"", ""b"", 8)  = 5
 * StringUtils.lastIndexOf(""aabaabaa"", ""ab"", 8) = 4
 * StringUtils.lastIndexOf(""aabaabaa"", ""b"", 9)  = 5
 * StringUtils.lastIndexOf(""aabaabaa"", ""b"", -1) = -1
 * StringUtils.lastIndexOf(""aabaabaa"", ""a"", 0)  = 0
 * StringUtils.lastIndexOf(""aabaabaa"", ""b"", 0)  = -1
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @param startPos  the start position, negative treated as zero
 * @return the first index of the search String,
 *  -1 if no match or <code>null</code> string input
 * @since 2.0
 */"
"public static int lastIndexOfIgnoreCase(String str, String searchStr) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    return lastIndexOfIgnoreCase(str, searchStr, str.length());
}","public void test093107() throws Throwable {
    String[] stringArray0 = new String[1];
    int int0 = StringUtils.lastIndexOfIgnoreCase(stringArray0[0], """");
    assertEquals((-1), int0);
}","/**
 * <p>Case in-sensitive find of the last index within a String.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A negative start position returns <code>-1</code>.
 * An empty ("""") search String always matches unless the start position is negative.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOfIgnoreCase(null, *)          = -1
 * StringUtils.lastIndexOfIgnoreCase(*, null)          = -1
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""A"")  = 7
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"")  = 5
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""AB"") = 4
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @return the first index of the search String,
 *  -1 if no match or <code>null</code> string input
 * @since 2.5
 */"
"public static int lastIndexOfIgnoreCase(String str, String searchStr) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    return lastIndexOfIgnoreCase(str, searchStr, str.length());
}","public void test094108() throws Throwable {
    int int0 = StringUtils.lastIndexOfIgnoreCase(""search and replace arrayfn=zku.* don't match: "", ""search and replace array lengths fn=zku.*tch: "");
    assertEquals((-1), int0);
}","/**
 * <p>Case in-sensitive find of the last index within a String.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A negative start position returns <code>-1</code>.
 * An empty ("""") search String always matches unless the start position is negative.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOfIgnoreCase(null, *)          = -1
 * StringUtils.lastIndexOfIgnoreCase(*, null)          = -1
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""A"")  = 7
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"")  = 5
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""AB"") = 4
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @return the first index of the search String,
 *  -1 if no match or <code>null</code> string input
 * @since 2.5
 */"
"public static int lastIndexOfIgnoreCase(String str, String searchStr) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    return lastIndexOfIgnoreCase(str, searchStr, str.length());
}","public void test095109() throws Throwable {
    int int0 = StringUtils.lastIndexOfIgnoreCase(""ackcompat c"", (String) null);
    assertEquals((-1), int0);
}","/**
 * <p>Case in-sensitive find of the last index within a String.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A negative start position returns <code>-1</code>.
 * An empty ("""") search String always matches unless the start position is negative.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOfIgnoreCase(null, *)          = -1
 * StringUtils.lastIndexOfIgnoreCase(*, null)          = -1
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""A"")  = 7
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"")  = 5
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""AB"") = 4
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @return the first index of the search String,
 *  -1 if no match or <code>null</code> string input
 * @since 2.5
 */"
"public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    if (startPos > (str.length() - searchStr.length())) {
        startPos = str.length() - searchStr.length();
    }
    if (startPos < 0) {
        return INDEX_NOT_FOUND;
    }
    if (searchStr.length() == 0) {
        return startPos;
    }
    for (int i = startPos; i >= 0; i--) {
        if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test096110() throws Throwable {
    int int0 = StringUtils.lastIndexOfIgnoreCase((String) null, ""illegalaccessexception occurred during hyurl*irbn5pat code"", 10);
    assertEquals((-1), int0);
}","/**
 * <p>Case in-sensitive find of the last index within a String
 * from the specified position.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A negative start position returns <code>-1</code>.
 * An empty ("""") search String always matches unless the start position is negative.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOfIgnoreCase(null, *, *)          = -1
 * StringUtils.lastIndexOfIgnoreCase(*, null, *)          = -1
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""A"", 8)  = 7
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"", 8)  = 5
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""AB"", 8) = 4
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"", 9)  = 5
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"", -1) = -1
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""A"", 0)  = 0
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"", 0)  = -1
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @param startPos  the start position
 * @return the first index of the search String,
 *  -1 if no match or <code>null</code> string input
 * @since 2.5
 */"
"public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    if (startPos > (str.length() - searchStr.length())) {
        startPos = str.length() - searchStr.length();
    }
    if (startPos < 0) {
        return INDEX_NOT_FOUND;
    }
    if (searchStr.length() == 0) {
        return startPos;
    }
    for (int i = startPos; i >= 0; i--) {
        if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test097111() throws Throwable {
    int int0 = StringUtils.lastIndexOfIgnoreCase("" vs "", (String) null, (-265));
    assertEquals((-1), int0);
}","/**
 * <p>Case in-sensitive find of the last index within a String
 * from the specified position.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A negative start position returns <code>-1</code>.
 * An empty ("""") search String always matches unless the start position is negative.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOfIgnoreCase(null, *, *)          = -1
 * StringUtils.lastIndexOfIgnoreCase(*, null, *)          = -1
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""A"", 8)  = 7
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"", 8)  = 5
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""AB"", 8) = 4
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"", 9)  = 5
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"", -1) = -1
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""A"", 0)  = 0
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"", 0)  = -1
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @param startPos  the start position
 * @return the first index of the search String,
 *  -1 if no match or <code>null</code> string input
 * @since 2.5
 */"
"public static int lastIndexOfIgnoreCase(String str, String searchStr) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    return lastIndexOfIgnoreCase(str, searchStr, str.length());
}","public void test098112() throws Throwable {
    int int0 = StringUtils.lastIndexOfIgnoreCase(""Cannot clone Cloneable type"", """");
    assertEquals(27, int0);
}","/**
 * <p>Case in-sensitive find of the last index within a String.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A negative start position returns <code>-1</code>.
 * An empty ("""") search String always matches unless the start position is negative.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOfIgnoreCase(null, *)          = -1
 * StringUtils.lastIndexOfIgnoreCase(*, null)          = -1
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""A"")  = 7
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"")  = 5
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""AB"") = 4
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @return the first index of the search String,
 *  -1 if no match or <code>null</code> string input
 * @since 2.5
 */"
"public static int lastIndexOfIgnoreCase(String str, String searchStr) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    return lastIndexOfIgnoreCase(str, searchStr, str.length());
}","public void test099113() throws Throwable {
    int int0 = StringUtils.lastIndexOfIgnoreCase(""ackcompat c"", ""illegalaccessexception occurred during 1.6 hyurl*irbn5code"");
    assertEquals((-1), int0);
}","/**
 * <p>Case in-sensitive find of the last index within a String.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A negative start position returns <code>-1</code>.
 * An empty ("""") search String always matches unless the start position is negative.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOfIgnoreCase(null, *)          = -1
 * StringUtils.lastIndexOfIgnoreCase(*, null)          = -1
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""A"")  = 7
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"")  = 5
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""AB"") = 4
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @return the first index of the search String,
 *  -1 if no match or <code>null</code> string input
 * @since 2.5
 */"
"public static int lastIndexOfIgnoreCase(String str, String searchStr) {
    if (str == null || searchStr == null) {
        return INDEX_NOT_FOUND;
    }
    return lastIndexOfIgnoreCase(str, searchStr, str.length());
}","public void test100114() throws Throwable {
    int int0 = StringUtils.lastIndexOfIgnoreCase(""XCEPTION O"", ""xception o"");
    assertEquals(0, int0);
}","/**
 * <p>Case in-sensitive find of the last index within a String.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A negative start position returns <code>-1</code>.
 * An empty ("""") search String always matches unless the start position is negative.
 * A start position greater than the string length searches the whole string.</p>
 *
 * <pre>
 * StringUtils.lastIndexOfIgnoreCase(null, *)          = -1
 * StringUtils.lastIndexOfIgnoreCase(*, null)          = -1
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""A"")  = 7
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""B"")  = 5
 * StringUtils.lastIndexOfIgnoreCase(""aabaabaa"", ""AB"") = 4
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @return the first index of the search String,
 *  -1 if no match or <code>null</code> string input
 * @since 2.5
 */"
"// Contains
//-----------------------------------------------------------------------
/**
 * <p>Checks if String contains a search character, handling <code>null</code>.
 * This method uses {@link String#indexOf(int)}.</p>
 *
 * <p>A <code>null</code> or empty ("""") String will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.contains(null, *)    = false
 * StringUtils.contains("""", *)      = false
 * StringUtils.contains(""abc"", 'a') = true
 * StringUtils.contains(""abc"", 'z') = false
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchChar  the character to find
 * @return true if the String contains the search character,
 *  false if not or <code>null</code> string input
 * @since 2.0
 */
public static boolean contains(String str, char searchChar) {
    if (isEmpty(str)) {
        return false;
    }
    return str.indexOf(searchChar) >= 0;
}","public void test101115() throws Throwable {
    boolean boolean0 = StringUtils.contains(""zh\u018Bzh"", '\u018B');
    assertTrue(boolean0);
}",""
"// Contains
//-----------------------------------------------------------------------
/**
 * <p>Checks if String contains a search character, handling <code>null</code>.
 * This method uses {@link String#indexOf(int)}.</p>
 *
 * <p>A <code>null</code> or empty ("""") String will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.contains(null, *)    = false
 * StringUtils.contains("""", *)      = false
 * StringUtils.contains(""abc"", 'a') = true
 * StringUtils.contains(""abc"", 'z') = false
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchChar  the character to find
 * @return true if the String contains the search character,
 *  false if not or <code>null</code> string input
 * @since 2.0
 */
public static boolean contains(String str, char searchChar) {
    if (isEmpty(str)) {
        return false;
    }
    return str.indexOf(searchChar) >= 0;
}","public void test102116() throws Throwable {
    boolean boolean0 = StringUtils.contains("""", '2');
    assertFalse(boolean0);
}",""
"// Contains
//-----------------------------------------------------------------------
/**
 * <p>Checks if String contains a search character, handling <code>null</code>.
 * This method uses {@link String#indexOf(int)}.</p>
 *
 * <p>A <code>null</code> or empty ("""") String will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.contains(null, *)    = false
 * StringUtils.contains("""", *)      = false
 * StringUtils.contains(""abc"", 'a') = true
 * StringUtils.contains(""abc"", 'z') = false
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchChar  the character to find
 * @return true if the String contains the search character,
 *  false if not or <code>null</code> string input
 * @since 2.0
 */
public static boolean contains(String str, char searchChar) {
    if (isEmpty(str)) {
        return false;
    }
    return str.indexOf(searchChar) >= 0;
}","public void test103117() throws Throwable {
    boolean boolean0 = StringUtils.contains(""-nh."", '{');
    assertFalse(boolean0);
}",""
"public static boolean contains(String str, String searchStr) {
    if (str == null || searchStr == null) {
        return false;
    }
    return str.indexOf(searchStr) >= 0;
}","public void test104118() throws Throwable {
    boolean boolean0 = StringUtils.contains((String) null, (String) null);
    assertFalse(boolean0);
}","/**
 * <p>Checks if String contains a search String, handling <code>null</code>.
 * This method uses {@link String#indexOf(String)}.</p>
 *
 * <p>A <code>null</code> String will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.contains(null, *)     = false
 * StringUtils.contains(*, null)     = false
 * StringUtils.contains("""", """")      = true
 * StringUtils.contains(""abc"", """")   = true
 * StringUtils.contains(""abc"", ""a"")  = true
 * StringUtils.contains(""abc"", ""z"")  = false
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @return true if the String contains the search String,
 *  false if not or <code>null</code> string input
 * @since 2.0
 */"
"public static boolean contains(String str, String searchStr) {
    if (str == null || searchStr == null) {
        return false;
    }
    return str.indexOf(searchStr) >= 0;
}","public void test105119() throws Throwable {
    boolean boolean0 = StringUtils.contains("" "", "" "");
    assertTrue(boolean0);
}","/**
 * <p>Checks if String contains a search String, handling <code>null</code>.
 * This method uses {@link String#indexOf(String)}.</p>
 *
 * <p>A <code>null</code> String will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.contains(null, *)     = false
 * StringUtils.contains(*, null)     = false
 * StringUtils.contains("""", """")      = true
 * StringUtils.contains(""abc"", """")   = true
 * StringUtils.contains(""abc"", ""a"")  = true
 * StringUtils.contains(""abc"", ""z"")  = false
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @return true if the String contains the search String,
 *  false if not or <code>null</code> string input
 * @since 2.0
 */"
"public static boolean contains(String str, String searchStr) {
    if (str == null || searchStr == null) {
        return false;
    }
    return str.indexOf(searchStr) >= 0;
}","public void test106120() throws Throwable {
    boolean boolean0 = StringUtils.contains(""Cu`lm\""eq! B&XHBPeeM"", (String) null);
    assertFalse(boolean0);
}","/**
 * <p>Checks if String contains a search String, handling <code>null</code>.
 * This method uses {@link String#indexOf(String)}.</p>
 *
 * <p>A <code>null</code> String will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.contains(null, *)     = false
 * StringUtils.contains(*, null)     = false
 * StringUtils.contains("""", """")      = true
 * StringUtils.contains(""abc"", """")   = true
 * StringUtils.contains(""abc"", ""a"")  = true
 * StringUtils.contains(""abc"", ""z"")  = false
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @return true if the String contains the search String,
 *  false if not or <code>null</code> string input
 * @since 2.0
 */"
"public static boolean contains(String str, String searchStr) {
    if (str == null || searchStr == null) {
        return false;
    }
    return str.indexOf(searchStr) >= 0;
}","public void test107121() throws Throwable {
    boolean boolean0 = StringUtils.contains(""nd replace array lenghs don't"", ""java.text.Normalizer"");
    assertFalse(boolean0);
}","/**
 * <p>Checks if String contains a search String, handling <code>null</code>.
 * This method uses {@link String#indexOf(String)}.</p>
 *
 * <p>A <code>null</code> String will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.contains(null, *)     = false
 * StringUtils.contains(*, null)     = false
 * StringUtils.contains("""", """")      = true
 * StringUtils.contains(""abc"", """")   = true
 * StringUtils.contains(""abc"", ""a"")  = true
 * StringUtils.contains(""abc"", ""z"")  = false
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @return true if the String contains the search String,
 *  false if not or <code>null</code> string input
 * @since 2.0
 */"
"public static boolean containsIgnoreCase(String str, String searchStr) {
    if (str == null || searchStr == null) {
        return false;
    }
    int len = searchStr.length();
    int max = str.length() - len;
    for (int i = 0; i <= max; i++) {
        if (str.regionMatches(true, i, searchStr, 0, len)) {
            return true;
        }
    }
    return false;
}","public void test108122() throws Throwable {
    boolean boolean0 = StringUtils.containsIgnoreCase((String) null, (String) null);
    assertFalse(boolean0);
}","/**
 * <p>Checks if String contains a search String irrespective of case,
 * handling <code>null</code>. Case-insensitivity is defined as by
 * {@link String#equalsIgnoreCase(String)}.
 *
 * <p>A <code>null</code> String will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.contains(null, *) = false
 * StringUtils.contains(*, null) = false
 * StringUtils.contains("""", """") = true
 * StringUtils.contains(""abc"", """") = true
 * StringUtils.contains(""abc"", ""a"") = true
 * StringUtils.contains(""abc"", ""z"") = false
 * StringUtils.contains(""abc"", ""A"") = true
 * StringUtils.contains(""abc"", ""Z"") = false
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @return true if the String contains the search String irrespective of
 * case or false if not or <code>null</code> string input
 */"
"public static boolean containsIgnoreCase(String str, String searchStr) {
    if (str == null || searchStr == null) {
        return false;
    }
    int len = searchStr.length();
    int max = str.length() - len;
    for (int i = 0; i <= max; i++) {
        if (str.regionMatches(true, i, searchStr, 0, len)) {
            return true;
        }
    }
    return false;
}","public void test109123() throws Throwable {
    boolean boolean0 = StringUtils.containsIgnoreCase("" "", "" "");
    assertTrue(boolean0);
}","/**
 * <p>Checks if String contains a search String irrespective of case,
 * handling <code>null</code>. Case-insensitivity is defined as by
 * {@link String#equalsIgnoreCase(String)}.
 *
 * <p>A <code>null</code> String will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.contains(null, *) = false
 * StringUtils.contains(*, null) = false
 * StringUtils.contains("""", """") = true
 * StringUtils.contains(""abc"", """") = true
 * StringUtils.contains(""abc"", ""a"") = true
 * StringUtils.contains(""abc"", ""z"") = false
 * StringUtils.contains(""abc"", ""A"") = true
 * StringUtils.contains(""abc"", ""Z"") = false
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @return true if the String contains the search String irrespective of
 * case or false if not or <code>null</code> string input
 */"
"public static boolean containsIgnoreCase(String str, String searchStr) {
    if (str == null || searchStr == null) {
        return false;
    }
    int len = searchStr.length();
    int max = str.length() - len;
    for (int i = 0; i <= max; i++) {
        if (str.regionMatches(true, i, searchStr, 0, len)) {
            return true;
        }
    }
    return false;
}","public void test110124() throws Throwable {
    boolean boolean0 = StringUtils.containsIgnoreCase(""(BL'`OXO;K5YJTT"", (String) null);
    assertFalse(boolean0);
}","/**
 * <p>Checks if String contains a search String irrespective of case,
 * handling <code>null</code>. Case-insensitivity is defined as by
 * {@link String#equalsIgnoreCase(String)}.
 *
 * <p>A <code>null</code> String will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.contains(null, *) = false
 * StringUtils.contains(*, null) = false
 * StringUtils.contains("""", """") = true
 * StringUtils.contains(""abc"", """") = true
 * StringUtils.contains(""abc"", ""a"") = true
 * StringUtils.contains(""abc"", ""z"") = false
 * StringUtils.contains(""abc"", ""A"") = true
 * StringUtils.contains(""abc"", ""Z"") = false
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @return true if the String contains the search String irrespective of
 * case or false if not or <code>null</code> string input
 */"
"public static boolean containsIgnoreCase(String str, String searchStr) {
    if (str == null || searchStr == null) {
        return false;
    }
    int len = searchStr.length();
    int max = str.length() - len;
    for (int i = 0; i <= max; i++) {
        if (str.regionMatches(true, i, searchStr, 0, len)) {
            return true;
        }
    }
    return false;
}","public void test111125() throws Throwable {
    boolean boolean0 = StringUtils.containsIgnoreCase(""Search and Replace array lengths don't match: "", ""Cannot pad a negative amount: "");
    assertFalse(boolean0);
}","/**
 * <p>Checks if String contains a search String irrespective of case,
 * handling <code>null</code>. Case-insensitivity is defined as by
 * {@link String#equalsIgnoreCase(String)}.
 *
 * <p>A <code>null</code> String will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.contains(null, *) = false
 * StringUtils.contains(*, null) = false
 * StringUtils.contains("""", """") = true
 * StringUtils.contains(""abc"", """") = true
 * StringUtils.contains(""abc"", ""a"") = true
 * StringUtils.contains(""abc"", ""z"") = false
 * StringUtils.contains(""abc"", ""A"") = true
 * StringUtils.contains(""abc"", ""Z"") = false
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStr  the String to find, may be null
 * @return true if the String contains the search String irrespective of
 * case or false if not or <code>null</code> string input
 */"
"// IndexOfAny chars
//-----------------------------------------------------------------------
/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A <code>null</code> or zero length search array will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)                = -1
 * StringUtils.indexOfAny("""", *)                  = -1
 * StringUtils.indexOfAny(*, null)                = -1
 * StringUtils.indexOfAny(*, [])                  = -1
 * StringUtils.indexOfAny(""zzabyycdxx"",['z','a']) = 0
 * StringUtils.indexOfAny(""zzabyycdxx"",['b','y']) = 3
 * StringUtils.indexOfAny(""aba"", ['z'])           = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 */
public static int indexOfAny(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int csLen = cs.length();
    int searchLen = searchChars.length;
    for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                // ch is a supplementary character
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}","public void test112126() throws Throwable {
    char[] charArray0 = new char[8];
    int int0 = StringUtils.indexOfAny((CharSequence) """", charArray0);
    assertEquals((-1), int0);
}",""
"// IndexOfAny chars
//-----------------------------------------------------------------------
/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A <code>null</code> or zero length search array will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)                = -1
 * StringUtils.indexOfAny("""", *)                  = -1
 * StringUtils.indexOfAny(*, null)                = -1
 * StringUtils.indexOfAny(*, [])                  = -1
 * StringUtils.indexOfAny(""zzabyycdxx"",['z','a']) = 0
 * StringUtils.indexOfAny(""zzabyycdxx"",['b','y']) = 3
 * StringUtils.indexOfAny(""aba"", ['z'])           = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 */
public static int indexOfAny(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int csLen = cs.length();
    int searchLen = searchChars.length;
    for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                // ch is a supplementary character
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}","public void test113127() throws Throwable {
    int int0 = StringUtils.indexOfAny((CharSequence) ""1%1H}13(5mU3a"", (char[]) null);
    assertEquals((-1), int0);
}",""
"public static int indexOfAny(CharSequence cs, String searchChars) {
    if (isEmpty(cs) || isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    return indexOfAny(cs, searchChars.toCharArray());
}","public void test114128() throws Throwable {
    int int0 = StringUtils.indexOfAny((CharSequence) ""(uYD6^VUqvF,L"", ""P,PTu"");
    assertEquals(1, int0);
}","/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A <code>null</code> search string will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)            = -1
 * StringUtils.indexOfAny("""", *)              = -1
 * StringUtils.indexOfAny(*, null)            = -1
 * StringUtils.indexOfAny(*, """")              = -1
 * StringUtils.indexOfAny(""zzabyycdxx"", ""za"") = 0
 * StringUtils.indexOfAny(""zzabyycdxx"", ""by"") = 3
 * StringUtils.indexOfAny(""aba"",""z"")          = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 */"
"public static int indexOfAny(CharSequence cs, String searchChars) {
    if (isEmpty(cs) || isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    return indexOfAny(cs, searchChars.toCharArray());
}","public void test115129() throws Throwable {
    int int0 = StringUtils.indexOfAny((CharSequence) "" x;RcFHLglka{g"", ""P,PTu"");
    assertEquals((-1), int0);
}","/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A <code>null</code> search string will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)            = -1
 * StringUtils.indexOfAny("""", *)              = -1
 * StringUtils.indexOfAny(*, null)            = -1
 * StringUtils.indexOfAny(*, """")              = -1
 * StringUtils.indexOfAny(""zzabyycdxx"", ""za"") = 0
 * StringUtils.indexOfAny(""zzabyycdxx"", ""by"") = 3
 * StringUtils.indexOfAny(""aba"",""z"")          = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 */"
"public static int indexOfAny(CharSequence cs, String searchChars) {
    if (isEmpty(cs) || isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    return indexOfAny(cs, searchChars.toCharArray());
}","public void test116130() throws Throwable {
    int int0 = StringUtils.indexOfAny((CharSequence) """", ""illegalaccessexception occurred during 1.6 hyurl*irbn5code"");
    assertEquals((-1), int0);
}","/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A <code>null</code> search string will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)            = -1
 * StringUtils.indexOfAny("""", *)              = -1
 * StringUtils.indexOfAny(*, null)            = -1
 * StringUtils.indexOfAny(*, """")              = -1
 * StringUtils.indexOfAny(""zzabyycdxx"", ""za"") = 0
 * StringUtils.indexOfAny(""zzabyycdxx"", ""by"") = 3
 * StringUtils.indexOfAny(""aba"",""z"")          = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 */"
"public static int indexOfAny(CharSequence cs, String searchChars) {
    if (isEmpty(cs) || isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    return indexOfAny(cs, searchChars.toCharArray());
}","public void test117131() throws Throwable {
    int int0 = StringUtils.indexOfAny((CharSequence) "" x;RcFHLglka{g"", (String) null);
    assertEquals((-1), int0);
}","/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A <code>null</code> search string will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)            = -1
 * StringUtils.indexOfAny("""", *)              = -1
 * StringUtils.indexOfAny(*, null)            = -1
 * StringUtils.indexOfAny(*, """")              = -1
 * StringUtils.indexOfAny(""zzabyycdxx"", ""za"") = 0
 * StringUtils.indexOfAny(""zzabyycdxx"", ""by"") = 3
 * StringUtils.indexOfAny(""aba"",""z"")          = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 */"
"// ContainsAny
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains any character in the given
 * set of characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>false</code>.
 * A <code>null</code> or zero length search array will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)                = false
 * StringUtils.containsAny("""", *)                  = false
 * StringUtils.containsAny(*, null)                = false
 * StringUtils.containsAny(*, [])                  = false
 * StringUtils.containsAny(""zzabyycdxx"",['z','a']) = true
 * StringUtils.containsAny(""zzabyycdxx"",['b','y']) = true
 * StringUtils.containsAny(""aba"", ['z'])           = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the <code>true</code> if any of the chars are found,
 * <code>false</code> if no match or null input
 * @since 2.4
 */
public static boolean containsAny(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    int csLast = csLength - 1;
    int searchLast = searchLength - 1;
    for (int i = 0; i < csLength; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == ch) {
                if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {
                    // missing low surrogate, fine, like String.indexOf(String)
                    if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        return true;
                    }
                } else {
                    // ch is in the Basic Multilingual Plane
                    return true;
                }
            }
        }
    }
    return false;
}","public void test118132() throws Throwable {
    char[] charArray0 = new char[6];
    boolean boolean0 = StringUtils.containsAny(null, charArray0);
    assertFalse(boolean0);
}",""
"// ContainsAny
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains any character in the given
 * set of characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>false</code>.
 * A <code>null</code> or zero length search array will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)                = false
 * StringUtils.containsAny("""", *)                  = false
 * StringUtils.containsAny(*, null)                = false
 * StringUtils.containsAny(*, [])                  = false
 * StringUtils.containsAny(""zzabyycdxx"",['z','a']) = true
 * StringUtils.containsAny(""zzabyycdxx"",['b','y']) = true
 * StringUtils.containsAny(""aba"", ['z'])           = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the <code>true</code> if any of the chars are found,
 * <code>false</code> if no match or null input
 * @since 2.4
 */
public static boolean containsAny(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    int csLast = csLength - 1;
    int searchLast = searchLength - 1;
    for (int i = 0; i < csLength; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == ch) {
                if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {
                    // missing low surrogate, fine, like String.indexOf(String)
                    if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        return true;
                    }
                } else {
                    // ch is in the Basic Multilingual Plane
                    return true;
                }
            }
        }
    }
    return false;
}","public void test119133() throws Throwable {
    boolean boolean0 = StringUtils.containsAny(""The Character A2_<qt not be null"", (char[]) null);
    assertFalse(boolean0);
}",""
"// ContainsAny
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains any character in the given
 * set of characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>false</code>.
 * A <code>null</code> or zero length search array will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)                = false
 * StringUtils.containsAny("""", *)                  = false
 * StringUtils.containsAny(*, null)                = false
 * StringUtils.containsAny(*, [])                  = false
 * StringUtils.containsAny(""zzabyycdxx"",['z','a']) = true
 * StringUtils.containsAny(""zzabyycdxx"",['b','y']) = true
 * StringUtils.containsAny(""aba"", ['z'])           = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the <code>true</code> if any of the chars are found,
 * <code>false</code> if no match or null input
 * @since 2.4
 */
public static boolean containsAny(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    int csLast = csLength - 1;
    int searchLast = searchLength - 1;
    for (int i = 0; i < csLength; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == ch) {
                if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {
                    // missing low surrogate, fine, like String.indexOf(String)
                    if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        return true;
                    }
                } else {
                    // ch is in the Basic Multilingual Plane
                    return true;
                }
            }
        }
    }
    return false;
}","public void test120134() throws Throwable {
    char[] charArray0 = new char[5];
    boolean boolean0 = StringUtils.containsAny(""\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF"", charArray0);
    assertFalse(boolean0);
}",""
"// ContainsAny
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains any character in the given
 * set of characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>false</code>.
 * A <code>null</code> or zero length search array will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)                = false
 * StringUtils.containsAny("""", *)                  = false
 * StringUtils.containsAny(*, null)                = false
 * StringUtils.containsAny(*, [])                  = false
 * StringUtils.containsAny(""zzabyycdxx"",['z','a']) = true
 * StringUtils.containsAny(""zzabyycdxx"",['b','y']) = true
 * StringUtils.containsAny(""aba"", ['z'])           = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the <code>true</code> if any of the chars are found,
 * <code>false</code> if no match or null input
 * @since 2.4
 */
public static boolean containsAny(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    int csLength = cs.length();
    int searchLength = searchChars.length;
    int csLast = csLength - 1;
    int searchLast = searchLength - 1;
    for (int i = 0; i < csLength; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == ch) {
                if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {
                    // missing low surrogate, fine, like String.indexOf(String)
                    if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        return true;
                    }
                } else {
                    // ch is in the Basic Multilingual Plane
                    return true;
                }
            }
        }
    }
    return false;
}","public void test122135() throws Throwable {
    char[] charArray0 = new char[1];
    boolean boolean0 = StringUtils.containsAny(""\u0000\u0002i#:'ho\u0005\u0006\u0007O\n\u0000\u0001\u0002#:'h\u0004\u0005\u0006\u0007U2\u0000\u0001\u0002J#r'\u0004\u0006SU\n\u0000\u0001\u0002J:'h\u0004\u0005\u0006\u0007U\b\n\u0000\u0002J#:'ho\u0005\u0006\u0007O\n\u0000\u0001\u0002#:'\u0004\u0005\u0006\u0007U2\u0000\u0001\u0002J#r'h\u0006SU\n\u0000\u0001\u0002J#:'h\u0004\u0005\u0006\u0007U\b\n"", charArray0);
    assertTrue(boolean0);
}",""
"public static boolean containsAny(CharSequence cs, String searchChars) {
    if (searchChars == null) {
        return false;
    }
    return containsAny(cs, searchChars.toCharArray());
}","public void test123136() throws Throwable {
    boolean boolean0 = StringUtils.containsAny(""n  lU*so0YbH"", ""searccannot pad a negative amount: n't match: "");
    assertTrue(boolean0);
}","/**
 * <p>
 * Checks if the CharSequence contains any character in the given set of characters.
 * </p>
 *
 * <p>
 * A <code>null</code> CharSequence will return <code>false</code>. A <code>null</code> search CharSequence will return
 * <code>false</code>.
 * </p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)            = false
 * StringUtils.containsAny("""", *)              = false
 * StringUtils.containsAny(*, null)            = false
 * StringUtils.containsAny(*, """")              = false
 * StringUtils.containsAny(""zzabyycdxx"", ""za"") = true
 * StringUtils.containsAny(""zzabyycdxx"", ""by"") = true
 * StringUtils.containsAny(""aba"",""z"")          = false
 * </pre>
 *
 * @param cs
 *            the CharSequence to check, may be null
 * @param searchChars
 *            the chars to search for, may be null
 * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input
 * @since 2.4
 */"
"public static boolean containsAny(CharSequence cs, String searchChars) {
    if (searchChars == null) {
        return false;
    }
    return containsAny(cs, searchChars.toCharArray());
}","public void test124137() throws Throwable {
    boolean boolean0 = StringUtils.containsAny(""h and replace array lengths do"", (String) null);
    assertFalse(boolean0);
}","/**
 * <p>
 * Checks if the CharSequence contains any character in the given set of characters.
 * </p>
 *
 * <p>
 * A <code>null</code> CharSequence will return <code>false</code>. A <code>null</code> search CharSequence will return
 * <code>false</code>.
 * </p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)            = false
 * StringUtils.containsAny("""", *)              = false
 * StringUtils.containsAny(*, null)            = false
 * StringUtils.containsAny(*, """")              = false
 * StringUtils.containsAny(""zzabyycdxx"", ""za"") = true
 * StringUtils.containsAny(""zzabyycdxx"", ""by"") = true
 * StringUtils.containsAny(""aba"",""z"")          = false
 * </pre>
 *
 * @param cs
 *            the CharSequence to check, may be null
 * @param searchChars
 *            the chars to search for, may be null
 * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input
 * @since 2.4
 */"
"// IndexOfAnyBut chars
//-----------------------------------------------------------------------
/**
 * <p>Searches a CharSequence to find the first index of any
 * character not in the given set of characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>-1</code>.
 * A <code>null</code> or zero length search array will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.indexOfAnyBut(null, *)           = -1
 * StringUtils.indexOfAnyBut("""", *)             = -1
 * StringUtils.indexOfAnyBut(*, null)           = -1
 * StringUtils.indexOfAnyBut(*, [])             = -1
 * StringUtils.indexOfAnyBut(""zzabyycdxx"",'za') = 3
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", '')  = 0
 * StringUtils.indexOfAnyBut(""aba"", 'ab')       = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 */
public static int indexOfAnyBut(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int csLen = cs.length();
    int searchLen = searchChars.length;
    outer: for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                continue outer;
            }
        }
        return i;
    }
    return INDEX_NOT_FOUND;
}","public void test125138() throws Throwable {
    char[] charArray0 = new char[2];
    int int0 = StringUtils.indexOfAnyBut((CharSequence) """", charArray0);
    assertEquals((-1), int0);
}",""
"// IndexOfAnyBut chars
//-----------------------------------------------------------------------
/**
 * <p>Searches a CharSequence to find the first index of any
 * character not in the given set of characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>-1</code>.
 * A <code>null</code> or zero length search array will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.indexOfAnyBut(null, *)           = -1
 * StringUtils.indexOfAnyBut("""", *)             = -1
 * StringUtils.indexOfAnyBut(*, null)           = -1
 * StringUtils.indexOfAnyBut(*, [])             = -1
 * StringUtils.indexOfAnyBut(""zzabyycdxx"",'za') = 3
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", '')  = 0
 * StringUtils.indexOfAnyBut(""aba"", 'ab')       = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 */
public static int indexOfAnyBut(CharSequence cs, char[] searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int csLen = cs.length();
    int searchLen = searchChars.length;
    outer: for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                continue outer;
            }
        }
        return i;
    }
    return INDEX_NOT_FOUND;
}","public void test126139() throws Throwable {
    char[] charArray0 = new char[0];
    int int0 = StringUtils.indexOfAnyBut((CharSequence) ""t5-ackcompat cod,q$"", charArray0);
    assertEquals((-1), int0);
}",""
"// ContainsOnly
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains only certain characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>false</code>.
 * A <code>null</code> valid character array will return <code>false</code>.
 * An empty CharSequence (length()=0) always returns <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.containsOnly(null, *)       = false
 * StringUtils.containsOnly(*, null)       = false
 * StringUtils.containsOnly("""", *)         = true
 * StringUtils.containsOnly(""ab"", '')      = false
 * StringUtils.containsOnly(""abab"", 'abc') = true
 * StringUtils.containsOnly(""ab1"", 'abc')  = false
 * StringUtils.containsOnly(""abz"", 'abc')  = false
 * </pre>
 *
 * @param cs  the String to check, may be null
 * @param valid  an array of valid chars, may be null
 * @return true if it only contains valid chars and is non-null
 */
public static boolean containsOnly(CharSequence cs, char[] valid) {
    // All these pre-checks are to maintain API with an older version
    if (valid == null || cs == null) {
        return false;
    }
    if (cs.length() == 0) {
        return true;
    }
    if (valid.length == 0) {
        return false;
    }
    return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND;
}","public void test127140() throws Throwable {
    char[] charArray0 = new char[3];
    boolean boolean0 = StringUtils.containsOnly((CharSequence) ""n  lU*so0YbH"", charArray0);
    assertFalse(boolean0);
}",""
"public static boolean containsOnly(CharSequence cs, String validChars) {
    if (cs == null || validChars == null) {
        return false;
    }
    return containsOnly(cs, validChars.toCharArray());
}","public void test128141() throws Throwable {
    String string0 = StringUtils.rightPad(""cc6V~i\""V$.% "", 4137, ""n  lU*so0YbH"");
    boolean boolean0 = StringUtils.containsOnly((CharSequence) ""n  lU*so0YbH"", string0);
    assertTrue(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only certain characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>false</code>.
 * A <code>null</code> valid character String will return <code>false</code>.
 * An empty String (length()=0) always returns <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.containsOnly(null, *)       = false
 * StringUtils.containsOnly(*, null)       = false
 * StringUtils.containsOnly("""", *)         = true
 * StringUtils.containsOnly(""ab"", """")      = false
 * StringUtils.containsOnly(""abab"", ""abc"") = true
 * StringUtils.containsOnly(""ab1"", ""abc"")  = false
 * StringUtils.containsOnly(""abz"", ""abc"")  = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param validChars  a String of valid chars, may be null
 * @return true if it only contains valid chars and is non-null
 * @since 2.0
 */"
"public static int indexOfAnyBut(String str, String searchChars) {
    if (isEmpty(str) || isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int strLen = str.length();
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (searchChars.indexOf(ch) < 0) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test129142() throws Throwable {
    int int0 = StringUtils.indexOfAnyBut("""", ""P=(D!|"");
    assertEquals((-1), int0);
}","/**
 * <p>Search a String to find the first index of any
 * character not in the given set of characters.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A <code>null</code> search string will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.indexOfAnyBut(null, *)            = -1
 * StringUtils.indexOfAnyBut("""", *)              = -1
 * StringUtils.indexOfAnyBut(*, null)            = -1
 * StringUtils.indexOfAnyBut(*, """")              = -1
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", ""za"") = 3
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", """")   = 0
 * StringUtils.indexOfAnyBut(""aba"",""ab"")         = -1
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 */"
"public static int indexOfAnyBut(String str, String searchChars) {
    if (isEmpty(str) || isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int strLen = str.length();
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (searchChars.indexOf(ch) < 0) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test130143() throws Throwable {
    int int0 = StringUtils.indexOfAnyBut(""XCEPTION O"", (String) null);
    assertEquals((-1), int0);
}","/**
 * <p>Search a String to find the first index of any
 * character not in the given set of characters.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A <code>null</code> search string will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.indexOfAnyBut(null, *)            = -1
 * StringUtils.indexOfAnyBut("""", *)              = -1
 * StringUtils.indexOfAnyBut(*, null)            = -1
 * StringUtils.indexOfAnyBut(*, """")              = -1
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", ""za"") = 3
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", """")   = 0
 * StringUtils.indexOfAnyBut(""aba"",""ab"")         = -1
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 */"
"public static int indexOfAnyBut(String str, String searchChars) {
    if (isEmpty(str) || isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int strLen = str.length();
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (searchChars.indexOf(ch) < 0) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test131144() throws Throwable {
    int int0 = StringUtils.indexOfAnyBut(""Cannot pad a negative amount: "", ""g"");
    assertEquals(0, int0);
}","/**
 * <p>Search a String to find the first index of any
 * character not in the given set of characters.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A <code>null</code> search string will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.indexOfAnyBut(null, *)            = -1
 * StringUtils.indexOfAnyBut("""", *)              = -1
 * StringUtils.indexOfAnyBut(*, null)            = -1
 * StringUtils.indexOfAnyBut(*, """")              = -1
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", ""za"") = 3
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", """")   = 0
 * StringUtils.indexOfAnyBut(""aba"",""ab"")         = -1
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 */"
"public static int indexOfAnyBut(String str, String searchChars) {
    if (isEmpty(str) || isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    int strLen = str.length();
    for (int i = 0; i < strLen; i++) {
        char ch = str.charAt(i);
        if (searchChars.indexOf(ch) < 0) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test132145() throws Throwable {
    int int0 = StringUtils.indexOfAnyBut(""arch and replace array lengths"", ""arch and replace array lengths"");
    assertEquals((-1), int0);
}","/**
 * <p>Search a String to find the first index of any
 * character not in the given set of characters.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A <code>null</code> search string will return <code>-1</code>.</p>
 *
 * <pre>
 * StringUtils.indexOfAnyBut(null, *)            = -1
 * StringUtils.indexOfAnyBut("""", *)              = -1
 * StringUtils.indexOfAnyBut(*, null)            = -1
 * StringUtils.indexOfAnyBut(*, """")              = -1
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", ""za"") = 3
 * StringUtils.indexOfAnyBut(""zzabyycdxx"", """")   = 0
 * StringUtils.indexOfAnyBut(""aba"",""ab"")         = -1
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchChars  the chars to search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 */"
"// ContainsOnly
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains only certain characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>false</code>.
 * A <code>null</code> valid character array will return <code>false</code>.
 * An empty CharSequence (length()=0) always returns <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.containsOnly(null, *)       = false
 * StringUtils.containsOnly(*, null)       = false
 * StringUtils.containsOnly("""", *)         = true
 * StringUtils.containsOnly(""ab"", '')      = false
 * StringUtils.containsOnly(""abab"", 'abc') = true
 * StringUtils.containsOnly(""ab1"", 'abc')  = false
 * StringUtils.containsOnly(""abz"", 'abc')  = false
 * </pre>
 *
 * @param cs  the String to check, may be null
 * @param valid  an array of valid chars, may be null
 * @return true if it only contains valid chars and is non-null
 */
public static boolean containsOnly(CharSequence cs, char[] valid) {
    // All these pre-checks are to maintain API with an older version
    if (valid == null || cs == null) {
        return false;
    }
    if (cs.length() == 0) {
        return true;
    }
    if (valid.length == 0) {
        return false;
    }
    return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND;
}","public void test133146() throws Throwable {
    boolean boolean0 = StringUtils.containsOnly((CharSequence) null, (char[]) null);
    assertFalse(boolean0);
}",""
"// ContainsOnly
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains only certain characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>false</code>.
 * A <code>null</code> valid character array will return <code>false</code>.
 * An empty CharSequence (length()=0) always returns <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.containsOnly(null, *)       = false
 * StringUtils.containsOnly(*, null)       = false
 * StringUtils.containsOnly("""", *)         = true
 * StringUtils.containsOnly(""ab"", '')      = false
 * StringUtils.containsOnly(""abab"", 'abc') = true
 * StringUtils.containsOnly(""ab1"", 'abc')  = false
 * StringUtils.containsOnly(""abz"", 'abc')  = false
 * </pre>
 *
 * @param cs  the String to check, may be null
 * @param valid  an array of valid chars, may be null
 * @return true if it only contains valid chars and is non-null
 */
public static boolean containsOnly(CharSequence cs, char[] valid) {
    // All these pre-checks are to maintain API with an older version
    if (valid == null || cs == null) {
        return false;
    }
    if (cs.length() == 0) {
        return true;
    }
    if (valid.length == 0) {
        return false;
    }
    return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND;
}","public void test134147() throws Throwable {
    char[] charArray0 = new char[3];
    boolean boolean0 = StringUtils.containsOnly((CharSequence) null, charArray0);
    assertFalse(boolean0);
}",""
"// ContainsOnly
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains only certain characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>false</code>.
 * A <code>null</code> valid character array will return <code>false</code>.
 * An empty CharSequence (length()=0) always returns <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.containsOnly(null, *)       = false
 * StringUtils.containsOnly(*, null)       = false
 * StringUtils.containsOnly("""", *)         = true
 * StringUtils.containsOnly(""ab"", '')      = false
 * StringUtils.containsOnly(""abab"", 'abc') = true
 * StringUtils.containsOnly(""ab1"", 'abc')  = false
 * StringUtils.containsOnly(""abz"", 'abc')  = false
 * </pre>
 *
 * @param cs  the String to check, may be null
 * @param valid  an array of valid chars, may be null
 * @return true if it only contains valid chars and is non-null
 */
public static boolean containsOnly(CharSequence cs, char[] valid) {
    // All these pre-checks are to maintain API with an older version
    if (valid == null || cs == null) {
        return false;
    }
    if (cs.length() == 0) {
        return true;
    }
    if (valid.length == 0) {
        return false;
    }
    return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND;
}","public void test135148() throws Throwable {
    CharBuffer charBuffer0 = CharBuffer.wrap((CharSequence) ""/Iw\u0001\""2~8-yy"", 0, 0);
    char[] charArray0 = new char[0];
    boolean boolean0 = StringUtils.containsOnly((CharSequence) charBuffer0, charArray0);
    assertTrue(boolean0);
}",""
"// ContainsOnly
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains only certain characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>false</code>.
 * A <code>null</code> valid character array will return <code>false</code>.
 * An empty CharSequence (length()=0) always returns <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.containsOnly(null, *)       = false
 * StringUtils.containsOnly(*, null)       = false
 * StringUtils.containsOnly("""", *)         = true
 * StringUtils.containsOnly(""ab"", '')      = false
 * StringUtils.containsOnly(""abab"", 'abc') = true
 * StringUtils.containsOnly(""ab1"", 'abc')  = false
 * StringUtils.containsOnly(""abz"", 'abc')  = false
 * </pre>
 *
 * @param cs  the String to check, may be null
 * @param valid  an array of valid chars, may be null
 * @return true if it only contains valid chars and is non-null
 */
public static boolean containsOnly(CharSequence cs, char[] valid) {
    // All these pre-checks are to maintain API with an older version
    if (valid == null || cs == null) {
        return false;
    }
    if (cs.length() == 0) {
        return true;
    }
    if (valid.length == 0) {
        return false;
    }
    return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND;
}","public void test136149() throws Throwable {
    char[] charArray0 = new char[0];
    boolean boolean0 = StringUtils.containsOnly((CharSequence) ""!4#"", charArray0);
    assertFalse(boolean0);
}",""
"public static boolean containsOnly(CharSequence cs, String validChars) {
    if (cs == null || validChars == null) {
        return false;
    }
    return containsOnly(cs, validChars.toCharArray());
}","public void test137150() throws Throwable {
    boolean boolean0 = StringUtils.containsOnly((CharSequence) null, ""arch and replace array lengths"");
    assertFalse(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only certain characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>false</code>.
 * A <code>null</code> valid character String will return <code>false</code>.
 * An empty String (length()=0) always returns <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.containsOnly(null, *)       = false
 * StringUtils.containsOnly(*, null)       = false
 * StringUtils.containsOnly("""", *)         = true
 * StringUtils.containsOnly(""ab"", """")      = false
 * StringUtils.containsOnly(""abab"", ""abc"") = true
 * StringUtils.containsOnly(""ab1"", ""abc"")  = false
 * StringUtils.containsOnly(""abz"", ""abc"")  = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param validChars  a String of valid chars, may be null
 * @return true if it only contains valid chars and is non-null
 * @since 2.0
 */"
"public static boolean containsOnly(CharSequence cs, String validChars) {
    if (cs == null || validChars == null) {
        return false;
    }
    return containsOnly(cs, validChars.toCharArray());
}","public void test138151() throws Throwable {
    boolean boolean0 = StringUtils.containsOnly((CharSequence) ""a3Um5(31}H1%1"", (String) null);
    assertFalse(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only certain characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>false</code>.
 * A <code>null</code> valid character String will return <code>false</code>.
 * An empty String (length()=0) always returns <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.containsOnly(null, *)       = false
 * StringUtils.containsOnly(*, null)       = false
 * StringUtils.containsOnly("""", *)         = true
 * StringUtils.containsOnly(""ab"", """")      = false
 * StringUtils.containsOnly(""abab"", ""abc"") = true
 * StringUtils.containsOnly(""ab1"", ""abc"")  = false
 * StringUtils.containsOnly(""abz"", ""abc"")  = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param validChars  a String of valid chars, may be null
 * @return true if it only contains valid chars and is non-null
 * @since 2.0
 */"
"// ContainsNone
//-----------------------------------------------------------------------
/**
 * <p>Checks that the CharSequence does not contain certain characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>true</code>.
 * A <code>null</code> invalid character array will return <code>true</code>.
 * An empty CharSequence (length()=0) always returns true.</p>
 *
 * <pre>
 * StringUtils.containsNone(null, *)       = true
 * StringUtils.containsNone(*, null)       = true
 * StringUtils.containsNone("""", *)         = true
 * StringUtils.containsNone(""ab"", '')      = true
 * StringUtils.containsNone(""abab"", 'xyz') = true
 * StringUtils.containsNone(""ab1"", 'xyz')  = true
 * StringUtils.containsNone(""abz"", 'xyz')  = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  an array of invalid chars, may be null
 * @return true if it contains none of the invalid chars, or is null
 * @since 2.0
 */
public static boolean containsNone(CharSequence cs, char[] searchChars) {
    if (cs == null || searchChars == null) {
        return true;
    }
    int csLen = cs.length();
    int searchLen = searchChars.length;
    for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                // missing low surrogate, fine, like String.indexOf(String)
                // ch is in the Basic Multilingual Plane
                return false;
            }
        }
    }
    return true;
}","public void test139152() throws Throwable {
    char[] charArray0 = new char[3];
    boolean boolean0 = StringUtils.containsNone((CharSequence) null, charArray0);
    assertTrue(boolean0);
}",""
"// ContainsNone
//-----------------------------------------------------------------------
/**
 * <p>Checks that the CharSequence does not contain certain characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>true</code>.
 * A <code>null</code> invalid character array will return <code>true</code>.
 * An empty CharSequence (length()=0) always returns true.</p>
 *
 * <pre>
 * StringUtils.containsNone(null, *)       = true
 * StringUtils.containsNone(*, null)       = true
 * StringUtils.containsNone("""", *)         = true
 * StringUtils.containsNone(""ab"", '')      = true
 * StringUtils.containsNone(""abab"", 'xyz') = true
 * StringUtils.containsNone(""ab1"", 'xyz')  = true
 * StringUtils.containsNone(""abz"", 'xyz')  = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  an array of invalid chars, may be null
 * @return true if it contains none of the invalid chars, or is null
 * @since 2.0
 */
public static boolean containsNone(CharSequence cs, char[] searchChars) {
    if (cs == null || searchChars == null) {
        return true;
    }
    int csLen = cs.length();
    int searchLen = searchChars.length;
    for (int i = 0; i < csLen; i++) {
        char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                // missing low surrogate, fine, like String.indexOf(String)
                // ch is in the Basic Multilingual Plane
                return false;
            }
        }
    }
    return true;
}","public void test140153() throws Throwable {
    String string0 = StringUtils.rightPad(""cc6V~i\""V$.% "", 4156, ""n  lU*so0YbH"");
    boolean boolean0 = StringUtils.containsNone((CharSequence) string0, (char[]) null);
    assertTrue(boolean0);
}",""
"public static boolean containsNone(CharSequence cs, String invalidChars) {
    if (cs == null || invalidChars == null) {
        return true;
    }
    return containsNone(cs, invalidChars.toCharArray());
}","public void test141154() throws Throwable {
    boolean boolean0 = StringUtils.containsNone((CharSequence) ""OhdsNXzd9<Z"", ""OhdsNXzd9<Z"");
    assertFalse(boolean0);
}","/**
 * <p>Checks that the CharSequence does not contain certain characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>true</code>.
 * A <code>null</code> invalid character array will return <code>true</code>.
 * An empty String ("""") always returns true.</p>
 *
 * <pre>
 * StringUtils.containsNone(null, *)       = true
 * StringUtils.containsNone(*, null)       = true
 * StringUtils.containsNone("""", *)         = true
 * StringUtils.containsNone(""ab"", """")      = true
 * StringUtils.containsNone(""abab"", ""xyz"") = true
 * StringUtils.containsNone(""ab1"", ""xyz"")  = true
 * StringUtils.containsNone(""abz"", ""xyz"")  = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param invalidChars  a String of invalid chars, may be null
 * @return true if it contains none of the invalid chars, or is null
 * @since 2.0
 */"
"public static boolean containsNone(CharSequence cs, String invalidChars) {
    if (cs == null || invalidChars == null) {
        return true;
    }
    return containsNone(cs, invalidChars.toCharArray());
}","public void test142155() throws Throwable {
    boolean boolean0 = StringUtils.containsNone((CharSequence) "" is less than 0: "", ""Y"");
    assertTrue(boolean0);
}","/**
 * <p>Checks that the CharSequence does not contain certain characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>true</code>.
 * A <code>null</code> invalid character array will return <code>true</code>.
 * An empty String ("""") always returns true.</p>
 *
 * <pre>
 * StringUtils.containsNone(null, *)       = true
 * StringUtils.containsNone(*, null)       = true
 * StringUtils.containsNone("""", *)         = true
 * StringUtils.containsNone(""ab"", """")      = true
 * StringUtils.containsNone(""abab"", ""xyz"") = true
 * StringUtils.containsNone(""ab1"", ""xyz"")  = true
 * StringUtils.containsNone(""abz"", ""xyz"")  = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param invalidChars  a String of invalid chars, may be null
 * @return true if it contains none of the invalid chars, or is null
 * @since 2.0
 */"
"public static boolean containsNone(CharSequence cs, String invalidChars) {
    if (cs == null || invalidChars == null) {
        return true;
    }
    return containsNone(cs, invalidChars.toCharArray());
}","public void test143156() throws Throwable {
    boolean boolean0 = StringUtils.containsNone((CharSequence) null, ""Nq|"");
    assertTrue(boolean0);
}","/**
 * <p>Checks that the CharSequence does not contain certain characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>true</code>.
 * A <code>null</code> invalid character array will return <code>true</code>.
 * An empty String ("""") always returns true.</p>
 *
 * <pre>
 * StringUtils.containsNone(null, *)       = true
 * StringUtils.containsNone(*, null)       = true
 * StringUtils.containsNone("""", *)         = true
 * StringUtils.containsNone(""ab"", """")      = true
 * StringUtils.containsNone(""abab"", ""xyz"") = true
 * StringUtils.containsNone(""ab1"", ""xyz"")  = true
 * StringUtils.containsNone(""abz"", ""xyz"")  = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param invalidChars  a String of invalid chars, may be null
 * @return true if it contains none of the invalid chars, or is null
 * @since 2.0
 */"
"public static boolean containsNone(CharSequence cs, String invalidChars) {
    if (cs == null || invalidChars == null) {
        return true;
    }
    return containsNone(cs, invalidChars.toCharArray());
}","public void test144157() throws Throwable {
    boolean boolean0 = StringUtils.containsNone((CharSequence) ""o"", (String) null);
    assertTrue(boolean0);
}","/**
 * <p>Checks that the CharSequence does not contain certain characters.</p>
 *
 * <p>A <code>null</code> CharSequence will return <code>true</code>.
 * A <code>null</code> invalid character array will return <code>true</code>.
 * An empty String ("""") always returns true.</p>
 *
 * <pre>
 * StringUtils.containsNone(null, *)       = true
 * StringUtils.containsNone(*, null)       = true
 * StringUtils.containsNone("""", *)         = true
 * StringUtils.containsNone(""ab"", """")      = true
 * StringUtils.containsNone(""abab"", ""xyz"") = true
 * StringUtils.containsNone(""ab1"", ""xyz"")  = true
 * StringUtils.containsNone(""abz"", ""xyz"")  = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param invalidChars  a String of invalid chars, may be null
 * @return true if it contains none of the invalid chars, or is null
 * @since 2.0
 */"
"// IndexOfAny strings
//-----------------------------------------------------------------------
/**
 * <p>Find the first index of any of a set of potential substrings.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A <code>null</code> or zero length search array will return <code>-1</code>.
 * A <code>null</code> search array entry will be ignored, but a search
 * array containing """" will return <code>0</code> if <code>str</code> is not
 * null. This method uses {@link String#indexOf(String)}.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)                     = -1
 * StringUtils.indexOfAny(*, null)                     = -1
 * StringUtils.indexOfAny(*, [])                       = -1
 * StringUtils.indexOfAny(""zzabyycdxx"", [""ab"",""cd""])   = 2
 * StringUtils.indexOfAny(""zzabyycdxx"", [""cd"",""ab""])   = 2
 * StringUtils.indexOfAny(""zzabyycdxx"", [""mn"",""op""])   = -1
 * StringUtils.indexOfAny(""zzabyycdxx"", [""zab"",""aby""]) = 1
 * StringUtils.indexOfAny(""zzabyycdxx"", [""""])          = 0
 * StringUtils.indexOfAny("""", [""""])                    = 0
 * StringUtils.indexOfAny("""", [""a""])                   = -1
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStrs  the Strings to search for, may be null
 * @return the first index of any of the searchStrs in str, -1 if no match
 */
public static int indexOfAny(String str, String[] searchStrs) {
    if (str == null || searchStrs == null) {
        return INDEX_NOT_FOUND;
    }
    int sz = searchStrs.length;
    // String's can't have a MAX_VALUEth index.
    int ret = Integer.MAX_VALUE;
    int tmp = 0;
    for (int i = 0; i < sz; i++) {
        String search = searchStrs[i];
        if (search == null) {
            continue;
        }
        tmp = str.indexOf(search);
        if (tmp == INDEX_NOT_FOUND) {
            continue;
        }
        if (tmp < ret) {
            ret = tmp;
        }
    }
    return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret;
}","public void test145158() throws Throwable {
    String[] stringArray0 = new String[7];
    int int0 = StringUtils.indexOfAny(stringArray0[6], stringArray0);
    assertEquals((-1), int0);
}",""
"// IndexOfAny strings
//-----------------------------------------------------------------------
/**
 * <p>Find the first index of any of a set of potential substrings.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A <code>null</code> or zero length search array will return <code>-1</code>.
 * A <code>null</code> search array entry will be ignored, but a search
 * array containing """" will return <code>0</code> if <code>str</code> is not
 * null. This method uses {@link String#indexOf(String)}.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)                     = -1
 * StringUtils.indexOfAny(*, null)                     = -1
 * StringUtils.indexOfAny(*, [])                       = -1
 * StringUtils.indexOfAny(""zzabyycdxx"", [""ab"",""cd""])   = 2
 * StringUtils.indexOfAny(""zzabyycdxx"", [""cd"",""ab""])   = 2
 * StringUtils.indexOfAny(""zzabyycdxx"", [""mn"",""op""])   = -1
 * StringUtils.indexOfAny(""zzabyycdxx"", [""zab"",""aby""]) = 1
 * StringUtils.indexOfAny(""zzabyycdxx"", [""""])          = 0
 * StringUtils.indexOfAny("""", [""""])                    = 0
 * StringUtils.indexOfAny("""", [""a""])                   = -1
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStrs  the Strings to search for, may be null
 * @return the first index of any of the searchStrs in str, -1 if no match
 */
public static int indexOfAny(String str, String[] searchStrs) {
    if (str == null || searchStrs == null) {
        return INDEX_NOT_FOUND;
    }
    int sz = searchStrs.length;
    // String's can't have a MAX_VALUEth index.
    int ret = Integer.MAX_VALUE;
    int tmp = 0;
    for (int i = 0; i < sz; i++) {
        String search = searchStrs[i];
        if (search == null) {
            continue;
        }
        tmp = str.indexOf(search);
        if (tmp == INDEX_NOT_FOUND) {
            continue;
        }
        if (tmp < ret) {
            ret = tmp;
        }
    }
    return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret;
}","public void test146159() throws Throwable {
    int int0 = StringUtils.indexOfAny(""Irix"", (String[]) null);
    assertEquals((-1), int0);
}",""
"// IndexOfAny strings
//-----------------------------------------------------------------------
/**
 * <p>Find the first index of any of a set of potential substrings.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A <code>null</code> or zero length search array will return <code>-1</code>.
 * A <code>null</code> search array entry will be ignored, but a search
 * array containing """" will return <code>0</code> if <code>str</code> is not
 * null. This method uses {@link String#indexOf(String)}.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)                     = -1
 * StringUtils.indexOfAny(*, null)                     = -1
 * StringUtils.indexOfAny(*, [])                       = -1
 * StringUtils.indexOfAny(""zzabyycdxx"", [""ab"",""cd""])   = 2
 * StringUtils.indexOfAny(""zzabyycdxx"", [""cd"",""ab""])   = 2
 * StringUtils.indexOfAny(""zzabyycdxx"", [""mn"",""op""])   = -1
 * StringUtils.indexOfAny(""zzabyycdxx"", [""zab"",""aby""]) = 1
 * StringUtils.indexOfAny(""zzabyycdxx"", [""""])          = 0
 * StringUtils.indexOfAny("""", [""""])                    = 0
 * StringUtils.indexOfAny("""", [""a""])                   = -1
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStrs  the Strings to search for, may be null
 * @return the first index of any of the searchStrs in str, -1 if no match
 */
public static int indexOfAny(String str, String[] searchStrs) {
    if (str == null || searchStrs == null) {
        return INDEX_NOT_FOUND;
    }
    int sz = searchStrs.length;
    // String's can't have a MAX_VALUEth index.
    int ret = Integer.MAX_VALUE;
    int tmp = 0;
    for (int i = 0; i < sz; i++) {
        String search = searchStrs[i];
        if (search == null) {
            continue;
        }
        tmp = str.indexOf(search);
        if (tmp == INDEX_NOT_FOUND) {
            continue;
        }
        if (tmp < ret) {
            ret = tmp;
        }
    }
    return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret;
}","public void test147160() throws Throwable {
    String[] stringArray0 = new String[7];
    stringArray0[2] = ""/+gE"";
    int int0 = StringUtils.indexOfAny(""xception o"", stringArray0);
    assertEquals((-1), int0);
}",""
"// IndexOfAny strings
//-----------------------------------------------------------------------
/**
 * <p>Find the first index of any of a set of potential substrings.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A <code>null</code> or zero length search array will return <code>-1</code>.
 * A <code>null</code> search array entry will be ignored, but a search
 * array containing """" will return <code>0</code> if <code>str</code> is not
 * null. This method uses {@link String#indexOf(String)}.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)                     = -1
 * StringUtils.indexOfAny(*, null)                     = -1
 * StringUtils.indexOfAny(*, [])                       = -1
 * StringUtils.indexOfAny(""zzabyycdxx"", [""ab"",""cd""])   = 2
 * StringUtils.indexOfAny(""zzabyycdxx"", [""cd"",""ab""])   = 2
 * StringUtils.indexOfAny(""zzabyycdxx"", [""mn"",""op""])   = -1
 * StringUtils.indexOfAny(""zzabyycdxx"", [""zab"",""aby""]) = 1
 * StringUtils.indexOfAny(""zzabyycdxx"", [""""])          = 0
 * StringUtils.indexOfAny("""", [""""])                    = 0
 * StringUtils.indexOfAny("""", [""a""])                   = -1
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStrs  the Strings to search for, may be null
 * @return the first index of any of the searchStrs in str, -1 if no match
 */
public static int indexOfAny(String str, String[] searchStrs) {
    if (str == null || searchStrs == null) {
        return INDEX_NOT_FOUND;
    }
    int sz = searchStrs.length;
    // String's can't have a MAX_VALUEth index.
    int ret = Integer.MAX_VALUE;
    int tmp = 0;
    for (int i = 0; i < sz; i++) {
        String search = searchStrs[i];
        if (search == null) {
            continue;
        }
        tmp = str.indexOf(search);
        if (tmp == INDEX_NOT_FOUND) {
            continue;
        }
        if (tmp < ret) {
            ret = tmp;
        }
    }
    return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret;
}","public void test148161() throws Throwable {
    String[] stringArray0 = new String[7];
    stringArray0[0] = ""xception o"";
    stringArray0[5] = ""xception o"";
    int int0 = StringUtils.indexOfAny(""xception o"", stringArray0);
    assertEquals(0, int0);
}",""
"public static int lastIndexOfAny(String str, String[] searchStrs) {
    if (str == null || searchStrs == null) {
        return INDEX_NOT_FOUND;
    }
    int sz = searchStrs.length;
    int ret = INDEX_NOT_FOUND;
    int tmp = 0;
    for (int i = 0; i < sz; i++) {
        String search = searchStrs[i];
        if (search == null) {
            continue;
        }
        tmp = str.lastIndexOf(search);
        if (tmp > ret) {
            ret = tmp;
        }
    }
    return ret;
}","public void test149162() throws Throwable {
    String[] stringArray0 = new String[2];
    int int0 = StringUtils.lastIndexOfAny((String) null, stringArray0);
    assertEquals((-1), int0);
}","/**
 * <p>Find the latest index of any of a set of potential substrings.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A <code>null</code> search array will return <code>-1</code>.
 * A <code>null</code> or zero length search array entry will be ignored,
 * but a search array containing """" will return the length of <code>str</code>
 * if <code>str</code> is not null. This method uses {@link String#indexOf(String)}</p>
 *
 * <pre>
 * StringUtils.lastIndexOfAny(null, *)                   = -1
 * StringUtils.lastIndexOfAny(*, null)                   = -1
 * StringUtils.lastIndexOfAny(*, [])                     = -1
 * StringUtils.lastIndexOfAny(*, [null])                 = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""ab"",""cd""]) = 6
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""cd"",""ab""]) = 6
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""op""]) = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""op""]) = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""""])   = 10
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStrs  the Strings to search for, may be null
 * @return the last index of any of the Strings, -1 if no match
 */"
"public static int lastIndexOfAny(String str, String[] searchStrs) {
    if (str == null || searchStrs == null) {
        return INDEX_NOT_FOUND;
    }
    int sz = searchStrs.length;
    int ret = INDEX_NOT_FOUND;
    int tmp = 0;
    for (int i = 0; i < sz; i++) {
        String search = searchStrs[i];
        if (search == null) {
            continue;
        }
        tmp = str.lastIndexOf(search);
        if (tmp > ret) {
            ret = tmp;
        }
    }
    return ret;
}","public void test150163() throws Throwable {
    String[] stringArray0 = new String[1];
    int int0 = StringUtils.lastIndexOfAny(""illegalKccessexceptionoccurred during ]9;w2a8b\""mv}!t code"", stringArray0);
    assertEquals((-1), int0);
}","/**
 * <p>Find the latest index of any of a set of potential substrings.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A <code>null</code> search array will return <code>-1</code>.
 * A <code>null</code> or zero length search array entry will be ignored,
 * but a search array containing """" will return the length of <code>str</code>
 * if <code>str</code> is not null. This method uses {@link String#indexOf(String)}</p>
 *
 * <pre>
 * StringUtils.lastIndexOfAny(null, *)                   = -1
 * StringUtils.lastIndexOfAny(*, null)                   = -1
 * StringUtils.lastIndexOfAny(*, [])                     = -1
 * StringUtils.lastIndexOfAny(*, [null])                 = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""ab"",""cd""]) = 6
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""cd"",""ab""]) = 6
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""op""]) = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""op""]) = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""""])   = 10
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStrs  the Strings to search for, may be null
 * @return the last index of any of the Strings, -1 if no match
 */"
"public static int lastIndexOfAny(String str, String[] searchStrs) {
    if (str == null || searchStrs == null) {
        return INDEX_NOT_FOUND;
    }
    int sz = searchStrs.length;
    int ret = INDEX_NOT_FOUND;
    int tmp = 0;
    for (int i = 0; i < sz; i++) {
        String search = searchStrs[i];
        if (search == null) {
            continue;
        }
        tmp = str.lastIndexOf(search);
        if (tmp > ret) {
            ret = tmp;
        }
    }
    return ret;
}","public void test151164() throws Throwable {
    int int0 = StringUtils.lastIndexOfAny("""", (String[]) null);
    assertEquals((-1), int0);
}","/**
 * <p>Find the latest index of any of a set of potential substrings.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A <code>null</code> search array will return <code>-1</code>.
 * A <code>null</code> or zero length search array entry will be ignored,
 * but a search array containing """" will return the length of <code>str</code>
 * if <code>str</code> is not null. This method uses {@link String#indexOf(String)}</p>
 *
 * <pre>
 * StringUtils.lastIndexOfAny(null, *)                   = -1
 * StringUtils.lastIndexOfAny(*, null)                   = -1
 * StringUtils.lastIndexOfAny(*, [])                     = -1
 * StringUtils.lastIndexOfAny(*, [null])                 = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""ab"",""cd""]) = 6
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""cd"",""ab""]) = 6
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""op""]) = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""op""]) = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""""])   = 10
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStrs  the Strings to search for, may be null
 * @return the last index of any of the Strings, -1 if no match
 */"
"public static int lastIndexOfAny(String str, String[] searchStrs) {
    if (str == null || searchStrs == null) {
        return INDEX_NOT_FOUND;
    }
    int sz = searchStrs.length;
    int ret = INDEX_NOT_FOUND;
    int tmp = 0;
    for (int i = 0; i < sz; i++) {
        String search = searchStrs[i];
        if (search == null) {
            continue;
        }
        tmp = str.lastIndexOf(search);
        if (tmp > ret) {
            ret = tmp;
        }
    }
    return ret;
}","public void test152165() throws Throwable {
    String[] stringArray0 = StringUtils.split(""`-}*)|Ql+v"", 'Y');
    int int0 = StringUtils.lastIndexOfAny(""`-}*)|Ql+v"", stringArray0);
    assertEquals(0, int0);
}","/**
 * <p>Find the latest index of any of a set of potential substrings.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A <code>null</code> search array will return <code>-1</code>.
 * A <code>null</code> or zero length search array entry will be ignored,
 * but a search array containing """" will return the length of <code>str</code>
 * if <code>str</code> is not null. This method uses {@link String#indexOf(String)}</p>
 *
 * <pre>
 * StringUtils.lastIndexOfAny(null, *)                   = -1
 * StringUtils.lastIndexOfAny(*, null)                   = -1
 * StringUtils.lastIndexOfAny(*, [])                     = -1
 * StringUtils.lastIndexOfAny(*, [null])                 = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""ab"",""cd""]) = 6
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""cd"",""ab""]) = 6
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""op""]) = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""op""]) = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""""])   = 10
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStrs  the Strings to search for, may be null
 * @return the last index of any of the Strings, -1 if no match
 */"
"public static int lastIndexOfAny(String str, String[] searchStrs) {
    if (str == null || searchStrs == null) {
        return INDEX_NOT_FOUND;
    }
    int sz = searchStrs.length;
    int ret = INDEX_NOT_FOUND;
    int tmp = 0;
    for (int i = 0; i < sz; i++) {
        String search = searchStrs[i];
        if (search == null) {
            continue;
        }
        tmp = str.lastIndexOf(search);
        if (tmp > ret) {
            ret = tmp;
        }
    }
    return ret;
}","public void test153166() throws Throwable {
    String[] stringArray0 = new String[1];
    stringArray0[0] = ""Cannot pad a negative amount: "";
    int int0 = StringUtils.lastIndexOfAny(""illegalaccessexception occurred during ]9;w2a8b\""mv}!t code"", stringArray0);
    assertEquals((-1), int0);
}","/**
 * <p>Find the latest index of any of a set of potential substrings.</p>
 *
 * <p>A <code>null</code> String will return <code>-1</code>.
 * A <code>null</code> search array will return <code>-1</code>.
 * A <code>null</code> or zero length search array entry will be ignored,
 * but a search array containing """" will return the length of <code>str</code>
 * if <code>str</code> is not null. This method uses {@link String#indexOf(String)}</p>
 *
 * <pre>
 * StringUtils.lastIndexOfAny(null, *)                   = -1
 * StringUtils.lastIndexOfAny(*, null)                   = -1
 * StringUtils.lastIndexOfAny(*, [])                     = -1
 * StringUtils.lastIndexOfAny(*, [null])                 = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""ab"",""cd""]) = 6
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""cd"",""ab""]) = 6
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""op""]) = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""op""]) = -1
 * StringUtils.lastIndexOfAny(""zzabyycdxx"", [""mn"",""""])   = 10
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param searchStrs  the Strings to search for, may be null
 * @return the last index of any of the Strings, -1 if no match
 */"
"// Substring
//-----------------------------------------------------------------------
/**
 * <p>Gets a substring from the specified String avoiding exceptions.</p>
 *
 * <p>A negative start position can be used to start <code>n</code>
 * characters from the end of the String.</p>
 *
 * <p>A <code>null</code> String will return <code>null</code>.
 * An empty ("""") String will return """".</p>
 *
 * <pre>
 * StringUtils.substring(null, *)   = null
 * StringUtils.substring("""", *)     = """"
 * StringUtils.substring(""abc"", 0)  = ""abc""
 * StringUtils.substring(""abc"", 2)  = ""c""
 * StringUtils.substring(""abc"", 4)  = """"
 * StringUtils.substring(""abc"", -2) = ""bc""
 * StringUtils.substring(""abc"", -4) = ""abc""
 * </pre>
 *
 * @param str  the String to get the substring from, may be null
 * @param start  the position to start from, negative means
 *  count back from the end of the String by this many characters
 * @return substring from start position, <code>null</code> if null String input
 */
public static String substring(String str, int start) {
    if (str == null) {
        return null;
    }
    // handle negatives, which means last n characters
    if (start < 0) {
        // remember start is negative
        start = str.length() + start;
    }
    if (start < 0) {
        start = 0;
    }
    if (start > str.length()) {
        return EMPTY;
    }
    return str.substring(start);
}","public void test154167() throws Throwable {
    String string0 = StringUtils.substring("""", (-29));
    assertEquals("""", string0);
}",""
"// Substring
//-----------------------------------------------------------------------
/**
 * <p>Gets a substring from the specified String avoiding exceptions.</p>
 *
 * <p>A negative start position can be used to start <code>n</code>
 * characters from the end of the String.</p>
 *
 * <p>A <code>null</code> String will return <code>null</code>.
 * An empty ("""") String will return """".</p>
 *
 * <pre>
 * StringUtils.substring(null, *)   = null
 * StringUtils.substring("""", *)     = """"
 * StringUtils.substring(""abc"", 0)  = ""abc""
 * StringUtils.substring(""abc"", 2)  = ""c""
 * StringUtils.substring(""abc"", 4)  = """"
 * StringUtils.substring(""abc"", -2) = ""bc""
 * StringUtils.substring(""abc"", -4) = ""abc""
 * </pre>
 *
 * @param str  the String to get the substring from, may be null
 * @param start  the position to start from, negative means
 *  count back from the end of the String by this many characters
 * @return substring from start position, <code>null</code> if null String input
 */
public static String substring(String str, int start) {
    if (str == null) {
        return null;
    }
    // handle negatives, which means last n characters
    if (start < 0) {
        // remember start is negative
        start = str.length() + start;
    }
    if (start < 0) {
        start = 0;
    }
    if (start > str.length()) {
        return EMPTY;
    }
    return str.substring(start);
}","public void test155168() throws Throwable {
    String string0 = StringUtils.substring((String) null, 15);
    assertNull(string0);
}",""
"// Substring
//-----------------------------------------------------------------------
/**
 * <p>Gets a substring from the specified String avoiding exceptions.</p>
 *
 * <p>A negative start position can be used to start <code>n</code>
 * characters from the end of the String.</p>
 *
 * <p>A <code>null</code> String will return <code>null</code>.
 * An empty ("""") String will return """".</p>
 *
 * <pre>
 * StringUtils.substring(null, *)   = null
 * StringUtils.substring("""", *)     = """"
 * StringUtils.substring(""abc"", 0)  = ""abc""
 * StringUtils.substring(""abc"", 2)  = ""c""
 * StringUtils.substring(""abc"", 4)  = """"
 * StringUtils.substring(""abc"", -2) = ""bc""
 * StringUtils.substring(""abc"", -4) = ""abc""
 * </pre>
 *
 * @param str  the String to get the substring from, may be null
 * @param start  the position to start from, negative means
 *  count back from the end of the String by this many characters
 * @return substring from start position, <code>null</code> if null String input
 */
public static String substring(String str, int start) {
    if (str == null) {
        return null;
    }
    // handle negatives, which means last n characters
    if (start < 0) {
        // remember start is negative
        start = str.length() + start;
    }
    if (start < 0) {
        start = 0;
    }
    if (start > str.length()) {
        return EMPTY;
    }
    return str.substring(start);
}","public void test156169() throws Throwable {
    String string0 = StringUtils.substring("" "", 14);
    assertEquals("""", string0);
}",""
"public static String substring(String str, int start, int end) {
    if (str == null) {
        return null;
    }
    // handle negatives
    if (end < 0) {
        // remember end is negative
        end = str.length() + end;
    }
    if (start < 0) {
        // remember start is negative
        start = str.length() + start;
    }
    // check length next
    if (end > str.length()) {
        end = str.length();
    }
    // if start is greater than end, return """"
    if (start > end) {
        return EMPTY;
    }
    if (start < 0) {
        start = 0;
    }
    if (end < 0) {
        end = 0;
    }
    return str.substring(start, end);
}","public void test157170() throws Throwable {
    String string0 = StringUtils.substring(""p"", (-1578), (-1578));
    assertEquals("""", string0);
}","/**
 * <p>Gets a substring from the specified String avoiding exceptions.</p>
 *
 * <p>A negative start position can be used to start/end <code>n</code>
 * characters from the end of the String.</p>
 *
 * <p>The returned substring starts with the character in the <code>start</code>
 * position and ends before the <code>end</code> position. All position counting is
 * zero-based -- i.e., to start at the beginning of the string use
 * <code>start = 0</code>. Negative start and end positions can be used to
 * specify offsets relative to the end of the String.</p>
 *
 * <p>If <code>start</code> is not strictly to the left of <code>end</code>, """"
 * is returned.</p>
 *
 * <pre>
 * StringUtils.substring(null, *, *)    = null
 * StringUtils.substring("""", * ,  *)    = """";
 * StringUtils.substring(""abc"", 0, 2)   = ""ab""
 * StringUtils.substring(""abc"", 2, 0)   = """"
 * StringUtils.substring(""abc"", 2, 4)   = ""c""
 * StringUtils.substring(""abc"", 4, 6)   = """"
 * StringUtils.substring(""abc"", 2, 2)   = """"
 * StringUtils.substring(""abc"", -2, -1) = ""b""
 * StringUtils.substring(""abc"", -4, 2)  = ""ab""
 * </pre>
 *
 * @param str  the String to get the substring from, may be null
 * @param start  the position to start from, negative means
 *  count back from the end of the String by this many characters
 * @param end  the position to end at (exclusive), negative means
 *  count back from the end of the String by this many characters
 * @return substring from start position to end positon,
 *  <code>null</code> if null String input
 */"
"public static String substring(String str, int start, int end) {
    if (str == null) {
        return null;
    }
    // handle negatives
    if (end < 0) {
        // remember end is negative
        end = str.length() + end;
    }
    if (start < 0) {
        // remember start is negative
        start = str.length() + start;
    }
    // check length next
    if (end > str.length()) {
        end = str.length();
    }
    // if start is greater than end, return """"
    if (start > end) {
        return EMPTY;
    }
    if (start < 0) {
        start = 0;
    }
    if (end < 0) {
        end = 0;
    }
    return str.substring(start, end);
}","public void test158172() throws Throwable {
    String string0 = StringUtils.substring((String) null, 1294, 1294);
    assertNull(string0);
}","/**
 * <p>Gets a substring from the specified String avoiding exceptions.</p>
 *
 * <p>A negative start position can be used to start/end <code>n</code>
 * characters from the end of the String.</p>
 *
 * <p>The returned substring starts with the character in the <code>start</code>
 * position and ends before the <code>end</code> position. All position counting is
 * zero-based -- i.e., to start at the beginning of the string use
 * <code>start = 0</code>. Negative start and end positions can be used to
 * specify offsets relative to the end of the String.</p>
 *
 * <p>If <code>start</code> is not strictly to the left of <code>end</code>, """"
 * is returned.</p>
 *
 * <pre>
 * StringUtils.substring(null, *, *)    = null
 * StringUtils.substring("""", * ,  *)    = """";
 * StringUtils.substring(""abc"", 0, 2)   = ""ab""
 * StringUtils.substring(""abc"", 2, 0)   = """"
 * StringUtils.substring(""abc"", 2, 4)   = ""c""
 * StringUtils.substring(""abc"", 4, 6)   = """"
 * StringUtils.substring(""abc"", 2, 2)   = """"
 * StringUtils.substring(""abc"", -2, -1) = ""b""
 * StringUtils.substring(""abc"", -4, 2)  = ""ab""
 * </pre>
 *
 * @param str  the String to get the substring from, may be null
 * @param start  the position to start from, negative means
 *  count back from the end of the String by this many characters
 * @param end  the position to end at (exclusive), negative means
 *  count back from the end of the String by this many characters
 * @return substring from start position to end positon,
 *  <code>null</code> if null String input
 */"
"public static String substring(String str, int start, int end) {
    if (str == null) {
        return null;
    }
    // handle negatives
    if (end < 0) {
        // remember end is negative
        end = str.length() + end;
    }
    if (start < 0) {
        // remember start is negative
        start = str.length() + start;
    }
    // check length next
    if (end > str.length()) {
        end = str.length();
    }
    // if start is greater than end, return """"
    if (start > end) {
        return EMPTY;
    }
    if (start < 0) {
        start = 0;
    }
    if (end < 0) {
        end = 0;
    }
    return str.substring(start, end);
}","public void test159173() throws Throwable {
    String string0 = StringUtils.substring(""Search and Replace array lengths don't mFtch: "", 1, 1);
    assertEquals("""", string0);
}","/**
 * <p>Gets a substring from the specified String avoiding exceptions.</p>
 *
 * <p>A negative start position can be used to start/end <code>n</code>
 * characters from the end of the String.</p>
 *
 * <p>The returned substring starts with the character in the <code>start</code>
 * position and ends before the <code>end</code> position. All position counting is
 * zero-based -- i.e., to start at the beginning of the string use
 * <code>start = 0</code>. Negative start and end positions can be used to
 * specify offsets relative to the end of the String.</p>
 *
 * <p>If <code>start</code> is not strictly to the left of <code>end</code>, """"
 * is returned.</p>
 *
 * <pre>
 * StringUtils.substring(null, *, *)    = null
 * StringUtils.substring("""", * ,  *)    = """";
 * StringUtils.substring(""abc"", 0, 2)   = ""ab""
 * StringUtils.substring(""abc"", 2, 0)   = """"
 * StringUtils.substring(""abc"", 2, 4)   = ""c""
 * StringUtils.substring(""abc"", 4, 6)   = """"
 * StringUtils.substring(""abc"", 2, 2)   = """"
 * StringUtils.substring(""abc"", -2, -1) = ""b""
 * StringUtils.substring(""abc"", -4, 2)  = ""ab""
 * </pre>
 *
 * @param str  the String to get the substring from, may be null
 * @param start  the position to start from, negative means
 *  count back from the end of the String by this many characters
 * @param end  the position to end at (exclusive), negative means
 *  count back from the end of the String by this many characters
 * @return substring from start position to end positon,
 *  <code>null</code> if null String input
 */"
"public static String substring(String str, int start, int end) {
    if (str == null) {
        return null;
    }
    // handle negatives
    if (end < 0) {
        // remember end is negative
        end = str.length() + end;
    }
    if (start < 0) {
        // remember start is negative
        start = str.length() + start;
    }
    // check length next
    if (end > str.length()) {
        end = str.length();
    }
    // if start is greater than end, return """"
    if (start > end) {
        return EMPTY;
    }
    if (start < 0) {
        start = 0;
    }
    if (end < 0) {
        end = 0;
    }
    return str.substring(start, end);
}","public void test160174() throws Throwable {
    String string0 = StringUtils.substring(""'"", 1481, 1481);
    assertEquals("""", string0);
}","/**
 * <p>Gets a substring from the specified String avoiding exceptions.</p>
 *
 * <p>A negative start position can be used to start/end <code>n</code>
 * characters from the end of the String.</p>
 *
 * <p>The returned substring starts with the character in the <code>start</code>
 * position and ends before the <code>end</code> position. All position counting is
 * zero-based -- i.e., to start at the beginning of the string use
 * <code>start = 0</code>. Negative start and end positions can be used to
 * specify offsets relative to the end of the String.</p>
 *
 * <p>If <code>start</code> is not strictly to the left of <code>end</code>, """"
 * is returned.</p>
 *
 * <pre>
 * StringUtils.substring(null, *, *)    = null
 * StringUtils.substring("""", * ,  *)    = """";
 * StringUtils.substring(""abc"", 0, 2)   = ""ab""
 * StringUtils.substring(""abc"", 2, 0)   = """"
 * StringUtils.substring(""abc"", 2, 4)   = ""c""
 * StringUtils.substring(""abc"", 4, 6)   = """"
 * StringUtils.substring(""abc"", 2, 2)   = """"
 * StringUtils.substring(""abc"", -2, -1) = ""b""
 * StringUtils.substring(""abc"", -4, 2)  = ""ab""
 * </pre>
 *
 * @param str  the String to get the substring from, may be null
 * @param start  the position to start from, negative means
 *  count back from the end of the String by this many characters
 * @param end  the position to end at (exclusive), negative means
 *  count back from the end of the String by this many characters
 * @return substring from start position to end positon,
 *  <code>null</code> if null String input
 */"
"// Left/Right/Mid
//-----------------------------------------------------------------------
/**
 * <p>Gets the leftmost <code>len</code> characters of a String.</p>
 *
 * <p>If <code>len</code> characters are not available, or the
 * String is <code>null</code>, the String will be returned without
 * an exception. An exception is thrown if len is negative.</p>
 *
 * <pre>
 * StringUtils.left(null, *)    = null
 * StringUtils.left(*, -ve)     = """"
 * StringUtils.left("""", *)      = """"
 * StringUtils.left(""abc"", 0)   = """"
 * StringUtils.left(""abc"", 2)   = ""ab""
 * StringUtils.left(""abc"", 4)   = ""abc""
 * </pre>
 *
 * @param str  the String to get the leftmost characters from, may be null
 * @param len  the length of the required String, must be zero or positive
 * @return the leftmost characters, <code>null</code> if null String input
 */
public static String left(String str, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0) {
        return EMPTY;
    }
    if (str.length() <= len) {
        return str;
    }
    return str.substring(0, len);
}","public void test161175() throws Throwable {
    String string0 = StringUtils.left("",DGW+0h-JC}8;E@&"", 13);
    assertNotNull(string0);
}",""
"// Left/Right/Mid
//-----------------------------------------------------------------------
/**
 * <p>Gets the leftmost <code>len</code> characters of a String.</p>
 *
 * <p>If <code>len</code> characters are not available, or the
 * String is <code>null</code>, the String will be returned without
 * an exception. An exception is thrown if len is negative.</p>
 *
 * <pre>
 * StringUtils.left(null, *)    = null
 * StringUtils.left(*, -ve)     = """"
 * StringUtils.left("""", *)      = """"
 * StringUtils.left(""abc"", 0)   = """"
 * StringUtils.left(""abc"", 2)   = ""ab""
 * StringUtils.left(""abc"", 4)   = ""abc""
 * </pre>
 *
 * @param str  the String to get the leftmost characters from, may be null
 * @param len  the length of the required String, must be zero or positive
 * @return the leftmost characters, <code>null</code> if null String input
 */
public static String left(String str, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0) {
        return EMPTY;
    }
    if (str.length() <= len) {
        return str;
    }
    return str.substring(0, len);
}","public void test162177() throws Throwable {
    String string0 = StringUtils.left((String) null, 8);
    assertNull(string0);
}",""
"// Left/Right/Mid
//-----------------------------------------------------------------------
/**
 * <p>Gets the leftmost <code>len</code> characters of a String.</p>
 *
 * <p>If <code>len</code> characters are not available, or the
 * String is <code>null</code>, the String will be returned without
 * an exception. An exception is thrown if len is negative.</p>
 *
 * <pre>
 * StringUtils.left(null, *)    = null
 * StringUtils.left(*, -ve)     = """"
 * StringUtils.left("""", *)      = """"
 * StringUtils.left(""abc"", 0)   = """"
 * StringUtils.left(""abc"", 2)   = ""ab""
 * StringUtils.left(""abc"", 4)   = ""abc""
 * </pre>
 *
 * @param str  the String to get the leftmost characters from, may be null
 * @param len  the length of the required String, must be zero or positive
 * @return the leftmost characters, <code>null</code> if null String input
 */
public static String left(String str, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0) {
        return EMPTY;
    }
    if (str.length() <= len) {
        return str;
    }
    return str.substring(0, len);
}","public void test163178() throws Throwable {
    String string0 = StringUtils.left("" "", (-1815));
    assertEquals("""", string0);
}",""
"// Left/Right/Mid
//-----------------------------------------------------------------------
/**
 * <p>Gets the leftmost <code>len</code> characters of a String.</p>
 *
 * <p>If <code>len</code> characters are not available, or the
 * String is <code>null</code>, the String will be returned without
 * an exception. An exception is thrown if len is negative.</p>
 *
 * <pre>
 * StringUtils.left(null, *)    = null
 * StringUtils.left(*, -ve)     = """"
 * StringUtils.left("""", *)      = """"
 * StringUtils.left(""abc"", 0)   = """"
 * StringUtils.left(""abc"", 2)   = ""ab""
 * StringUtils.left(""abc"", 4)   = ""abc""
 * </pre>
 *
 * @param str  the String to get the leftmost characters from, may be null
 * @param len  the length of the required String, must be zero or positive
 * @return the leftmost characters, <code>null</code> if null String input
 */
public static String left(String str, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0) {
        return EMPTY;
    }
    if (str.length() <= len) {
        return str;
    }
    return str.substring(0, len);
}","public void test164179() throws Throwable {
    String string0 = StringUtils.left("" "", 4);
    assertEquals("" "", string0);
}",""
"public static String right(String str, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0) {
        return EMPTY;
    }
    if (str.length() <= len) {
        return str;
    }
    return str.substring(str.length() - len);
}","public void test165180() throws Throwable {
    String string0 = StringUtils.right(""0BLm:~A[12{E;Oq,V"", 1);
    assertEquals(""V"", string0);
}","/**
 * <p>Gets the rightmost <code>len</code> characters of a String.</p>
 *
 * <p>If <code>len</code> characters are not available, or the String
 * is <code>null</code>, the String will be returned without an
 * an exception. An exception is thrown if len is negative.</p>
 *
 * <pre>
 * StringUtils.right(null, *)    = null
 * StringUtils.right(*, -ve)     = """"
 * StringUtils.right("""", *)      = """"
 * StringUtils.right(""abc"", 0)   = """"
 * StringUtils.right(""abc"", 2)   = ""bc""
 * StringUtils.right(""abc"", 4)   = ""abc""
 * </pre>
 *
 * @param str  the String to get the rightmost characters from, may be null
 * @param len  the length of the required String, must be zero or positive
 * @return the rightmost characters, <code>null</code> if null String input
 */"
"public static String right(String str, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0) {
        return EMPTY;
    }
    if (str.length() <= len) {
        return str;
    }
    return str.substring(str.length() - len);
}","public void test166182() throws Throwable {
    String string0 = StringUtils.right((String) null, 4);
    assertNull(string0);
}","/**
 * <p>Gets the rightmost <code>len</code> characters of a String.</p>
 *
 * <p>If <code>len</code> characters are not available, or the String
 * is <code>null</code>, the String will be returned without an
 * an exception. An exception is thrown if len is negative.</p>
 *
 * <pre>
 * StringUtils.right(null, *)    = null
 * StringUtils.right(*, -ve)     = """"
 * StringUtils.right("""", *)      = """"
 * StringUtils.right(""abc"", 0)   = """"
 * StringUtils.right(""abc"", 2)   = ""bc""
 * StringUtils.right(""abc"", 4)   = ""abc""
 * </pre>
 *
 * @param str  the String to get the rightmost characters from, may be null
 * @param len  the length of the required String, must be zero or positive
 * @return the rightmost characters, <code>null</code> if null String input
 */"
"public static String right(String str, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0) {
        return EMPTY;
    }
    if (str.length() <= len) {
        return str;
    }
    return str.substring(str.length() - len);
}","public void test167183() throws Throwable {
    String string0 = StringUtils.right(""k"", (-3042));
    assertEquals("""", string0);
}","/**
 * <p>Gets the rightmost <code>len</code> characters of a String.</p>
 *
 * <p>If <code>len</code> characters are not available, or the String
 * is <code>null</code>, the String will be returned without an
 * an exception. An exception is thrown if len is negative.</p>
 *
 * <pre>
 * StringUtils.right(null, *)    = null
 * StringUtils.right(*, -ve)     = """"
 * StringUtils.right("""", *)      = """"
 * StringUtils.right(""abc"", 0)   = """"
 * StringUtils.right(""abc"", 2)   = ""bc""
 * StringUtils.right(""abc"", 4)   = ""abc""
 * </pre>
 *
 * @param str  the String to get the rightmost characters from, may be null
 * @param len  the length of the required String, must be zero or positive
 * @return the rightmost characters, <code>null</code> if null String input
 */"
"public static String right(String str, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0) {
        return EMPTY;
    }
    if (str.length() <= len) {
        return str;
    }
    return str.substring(str.length() - len);
}","public void test168184() throws Throwable {
    String string0 = StringUtils.right(""'ns`gl.npSprOfC"", 102);
    assertEquals(""'ns`gl.npSprOfC"", string0);
}","/**
 * <p>Gets the rightmost <code>len</code> characters of a String.</p>
 *
 * <p>If <code>len</code> characters are not available, or the String
 * is <code>null</code>, the String will be returned without an
 * an exception. An exception is thrown if len is negative.</p>
 *
 * <pre>
 * StringUtils.right(null, *)    = null
 * StringUtils.right(*, -ve)     = """"
 * StringUtils.right("""", *)      = """"
 * StringUtils.right(""abc"", 0)   = """"
 * StringUtils.right(""abc"", 2)   = ""bc""
 * StringUtils.right(""abc"", 4)   = ""abc""
 * </pre>
 *
 * @param str  the String to get the rightmost characters from, may be null
 * @param len  the length of the required String, must be zero or positive
 * @return the rightmost characters, <code>null</code> if null String input
 */"
"public static String mid(String str, int pos, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0 || pos > str.length()) {
        return EMPTY;
    }
    if (pos < 0) {
        pos = 0;
    }
    if (str.length() <= (pos + len)) {
        return str.substring(pos);
    }
    return str.substring(pos, pos + len);
}","public void test169185() throws Throwable {
    String string0 = StringUtils.mid("" "", (-256), '%');
    assertNotNull(string0);
}","/**
 * <p>Gets <code>len</code> characters from the middle of a String.</p>
 *
 * <p>If <code>len</code> characters are not available, the remainder
 * of the String will be returned without an exception. If the
 * String is <code>null</code>, <code>null</code> will be returned.
 * An exception is thrown if len is negative.</p>
 *
 * <pre>
 * StringUtils.mid(null, *, *)    = null
 * StringUtils.mid(*, *, -ve)     = """"
 * StringUtils.mid("""", 0, *)      = """"
 * StringUtils.mid(""abc"", 0, 2)   = ""ab""
 * StringUtils.mid(""abc"", 0, 4)   = ""abc""
 * StringUtils.mid(""abc"", 2, 4)   = ""c""
 * StringUtils.mid(""abc"", 4, 2)   = """"
 * StringUtils.mid(""abc"", -2, 2)  = ""ab""
 * </pre>
 *
 * @param str  the String to get the characters from, may be null
 * @param pos  the position to start from, negative treated as zero
 * @param len  the length of the required String, must be zero or positive
 * @return the middle characters, <code>null</code> if null String input
 */"
"public static String mid(String str, int pos, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0 || pos > str.length()) {
        return EMPTY;
    }
    if (pos < 0) {
        pos = 0;
    }
    if (str.length() <= (pos + len)) {
        return str.substring(pos);
    }
    return str.substring(pos, pos + len);
}","public void test170187() throws Throwable {
    String string0 = StringUtils.mid((String) null, (-3), (-3));
    assertNull(string0);
}","/**
 * <p>Gets <code>len</code> characters from the middle of a String.</p>
 *
 * <p>If <code>len</code> characters are not available, the remainder
 * of the String will be returned without an exception. If the
 * String is <code>null</code>, <code>null</code> will be returned.
 * An exception is thrown if len is negative.</p>
 *
 * <pre>
 * StringUtils.mid(null, *, *)    = null
 * StringUtils.mid(*, *, -ve)     = """"
 * StringUtils.mid("""", 0, *)      = """"
 * StringUtils.mid(""abc"", 0, 2)   = ""ab""
 * StringUtils.mid(""abc"", 0, 4)   = ""abc""
 * StringUtils.mid(""abc"", 2, 4)   = ""c""
 * StringUtils.mid(""abc"", 4, 2)   = """"
 * StringUtils.mid(""abc"", -2, 2)  = ""ab""
 * </pre>
 *
 * @param str  the String to get the characters from, may be null
 * @param pos  the position to start from, negative treated as zero
 * @param len  the length of the required String, must be zero or positive
 * @return the middle characters, <code>null</code> if null String input
 */"
"public static String mid(String str, int pos, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0 || pos > str.length()) {
        return EMPTY;
    }
    if (pos < 0) {
        pos = 0;
    }
    if (str.length() <= (pos + len)) {
        return str.substring(pos);
    }
    return str.substring(pos, pos + len);
}","public void test171188() throws Throwable {
    String string0 = StringUtils.mid(""I"", (-34), (-34));
    assertEquals("""", string0);
}","/**
 * <p>Gets <code>len</code> characters from the middle of a String.</p>
 *
 * <p>If <code>len</code> characters are not available, the remainder
 * of the String will be returned without an exception. If the
 * String is <code>null</code>, <code>null</code> will be returned.
 * An exception is thrown if len is negative.</p>
 *
 * <pre>
 * StringUtils.mid(null, *, *)    = null
 * StringUtils.mid(*, *, -ve)     = """"
 * StringUtils.mid("""", 0, *)      = """"
 * StringUtils.mid(""abc"", 0, 2)   = ""ab""
 * StringUtils.mid(""abc"", 0, 4)   = ""abc""
 * StringUtils.mid(""abc"", 2, 4)   = ""c""
 * StringUtils.mid(""abc"", 4, 2)   = """"
 * StringUtils.mid(""abc"", -2, 2)  = ""ab""
 * </pre>
 *
 * @param str  the String to get the characters from, may be null
 * @param pos  the position to start from, negative treated as zero
 * @param len  the length of the required String, must be zero or positive
 * @return the middle characters, <code>null</code> if null String input
 */"
"public static String mid(String str, int pos, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0 || pos > str.length()) {
        return EMPTY;
    }
    if (pos < 0) {
        pos = 0;
    }
    if (str.length() <= (pos + len)) {
        return str.substring(pos);
    }
    return str.substring(pos, pos + len);
}","public void test172189() throws Throwable {
    String string0 = StringUtils.mid(""b"", 4, 4);
    assertEquals("""", string0);
}","/**
 * <p>Gets <code>len</code> characters from the middle of a String.</p>
 *
 * <p>If <code>len</code> characters are not available, the remainder
 * of the String will be returned without an exception. If the
 * String is <code>null</code>, <code>null</code> will be returned.
 * An exception is thrown if len is negative.</p>
 *
 * <pre>
 * StringUtils.mid(null, *, *)    = null
 * StringUtils.mid(*, *, -ve)     = """"
 * StringUtils.mid("""", 0, *)      = """"
 * StringUtils.mid(""abc"", 0, 2)   = ""ab""
 * StringUtils.mid(""abc"", 0, 4)   = ""abc""
 * StringUtils.mid(""abc"", 2, 4)   = ""c""
 * StringUtils.mid(""abc"", 4, 2)   = """"
 * StringUtils.mid(""abc"", -2, 2)  = ""ab""
 * </pre>
 *
 * @param str  the String to get the characters from, may be null
 * @param pos  the position to start from, negative treated as zero
 * @param len  the length of the required String, must be zero or positive
 * @return the middle characters, <code>null</code> if null String input
 */"
"public static String mid(String str, int pos, int len) {
    if (str == null) {
        return null;
    }
    if (len < 0 || pos > str.length()) {
        return EMPTY;
    }
    if (pos < 0) {
        pos = 0;
    }
    if (str.length() <= (pos + len)) {
        return str.substring(pos);
    }
    return str.substring(pos, pos + len);
}","public void test173190() throws Throwable {
    String string0 = StringUtils.mid(""^amxhe89wC`~>"", 4, 4);
    assertNotNull(string0);
}","/**
 * <p>Gets <code>len</code> characters from the middle of a String.</p>
 *
 * <p>If <code>len</code> characters are not available, the remainder
 * of the String will be returned without an exception. If the
 * String is <code>null</code>, <code>null</code> will be returned.
 * An exception is thrown if len is negative.</p>
 *
 * <pre>
 * StringUtils.mid(null, *, *)    = null
 * StringUtils.mid(*, *, -ve)     = """"
 * StringUtils.mid("""", 0, *)      = """"
 * StringUtils.mid(""abc"", 0, 2)   = ""ab""
 * StringUtils.mid(""abc"", 0, 4)   = ""abc""
 * StringUtils.mid(""abc"", 2, 4)   = ""c""
 * StringUtils.mid(""abc"", 4, 2)   = """"
 * StringUtils.mid(""abc"", -2, 2)  = ""ab""
 * </pre>
 *
 * @param str  the String to get the characters from, may be null
 * @param pos  the position to start from, negative treated as zero
 * @param len  the length of the required String, must be zero or positive
 * @return the middle characters, <code>null</code> if null String input
 */"
"// SubStringAfter/SubStringBefore
//-----------------------------------------------------------------------
/**
 * <p>Gets the substring before the first occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A <code>null</code> string input will return <code>null</code>.
 * An empty ("""") string input will return the empty string.
 * A <code>null</code> separator will return the input string.</p>
 *
 * <p>If nothing is found, the string input is returned.</p>
 *
 * <pre>
 * StringUtils.substringBefore(null, *)      = null
 * StringUtils.substringBefore("""", *)        = """"
 * StringUtils.substringBefore(""abc"", ""a"")   = """"
 * StringUtils.substringBefore(""abcba"", ""b"") = ""a""
 * StringUtils.substringBefore(""abc"", ""c"")   = ""ab""
 * StringUtils.substringBefore(""abc"", ""d"")   = ""abc""
 * StringUtils.substringBefore(""abc"", """")    = """"
 * StringUtils.substringBefore(""abc"", null)  = ""abc""
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring before the first occurrence of the separator,
 *  <code>null</code> if null String input
 * @since 2.0
 */
public static String substringBefore(String str, String separator) {
    if (isEmpty(str) || separator == null) {
        return str;
    }
    if (separator.length() == 0) {
        return EMPTY;
    }
    int pos = str.indexOf(separator);
    if (pos == INDEX_NOT_FOUND) {
        return str;
    }
    return str.substring(0, pos);
}","public void test174192() throws Throwable {
    String string0 = StringUtils.substringBefore("""", """");
    assertEquals("""", string0);
}",""
"// SubStringAfter/SubStringBefore
//-----------------------------------------------------------------------
/**
 * <p>Gets the substring before the first occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A <code>null</code> string input will return <code>null</code>.
 * An empty ("""") string input will return the empty string.
 * A <code>null</code> separator will return the input string.</p>
 *
 * <p>If nothing is found, the string input is returned.</p>
 *
 * <pre>
 * StringUtils.substringBefore(null, *)      = null
 * StringUtils.substringBefore("""", *)        = """"
 * StringUtils.substringBefore(""abc"", ""a"")   = """"
 * StringUtils.substringBefore(""abcba"", ""b"") = ""a""
 * StringUtils.substringBefore(""abc"", ""c"")   = ""ab""
 * StringUtils.substringBefore(""abc"", ""d"")   = ""abc""
 * StringUtils.substringBefore(""abc"", """")    = """"
 * StringUtils.substringBefore(""abc"", null)  = ""abc""
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring before the first occurrence of the separator,
 *  <code>null</code> if null String input
 * @since 2.0
 */
public static String substringBefore(String str, String separator) {
    if (isEmpty(str) || separator == null) {
        return str;
    }
    if (separator.length() == 0) {
        return EMPTY;
    }
    int pos = str.indexOf(separator);
    if (pos == INDEX_NOT_FOUND) {
        return str;
    }
    return str.substring(0, pos);
}","public void test175193() throws Throwable {
    String string0 = StringUtils.substringBefore(""line.separator"", (String) null);
    assertEquals(""line.separator"", string0);
}",""
"// SubStringAfter/SubStringBefore
//-----------------------------------------------------------------------
/**
 * <p>Gets the substring before the first occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A <code>null</code> string input will return <code>null</code>.
 * An empty ("""") string input will return the empty string.
 * A <code>null</code> separator will return the input string.</p>
 *
 * <p>If nothing is found, the string input is returned.</p>
 *
 * <pre>
 * StringUtils.substringBefore(null, *)      = null
 * StringUtils.substringBefore("""", *)        = """"
 * StringUtils.substringBefore(""abc"", ""a"")   = """"
 * StringUtils.substringBefore(""abcba"", ""b"") = ""a""
 * StringUtils.substringBefore(""abc"", ""c"")   = ""ab""
 * StringUtils.substringBefore(""abc"", ""d"")   = ""abc""
 * StringUtils.substringBefore(""abc"", """")    = """"
 * StringUtils.substringBefore(""abc"", null)  = ""abc""
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring before the first occurrence of the separator,
 *  <code>null</code> if null String input
 * @since 2.0
 */
public static String substringBefore(String str, String separator) {
    if (isEmpty(str) || separator == null) {
        return str;
    }
    if (separator.length() == 0) {
        return EMPTY;
    }
    int pos = str.indexOf(separator);
    if (pos == INDEX_NOT_FOUND) {
        return str;
    }
    return str.substring(0, pos);
}","public void test176195() throws Throwable {
    String string0 = StringUtils.substringBefore("" "", ""..."");
    assertEquals("" "", string0);
}",""
"// SubStringAfter/SubStringBefore
//-----------------------------------------------------------------------
/**
 * <p>Gets the substring before the first occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A <code>null</code> string input will return <code>null</code>.
 * An empty ("""") string input will return the empty string.
 * A <code>null</code> separator will return the input string.</p>
 *
 * <p>If nothing is found, the string input is returned.</p>
 *
 * <pre>
 * StringUtils.substringBefore(null, *)      = null
 * StringUtils.substringBefore("""", *)        = """"
 * StringUtils.substringBefore(""abc"", ""a"")   = """"
 * StringUtils.substringBefore(""abcba"", ""b"") = ""a""
 * StringUtils.substringBefore(""abc"", ""c"")   = ""ab""
 * StringUtils.substringBefore(""abc"", ""d"")   = ""abc""
 * StringUtils.substringBefore(""abc"", """")    = """"
 * StringUtils.substringBefore(""abc"", null)  = ""abc""
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring before the first occurrence of the separator,
 *  <code>null</code> if null String input
 * @since 2.0
 */
public static String substringBefore(String str, String separator) {
    if (isEmpty(str) || separator == null) {
        return str;
    }
    if (separator.length() == 0) {
        return EMPTY;
    }
    int pos = str.indexOf(separator);
    if (pos == INDEX_NOT_FOUND) {
        return str;
    }
    return str.substring(0, pos);
}","public void test177196() throws Throwable {
    String string0 = StringUtils.substringBefore(""wjava.ext.dirsu9m"", """");
    assertEquals("""", string0);
}",""
"// SubStringAfter/SubStringBefore
//-----------------------------------------------------------------------
/**
 * <p>Gets the substring before the first occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A <code>null</code> string input will return <code>null</code>.
 * An empty ("""") string input will return the empty string.
 * A <code>null</code> separator will return the input string.</p>
 *
 * <p>If nothing is found, the string input is returned.</p>
 *
 * <pre>
 * StringUtils.substringBefore(null, *)      = null
 * StringUtils.substringBefore("""", *)        = """"
 * StringUtils.substringBefore(""abc"", ""a"")   = """"
 * StringUtils.substringBefore(""abcba"", ""b"") = ""a""
 * StringUtils.substringBefore(""abc"", ""c"")   = ""ab""
 * StringUtils.substringBefore(""abc"", ""d"")   = ""abc""
 * StringUtils.substringBefore(""abc"", """")    = """"
 * StringUtils.substringBefore(""abc"", null)  = ""abc""
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring before the first occurrence of the separator,
 *  <code>null</code> if null String input
 * @since 2.0
 */
public static String substringBefore(String str, String separator) {
    if (isEmpty(str) || separator == null) {
        return str;
    }
    if (separator.length() == 0) {
        return EMPTY;
    }
    int pos = str.indexOf(separator);
    if (pos == INDEX_NOT_FOUND) {
        return str;
    }
    return str.substring(0, pos);
}","public void test178197() throws Throwable {
    String string0 = StringUtils.substringBefore(""mnxc'p108CC*~"", ""mnxc'p108CC*~"");
    assertEquals("""", string0);
}",""
"public static String substringAfter(String str, String separator) {
    if (isEmpty(str)) {
        return str;
    }
    if (separator == null) {
        return EMPTY;
    }
    int pos = str.indexOf(separator);
    if (pos == INDEX_NOT_FOUND) {
        return EMPTY;
    }
    return str.substring(pos + separator.length());
}","public void test179198() throws Throwable {
    String string0 = StringUtils.substringAfter(""T^mot*oLive of "", ""T^mot*oLive of "");
    assertEquals("""", string0);
}","/**
 * <p>Gets the substring after the first occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A <code>null</code> string input will return <code>null</code>.
 * An empty ("""") string input will return the empty string.
 * A <code>null</code> separator will return the empty string if the
 * input string is not <code>null</code>.</p>
 *
 * <p>If nothing is found, the empty string is returned.</p>
 *
 * <pre>
 * StringUtils.substringAfter(null, *)      = null
 * StringUtils.substringAfter("""", *)        = """"
 * StringUtils.substringAfter(*, null)      = """"
 * StringUtils.substringAfter(""abc"", ""a"")   = ""bc""
 * StringUtils.substringAfter(""abcba"", ""b"") = ""cba""
 * StringUtils.substringAfter(""abc"", ""c"")   = """"
 * StringUtils.substringAfter(""abc"", ""d"")   = """"
 * StringUtils.substringAfter(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring after the first occurrence of the separator,
 *  <code>null</code> if null String input
 * @since 2.0
 */"
"public static String substringAfter(String str, String separator) {
    if (isEmpty(str)) {
        return str;
    }
    if (separator == null) {
        return EMPTY;
    }
    int pos = str.indexOf(separator);
    if (pos == INDEX_NOT_FOUND) {
        return EMPTY;
    }
    return str.substring(pos + separator.length());
}","public void test180199() throws Throwable {
    String string0 = StringUtils.substringAfter("""", """");
    assertEquals("""", string0);
}","/**
 * <p>Gets the substring after the first occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A <code>null</code> string input will return <code>null</code>.
 * An empty ("""") string input will return the empty string.
 * A <code>null</code> separator will return the empty string if the
 * input string is not <code>null</code>.</p>
 *
 * <p>If nothing is found, the empty string is returned.</p>
 *
 * <pre>
 * StringUtils.substringAfter(null, *)      = null
 * StringUtils.substringAfter("""", *)        = """"
 * StringUtils.substringAfter(*, null)      = """"
 * StringUtils.substringAfter(""abc"", ""a"")   = ""bc""
 * StringUtils.substringAfter(""abcba"", ""b"") = ""cba""
 * StringUtils.substringAfter(""abc"", ""c"")   = """"
 * StringUtils.substringAfter(""abc"", ""d"")   = """"
 * StringUtils.substringAfter(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring after the first occurrence of the separator,
 *  <code>null</code> if null String input
 * @since 2.0
 */"
"public static String substringAfter(String str, String separator) {
    if (isEmpty(str)) {
        return str;
    }
    if (separator == null) {
        return EMPTY;
    }
    int pos = str.indexOf(separator);
    if (pos == INDEX_NOT_FOUND) {
        return EMPTY;
    }
    return str.substring(pos + separator.length());
}","public void test181200() throws Throwable {
    String string0 = StringUtils.substringAfter(""HP-"", (String) null);
    assertEquals("""", string0);
}","/**
 * <p>Gets the substring after the first occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A <code>null</code> string input will return <code>null</code>.
 * An empty ("""") string input will return the empty string.
 * A <code>null</code> separator will return the empty string if the
 * input string is not <code>null</code>.</p>
 *
 * <p>If nothing is found, the empty string is returned.</p>
 *
 * <pre>
 * StringUtils.substringAfter(null, *)      = null
 * StringUtils.substringAfter("""", *)        = """"
 * StringUtils.substringAfter(*, null)      = """"
 * StringUtils.substringAfter(""abc"", ""a"")   = ""bc""
 * StringUtils.substringAfter(""abcba"", ""b"") = ""cba""
 * StringUtils.substringAfter(""abc"", ""c"")   = """"
 * StringUtils.substringAfter(""abc"", ""d"")   = """"
 * StringUtils.substringAfter(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring after the first occurrence of the separator,
 *  <code>null</code> if null String input
 * @since 2.0
 */"
"public static String substringAfter(String str, String separator) {
    if (isEmpty(str)) {
        return str;
    }
    if (separator == null) {
        return EMPTY;
    }
    int pos = str.indexOf(separator);
    if (pos == INDEX_NOT_FOUND) {
        return EMPTY;
    }
    return str.substring(pos + separator.length());
}","public void test182201() throws Throwable {
    String string0 = StringUtils.substringAfter(""UpKl~["", ""Z-"");
    assertEquals("""", string0);
}","/**
 * <p>Gets the substring after the first occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A <code>null</code> string input will return <code>null</code>.
 * An empty ("""") string input will return the empty string.
 * A <code>null</code> separator will return the empty string if the
 * input string is not <code>null</code>.</p>
 *
 * <p>If nothing is found, the empty string is returned.</p>
 *
 * <pre>
 * StringUtils.substringAfter(null, *)      = null
 * StringUtils.substringAfter("""", *)        = """"
 * StringUtils.substringAfter(*, null)      = """"
 * StringUtils.substringAfter(""abc"", ""a"")   = ""bc""
 * StringUtils.substringAfter(""abcba"", ""b"") = ""cba""
 * StringUtils.substringAfter(""abc"", ""c"")   = """"
 * StringUtils.substringAfter(""abc"", ""d"")   = """"
 * StringUtils.substringAfter(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring after the first occurrence of the separator,
 *  <code>null</code> if null String input
 * @since 2.0
 */"
"public static String substringBeforeLast(String str, String separator) {
    if (isEmpty(str) || isEmpty(separator)) {
        return str;
    }
    int pos = str.lastIndexOf(separator);
    if (pos == INDEX_NOT_FOUND) {
        return str;
    }
    return str.substring(0, pos);
}","public void test183202() throws Throwable {
    String string0 = StringUtils.substringBeforeLast((String) null, (String) null);
    assertNull(string0);
}","/**
 * <p>Gets the substring before the last occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A <code>null</code> string input will return <code>null</code>.
 * An empty ("""") string input will return the empty string.
 * An empty or <code>null</code> separator will return the input string.</p>
 *
 * <p>If nothing is found, the string input is returned.</p>
 *
 * <pre>
 * StringUtils.substringBeforeLast(null, *)      = null
 * StringUtils.substringBeforeLast("""", *)        = """"
 * StringUtils.substringBeforeLast(""abcba"", ""b"") = ""abc""
 * StringUtils.substringBeforeLast(""abc"", ""c"")   = ""ab""
 * StringUtils.substringBeforeLast(""a"", ""a"")     = """"
 * StringUtils.substringBeforeLast(""a"", ""z"")     = ""a""
 * StringUtils.substringBeforeLast(""a"", null)    = ""a""
 * StringUtils.substringBeforeLast(""a"", """")      = ""a""
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring before the last occurrence of the separator,
 *  <code>null</code> if null String input
 * @since 2.0
 */"
"public static String substringBeforeLast(String str, String separator) {
    if (isEmpty(str) || isEmpty(separator)) {
        return str;
    }
    int pos = str.lastIndexOf(separator);
    if (pos == INDEX_NOT_FOUND) {
        return str;
    }
    return str.substring(0, pos);
}","public void test184203() throws Throwable {
    String string0 = StringUtils.substringBeforeLast(""3u3WfV0jzGK"", ""3u3WfV0jzGK"");
    assertEquals("""", string0);
}","/**
 * <p>Gets the substring before the last occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A <code>null</code> string input will return <code>null</code>.
 * An empty ("""") string input will return the empty string.
 * An empty or <code>null</code> separator will return the input string.</p>
 *
 * <p>If nothing is found, the string input is returned.</p>
 *
 * <pre>
 * StringUtils.substringBeforeLast(null, *)      = null
 * StringUtils.substringBeforeLast("""", *)        = """"
 * StringUtils.substringBeforeLast(""abcba"", ""b"") = ""abc""
 * StringUtils.substringBeforeLast(""abc"", ""c"")   = ""ab""
 * StringUtils.substringBeforeLast(""a"", ""a"")     = """"
 * StringUtils.substringBeforeLast(""a"", ""z"")     = ""a""
 * StringUtils.substringBeforeLast(""a"", null)    = ""a""
 * StringUtils.substringBeforeLast(""a"", """")      = ""a""
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring before the last occurrence of the separator,
 *  <code>null</code> if null String input
 * @since 2.0
 */"
"public static String substringBeforeLast(String str, String separator) {
    if (isEmpty(str) || isEmpty(separator)) {
        return str;
    }
    int pos = str.lastIndexOf(separator);
    if (pos == INDEX_NOT_FOUND) {
        return str;
    }
    return str.substring(0, pos);
}","public void test185204() throws Throwable {
    String string0 = StringUtils.substringBeforeLast(""url*irbn5co"", """");
    assertEquals(""url*irbn5co"", string0);
}","/**
 * <p>Gets the substring before the last occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A <code>null</code> string input will return <code>null</code>.
 * An empty ("""") string input will return the empty string.
 * An empty or <code>null</code> separator will return the input string.</p>
 *
 * <p>If nothing is found, the string input is returned.</p>
 *
 * <pre>
 * StringUtils.substringBeforeLast(null, *)      = null
 * StringUtils.substringBeforeLast("""", *)        = """"
 * StringUtils.substringBeforeLast(""abcba"", ""b"") = ""abc""
 * StringUtils.substringBeforeLast(""abc"", ""c"")   = ""ab""
 * StringUtils.substringBeforeLast(""a"", ""a"")     = """"
 * StringUtils.substringBeforeLast(""a"", ""z"")     = ""a""
 * StringUtils.substringBeforeLast(""a"", null)    = ""a""
 * StringUtils.substringBeforeLast(""a"", """")      = ""a""
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring before the last occurrence of the separator,
 *  <code>null</code> if null String input
 * @since 2.0
 */"
"public static String substringBeforeLast(String str, String separator) {
    if (isEmpty(str) || isEmpty(separator)) {
        return str;
    }
    int pos = str.lastIndexOf(separator);
    if (pos == INDEX_NOT_FOUND) {
        return str;
    }
    return str.substring(0, pos);
}","public void test186205() throws Throwable {
    String string0 = StringUtils.substringBeforeLast(""1IR`mR2MMLxzCaQi/oX"", ""8|>|>v4p[="");
    assertEquals(""1IR`mR2MMLxzCaQi/oX"", string0);
}","/**
 * <p>Gets the substring before the last occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A <code>null</code> string input will return <code>null</code>.
 * An empty ("""") string input will return the empty string.
 * An empty or <code>null</code> separator will return the input string.</p>
 *
 * <p>If nothing is found, the string input is returned.</p>
 *
 * <pre>
 * StringUtils.substringBeforeLast(null, *)      = null
 * StringUtils.substringBeforeLast("""", *)        = """"
 * StringUtils.substringBeforeLast(""abcba"", ""b"") = ""abc""
 * StringUtils.substringBeforeLast(""abc"", ""c"")   = ""ab""
 * StringUtils.substringBeforeLast(""a"", ""a"")     = """"
 * StringUtils.substringBeforeLast(""a"", ""z"")     = ""a""
 * StringUtils.substringBeforeLast(""a"", null)    = ""a""
 * StringUtils.substringBeforeLast(""a"", """")      = ""a""
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring before the last occurrence of the separator,
 *  <code>null</code> if null String input
 * @since 2.0
 */"
"public static String substringAfterLast(String str, String separator) {
    if (isEmpty(str)) {
        return str;
    }
    if (isEmpty(separator)) {
        return EMPTY;
    }
    int pos = str.lastIndexOf(separator);
    if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) {
        return EMPTY;
    }
    return str.substring(pos + separator.length());
}","public void test187206() throws Throwable {
    String string0 = StringUtils.substringAfterLast(""&"", """");
    assertEquals("""", string0);
}","/**
 * <p>Gets the substring after the last occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A <code>null</code> string input will return <code>null</code>.
 * An empty ("""") string input will return the empty string.
 * An empty or <code>null</code> separator will return the empty string if
 * the input string is not <code>null</code>.</p>
 *
 * <p>If nothing is found, the empty string is returned.</p>
 *
 * <pre>
 * StringUtils.substringAfterLast(null, *)      = null
 * StringUtils.substringAfterLast("""", *)        = """"
 * StringUtils.substringAfterLast(*, """")        = """"
 * StringUtils.substringAfterLast(*, null)      = """"
 * StringUtils.substringAfterLast(""abc"", ""a"")   = ""bc""
 * StringUtils.substringAfterLast(""abcba"", ""b"") = ""a""
 * StringUtils.substringAfterLast(""abc"", ""c"")   = """"
 * StringUtils.substringAfterLast(""a"", ""a"")     = """"
 * StringUtils.substringAfterLast(""a"", ""z"")     = """"
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring after the last occurrence of the separator,
 *  <code>null</code> if null String input
 * @since 2.0
 */"
"public static String substringAfterLast(String str, String separator) {
    if (isEmpty(str)) {
        return str;
    }
    if (isEmpty(separator)) {
        return EMPTY;
    }
    int pos = str.lastIndexOf(separator);
    if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) {
        return EMPTY;
    }
    return str.substring(pos + separator.length());
}","public void test188207() throws Throwable {
    String string0 = StringUtils.substringAfterLast("""", """");
    assertEquals("""", string0);
}","/**
 * <p>Gets the substring after the last occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A <code>null</code> string input will return <code>null</code>.
 * An empty ("""") string input will return the empty string.
 * An empty or <code>null</code> separator will return the empty string if
 * the input string is not <code>null</code>.</p>
 *
 * <p>If nothing is found, the empty string is returned.</p>
 *
 * <pre>
 * StringUtils.substringAfterLast(null, *)      = null
 * StringUtils.substringAfterLast("""", *)        = """"
 * StringUtils.substringAfterLast(*, """")        = """"
 * StringUtils.substringAfterLast(*, null)      = """"
 * StringUtils.substringAfterLast(""abc"", ""a"")   = ""bc""
 * StringUtils.substringAfterLast(""abcba"", ""b"") = ""a""
 * StringUtils.substringAfterLast(""abc"", ""c"")   = """"
 * StringUtils.substringAfterLast(""a"", ""a"")     = """"
 * StringUtils.substringAfterLast(""a"", ""z"")     = """"
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring after the last occurrence of the separator,
 *  <code>null</code> if null String input
 * @since 2.0
 */"
"public static String substringAfterLast(String str, String separator) {
    if (isEmpty(str)) {
        return str;
    }
    if (isEmpty(separator)) {
        return EMPTY;
    }
    int pos = str.lastIndexOf(separator);
    if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) {
        return EMPTY;
    }
    return str.substring(pos + separator.length());
}","public void test189208() throws Throwable {
    String string0 = StringUtils.substringAfterLast(""NoSuchFieldException occurred during 1.6 backcompat code"", ""NoSuchFieldException occurred during 1.6 backcompat cod"");
    assertEquals(""e"", string0);
}","/**
 * <p>Gets the substring after the last occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A <code>null</code> string input will return <code>null</code>.
 * An empty ("""") string input will return the empty string.
 * An empty or <code>null</code> separator will return the empty string if
 * the input string is not <code>null</code>.</p>
 *
 * <p>If nothing is found, the empty string is returned.</p>
 *
 * <pre>
 * StringUtils.substringAfterLast(null, *)      = null
 * StringUtils.substringAfterLast("""", *)        = """"
 * StringUtils.substringAfterLast(*, """")        = """"
 * StringUtils.substringAfterLast(*, null)      = """"
 * StringUtils.substringAfterLast(""abc"", ""a"")   = ""bc""
 * StringUtils.substringAfterLast(""abcba"", ""b"") = ""a""
 * StringUtils.substringAfterLast(""abc"", ""c"")   = """"
 * StringUtils.substringAfterLast(""a"", ""a"")     = """"
 * StringUtils.substringAfterLast(""a"", ""z"")     = """"
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring after the last occurrence of the separator,
 *  <code>null</code> if null String input
 * @since 2.0
 */"
"public static String substringAfterLast(String str, String separator) {
    if (isEmpty(str)) {
        return str;
    }
    if (isEmpty(separator)) {
        return EMPTY;
    }
    int pos = str.lastIndexOf(separator);
    if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) {
        return EMPTY;
    }
    return str.substring(pos + separator.length());
}","public void test190209() throws Throwable {
    String string0 = StringUtils.substringAfterLast(""0c)/<'Q"", ""}p]Nu8D@y4y+/([LS"");
    assertEquals("""", string0);
}","/**
 * <p>Gets the substring after the last occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A <code>null</code> string input will return <code>null</code>.
 * An empty ("""") string input will return the empty string.
 * An empty or <code>null</code> separator will return the empty string if
 * the input string is not <code>null</code>.</p>
 *
 * <p>If nothing is found, the empty string is returned.</p>
 *
 * <pre>
 * StringUtils.substringAfterLast(null, *)      = null
 * StringUtils.substringAfterLast("""", *)        = """"
 * StringUtils.substringAfterLast(*, """")        = """"
 * StringUtils.substringAfterLast(*, null)      = """"
 * StringUtils.substringAfterLast(""abc"", ""a"")   = ""bc""
 * StringUtils.substringAfterLast(""abcba"", ""b"") = ""a""
 * StringUtils.substringAfterLast(""abc"", ""c"")   = """"
 * StringUtils.substringAfterLast(""a"", ""a"")     = """"
 * StringUtils.substringAfterLast(""a"", ""z"")     = """"
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring after the last occurrence of the separator,
 *  <code>null</code> if null String input
 * @since 2.0
 */"
"public static String substringAfterLast(String str, String separator) {
    if (isEmpty(str)) {
        return str;
    }
    if (isEmpty(separator)) {
        return EMPTY;
    }
    int pos = str.lastIndexOf(separator);
    if (pos == INDEX_NOT_FOUND || pos == (str.length() - separator.length())) {
        return EMPTY;
    }
    return str.substring(pos + separator.length());
}","public void test191210() throws Throwable {
    String string0 = StringUtils.substringAfterLast(""nd replace array lengths don't"", ""nd replace array lengths don't"");
    assertEquals("""", string0);
}","/**
 * <p>Gets the substring after the last occurrence of a separator.
 * The separator is not returned.</p>
 *
 * <p>A <code>null</code> string input will return <code>null</code>.
 * An empty ("""") string input will return the empty string.
 * An empty or <code>null</code> separator will return the empty string if
 * the input string is not <code>null</code>.</p>
 *
 * <p>If nothing is found, the empty string is returned.</p>
 *
 * <pre>
 * StringUtils.substringAfterLast(null, *)      = null
 * StringUtils.substringAfterLast("""", *)        = """"
 * StringUtils.substringAfterLast(*, """")        = """"
 * StringUtils.substringAfterLast(*, null)      = """"
 * StringUtils.substringAfterLast(""abc"", ""a"")   = ""bc""
 * StringUtils.substringAfterLast(""abcba"", ""b"") = ""a""
 * StringUtils.substringAfterLast(""abc"", ""c"")   = """"
 * StringUtils.substringAfterLast(""a"", ""a"")     = """"
 * StringUtils.substringAfterLast(""a"", ""z"")     = """"
 * </pre>
 *
 * @param str  the String to get a substring from, may be null
 * @param separator  the String to search for, may be null
 * @return the substring after the last occurrence of the separator,
 *  <code>null</code> if null String input
 * @since 2.0
 */"
"// Substring between
//-----------------------------------------------------------------------
/**
 * <p>Gets the String that is nested in between two instances of the
 * same String.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> tag returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.substringBetween(null, *)            = null
 * StringUtils.substringBetween("""", """")             = """"
 * StringUtils.substringBetween("""", ""tag"")          = null
 * StringUtils.substringBetween(""tagabctag"", null)  = null
 * StringUtils.substringBetween(""tagabctag"", """")    = """"
 * StringUtils.substringBetween(""tagabctag"", ""tag"") = ""abc""
 * </pre>
 *
 * @param str  the String containing the substring, may be null
 * @param tag  the String before and after the substring, may be null
 * @return the substring, <code>null</code> if no match
 * @since 2.0
 */
public static String substringBetween(String str, String tag) {
    return substringBetween(str, tag, tag);
}","public void test192211() throws Throwable {
    String string0 = StringUtils.substringBetween((String) null, (String) null);
    assertNull(string0);
}",""
"public static String substringBetween(String str, String open, String close) {
    if (str == null || open == null || close == null) {
        return null;
    }
    int start = str.indexOf(open);
    if (start != INDEX_NOT_FOUND) {
        int end = str.indexOf(close, start + open.length());
        if (end != INDEX_NOT_FOUND) {
            return str.substring(start + open.length(), end);
        }
    }
    return null;
}","public void test193212() throws Throwable {
    String string0 = StringUtils.substringBetween(""-s<R|!"", (String) null, ""-s<R|!"");
    assertNull(string0);
}","/**
 * <p>Gets the String that is nested in between two Strings.
 * Only the first match is returned.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> open/close returns <code>null</code> (no match).
 * An empty ("""") open and close returns an empty string.</p>
 *
 * <pre>
 * StringUtils.substringBetween(""wx[b]yz"", ""["", ""]"") = ""b""
 * StringUtils.substringBetween(null, *, *)          = null
 * StringUtils.substringBetween(*, null, *)          = null
 * StringUtils.substringBetween(*, *, null)          = null
 * StringUtils.substringBetween("""", """", """")          = """"
 * StringUtils.substringBetween("""", """", ""]"")         = null
 * StringUtils.substringBetween("""", ""["", ""]"")        = null
 * StringUtils.substringBetween(""yabcz"", """", """")     = """"
 * StringUtils.substringBetween(""yabcz"", ""y"", ""z"")   = ""abc""
 * StringUtils.substringBetween(""yabczyabcz"", ""y"", ""z"")   = ""abc""
 * </pre>
 *
 * @param str  the String containing the substring, may be null
 * @param open  the String before the substring, may be null
 * @param close  the String after the substring, may be null
 * @return the substring, <code>null</code> if no match
 * @since 2.0
 */"
"public static String substringBetween(String str, String open, String close) {
    if (str == null || open == null || close == null) {
        return null;
    }
    int start = str.indexOf(open);
    if (start != INDEX_NOT_FOUND) {
        int end = str.indexOf(close, start + open.length());
        if (end != INDEX_NOT_FOUND) {
            return str.substring(start + open.length(), end);
        }
    }
    return null;
}","public void test194213() throws Throwable {
    String string0 = StringUtils.substringBetween("";"", ""The stripAccents(String) method is not supported until Java 1.6"", (String) null);
    assertNull(string0);
}","/**
 * <p>Gets the String that is nested in between two Strings.
 * Only the first match is returned.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> open/close returns <code>null</code> (no match).
 * An empty ("""") open and close returns an empty string.</p>
 *
 * <pre>
 * StringUtils.substringBetween(""wx[b]yz"", ""["", ""]"") = ""b""
 * StringUtils.substringBetween(null, *, *)          = null
 * StringUtils.substringBetween(*, null, *)          = null
 * StringUtils.substringBetween(*, *, null)          = null
 * StringUtils.substringBetween("""", """", """")          = """"
 * StringUtils.substringBetween("""", """", ""]"")         = null
 * StringUtils.substringBetween("""", ""["", ""]"")        = null
 * StringUtils.substringBetween(""yabcz"", """", """")     = """"
 * StringUtils.substringBetween(""yabcz"", ""y"", ""z"")   = ""abc""
 * StringUtils.substringBetween(""yabczyabcz"", ""y"", ""z"")   = ""abc""
 * </pre>
 *
 * @param str  the String containing the substring, may be null
 * @param open  the String before the substring, may be null
 * @param close  the String after the substring, may be null
 * @return the substring, <code>null</code> if no match
 * @since 2.0
 */"
"public static String substringBetween(String str, String open, String close) {
    if (str == null || open == null || close == null) {
        return null;
    }
    int start = str.indexOf(open);
    if (start != INDEX_NOT_FOUND) {
        int end = str.indexOf(close, start + open.length());
        if (end != INDEX_NOT_FOUND) {
            return str.substring(start + open.length(), end);
        }
    }
    return null;
}","public void test195214() throws Throwable {
    String string0 = StringUtils.substringBetween("""", ""Cannot pad a negative amount: "", """");
    assertNull(string0);
}","/**
 * <p>Gets the String that is nested in between two Strings.
 * Only the first match is returned.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> open/close returns <code>null</code> (no match).
 * An empty ("""") open and close returns an empty string.</p>
 *
 * <pre>
 * StringUtils.substringBetween(""wx[b]yz"", ""["", ""]"") = ""b""
 * StringUtils.substringBetween(null, *, *)          = null
 * StringUtils.substringBetween(*, null, *)          = null
 * StringUtils.substringBetween(*, *, null)          = null
 * StringUtils.substringBetween("""", """", """")          = """"
 * StringUtils.substringBetween("""", """", ""]"")         = null
 * StringUtils.substringBetween("""", ""["", ""]"")        = null
 * StringUtils.substringBetween(""yabcz"", """", """")     = """"
 * StringUtils.substringBetween(""yabcz"", ""y"", ""z"")   = ""abc""
 * StringUtils.substringBetween(""yabczyabcz"", ""y"", ""z"")   = ""abc""
 * </pre>
 *
 * @param str  the String containing the substring, may be null
 * @param open  the String before the substring, may be null
 * @param close  the String after the substring, may be null
 * @return the substring, <code>null</code> if no match
 * @since 2.0
 */"
"// Substring between
//-----------------------------------------------------------------------
/**
 * <p>Gets the String that is nested in between two instances of the
 * same String.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> tag returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.substringBetween(null, *)            = null
 * StringUtils.substringBetween("""", """")             = """"
 * StringUtils.substringBetween("""", ""tag"")          = null
 * StringUtils.substringBetween(""tagabctag"", null)  = null
 * StringUtils.substringBetween(""tagabctag"", """")    = """"
 * StringUtils.substringBetween(""tagabctag"", ""tag"") = ""abc""
 * </pre>
 *
 * @param str  the String containing the substring, may be null
 * @param tag  the String before and after the substring, may be null
 * @return the substring, <code>null</code> if no match
 * @since 2.0
 */
public static String substringBetween(String str, String tag) {
    return substringBetween(str, tag, tag);
}","public void test196215() throws Throwable {
    String string0 = StringUtils.substringBetween("""", """");
    assertEquals("""", string0);
}",""
"public static String[] substringsBetween(String str, String open, String close) {
    if (str == null || isEmpty(open) || isEmpty(close)) {
        return null;
    }
    int strLen = str.length();
    if (strLen == 0) {
        return ArrayUtils.EMPTY_STRING_ARRAY;
    }
    int closeLen = close.length();
    int openLen = open.length();
    List<String> list = new ArrayList<String>();
    int pos = 0;
    while (pos < (strLen - closeLen)) {
        int start = str.indexOf(open, pos);
        if (start < 0) {
            break;
        }
        start += openLen;
        int end = str.indexOf(close, start);
        if (end < 0) {
            break;
        }
        list.add(str.substring(start, end));
        pos = end + closeLen;
    }
    if (list.isEmpty()) {
        return null;
    }
    return list.toArray(new String[list.size()]);
}","public void test197216() throws Throwable {
    String[] stringArray0 = StringUtils.substringsBetween((String) null, (String) null, (String) null);
    assertNull(stringArray0);
}","/**
 * <p>Searches a String for substrings delimited by a start and end tag,
 * returning all matching substrings in an array.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> open/close returns <code>null</code> (no match).
 * An empty ("""") open/close returns <code>null</code> (no match).</p>
 *
 * <pre>
 * StringUtils.substringsBetween(""[a][b][c]"", ""["", ""]"") = [""a"",""b"",""c""]
 * StringUtils.substringsBetween(null, *, *)            = null
 * StringUtils.substringsBetween(*, null, *)            = null
 * StringUtils.substringsBetween(*, *, null)            = null
 * StringUtils.substringsBetween("""", ""["", ""]"")          = []
 * </pre>
 *
 * @param str  the String containing the substrings, null returns null, empty returns empty
 * @param open  the String identifying the start of the substring, empty returns null
 * @param close  the String identifying the end of the substring, empty returns null
 * @return a String Array of substrings, or <code>null</code> if no match
 * @since 2.3
 */"
"public static String[] substringsBetween(String str, String open, String close) {
    if (str == null || isEmpty(open) || isEmpty(close)) {
        return null;
    }
    int strLen = str.length();
    if (strLen == 0) {
        return ArrayUtils.EMPTY_STRING_ARRAY;
    }
    int closeLen = close.length();
    int openLen = open.length();
    List<String> list = new ArrayList<String>();
    int pos = 0;
    while (pos < (strLen - closeLen)) {
        int start = str.indexOf(open, pos);
        if (start < 0) {
            break;
        }
        start += openLen;
        int end = str.indexOf(close, start);
        if (end < 0) {
            break;
        }
        list.add(str.substring(start, end));
        pos = end + closeLen;
    }
    if (list.isEmpty()) {
        return null;
    }
    return list.toArray(new String[list.size()]);
}","public void test198217() throws Throwable {
    String[] stringArray0 = StringUtils.substringsBetween("""", """", """");
    assertNull(stringArray0);
}","/**
 * <p>Searches a String for substrings delimited by a start and end tag,
 * returning all matching substrings in an array.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> open/close returns <code>null</code> (no match).
 * An empty ("""") open/close returns <code>null</code> (no match).</p>
 *
 * <pre>
 * StringUtils.substringsBetween(""[a][b][c]"", ""["", ""]"") = [""a"",""b"",""c""]
 * StringUtils.substringsBetween(null, *, *)            = null
 * StringUtils.substringsBetween(*, null, *)            = null
 * StringUtils.substringsBetween(*, *, null)            = null
 * StringUtils.substringsBetween("""", ""["", ""]"")          = []
 * </pre>
 *
 * @param str  the String containing the substrings, null returns null, empty returns empty
 * @param open  the String identifying the start of the substring, empty returns null
 * @param close  the String identifying the end of the substring, empty returns null
 * @return a String Array of substrings, or <code>null</code> if no match
 * @since 2.3
 */"
"public static String[] substringsBetween(String str, String open, String close) {
    if (str == null || isEmpty(open) || isEmpty(close)) {
        return null;
    }
    int strLen = str.length();
    if (strLen == 0) {
        return ArrayUtils.EMPTY_STRING_ARRAY;
    }
    int closeLen = close.length();
    int openLen = open.length();
    List<String> list = new ArrayList<String>();
    int pos = 0;
    while (pos < (strLen - closeLen)) {
        int start = str.indexOf(open, pos);
        if (start < 0) {
            break;
        }
        start += openLen;
        int end = str.indexOf(close, start);
        if (end < 0) {
            break;
        }
        list.add(str.substring(start, end));
        pos = end + closeLen;
    }
    if (list.isEmpty()) {
        return null;
    }
    return list.toArray(new String[list.size()]);
}","public void test199218() throws Throwable {
    String[] stringArray0 = StringUtils.substringsBetween(""AUTOSELECT_FILTERINGgEXTENDED_FILTERINGgIGNORE_EXTENDED_RANGESgMAP_EXTENDED_RANGESgREJECT_EXTENDED_RANGES"", ""g"", ""g"");
    assertEquals(2, stringArray0.length);
}","/**
 * <p>Searches a String for substrings delimited by a start and end tag,
 * returning all matching substrings in an array.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> open/close returns <code>null</code> (no match).
 * An empty ("""") open/close returns <code>null</code> (no match).</p>
 *
 * <pre>
 * StringUtils.substringsBetween(""[a][b][c]"", ""["", ""]"") = [""a"",""b"",""c""]
 * StringUtils.substringsBetween(null, *, *)            = null
 * StringUtils.substringsBetween(*, null, *)            = null
 * StringUtils.substringsBetween(*, *, null)            = null
 * StringUtils.substringsBetween("""", ""["", ""]"")          = []
 * </pre>
 *
 * @param str  the String containing the substrings, null returns null, empty returns empty
 * @param open  the String identifying the start of the substring, empty returns null
 * @param close  the String identifying the end of the substring, empty returns null
 * @return a String Array of substrings, or <code>null</code> if no match
 * @since 2.3
 */"
"public static String[] substringsBetween(String str, String open, String close) {
    if (str == null || isEmpty(open) || isEmpty(close)) {
        return null;
    }
    int strLen = str.length();
    if (strLen == 0) {
        return ArrayUtils.EMPTY_STRING_ARRAY;
    }
    int closeLen = close.length();
    int openLen = open.length();
    List<String> list = new ArrayList<String>();
    int pos = 0;
    while (pos < (strLen - closeLen)) {
        int start = str.indexOf(open, pos);
        if (start < 0) {
            break;
        }
        start += openLen;
        int end = str.indexOf(close, start);
        if (end < 0) {
            break;
        }
        list.add(str.substring(start, end));
        pos = end + closeLen;
    }
    if (list.isEmpty()) {
        return null;
    }
    return list.toArray(new String[list.size()]);
}","public void test200220() throws Throwable {
    String[] stringArray0 = StringUtils.substringsBetween(""WAe"", ""WAe"", """");
    assertNull(stringArray0);
}","/**
 * <p>Searches a String for substrings delimited by a start and end tag,
 * returning all matching substrings in an array.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> open/close returns <code>null</code> (no match).
 * An empty ("""") open/close returns <code>null</code> (no match).</p>
 *
 * <pre>
 * StringUtils.substringsBetween(""[a][b][c]"", ""["", ""]"") = [""a"",""b"",""c""]
 * StringUtils.substringsBetween(null, *, *)            = null
 * StringUtils.substringsBetween(*, null, *)            = null
 * StringUtils.substringsBetween(*, *, null)            = null
 * StringUtils.substringsBetween("""", ""["", ""]"")          = []
 * </pre>
 *
 * @param str  the String containing the substrings, null returns null, empty returns empty
 * @param open  the String identifying the start of the substring, empty returns null
 * @param close  the String identifying the end of the substring, empty returns null
 * @return a String Array of substrings, or <code>null</code> if no match
 * @since 2.3
 */"
"public static String[] substringsBetween(String str, String open, String close) {
    if (str == null || isEmpty(open) || isEmpty(close)) {
        return null;
    }
    int strLen = str.length();
    if (strLen == 0) {
        return ArrayUtils.EMPTY_STRING_ARRAY;
    }
    int closeLen = close.length();
    int openLen = open.length();
    List<String> list = new ArrayList<String>();
    int pos = 0;
    while (pos < (strLen - closeLen)) {
        int start = str.indexOf(open, pos);
        if (start < 0) {
            break;
        }
        start += openLen;
        int end = str.indexOf(close, start);
        if (end < 0) {
            break;
        }
        list.add(str.substring(start, end));
        pos = end + closeLen;
    }
    if (list.isEmpty()) {
        return null;
    }
    return list.toArray(new String[list.size()]);
}","public void test201221() throws Throwable {
    String[] stringArray0 = StringUtils.substringsBetween("""", ""0"", ""0"");
    assertEquals(0, stringArray0.length);
}","/**
 * <p>Searches a String for substrings delimited by a start and end tag,
 * returning all matching substrings in an array.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> open/close returns <code>null</code> (no match).
 * An empty ("""") open/close returns <code>null</code> (no match).</p>
 *
 * <pre>
 * StringUtils.substringsBetween(""[a][b][c]"", ""["", ""]"") = [""a"",""b"",""c""]
 * StringUtils.substringsBetween(null, *, *)            = null
 * StringUtils.substringsBetween(*, null, *)            = null
 * StringUtils.substringsBetween(*, *, null)            = null
 * StringUtils.substringsBetween("""", ""["", ""]"")          = []
 * </pre>
 *
 * @param str  the String containing the substrings, null returns null, empty returns empty
 * @param open  the String identifying the start of the substring, empty returns null
 * @param close  the String identifying the end of the substring, empty returns null
 * @return a String Array of substrings, or <code>null</code> if no match
 * @since 2.3
 */"
"public static String[] substringsBetween(String str, String open, String close) {
    if (str == null || isEmpty(open) || isEmpty(close)) {
        return null;
    }
    int strLen = str.length();
    if (strLen == 0) {
        return ArrayUtils.EMPTY_STRING_ARRAY;
    }
    int closeLen = close.length();
    int openLen = open.length();
    List<String> list = new ArrayList<String>();
    int pos = 0;
    while (pos < (strLen - closeLen)) {
        int start = str.indexOf(open, pos);
        if (start < 0) {
            break;
        }
        start += openLen;
        int end = str.indexOf(close, start);
        if (end < 0) {
            break;
        }
        list.add(str.substring(start, end));
        pos = end + closeLen;
    }
    if (list.isEmpty()) {
        return null;
    }
    return list.toArray(new String[list.size()]);
}","public void test202222() throws Throwable {
    String[] stringArray0 = StringUtils.substringsBetween(""Irixx9qIrixx9qIrixx9qIrixx9qIrixx9qIrixx9qIrixx9qIrixx9qIrixx9qIrixx9qIrixx9qIrixx9qx9q"", ""Irixx9qIrixx9qIrixx9qIrixx9qIrixx9qIrixx9qIrixx9qIrixx9qIrixx9qIrixx9qIrixx9qIrixx9qx9q"", ""Irixx9qIrixx9qIrixx9qIrixx9qIrixx9qIrixx9qIrixx9qIrixx9qIrixx9qIrixx9qIrixx9qIrixx9qx9q"");
    assertNull(stringArray0);
}","/**
 * <p>Searches a String for substrings delimited by a start and end tag,
 * returning all matching substrings in an array.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> open/close returns <code>null</code> (no match).
 * An empty ("""") open/close returns <code>null</code> (no match).</p>
 *
 * <pre>
 * StringUtils.substringsBetween(""[a][b][c]"", ""["", ""]"") = [""a"",""b"",""c""]
 * StringUtils.substringsBetween(null, *, *)            = null
 * StringUtils.substringsBetween(*, null, *)            = null
 * StringUtils.substringsBetween(*, *, null)            = null
 * StringUtils.substringsBetween("""", ""["", ""]"")          = []
 * </pre>
 *
 * @param str  the String containing the substrings, null returns null, empty returns empty
 * @param open  the String identifying the start of the substring, empty returns null
 * @param close  the String identifying the end of the substring, empty returns null
 * @return a String Array of substrings, or <code>null</code> if no match
 * @since 2.3
 */"
"public static String[] substringsBetween(String str, String open, String close) {
    if (str == null || isEmpty(open) || isEmpty(close)) {
        return null;
    }
    int strLen = str.length();
    if (strLen == 0) {
        return ArrayUtils.EMPTY_STRING_ARRAY;
    }
    int closeLen = close.length();
    int openLen = open.length();
    List<String> list = new ArrayList<String>();
    int pos = 0;
    while (pos < (strLen - closeLen)) {
        int start = str.indexOf(open, pos);
        if (start < 0) {
            break;
        }
        start += openLen;
        int end = str.indexOf(close, start);
        if (end < 0) {
            break;
        }
        list.add(str.substring(start, end));
        pos = end + closeLen;
    }
    if (list.isEmpty()) {
        return null;
    }
    return list.toArray(new String[list.size()]);
}","public void test203223() throws Throwable {
    String[] stringArray0 = StringUtils.substringsBetween(""E{J5OfGT_j=:?e!"", ""E{J5OfGT_j=:?e!"", ""0"");
    assertNull(stringArray0);
}","/**
 * <p>Searches a String for substrings delimited by a start and end tag,
 * returning all matching substrings in an array.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> open/close returns <code>null</code> (no match).
 * An empty ("""") open/close returns <code>null</code> (no match).</p>
 *
 * <pre>
 * StringUtils.substringsBetween(""[a][b][c]"", ""["", ""]"") = [""a"",""b"",""c""]
 * StringUtils.substringsBetween(null, *, *)            = null
 * StringUtils.substringsBetween(*, null, *)            = null
 * StringUtils.substringsBetween(*, *, null)            = null
 * StringUtils.substringsBetween("""", ""["", ""]"")          = []
 * </pre>
 *
 * @param str  the String containing the substrings, null returns null, empty returns empty
 * @param open  the String identifying the start of the substring, empty returns null
 * @param close  the String identifying the end of the substring, empty returns null
 * @return a String Array of substrings, or <code>null</code> if no match
 * @since 2.3
 */"
"public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) {
    return splitByWholeSeparatorWorker(str, separator, -1, true);
}","public void test204224() throws Throwable {
    String[] stringArray0 = StringUtils.splitByWholeSeparatorPreserveAllTokens((String) null, (String) null);
    assertNull(stringArray0);
}","/**
 * <p>Splits the provided text into an array, separator string specified. </p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as separators for empty tokens.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> separator splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *)               = null
 * StringUtils.splitByWholeSeparatorPreserveAllTokens("""", *)                 = []
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(""ab de fg"", null)      = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(""ab   de fg"", null)    = [""ab"", """", """", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(""ab:cd:ef"", "":"")       = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(""ab-!-cd-!-ef"", ""-!-"") = [""ab"", ""cd"", ""ef""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @param separator  String containing the String to be used as a delimiter,
 *  <code>null</code> splits on whitespace
 * @return an array of parsed Strings, <code>null</code> if null String was input
 * @since 2.4
 */"
"public static String[] splitByWholeSeparator(String str, String separator) {
    return splitByWholeSeparatorWorker(str, separator, -1, false);
}","public void test205225() throws Throwable {
    String[] stringArray0 = StringUtils.splitByWholeSeparator("""", """");
    assertEquals(0, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array, separator string specified.</p>
 *
 * <p>The separator(s) will not be included in the returned String array.
 * Adjacent separators are treated as one separator.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> separator splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.splitByWholeSeparator(null, *)               = null
 * StringUtils.splitByWholeSeparator("""", *)                 = []
 * StringUtils.splitByWholeSeparator(""ab de fg"", null)      = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparator(""ab   de fg"", null)    = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparator(""ab:cd:ef"", "":"")       = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitByWholeSeparator(""ab-!-cd-!-ef"", ""-!-"") = [""ab"", ""cd"", ""ef""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @param separator  String containing the String to be used as a delimiter,
 *  <code>null</code> splits on whitespace
 * @return an array of parsed Strings, <code>null</code> if null String was input
 */"
"public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) {
    return splitByWholeSeparatorWorker(str, separator, -1, true);
}","public void test206226() throws Throwable {
    String[] stringArray0 = StringUtils.splitByWholeSeparatorPreserveAllTokens(""searchcanno pad a negative amount: 't match: "", (String) null);
    assertNotNull(stringArray0);
}","/**
 * <p>Splits the provided text into an array, separator string specified. </p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as separators for empty tokens.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> separator splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *)               = null
 * StringUtils.splitByWholeSeparatorPreserveAllTokens("""", *)                 = []
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(""ab de fg"", null)      = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(""ab   de fg"", null)    = [""ab"", """", """", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(""ab:cd:ef"", "":"")       = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(""ab-!-cd-!-ef"", ""-!-"") = [""ab"", ""cd"", ""ef""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @param separator  String containing the String to be used as a delimiter,
 *  <code>null</code> splits on whitespace
 * @return an array of parsed Strings, <code>null</code> if null String was input
 * @since 2.4
 */"
"public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) {
    return splitByWholeSeparatorWorker(str, separator, -1, true);
}","public void test207228() throws Throwable {
    String[] stringArray0 = StringUtils.splitByWholeSeparatorPreserveAllTokens(""illegalaccessexception occurred during ]9;w2a8b\""mv}!t code"", ""9"");
    assertEquals(2, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array, separator string specified. </p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as separators for empty tokens.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> separator splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *)               = null
 * StringUtils.splitByWholeSeparatorPreserveAllTokens("""", *)                 = []
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(""ab de fg"", null)      = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(""ab   de fg"", null)    = [""ab"", """", """", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(""ab:cd:ef"", "":"")       = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitByWholeSeparatorPreserveAllTokens(""ab-!-cd-!-ef"", ""-!-"") = [""ab"", ""cd"", ""ef""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @param separator  String containing the String to be used as a delimiter,
 *  <code>null</code> splits on whitespace
 * @return an array of parsed Strings, <code>null</code> if null String was input
 * @since 2.4
 */"
"public static String[] splitByWholeSeparator(String str, String separator, int max) {
    return splitByWholeSeparatorWorker(str, separator, max, false);
}","public void test208229() throws Throwable {
    String[] stringArray0 = StringUtils.splitByWholeSeparator(""Cannot pad a negative amount: "", "" "", 1);
    assertEquals(1, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array, separator string specified.
 * Returns a maximum of <code>max</code> substrings.</p>
 *
 * <p>The separator(s) will not be included in the returned String array.
 * Adjacent separators are treated as one separator.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> separator splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.splitByWholeSeparator(null, *, *)               = null
 * StringUtils.splitByWholeSeparator("""", *, *)                 = []
 * StringUtils.splitByWholeSeparator(""ab de fg"", null, 0)      = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparator(""ab   de fg"", null, 0)    = [""ab"", ""de"", ""fg""]
 * StringUtils.splitByWholeSeparator(""ab:cd:ef"", "":"", 2)       = [""ab"", ""cd:ef""]
 * StringUtils.splitByWholeSeparator(""ab-!-cd-!-ef"", ""-!-"", 5) = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitByWholeSeparator(""ab-!-cd-!-ef"", ""-!-"", 2) = [""ab"", ""cd-!-ef""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @param separator  String containing the String to be used as a delimiter,
 *  <code>null</code> splits on whitespace
 * @param max  the maximum number of elements to include in the returned
 *  array. A zero or negative value implies no limit.
 * @return an array of parsed Strings, <code>null</code> if null String was input
 */"
"public static String[] split(String str, char separatorChar) {
    return splitWorker(str, separatorChar, false);
}","public void test209230() throws Throwable {
    String[] stringArray0 = StringUtils.split((String) null, '@');
    assertNull(stringArray0);
}","/**
 * <p>Splits the provided text into an array, separator specified.
 * This is an alternative to using StringTokenizer.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as one separator.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.split(null, *)         = null
 * StringUtils.split("""", *)           = []
 * StringUtils.split(""a.b.c"", '.')    = [""a"", ""b"", ""c""]
 * StringUtils.split(""a..b.c"", '.')   = [""a"", ""b"", ""c""]
 * StringUtils.split(""a:b:c"", '.')    = [""a:b:c""]
 * StringUtils.split(""a b c"", ' ')    = [""a"", ""b"", ""c""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @param separatorChar  the character used as the delimiter
 * @return an array of parsed Strings, <code>null</code> if null String input
 * @since 2.0
 */"
"public static String reverseDelimited(String str, char separatorChar) {
    if (str == null) {
        return null;
    }
    // could implement manually, but simple way is to reuse other,
    // probably slower, methods.
    String[] strs = split(str, separatorChar);
    ArrayUtils.reverse(strs);
    return join(strs, separatorChar);
}","public void test210231() throws Throwable {
    String string0 = StringUtils.reverseDelimited("""", '|');
    assertEquals("""", string0);
}","/**
 * <p>Reverses a String that is delimited by a specific character.</p>
 *
 * <p>The Strings between the delimiters are not reversed.
 * Thus java.lang.String becomes String.lang.java (if the delimiter
 * is <code>'.'</code>).</p>
 *
 * <pre>
 * StringUtils.reverseDelimited(null, *)      = null
 * StringUtils.reverseDelimited("""", *)        = """"
 * StringUtils.reverseDelimited(""a.b.c"", 'x') = ""a.b.c""
 * StringUtils.reverseDelimited(""a.b.c"", ""."") = ""c.b.a""
 * </pre>
 *
 * @param str  the String to reverse, may be null
 * @param separatorChar  the separator character to use
 * @return the reversed String, <code>null</code> if null String input
 * @since 2.0
 */"
"public static String[] splitPreserveAllTokens(String str, char separatorChar) {
    return splitWorker(str, separatorChar, true);
}","public void test211232() throws Throwable {
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""I"", 'I');
    assertEquals(2, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array, separator specified,
 * preserving all tokens, including empty tokens created by adjacent
 * separators. This is an alternative to using StringTokenizer.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as separators for empty tokens.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.splitPreserveAllTokens(null, *)         = null
 * StringUtils.splitPreserveAllTokens("""", *)           = []
 * StringUtils.splitPreserveAllTokens(""a.b.c"", '.')    = [""a"", ""b"", ""c""]
 * StringUtils.splitPreserveAllTokens(""a..b.c"", '.')   = [""a"", """", ""b"", ""c""]
 * StringUtils.splitPreserveAllTokens(""a:b:c"", '.')    = [""a:b:c""]
 * StringUtils.splitPreserveAllTokens(""a\tb\nc"", null) = [""a"", ""b"", ""c""]
 * StringUtils.splitPreserveAllTokens(""a b c"", ' ')    = [""a"", ""b"", ""c""]
 * StringUtils.splitPreserveAllTokens(""a b c "", ' ')   = [""a"", ""b"", ""c"", """"]
 * StringUtils.splitPreserveAllTokens(""a b c  "", ' ')   = [""a"", ""b"", ""c"", """", """"]
 * StringUtils.splitPreserveAllTokens("" a b c"", ' ')   = ["""", a"", ""b"", ""c""]
 * StringUtils.splitPreserveAllTokens(""  a b c"", ' ')  = ["""", """", a"", ""b"", ""c""]
 * StringUtils.splitPreserveAllTokens("" a b c "", ' ')  = ["""", a"", ""b"", ""c"", """"]
 * </pre>
 *
 * @param str  the String to parse, may be <code>null</code>
 * @param separatorChar  the character used as the delimiter,
 *  <code>null</code> splits on whitespace
 * @return an array of parsed Strings, <code>null</code> if null String input
 * @since 2.1
 */"
"public static String[] split(String str, char separatorChar) {
    return splitWorker(str, separatorChar, false);
}","public void test212233() throws Throwable {
    String[] stringArray0 = StringUtils.split(""illegalaccessexception occurred during ]9;w2a8b\""mv}!t code"", 's');
    assertEquals(2, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array, separator specified.
 * This is an alternative to using StringTokenizer.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as one separator.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.split(null, *)         = null
 * StringUtils.split("""", *)           = []
 * StringUtils.split(""a.b.c"", '.')    = [""a"", ""b"", ""c""]
 * StringUtils.split(""a..b.c"", '.')   = [""a"", ""b"", ""c""]
 * StringUtils.split(""a:b:c"", '.')    = [""a:b:c""]
 * StringUtils.split(""a b c"", ' ')    = [""a"", ""b"", ""c""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @param separatorChar  the character used as the delimiter
 * @return an array of parsed Strings, <code>null</code> if null String input
 * @since 2.0
 */"
"public static String[] split(String str, char separatorChar) {
    return splitWorker(str, separatorChar, false);
}","public void test213234() throws Throwable {
    String[] stringArray0 = StringUtils.split(""illegalaccessexception occurred during ]9;w2a8b\""mv}!t code"", 'e');
    assertEquals(6, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array, separator specified.
 * This is an alternative to using StringTokenizer.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as one separator.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.split(null, *)         = null
 * StringUtils.split("""", *)           = []
 * StringUtils.split(""a.b.c"", '.')    = [""a"", ""b"", ""c""]
 * StringUtils.split(""a..b.c"", '.')   = [""a"", ""b"", ""c""]
 * StringUtils.split(""a:b:c"", '.')    = [""a:b:c""]
 * StringUtils.split(""a b c"", ' ')    = [""a"", ""b"", ""c""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @param separatorChar  the character used as the delimiter
 * @return an array of parsed Strings, <code>null</code> if null String input
 * @since 2.0
 */"
"public static String[] splitPreserveAllTokens(String str, String separatorChars) {
    return splitWorker(str, separatorChars, -1, true);
}","public void test214235() throws Throwable {
    String[] stringArray0 = StringUtils.splitPreserveAllTokens("""", """");
    assertEquals(0, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array, separators specified,
 * preserving all tokens, including empty tokens created by adjacent
 * separators. This is an alternative to using StringTokenizer.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as separators for empty tokens.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> separatorChars splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.splitPreserveAllTokens(null, *)           = null
 * StringUtils.splitPreserveAllTokens("""", *)             = []
 * StringUtils.splitPreserveAllTokens(""abc def"", null)   = [""abc"", ""def""]
 * StringUtils.splitPreserveAllTokens(""abc def"", "" "")    = [""abc"", ""def""]
 * StringUtils.splitPreserveAllTokens(""abc  def"", "" "")   = [""abc"", """", def""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef"", "":"")   = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef:"", "":"")  = [""ab"", ""cd"", ""ef"", """"]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef::"", "":"") = [""ab"", ""cd"", ""ef"", """", """"]
 * StringUtils.splitPreserveAllTokens(""ab::cd:ef"", "":"")  = [""ab"", """", cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens("":cd:ef"", "":"")     = ["""", cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""::cd:ef"", "":"")    = ["""", """", cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens("":cd:ef:"", "":"")    = ["""", cd"", ""ef"", """"]
 * </pre>
 *
 * @param str  the String to parse, may be <code>null</code>
 * @param separatorChars  the characters used as the delimiters,
 *  <code>null</code> splits on whitespace
 * @return an array of parsed Strings, <code>null</code> if null String input
 * @since 2.1
 */"
"public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {
    // timeToLive should be 0 if not used or nothing to replace, else it's
    // the length of the replace array
    int timeToLive = searchList == null ? 0 : searchList.length;
    return replaceEach(text, searchList, replacementList, true, timeToLive);
}","public void test215236() throws Throwable {
    String[] stringArray0 = StringUtils.splitPreserveAllTokens("" backcompat"");
    String string0 = StringUtils.replaceEachRepeatedly("" backcompat"", stringArray0, (String[]) null);
    assertEquals("" backcompat"", string0);
}","/**
 * <p>
 * Replaces all occurrences of Strings within another String.
 * </p>
 *
 * <p>
 * A <code>null</code> reference passed to this method is a no-op, or if
 * any ""search string"" or ""string to replace"" is null, that replace will be
 * ignored. This will not repeat. For repeating replaces, call the
 * overloaded method.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *, *) = null
 *  StringUtils.replaceEach("""", *, *, *) = """"
 *  StringUtils.replaceEach(""aba"", null, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[0], null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", null, new String[0], *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""}, *) = ""b""
 *  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""}, *) = ""aba""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""}, *) = ""wcte""
 *  (example of how it repeats)
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, false) = ""dcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, true) = ""tcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, true) = IllegalArgumentException
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, false) = ""dcabe""
 * </pre>
 *
 * @param text
 *            text to search and replace in, no-op if null
 * @param searchList
 *            the Strings to search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @return the text with any replacements processed, <code>null</code> if
 *         null String input
 * @throws IllegalArgumentException
 *             if the search is repeating and there is an endless loop due
 *             to outputs of one being inputs to another
 * @throws IndexOutOfBoundsException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */"
"public static String[] splitPreserveAllTokens(String str, String separatorChars) {
    return splitWorker(str, separatorChars, -1, true);
}","public void test216238() throws Throwable {
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""c7xo]P:]5h)~(K\""gGW"", ""g"");
    assertEquals(2, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array, separators specified,
 * preserving all tokens, including empty tokens created by adjacent
 * separators. This is an alternative to using StringTokenizer.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as separators for empty tokens.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> separatorChars splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.splitPreserveAllTokens(null, *)           = null
 * StringUtils.splitPreserveAllTokens("""", *)             = []
 * StringUtils.splitPreserveAllTokens(""abc def"", null)   = [""abc"", ""def""]
 * StringUtils.splitPreserveAllTokens(""abc def"", "" "")    = [""abc"", ""def""]
 * StringUtils.splitPreserveAllTokens(""abc  def"", "" "")   = [""abc"", """", def""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef"", "":"")   = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef:"", "":"")  = [""ab"", ""cd"", ""ef"", """"]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef::"", "":"") = [""ab"", ""cd"", ""ef"", """", """"]
 * StringUtils.splitPreserveAllTokens(""ab::cd:ef"", "":"")  = [""ab"", """", cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens("":cd:ef"", "":"")     = ["""", cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""::cd:ef"", "":"")    = ["""", """", cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens("":cd:ef:"", "":"")    = ["""", cd"", ""ef"", """"]
 * </pre>
 *
 * @param str  the String to parse, may be <code>null</code>
 * @param separatorChars  the characters used as the delimiters,
 *  <code>null</code> splits on whitespace
 * @return an array of parsed Strings, <code>null</code> if null String input
 * @since 2.1
 */"
"public static String[] splitPreserveAllTokens(String str, String separatorChars) {
    return splitWorker(str, separatorChars, -1, true);
}","public void test217239() throws Throwable {
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""0"", ""0"");
    assertEquals(2, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array, separators specified,
 * preserving all tokens, including empty tokens created by adjacent
 * separators. This is an alternative to using StringTokenizer.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as separators for empty tokens.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> separatorChars splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.splitPreserveAllTokens(null, *)           = null
 * StringUtils.splitPreserveAllTokens("""", *)             = []
 * StringUtils.splitPreserveAllTokens(""abc def"", null)   = [""abc"", ""def""]
 * StringUtils.splitPreserveAllTokens(""abc def"", "" "")    = [""abc"", ""def""]
 * StringUtils.splitPreserveAllTokens(""abc  def"", "" "")   = [""abc"", """", def""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef"", "":"")   = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef:"", "":"")  = [""ab"", ""cd"", ""ef"", """"]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef::"", "":"") = [""ab"", ""cd"", ""ef"", """", """"]
 * StringUtils.splitPreserveAllTokens(""ab::cd:ef"", "":"")  = [""ab"", """", cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens("":cd:ef"", "":"")     = ["""", cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""::cd:ef"", "":"")    = ["""", """", cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens("":cd:ef:"", "":"")    = ["""", cd"", ""ef"", """"]
 * </pre>
 *
 * @param str  the String to parse, may be <code>null</code>
 * @param separatorChars  the characters used as the delimiters,
 *  <code>null</code> splits on whitespace
 * @return an array of parsed Strings, <code>null</code> if null String input
 * @since 2.1
 */"
"public static String[] splitPreserveAllTokens(String str, String separatorChars) {
    return splitWorker(str, separatorChars, -1, true);
}","public void test218240() throws Throwable {
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""wWmwZ\""<jC'Q[_VU9M"", ""f[gsIx'+]-Tt$`~1`"");
    assertEquals(3, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array, separators specified,
 * preserving all tokens, including empty tokens created by adjacent
 * separators. This is an alternative to using StringTokenizer.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as separators for empty tokens.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> separatorChars splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.splitPreserveAllTokens(null, *)           = null
 * StringUtils.splitPreserveAllTokens("""", *)             = []
 * StringUtils.splitPreserveAllTokens(""abc def"", null)   = [""abc"", ""def""]
 * StringUtils.splitPreserveAllTokens(""abc def"", "" "")    = [""abc"", ""def""]
 * StringUtils.splitPreserveAllTokens(""abc  def"", "" "")   = [""abc"", """", def""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef"", "":"")   = [""ab"", ""cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef:"", "":"")  = [""ab"", ""cd"", ""ef"", """"]
 * StringUtils.splitPreserveAllTokens(""ab:cd:ef::"", "":"") = [""ab"", ""cd"", ""ef"", """", """"]
 * StringUtils.splitPreserveAllTokens(""ab::cd:ef"", "":"")  = [""ab"", """", cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens("":cd:ef"", "":"")     = ["""", cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens(""::cd:ef"", "":"")    = ["""", """", cd"", ""ef""]
 * StringUtils.splitPreserveAllTokens("":cd:ef:"", "":"")    = ["""", cd"", ""ef"", """"]
 * </pre>
 *
 * @param str  the String to parse, may be <code>null</code>
 * @param separatorChars  the characters used as the delimiters,
 *  <code>null</code> splits on whitespace
 * @return an array of parsed Strings, <code>null</code> if null String input
 * @since 2.1
 */"
"public static String[] split(String str, String separatorChars) {
    return splitWorker(str, separatorChars, -1, false);
}","public void test219241() throws Throwable {
    String[] stringArray0 = StringUtils.split(""user.name"", ""user.name"");
    assertEquals(0, stringArray0.length);
}","/**
 * <p>Splits the provided text into an array, separators specified.
 * This is an alternative to using StringTokenizer.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as one separator.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.
 * A <code>null</code> separatorChars splits on whitespace.</p>
 *
 * <pre>
 * StringUtils.split(null, *)         = null
 * StringUtils.split("""", *)           = []
 * StringUtils.split(""abc def"", null) = [""abc"", ""def""]
 * StringUtils.split(""abc def"", "" "")  = [""abc"", ""def""]
 * StringUtils.split(""abc  def"", "" "") = [""abc"", ""def""]
 * StringUtils.split(""ab:cd:ef"", "":"") = [""ab"", ""cd"", ""ef""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @param separatorChars  the characters used as the delimiters,
 *  <code>null</code> splits on whitespace
 * @return an array of parsed Strings, <code>null</code> if null String input
 */"
"public static String[] splitByCharacterTypeCamelCase(String str) {
    return splitByCharacterType(str, true);
}","public void test220242() throws Throwable {
    String[] stringArray0 = new String[3];
    String[] stringArray1 = StringUtils.splitByCharacterTypeCamelCase(stringArray0[2]);
    assertNull(stringArray1);
}","/**
 * <p>Splits a String by Character type as returned by
 * <code>java.lang.Character.getType(char)</code>. Groups of contiguous
 * characters of the same type are returned as complete tokens, with the
 * following exception: the character of type
 * <code>Character.UPPERCASE_LETTER</code>, if any, immediately
 * preceding a token of type <code>Character.LOWERCASE_LETTER</code>
 * will belong to the following token rather than to the preceding, if any,
 * <code>Character.UPPERCASE_LETTER</code> token.
 * <pre>
 * StringUtils.splitByCharacterTypeCamelCase(null)         = null
 * StringUtils.splitByCharacterTypeCamelCase("""")           = []
 * StringUtils.splitByCharacterTypeCamelCase(""ab de fg"")   = [""ab"", "" "", ""de"", "" "", ""fg""]
 * StringUtils.splitByCharacterTypeCamelCase(""ab   de fg"") = [""ab"", ""   "", ""de"", "" "", ""fg""]
 * StringUtils.splitByCharacterTypeCamelCase(""ab:cd:ef"")   = [""ab"", "":"", ""cd"", "":"", ""ef""]
 * StringUtils.splitByCharacterTypeCamelCase(""number5"")    = [""number"", ""5""]
 * StringUtils.splitByCharacterTypeCamelCase(""fooBar"")     = [""foo"", ""Bar""]
 * StringUtils.splitByCharacterTypeCamelCase(""foo200Bar"")  = [""foo"", ""200"", ""Bar""]
 * StringUtils.splitByCharacterTypeCamelCase(""ASFRules"")   = [""ASF"", ""Rules""]
 * </pre>
 * @param str the String to split, may be <code>null</code>
 * @return an array of parsed Strings, <code>null</code> if null String input
 * @since 2.4
 */"
"public static String[] splitByCharacterType(String str) {
    return splitByCharacterType(str, false);
}","public void test221243() throws Throwable {
    String[] stringArray0 = StringUtils.splitByCharacterType(""wWmw\""<jCQ*_VUM"");
    assertEquals(10, stringArray0.length);
}","/**
 * <p>Splits a String by Character type as returned by
 * <code>java.lang.Character.getType(char)</code>. Groups of contiguous
 * characters of the same type are returned as complete tokens.
 * <pre>
 * StringUtils.splitByCharacterType(null)         = null
 * StringUtils.splitByCharacterType("""")           = []
 * StringUtils.splitByCharacterType(""ab de fg"")   = [""ab"", "" "", ""de"", "" "", ""fg""]
 * StringUtils.splitByCharacterType(""ab   de fg"") = [""ab"", ""   "", ""de"", "" "", ""fg""]
 * StringUtils.splitByCharacterType(""ab:cd:ef"")   = [""ab"", "":"", ""cd"", "":"", ""ef""]
 * StringUtils.splitByCharacterType(""number5"")    = [""number"", ""5""]
 * StringUtils.splitByCharacterType(""fooBar"")     = [""foo"", ""B"", ""ar""]
 * StringUtils.splitByCharacterType(""foo200Bar"")  = [""foo"", ""200"", ""B"", ""ar""]
 * StringUtils.splitByCharacterType(""ASFRules"")   = [""ASFR"", ""ules""]
 * </pre>
 * @param str the String to split, may be <code>null</code>
 * @return an array of parsed Strings, <code>null</code> if null String input
 * @since 2.4
 */"
"public static String[] splitByCharacterTypeCamelCase(String str) {
    return splitByCharacterType(str, true);
}","public void test222244() throws Throwable {
    String[] stringArray0 = StringUtils.splitByCharacterTypeCamelCase(""-^3JYTnJx=  Ou"");
    assertEquals(9, stringArray0.length);
}","/**
 * <p>Splits a String by Character type as returned by
 * <code>java.lang.Character.getType(char)</code>. Groups of contiguous
 * characters of the same type are returned as complete tokens, with the
 * following exception: the character of type
 * <code>Character.UPPERCASE_LETTER</code>, if any, immediately
 * preceding a token of type <code>Character.LOWERCASE_LETTER</code>
 * will belong to the following token rather than to the preceding, if any,
 * <code>Character.UPPERCASE_LETTER</code> token.
 * <pre>
 * StringUtils.splitByCharacterTypeCamelCase(null)         = null
 * StringUtils.splitByCharacterTypeCamelCase("""")           = []
 * StringUtils.splitByCharacterTypeCamelCase(""ab de fg"")   = [""ab"", "" "", ""de"", "" "", ""fg""]
 * StringUtils.splitByCharacterTypeCamelCase(""ab   de fg"") = [""ab"", ""   "", ""de"", "" "", ""fg""]
 * StringUtils.splitByCharacterTypeCamelCase(""ab:cd:ef"")   = [""ab"", "":"", ""cd"", "":"", ""ef""]
 * StringUtils.splitByCharacterTypeCamelCase(""number5"")    = [""number"", ""5""]
 * StringUtils.splitByCharacterTypeCamelCase(""fooBar"")     = [""foo"", ""Bar""]
 * StringUtils.splitByCharacterTypeCamelCase(""foo200Bar"")  = [""foo"", ""200"", ""Bar""]
 * StringUtils.splitByCharacterTypeCamelCase(""ASFRules"")   = [""ASF"", ""Rules""]
 * </pre>
 * @param str the String to split, may be <code>null</code>
 * @return an array of parsed Strings, <code>null</code> if null String input
 * @since 2.4
 */"
"public static String join(Object[] array, char separator) {
    if (array == null) {
        return null;
    }
    return join(array, separator, 0, array.length);
}","public void test223245() throws Throwable {
    String string0 = StringUtils.join((Object[]) null, '@');
    assertNull(string0);
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)               = null
 * StringUtils.join([], *)                 = """"
 * StringUtils.join([null], *)             = """"
 * StringUtils.join([""a"", ""b"", ""c""], ';')  = ""a;b;c""
 * StringUtils.join([""a"", ""b"", ""c""], null) = ""abc""
 * StringUtils.join([null, """", ""a""], ';')  = "";;a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use
 * @return the joined String, <code>null</code> if null array input
 * @since 2.0
 */"
"public static String join(Object[] array, char separator, int startIndex, int endIndex) {
    if (array == null) {
        return null;
    }
    int bufSize = (endIndex - startIndex);
    if (bufSize <= 0) {
        return EMPTY;
    }
    bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);
    StringBuilder buf = new StringBuilder(bufSize);
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}","public void test224246() throws Throwable {
    String string0 = StringUtils.join((Object[]) null, 'v', 743, 743);
    assertNull(string0);
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)               = null
 * StringUtils.join([], *)                 = """"
 * StringUtils.join([null], *)             = """"
 * StringUtils.join([""a"", ""b"", ""c""], ';')  = ""a;b;c""
 * StringUtils.join([""a"", ""b"", ""c""], null) = ""abc""
 * StringUtils.join([null, """", ""a""], ';')  = "";;a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use
 * @param startIndex the first index to start joining from.  It is
 * an error to pass in an end index past the end of the array
 * @param endIndex the index to stop joining from (exclusive). It is
 * an error to pass in an end index past the end of the array
 * @return the joined String, <code>null</code> if null array input
 * @since 2.0
 */"
"public static String join(Object[] array, char separator) {
    if (array == null) {
        return null;
    }
    return join(array, separator, 0, array.length);
}","public void test225247() throws Throwable {
    String[] stringArray0 = new String[11];
    String string0 = StringUtils.join((Object[]) stringArray0, '`');
    assertNotNull(string0);
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)               = null
 * StringUtils.join([], *)                 = """"
 * StringUtils.join([null], *)             = """"
 * StringUtils.join([""a"", ""b"", ""c""], ';')  = ""a;b;c""
 * StringUtils.join([""a"", ""b"", ""c""], null) = ""abc""
 * StringUtils.join([null, """", ""a""], ';')  = "";;a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use
 * @return the joined String, <code>null</code> if null array input
 * @since 2.0
 */"
"// Joining
//-----------------------------------------------------------------------
/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No separator is added to the joined String.
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null)            = null
 * StringUtils.join([])              = """"
 * StringUtils.join([null])          = """"
 * StringUtils.join([""a"", ""b"", ""c""]) = ""abc""
 * StringUtils.join([null, """", ""a""]) = ""a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @return the joined String, <code>null</code> if null array input
 * @since 2.0
 */
public static String join(Object[] array) {
    return join(array, null);
}","public void test226249() throws Throwable {
    String string0 = StringUtils.join((Object[]) null);
    assertNull(string0);
}",""
"public static String join(Object[] array, String separator, int startIndex, int endIndex) {
    if (array == null) {
        return null;
    }
    if (separator == null) {
        separator = EMPTY;
    }
    // endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))
    //           (Assuming that all Strings are roughly equally long)
    int bufSize = (endIndex - startIndex);
    if (bufSize <= 0) {
        return EMPTY;
    }
    bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());
    StringBuilder buf = new StringBuilder(bufSize);
    for (int i = startIndex; i < endIndex; i++) {
        if (i > startIndex) {
            buf.append(separator);
        }
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}","public void test227250() throws Throwable {
    String string0 = StringUtils.join((Object[]) null, ""Q^:"", (-884), (-884));
    assertNull(string0);
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A <code>null</code> separator is the same as an empty String ("""").
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)                = null
 * StringUtils.join([], *)                  = """"
 * StringUtils.join([null], *)              = """"
 * StringUtils.join([""a"", ""b"", ""c""], ""--"")  = ""a--b--c""
 * StringUtils.join([""a"", ""b"", ""c""], null)  = ""abc""
 * StringUtils.join([""a"", ""b"", ""c""], """")    = ""abc""
 * StringUtils.join([null, """", ""a""], ',')   = "",,a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @param startIndex the first index to start joining from.  It is
 * an error to pass in an end index past the end of the array
 * @param endIndex the index to stop joining from (exclusive). It is
 * an error to pass in an end index past the end of the array
 * @return the joined String, <code>null</code> if null array input
 */"
"public static String join(Object[] array, String separator) {
    if (array == null) {
        return null;
    }
    return join(array, separator, 0, array.length);
}","public void test228251() throws Throwable {
    String[] stringArray0 = new String[18];
    String string0 = StringUtils.join((Object[]) stringArray0, ""}PpL"");
    assertNotNull(string0);
}","/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A <code>null</code> separator is the same as an empty String ("""").
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null, *)                = null
 * StringUtils.join([], *)                  = """"
 * StringUtils.join([null], *)              = """"
 * StringUtils.join([""a"", ""b"", ""c""], ""--"")  = ""a--b--c""
 * StringUtils.join([""a"", ""b"", ""c""], null)  = ""abc""
 * StringUtils.join([""a"", ""b"", ""c""], """")    = ""abc""
 * StringUtils.join([null, """", ""a""], ',')   = "",,a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @return the joined String, <code>null</code> if null array input
 */"
"// Joining
//-----------------------------------------------------------------------
/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No separator is added to the joined String.
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null)            = null
 * StringUtils.join([])              = """"
 * StringUtils.join([null])          = """"
 * StringUtils.join([""a"", ""b"", ""c""]) = ""abc""
 * StringUtils.join([null, """", ""a""]) = ""a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @return the joined String, <code>null</code> if null array input
 * @since 2.0
 */
public static String join(Object[] array) {
    return join(array, null);
}","public void test229253() throws Throwable {
    Object[] objectArray0 = new Object[0];
    String string0 = StringUtils.join(objectArray0);
    assertEquals("""", string0);
}",""
"// Joining
//-----------------------------------------------------------------------
/**
 * <p>Joins the elements of the provided array into a single String
 * containing the provided list of elements.</p>
 *
 * <p>No separator is added to the joined String.
 * Null objects or empty strings within the array are represented by
 * empty strings.</p>
 *
 * <pre>
 * StringUtils.join(null)            = null
 * StringUtils.join([])              = """"
 * StringUtils.join([null])          = """"
 * StringUtils.join([""a"", ""b"", ""c""]) = ""abc""
 * StringUtils.join([null, """", ""a""]) = ""a""
 * </pre>
 *
 * @param array  the array of values to join together, may be null
 * @return the joined String, <code>null</code> if null array input
 * @since 2.0
 */
public static String join(Object[] array) {
    return join(array, null);
}","public void test230254() throws Throwable {
    Object[] objectArray0 = new Object[1];
    Object object0 = new Object();
    objectArray0[0] = object0;
    String string0 = StringUtils.join(objectArray0);
    assertNotNull(string0);
}",""
"public static String join(Iterable<?> iterable, char separator) {
    if (iterable == null) {
        return null;
    }
    return join(iterable.iterator(), separator);
}","public void test231255() throws Throwable {
    Stack<Locale> stack0 = new Stack<Locale>();
    String string0 = StringUtils.join((Iterable<?>) stack0, '\u018B');
    assertEquals("""", string0);
}","/**
 * <p>Joins the elements of the provided <code>Iterable</code> into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list. Null objects or empty
 * strings within the iteration are represented by empty strings.</p>
 *
 * <p>See the examples here: {@link #join(Object[],char)}. </p>
 *
 * @param iterable  the <code>Iterable</code> providing the values to join together, may be null
 * @param separator  the separator character to use
 * @return the joined String, <code>null</code> if null iterator input
 * @since 2.3
 */"
"public static String join(Iterator<?> iterator, char separator) {
    // handle null, zero and one elements before building a buffer
    if (iterator == null) {
        return null;
    }
    if (!iterator.hasNext()) {
        return EMPTY;
    }
    Object first = iterator.next();
    if (!iterator.hasNext()) {
        return ObjectUtils.toString(first);
    }
    // two or more elements
    // Java default is 16, probably too small
    StringBuilder buf = new StringBuilder(256);
    if (first != null) {
        buf.append(first);
    }
    while (iterator.hasNext()) {
        buf.append(separator);
        Object obj = iterator.next();
        if (obj != null) {
            buf.append(obj);
        }
    }
    return buf.toString();
}","public void test232256() throws Throwable {
    String string0 = StringUtils.join((Iterator<?>) null, 'T');
    assertNull(string0);
}","/**
 * <p>Joins the elements of the provided <code>Iterator</code> into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list. Null objects or empty
 * strings within the iteration are represented by empty strings.</p>
 *
 * <p>See the examples here: {@link #join(Object[],char)}. </p>
 *
 * @param iterator  the <code>Iterator</code> of values to join together, may be null
 * @param separator  the separator character to use
 * @return the joined String, <code>null</code> if null iterator input
 * @since 2.0
 */"
"public static String join(Iterable<?> iterable, char separator) {
    if (iterable == null) {
        return null;
    }
    return join(iterable.iterator(), separator);
}","public void test233257() throws Throwable {
    Stack<Locale> stack0 = new Stack<Locale>();
    Locale locale0 = Locale.CHINESE;
    stack0.add(locale0);
    String string0 = StringUtils.join((Iterable<?>) stack0, '\u018B');
    assertNotNull(string0);
}","/**
 * <p>Joins the elements of the provided <code>Iterable</code> into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list. Null objects or empty
 * strings within the iteration are represented by empty strings.</p>
 *
 * <p>See the examples here: {@link #join(Object[],char)}. </p>
 *
 * @param iterable  the <code>Iterable</code> providing the values to join together, may be null
 * @param separator  the separator character to use
 * @return the joined String, <code>null</code> if null iterator input
 * @since 2.3
 */"
"public static String join(Iterable<?> iterable, char separator) {
    if (iterable == null) {
        return null;
    }
    return join(iterable.iterator(), separator);
}","public void test234258() throws Throwable {
    Stack<Locale> stack0 = new Stack<Locale>();
    Locale locale0 = Locale.CHINESE;
    stack0.add(locale0);
    stack0.add(locale0);
    String string0 = StringUtils.join((Iterable<?>) stack0, '\u018B');
    assertEquals(""zh\u018Bzh"", string0);
}","/**
 * <p>Joins the elements of the provided <code>Iterable</code> into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list. Null objects or empty
 * strings within the iteration are represented by empty strings.</p>
 *
 * <p>See the examples here: {@link #join(Object[],char)}. </p>
 *
 * @param iterable  the <code>Iterable</code> providing the values to join together, may be null
 * @param separator  the separator character to use
 * @return the joined String, <code>null</code> if null iterator input
 * @since 2.3
 */"
"public static String join(Iterable<?> iterable, char separator) {
    if (iterable == null) {
        return null;
    }
    return join(iterable.iterator(), separator);
}","public void test235260() throws Throwable {
    Stack<Locale> stack0 = new Stack<Locale>();
    stack0.setSize(16);
    String string0 = StringUtils.join((Iterable<?>) stack0, '\u03BF');
    assertNotNull(string0);
}","/**
 * <p>Joins the elements of the provided <code>Iterable</code> into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list. Null objects or empty
 * strings within the iteration are represented by empty strings.</p>
 *
 * <p>See the examples here: {@link #join(Object[],char)}. </p>
 *
 * @param iterable  the <code>Iterable</code> providing the values to join together, may be null
 * @param separator  the separator character to use
 * @return the joined String, <code>null</code> if null iterator input
 * @since 2.3
 */"
"public static String join(Iterable<?> iterable, String separator) {
    if (iterable == null) {
        return null;
    }
    return join(iterable.iterator(), separator);
}","public void test236262() throws Throwable {
    Stack<Locale> stack0 = new Stack<Locale>();
    String string0 = StringUtils.join((Iterable<?>) stack0, ""\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF"");
    assertEquals("""", string0);
}","/**
 * <p>Joins the elements of the provided <code>Iterable</code> into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A <code>null</code> separator is the same as an empty String ("""").</p>
 *
 * <p>See the examples here: {@link #join(Object[],String)}. </p>
 *
 * @param iterable  the <code>Iterable</code> providing the values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @return the joined String, <code>null</code> if null iterator input
 * @since 2.3
 */"
"public static String join(Iterator<?> iterator, String separator) {
    // handle null, zero and one elements before building a buffer
    if (iterator == null) {
        return null;
    }
    if (!iterator.hasNext()) {
        return EMPTY;
    }
    Object first = iterator.next();
    if (!iterator.hasNext()) {
        return ObjectUtils.toString(first);
    }
    // two or more elements
    // Java default is 16, probably too small
    StringBuilder buf = new StringBuilder(256);
    if (first != null) {
        buf.append(first);
    }
    while (iterator.hasNext()) {
        if (separator != null) {
            buf.append(separator);
        }
        Object obj = iterator.next();
        if (obj != null) {
            buf.append(obj);
        }
    }
    return buf.toString();
}","public void test237263() throws Throwable {
    String string0 = StringUtils.join((Iterator<?>) null, ""illegalaccessexception occurred during ]9;w2a8b\""mv}!t codeCannot pad a negative amount: "");
    assertNull(string0);
}","/**
 * <p>Joins the elements of the provided <code>Iterator</code> into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A <code>null</code> separator is the same as an empty String ("""").</p>
 *
 * <p>See the examples here: {@link #join(Object[],String)}. </p>
 *
 * @param iterator  the <code>Iterator</code> of values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @return the joined String, <code>null</code> if null iterator input
 */"
"public static String join(Iterable<?> iterable, String separator) {
    if (iterable == null) {
        return null;
    }
    return join(iterable.iterator(), separator);
}","public void test238264() throws Throwable {
    Stack<Locale> stack0 = new Stack<Locale>();
    stack0.setSize(16);
    String string0 = StringUtils.join((Iterable<?>) stack0, ""\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF"");
    assertNotNull(string0);
}","/**
 * <p>Joins the elements of the provided <code>Iterable</code> into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A <code>null</code> separator is the same as an empty String ("""").</p>
 *
 * <p>See the examples here: {@link #join(Object[],String)}. </p>
 *
 * @param iterable  the <code>Iterable</code> providing the values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @return the joined String, <code>null</code> if null iterator input
 * @since 2.3
 */"
"public static String join(Iterable<?> iterable, String separator) {
    if (iterable == null) {
        return null;
    }
    return join(iterable.iterator(), separator);
}","public void test239265() throws Throwable {
    Locale.FilteringMode locale_FilteringMode0 = Locale.FilteringMode.AUTOSELECT_FILTERING;
    Locale.FilteringMode[] locale_FilteringModeArray0 = new Locale.FilteringMode[1];
    locale_FilteringModeArray0[0] = locale_FilteringMode0;
    EnumSet<Locale.FilteringMode> enumSet0 = EnumSet.of(locale_FilteringMode0, locale_FilteringModeArray0);
    String string0 = StringUtils.join((Iterable<?>) enumSet0, ""search cannot pad a negative amount: t match: "");
    assertNotNull(string0);
}","/**
 * <p>Joins the elements of the provided <code>Iterable</code> into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A <code>null</code> separator is the same as an empty String ("""").</p>
 *
 * <p>See the examples here: {@link #join(Object[],String)}. </p>
 *
 * @param iterable  the <code>Iterable</code> providing the values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @return the joined String, <code>null</code> if null iterator input
 * @since 2.3
 */"
"public static String join(Iterable<?> iterable, String separator) {
    if (iterable == null) {
        return null;
    }
    return join(iterable.iterator(), separator);
}","public void test240266() throws Throwable {
    Class<Locale.FilteringMode> class0 = Locale.FilteringMode.class;
    EnumSet<Locale.FilteringMode> enumSet0 = EnumSet.allOf(class0);
    String string0 = StringUtils.join((Iterable<?>) enumSet0, (String) null);
    assertEquals(""AUTOSELECT_FILTERINGEXTENDED_FILTERINGIGNORE_EXTENDED_RANGESMAP_EXTENDED_RANGESREJECT_EXTENDED_RANGES"", string0);
}","/**
 * <p>Joins the elements of the provided <code>Iterable</code> into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A <code>null</code> separator is the same as an empty String ("""").</p>
 *
 * <p>See the examples here: {@link #join(Object[],String)}. </p>
 *
 * @param iterable  the <code>Iterable</code> providing the values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @return the joined String, <code>null</code> if null iterator input
 * @since 2.3
 */"
"public static String join(Iterable<?> iterable, char separator) {
    if (iterable == null) {
        return null;
    }
    return join(iterable.iterator(), separator);
}","public void test241268() throws Throwable {
    String string0 = StringUtils.join((Iterable<?>) null, '-');
    assertNull(string0);
}","/**
 * <p>Joins the elements of the provided <code>Iterable</code> into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list. Null objects or empty
 * strings within the iteration are represented by empty strings.</p>
 *
 * <p>See the examples here: {@link #join(Object[],char)}. </p>
 *
 * @param iterable  the <code>Iterable</code> providing the values to join together, may be null
 * @param separator  the separator character to use
 * @return the joined String, <code>null</code> if null iterator input
 * @since 2.3
 */"
"public static String join(Iterable<?> iterable, String separator) {
    if (iterable == null) {
        return null;
    }
    return join(iterable.iterator(), separator);
}","public void test242269() throws Throwable {
    String string0 = StringUtils.join((Iterable<?>) null, ""MSx]`BDW:MdF}hb"");
    assertNull(string0);
}","/**
 * <p>Joins the elements of the provided <code>Iterable</code> into
 * a single String containing the provided elements.</p>
 *
 * <p>No delimiter is added before or after the list.
 * A <code>null</code> separator is the same as an empty String ("""").</p>
 *
 * <p>See the examples here: {@link #join(Object[],String)}. </p>
 *
 * @param iterable  the <code>Iterable</code> providing the values to join together, may be null
 * @param separator  the separator character to use, null treated as """"
 * @return the joined String, <code>null</code> if null iterator input
 * @since 2.3
 */"
"// Delete
//-----------------------------------------------------------------------
/**
 * <p>Deletes all whitespaces from a String as defined by
 * {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.deleteWhitespace(null)         = null
 * StringUtils.deleteWhitespace("""")           = """"
 * StringUtils.deleteWhitespace(""abc"")        = ""abc""
 * StringUtils.deleteWhitespace(""   ab  c  "") = ""abc""
 * </pre>
 *
 * @param str  the String to delete whitespace from, may be null
 * @return the String without whitespaces, <code>null</code> if null String input
 */
public static String deleteWhitespace(String str) {
    if (isEmpty(str)) {
        return str;
    }
    int sz = str.length();
    char[] chs = new char[sz];
    int count = 0;
    for (int i = 0; i < sz; i++) {
        if (!Character.isWhitespace(str.charAt(i))) {
            chs[count++] = str.charAt(i);
        }
    }
    if (count == sz) {
        return str;
    }
    return new String(chs, 0, count);
}","public void test243270() throws Throwable {
    String string0 = StringUtils.deleteWhitespace((String) null);
    assertNull(string0);
}",""
"// Delete
//-----------------------------------------------------------------------
/**
 * <p>Deletes all whitespaces from a String as defined by
 * {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.deleteWhitespace(null)         = null
 * StringUtils.deleteWhitespace("""")           = """"
 * StringUtils.deleteWhitespace(""abc"")        = ""abc""
 * StringUtils.deleteWhitespace(""   ab  c  "") = ""abc""
 * </pre>
 *
 * @param str  the String to delete whitespace from, may be null
 * @return the String without whitespaces, <code>null</code> if null String input
 */
public static String deleteWhitespace(String str) {
    if (isEmpty(str)) {
        return str;
    }
    int sz = str.length();
    char[] chs = new char[sz];
    int count = 0;
    for (int i = 0; i < sz; i++) {
        if (!Character.isWhitespace(str.charAt(i))) {
            chs[count++] = str.charAt(i);
        }
    }
    if (count == sz) {
        return str;
    }
    return new String(chs, 0, count);
}","public void test244271() throws Throwable {
    String string0 = StringUtils.deleteWhitespace(""{%Villegalaccessexception occurred during ]9;w2a8b\""mv}!t code"");
    assertEquals(""{%Villegalaccessexceptionoccurredduring]9;w2a8b\""mv}!tcode"", string0);
}",""
"// Remove
//-----------------------------------------------------------------------
/**
 * <p>Removes a substring only if it is at the begining of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A <code>null</code> source string will return <code>null</code>.
 * An empty ("""") source string will return the empty string.
 * A <code>null</code> search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeStart(null, *)      = null
 * StringUtils.removeStart("""", *)        = """"
 * StringUtils.removeStart(*, null)      = *
 * StringUtils.removeStart(""www.domain.com"", ""www."")   = ""domain.com""
 * StringUtils.removeStart(""domain.com"", ""www."")       = ""domain.com""
 * StringUtils.removeStart(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeStart(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for and remove, may be null
 * @return the substring with the string removed if found,
 *  <code>null</code> if null String input
 * @since 2.1
 */
public static String removeStart(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (str.startsWith(remove)) {
        return str.substring(remove.length());
    }
    return str;
}","public void test245272() throws Throwable {
    String string0 = StringUtils.removeStart((String) null, (String) null);
    assertNull(string0);
}",""
"// Remove
//-----------------------------------------------------------------------
/**
 * <p>Removes a substring only if it is at the begining of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A <code>null</code> source string will return <code>null</code>.
 * An empty ("""") source string will return the empty string.
 * A <code>null</code> search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeStart(null, *)      = null
 * StringUtils.removeStart("""", *)        = """"
 * StringUtils.removeStart(*, null)      = *
 * StringUtils.removeStart(""www.domain.com"", ""www."")   = ""domain.com""
 * StringUtils.removeStart(""domain.com"", ""www."")       = ""domain.com""
 * StringUtils.removeStart(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeStart(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for and remove, may be null
 * @return the substring with the string removed if found,
 *  <code>null</code> if null String input
 * @since 2.1
 */
public static String removeStart(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (str.startsWith(remove)) {
        return str.substring(remove.length());
    }
    return str;
}","public void test246273() throws Throwable {
    String string0 = StringUtils.removeStart(""\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF"", ""\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF\u03BF"");
    assertEquals("""", string0);
}",""
"// Remove
//-----------------------------------------------------------------------
/**
 * <p>Removes a substring only if it is at the begining of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A <code>null</code> source string will return <code>null</code>.
 * An empty ("""") source string will return the empty string.
 * A <code>null</code> search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeStart(null, *)      = null
 * StringUtils.removeStart("""", *)        = """"
 * StringUtils.removeStart(*, null)      = *
 * StringUtils.removeStart(""www.domain.com"", ""www."")   = ""domain.com""
 * StringUtils.removeStart(""domain.com"", ""www."")       = ""domain.com""
 * StringUtils.removeStart(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeStart(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for and remove, may be null
 * @return the substring with the string removed if found,
 *  <code>null</code> if null String input
 * @since 2.1
 */
public static String removeStart(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (str.startsWith(remove)) {
        return str.substring(remove.length());
    }
    return str;
}","public void test247274() throws Throwable {
    String string0 = StringUtils.removeStart(""Cannot pad a negative amount: "", """");
    assertEquals(""Cannot pad a negative amount: "", string0);
}",""
"// Remove
//-----------------------------------------------------------------------
/**
 * <p>Removes a substring only if it is at the begining of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A <code>null</code> source string will return <code>null</code>.
 * An empty ("""") source string will return the empty string.
 * A <code>null</code> search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeStart(null, *)      = null
 * StringUtils.removeStart("""", *)        = """"
 * StringUtils.removeStart(*, null)      = *
 * StringUtils.removeStart(""www.domain.com"", ""www."")   = ""domain.com""
 * StringUtils.removeStart(""domain.com"", ""www."")       = ""domain.com""
 * StringUtils.removeStart(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeStart(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for and remove, may be null
 * @return the substring with the string removed if found,
 *  <code>null</code> if null String input
 * @since 2.1
 */
public static String removeStart(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (str.startsWith(remove)) {
        return str.substring(remove.length());
    }
    return str;
}","public void test248275() throws Throwable {
    String string0 = StringUtils.removeStart(""Cannot pad a negative amount: "", ""illegalaccessexception occurred during ]9;w2a8b\""mv}!t code"");
    assertEquals(""Cannot pad a negative amount: "", string0);
}",""
"public static String removeStartIgnoreCase(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (startsWithIgnoreCase(str, remove)) {
        return str.substring(remove.length());
    }
    return str;
}","public void test249276() throws Throwable {
    String string0 = StringUtils.removeStartIgnoreCase((String) null, (String) null);
    assertNull(string0);
}","/**
 * <p>Case insensitive removal of a substring if it is at the begining of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A <code>null</code> source string will return <code>null</code>.
 * An empty ("""") source string will return the empty string.
 * A <code>null</code> search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeStartIgnoreCase(null, *)      = null
 * StringUtils.removeStartIgnoreCase("""", *)        = """"
 * StringUtils.removeStartIgnoreCase(*, null)      = *
 * StringUtils.removeStartIgnoreCase(""www.domain.com"", ""www."")   = ""domain.com""
 * StringUtils.removeStartIgnoreCase(""www.domain.com"", ""WWW."")   = ""domain.com""
 * StringUtils.removeStartIgnoreCase(""domain.com"", ""www."")       = ""domain.com""
 * StringUtils.removeStartIgnoreCase(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeStartIgnoreCase(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for (case insensitive) and remove, may be null
 * @return the substring with the string removed if found,
 *  <code>null</code> if null String input
 * @since 2.4
 */"
"public static String removeStartIgnoreCase(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (startsWithIgnoreCase(str, remove)) {
        return str.substring(remove.length());
    }
    return str;
}","public void test250277() throws Throwable {
    String string0 = StringUtils.removeStartIgnoreCase(""3u3WfV0jzGK"", """");
    assertEquals(""3u3WfV0jzGK"", string0);
}","/**
 * <p>Case insensitive removal of a substring if it is at the begining of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A <code>null</code> source string will return <code>null</code>.
 * An empty ("""") source string will return the empty string.
 * A <code>null</code> search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeStartIgnoreCase(null, *)      = null
 * StringUtils.removeStartIgnoreCase("""", *)        = """"
 * StringUtils.removeStartIgnoreCase(*, null)      = *
 * StringUtils.removeStartIgnoreCase(""www.domain.com"", ""www."")   = ""domain.com""
 * StringUtils.removeStartIgnoreCase(""www.domain.com"", ""WWW."")   = ""domain.com""
 * StringUtils.removeStartIgnoreCase(""domain.com"", ""www."")       = ""domain.com""
 * StringUtils.removeStartIgnoreCase(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeStartIgnoreCase(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for (case insensitive) and remove, may be null
 * @return the substring with the string removed if found,
 *  <code>null</code> if null String input
 * @since 2.4
 */"
"public static String removeStartIgnoreCase(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (startsWithIgnoreCase(str, remove)) {
        return str.substring(remove.length());
    }
    return str;
}","public void test251278() throws Throwable {
    String string0 = StringUtils.removeStartIgnoreCase(""g"", ""g"");
    assertEquals("""", string0);
}","/**
 * <p>Case insensitive removal of a substring if it is at the begining of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A <code>null</code> source string will return <code>null</code>.
 * An empty ("""") source string will return the empty string.
 * A <code>null</code> search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeStartIgnoreCase(null, *)      = null
 * StringUtils.removeStartIgnoreCase("""", *)        = """"
 * StringUtils.removeStartIgnoreCase(*, null)      = *
 * StringUtils.removeStartIgnoreCase(""www.domain.com"", ""www."")   = ""domain.com""
 * StringUtils.removeStartIgnoreCase(""www.domain.com"", ""WWW."")   = ""domain.com""
 * StringUtils.removeStartIgnoreCase(""domain.com"", ""www."")       = ""domain.com""
 * StringUtils.removeStartIgnoreCase(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeStartIgnoreCase(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for (case insensitive) and remove, may be null
 * @return the substring with the string removed if found,
 *  <code>null</code> if null String input
 * @since 2.4
 */"
"public static String removeEnd(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (str.endsWith(remove)) {
        return str.substring(0, str.length() - remove.length());
    }
    return str;
}","public void test252279() throws Throwable {
    String string0 = StringUtils.removeEnd(""'vK"", """");
    assertEquals(""'vK"", string0);
}","/**
 * <p>Removes a substring only if it is at the end of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A <code>null</code> source string will return <code>null</code>.
 * An empty ("""") source string will return the empty string.
 * A <code>null</code> search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeEnd(null, *)      = null
 * StringUtils.removeEnd("""", *)        = """"
 * StringUtils.removeEnd(*, null)      = *
 * StringUtils.removeEnd(""www.domain.com"", "".com."")  = ""www.domain.com""
 * StringUtils.removeEnd(""www.domain.com"", "".com"")   = ""www.domain""
 * StringUtils.removeEnd(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeEnd(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for and remove, may be null
 * @return the substring with the string removed if found,
 *  <code>null</code> if null String input
 * @since 2.1
 */"
"public static String removeEnd(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (str.endsWith(remove)) {
        return str.substring(0, str.length() - remove.length());
    }
    return str;
}","public void test253280() throws Throwable {
    String string0 = StringUtils.removeEnd(""N+U"", ""illegalaccessexception occurred during ]9;w2a8b\""mv}!t codeCannot pad a negative amount: "");
    assertEquals(""N+U"", string0);
}","/**
 * <p>Removes a substring only if it is at the end of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A <code>null</code> source string will return <code>null</code>.
 * An empty ("""") source string will return the empty string.
 * A <code>null</code> search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeEnd(null, *)      = null
 * StringUtils.removeEnd("""", *)        = """"
 * StringUtils.removeEnd(*, null)      = *
 * StringUtils.removeEnd(""www.domain.com"", "".com."")  = ""www.domain.com""
 * StringUtils.removeEnd(""www.domain.com"", "".com"")   = ""www.domain""
 * StringUtils.removeEnd(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeEnd(""abc"", """")    = ""abc""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for and remove, may be null
 * @return the substring with the string removed if found,
 *  <code>null</code> if null String input
 * @since 2.1
 */"
"public static String removeEndIgnoreCase(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (endsWithIgnoreCase(str, remove)) {
        return str.substring(0, str.length() - remove.length());
    }
    return str;
}","public void test254281() throws Throwable {
    String string0 = StringUtils.removeEndIgnoreCase("""", (String) null);
    assertEquals("""", string0);
}","/**
 * <p>Case insensitive removal of a substring if it is at the end of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A <code>null</code> source string will return <code>null</code>.
 * An empty ("""") source string will return the empty string.
 * A <code>null</code> search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeEndIgnoreCase(null, *)      = null
 * StringUtils.removeEndIgnoreCase("""", *)        = """"
 * StringUtils.removeEndIgnoreCase(*, null)      = *
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", "".com."")  = ""www.domain.com""
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", "".com"")   = ""www.domain""
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeEndIgnoreCase(""abc"", """")    = ""abc""
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", "".COM"") = ""www.domain"")
 * StringUtils.removeEndIgnoreCase(""www.domain.COM"", "".com"") = ""www.domain"")
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for (case insensitive) and remove, may be null
 * @return the substring with the string removed if found,
 *  <code>null</code> if null String input
 * @since 2.4
 */"
"public static String removeEndIgnoreCase(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (endsWithIgnoreCase(str, remove)) {
        return str.substring(0, str.length() - remove.length());
    }
    return str;
}","public void test255282() throws Throwable {
    String string0 = StringUtils.removeEndIgnoreCase("" is less than 0: "", (String) null);
    assertNotNull(string0);
}","/**
 * <p>Case insensitive removal of a substring if it is at the end of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A <code>null</code> source string will return <code>null</code>.
 * An empty ("""") source string will return the empty string.
 * A <code>null</code> search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeEndIgnoreCase(null, *)      = null
 * StringUtils.removeEndIgnoreCase("""", *)        = """"
 * StringUtils.removeEndIgnoreCase(*, null)      = *
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", "".com."")  = ""www.domain.com""
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", "".com"")   = ""www.domain""
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeEndIgnoreCase(""abc"", """")    = ""abc""
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", "".COM"") = ""www.domain"")
 * StringUtils.removeEndIgnoreCase(""www.domain.COM"", "".com"") = ""www.domain"")
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for (case insensitive) and remove, may be null
 * @return the substring with the string removed if found,
 *  <code>null</code> if null String input
 * @since 2.4
 */"
"public static String removeEndIgnoreCase(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (endsWithIgnoreCase(str, remove)) {
        return str.substring(0, str.length() - remove.length());
    }
    return str;
}","public void test256284() throws Throwable {
    String string0 = StringUtils.removeEndIgnoreCase(""0"", ""0"");
    assertEquals("""", string0);
}","/**
 * <p>Case insensitive removal of a substring if it is at the end of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A <code>null</code> source string will return <code>null</code>.
 * An empty ("""") source string will return the empty string.
 * A <code>null</code> search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeEndIgnoreCase(null, *)      = null
 * StringUtils.removeEndIgnoreCase("""", *)        = """"
 * StringUtils.removeEndIgnoreCase(*, null)      = *
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", "".com."")  = ""www.domain.com""
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", "".com"")   = ""www.domain""
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", ""domain"") = ""www.domain.com""
 * StringUtils.removeEndIgnoreCase(""abc"", """")    = ""abc""
 * StringUtils.removeEndIgnoreCase(""www.domain.com"", "".COM"") = ""www.domain"")
 * StringUtils.removeEndIgnoreCase(""www.domain.COM"", "".com"") = ""www.domain"")
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for (case insensitive) and remove, may be null
 * @return the substring with the string removed if found,
 *  <code>null</code> if null String input
 * @since 2.4
 */"
"public static String remove(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    return replace(str, remove, EMPTY, -1);
}","public void test257285() throws Throwable {
    String string0 = StringUtils.remove((String) null, (String) null);
    assertNull(string0);
}","/**
 * <p>Removes all occurrences of a substring from within the source string.</p>
 *
 * <p>A <code>null</code> source string will return <code>null</code>.
 * An empty ("""") source string will return the empty string.
 * A <code>null</code> remove string will return the source string.
 * An empty ("""") remove string will return the source string.</p>
 *
 * <pre>
 * StringUtils.remove(null, *)        = null
 * StringUtils.remove("""", *)          = """"
 * StringUtils.remove(*, null)        = *
 * StringUtils.remove(*, """")          = *
 * StringUtils.remove(""queued"", ""ue"") = ""qd""
 * StringUtils.remove(""queued"", ""zz"") = ""queued""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for and remove, may be null
 * @return the substring with the string removed if found,
 *  <code>null</code> if null String input
 * @since 2.1
 */"
"public static String remove(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    return replace(str, remove, EMPTY, -1);
}","public void test258286() throws Throwable {
    String string0 = StringUtils.remove(""java.vm.specification.version"", "")"");
    assertEquals(""java.vm.specification.version"", string0);
}","/**
 * <p>Removes all occurrences of a substring from within the source string.</p>
 *
 * <p>A <code>null</code> source string will return <code>null</code>.
 * An empty ("""") source string will return the empty string.
 * A <code>null</code> remove string will return the source string.
 * An empty ("""") remove string will return the source string.</p>
 *
 * <pre>
 * StringUtils.remove(null, *)        = null
 * StringUtils.remove("""", *)          = """"
 * StringUtils.remove(*, null)        = *
 * StringUtils.remove(*, """")          = *
 * StringUtils.remove(""queued"", ""ue"") = ""qd""
 * StringUtils.remove(""queued"", ""zz"") = ""queued""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for and remove, may be null
 * @return the substring with the string removed if found,
 *  <code>null</code> if null String input
 * @since 2.1
 */"
"public static String remove(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    return replace(str, remove, EMPTY, -1);
}","public void test259287() throws Throwable {
    String string0 = StringUtils.remove(""illegalaccessexception occurred during ]9;w2a8b\""mv}!t codeCannot pad a negative amount: "", (String) null);
    assertEquals(""illegalaccessexception occurred during ]9;w2a8b\""mv}!t codeCannot pad a negative amount: "", string0);
}","/**
 * <p>Removes all occurrences of a substring from within the source string.</p>
 *
 * <p>A <code>null</code> source string will return <code>null</code>.
 * An empty ("""") source string will return the empty string.
 * A <code>null</code> remove string will return the source string.
 * An empty ("""") remove string will return the source string.</p>
 *
 * <pre>
 * StringUtils.remove(null, *)        = null
 * StringUtils.remove("""", *)          = """"
 * StringUtils.remove(*, null)        = *
 * StringUtils.remove(*, """")          = *
 * StringUtils.remove(""queued"", ""ue"") = ""qd""
 * StringUtils.remove(""queued"", ""zz"") = ""queued""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for and remove, may be null
 * @return the substring with the string removed if found,
 *  <code>null</code> if null String input
 * @since 2.1
 */"
"public static String remove(String str, char remove) {
    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {
        return str;
    }
    char[] chars = str.toCharArray();
    int pos = 0;
    for (int i = 0; i < chars.length; i++) {
        if (chars[i] != remove) {
            chars[pos++] = chars[i];
        }
    }
    return new String(chars, 0, pos);
}","public void test260289() throws Throwable {
    String string0 = StringUtils.remove("""", 'P');
    assertEquals("""", string0);
}","/**
 * <p>Removes all occurrences of a character from within the source string.</p>
 *
 * <p>A <code>null</code> source string will return <code>null</code>.
 * An empty ("""") source string will return the empty string.</p>
 *
 * <pre>
 * StringUtils.remove(null, *)       = null
 * StringUtils.remove("""", *)         = """"
 * StringUtils.remove(""queued"", 'u') = ""qeed""
 * StringUtils.remove(""queued"", 'z') = ""queued""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the char to search for and remove, may be null
 * @return the substring with the char removed if found,
 *  <code>null</code> if null String input
 * @since 2.1
 */"
"public static String remove(String str, char remove) {
    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {
        return str;
    }
    char[] chars = str.toCharArray();
    int pos = 0;
    for (int i = 0; i < chars.length; i++) {
        if (chars[i] != remove) {
            chars[pos++] = chars[i];
        }
    }
    return new String(chars, 0, pos);
}","public void test261290() throws Throwable {
    String string0 = StringUtils.remove(""java.home"", 'n');
    assertEquals(""java.home"", string0);
}","/**
 * <p>Removes all occurrences of a character from within the source string.</p>
 *
 * <p>A <code>null</code> source string will return <code>null</code>.
 * An empty ("""") source string will return the empty string.</p>
 *
 * <pre>
 * StringUtils.remove(null, *)       = null
 * StringUtils.remove("""", *)         = """"
 * StringUtils.remove(""queued"", 'u') = ""qeed""
 * StringUtils.remove(""queued"", 'z') = ""queued""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the char to search for and remove, may be null
 * @return the substring with the char removed if found,
 *  <code>null</code> if null String input
 * @since 2.1
 */"
"public static String remove(String str, char remove) {
    if (isEmpty(str) || str.indexOf(remove) == INDEX_NOT_FOUND) {
        return str;
    }
    char[] chars = str.toCharArray();
    int pos = 0;
    for (int i = 0; i < chars.length; i++) {
        if (chars[i] != remove) {
            chars[pos++] = chars[i];
        }
    }
    return new String(chars, 0, pos);
}","public void test262291() throws Throwable {
    String string0 = StringUtils.remove(""NoSuchMethodException occurred during 1.6 backcompat code"", 'c');
    assertEquals(""NoSuhMethodExeption ourred during 1.6 bakompat ode"", string0);
}","/**
 * <p>Removes all occurrences of a character from within the source string.</p>
 *
 * <p>A <code>null</code> source string will return <code>null</code>.
 * An empty ("""") source string will return the empty string.</p>
 *
 * <pre>
 * StringUtils.remove(null, *)       = null
 * StringUtils.remove("""", *)         = """"
 * StringUtils.remove(""queued"", 'u') = ""qeed""
 * StringUtils.remove(""queued"", 'z') = ""queued""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the char to search for and remove, may be null
 * @return the substring with the char removed if found,
 *  <code>null</code> if null String input
 * @since 2.1
 */"
"// Replacing
//-----------------------------------------------------------------------
/**
 * <p>Replaces a String with another String inside a larger String, once.</p>
 *
 * <p>A <code>null</code> reference passed to this method is a no-op.</p>
 *
 * <pre>
 * StringUtils.replaceOnce(null, *, *)        = null
 * StringUtils.replaceOnce("""", *, *)          = """"
 * StringUtils.replaceOnce(""any"", null, *)    = ""any""
 * StringUtils.replaceOnce(""any"", *, null)    = ""any""
 * StringUtils.replaceOnce(""any"", """", *)      = ""any""
 * StringUtils.replaceOnce(""aba"", ""a"", null)  = ""aba""
 * StringUtils.replaceOnce(""aba"", ""a"", """")    = ""ba""
 * StringUtils.replaceOnce(""aba"", ""a"", ""z"")   = ""zba""
 * </pre>
 *
 * @see #replace(String text, String searchString, String replacement, int max)
 * @param text  text to search and replace in, may be null
 * @param searchString  the String to search for, may be null
 * @param replacement  the String to replace with, may be null
 * @return the text with any replacements processed,
 *  <code>null</code> if null String input
 */
public static String replaceOnce(String text, String searchString, String replacement) {
    return replace(text, searchString, replacement, 1);
}","public void test263292() throws Throwable {
    String string0 = StringUtils.replaceOnce("" "", "" "", (String) null);
    assertEquals("" "", string0);
}",""
"public static String replace(String text, String searchString, String replacement, int max) {
    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {
        return text;
    }
    int start = 0;
    int end = text.indexOf(searchString, start);
    if (end == INDEX_NOT_FOUND) {
        return text;
    }
    int replLength = searchString.length();
    int increase = replacement.length() - replLength;
    increase = (increase < 0 ? 0 : increase);
    increase *= (max < 0 ? 16 : (max > 64 ? 64 : max));
    StringBuilder buf = new StringBuilder(text.length() + increase);
    while (end != INDEX_NOT_FOUND) {
        buf.append(text.substring(start, end)).append(replacement);
        start = end + replLength;
        if (--max == 0) {
            break;
        }
        end = text.indexOf(searchString, start);
    }
    buf.append(text.substring(start));
    return buf.toString();
}","public void test264294() throws Throwable {
    String string0 = StringUtils.replace(""normalize"", ""+cmpaAi~;"", ""normalize"", 0);
    assertEquals(""normalize"", string0);
}","/**
 * <p>Replaces a String with another String inside a larger String,
 * for the first <code>max</code> values of the search String.</p>
 *
 * <p>A <code>null</code> reference passed to this method is a no-op.</p>
 *
 * <pre>
 * StringUtils.replace(null, *, *, *)         = null
 * StringUtils.replace("""", *, *, *)           = """"
 * StringUtils.replace(""any"", null, *, *)     = ""any""
 * StringUtils.replace(""any"", *, null, *)     = ""any""
 * StringUtils.replace(""any"", """", *, *)       = ""any""
 * StringUtils.replace(""any"", *, *, 0)        = ""any""
 * StringUtils.replace(""abaa"", ""a"", null, -1) = ""abaa""
 * StringUtils.replace(""abaa"", ""a"", """", -1)   = ""b""
 * StringUtils.replace(""abaa"", ""a"", ""z"", 0)   = ""abaa""
 * StringUtils.replace(""abaa"", ""a"", ""z"", 1)   = ""zbaa""
 * StringUtils.replace(""abaa"", ""a"", ""z"", 2)   = ""zbza""
 * StringUtils.replace(""abaa"", ""a"", ""z"", -1)  = ""zbzz""
 * </pre>
 *
 * @param text  text to search and replace in, may be null
 * @param searchString  the String to search for, may be null
 * @param replacement  the String to replace it with, may be null
 * @param max  maximum number of values to replace, or <code>-1</code> if no maximum
 * @return the text with any replacements processed,
 *  <code>null</code> if null String input
 */"
"public static String replace(String text, String searchString, String replacement, int max) {
    if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {
        return text;
    }
    int start = 0;
    int end = text.indexOf(searchString, start);
    if (end == INDEX_NOT_FOUND) {
        return text;
    }
    int replLength = searchString.length();
    int increase = replacement.length() - replLength;
    increase = (increase < 0 ? 0 : increase);
    increase *= (max < 0 ? 16 : (max > 64 ? 64 : max));
    StringBuilder buf = new StringBuilder(text.length() + increase);
    while (end != INDEX_NOT_FOUND) {
        buf.append(text.substring(start, end)).append(replacement);
        start = end + replLength;
        if (--max == 0) {
            break;
        }
        end = text.indexOf(searchString, start);
    }
    buf.append(text.substring(start));
    return buf.toString();
}","public void test265295() throws Throwable {
    String string0 = StringUtils.replace(""classnotfo#njava.util.locale@0000000016y  backcompat code"", ""classnotfo#njava.util.locale@0000000016y  backcompat code"", ""classnotfo#njava.util.locale@0000000016y  backcompat code"", 111);
    assertNotNull(string0);
}","/**
 * <p>Replaces a String with another String inside a larger String,
 * for the first <code>max</code> values of the search String.</p>
 *
 * <p>A <code>null</code> reference passed to this method is a no-op.</p>
 *
 * <pre>
 * StringUtils.replace(null, *, *, *)         = null
 * StringUtils.replace("""", *, *, *)           = """"
 * StringUtils.replace(""any"", null, *, *)     = ""any""
 * StringUtils.replace(""any"", *, null, *)     = ""any""
 * StringUtils.replace(""any"", """", *, *)       = ""any""
 * StringUtils.replace(""any"", *, *, 0)        = ""any""
 * StringUtils.replace(""abaa"", ""a"", null, -1) = ""abaa""
 * StringUtils.replace(""abaa"", ""a"", """", -1)   = ""b""
 * StringUtils.replace(""abaa"", ""a"", ""z"", 0)   = ""abaa""
 * StringUtils.replace(""abaa"", ""a"", ""z"", 1)   = ""zbaa""
 * StringUtils.replace(""abaa"", ""a"", ""z"", 2)   = ""zbza""
 * StringUtils.replace(""abaa"", ""a"", ""z"", -1)  = ""zbzz""
 * </pre>
 *
 * @param text  text to search and replace in, may be null
 * @param searchString  the String to search for, may be null
 * @param replacement  the String to replace it with, may be null
 * @param max  maximum number of values to replace, or <code>-1</code> if no maximum
 * @return the text with any replacements processed,
 *  <code>null</code> if null String input
 */"
"public static String remove(String str, String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    return replace(str, remove, EMPTY, -1);
}","public void test266296() throws Throwable {
    String string0 = StringUtils.remove(""nd replace array lengths don't"", ""nd replace array lengths don't"");
    assertEquals("""", string0);
}","/**
 * <p>Removes all occurrences of a substring from within the source string.</p>
 *
 * <p>A <code>null</code> source string will return <code>null</code>.
 * An empty ("""") source string will return the empty string.
 * A <code>null</code> remove string will return the source string.
 * An empty ("""") remove string will return the source string.</p>
 *
 * <pre>
 * StringUtils.remove(null, *)        = null
 * StringUtils.remove("""", *)          = """"
 * StringUtils.remove(*, null)        = *
 * StringUtils.remove(*, """")          = *
 * StringUtils.remove(""queued"", ""ue"") = ""qd""
 * StringUtils.remove(""queued"", ""zz"") = ""queued""
 * </pre>
 *
 * @param str  the source String to search, may be null
 * @param remove  the String to search for and remove, may be null
 * @return the substring with the string removed if found,
 *  <code>null</code> if null String input
 * @since 2.1
 */"
"// Replacing
//-----------------------------------------------------------------------
/**
 * <p>Replaces a String with another String inside a larger String, once.</p>
 *
 * <p>A <code>null</code> reference passed to this method is a no-op.</p>
 *
 * <pre>
 * StringUtils.replaceOnce(null, *, *)        = null
 * StringUtils.replaceOnce("""", *, *)          = """"
 * StringUtils.replaceOnce(""any"", null, *)    = ""any""
 * StringUtils.replaceOnce(""any"", *, null)    = ""any""
 * StringUtils.replaceOnce(""any"", """", *)      = ""any""
 * StringUtils.replaceOnce(""aba"", ""a"", null)  = ""aba""
 * StringUtils.replaceOnce(""aba"", ""a"", """")    = ""ba""
 * StringUtils.replaceOnce(""aba"", ""a"", ""z"")   = ""zba""
 * </pre>
 *
 * @see #replace(String text, String searchString, String replacement, int max)
 * @param text  text to search and replace in, may be null
 * @param searchString  the String to search for, may be null
 * @param replacement  the String to replace with, may be null
 * @return the text with any replacements processed,
 *  <code>null</code> if null String input
 */
public static String replaceOnce(String text, String searchString, String replacement) {
    return replace(text, searchString, replacement, 1);
}","public void test267297() throws Throwable {
    String string0 = StringUtils.replaceOnce("" "", "" "", "" "");
    assertEquals("" "", string0);
}",""
"public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {
    // timeToLive should be 0 if not used or nothing to replace, else it's
    // the length of the replace array
    int timeToLive = searchList == null ? 0 : searchList.length;
    return replaceEach(text, searchList, replacementList, true, timeToLive);
}","public void test268298() throws Throwable {
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""vR "");
    // Undeclared exception!
    try {
        StringUtils.replaceEachRepeatedly(""vR "", stringArray0, stringArray0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // TimeToLive of -1 is less than 0: vR
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}","/**
 * <p>
 * Replaces all occurrences of Strings within another String.
 * </p>
 *
 * <p>
 * A <code>null</code> reference passed to this method is a no-op, or if
 * any ""search string"" or ""string to replace"" is null, that replace will be
 * ignored. This will not repeat. For repeating replaces, call the
 * overloaded method.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *, *) = null
 *  StringUtils.replaceEach("""", *, *, *) = """"
 *  StringUtils.replaceEach(""aba"", null, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[0], null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", null, new String[0], *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""}, *) = ""b""
 *  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""}, *) = ""aba""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""}, *) = ""wcte""
 *  (example of how it repeats)
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, false) = ""dcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, true) = ""tcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, true) = IllegalArgumentException
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, false) = ""dcabe""
 * </pre>
 *
 * @param text
 *            text to search and replace in, no-op if null
 * @param searchList
 *            the Strings to search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @return the text with any replacements processed, <code>null</code> if
 *         null String input
 * @throws IllegalArgumentException
 *             if the search is repeating and there is an endless loop due
 *             to outputs of one being inputs to another
 * @throws IndexOutOfBoundsException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */"
"public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {
    // timeToLive should be 0 if not used or nothing to replace, else it's
    // the length of the replace array
    int timeToLive = searchList == null ? 0 : searchList.length;
    return replaceEach(text, searchList, replacementList, true, timeToLive);
}","public void test269299() throws Throwable {
    String string0 = StringUtils.replaceEachRepeatedly(""org.apache.commons.lang3.StringUtils"", (String[]) null, (String[]) null);
    assertEquals(""org.apache.commons.lang3.StringUtils"", string0);
}","/**
 * <p>
 * Replaces all occurrences of Strings within another String.
 * </p>
 *
 * <p>
 * A <code>null</code> reference passed to this method is a no-op, or if
 * any ""search string"" or ""string to replace"" is null, that replace will be
 * ignored. This will not repeat. For repeating replaces, call the
 * overloaded method.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *, *) = null
 *  StringUtils.replaceEach("""", *, *, *) = """"
 *  StringUtils.replaceEach(""aba"", null, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[0], null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", null, new String[0], *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""}, *) = ""b""
 *  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""}, *) = ""aba""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""}, *) = ""wcte""
 *  (example of how it repeats)
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, false) = ""dcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, true) = ""tcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, true) = IllegalArgumentException
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, false) = ""dcabe""
 * </pre>
 *
 * @param text
 *            text to search and replace in, no-op if null
 * @param searchList
 *            the Strings to search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @return the text with any replacements processed, <code>null</code> if
 *         null String input
 * @throws IllegalArgumentException
 *             if the search is repeating and there is an endless loop due
 *             to outputs of one being inputs to another
 * @throws IndexOutOfBoundsException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */"
"public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {
    // timeToLive should be 0 if not used or nothing to replace, else it's
    // the length of the replace array
    int timeToLive = searchList == null ? 0 : searchList.length;
    return replaceEach(text, searchList, replacementList, true, timeToLive);
}","public void test270300() throws Throwable {
    String string0 = StringUtils.replaceEachRepeatedly((String) null, (String[]) null, (String[]) null);
    assertNull(string0);
}","/**
 * <p>
 * Replaces all occurrences of Strings within another String.
 * </p>
 *
 * <p>
 * A <code>null</code> reference passed to this method is a no-op, or if
 * any ""search string"" or ""string to replace"" is null, that replace will be
 * ignored. This will not repeat. For repeating replaces, call the
 * overloaded method.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *, *) = null
 *  StringUtils.replaceEach("""", *, *, *) = """"
 *  StringUtils.replaceEach(""aba"", null, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[0], null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", null, new String[0], *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""}, *) = ""b""
 *  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""}, *) = ""aba""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""}, *) = ""wcte""
 *  (example of how it repeats)
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, false) = ""dcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, true) = ""tcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, true) = IllegalArgumentException
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, false) = ""dcabe""
 * </pre>
 *
 * @param text
 *            text to search and replace in, no-op if null
 * @param searchList
 *            the Strings to search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @return the text with any replacements processed, <code>null</code> if
 *         null String input
 * @throws IllegalArgumentException
 *             if the search is repeating and there is an endless loop due
 *             to outputs of one being inputs to another
 * @throws IndexOutOfBoundsException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */"
"public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {
    // timeToLive should be 0 if not used or nothing to replace, else it's
    // the length of the replace array
    int timeToLive = searchList == null ? 0 : searchList.length;
    return replaceEach(text, searchList, replacementList, true, timeToLive);
}","public void test271301() throws Throwable {
    String[] stringArray0 = new String[1];
    String string0 = StringUtils.replaceEachRepeatedly("""", stringArray0, stringArray0);
    assertEquals("""", string0);
}","/**
 * <p>
 * Replaces all occurrences of Strings within another String.
 * </p>
 *
 * <p>
 * A <code>null</code> reference passed to this method is a no-op, or if
 * any ""search string"" or ""string to replace"" is null, that replace will be
 * ignored. This will not repeat. For repeating replaces, call the
 * overloaded method.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *, *) = null
 *  StringUtils.replaceEach("""", *, *, *) = """"
 *  StringUtils.replaceEach(""aba"", null, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[0], null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", null, new String[0], *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""}, *) = ""b""
 *  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""}, *) = ""aba""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""}, *) = ""wcte""
 *  (example of how it repeats)
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, false) = ""dcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, true) = ""tcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, true) = IllegalArgumentException
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, false) = ""dcabe""
 * </pre>
 *
 * @param text
 *            text to search and replace in, no-op if null
 * @param searchList
 *            the Strings to search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @return the text with any replacements processed, <code>null</code> if
 *         null String input
 * @throws IllegalArgumentException
 *             if the search is repeating and there is an endless loop due
 *             to outputs of one being inputs to another
 * @throws IndexOutOfBoundsException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */"
"public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {
    // timeToLive should be 0 if not used or nothing to replace, else it's
    // the length of the replace array
    int timeToLive = searchList == null ? 0 : searchList.length;
    return replaceEach(text, searchList, replacementList, true, timeToLive);
}","public void test272302() throws Throwable {
    String[] stringArray0 = new String[0];
    String string0 = StringUtils.replaceEachRepeatedly(""I"", stringArray0, stringArray0);
    assertEquals(""I"", string0);
}","/**
 * <p>
 * Replaces all occurrences of Strings within another String.
 * </p>
 *
 * <p>
 * A <code>null</code> reference passed to this method is a no-op, or if
 * any ""search string"" or ""string to replace"" is null, that replace will be
 * ignored. This will not repeat. For repeating replaces, call the
 * overloaded method.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *, *) = null
 *  StringUtils.replaceEach("""", *, *, *) = """"
 *  StringUtils.replaceEach(""aba"", null, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[0], null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", null, new String[0], *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""}, *) = ""b""
 *  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""}, *) = ""aba""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""}, *) = ""wcte""
 *  (example of how it repeats)
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, false) = ""dcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, true) = ""tcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, true) = IllegalArgumentException
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, false) = ""dcabe""
 * </pre>
 *
 * @param text
 *            text to search and replace in, no-op if null
 * @param searchList
 *            the Strings to search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @return the text with any replacements processed, <code>null</code> if
 *         null String input
 * @throws IllegalArgumentException
 *             if the search is repeating and there is an endless loop due
 *             to outputs of one being inputs to another
 * @throws IndexOutOfBoundsException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */"
"public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {
    // timeToLive should be 0 if not used or nothing to replace, else it's
    // the length of the replace array
    int timeToLive = searchList == null ? 0 : searchList.length;
    return replaceEach(text, searchList, replacementList, true, timeToLive);
}","public void test273303() throws Throwable {
    String[] stringArray0 = new String[10];
    String[] stringArray1 = new String[0];
    String string0 = StringUtils.replaceEachRepeatedly(""aROA"", stringArray0, stringArray1);
    assertEquals(""aROA"", string0);
}","/**
 * <p>
 * Replaces all occurrences of Strings within another String.
 * </p>
 *
 * <p>
 * A <code>null</code> reference passed to this method is a no-op, or if
 * any ""search string"" or ""string to replace"" is null, that replace will be
 * ignored. This will not repeat. For repeating replaces, call the
 * overloaded method.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *, *) = null
 *  StringUtils.replaceEach("""", *, *, *) = """"
 *  StringUtils.replaceEach(""aba"", null, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[0], null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", null, new String[0], *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""}, *) = ""b""
 *  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""}, *) = ""aba""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""}, *) = ""wcte""
 *  (example of how it repeats)
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, false) = ""dcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, true) = ""tcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, true) = IllegalArgumentException
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, false) = ""dcabe""
 * </pre>
 *
 * @param text
 *            text to search and replace in, no-op if null
 * @param searchList
 *            the Strings to search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @return the text with any replacements processed, <code>null</code> if
 *         null String input
 * @throws IllegalArgumentException
 *             if the search is repeating and there is an endless loop due
 *             to outputs of one being inputs to another
 * @throws IndexOutOfBoundsException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */"
"public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {
    // timeToLive should be 0 if not used or nothing to replace, else it's
    // the length of the replace array
    int timeToLive = searchList == null ? 0 : searchList.length;
    return replaceEach(text, searchList, replacementList, true, timeToLive);
}","public void test274304() throws Throwable {
    String[] stringArray0 = StringUtils.splitByCharacterTypeCamelCase(""vs "");
    String[] stringArray1 = new String[1];
    // Undeclared exception!
    try {
        StringUtils.replaceEachRepeatedly(""vs "", stringArray0, stringArray1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Search and Replace array lengths don't match: 2 vs 1
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}","/**
 * <p>
 * Replaces all occurrences of Strings within another String.
 * </p>
 *
 * <p>
 * A <code>null</code> reference passed to this method is a no-op, or if
 * any ""search string"" or ""string to replace"" is null, that replace will be
 * ignored. This will not repeat. For repeating replaces, call the
 * overloaded method.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *, *) = null
 *  StringUtils.replaceEach("""", *, *, *) = """"
 *  StringUtils.replaceEach(""aba"", null, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[0], null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", null, new String[0], *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""}, *) = ""b""
 *  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""}, *) = ""aba""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""}, *) = ""wcte""
 *  (example of how it repeats)
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, false) = ""dcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, true) = ""tcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, true) = IllegalArgumentException
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, false) = ""dcabe""
 * </pre>
 *
 * @param text
 *            text to search and replace in, no-op if null
 * @param searchList
 *            the Strings to search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @return the text with any replacements processed, <code>null</code> if
 *         null String input
 * @throws IllegalArgumentException
 *             if the search is repeating and there is an endless loop due
 *             to outputs of one being inputs to another
 * @throws IndexOutOfBoundsException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */"
"public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {
    // timeToLive should be 0 if not used or nothing to replace, else it's
    // the length of the replace array
    int timeToLive = searchList == null ? 0 : searchList.length;
    return replaceEach(text, searchList, replacementList, true, timeToLive);
}","public void test275305() throws Throwable {
    String[] stringArray0 = StringUtils.splitByCharacterTypeCamelCase(""-"");
    String[] stringArray1 = new String[1];
    String string0 = StringUtils.replaceEachRepeatedly(""-"", stringArray0, stringArray1);
    assertEquals(""-"", string0);
}","/**
 * <p>
 * Replaces all occurrences of Strings within another String.
 * </p>
 *
 * <p>
 * A <code>null</code> reference passed to this method is a no-op, or if
 * any ""search string"" or ""string to replace"" is null, that replace will be
 * ignored. This will not repeat. For repeating replaces, call the
 * overloaded method.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *, *) = null
 *  StringUtils.replaceEach("""", *, *, *) = """"
 *  StringUtils.replaceEach(""aba"", null, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[0], null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", null, new String[0], *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""}, *) = ""b""
 *  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""}, *) = ""aba""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""}, *) = ""wcte""
 *  (example of how it repeats)
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, false) = ""dcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, true) = ""tcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, true) = IllegalArgumentException
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, false) = ""dcabe""
 * </pre>
 *
 * @param text
 *            text to search and replace in, no-op if null
 * @param searchList
 *            the Strings to search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @return the text with any replacements processed, <code>null</code> if
 *         null String input
 * @throws IllegalArgumentException
 *             if the search is repeating and there is an endless loop due
 *             to outputs of one being inputs to another
 * @throws IndexOutOfBoundsException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */"
"public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {
    // timeToLive should be 0 if not used or nothing to replace, else it's
    // the length of the replace array
    int timeToLive = searchList == null ? 0 : searchList.length;
    return replaceEach(text, searchList, replacementList, true, timeToLive);
}","public void test276307() throws Throwable {
    String[] stringArray0 = new String[2];
    stringArray0[0] = ""2"";
    String[] stringArray1 = new String[2];
    stringArray1[0] = ""\u0000\u0001\u0002j#:'h\u0004\u0005\u0006\u0007u\b\n\u0000\u0001\u0002j#:'h\u0004\u0005 vs "";
    String string0 = StringUtils.replaceEachRepeatedly(""2"", stringArray0, stringArray1);
    assertEquals(""\u0000\u0001\u0002j#:'h\u0004\u0005\u0006\u0007u\b\n\u0000\u0001\u0002j#:'h\u0004\u0005 vs "", string0);
}","/**
 * <p>
 * Replaces all occurrences of Strings within another String.
 * </p>
 *
 * <p>
 * A <code>null</code> reference passed to this method is a no-op, or if
 * any ""search string"" or ""string to replace"" is null, that replace will be
 * ignored. This will not repeat. For repeating replaces, call the
 * overloaded method.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *, *) = null
 *  StringUtils.replaceEach("""", *, *, *) = """"
 *  StringUtils.replaceEach(""aba"", null, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[0], null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", null, new String[0], *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""}, *) = ""b""
 *  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""}, *) = ""aba""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""}, *) = ""wcte""
 *  (example of how it repeats)
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, false) = ""dcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, true) = ""tcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, true) = IllegalArgumentException
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, false) = ""dcabe""
 * </pre>
 *
 * @param text
 *            text to search and replace in, no-op if null
 * @param searchList
 *            the Strings to search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @return the text with any replacements processed, <code>null</code> if
 *         null String input
 * @throws IllegalArgumentException
 *             if the search is repeating and there is an endless loop due
 *             to outputs of one being inputs to another
 * @throws IndexOutOfBoundsException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */"
"public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {
    // timeToLive should be 0 if not used or nothing to replace, else it's
    // the length of the replace array
    int timeToLive = searchList == null ? 0 : searchList.length;
    return replaceEach(text, searchList, replacementList, true, timeToLive);
}","public void test277308() throws Throwable {
    String[] stringArray0 = Locale.getISOLanguages();
    // Undeclared exception!
    StringUtils.replaceEachRepeatedly(""os.name"", stringArray0, stringArray0);
}","/**
 * <p>
 * Replaces all occurrences of Strings within another String.
 * </p>
 *
 * <p>
 * A <code>null</code> reference passed to this method is a no-op, or if
 * any ""search string"" or ""string to replace"" is null, that replace will be
 * ignored. This will not repeat. For repeating replaces, call the
 * overloaded method.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *, *) = null
 *  StringUtils.replaceEach("""", *, *, *) = """"
 *  StringUtils.replaceEach(""aba"", null, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[0], null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", null, new String[0], *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""}, *) = ""b""
 *  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""}, *) = ""aba""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""}, *) = ""wcte""
 *  (example of how it repeats)
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, false) = ""dcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, true) = ""tcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, true) = IllegalArgumentException
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, false) = ""dcabe""
 * </pre>
 *
 * @param text
 *            text to search and replace in, no-op if null
 * @param searchList
 *            the Strings to search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @return the text with any replacements processed, <code>null</code> if
 *         null String input
 * @throws IllegalArgumentException
 *             if the search is repeating and there is an endless loop due
 *             to outputs of one being inputs to another
 * @throws IndexOutOfBoundsException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */"
"public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {
    // timeToLive should be 0 if not used or nothing to replace, else it's
    // the length of the replace array
    int timeToLive = searchList == null ? 0 : searchList.length;
    return replaceEach(text, searchList, replacementList, true, timeToLive);
}","public void test278309() throws Throwable {
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""RD("";
    stringArray0[2] = ""r"";
    String[] stringArray1 = new String[3];
    stringArray1[2] = ""r"";
    // Undeclared exception!
    try {
        StringUtils.replaceEachRepeatedly(""r"", stringArray0, stringArray1);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // TimeToLive of -1 is less than 0: r
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}","/**
 * <p>
 * Replaces all occurrences of Strings within another String.
 * </p>
 *
 * <p>
 * A <code>null</code> reference passed to this method is a no-op, or if
 * any ""search string"" or ""string to replace"" is null, that replace will be
 * ignored. This will not repeat. For repeating replaces, call the
 * overloaded method.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *, *) = null
 *  StringUtils.replaceEach("""", *, *, *) = """"
 *  StringUtils.replaceEach(""aba"", null, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[0], null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", null, new String[0], *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""}, *) = ""b""
 *  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""}, *) = ""aba""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""}, *) = ""wcte""
 *  (example of how it repeats)
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, false) = ""dcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, true) = ""tcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, true) = IllegalArgumentException
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, false) = ""dcabe""
 * </pre>
 *
 * @param text
 *            text to search and replace in, no-op if null
 * @param searchList
 *            the Strings to search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @return the text with any replacements processed, <code>null</code> if
 *         null String input
 * @throws IllegalArgumentException
 *             if the search is repeating and there is an endless loop due
 *             to outputs of one being inputs to another
 * @throws IndexOutOfBoundsException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */"
"public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {
    // timeToLive should be 0 if not used or nothing to replace, else it's
    // the length of the replace array
    int timeToLive = searchList == null ? 0 : searchList.length;
    return replaceEach(text, searchList, replacementList, true, timeToLive);
}","public void test279310() throws Throwable {
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""illegalaccessexception occurred during 1.6 bhyurl*irbn5ode"");
    // Undeclared exception!
    try {
        StringUtils.replaceEachRepeatedly(""illegalaccessexception occurred during 1.6 bhyurl*irbn5ode"", stringArray0, stringArray0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // TimeToLive of -1 is less than 0: illegalaccessexception occurred during 1.6 bhyurl*irbn5ode
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}","/**
 * <p>
 * Replaces all occurrences of Strings within another String.
 * </p>
 *
 * <p>
 * A <code>null</code> reference passed to this method is a no-op, or if
 * any ""search string"" or ""string to replace"" is null, that replace will be
 * ignored. This will not repeat. For repeating replaces, call the
 * overloaded method.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *, *) = null
 *  StringUtils.replaceEach("""", *, *, *) = """"
 *  StringUtils.replaceEach(""aba"", null, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[0], null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", null, new String[0], *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, null, *) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""}, *) = ""b""
 *  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""}, *) = ""aba""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""}, *) = ""wcte""
 *  (example of how it repeats)
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, false) = ""dcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, true) = ""tcte""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, true) = IllegalArgumentException
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, false) = ""dcabe""
 * </pre>
 *
 * @param text
 *            text to search and replace in, no-op if null
 * @param searchList
 *            the Strings to search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @return the text with any replacements processed, <code>null</code> if
 *         null String input
 * @throws IllegalArgumentException
 *             if the search is repeating and there is an endless loop due
 *             to outputs of one being inputs to another
 * @throws IndexOutOfBoundsException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */"
"public static String replaceEach(String text, String[] searchList, String[] replacementList) {
    return replaceEach(text, searchList, replacementList, false, 0);
}","public void test280311() throws Throwable {
    String[] stringArray0 = new String[5];
    stringArray0[2] = "":EBv9<Vpi#}"";
    String string0 = StringUtils.replaceEach("":EBv9<Vpi#}"", stringArray0, stringArray0);
    assertEquals("":EBv9<Vpi#}"", string0);
}","/**
 * <p>
 * Replaces all occurrences of Strings within another String.
 * </p>
 *
 * <p>
 * A <code>null</code> reference passed to this method is a no-op, or if
 * any ""search string"" or ""string to replace"" is null, that replace will be
 * ignored. This will not repeat. For repeating replaces, call the
 * overloaded method.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *)        = null
 *  StringUtils.replaceEach("""", *, *)          = """"
 *  StringUtils.replaceEach(""aba"", null, null) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[0], null) = ""aba""
 *  StringUtils.replaceEach(""aba"", null, new String[0]) = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, null)  = ""aba""
 *  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""})  = ""b""
 *  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""})  = ""aba""
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""})  = ""wcte""
 *  (example of how it does not repeat)
 *  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""})  = ""dcte""
 * </pre>
 *
 * @param text
 *            text to search and replace in, no-op if null
 * @param searchList
 *            the Strings to search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @return the text with any replacements processed, <code>null</code> if
 *         null String input
 * @throws IndexOutOfBoundsException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */"
"// Replace, character based
//-----------------------------------------------------------------------
/**
 * <p>Replaces all occurrences of a character in a String with another.
 * This is a null-safe version of {@link String#replace(char, char)}.</p>
 *
 * <p>A <code>null</code> string input returns <code>null</code>.
 * An empty ("""") string input returns an empty string.</p>
 *
 * <pre>
 * StringUtils.replaceChars(null, *, *)        = null
 * StringUtils.replaceChars("""", *, *)          = """"
 * StringUtils.replaceChars(""abcba"", 'b', 'y') = ""aycya""
 * StringUtils.replaceChars(""abcba"", 'z', 'y') = ""abcba""
 * </pre>
 *
 * @param str  String to replace characters in, may be null
 * @param searchChar  the character to search for, may be null
 * @param replaceChar  the character to replace, may be null
 * @return modified String, <code>null</code> if null string input
 * @since 2.0
 */
public static String replaceChars(String str, char searchChar, char replaceChar) {
    if (str == null) {
        return null;
    }
    return str.replace(searchChar, replaceChar);
}","public void test281312() throws Throwable {
    String string0 = StringUtils.replaceChars(""qzu"", '+', '+');
    assertNotNull(string0);
}",""
"// Replace, character based
//-----------------------------------------------------------------------
/**
 * <p>Replaces all occurrences of a character in a String with another.
 * This is a null-safe version of {@link String#replace(char, char)}.</p>
 *
 * <p>A <code>null</code> string input returns <code>null</code>.
 * An empty ("""") string input returns an empty string.</p>
 *
 * <pre>
 * StringUtils.replaceChars(null, *, *)        = null
 * StringUtils.replaceChars("""", *, *)          = """"
 * StringUtils.replaceChars(""abcba"", 'b', 'y') = ""aycya""
 * StringUtils.replaceChars(""abcba"", 'z', 'y') = ""abcba""
 * </pre>
 *
 * @param str  String to replace characters in, may be null
 * @param searchChar  the character to search for, may be null
 * @param replaceChar  the character to replace, may be null
 * @return modified String, <code>null</code> if null string input
 * @since 2.0
 */
public static String replaceChars(String str, char searchChar, char replaceChar) {
    if (str == null) {
        return null;
    }
    return str.replace(searchChar, replaceChar);
}","public void test282314() throws Throwable {
    String string0 = StringUtils.replaceChars((String) null, '9', '9');
    assertNull(string0);
}",""
"public static String replaceChars(String str, String searchChars, String replaceChars) {
    if (isEmpty(str) || isEmpty(searchChars)) {
        return str;
    }
    if (replaceChars == null) {
        replaceChars = EMPTY;
    }
    boolean modified = false;
    int replaceCharsLength = replaceChars.length();
    int strLength = str.length();
    StringBuilder buf = new StringBuilder(strLength);
    for (int i = 0; i < strLength; i++) {
        char ch = str.charAt(i);
        int index = searchChars.indexOf(ch);
        if (index >= 0) {
            modified = true;
            if (index < replaceCharsLength) {
                buf.append(replaceChars.charAt(index));
            }
        } else {
            buf.append(ch);
        }
    }
    if (modified) {
        return buf.toString();
    }
    return str;
}","public void test283315() throws Throwable {
    String string0 = StringUtils.replaceChars((String) null, (String) null, (String) null);
    assertNull(string0);
}","/**
 * <p>Replaces multiple characters in a String in one go.
 * This method can also be used to delete characters.</p>
 *
 * <p>For example:<br />
 * <code>replaceChars(&quot;hello&quot;, &quot;ho&quot;, &quot;jy&quot;) = jelly</code>.</p>
 *
 * <p>A <code>null</code> string input returns <code>null</code>.
 * An empty ("""") string input returns an empty string.
 * A null or empty set of search characters returns the input string.</p>
 *
 * <p>The length of the search characters should normally equal the length
 * of the replace characters.
 * If the search characters is longer, then the extra search characters
 * are deleted.
 * If the search characters is shorter, then the extra replace characters
 * are ignored.</p>
 *
 * <pre>
 * StringUtils.replaceChars(null, *, *)           = null
 * StringUtils.replaceChars("""", *, *)             = """"
 * StringUtils.replaceChars(""abc"", null, *)       = ""abc""
 * StringUtils.replaceChars(""abc"", """", *)         = ""abc""
 * StringUtils.replaceChars(""abc"", ""b"", null)     = ""ac""
 * StringUtils.replaceChars(""abc"", ""b"", """")       = ""ac""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""yz"")  = ""ayzya""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""y"")   = ""ayya""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""yzx"") = ""ayzya""
 * </pre>
 *
 * @param str  String to replace characters in, may be null
 * @param searchChars  a set of characters to search for, may be null
 * @param replaceChars  a set of characters to replace, may be null
 * @return modified String, <code>null</code> if null string input
 * @since 2.0
 */"
"public static String replaceChars(String str, String searchChars, String replaceChars) {
    if (isEmpty(str) || isEmpty(searchChars)) {
        return str;
    }
    if (replaceChars == null) {
        replaceChars = EMPTY;
    }
    boolean modified = false;
    int replaceCharsLength = replaceChars.length();
    int strLength = str.length();
    StringBuilder buf = new StringBuilder(strLength);
    for (int i = 0; i < strLength; i++) {
        char ch = str.charAt(i);
        int index = searchChars.indexOf(ch);
        if (index >= 0) {
            modified = true;
            if (index < replaceCharsLength) {
                buf.append(replaceChars.charAt(index));
            }
        } else {
            buf.append(ch);
        }
    }
    if (modified) {
        return buf.toString();
    }
    return str;
}","public void test284316() throws Throwable {
    String string0 = StringUtils.replaceChars(""NeZ+9M"", ""NeZ+9M"", ""NeZ+9M"");
    assertEquals(""NeZ+9M"", string0);
}","/**
 * <p>Replaces multiple characters in a String in one go.
 * This method can also be used to delete characters.</p>
 *
 * <p>For example:<br />
 * <code>replaceChars(&quot;hello&quot;, &quot;ho&quot;, &quot;jy&quot;) = jelly</code>.</p>
 *
 * <p>A <code>null</code> string input returns <code>null</code>.
 * An empty ("""") string input returns an empty string.
 * A null or empty set of search characters returns the input string.</p>
 *
 * <p>The length of the search characters should normally equal the length
 * of the replace characters.
 * If the search characters is longer, then the extra search characters
 * are deleted.
 * If the search characters is shorter, then the extra replace characters
 * are ignored.</p>
 *
 * <pre>
 * StringUtils.replaceChars(null, *, *)           = null
 * StringUtils.replaceChars("""", *, *)             = """"
 * StringUtils.replaceChars(""abc"", null, *)       = ""abc""
 * StringUtils.replaceChars(""abc"", """", *)         = ""abc""
 * StringUtils.replaceChars(""abc"", ""b"", null)     = ""ac""
 * StringUtils.replaceChars(""abc"", ""b"", """")       = ""ac""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""yz"")  = ""ayzya""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""y"")   = ""ayya""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""yzx"") = ""ayzya""
 * </pre>
 *
 * @param str  String to replace characters in, may be null
 * @param searchChars  a set of characters to search for, may be null
 * @param replaceChars  a set of characters to replace, may be null
 * @return modified String, <code>null</code> if null string input
 * @since 2.0
 */"
"public static String replaceChars(String str, String searchChars, String replaceChars) {
    if (isEmpty(str) || isEmpty(searchChars)) {
        return str;
    }
    if (replaceChars == null) {
        replaceChars = EMPTY;
    }
    boolean modified = false;
    int replaceCharsLength = replaceChars.length();
    int strLength = str.length();
    StringBuilder buf = new StringBuilder(strLength);
    for (int i = 0; i < strLength; i++) {
        char ch = str.charAt(i);
        int index = searchChars.indexOf(ch);
        if (index >= 0) {
            modified = true;
            if (index < replaceCharsLength) {
                buf.append(replaceChars.charAt(index));
            }
        } else {
            buf.append(ch);
        }
    }
    if (modified) {
        return buf.toString();
    }
    return str;
}","public void test285317() throws Throwable {
    String string0 = StringUtils.replaceChars(""nd replace array lengths don't"", (String) null, ""illegalaccessexception occurred during ]9;w2a8b\""mv}!t code_o~ihv Bn r $C2Aillegalaccessexception occurred during ]9;w2a8b\""mv}!t code_o~ihv Bn r $C2Aillegalaccessexception occurred during ]9;w2a8b\""mv}!t code_o~ihv Bn r $C2Aillegalaccessexception occurred during ]9;w2a8b\""mv}!t code_o~ihv Bn r $C2Aillegalaccessexception occurred during ]9;w2a8b\""mv}!t code_o~ihv Bn r $C2Aillegalaccessexception occurred during ]9;w2a8b\""mv}!t code_o~ihv Bn r $C2Aillegalaccessexception occurred during ]9;w2a8b\""mv}!t code_o~ihv Bn r $C2Aillegalaccessexception occurred during ]9;w2a8b\""mv}!t code_o~ihv Bn r $C2Aillegalaccessexception occurred during ]9;w2a8b\""mv}!t code_o~ihv Bn r $C2Aillegalaccessexception occurred during ]9;w2a8b\""mv}!t code_o~ihv Bn r $C2Aillegalaccessexception occurred during ]9;w2a8b\""mv}!t code_o~ihv Bn r $C2Aillegalaccessexception occurred during ]9;w2a8b\""mv}!t code_o~ihv Bn r $C2Aillegalaccessexception occurred during ]9;w2a8b\""mv}!t code_o~ihv Bn r $C2A_o~ihv Bn r $C2A"");
    assertEquals(""nd replace array lengths don't"", string0);
}","/**
 * <p>Replaces multiple characters in a String in one go.
 * This method can also be used to delete characters.</p>
 *
 * <p>For example:<br />
 * <code>replaceChars(&quot;hello&quot;, &quot;ho&quot;, &quot;jy&quot;) = jelly</code>.</p>
 *
 * <p>A <code>null</code> string input returns <code>null</code>.
 * An empty ("""") string input returns an empty string.
 * A null or empty set of search characters returns the input string.</p>
 *
 * <p>The length of the search characters should normally equal the length
 * of the replace characters.
 * If the search characters is longer, then the extra search characters
 * are deleted.
 * If the search characters is shorter, then the extra replace characters
 * are ignored.</p>
 *
 * <pre>
 * StringUtils.replaceChars(null, *, *)           = null
 * StringUtils.replaceChars("""", *, *)             = """"
 * StringUtils.replaceChars(""abc"", null, *)       = ""abc""
 * StringUtils.replaceChars(""abc"", """", *)         = ""abc""
 * StringUtils.replaceChars(""abc"", ""b"", null)     = ""ac""
 * StringUtils.replaceChars(""abc"", ""b"", """")       = ""ac""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""yz"")  = ""ayzya""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""y"")   = ""ayya""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""yzx"") = ""ayzya""
 * </pre>
 *
 * @param str  String to replace characters in, may be null
 * @param searchChars  a set of characters to search for, may be null
 * @param replaceChars  a set of characters to replace, may be null
 * @return modified String, <code>null</code> if null string input
 * @since 2.0
 */"
"public static String replaceChars(String str, String searchChars, String replaceChars) {
    if (isEmpty(str) || isEmpty(searchChars)) {
        return str;
    }
    if (replaceChars == null) {
        replaceChars = EMPTY;
    }
    boolean modified = false;
    int replaceCharsLength = replaceChars.length();
    int strLength = str.length();
    StringBuilder buf = new StringBuilder(strLength);
    for (int i = 0; i < strLength; i++) {
        char ch = str.charAt(i);
        int index = searchChars.indexOf(ch);
        if (index >= 0) {
            modified = true;
            if (index < replaceCharsLength) {
                buf.append(replaceChars.charAt(index));
            }
        } else {
            buf.append(ch);
        }
    }
    if (modified) {
        return buf.toString();
    }
    return str;
}","public void test286319() throws Throwable {
    String string0 = StringUtils.replaceChars(""~'O(Tj="", ""~'O(Tj="", (String) null);
    assertEquals("""", string0);
}","/**
 * <p>Replaces multiple characters in a String in one go.
 * This method can also be used to delete characters.</p>
 *
 * <p>For example:<br />
 * <code>replaceChars(&quot;hello&quot;, &quot;ho&quot;, &quot;jy&quot;) = jelly</code>.</p>
 *
 * <p>A <code>null</code> string input returns <code>null</code>.
 * An empty ("""") string input returns an empty string.
 * A null or empty set of search characters returns the input string.</p>
 *
 * <p>The length of the search characters should normally equal the length
 * of the replace characters.
 * If the search characters is longer, then the extra search characters
 * are deleted.
 * If the search characters is shorter, then the extra replace characters
 * are ignored.</p>
 *
 * <pre>
 * StringUtils.replaceChars(null, *, *)           = null
 * StringUtils.replaceChars("""", *, *)             = """"
 * StringUtils.replaceChars(""abc"", null, *)       = ""abc""
 * StringUtils.replaceChars(""abc"", """", *)         = ""abc""
 * StringUtils.replaceChars(""abc"", ""b"", null)     = ""ac""
 * StringUtils.replaceChars(""abc"", ""b"", """")       = ""ac""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""yz"")  = ""ayzya""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""y"")   = ""ayya""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""yzx"") = ""ayzya""
 * </pre>
 *
 * @param str  String to replace characters in, may be null
 * @param searchChars  a set of characters to search for, may be null
 * @param replaceChars  a set of characters to replace, may be null
 * @return modified String, <code>null</code> if null string input
 * @since 2.0
 */"
"public static String replaceChars(String str, String searchChars, String replaceChars) {
    if (isEmpty(str) || isEmpty(searchChars)) {
        return str;
    }
    if (replaceChars == null) {
        replaceChars = EMPTY;
    }
    boolean modified = false;
    int replaceCharsLength = replaceChars.length();
    int strLength = str.length();
    StringBuilder buf = new StringBuilder(strLength);
    for (int i = 0; i < strLength; i++) {
        char ch = str.charAt(i);
        int index = searchChars.indexOf(ch);
        if (index >= 0) {
            modified = true;
            if (index < replaceCharsLength) {
                buf.append(replaceChars.charAt(index));
            }
        } else {
            buf.append(ch);
        }
    }
    if (modified) {
        return buf.toString();
    }
    return str;
}","public void test287320() throws Throwable {
    String string0 = StringUtils.replaceChars(""TNp~&**H<A"", ""Index: "", ""Index: "");
    assertEquals(""TNp~&**H<A"", string0);
}","/**
 * <p>Replaces multiple characters in a String in one go.
 * This method can also be used to delete characters.</p>
 *
 * <p>For example:<br />
 * <code>replaceChars(&quot;hello&quot;, &quot;ho&quot;, &quot;jy&quot;) = jelly</code>.</p>
 *
 * <p>A <code>null</code> string input returns <code>null</code>.
 * An empty ("""") string input returns an empty string.
 * A null or empty set of search characters returns the input string.</p>
 *
 * <p>The length of the search characters should normally equal the length
 * of the replace characters.
 * If the search characters is longer, then the extra search characters
 * are deleted.
 * If the search characters is shorter, then the extra replace characters
 * are ignored.</p>
 *
 * <pre>
 * StringUtils.replaceChars(null, *, *)           = null
 * StringUtils.replaceChars("""", *, *)             = """"
 * StringUtils.replaceChars(""abc"", null, *)       = ""abc""
 * StringUtils.replaceChars(""abc"", """", *)         = ""abc""
 * StringUtils.replaceChars(""abc"", ""b"", null)     = ""ac""
 * StringUtils.replaceChars(""abc"", ""b"", """")       = ""ac""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""yz"")  = ""ayzya""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""y"")   = ""ayya""
 * StringUtils.replaceChars(""abcba"", ""bc"", ""yzx"") = ""ayzya""
 * </pre>
 *
 * @param str  String to replace characters in, may be null
 * @param searchChars  a set of characters to search for, may be null
 * @param replaceChars  a set of characters to replace, may be null
 * @return modified String, <code>null</code> if null string input
 * @since 2.0
 */"
"// Overlay
//-----------------------------------------------------------------------
/**
 * <p>Overlays part of a String with another String.</p>
 *
 * <p>A <code>null</code> string input returns <code>null</code>.
 * A negative index is treated as zero.
 * An index greater than the string length is treated as the string length.
 * The start index is always the smaller of the two indices.</p>
 *
 * <pre>
 * StringUtils.overlay(null, *, *, *)            = null
 * StringUtils.overlay("""", ""abc"", 0, 0)          = ""abc""
 * StringUtils.overlay(""abcdef"", null, 2, 4)     = ""abef""
 * StringUtils.overlay(""abcdef"", """", 2, 4)       = ""abef""
 * StringUtils.overlay(""abcdef"", """", 4, 2)       = ""abef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 2, 4)   = ""abzzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 4, 2)   = ""abzzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", -1, 4)  = ""zzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 2, 8)   = ""abzzzz""
 * StringUtils.overlay(""abcdef"", ""zzzz"", -2, -3) = ""zzzzabcdef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 8, 10)  = ""abcdefzzzz""
 * </pre>
 *
 * @param str  the String to do overlaying in, may be null
 * @param overlay  the String to overlay, may be null
 * @param start  the position to start overlaying at
 * @param end  the position to stop overlaying before
 * @return overlayed String, <code>null</code> if null String input
 * @since 2.0
 */
public static String overlay(String str, String overlay, int start, int end) {
    if (str == null) {
        return null;
    }
    if (overlay == null) {
        overlay = EMPTY;
    }
    int len = str.length();
    if (start < 0) {
        start = 0;
    }
    if (start > len) {
        start = len;
    }
    if (end < 0) {
        end = 0;
    }
    if (end > len) {
        end = len;
    }
    if (start > end) {
        int temp = start;
        start = end;
        end = temp;
    }
    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();
}","public void test288321() throws Throwable {
    String string0 = StringUtils.overlay((String) null, ""Ti$eToLive of "", (-21), (-21));
    assertNull(string0);
}",""
"// Overlay
//-----------------------------------------------------------------------
/**
 * <p>Overlays part of a String with another String.</p>
 *
 * <p>A <code>null</code> string input returns <code>null</code>.
 * A negative index is treated as zero.
 * An index greater than the string length is treated as the string length.
 * The start index is always the smaller of the two indices.</p>
 *
 * <pre>
 * StringUtils.overlay(null, *, *, *)            = null
 * StringUtils.overlay("""", ""abc"", 0, 0)          = ""abc""
 * StringUtils.overlay(""abcdef"", null, 2, 4)     = ""abef""
 * StringUtils.overlay(""abcdef"", """", 2, 4)       = ""abef""
 * StringUtils.overlay(""abcdef"", """", 4, 2)       = ""abef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 2, 4)   = ""abzzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 4, 2)   = ""abzzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", -1, 4)  = ""zzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 2, 8)   = ""abzzzz""
 * StringUtils.overlay(""abcdef"", ""zzzz"", -2, -3) = ""zzzzabcdef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 8, 10)  = ""abcdefzzzz""
 * </pre>
 *
 * @param str  the String to do overlaying in, may be null
 * @param overlay  the String to overlay, may be null
 * @param start  the position to start overlaying at
 * @param end  the position to stop overlaying before
 * @return overlayed String, <code>null</code> if null String input
 * @since 2.0
 */
public static String overlay(String str, String overlay, int start, int end) {
    if (str == null) {
        return null;
    }
    if (overlay == null) {
        overlay = EMPTY;
    }
    int len = str.length();
    if (start < 0) {
        start = 0;
    }
    if (start > len) {
        start = len;
    }
    if (end < 0) {
        end = 0;
    }
    if (end > len) {
        end = len;
    }
    if (start > end) {
        int temp = start;
        start = end;
        end = temp;
    }
    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();
}","public void test289322() throws Throwable {
    String string0 = StringUtils.overlay(""|42RaG#;"", (String) null, 6, (-2070));
    assertEquals(""#;"", string0);
}",""
"// Overlay
//-----------------------------------------------------------------------
/**
 * <p>Overlays part of a String with another String.</p>
 *
 * <p>A <code>null</code> string input returns <code>null</code>.
 * A negative index is treated as zero.
 * An index greater than the string length is treated as the string length.
 * The start index is always the smaller of the two indices.</p>
 *
 * <pre>
 * StringUtils.overlay(null, *, *, *)            = null
 * StringUtils.overlay("""", ""abc"", 0, 0)          = ""abc""
 * StringUtils.overlay(""abcdef"", null, 2, 4)     = ""abef""
 * StringUtils.overlay(""abcdef"", """", 2, 4)       = ""abef""
 * StringUtils.overlay(""abcdef"", """", 4, 2)       = ""abef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 2, 4)   = ""abzzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 4, 2)   = ""abzzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", -1, 4)  = ""zzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 2, 8)   = ""abzzzz""
 * StringUtils.overlay(""abcdef"", ""zzzz"", -2, -3) = ""zzzzabcdef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 8, 10)  = ""abcdefzzzz""
 * </pre>
 *
 * @param str  the String to do overlaying in, may be null
 * @param overlay  the String to overlay, may be null
 * @param start  the position to start overlaying at
 * @param end  the position to stop overlaying before
 * @return overlayed String, <code>null</code> if null String input
 * @since 2.0
 */
public static String overlay(String str, String overlay, int start, int end) {
    if (str == null) {
        return null;
    }
    if (overlay == null) {
        overlay = EMPTY;
    }
    int len = str.length();
    if (start < 0) {
        start = 0;
    }
    if (start > len) {
        start = len;
    }
    if (end < 0) {
        end = 0;
    }
    if (end > len) {
        end = len;
    }
    if (start > end) {
        int temp = start;
        start = end;
        end = temp;
    }
    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();
}","public void test290323() throws Throwable {
    String string0 = StringUtils.overlay(""classnotfo#ndexception occurredx|:u3{` 6y  backcompat code"", ""classnotfo#ndexception occurredx|:u3{` 6y  backcompat code"", (-873), (-873));
    assertEquals(""classnotfo#ndexception occurredx|:u3{` 6y  backcompat codeclassnotfo#ndexception occurredx|:u3{` 6y  backcompat code"", string0);
}",""
"// Overlay
//-----------------------------------------------------------------------
/**
 * <p>Overlays part of a String with another String.</p>
 *
 * <p>A <code>null</code> string input returns <code>null</code>.
 * A negative index is treated as zero.
 * An index greater than the string length is treated as the string length.
 * The start index is always the smaller of the two indices.</p>
 *
 * <pre>
 * StringUtils.overlay(null, *, *, *)            = null
 * StringUtils.overlay("""", ""abc"", 0, 0)          = ""abc""
 * StringUtils.overlay(""abcdef"", null, 2, 4)     = ""abef""
 * StringUtils.overlay(""abcdef"", """", 2, 4)       = ""abef""
 * StringUtils.overlay(""abcdef"", """", 4, 2)       = ""abef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 2, 4)   = ""abzzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 4, 2)   = ""abzzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", -1, 4)  = ""zzzzef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 2, 8)   = ""abzzzz""
 * StringUtils.overlay(""abcdef"", ""zzzz"", -2, -3) = ""zzzzabcdef""
 * StringUtils.overlay(""abcdef"", ""zzzz"", 8, 10)  = ""abcdefzzzz""
 * </pre>
 *
 * @param str  the String to do overlaying in, may be null
 * @param overlay  the String to overlay, may be null
 * @param start  the position to start overlaying at
 * @param end  the position to stop overlaying before
 * @return overlayed String, <code>null</code> if null String input
 * @since 2.0
 */
public static String overlay(String str, String overlay, int start, int end) {
    if (str == null) {
        return null;
    }
    if (overlay == null) {
        overlay = EMPTY;
    }
    int len = str.length();
    if (start < 0) {
        start = 0;
    }
    if (start > len) {
        start = len;
    }
    if (end < 0) {
        end = 0;
    }
    if (end > len) {
        end = len;
    }
    if (start > end) {
        int temp = start;
        start = end;
        end = temp;
    }
    return new StringBuilder(len + start - end + overlay.length() + 1).append(str.substring(0, start)).append(overlay).append(str.substring(end)).toString();
}","public void test291324() throws Throwable {
    String string0 = StringUtils.overlay(""]"", ""]"", 18, 18);
    assertEquals(""]]"", string0);
}",""
"// Chomping
//-----------------------------------------------------------------------
/**
 * <p>Removes one newline from end of a String if it's there,
 * otherwise leave it alone.  A newline is &quot;<code>\n</code>&quot;,
 * &quot;<code>\r</code>&quot;, or &quot;<code>\r\n</code>&quot;.</p>
 *
 * <p>NOTE: This method changed in 2.0.
 * It now more closely matches Perl chomp.</p>
 *
 * <pre>
 * StringUtils.chomp(null)          = null
 * StringUtils.chomp("""")            = """"
 * StringUtils.chomp(""abc \r"")      = ""abc ""
 * StringUtils.chomp(""abc\n"")       = ""abc""
 * StringUtils.chomp(""abc\r\n"")     = ""abc""
 * StringUtils.chomp(""abc\r\n\r\n"") = ""abc\r\n""
 * StringUtils.chomp(""abc\n\r"")     = ""abc\n""
 * StringUtils.chomp(""abc\n\rabc"")  = ""abc\n\rabc""
 * StringUtils.chomp(""\r"")          = """"
 * StringUtils.chomp(""\n"")          = """"
 * StringUtils.chomp(""\r\n"")        = """"
 * </pre>
 *
 * @param str  the String to chomp a newline from, may be null
 * @return String without newline, <code>null</code> if null String input
 */
public static String chomp(String str) {
    if (isEmpty(str)) {
        return str;
    }
    if (str.length() == 1) {
        char ch = str.charAt(0);
        if (ch == CharUtils.CR || ch == CharUtils.LF) {
            return EMPTY;
        }
        return str;
    }
    int lastIdx = str.length() - 1;
    char last = str.charAt(lastIdx);
    if (last == CharUtils.LF) {
        if (str.charAt(lastIdx - 1) == CharUtils.CR) {
            lastIdx--;
        }
    } else if (last != CharUtils.CR) {
        lastIdx++;
    }
    return str.substring(0, lastIdx);
}","public void test292325() throws Throwable {
    String string0 = StringUtils.chomp(""w~>Ct+ $"");
    assertEquals(""w~>Ct+ $"", string0);
}",""
"// Chomping
//-----------------------------------------------------------------------
/**
 * <p>Removes one newline from end of a String if it's there,
 * otherwise leave it alone.  A newline is &quot;<code>\n</code>&quot;,
 * &quot;<code>\r</code>&quot;, or &quot;<code>\r\n</code>&quot;.</p>
 *
 * <p>NOTE: This method changed in 2.0.
 * It now more closely matches Perl chomp.</p>
 *
 * <pre>
 * StringUtils.chomp(null)          = null
 * StringUtils.chomp("""")            = """"
 * StringUtils.chomp(""abc \r"")      = ""abc ""
 * StringUtils.chomp(""abc\n"")       = ""abc""
 * StringUtils.chomp(""abc\r\n"")     = ""abc""
 * StringUtils.chomp(""abc\r\n\r\n"") = ""abc\r\n""
 * StringUtils.chomp(""abc\n\r"")     = ""abc\n""
 * StringUtils.chomp(""abc\n\rabc"")  = ""abc\n\rabc""
 * StringUtils.chomp(""\r"")          = """"
 * StringUtils.chomp(""\n"")          = """"
 * StringUtils.chomp(""\r\n"")        = """"
 * </pre>
 *
 * @param str  the String to chomp a newline from, may be null
 * @return String without newline, <code>null</code> if null String input
 */
public static String chomp(String str) {
    if (isEmpty(str)) {
        return str;
    }
    if (str.length() == 1) {
        char ch = str.charAt(0);
        if (ch == CharUtils.CR || ch == CharUtils.LF) {
            return EMPTY;
        }
        return str;
    }
    int lastIdx = str.length() - 1;
    char last = str.charAt(lastIdx);
    if (last == CharUtils.LF) {
        if (str.charAt(lastIdx - 1) == CharUtils.CR) {
            lastIdx--;
        }
    } else if (last != CharUtils.CR) {
        lastIdx++;
    }
    return str.substring(0, lastIdx);
}","public void test293326() throws Throwable {
    String string0 = StringUtils.chomp((String) null);
    assertNull(string0);
}",""
"// Chomping
//-----------------------------------------------------------------------
/**
 * <p>Removes one newline from end of a String if it's there,
 * otherwise leave it alone.  A newline is &quot;<code>\n</code>&quot;,
 * &quot;<code>\r</code>&quot;, or &quot;<code>\r\n</code>&quot;.</p>
 *
 * <p>NOTE: This method changed in 2.0.
 * It now more closely matches Perl chomp.</p>
 *
 * <pre>
 * StringUtils.chomp(null)          = null
 * StringUtils.chomp("""")            = """"
 * StringUtils.chomp(""abc \r"")      = ""abc ""
 * StringUtils.chomp(""abc\n"")       = ""abc""
 * StringUtils.chomp(""abc\r\n"")     = ""abc""
 * StringUtils.chomp(""abc\r\n\r\n"") = ""abc\r\n""
 * StringUtils.chomp(""abc\n\r"")     = ""abc\n""
 * StringUtils.chomp(""abc\n\rabc"")  = ""abc\n\rabc""
 * StringUtils.chomp(""\r"")          = """"
 * StringUtils.chomp(""\n"")          = """"
 * StringUtils.chomp(""\r\n"")        = """"
 * </pre>
 *
 * @param str  the String to chomp a newline from, may be null
 * @return String without newline, <code>null</code> if null String input
 */
public static String chomp(String str) {
    if (isEmpty(str)) {
        return str;
    }
    if (str.length() == 1) {
        char ch = str.charAt(0);
        if (ch == CharUtils.CR || ch == CharUtils.LF) {
            return EMPTY;
        }
        return str;
    }
    int lastIdx = str.length() - 1;
    char last = str.charAt(lastIdx);
    if (last == CharUtils.LF) {
        if (str.charAt(lastIdx - 1) == CharUtils.CR) {
            lastIdx--;
        }
    } else if (last != CharUtils.CR) {
        lastIdx++;
    }
    return str.substring(0, lastIdx);
}","public void test294327() throws Throwable {
    String string0 = StringUtils.chomp("" "");
    assertEquals("" "", string0);
}",""
"// Chomping
//-----------------------------------------------------------------------
/**
 * <p>Removes one newline from end of a String if it's there,
 * otherwise leave it alone.  A newline is &quot;<code>\n</code>&quot;,
 * &quot;<code>\r</code>&quot;, or &quot;<code>\r\n</code>&quot;.</p>
 *
 * <p>NOTE: This method changed in 2.0.
 * It now more closely matches Perl chomp.</p>
 *
 * <pre>
 * StringUtils.chomp(null)          = null
 * StringUtils.chomp("""")            = """"
 * StringUtils.chomp(""abc \r"")      = ""abc ""
 * StringUtils.chomp(""abc\n"")       = ""abc""
 * StringUtils.chomp(""abc\r\n"")     = ""abc""
 * StringUtils.chomp(""abc\r\n\r\n"") = ""abc\r\n""
 * StringUtils.chomp(""abc\n\r"")     = ""abc\n""
 * StringUtils.chomp(""abc\n\rabc"")  = ""abc\n\rabc""
 * StringUtils.chomp(""\r"")          = """"
 * StringUtils.chomp(""\n"")          = """"
 * StringUtils.chomp(""\r\n"")        = """"
 * </pre>
 *
 * @param str  the String to chomp a newline from, may be null
 * @return String without newline, <code>null</code> if null String input
 */
public static String chomp(String str) {
    if (isEmpty(str)) {
        return str;
    }
    if (str.length() == 1) {
        char ch = str.charAt(0);
        if (ch == CharUtils.CR || ch == CharUtils.LF) {
            return EMPTY;
        }
        return str;
    }
    int lastIdx = str.length() - 1;
    char last = str.charAt(lastIdx);
    if (last == CharUtils.LF) {
        if (str.charAt(lastIdx - 1) == CharUtils.CR) {
            lastIdx--;
        }
    } else if (last != CharUtils.CR) {
        lastIdx++;
    }
    return str.substring(0, lastIdx);
}","public void test295328() throws Throwable {
    String string0 = StringUtils.chomp(""\u0000\u0001\u0002#:'h\u0004\u0005\u0007\b\n"");
    assertEquals(""\u0000\u0001\u0002#:'h\u0004\u0005\u0007\b"", string0);
}",""
"public static String chomp(String str, String separator) {
    if (isEmpty(str) || separator == null) {
        return str;
    }
    if (str.endsWith(separator)) {
        return str.substring(0, str.length() - separator.length());
    }
    return str;
}","public void test296329() throws Throwable {
    String string0 = StringUtils.chomp("""", """");
    assertEquals("""", string0);
}","/**
 * <p>Removes <code>separator</code> from the end of
 * <code>str</code> if it's there, otherwise leave it alone.</p>
 *
 * <p>NOTE: This method changed in version 2.0.
 * It now more closely matches Perl chomp.
 * For the previous behavior, use {@link #substringBeforeLast(String, String)}.
 * This method uses {@link String#endsWith(String)}.</p>
 *
 * <pre>
 * StringUtils.chomp(null, *)         = null
 * StringUtils.chomp("""", *)           = """"
 * StringUtils.chomp(""foobar"", ""bar"") = ""foo""
 * StringUtils.chomp(""foobar"", ""baz"") = ""foobar""
 * StringUtils.chomp(""foo"", ""foo"")    = """"
 * StringUtils.chomp(""foo "", ""foo"")   = ""foo ""
 * StringUtils.chomp("" foo"", ""foo"")   = "" ""
 * StringUtils.chomp(""foo"", ""foooo"")  = ""foo""
 * StringUtils.chomp(""foo"", """")       = ""foo""
 * StringUtils.chomp(""foo"", null)     = ""foo""
 * </pre>
 *
 * @param str  the String to chomp from, may be null
 * @param separator  separator String, may be null
 * @return String without trailing separator, <code>null</code> if null String input
 */"
"public static String chomp(String str, String separator) {
    if (isEmpty(str) || separator == null) {
        return str;
    }
    if (str.endsWith(separator)) {
        return str.substring(0, str.length() - separator.length());
    }
    return str;
}","public void test297330() throws Throwable {
    String string0 = StringUtils.chomp(""\u0000lWg]\u0001\u0002J:'h\u0004\u0005\u0007\b\n\u000BJ\u000E1"", (String) null);
    assertNotNull(string0);
}","/**
 * <p>Removes <code>separator</code> from the end of
 * <code>str</code> if it's there, otherwise leave it alone.</p>
 *
 * <p>NOTE: This method changed in version 2.0.
 * It now more closely matches Perl chomp.
 * For the previous behavior, use {@link #substringBeforeLast(String, String)}.
 * This method uses {@link String#endsWith(String)}.</p>
 *
 * <pre>
 * StringUtils.chomp(null, *)         = null
 * StringUtils.chomp("""", *)           = """"
 * StringUtils.chomp(""foobar"", ""bar"") = ""foo""
 * StringUtils.chomp(""foobar"", ""baz"") = ""foobar""
 * StringUtils.chomp(""foo"", ""foo"")    = """"
 * StringUtils.chomp(""foo "", ""foo"")   = ""foo ""
 * StringUtils.chomp("" foo"", ""foo"")   = "" ""
 * StringUtils.chomp(""foo"", ""foooo"")  = ""foo""
 * StringUtils.chomp(""foo"", """")       = ""foo""
 * StringUtils.chomp(""foo"", null)     = ""foo""
 * </pre>
 *
 * @param str  the String to chomp from, may be null
 * @param separator  separator String, may be null
 * @return String without trailing separator, <code>null</code> if null String input
 */"
"public static String chomp(String str, String separator) {
    if (isEmpty(str) || separator == null) {
        return str;
    }
    if (str.endsWith(separator)) {
        return str.substring(0, str.length() - separator.length());
    }
    return str;
}","public void test298332() throws Throwable {
    String string0 = StringUtils.chomp(""\u0000LWG]\u0001\u0002J:'H\u0004\u0005\u0007\b\n\u000BJ\u000E1"", ""\u0000lWg]\u0001\u0002J:'h\u0004\u0005\u0007\b\n\u000BJ\u000E1"");
    assertEquals(""\u0000LWG]\u0001\u0002J:'H\u0004\u0005\u0007\b\n\u000BJ\u000E1"", string0);
}","/**
 * <p>Removes <code>separator</code> from the end of
 * <code>str</code> if it's there, otherwise leave it alone.</p>
 *
 * <p>NOTE: This method changed in version 2.0.
 * It now more closely matches Perl chomp.
 * For the previous behavior, use {@link #substringBeforeLast(String, String)}.
 * This method uses {@link String#endsWith(String)}.</p>
 *
 * <pre>
 * StringUtils.chomp(null, *)         = null
 * StringUtils.chomp("""", *)           = """"
 * StringUtils.chomp(""foobar"", ""bar"") = ""foo""
 * StringUtils.chomp(""foobar"", ""baz"") = ""foobar""
 * StringUtils.chomp(""foo"", ""foo"")    = """"
 * StringUtils.chomp(""foo "", ""foo"")   = ""foo ""
 * StringUtils.chomp("" foo"", ""foo"")   = "" ""
 * StringUtils.chomp(""foo"", ""foooo"")  = ""foo""
 * StringUtils.chomp(""foo"", """")       = ""foo""
 * StringUtils.chomp(""foo"", null)     = ""foo""
 * </pre>
 *
 * @param str  the String to chomp from, may be null
 * @param separator  separator String, may be null
 * @return String without trailing separator, <code>null</code> if null String input
 */"
"public static String chomp(String str, String separator) {
    if (isEmpty(str) || separator == null) {
        return str;
    }
    if (str.endsWith(separator)) {
        return str.substring(0, str.length() - separator.length());
    }
    return str;
}","public void test299333() throws Throwable {
    String string0 = StringUtils.chomp(""Cannot pad a negative amount: "", ""Cannot pad a negative amount: "");
    assertEquals("""", string0);
}","/**
 * <p>Removes <code>separator</code> from the end of
 * <code>str</code> if it's there, otherwise leave it alone.</p>
 *
 * <p>NOTE: This method changed in version 2.0.
 * It now more closely matches Perl chomp.
 * For the previous behavior, use {@link #substringBeforeLast(String, String)}.
 * This method uses {@link String#endsWith(String)}.</p>
 *
 * <pre>
 * StringUtils.chomp(null, *)         = null
 * StringUtils.chomp("""", *)           = """"
 * StringUtils.chomp(""foobar"", ""bar"") = ""foo""
 * StringUtils.chomp(""foobar"", ""baz"") = ""foobar""
 * StringUtils.chomp(""foo"", ""foo"")    = """"
 * StringUtils.chomp(""foo "", ""foo"")   = ""foo ""
 * StringUtils.chomp("" foo"", ""foo"")   = "" ""
 * StringUtils.chomp(""foo"", ""foooo"")  = ""foo""
 * StringUtils.chomp(""foo"", """")       = ""foo""
 * StringUtils.chomp(""foo"", null)     = ""foo""
 * </pre>
 *
 * @param str  the String to chomp from, may be null
 * @param separator  separator String, may be null
 * @return String without trailing separator, <code>null</code> if null String input
 */"
"// Chopping
//-----------------------------------------------------------------------
/**
 * <p>Remove the last character from a String.</p>
 *
 * <p>If the String ends in <code>\r\n</code>, then remove both
 * of them.</p>
 *
 * <pre>
 * StringUtils.chop(null)          = null
 * StringUtils.chop("""")            = """"
 * StringUtils.chop(""abc \r"")      = ""abc ""
 * StringUtils.chop(""abc\n"")       = ""abc""
 * StringUtils.chop(""abc\r\n"")     = ""abc""
 * StringUtils.chop(""abc"")         = ""ab""
 * StringUtils.chop(""abc\nabc"")    = ""abc\nab""
 * StringUtils.chop(""a"")           = """"
 * StringUtils.chop(""\r"")          = """"
 * StringUtils.chop(""\n"")          = """"
 * StringUtils.chop(""\r\n"")        = """"
 * </pre>
 *
 * @param str  the String to chop last character from, may be null
 * @return String without last character, <code>null</code> if null String input
 */
public static String chop(String str) {
    if (str == null) {
        return null;
    }
    int strLen = str.length();
    if (strLen < 2) {
        return EMPTY;
    }
    int lastIdx = strLen - 1;
    String ret = str.substring(0, lastIdx);
    char last = str.charAt(lastIdx);
    if (last == CharUtils.LF) {
        if (ret.charAt(lastIdx - 1) == CharUtils.CR) {
            return ret.substring(0, lastIdx - 1);
        }
    }
    return ret;
}","public void test300334() throws Throwable {
    String string0 = StringUtils.chop(""java.vm.info"");
    assertEquals(""java.vm.inf"", string0);
}",""
"// Chopping
//-----------------------------------------------------------------------
/**
 * <p>Remove the last character from a String.</p>
 *
 * <p>If the String ends in <code>\r\n</code>, then remove both
 * of them.</p>
 *
 * <pre>
 * StringUtils.chop(null)          = null
 * StringUtils.chop("""")            = """"
 * StringUtils.chop(""abc \r"")      = ""abc ""
 * StringUtils.chop(""abc\n"")       = ""abc""
 * StringUtils.chop(""abc\r\n"")     = ""abc""
 * StringUtils.chop(""abc"")         = ""ab""
 * StringUtils.chop(""abc\nabc"")    = ""abc\nab""
 * StringUtils.chop(""a"")           = """"
 * StringUtils.chop(""\r"")          = """"
 * StringUtils.chop(""\n"")          = """"
 * StringUtils.chop(""\r\n"")        = """"
 * </pre>
 *
 * @param str  the String to chop last character from, may be null
 * @return String without last character, <code>null</code> if null String input
 */
public static String chop(String str) {
    if (str == null) {
        return null;
    }
    int strLen = str.length();
    if (strLen < 2) {
        return EMPTY;
    }
    int lastIdx = strLen - 1;
    String ret = str.substring(0, lastIdx);
    char last = str.charAt(lastIdx);
    if (last == CharUtils.LF) {
        if (ret.charAt(lastIdx - 1) == CharUtils.CR) {
            return ret.substring(0, lastIdx - 1);
        }
    }
    return ret;
}","public void test301336() throws Throwable {
    String string0 = StringUtils.chop((String) null);
    assertNull(string0);
}",""
"// Chopping
//-----------------------------------------------------------------------
/**
 * <p>Remove the last character from a String.</p>
 *
 * <p>If the String ends in <code>\r\n</code>, then remove both
 * of them.</p>
 *
 * <pre>
 * StringUtils.chop(null)          = null
 * StringUtils.chop("""")            = """"
 * StringUtils.chop(""abc \r"")      = ""abc ""
 * StringUtils.chop(""abc\n"")       = ""abc""
 * StringUtils.chop(""abc\r\n"")     = ""abc""
 * StringUtils.chop(""abc"")         = ""ab""
 * StringUtils.chop(""abc\nabc"")    = ""abc\nab""
 * StringUtils.chop(""a"")           = """"
 * StringUtils.chop(""\r"")          = """"
 * StringUtils.chop(""\n"")          = """"
 * StringUtils.chop(""\r\n"")        = """"
 * </pre>
 *
 * @param str  the String to chop last character from, may be null
 * @return String without last character, <code>null</code> if null String input
 */
public static String chop(String str) {
    if (str == null) {
        return null;
    }
    int strLen = str.length();
    if (strLen < 2) {
        return EMPTY;
    }
    int lastIdx = strLen - 1;
    String ret = str.substring(0, lastIdx);
    char last = str.charAt(lastIdx);
    if (last == CharUtils.LF) {
        if (ret.charAt(lastIdx - 1) == CharUtils.CR) {
            return ret.substring(0, lastIdx - 1);
        }
    }
    return ret;
}","public void test302337() throws Throwable {
    String string0 = StringUtils.chop("""");
    assertEquals("""", string0);
}",""
"// Chopping
//-----------------------------------------------------------------------
/**
 * <p>Remove the last character from a String.</p>
 *
 * <p>If the String ends in <code>\r\n</code>, then remove both
 * of them.</p>
 *
 * <pre>
 * StringUtils.chop(null)          = null
 * StringUtils.chop("""")            = """"
 * StringUtils.chop(""abc \r"")      = ""abc ""
 * StringUtils.chop(""abc\n"")       = ""abc""
 * StringUtils.chop(""abc\r\n"")     = ""abc""
 * StringUtils.chop(""abc"")         = ""ab""
 * StringUtils.chop(""abc\nabc"")    = ""abc\nab""
 * StringUtils.chop(""a"")           = """"
 * StringUtils.chop(""\r"")          = """"
 * StringUtils.chop(""\n"")          = """"
 * StringUtils.chop(""\r\n"")        = """"
 * </pre>
 *
 * @param str  the String to chop last character from, may be null
 * @return String without last character, <code>null</code> if null String input
 */
public static String chop(String str) {
    if (str == null) {
        return null;
    }
    int strLen = str.length();
    if (strLen < 2) {
        return EMPTY;
    }
    int lastIdx = strLen - 1;
    String ret = str.substring(0, lastIdx);
    char last = str.charAt(lastIdx);
    if (last == CharUtils.LF) {
        if (ret.charAt(lastIdx - 1) == CharUtils.CR) {
            return ret.substring(0, lastIdx - 1);
        }
    }
    return ret;
}","public void test303338() throws Throwable {
    String string0 = StringUtils.chop(""\u0000\u0001\u0002j#:'\u0004\u0005\u0006\u0007\b\n\u0000Z\u0002j#:'h\u0004Q\u0006\u0007\b\n"");
    assertEquals(""\u0000\u0001\u0002j#:'\u0004\u0005\u0006\u0007\b\n\u0000Z\u0002j#:'h\u0004Q\u0006\u0007\b"", string0);
}",""
"public static String repeat(String str, String separator, int repeat) {
    if (str == null || separator == null) {
        return repeat(str, repeat);
    } else {
        // given that repeat(String, int) is quite optimized, better to rely on it than try and splice this into it
        String result = repeat(str + separator, repeat);
        return removeEnd(result, separator);
    }
}","public void test304339() throws Throwable {
    String string0 = StringUtils.repeat((String) null, ""Minimum abbreviation width with offset is 7"", 9941);
    assertNull(string0);
}","/**
 * <p>Repeat a String <code>repeat</code> times to form a
 * new String, with a String separator injected each time. </p>
 *
 * <pre>
 * StringUtils.repeat(null, null, 2) = null
 * StringUtils.repeat(null, ""x"", 2)  = null
 * StringUtils.repeat("""", null, 0)   = """"
 * StringUtils.repeat("""", """", 2)     = """"
 * StringUtils.repeat("""", ""x"", 3)    = ""xxx""
 * StringUtils.repeat(""?"", "", "", 3)  = ""?, ?, ?""
 * </pre>
 *
 * @param str        the String to repeat, may be null
 * @param separator  the String to inject, may be null
 * @param repeat     number of times to repeat str, negative treated as zero
 * @return a new String consisting of the original String repeated,
 *  <code>null</code> if null String input
 */"
"public static String repeat(String str, String separator, int repeat) {
    if (str == null || separator == null) {
        return repeat(str, repeat);
    } else {
        // given that repeat(String, int) is quite optimized, better to rely on it than try and splice this into it
        String result = repeat(str + separator, repeat);
        return removeEnd(result, separator);
    }
}","public void test305340() throws Throwable {
    String string0 = StringUtils.repeat(""=5}62t4Et?wUZU/d;"", ""=5}62t4Et?wUZU/d;"", (-925898041));
    assertEquals("""", string0);
}","/**
 * <p>Repeat a String <code>repeat</code> times to form a
 * new String, with a String separator injected each time. </p>
 *
 * <pre>
 * StringUtils.repeat(null, null, 2) = null
 * StringUtils.repeat(null, ""x"", 2)  = null
 * StringUtils.repeat("""", null, 0)   = """"
 * StringUtils.repeat("""", """", 2)     = """"
 * StringUtils.repeat("""", ""x"", 3)    = ""xxx""
 * StringUtils.repeat(""?"", "", "", 3)  = ""?, ?, ?""
 * </pre>
 *
 * @param str        the String to repeat, may be null
 * @param separator  the String to inject, may be null
 * @param repeat     number of times to repeat str, negative treated as zero
 * @return a new String consisting of the original String repeated,
 *  <code>null</code> if null String input
 */"
"// Conversion
//-----------------------------------------------------------------------
// Padding
//-----------------------------------------------------------------------
/**
 * <p>Repeat a String <code>repeat</code> times to form a
 * new String.</p>
 *
 * <pre>
 * StringUtils.repeat(null, 2) = null
 * StringUtils.repeat("""", 0)   = """"
 * StringUtils.repeat("""", 2)   = """"
 * StringUtils.repeat(""a"", 3)  = ""aaa""
 * StringUtils.repeat(""ab"", 2) = ""abab""
 * StringUtils.repeat(""a"", -2) = """"
 * </pre>
 *
 * @param str  the String to repeat, may be null
 * @param repeat  number of times to repeat str, negative treated as zero
 * @return a new String consisting of the original String repeated,
 *  <code>null</code> if null String input
 * @since 2.5
 */
public static String repeat(String str, int repeat) {
    // Performance tuned for 2.0 (JDK1.4)
    if (str == null) {
        return null;
    }
    if (repeat <= 0) {
        return EMPTY;
    }
    int inputLength = str.length();
    if (repeat == 1 || inputLength == 0) {
        return str;
    }
    if (inputLength == 1 && repeat <= PAD_LIMIT) {
        return padding(repeat, str.charAt(0));
    }
    int outputLength = inputLength * repeat;
    switch(inputLength) {
        case 1:
            char ch = str.charAt(0);
            char[] output1 = new char[outputLength];
            for (int i = repeat - 1; i >= 0; i--) {
                output1[i] = ch;
            }
            return new String(output1);
        case 2:
            char ch0 = str.charAt(0);
            char ch1 = str.charAt(1);
            char[] output2 = new char[outputLength];
            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {
                output2[i] = ch0;
                output2[i + 1] = ch1;
            }
            return new String(output2);
        default:
            StringBuilder buf = new StringBuilder(outputLength);
            for (int i = 0; i < repeat; i++) {
                buf.append(str);
            }
            return buf.toString();
    }
}","public void test306341() throws Throwable {
    String string0 = StringUtils.repeat(""illegalaccessexception occurred during ]9;w2a8b\""mv}!t cod#lmfmua{{bpk+vnegative amount: "", 1);
    assertEquals(""illegalaccessexception occurred during ]9;w2a8b\""mv}!t cod#lmfmua{{bpk+vnegative amount: "", string0);
}",""
"// Conversion
//-----------------------------------------------------------------------
// Padding
//-----------------------------------------------------------------------
/**
 * <p>Repeat a String <code>repeat</code> times to form a
 * new String.</p>
 *
 * <pre>
 * StringUtils.repeat(null, 2) = null
 * StringUtils.repeat("""", 0)   = """"
 * StringUtils.repeat("""", 2)   = """"
 * StringUtils.repeat(""a"", 3)  = ""aaa""
 * StringUtils.repeat(""ab"", 2) = ""abab""
 * StringUtils.repeat(""a"", -2) = """"
 * </pre>
 *
 * @param str  the String to repeat, may be null
 * @param repeat  number of times to repeat str, negative treated as zero
 * @return a new String consisting of the original String repeated,
 *  <code>null</code> if null String input
 * @since 2.5
 */
public static String repeat(String str, int repeat) {
    // Performance tuned for 2.0 (JDK1.4)
    if (str == null) {
        return null;
    }
    if (repeat <= 0) {
        return EMPTY;
    }
    int inputLength = str.length();
    if (repeat == 1 || inputLength == 0) {
        return str;
    }
    if (inputLength == 1 && repeat <= PAD_LIMIT) {
        return padding(repeat, str.charAt(0));
    }
    int outputLength = inputLength * repeat;
    switch(inputLength) {
        case 1:
            char ch = str.charAt(0);
            char[] output1 = new char[outputLength];
            for (int i = repeat - 1; i >= 0; i--) {
                output1[i] = ch;
            }
            return new String(output1);
        case 2:
            char ch0 = str.charAt(0);
            char ch1 = str.charAt(1);
            char[] output2 = new char[outputLength];
            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {
                output2[i] = ch0;
                output2[i + 1] = ch1;
            }
            return new String(output2);
        default:
            StringBuilder buf = new StringBuilder(outputLength);
            for (int i = 0; i < repeat; i++) {
                buf.append(str);
            }
            return buf.toString();
    }
}","public void test307342() throws Throwable {
    String string0 = StringUtils.repeat("" "", 9993);
    assertNotNull(string0);
}",""
"// Conversion
//-----------------------------------------------------------------------
// Padding
//-----------------------------------------------------------------------
/**
 * <p>Repeat a String <code>repeat</code> times to form a
 * new String.</p>
 *
 * <pre>
 * StringUtils.repeat(null, 2) = null
 * StringUtils.repeat("""", 0)   = """"
 * StringUtils.repeat("""", 2)   = """"
 * StringUtils.repeat(""a"", 3)  = ""aaa""
 * StringUtils.repeat(""ab"", 2) = ""abab""
 * StringUtils.repeat(""a"", -2) = """"
 * </pre>
 *
 * @param str  the String to repeat, may be null
 * @param repeat  number of times to repeat str, negative treated as zero
 * @return a new String consisting of the original String repeated,
 *  <code>null</code> if null String input
 * @since 2.5
 */
public static String repeat(String str, int repeat) {
    // Performance tuned for 2.0 (JDK1.4)
    if (str == null) {
        return null;
    }
    if (repeat <= 0) {
        return EMPTY;
    }
    int inputLength = str.length();
    if (repeat == 1 || inputLength == 0) {
        return str;
    }
    if (inputLength == 1 && repeat <= PAD_LIMIT) {
        return padding(repeat, str.charAt(0));
    }
    int outputLength = inputLength * repeat;
    switch(inputLength) {
        case 1:
            char ch = str.charAt(0);
            char[] output1 = new char[outputLength];
            for (int i = repeat - 1; i >= 0; i--) {
                output1[i] = ch;
            }
            return new String(output1);
        case 2:
            char ch0 = str.charAt(0);
            char ch1 = str.charAt(1);
            char[] output2 = new char[outputLength];
            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {
                output2[i] = ch0;
                output2[i + 1] = ch1;
            }
            return new String(output2);
        default:
            StringBuilder buf = new StringBuilder(outputLength);
            for (int i = 0; i < repeat; i++) {
                buf.append(str);
            }
            return buf.toString();
    }
}","public void test308343() throws Throwable {
    String string0 = StringUtils.repeat(""/"", 122);
    assertEquals(""//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////"", string0);
}",""
"public static String repeat(String str, String separator, int repeat) {
    if (str == null || separator == null) {
        return repeat(str, repeat);
    } else {
        // given that repeat(String, int) is quite optimized, better to rely on it than try and splice this into it
        String result = repeat(str + separator, repeat);
        return removeEnd(result, separator);
    }
}","public void test309344() throws Throwable {
    String string0 = StringUtils.repeat(""&"", ""&"", 21);
    assertEquals(""&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&"", string0);
}","/**
 * <p>Repeat a String <code>repeat</code> times to form a
 * new String, with a String separator injected each time. </p>
 *
 * <pre>
 * StringUtils.repeat(null, null, 2) = null
 * StringUtils.repeat(null, ""x"", 2)  = null
 * StringUtils.repeat("""", null, 0)   = """"
 * StringUtils.repeat("""", """", 2)     = """"
 * StringUtils.repeat("""", ""x"", 3)    = ""xxx""
 * StringUtils.repeat(""?"", "", "", 3)  = ""?, ?, ?""
 * </pre>
 *
 * @param str        the String to repeat, may be null
 * @param separator  the String to inject, may be null
 * @param repeat     number of times to repeat str, negative treated as zero
 * @return a new String consisting of the original String repeated,
 *  <code>null</code> if null String input
 */"
"public static String repeat(String str, String separator, int repeat) {
    if (str == null || separator == null) {
        return repeat(str, repeat);
    } else {
        // given that repeat(String, int) is quite optimized, better to rely on it than try and splice this into it
        String result = repeat(str + separator, repeat);
        return removeEnd(result, separator);
    }
}","public void test310345() throws Throwable {
    String string0 = StringUtils.repeat("""", (String) null, 14);
    assertNotNull(string0);
}","/**
 * <p>Repeat a String <code>repeat</code> times to form a
 * new String, with a String separator injected each time. </p>
 *
 * <pre>
 * StringUtils.repeat(null, null, 2) = null
 * StringUtils.repeat(null, ""x"", 2)  = null
 * StringUtils.repeat("""", null, 0)   = """"
 * StringUtils.repeat("""", """", 2)     = """"
 * StringUtils.repeat("""", ""x"", 3)    = ""xxx""
 * StringUtils.repeat(""?"", "", "", 3)  = ""?, ?, ?""
 * </pre>
 *
 * @param str        the String to repeat, may be null
 * @param separator  the String to inject, may be null
 * @param repeat     number of times to repeat str, negative treated as zero
 * @return a new String consisting of the original String repeated,
 *  <code>null</code> if null String input
 */"
"public static String rightPad(String str, int size) {
    return rightPad(str, size, ' ');
}","public void test311347() throws Throwable {
    String string0 = StringUtils.rightPad(""m!YlW)'CbCM"", 4);
    assertEquals(""m!YlW)'CbCM"", string0);
}","/**
 * <p>Right pad a String with spaces (' ').</p>
 *
 * <p>The String is padded to the size of <code>size</code>.</p>
 *
 * <pre>
 * StringUtils.rightPad(null, *)   = null
 * StringUtils.rightPad("""", 3)     = ""   ""
 * StringUtils.rightPad(""bat"", 3)  = ""bat""
 * StringUtils.rightPad(""bat"", 5)  = ""bat  ""
 * StringUtils.rightPad(""bat"", 1)  = ""bat""
 * StringUtils.rightPad(""bat"", -1) = ""bat""
 * </pre>
 *
 * @param str  the String to pad out, may be null
 * @param size  the size to pad to
 * @return right padded String or original String if no padding is necessary,
 *  <code>null</code> if null String input
 */"
"public static String rightPad(String str, int size, String padStr) {
    if (str == null) {
        return null;
    }
    if (isEmpty(padStr)) {
        padStr = "" "";
    }
    int padLen = padStr.length();
    int strLen = str.length();
    int pads = size - strLen;
    if (pads <= 0) {
        // returns original String when possible
        return str;
    }
    if (padLen == 1 && pads <= PAD_LIMIT) {
        return rightPad(str, size, padStr.charAt(0));
    }
    if (pads == padLen) {
        return str.concat(padStr);
    } else if (pads < padLen) {
        return str.concat(padStr.substring(0, pads));
    } else {
        char[] padding = new char[pads];
        char[] padChars = padStr.toCharArray();
        for (int i = 0; i < pads; i++) {
            padding[i] = padChars[i % padLen];
        }
        return str.concat(new String(padding));
    }
}","public void test312348() throws Throwable {
    String string0 = StringUtils.rightPad("""", 40, """");
    assertNotNull(string0);
}","/**
 * <p>Right pad a String with a specified String.</p>
 *
 * <p>The String is padded to the size of <code>size</code>.</p>
 *
 * <pre>
 * StringUtils.rightPad(null, *, *)      = null
 * StringUtils.rightPad("""", 3, ""z"")      = ""zzz""
 * StringUtils.rightPad(""bat"", 3, ""yz"")  = ""bat""
 * StringUtils.rightPad(""bat"", 5, ""yz"")  = ""batyz""
 * StringUtils.rightPad(""bat"", 8, ""yz"")  = ""batyzyzy""
 * StringUtils.rightPad(""bat"", 1, ""yz"")  = ""bat""
 * StringUtils.rightPad(""bat"", -1, ""yz"") = ""bat""
 * StringUtils.rightPad(""bat"", 5, null)  = ""bat  ""
 * StringUtils.rightPad(""bat"", 5, """")    = ""bat  ""
 * </pre>
 *
 * @param str  the String to pad out, may be null
 * @param size  the size to pad to
 * @param padStr  the String to pad with, null or empty treated as single space
 * @return right padded String or original String if no padding is necessary,
 *  <code>null</code> if null String input
 */"
"public static String rightPad(String str, int size, char padChar) {
    if (str == null) {
        return null;
    }
    int pads = size - str.length();
    if (pads <= 0) {
        // returns original String when possible
        return str;
    }
    if (pads > PAD_LIMIT) {
        return rightPad(str, size, String.valueOf(padChar));
    }
    return str.concat(padding(pads, padChar));
}","public void test313350() throws Throwable {
    // Undeclared exception!
    StringUtils.rightPad(""java.vendor"", 56319, '<');
}","/**
 * <p>Right pad a String with a specified character.</p>
 *
 * <p>The String is padded to the size of <code>size</code>.</p>
 *
 * <pre>
 * StringUtils.rightPad(null, *, *)     = null
 * StringUtils.rightPad("""", 3, 'z')     = ""zzz""
 * StringUtils.rightPad(""bat"", 3, 'z')  = ""bat""
 * StringUtils.rightPad(""bat"", 5, 'z')  = ""batzz""
 * StringUtils.rightPad(""bat"", 1, 'z')  = ""bat""
 * StringUtils.rightPad(""bat"", -1, 'z') = ""bat""
 * </pre>
 *
 * @param str  the String to pad out, may be null
 * @param size  the size to pad to
 * @param padChar  the character to pad with
 * @return right padded String or original String if no padding is necessary,
 *  <code>null</code> if null String input
 * @since 2.0
 */"
"public static String rightPad(String str, int size, String padStr) {
    if (str == null) {
        return null;
    }
    if (isEmpty(padStr)) {
        padStr = "" "";
    }
    int padLen = padStr.length();
    int strLen = str.length();
    int pads = size - strLen;
    if (pads <= 0) {
        // returns original String when possible
        return str;
    }
    if (padLen == 1 && pads <= PAD_LIMIT) {
        return rightPad(str, size, padStr.charAt(0));
    }
    if (pads == padLen) {
        return str.concat(padStr);
    } else if (pads < padLen) {
        return str.concat(padStr.substring(0, pads));
    } else {
        char[] padding = new char[pads];
        char[] padChars = padStr.toCharArray();
        for (int i = 0; i < pads; i++) {
            padding[i] = padChars[i % padLen];
        }
        return str.concat(new String(padding));
    }
}","public void test314351() throws Throwable {
    String string0 = StringUtils.rightPad((String) null, 4, (String) null);
    assertNull(string0);
}","/**
 * <p>Right pad a String with a specified String.</p>
 *
 * <p>The String is padded to the size of <code>size</code>.</p>
 *
 * <pre>
 * StringUtils.rightPad(null, *, *)      = null
 * StringUtils.rightPad("""", 3, ""z"")      = ""zzz""
 * StringUtils.rightPad(""bat"", 3, ""yz"")  = ""bat""
 * StringUtils.rightPad(""bat"", 5, ""yz"")  = ""batyz""
 * StringUtils.rightPad(""bat"", 8, ""yz"")  = ""batyzyzy""
 * StringUtils.rightPad(""bat"", 1, ""yz"")  = ""bat""
 * StringUtils.rightPad(""bat"", -1, ""yz"") = ""bat""
 * StringUtils.rightPad(""bat"", 5, null)  = ""bat  ""
 * StringUtils.rightPad(""bat"", 5, """")    = ""bat  ""
 * </pre>
 *
 * @param str  the String to pad out, may be null
 * @param size  the size to pad to
 * @param padStr  the String to pad with, null or empty treated as single space
 * @return right padded String or original String if no padding is necessary,
 *  <code>null</code> if null String input
 */"
"public static String rightPad(String str, int size, String padStr) {
    if (str == null) {
        return null;
    }
    if (isEmpty(padStr)) {
        padStr = "" "";
    }
    int padLen = padStr.length();
    int strLen = str.length();
    int pads = size - strLen;
    if (pads <= 0) {
        // returns original String when possible
        return str;
    }
    if (padLen == 1 && pads <= PAD_LIMIT) {
        return rightPad(str, size, padStr.charAt(0));
    }
    if (pads == padLen) {
        return str.concat(padStr);
    } else if (pads < padLen) {
        return str.concat(padStr.substring(0, pads));
    } else {
        char[] padding = new char[pads];
        char[] padChars = padStr.toCharArray();
        for (int i = 0; i < pads; i++) {
            padding[i] = padChars[i % padLen];
        }
        return str.concat(new String(padding));
    }
}","public void test315352() throws Throwable {
    String string0 = StringUtils.rightPad(""XfJZErYbfzRS>Z$b\"""", 2, ""XfJZErYbfzRS>Z$b\"""");
    assertEquals(""XfJZErYbfzRS>Z$b\"""", string0);
}","/**
 * <p>Right pad a String with a specified String.</p>
 *
 * <p>The String is padded to the size of <code>size</code>.</p>
 *
 * <pre>
 * StringUtils.rightPad(null, *, *)      = null
 * StringUtils.rightPad("""", 3, ""z"")      = ""zzz""
 * StringUtils.rightPad(""bat"", 3, ""yz"")  = ""bat""
 * StringUtils.rightPad(""bat"", 5, ""yz"")  = ""batyz""
 * StringUtils.rightPad(""bat"", 8, ""yz"")  = ""batyzyzy""
 * StringUtils.rightPad(""bat"", 1, ""yz"")  = ""bat""
 * StringUtils.rightPad(""bat"", -1, ""yz"") = ""bat""
 * StringUtils.rightPad(""bat"", 5, null)  = ""bat  ""
 * StringUtils.rightPad(""bat"", 5, """")    = ""bat  ""
 * </pre>
 *
 * @param str  the String to pad out, may be null
 * @param size  the size to pad to
 * @param padStr  the String to pad with, null or empty treated as single space
 * @return right padded String or original String if no padding is necessary,
 *  <code>null</code> if null String input
 */"
"public static String center(String str, int size, String padStr) {
    if (str == null || size <= 0) {
        return str;
    }
    if (isEmpty(padStr)) {
        padStr = "" "";
    }
    int strLen = str.length();
    int pads = size - strLen;
    if (pads <= 0) {
        return str;
    }
    str = leftPad(str, strLen + pads / 2, padStr);
    str = rightPad(str, size, padStr);
    return str;
}","public void test316353() throws Throwable {
    String string0 = StringUtils.center(""vs "", 9, ""vs "");
    assertEquals(""vs vs vs "", string0);
}","/**
 * <p>Centers a String in a larger String of size <code>size</code>.
 * Uses a supplied String as the value to pad the String with.</p>
 *
 * <p>If the size is less than the String length, the String is returned.
 * A <code>null</code> String returns <code>null</code>.
 * A negative size is treated as zero.</p>
 *
 * <pre>
 * StringUtils.center(null, *, *)     = null
 * StringUtils.center("""", 4, "" "")     = ""    ""
 * StringUtils.center(""ab"", -1, "" "")  = ""ab""
 * StringUtils.center(""ab"", 4, "" "")   = "" ab""
 * StringUtils.center(""abcd"", 2, "" "") = ""abcd""
 * StringUtils.center(""a"", 4, "" "")    = "" a  ""
 * StringUtils.center(""a"", 4, ""yz"")   = ""yayz""
 * StringUtils.center(""abc"", 7, null) = ""  abc  ""
 * StringUtils.center(""abc"", 7, """")   = ""  abc  ""
 * </pre>
 *
 * @param str  the String to center, may be null
 * @param size  the int size of new String, negative treated as zero
 * @param padStr  the String to pad the new String with, must not be null or empty
 * @return centered String, <code>null</code> if null String input
 * @throws IllegalArgumentException if padStr is <code>null</code> or empty
 */"
"public static String center(String str, int size, String padStr) {
    if (str == null || size <= 0) {
        return str;
    }
    if (isEmpty(padStr)) {
        padStr = "" "";
    }
    int strLen = str.length();
    int pads = size - strLen;
    if (pads <= 0) {
        return str;
    }
    str = leftPad(str, strLen + pads / 2, padStr);
    str = rightPad(str, size, padStr);
    return str;
}","public void test317354() throws Throwable {
    String string0 = StringUtils.center(""'; the SystemUtils property value will default to null."", 76, ""'; the SystemUtils property value will default to null."");
    assertEquals(""'; the Sys'; the SystemUtils property value will default to null.'; the Syst"", string0);
}","/**
 * <p>Centers a String in a larger String of size <code>size</code>.
 * Uses a supplied String as the value to pad the String with.</p>
 *
 * <p>If the size is less than the String length, the String is returned.
 * A <code>null</code> String returns <code>null</code>.
 * A negative size is treated as zero.</p>
 *
 * <pre>
 * StringUtils.center(null, *, *)     = null
 * StringUtils.center("""", 4, "" "")     = ""    ""
 * StringUtils.center(""ab"", -1, "" "")  = ""ab""
 * StringUtils.center(""ab"", 4, "" "")   = "" ab""
 * StringUtils.center(""abcd"", 2, "" "") = ""abcd""
 * StringUtils.center(""a"", 4, "" "")    = "" a  ""
 * StringUtils.center(""a"", 4, ""yz"")   = ""yayz""
 * StringUtils.center(""abc"", 7, null) = ""  abc  ""
 * StringUtils.center(""abc"", 7, """")   = ""  abc  ""
 * </pre>
 *
 * @param str  the String to center, may be null
 * @param size  the int size of new String, negative treated as zero
 * @param padStr  the String to pad the new String with, must not be null or empty
 * @return centered String, <code>null</code> if null String input
 * @throws IllegalArgumentException if padStr is <code>null</code> or empty
 */"
"public static String leftPad(String str, int size) {
    return leftPad(str, size, ' ');
}","public void test318355() throws Throwable {
    // Undeclared exception!
    StringUtils.leftPad("" "", 56319);
}","/**
 * <p>Left pad a String with spaces (' ').</p>
 *
 * <p>The String is padded to the size of <code>size</code>.</p>
 *
 * <pre>
 * StringUtils.leftPad(null, *)   = null
 * StringUtils.leftPad("""", 3)     = ""   ""
 * StringUtils.leftPad(""bat"", 3)  = ""bat""
 * StringUtils.leftPad(""bat"", 5)  = ""  bat""
 * StringUtils.leftPad(""bat"", 1)  = ""bat""
 * StringUtils.leftPad(""bat"", -1) = ""bat""
 * </pre>
 *
 * @param str  the String to pad out, may be null
 * @param size  the size to pad to
 * @return left padded String or original String if no padding is necessary,
 *  <code>null</code> if null String input
 */"
"public static String leftPad(String str, int size) {
    return leftPad(str, size, ' ');
}","public void test319356() throws Throwable {
    String string0 = StringUtils.leftPad("" "", (-17));
    assertEquals("" "", string0);
}","/**
 * <p>Left pad a String with spaces (' ').</p>
 *
 * <p>The String is padded to the size of <code>size</code>.</p>
 *
 * <pre>
 * StringUtils.leftPad(null, *)   = null
 * StringUtils.leftPad("""", 3)     = ""   ""
 * StringUtils.leftPad(""bat"", 3)  = ""bat""
 * StringUtils.leftPad(""bat"", 5)  = ""  bat""
 * StringUtils.leftPad(""bat"", 1)  = ""bat""
 * StringUtils.leftPad(""bat"", -1) = ""bat""
 * </pre>
 *
 * @param str  the String to pad out, may be null
 * @param size  the size to pad to
 * @return left padded String or original String if no padding is necessary,
 *  <code>null</code> if null String input
 */"
"public static String leftPad(String str, int size, String padStr) {
    if (str == null) {
        return null;
    }
    if (isEmpty(padStr)) {
        padStr = "" "";
    }
    int padLen = padStr.length();
    int strLen = str.length();
    int pads = size - strLen;
    if (pads <= 0) {
        // returns original String when possible
        return str;
    }
    if (padLen == 1 && pads <= PAD_LIMIT) {
        return leftPad(str, size, padStr.charAt(0));
    }
    if (pads == padLen) {
        return padStr.concat(str);
    } else if (pads < padLen) {
        return padStr.substring(0, pads).concat(str);
    } else {
        char[] padding = new char[pads];
        char[] padChars = padStr.toCharArray();
        for (int i = 0; i < pads; i++) {
            padding[i] = padChars[i % padLen];
        }
        return new String(padding).concat(str);
    }
}","public void test320357() throws Throwable {
    String string0 = StringUtils.leftPad("""", 3, """");
    assertEquals(""   "", string0);
}","/**
 * <p>Left pad a String with a specified String.</p>
 *
 * <p>Pad to a size of <code>size</code>.</p>
 *
 * <pre>
 * StringUtils.leftPad(null, *, *)      = null
 * StringUtils.leftPad("""", 3, ""z"")      = ""zzz""
 * StringUtils.leftPad(""bat"", 3, ""yz"")  = ""bat""
 * StringUtils.leftPad(""bat"", 5, ""yz"")  = ""yzbat""
 * StringUtils.leftPad(""bat"", 8, ""yz"")  = ""yzyzybat""
 * StringUtils.leftPad(""bat"", 1, ""yz"")  = ""bat""
 * StringUtils.leftPad(""bat"", -1, ""yz"") = ""bat""
 * StringUtils.leftPad(""bat"", 5, null)  = ""  bat""
 * StringUtils.leftPad(""bat"", 5, """")    = ""  bat""
 * </pre>
 *
 * @param str  the String to pad out, may be null
 * @param size  the size to pad to
 * @param padStr  the String to pad with, null or empty treated as single space
 * @return left padded String or original String if no padding is necessary,
 *  <code>null</code> if null String input
 */"
"public static String leftPad(String str, int size, String padStr) {
    if (str == null) {
        return null;
    }
    if (isEmpty(padStr)) {
        padStr = "" "";
    }
    int padLen = padStr.length();
    int strLen = str.length();
    int pads = size - strLen;
    if (pads <= 0) {
        // returns original String when possible
        return str;
    }
    if (padLen == 1 && pads <= PAD_LIMIT) {
        return leftPad(str, size, padStr.charAt(0));
    }
    if (pads == padLen) {
        return padStr.concat(str);
    } else if (pads < padLen) {
        return padStr.substring(0, pads).concat(str);
    } else {
        char[] padding = new char[pads];
        char[] padChars = padStr.toCharArray();
        for (int i = 0; i < pads; i++) {
            padding[i] = padChars[i % padLen];
        }
        return new String(padding).concat(str);
    }
}","public void test321359() throws Throwable {
    String string0 = StringUtils.leftPad((String) null, 3226, (String) null);
    assertNull(string0);
}","/**
 * <p>Left pad a String with a specified String.</p>
 *
 * <p>Pad to a size of <code>size</code>.</p>
 *
 * <pre>
 * StringUtils.leftPad(null, *, *)      = null
 * StringUtils.leftPad("""", 3, ""z"")      = ""zzz""
 * StringUtils.leftPad(""bat"", 3, ""yz"")  = ""bat""
 * StringUtils.leftPad(""bat"", 5, ""yz"")  = ""yzbat""
 * StringUtils.leftPad(""bat"", 8, ""yz"")  = ""yzyzybat""
 * StringUtils.leftPad(""bat"", 1, ""yz"")  = ""bat""
 * StringUtils.leftPad(""bat"", -1, ""yz"") = ""bat""
 * StringUtils.leftPad(""bat"", 5, null)  = ""  bat""
 * StringUtils.leftPad(""bat"", 5, """")    = ""  bat""
 * </pre>
 *
 * @param str  the String to pad out, may be null
 * @param size  the size to pad to
 * @param padStr  the String to pad with, null or empty treated as single space
 * @return left padded String or original String if no padding is necessary,
 *  <code>null</code> if null String input
 */"
"public static String center(String str, int size, String padStr) {
    if (str == null || size <= 0) {
        return str;
    }
    if (isEmpty(padStr)) {
        padStr = "" "";
    }
    int strLen = str.length();
    int pads = size - strLen;
    if (pads <= 0) {
        return str;
    }
    str = leftPad(str, strLen + pads / 2, padStr);
    str = rightPad(str, size, padStr);
    return str;
}","public void test322360() throws Throwable {
    String string0 = StringUtils.center(""'vK"", 4, ""'vK"");
    assertEquals(""'vK'"", string0);
}","/**
 * <p>Centers a String in a larger String of size <code>size</code>.
 * Uses a supplied String as the value to pad the String with.</p>
 *
 * <p>If the size is less than the String length, the String is returned.
 * A <code>null</code> String returns <code>null</code>.
 * A negative size is treated as zero.</p>
 *
 * <pre>
 * StringUtils.center(null, *, *)     = null
 * StringUtils.center("""", 4, "" "")     = ""    ""
 * StringUtils.center(""ab"", -1, "" "")  = ""ab""
 * StringUtils.center(""ab"", 4, "" "")   = "" ab""
 * StringUtils.center(""abcd"", 2, "" "") = ""abcd""
 * StringUtils.center(""a"", 4, "" "")    = "" a  ""
 * StringUtils.center(""a"", 4, ""yz"")   = ""yayz""
 * StringUtils.center(""abc"", 7, null) = ""  abc  ""
 * StringUtils.center(""abc"", 7, """")   = ""  abc  ""
 * </pre>
 *
 * @param str  the String to center, may be null
 * @param size  the int size of new String, negative treated as zero
 * @param padStr  the String to pad the new String with, must not be null or empty
 * @return centered String, <code>null</code> if null String input
 * @throws IllegalArgumentException if padStr is <code>null</code> or empty
 */"
"public static String center(String str, int size, String padStr) {
    if (str == null || size <= 0) {
        return str;
    }
    if (isEmpty(padStr)) {
        padStr = "" "";
    }
    int strLen = str.length();
    int pads = size - strLen;
    if (pads <= 0) {
        return str;
    }
    str = leftPad(str, strLen + pads / 2, padStr);
    str = rightPad(str, size, padStr);
    return str;
}","public void test323361() throws Throwable {
    String string0 = StringUtils.center(""O(qUDM\nD:Z(<"", 126, ""O(qUDM\nD:Z(<"");
    assertEquals(""O(qUDM\nD:Z(<O(qUDM\nD:Z(<O(qUDM\nD:Z(<O(qUDM\nD:Z(<O(qUDM\nD:O(qUDM\nD:Z(<O(qUDM\nD:Z(<O(qUDM\nD:Z(<O(qUDM\nD:Z(<O(qUDM\nD:Z(<O(qUDM\nD:"", string0);
}","/**
 * <p>Centers a String in a larger String of size <code>size</code>.
 * Uses a supplied String as the value to pad the String with.</p>
 *
 * <p>If the size is less than the String length, the String is returned.
 * A <code>null</code> String returns <code>null</code>.
 * A negative size is treated as zero.</p>
 *
 * <pre>
 * StringUtils.center(null, *, *)     = null
 * StringUtils.center("""", 4, "" "")     = ""    ""
 * StringUtils.center(""ab"", -1, "" "")  = ""ab""
 * StringUtils.center(""ab"", 4, "" "")   = "" ab""
 * StringUtils.center(""abcd"", 2, "" "") = ""abcd""
 * StringUtils.center(""a"", 4, "" "")    = "" a  ""
 * StringUtils.center(""a"", 4, ""yz"")   = ""yayz""
 * StringUtils.center(""abc"", 7, null) = ""  abc  ""
 * StringUtils.center(""abc"", 7, """")   = ""  abc  ""
 * </pre>
 *
 * @param str  the String to center, may be null
 * @param size  the int size of new String, negative treated as zero
 * @param padStr  the String to pad the new String with, must not be null or empty
 * @return centered String, <code>null</code> if null String input
 * @throws IllegalArgumentException if padStr is <code>null</code> or empty
 */"
"// Centering
//-----------------------------------------------------------------------
/**
 * <p>Centers a String in a larger String of size <code>size</code>
 * using the space character (' ').<p>
 *
 * <p>If the size is less than the String length, the String is returned.
 * A <code>null</code> String returns <code>null</code>.
 * A negative size is treated as zero.</p>
 *
 * <p>Equivalent to <code>center(str, size, "" "")</code>.</p>
 *
 * <pre>
 * StringUtils.center(null, *)   = null
 * StringUtils.center("""", 4)     = ""    ""
 * StringUtils.center(""ab"", -1)  = ""ab""
 * StringUtils.center(""ab"", 4)   = "" ab ""
 * StringUtils.center(""abcd"", 2) = ""abcd""
 * StringUtils.center(""a"", 4)    = "" a  ""
 * </pre>
 *
 * @param str  the String to center, may be null
 * @param size  the int size of new String, negative treated as zero
 * @return centered String, <code>null</code> if null String input
 */
public static String center(String str, int size) {
    return center(str, size, ' ');
}","public void test324362() throws Throwable {
    String string0 = StringUtils.center((String) null, 2);
    assertNull(string0);
}",""
"// Centering
//-----------------------------------------------------------------------
/**
 * <p>Centers a String in a larger String of size <code>size</code>
 * using the space character (' ').<p>
 *
 * <p>If the size is less than the String length, the String is returned.
 * A <code>null</code> String returns <code>null</code>.
 * A negative size is treated as zero.</p>
 *
 * <p>Equivalent to <code>center(str, size, "" "")</code>.</p>
 *
 * <pre>
 * StringUtils.center(null, *)   = null
 * StringUtils.center("""", 4)     = ""    ""
 * StringUtils.center(""ab"", -1)  = ""ab""
 * StringUtils.center(""ab"", 4)   = "" ab ""
 * StringUtils.center(""abcd"", 2) = ""abcd""
 * StringUtils.center(""a"", 4)    = "" a  ""
 * </pre>
 *
 * @param str  the String to center, may be null
 * @param size  the int size of new String, negative treated as zero
 * @return centered String, <code>null</code> if null String input
 */
public static String center(String str, int size) {
    return center(str, size, ' ');
}","public void test325363() throws Throwable {
    String string0 = StringUtils.center(""k$z"", (-1001));
    assertEquals(""k$z"", string0);
}",""
"// Centering
//-----------------------------------------------------------------------
/**
 * <p>Centers a String in a larger String of size <code>size</code>
 * using the space character (' ').<p>
 *
 * <p>If the size is less than the String length, the String is returned.
 * A <code>null</code> String returns <code>null</code>.
 * A negative size is treated as zero.</p>
 *
 * <p>Equivalent to <code>center(str, size, "" "")</code>.</p>
 *
 * <pre>
 * StringUtils.center(null, *)   = null
 * StringUtils.center("""", 4)     = ""    ""
 * StringUtils.center(""ab"", -1)  = ""ab""
 * StringUtils.center(""ab"", 4)   = "" ab ""
 * StringUtils.center(""abcd"", 2) = ""abcd""
 * StringUtils.center(""a"", 4)    = "" a  ""
 * </pre>
 *
 * @param str  the String to center, may be null
 * @param size  the int size of new String, negative treated as zero
 * @return centered String, <code>null</code> if null String input
 */
public static String center(String str, int size) {
    return center(str, size, ' ');
}","public void test326364() throws Throwable {
    String string0 = StringUtils.center("", '"", 893);
    assertEquals(""                                                                                                                                                                                                                                                                                                                                                                                                                                                             , '                                                                                                                                                                                                                                                                                                                                                                                                                                                             "", string0);
}",""
"public static String center(String str, int size, String padStr) {
    if (str == null || size <= 0) {
        return str;
    }
    if (isEmpty(padStr)) {
        padStr = "" "";
    }
    int strLen = str.length();
    int pads = size - strLen;
    if (pads <= 0) {
        return str;
    }
    str = leftPad(str, strLen + pads / 2, padStr);
    str = rightPad(str, size, padStr);
    return str;
}","public void test327365() throws Throwable {
    String string0 = StringUtils.center((String) null, 4, (String) null);
    assertNull(string0);
}","/**
 * <p>Centers a String in a larger String of size <code>size</code>.
 * Uses a supplied String as the value to pad the String with.</p>
 *
 * <p>If the size is less than the String length, the String is returned.
 * A <code>null</code> String returns <code>null</code>.
 * A negative size is treated as zero.</p>
 *
 * <pre>
 * StringUtils.center(null, *, *)     = null
 * StringUtils.center("""", 4, "" "")     = ""    ""
 * StringUtils.center(""ab"", -1, "" "")  = ""ab""
 * StringUtils.center(""ab"", 4, "" "")   = "" ab""
 * StringUtils.center(""abcd"", 2, "" "") = ""abcd""
 * StringUtils.center(""a"", 4, "" "")    = "" a  ""
 * StringUtils.center(""a"", 4, ""yz"")   = ""yayz""
 * StringUtils.center(""abc"", 7, null) = ""  abc  ""
 * StringUtils.center(""abc"", 7, """")   = ""  abc  ""
 * </pre>
 *
 * @param str  the String to center, may be null
 * @param size  the int size of new String, negative treated as zero
 * @param padStr  the String to pad the new String with, must not be null or empty
 * @return centered String, <code>null</code> if null String input
 * @throws IllegalArgumentException if padStr is <code>null</code> or empty
 */"
"public static String center(String str, int size, String padStr) {
    if (str == null || size <= 0) {
        return str;
    }
    if (isEmpty(padStr)) {
        padStr = "" "";
    }
    int strLen = str.length();
    int pads = size - strLen;
    if (pads <= 0) {
        return str;
    }
    str = leftPad(str, strLen + pads / 2, padStr);
    str = rightPad(str, size, padStr);
    return str;
}","public void test328366() throws Throwable {
    String string0 = StringUtils.center(""java.text.Normalizer"", (-3), ""java.text.Normalizer"");
    assertEquals(""java.text.Normalizer"", string0);
}","/**
 * <p>Centers a String in a larger String of size <code>size</code>.
 * Uses a supplied String as the value to pad the String with.</p>
 *
 * <p>If the size is less than the String length, the String is returned.
 * A <code>null</code> String returns <code>null</code>.
 * A negative size is treated as zero.</p>
 *
 * <pre>
 * StringUtils.center(null, *, *)     = null
 * StringUtils.center("""", 4, "" "")     = ""    ""
 * StringUtils.center(""ab"", -1, "" "")  = ""ab""
 * StringUtils.center(""ab"", 4, "" "")   = "" ab""
 * StringUtils.center(""abcd"", 2, "" "") = ""abcd""
 * StringUtils.center(""a"", 4, "" "")    = "" a  ""
 * StringUtils.center(""a"", 4, ""yz"")   = ""yayz""
 * StringUtils.center(""abc"", 7, null) = ""  abc  ""
 * StringUtils.center(""abc"", 7, """")   = ""  abc  ""
 * </pre>
 *
 * @param str  the String to center, may be null
 * @param size  the int size of new String, negative treated as zero
 * @param padStr  the String to pad the new String with, must not be null or empty
 * @return centered String, <code>null</code> if null String input
 * @throws IllegalArgumentException if padStr is <code>null</code> or empty
 */"
"public static String center(String str, int size, String padStr) {
    if (str == null || size <= 0) {
        return str;
    }
    if (isEmpty(padStr)) {
        padStr = "" "";
    }
    int strLen = str.length();
    int pads = size - strLen;
    if (pads <= 0) {
        return str;
    }
    str = leftPad(str, strLen + pads / 2, padStr);
    str = rightPad(str, size, padStr);
    return str;
}","public void test329367() throws Throwable {
    String string0 = StringUtils.center("""", 4, """");
    assertEquals(""    "", string0);
}","/**
 * <p>Centers a String in a larger String of size <code>size</code>.
 * Uses a supplied String as the value to pad the String with.</p>
 *
 * <p>If the size is less than the String length, the String is returned.
 * A <code>null</code> String returns <code>null</code>.
 * A negative size is treated as zero.</p>
 *
 * <pre>
 * StringUtils.center(null, *, *)     = null
 * StringUtils.center("""", 4, "" "")     = ""    ""
 * StringUtils.center(""ab"", -1, "" "")  = ""ab""
 * StringUtils.center(""ab"", 4, "" "")   = "" ab""
 * StringUtils.center(""abcd"", 2, "" "") = ""abcd""
 * StringUtils.center(""a"", 4, "" "")    = "" a  ""
 * StringUtils.center(""a"", 4, ""yz"")   = ""yayz""
 * StringUtils.center(""abc"", 7, null) = ""  abc  ""
 * StringUtils.center(""abc"", 7, """")   = ""  abc  ""
 * </pre>
 *
 * @param str  the String to center, may be null
 * @param size  the int size of new String, negative treated as zero
 * @param padStr  the String to pad the new String with, must not be null or empty
 * @return centered String, <code>null</code> if null String input
 * @throws IllegalArgumentException if padStr is <code>null</code> or empty
 */"
"public static String center(String str, int size, String padStr) {
    if (str == null || size <= 0) {
        return str;
    }
    if (isEmpty(padStr)) {
        padStr = "" "";
    }
    int strLen = str.length();
    int pads = size - strLen;
    if (pads <= 0) {
        return str;
    }
    str = leftPad(str, strLen + pads / 2, padStr);
    str = rightPad(str, size, padStr);
    return str;
}","public void test330368() throws Throwable {
    String string0 = StringUtils.center(""IllegalAccessException occurred during 1.6 backcompat code"", 33, ""IllegalAccessException occurred during 1.6 backcompat code"");
    assertEquals(""IllegalAccessException occurred during 1.6 backcompat code"", string0);
}","/**
 * <p>Centers a String in a larger String of size <code>size</code>.
 * Uses a supplied String as the value to pad the String with.</p>
 *
 * <p>If the size is less than the String length, the String is returned.
 * A <code>null</code> String returns <code>null</code>.
 * A negative size is treated as zero.</p>
 *
 * <pre>
 * StringUtils.center(null, *, *)     = null
 * StringUtils.center("""", 4, "" "")     = ""    ""
 * StringUtils.center(""ab"", -1, "" "")  = ""ab""
 * StringUtils.center(""ab"", 4, "" "")   = "" ab""
 * StringUtils.center(""abcd"", 2, "" "") = ""abcd""
 * StringUtils.center(""a"", 4, "" "")    = "" a  ""
 * StringUtils.center(""a"", 4, ""yz"")   = ""yayz""
 * StringUtils.center(""abc"", 7, null) = ""  abc  ""
 * StringUtils.center(""abc"", 7, """")   = ""  abc  ""
 * </pre>
 *
 * @param str  the String to center, may be null
 * @param size  the int size of new String, negative treated as zero
 * @param padStr  the String to pad the new String with, must not be null or empty
 * @return centered String, <code>null</code> if null String input
 * @throws IllegalArgumentException if padStr is <code>null</code> or empty
 */"
"// Case conversion
//-----------------------------------------------------------------------
/**
 * <p>Converts a String to upper case as per {@link String#toUpperCase()}.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.upperCase(null)  = null
 * StringUtils.upperCase("""")    = """"
 * StringUtils.upperCase(""aBc"") = ""ABC""
 * </pre>
 *
 * <p><strong>Note:</strong> As described in the documentation for {@link String#toUpperCase()},
 * the result of this method is affected by the current locale.
 * For platform-independent case transformations, the method {@link #lowerCase(String, Locale)}
 * should be used with a specific locale (e.g. {@link Locale#ENGLISH}).</p>
 *
 * @param str  the String to upper case, may be null
 * @return the upper cased String, <code>null</code> if null String input
 */
public static String upperCase(String str) {
    if (str == null) {
        return null;
    }
    return str.toUpperCase();
}","public void test332370() throws Throwable {
    String string0 = StringUtils.upperCase((String) null);
    assertNull(string0);
}",""
"public static String upperCase(String str, Locale locale) {
    if (str == null) {
        return null;
    }
    return str.toUpperCase(locale);
}","public void test333371() throws Throwable {
    Locale locale0 = Locale.US;
    String string0 = StringUtils.upperCase(""xa\""Vv"", locale0);
    assertNotNull(string0);
}","/**
 * <p>Converts a String to upper case as per {@link String#toUpperCase(Locale)}.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.upperCase(null, Locale.ENGLISH)  = null
 * StringUtils.upperCase("""", Locale.ENGLISH)    = """"
 * StringUtils.upperCase(""aBc"", Locale.ENGLISH) = ""ABC""
 * </pre>
 *
 * @param str  the String to upper case, may be null
 * @param locale  the locale that defines the case transformation rules, must not be null
 * @return the upper cased String, <code>null</code> if null String input
 * @since 2.5
 */"
"public static String upperCase(String str, Locale locale) {
    if (str == null) {
        return null;
    }
    return str.toUpperCase(locale);
}","public void test334373() throws Throwable {
    Locale locale0 = Locale.KOREA;
    String string0 = StringUtils.upperCase((String) null, locale0);
    assertNull(string0);
}","/**
 * <p>Converts a String to upper case as per {@link String#toUpperCase(Locale)}.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.upperCase(null, Locale.ENGLISH)  = null
 * StringUtils.upperCase("""", Locale.ENGLISH)    = """"
 * StringUtils.upperCase(""aBc"", Locale.ENGLISH) = ""ABC""
 * </pre>
 *
 * @param str  the String to upper case, may be null
 * @param locale  the locale that defines the case transformation rules, must not be null
 * @return the upper cased String, <code>null</code> if null String input
 * @since 2.5
 */"
"public static String lowerCase(String str) {
    if (str == null) {
        return null;
    }
    return str.toLowerCase();
}","public void test335374() throws Throwable {
    String string0 = StringUtils.lowerCase(""\""I"");
    assertNotNull(string0);
}","/**
 * <p>Converts a String to lower case as per {@link String#toLowerCase()}.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.lowerCase(null)  = null
 * StringUtils.lowerCase("""")    = """"
 * StringUtils.lowerCase(""aBc"") = ""abc""
 * </pre>
 *
 * <p><strong>Note:</strong> As described in the documentation for {@link String#toLowerCase()},
 * the result of this method is affected by the current locale.
 * For platform-independent case transformations, the method {@link #lowerCase(String, Locale)}
 * should be used with a specific locale (e.g. {@link Locale#ENGLISH}).</p>
 *
 * @param str  the String to lower case, may be null
 * @return the lower cased String, <code>null</code> if null String input
 */"
"public static String lowerCase(String str) {
    if (str == null) {
        return null;
    }
    return str.toLowerCase();
}","public void test336376() throws Throwable {
    String string0 = StringUtils.lowerCase((String) null);
    assertNull(string0);
}","/**
 * <p>Converts a String to lower case as per {@link String#toLowerCase()}.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.lowerCase(null)  = null
 * StringUtils.lowerCase("""")    = """"
 * StringUtils.lowerCase(""aBc"") = ""abc""
 * </pre>
 *
 * <p><strong>Note:</strong> As described in the documentation for {@link String#toLowerCase()},
 * the result of this method is affected by the current locale.
 * For platform-independent case transformations, the method {@link #lowerCase(String, Locale)}
 * should be used with a specific locale (e.g. {@link Locale#ENGLISH}).</p>
 *
 * @param str  the String to lower case, may be null
 * @return the lower cased String, <code>null</code> if null String input
 */"
"public static String lowerCase(String str, Locale locale) {
    if (str == null) {
        return null;
    }
    return str.toLowerCase(locale);
}","public void test337377() throws Throwable {
    Locale locale0 = Locale.CANADA_FRENCH;
    String string0 = StringUtils.lowerCase(""'; the SystemUtils property value will default to null."", locale0);
    assertEquals(""'; the systemutils property value will default to null."", string0);
}","/**
 * <p>Converts a String to lower case as per {@link String#toLowerCase(Locale)}.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.lowerCase(null, Locale.ENGLISH)  = null
 * StringUtils.lowerCase("""", Locale.ENGLISH)    = """"
 * StringUtils.lowerCase(""aBc"", Locale.ENGLISH) = ""abc""
 * </pre>
 *
 * @param str  the String to lower case, may be null
 * @param locale  the locale that defines the case transformation rules, must not be null
 * @return the lower cased String, <code>null</code> if null String input
 * @since 2.5
 */"
"public static String lowerCase(String str, Locale locale) {
    if (str == null) {
        return null;
    }
    return str.toLowerCase(locale);
}","public void test338379() throws Throwable {
    String string0 = StringUtils.lowerCase((String) null, (Locale) null);
    assertNull(string0);
}","/**
 * <p>Converts a String to lower case as per {@link String#toLowerCase(Locale)}.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.lowerCase(null, Locale.ENGLISH)  = null
 * StringUtils.lowerCase("""", Locale.ENGLISH)    = """"
 * StringUtils.lowerCase(""aBc"", Locale.ENGLISH) = ""abc""
 * </pre>
 *
 * @param str  the String to lower case, may be null
 * @param locale  the locale that defines the case transformation rules, must not be null
 * @return the lower cased String, <code>null</code> if null String input
 * @since 2.5
 */"
"public static String capitalize(CharSequence cs) {
    if (cs == null) {
        return null;
    }
    int strLen;
    if ((strLen = cs.length()) == 0) {
        return cs.toString();
    }
    return new StringBuilder(strLen).append(Character.toTitleCase(cs.charAt(0))).append(CharSequenceUtils.subSequence(cs, 1)).toString();
}","public void test339380() throws Throwable {
    String string0 = StringUtils.capitalize(""F"");
    assertNotNull(string0);
}","/**
 * <p>Capitalizes a String changing the first letter to title case as
 * per {@link Character#toTitleCase(char)}. No other letters are changed.</p>
 *
 * <p>For a word based algorithm, see {@link WordUtils#capitalize(String)}.
 * A <code>null</code> input String returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.capitalize(null)  = null
 * StringUtils.capitalize("""")    = """"
 * StringUtils.capitalize(""cat"") = ""Cat""
 * StringUtils.capitalize(""cAt"") = ""CAt""
 * </pre>
 *
 * @param cs the String to capitalize, may be null
 * @return the capitalized String, <code>null</code> if null String input
 * @see WordUtils#capitalize(String)
 * @see #uncapitalize(String)
 * @since 2.0
 */"
"public static String capitalize(CharSequence cs) {
    if (cs == null) {
        return null;
    }
    int strLen;
    if ((strLen = cs.length()) == 0) {
        return cs.toString();
    }
    return new StringBuilder(strLen).append(Character.toTitleCase(cs.charAt(0))).append(CharSequenceUtils.subSequence(cs, 1)).toString();
}","public void test340382() throws Throwable {
    String string0 = StringUtils.capitalize((CharSequence) null);
    assertNull(string0);
}","/**
 * <p>Capitalizes a String changing the first letter to title case as
 * per {@link Character#toTitleCase(char)}. No other letters are changed.</p>
 *
 * <p>For a word based algorithm, see {@link WordUtils#capitalize(String)}.
 * A <code>null</code> input String returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.capitalize(null)  = null
 * StringUtils.capitalize("""")    = """"
 * StringUtils.capitalize(""cat"") = ""Cat""
 * StringUtils.capitalize(""cAt"") = ""CAt""
 * </pre>
 *
 * @param cs the String to capitalize, may be null
 * @return the capitalized String, <code>null</code> if null String input
 * @see WordUtils#capitalize(String)
 * @see #uncapitalize(String)
 * @since 2.0
 */"
"public static String capitalize(CharSequence cs) {
    if (cs == null) {
        return null;
    }
    int strLen;
    if ((strLen = cs.length()) == 0) {
        return cs.toString();
    }
    return new StringBuilder(strLen).append(Character.toTitleCase(cs.charAt(0))).append(CharSequenceUtils.subSequence(cs, 1)).toString();
}","public void test341383() throws Throwable {
    String string0 = StringUtils.capitalize("""");
    assertEquals("""", string0);
}","/**
 * <p>Capitalizes a String changing the first letter to title case as
 * per {@link Character#toTitleCase(char)}. No other letters are changed.</p>
 *
 * <p>For a word based algorithm, see {@link WordUtils#capitalize(String)}.
 * A <code>null</code> input String returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.capitalize(null)  = null
 * StringUtils.capitalize("""")    = """"
 * StringUtils.capitalize(""cat"") = ""Cat""
 * StringUtils.capitalize(""cAt"") = ""CAt""
 * </pre>
 *
 * @param cs the String to capitalize, may be null
 * @return the capitalized String, <code>null</code> if null String input
 * @see WordUtils#capitalize(String)
 * @see #uncapitalize(String)
 * @since 2.0
 */"
"public static String uncapitalize(CharSequence cs) {
    if (cs == null) {
        return null;
    }
    int strLen;
    if ((strLen = cs.length()) == 0) {
        return cs.toString();
    }
    return new StringBuilder(strLen).append(Character.toLowerCase(cs.charAt(0))).append(CharSequenceUtils.subSequence(cs, 1)).toString();
}","public void test342384() throws Throwable {
    String string0 = StringUtils.uncapitalize(""illegalaUccb6v~i\""v$.%  occured duricopatcodel*irbn5code"");
    assertEquals(""illegalaUccb6v~i\""v$.%  occured duricopatcodel*irbn5code"", string0);
}","/**
 * <p>Uncapitalizes a CharSequence changing the first letter to title case as
 * per {@link Character#toLowerCase(char)}. No other letters are changed.</p>
 *
 * <p>For a word based algorithm, see {@link WordUtils#uncapitalize(String)}.
 * A <code>null</code> input String returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.uncapitalize(null)  = null
 * StringUtils.uncapitalize("""")    = """"
 * StringUtils.uncapitalize(""Cat"") = ""cat""
 * StringUtils.uncapitalize(""CAT"") = ""cAT""
 * </pre>
 *
 * @param cs the String to uncapitalize, may be null
 * @return the uncapitalized String, <code>null</code> if null String input
 * @see WordUtils#uncapitalize(String)
 * @see #capitalize(CharSequence)
 * @since 2.0
 */"
"public static String uncapitalize(CharSequence cs) {
    if (cs == null) {
        return null;
    }
    int strLen;
    if ((strLen = cs.length()) == 0) {
        return cs.toString();
    }
    return new StringBuilder(strLen).append(Character.toLowerCase(cs.charAt(0))).append(CharSequenceUtils.subSequence(cs, 1)).toString();
}","public void test343386() throws Throwable {
    String string0 = StringUtils.uncapitalize((CharSequence) null);
    assertNull(string0);
}","/**
 * <p>Uncapitalizes a CharSequence changing the first letter to title case as
 * per {@link Character#toLowerCase(char)}. No other letters are changed.</p>
 *
 * <p>For a word based algorithm, see {@link WordUtils#uncapitalize(String)}.
 * A <code>null</code> input String returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.uncapitalize(null)  = null
 * StringUtils.uncapitalize("""")    = """"
 * StringUtils.uncapitalize(""Cat"") = ""cat""
 * StringUtils.uncapitalize(""CAT"") = ""cAT""
 * </pre>
 *
 * @param cs the String to uncapitalize, may be null
 * @return the uncapitalized String, <code>null</code> if null String input
 * @see WordUtils#uncapitalize(String)
 * @see #capitalize(CharSequence)
 * @since 2.0
 */"
"public static String uncapitalize(CharSequence cs) {
    if (cs == null) {
        return null;
    }
    int strLen;
    if ((strLen = cs.length()) == 0) {
        return cs.toString();
    }
    return new StringBuilder(strLen).append(Character.toLowerCase(cs.charAt(0))).append(CharSequenceUtils.subSequence(cs, 1)).toString();
}","public void test344387() throws Throwable {
    String string0 = StringUtils.uncapitalize("""");
    assertEquals("""", string0);
}","/**
 * <p>Uncapitalizes a CharSequence changing the first letter to title case as
 * per {@link Character#toLowerCase(char)}. No other letters are changed.</p>
 *
 * <p>For a word based algorithm, see {@link WordUtils#uncapitalize(String)}.
 * A <code>null</code> input String returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.uncapitalize(null)  = null
 * StringUtils.uncapitalize("""")    = """"
 * StringUtils.uncapitalize(""Cat"") = ""cat""
 * StringUtils.uncapitalize(""CAT"") = ""cAT""
 * </pre>
 *
 * @param cs the String to uncapitalize, may be null
 * @return the uncapitalized String, <code>null</code> if null String input
 * @see WordUtils#uncapitalize(String)
 * @see #capitalize(CharSequence)
 * @since 2.0
 */"
"public static String swapCase(String str) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    StringBuilder buffer = new StringBuilder(strLen);
    char ch = 0;
    for (int i = 0; i < strLen; i++) {
        ch = str.charAt(i);
        if (Character.isUpperCase(ch)) {
            ch = Character.toLowerCase(ch);
        } else if (Character.isTitleCase(ch)) {
            ch = Character.toLowerCase(ch);
        } else if (Character.isLowerCase(ch)) {
            ch = Character.toUpperCase(ch);
        }
        buffer.append(ch);
    }
    return buffer.toString();
}","public void test345388() throws Throwable {
    String string0 = StringUtils.swapCase((String) null);
    assertNull(string0);
}","/**
 * <p>Swaps the case of a String changing upper and title case to
 * lower case, and lower case to upper case.</p>
 *
 * <ul>
 *  <li>Upper case character converts to Lower case</li>
 *  <li>Title case character converts to Lower case</li>
 *  <li>Lower case character converts to Upper case</li>
 * </ul>
 *
 * <p>For a word based algorithm, see {@link WordUtils#swapCase(String)}.
 * A <code>null</code> input String returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.swapCase(null)                 = null
 * StringUtils.swapCase("""")                   = """"
 * StringUtils.swapCase(""The dog has a BONE"") = ""tHE DOG HAS A bone""
 * </pre>
 *
 * <p>NOTE: This method changed in Lang version 2.0.
 * It no longer performs a word based algorithm.
 * If you only use ASCII, you will notice no change.
 * That functionality is available in WordUtils.</p>
 *
 * @param str  the String to swap case, may be null
 * @return the changed String, <code>null</code> if null String input
 */"
"public static String swapCase(String str) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    StringBuilder buffer = new StringBuilder(strLen);
    char ch = 0;
    for (int i = 0; i < strLen; i++) {
        ch = str.charAt(i);
        if (Character.isUpperCase(ch)) {
            ch = Character.toLowerCase(ch);
        } else if (Character.isTitleCase(ch)) {
            ch = Character.toLowerCase(ch);
        } else if (Character.isLowerCase(ch)) {
            ch = Character.toUpperCase(ch);
        }
        buffer.append(ch);
    }
    return buffer.toString();
}","public void test346389() throws Throwable {
    String string0 = StringUtils.swapCase("""");
    assertEquals("""", string0);
}","/**
 * <p>Swaps the case of a String changing upper and title case to
 * lower case, and lower case to upper case.</p>
 *
 * <ul>
 *  <li>Upper case character converts to Lower case</li>
 *  <li>Title case character converts to Lower case</li>
 *  <li>Lower case character converts to Upper case</li>
 * </ul>
 *
 * <p>For a word based algorithm, see {@link WordUtils#swapCase(String)}.
 * A <code>null</code> input String returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.swapCase(null)                 = null
 * StringUtils.swapCase("""")                   = """"
 * StringUtils.swapCase(""The dog has a BONE"") = ""tHE DOG HAS A bone""
 * </pre>
 *
 * <p>NOTE: This method changed in Lang version 2.0.
 * It no longer performs a word based algorithm.
 * If you only use ASCII, you will notice no change.
 * That functionality is available in WordUtils.</p>
 *
 * @param str  the String to swap case, may be null
 * @return the changed String, <code>null</code> if null String input
 */"
"public static String swapCase(String str) {
    int strLen;
    if (str == null || (strLen = str.length()) == 0) {
        return str;
    }
    StringBuilder buffer = new StringBuilder(strLen);
    char ch = 0;
    for (int i = 0; i < strLen; i++) {
        ch = str.charAt(i);
        if (Character.isUpperCase(ch)) {
            ch = Character.toLowerCase(ch);
        } else if (Character.isTitleCase(ch)) {
            ch = Character.toLowerCase(ch);
        } else if (Character.isLowerCase(ch)) {
            ch = Character.toUpperCase(ch);
        }
        buffer.append(ch);
    }
    return buffer.toString();
}","public void test347390() throws Throwable {
    String string0 = StringUtils.swapCase(""P9%~l}\""F==6"");
    assertEquals(""p9%~L}\""f==6"", string0);
}","/**
 * <p>Swaps the case of a String changing upper and title case to
 * lower case, and lower case to upper case.</p>
 *
 * <ul>
 *  <li>Upper case character converts to Lower case</li>
 *  <li>Title case character converts to Lower case</li>
 *  <li>Lower case character converts to Upper case</li>
 * </ul>
 *
 * <p>For a word based algorithm, see {@link WordUtils#swapCase(String)}.
 * A <code>null</code> input String returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.swapCase(null)                 = null
 * StringUtils.swapCase("""")                   = """"
 * StringUtils.swapCase(""The dog has a BONE"") = ""tHE DOG HAS A bone""
 * </pre>
 *
 * <p>NOTE: This method changed in Lang version 2.0.
 * It no longer performs a word based algorithm.
 * If you only use ASCII, you will notice no change.
 * That functionality is available in WordUtils.</p>
 *
 * @param str  the String to swap case, may be null
 * @return the changed String, <code>null</code> if null String input
 */"
"// Count matches
//-----------------------------------------------------------------------
/**
 * <p>Counts how many times the substring appears in the larger String.</p>
 *
 * <p>A <code>null</code> or empty ("""") String input returns <code>0</code>.</p>
 *
 * <pre>
 * StringUtils.countMatches(null, *)       = 0
 * StringUtils.countMatches("""", *)         = 0
 * StringUtils.countMatches(""abba"", null)  = 0
 * StringUtils.countMatches(""abba"", """")    = 0
 * StringUtils.countMatches(""abba"", ""a"")   = 2
 * StringUtils.countMatches(""abba"", ""ab"")  = 1
 * StringUtils.countMatches(""abba"", ""xxx"") = 0
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param sub  the substring to count, may be null
 * @return the number of occurrences, 0 if either String is <code>null</code>
 */
public static int countMatches(String str, String sub) {
    if (isEmpty(str) || isEmpty(sub)) {
        return 0;
    }
    int count = 0;
    int idx = 0;
    while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) {
        count++;
        idx += sub.length();
    }
    return count;
}","public void test348391() throws Throwable {
    int int0 = StringUtils.countMatches((String) null, (String) null);
    assertEquals(0, int0);
}",""
"// Count matches
//-----------------------------------------------------------------------
/**
 * <p>Counts how many times the substring appears in the larger String.</p>
 *
 * <p>A <code>null</code> or empty ("""") String input returns <code>0</code>.</p>
 *
 * <pre>
 * StringUtils.countMatches(null, *)       = 0
 * StringUtils.countMatches("""", *)         = 0
 * StringUtils.countMatches(""abba"", null)  = 0
 * StringUtils.countMatches(""abba"", """")    = 0
 * StringUtils.countMatches(""abba"", ""a"")   = 2
 * StringUtils.countMatches(""abba"", ""ab"")  = 1
 * StringUtils.countMatches(""abba"", ""xxx"") = 0
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param sub  the substring to count, may be null
 * @return the number of occurrences, 0 if either String is <code>null</code>
 */
public static int countMatches(String str, String sub) {
    if (isEmpty(str) || isEmpty(sub)) {
        return 0;
    }
    int count = 0;
    int idx = 0;
    while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) {
        count++;
        idx += sub.length();
    }
    return count;
}","public void test349392() throws Throwable {
    int int0 = StringUtils.countMatches(""|Na"", ""|Na"");
    assertEquals(1, int0);
}",""
"// Count matches
//-----------------------------------------------------------------------
/**
 * <p>Counts how many times the substring appears in the larger String.</p>
 *
 * <p>A <code>null</code> or empty ("""") String input returns <code>0</code>.</p>
 *
 * <pre>
 * StringUtils.countMatches(null, *)       = 0
 * StringUtils.countMatches("""", *)         = 0
 * StringUtils.countMatches(""abba"", null)  = 0
 * StringUtils.countMatches(""abba"", """")    = 0
 * StringUtils.countMatches(""abba"", ""a"")   = 2
 * StringUtils.countMatches(""abba"", ""ab"")  = 1
 * StringUtils.countMatches(""abba"", ""xxx"") = 0
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param sub  the substring to count, may be null
 * @return the number of occurrences, 0 if either String is <code>null</code>
 */
public static int countMatches(String str, String sub) {
    if (isEmpty(str) || isEmpty(sub)) {
        return 0;
    }
    int count = 0;
    int idx = 0;
    while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) {
        count++;
        idx += sub.length();
    }
    return count;
}","public void test350393() throws Throwable {
    int int0 = StringUtils.countMatches(""{NUN`+E-"", (String) null);
    assertEquals(0, int0);
}",""
"// Character Tests
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains only unicode letters.</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty CharSequence (length()=0) will return <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.isAlpha(null)   = false
 * StringUtils.isAlpha("""")     = true
 * StringUtils.isAlpha(""  "")   = false
 * StringUtils.isAlpha(""abc"")  = true
 * StringUtils.isAlpha(""ab2c"") = false
 * StringUtils.isAlpha(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if only contains letters, and is non-null
 */
public static boolean isAlpha(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isLetter(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test351394() throws Throwable {
    boolean boolean0 = StringUtils.isAlpha((CharSequence) null);
    assertFalse(boolean0);
}",""
"// Character Tests
//-----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains only unicode letters.</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty CharSequence (length()=0) will return <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.isAlpha(null)   = false
 * StringUtils.isAlpha("""")     = true
 * StringUtils.isAlpha(""  "")   = false
 * StringUtils.isAlpha(""abc"")  = true
 * StringUtils.isAlpha(""ab2c"") = false
 * StringUtils.isAlpha(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if only contains letters, and is non-null
 */
public static boolean isAlpha(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isLetter(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test352395() throws Throwable {
    boolean boolean0 = StringUtils.isAlpha(""VeUju"");
    assertTrue(boolean0);
}",""
"public static boolean isAlphaSpace(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {
            return false;
        }
    }
    return true;
}","public void test353396() throws Throwable {
    boolean boolean0 = StringUtils.isAlphaSpace("""");
    assertTrue(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only unicode letters and
 * space (' ').</p>
 *
 * <p><code>null</code> will return <code>false</code>
 * An empty CharSequence (length()=0) will return <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.isAlphaSpace(null)   = false
 * StringUtils.isAlphaSpace("""")     = true
 * StringUtils.isAlphaSpace(""  "")   = true
 * StringUtils.isAlphaSpace(""abc"")  = true
 * StringUtils.isAlphaSpace(""ab c"") = true
 * StringUtils.isAlphaSpace(""ab2c"") = false
 * StringUtils.isAlphaSpace(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if only contains letters and space,
 *  and is non-null
 */"
"public static boolean isAlphaSpace(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {
            return false;
        }
    }
    return true;
}","public void test354397() throws Throwable {
    boolean boolean0 = StringUtils.isAlphaSpace((CharSequence) null);
    assertFalse(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only unicode letters and
 * space (' ').</p>
 *
 * <p><code>null</code> will return <code>false</code>
 * An empty CharSequence (length()=0) will return <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.isAlphaSpace(null)   = false
 * StringUtils.isAlphaSpace("""")     = true
 * StringUtils.isAlphaSpace(""  "")   = true
 * StringUtils.isAlphaSpace(""abc"")  = true
 * StringUtils.isAlphaSpace(""ab c"") = true
 * StringUtils.isAlphaSpace(""ab2c"") = false
 * StringUtils.isAlphaSpace(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if only contains letters and space,
 *  and is non-null
 */"
"public static boolean isAlphaSpace(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if ((Character.isLetter(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {
            return false;
        }
    }
    return true;
}","public void test355398() throws Throwable {
    boolean boolean0 = StringUtils.isAlphaSpace(""                                                                                                                                                                                                                                                                                                                                                                                                              Itj/P)889}K _GCSG                                                                                                                                                                                                                                                                                                                                                                                                               "");
    assertFalse(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only unicode letters and
 * space (' ').</p>
 *
 * <p><code>null</code> will return <code>false</code>
 * An empty CharSequence (length()=0) will return <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.isAlphaSpace(null)   = false
 * StringUtils.isAlphaSpace("""")     = true
 * StringUtils.isAlphaSpace(""  "")   = true
 * StringUtils.isAlphaSpace(""abc"")  = true
 * StringUtils.isAlphaSpace(""ab c"") = true
 * StringUtils.isAlphaSpace(""ab2c"") = false
 * StringUtils.isAlphaSpace(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if only contains letters and space,
 *  and is non-null
 */"
"public static boolean isAlphanumeric(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isLetterOrDigit(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test356399() throws Throwable {
    boolean boolean0 = StringUtils.isAlphanumeric("""");
    assertTrue(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only unicode letters or digits.</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty CharSequence (length()=0) will return <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.isAlphanumeric(null)   = false
 * StringUtils.isAlphanumeric("""")     = true
 * StringUtils.isAlphanumeric(""  "")   = false
 * StringUtils.isAlphanumeric(""abc"")  = true
 * StringUtils.isAlphanumeric(""ab c"") = false
 * StringUtils.isAlphanumeric(""ab2c"") = true
 * StringUtils.isAlphanumeric(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if only contains letters or digits,
 *  and is non-null
 */"
"public static boolean isAlphanumeric(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isLetterOrDigit(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test357400() throws Throwable {
    boolean boolean0 = StringUtils.isAlphanumeric((CharSequence) null);
    assertFalse(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only unicode letters or digits.</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty CharSequence (length()=0) will return <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.isAlphanumeric(null)   = false
 * StringUtils.isAlphanumeric("""")     = true
 * StringUtils.isAlphanumeric(""  "")   = false
 * StringUtils.isAlphanumeric(""abc"")  = true
 * StringUtils.isAlphanumeric(""ab c"") = false
 * StringUtils.isAlphanumeric(""ab2c"") = true
 * StringUtils.isAlphanumeric(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if only contains letters or digits,
 *  and is non-null
 */"
"public static boolean isAlphanumeric(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isLetterOrDigit(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test358401() throws Throwable {
    boolean boolean0 = StringUtils.isAlphanumeric(""searchScannot pad a negative amount: t match: "");
    assertFalse(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only unicode letters or digits.</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty CharSequence (length()=0) will return <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.isAlphanumeric(null)   = false
 * StringUtils.isAlphanumeric("""")     = true
 * StringUtils.isAlphanumeric(""  "")   = false
 * StringUtils.isAlphanumeric(""abc"")  = true
 * StringUtils.isAlphanumeric(""ab c"") = false
 * StringUtils.isAlphanumeric(""ab2c"") = true
 * StringUtils.isAlphanumeric(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if only contains letters or digits,
 *  and is non-null
 */"
"public static boolean isAlphanumericSpace(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {
            return false;
        }
    }
    return true;
}","public void test359402() throws Throwable {
    boolean boolean0 = StringUtils.isAlphanumericSpace(""4g?#Fut]=bKow"");
    assertFalse(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only unicode letters, digits
 * or space (<code>' '</code>).</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty CharSequence (length()=0) will return <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.isAlphanumeric(null)   = false
 * StringUtils.isAlphanumeric("""")     = true
 * StringUtils.isAlphanumeric(""  "")   = true
 * StringUtils.isAlphanumeric(""abc"")  = true
 * StringUtils.isAlphanumeric(""ab c"") = true
 * StringUtils.isAlphanumeric(""ab2c"") = true
 * StringUtils.isAlphanumeric(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if only contains letters, digits or space,
 *  and is non-null
 */"
"public static boolean isAlphanumericSpace(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {
            return false;
        }
    }
    return true;
}","public void test360403() throws Throwable {
    boolean boolean0 = StringUtils.isAlphanumericSpace((CharSequence) null);
    assertFalse(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only unicode letters, digits
 * or space (<code>' '</code>).</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty CharSequence (length()=0) will return <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.isAlphanumeric(null)   = false
 * StringUtils.isAlphanumeric("""")     = true
 * StringUtils.isAlphanumeric(""  "")   = true
 * StringUtils.isAlphanumeric(""abc"")  = true
 * StringUtils.isAlphanumeric(""ab c"") = true
 * StringUtils.isAlphanumeric(""ab2c"") = true
 * StringUtils.isAlphanumeric(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if only contains letters, digits or space,
 *  and is non-null
 */"
"public static boolean isAlphanumericSpace(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if ((Character.isLetterOrDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {
            return false;
        }
    }
    return true;
}","public void test361404() throws Throwable {
    boolean boolean0 = StringUtils.isAlphanumericSpace(""TimeToLive of "");
    assertTrue(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only unicode letters, digits
 * or space (<code>' '</code>).</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty CharSequence (length()=0) will return <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.isAlphanumeric(null)   = false
 * StringUtils.isAlphanumeric("""")     = true
 * StringUtils.isAlphanumeric(""  "")   = true
 * StringUtils.isAlphanumeric(""abc"")  = true
 * StringUtils.isAlphanumeric(""ab c"") = true
 * StringUtils.isAlphanumeric(""ab2c"") = true
 * StringUtils.isAlphanumeric(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if only contains letters, digits or space,
 *  and is non-null
 */"
"public static boolean isAsciiPrintable(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test362405() throws Throwable {
    boolean boolean0 = StringUtils.isAsciiPrintable(""-s<R|!"");
    assertTrue(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only ASCII printable characters.</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty CharSequence (length()=0) will return <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.isAsciiPrintable(null)     = false
 * StringUtils.isAsciiPrintable("""")       = true
 * StringUtils.isAsciiPrintable("" "")      = true
 * StringUtils.isAsciiPrintable(""Ceki"")   = true
 * StringUtils.isAsciiPrintable(""ab2c"")   = true
 * StringUtils.isAsciiPrintable(""!ab-c~"") = true
 * StringUtils.isAsciiPrintable(""\u0020"") = true
 * StringUtils.isAsciiPrintable(""\u0021"") = true
 * StringUtils.isAsciiPrintable(""\u007e"") = true
 * StringUtils.isAsciiPrintable(""\u007f"") = false
 * StringUtils.isAsciiPrintable(""Ceki G\u00fclc\u00fc"") = false
 * </pre>
 *
 * @param cs the CharSequence to check, may be null
 * @return <code>true</code> if every character is in the range
 *  32 thru 126
 * @since 2.1
 */"
"public static boolean isAsciiPrintable(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test363406() throws Throwable {
    boolean boolean0 = StringUtils.isAsciiPrintable((CharSequence) null);
    assertFalse(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only ASCII printable characters.</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty CharSequence (length()=0) will return <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.isAsciiPrintable(null)     = false
 * StringUtils.isAsciiPrintable("""")       = true
 * StringUtils.isAsciiPrintable("" "")      = true
 * StringUtils.isAsciiPrintable(""Ceki"")   = true
 * StringUtils.isAsciiPrintable(""ab2c"")   = true
 * StringUtils.isAsciiPrintable(""!ab-c~"") = true
 * StringUtils.isAsciiPrintable(""\u0020"") = true
 * StringUtils.isAsciiPrintable(""\u0021"") = true
 * StringUtils.isAsciiPrintable(""\u007e"") = true
 * StringUtils.isAsciiPrintable(""\u007f"") = false
 * StringUtils.isAsciiPrintable(""Ceki G\u00fclc\u00fc"") = false
 * </pre>
 *
 * @param cs the CharSequence to check, may be null
 * @return <code>true</code> if every character is in the range
 *  32 thru 126
 * @since 2.1
 */"
"public static boolean isAsciiPrintable(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (CharUtils.isAsciiPrintable(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test364407() throws Throwable {
    boolean boolean0 = StringUtils.isAsciiPrintable(""=Xz2T~H^TxO3~pKion width is 4"");
    assertFalse(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only ASCII printable characters.</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty CharSequence (length()=0) will return <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.isAsciiPrintable(null)     = false
 * StringUtils.isAsciiPrintable("""")       = true
 * StringUtils.isAsciiPrintable("" "")      = true
 * StringUtils.isAsciiPrintable(""Ceki"")   = true
 * StringUtils.isAsciiPrintable(""ab2c"")   = true
 * StringUtils.isAsciiPrintable(""!ab-c~"") = true
 * StringUtils.isAsciiPrintable(""\u0020"") = true
 * StringUtils.isAsciiPrintable(""\u0021"") = true
 * StringUtils.isAsciiPrintable(""\u007e"") = true
 * StringUtils.isAsciiPrintable(""\u007f"") = false
 * StringUtils.isAsciiPrintable(""Ceki G\u00fclc\u00fc"") = false
 * </pre>
 *
 * @param cs the CharSequence to check, may be null
 * @return <code>true</code> if every character is in the range
 *  32 thru 126
 * @since 2.1
 */"
"public static boolean isNumeric(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isDigit(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test365408() throws Throwable {
    boolean boolean0 = StringUtils.isNumeric((CharSequence) null);
    assertFalse(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only unicode digits.
 * A decimal point is not a unicode digit and returns false.</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty CharSequence (length()=0) will return <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.isNumeric(null)   = false
 * StringUtils.isNumeric("""")     = true
 * StringUtils.isNumeric(""  "")   = false
 * StringUtils.isNumeric(""123"")  = true
 * StringUtils.isNumeric(""12 3"") = false
 * StringUtils.isNumeric(""ab2c"") = false
 * StringUtils.isNumeric(""12-3"") = false
 * StringUtils.isNumeric(""12.3"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if only contains digits, and is non-null
 */"
"public static boolean isNumeric(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isDigit(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test366409() throws Throwable {
    boolean boolean0 = StringUtils.isNumeric("""");
    assertTrue(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only unicode digits.
 * A decimal point is not a unicode digit and returns false.</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty CharSequence (length()=0) will return <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.isNumeric(null)   = false
 * StringUtils.isNumeric("""")     = true
 * StringUtils.isNumeric(""  "")   = false
 * StringUtils.isNumeric(""123"")  = true
 * StringUtils.isNumeric(""12 3"") = false
 * StringUtils.isNumeric(""ab2c"") = false
 * StringUtils.isNumeric(""12-3"") = false
 * StringUtils.isNumeric(""12.3"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if only contains digits, and is non-null
 */"
"public static boolean isNumeric(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isDigit(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test367410() throws Throwable {
    boolean boolean0 = StringUtils.isNumeric(""1?~(EVUP\""$3`Y[S;|"");
    assertFalse(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only unicode digits.
 * A decimal point is not a unicode digit and returns false.</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty CharSequence (length()=0) will return <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.isNumeric(null)   = false
 * StringUtils.isNumeric("""")     = true
 * StringUtils.isNumeric(""  "")   = false
 * StringUtils.isNumeric(""123"")  = true
 * StringUtils.isNumeric(""12 3"") = false
 * StringUtils.isNumeric(""ab2c"") = false
 * StringUtils.isNumeric(""12-3"") = false
 * StringUtils.isNumeric(""12.3"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if only contains digits, and is non-null
 */"
"public static boolean isNumericSpace(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {
            return false;
        }
    }
    return true;
}","public void test368411() throws Throwable {
    boolean boolean0 = StringUtils.isNumericSpace("" and replace array lengths don"");
    assertFalse(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only unicode digits or space
 * (<code>' '</code>).
 * A decimal point is not a unicode digit and returns false.</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty CharSequence (length()=0) will return <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.isNumeric(null)   = false
 * StringUtils.isNumeric("""")     = true
 * StringUtils.isNumeric(""  "")   = true
 * StringUtils.isNumeric(""123"")  = true
 * StringUtils.isNumeric(""12 3"") = true
 * StringUtils.isNumeric(""ab2c"") = false
 * StringUtils.isNumeric(""12-3"") = false
 * StringUtils.isNumeric(""12.3"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if only contains digits or space,
 *  and is non-null
 */"
"public static boolean isNumericSpace(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {
            return false;
        }
    }
    return true;
}","public void test369412() throws Throwable {
    boolean boolean0 = StringUtils.isNumericSpace((CharSequence) null);
    assertFalse(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only unicode digits or space
 * (<code>' '</code>).
 * A decimal point is not a unicode digit and returns false.</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty CharSequence (length()=0) will return <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.isNumeric(null)   = false
 * StringUtils.isNumeric("""")     = true
 * StringUtils.isNumeric(""  "")   = true
 * StringUtils.isNumeric(""123"")  = true
 * StringUtils.isNumeric(""12 3"") = true
 * StringUtils.isNumeric(""ab2c"") = false
 * StringUtils.isNumeric(""12-3"") = false
 * StringUtils.isNumeric(""12.3"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if only contains digits or space,
 *  and is non-null
 */"
"public static boolean isNumericSpace(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {
            return false;
        }
    }
    return true;
}","public void test370413() throws Throwable {
    boolean boolean0 = StringUtils.isNumericSpace("""");
    assertTrue(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only unicode digits or space
 * (<code>' '</code>).
 * A decimal point is not a unicode digit and returns false.</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty CharSequence (length()=0) will return <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.isNumeric(null)   = false
 * StringUtils.isNumeric("""")     = true
 * StringUtils.isNumeric(""  "")   = true
 * StringUtils.isNumeric(""123"")  = true
 * StringUtils.isNumeric(""12 3"") = true
 * StringUtils.isNumeric(""ab2c"") = false
 * StringUtils.isNumeric(""12-3"") = false
 * StringUtils.isNumeric(""12.3"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if only contains digits or space,
 *  and is non-null
 */"
"public static boolean isNumericSpace(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if ((Character.isDigit(cs.charAt(i)) == false) && (cs.charAt(i) != ' ')) {
            return false;
        }
    }
    return true;
}","public void test371414() throws Throwable {
    boolean boolean0 = StringUtils.isNumericSpace(""1r<%*:..$:@"");
    assertFalse(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only unicode digits or space
 * (<code>' '</code>).
 * A decimal point is not a unicode digit and returns false.</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty CharSequence (length()=0) will return <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.isNumeric(null)   = false
 * StringUtils.isNumeric("""")     = true
 * StringUtils.isNumeric(""  "")   = true
 * StringUtils.isNumeric(""123"")  = true
 * StringUtils.isNumeric(""12 3"") = true
 * StringUtils.isNumeric(""ab2c"") = false
 * StringUtils.isNumeric(""12-3"") = false
 * StringUtils.isNumeric(""12.3"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if only contains digits or space,
 *  and is non-null
 */"
"public static boolean isWhitespace(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if ((Character.isWhitespace(cs.charAt(i)) == false)) {
            return false;
        }
    }
    return true;
}","public void test372415() throws Throwable {
    boolean boolean0 = StringUtils.isWhitespace("""");
    assertTrue(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only whitespace.</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty CharSequence (length()=0) will return <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.isWhitespace(null)   = false
 * StringUtils.isWhitespace("""")     = true
 * StringUtils.isWhitespace(""  "")   = true
 * StringUtils.isWhitespace(""abc"")  = false
 * StringUtils.isWhitespace(""ab2c"") = false
 * StringUtils.isWhitespace(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if only contains whitespace, and is non-null
 * @since 2.0
 */"
"public static boolean isWhitespace(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if ((Character.isWhitespace(cs.charAt(i)) == false)) {
            return false;
        }
    }
    return true;
}","public void test373416() throws Throwable {
    boolean boolean0 = StringUtils.isWhitespace((CharSequence) null);
    assertFalse(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only whitespace.</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty CharSequence (length()=0) will return <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.isWhitespace(null)   = false
 * StringUtils.isWhitespace("""")     = true
 * StringUtils.isWhitespace(""  "")   = true
 * StringUtils.isWhitespace(""abc"")  = false
 * StringUtils.isWhitespace(""ab2c"") = false
 * StringUtils.isWhitespace(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if only contains whitespace, and is non-null
 * @since 2.0
 */"
"public static boolean isWhitespace(CharSequence cs) {
    if (cs == null) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if ((Character.isWhitespace(cs.charAt(i)) == false)) {
            return false;
        }
    }
    return true;
}","public void test374417() throws Throwable {
    boolean boolean0 = StringUtils.isWhitespace("" :tnuoma evitagen a dap tonnaC"");
    assertFalse(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only whitespace.</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty CharSequence (length()=0) will return <code>true</code>.</p>
 *
 * <pre>
 * StringUtils.isWhitespace(null)   = false
 * StringUtils.isWhitespace("""")     = true
 * StringUtils.isWhitespace(""  "")   = true
 * StringUtils.isWhitespace(""abc"")  = false
 * StringUtils.isWhitespace(""ab2c"") = false
 * StringUtils.isWhitespace(""ab-c"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if only contains whitespace, and is non-null
 * @since 2.0
 */"
"public static boolean isAllLowerCase(CharSequence cs) {
    if (cs == null || isEmpty(cs)) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isLowerCase(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test375418() throws Throwable {
    boolean boolean0 = StringUtils.isAllLowerCase((CharSequence) null);
    assertFalse(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only lowercase characters.</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty CharSequence (length()=0) will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.isAllLowerCase(null)   = false
 * StringUtils.isAllLowerCase("""")     = false
 * StringUtils.isAllLowerCase(""  "")   = false
 * StringUtils.isAllLowerCase(""abc"")  = true
 * StringUtils.isAllLowerCase(""abC"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if only contains lowercase characters, and is non-null
 * @since 2.5
 */"
"public static boolean isAllLowerCase(CharSequence cs) {
    if (cs == null || isEmpty(cs)) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isLowerCase(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test376419() throws Throwable {
    boolean boolean0 = StringUtils.isAllLowerCase(""<6hV)z5xkC\""`I`0"");
    assertFalse(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only lowercase characters.</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty CharSequence (length()=0) will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.isAllLowerCase(null)   = false
 * StringUtils.isAllLowerCase("""")     = false
 * StringUtils.isAllLowerCase(""  "")   = false
 * StringUtils.isAllLowerCase(""abc"")  = true
 * StringUtils.isAllLowerCase(""abC"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if only contains lowercase characters, and is non-null
 * @since 2.5
 */"
"public static boolean isAllLowerCase(CharSequence cs) {
    if (cs == null || isEmpty(cs)) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isLowerCase(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test377420() throws Throwable {
    boolean boolean0 = StringUtils.isAllLowerCase("""");
    assertFalse(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only lowercase characters.</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty CharSequence (length()=0) will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.isAllLowerCase(null)   = false
 * StringUtils.isAllLowerCase("""")     = false
 * StringUtils.isAllLowerCase(""  "")   = false
 * StringUtils.isAllLowerCase(""abc"")  = true
 * StringUtils.isAllLowerCase(""abC"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if only contains lowercase characters, and is non-null
 * @since 2.5
 */"
"public static boolean isAllLowerCase(CharSequence cs) {
    if (cs == null || isEmpty(cs)) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isLowerCase(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test378421() throws Throwable {
    boolean boolean0 = StringUtils.isAllLowerCase(""g"");
    assertTrue(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only lowercase characters.</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty CharSequence (length()=0) will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.isAllLowerCase(null)   = false
 * StringUtils.isAllLowerCase("""")     = false
 * StringUtils.isAllLowerCase(""  "")   = false
 * StringUtils.isAllLowerCase(""abc"")  = true
 * StringUtils.isAllLowerCase(""abC"") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return <code>true</code> if only contains lowercase characters, and is non-null
 * @since 2.5
 */"
"public static boolean isAllUpperCase(CharSequence cs) {
    if (cs == null || isEmpty(cs)) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isUpperCase(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test379422() throws Throwable {
    boolean boolean0 = StringUtils.isAllUpperCase((CharSequence) null);
    assertFalse(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only uppercase characters.</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty String (length()=0) will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.isAllUpperCase(null)   = false
 * StringUtils.isAllUpperCase("""")     = false
 * StringUtils.isAllUpperCase(""  "")   = false
 * StringUtils.isAllUpperCase(""ABC"")  = true
 * StringUtils.isAllUpperCase(""aBC"") = false
 * </pre>
 *
 * @param cs the CharSequence to check, may be null
 * @return <code>true</code> if only contains uppercase characters, and is non-null
 * @since 2.5
 */"
"public static boolean isAllUpperCase(CharSequence cs) {
    if (cs == null || isEmpty(cs)) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isUpperCase(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test380423() throws Throwable {
    boolean boolean0 = StringUtils.isAllUpperCase("""");
    assertFalse(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only uppercase characters.</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty String (length()=0) will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.isAllUpperCase(null)   = false
 * StringUtils.isAllUpperCase("""")     = false
 * StringUtils.isAllUpperCase(""  "")   = false
 * StringUtils.isAllUpperCase(""ABC"")  = true
 * StringUtils.isAllUpperCase(""aBC"") = false
 * </pre>
 *
 * @param cs the CharSequence to check, may be null
 * @return <code>true</code> if only contains uppercase characters, and is non-null
 * @since 2.5
 */"
"public static boolean isAllUpperCase(CharSequence cs) {
    if (cs == null || isEmpty(cs)) {
        return false;
    }
    int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (Character.isUpperCase(cs.charAt(i)) == false) {
            return false;
        }
    }
    return true;
}","public void test381424() throws Throwable {
    boolean boolean0 = StringUtils.isAllUpperCase(""M"");
    assertTrue(boolean0);
}","/**
 * <p>Checks if the CharSequence contains only uppercase characters.</p>
 *
 * <p><code>null</code> will return <code>false</code>.
 * An empty String (length()=0) will return <code>false</code>.</p>
 *
 * <pre>
 * StringUtils.isAllUpperCase(null)   = false
 * StringUtils.isAllUpperCase("""")     = false
 * StringUtils.isAllUpperCase(""  "")   = false
 * StringUtils.isAllUpperCase(""ABC"")  = true
 * StringUtils.isAllUpperCase(""aBC"") = false
 * </pre>
 *
 * @param cs the CharSequence to check, may be null
 * @return <code>true</code> if only contains uppercase characters, and is non-null
 * @since 2.5
 */"
"// Defaults
//-----------------------------------------------------------------------
/**
 * <p>Returns either the passed in String,
 * or if the String is <code>null</code>, an empty String ("""").</p>
 *
 * <pre>
 * StringUtils.defaultString(null)  = """"
 * StringUtils.defaultString("""")    = """"
 * StringUtils.defaultString(""bat"") = ""bat""
 * </pre>
 *
 * @see ObjectUtils#toString(Object)
 * @see String#valueOf(Object)
 * @param str  the String to check, may be null
 * @return the passed in String, or the empty String if it
 *  was <code>null</code>
 */
public static String defaultString(String str) {
    return str == null ? EMPTY : str;
}","public void test382425() throws Throwable {
    String string0 = StringUtils.defaultString(""search cannot pad a negative amount: t match: "");
    assertEquals(""search cannot pad a negative amount: t match: "", string0);
}",""
"// Defaults
//-----------------------------------------------------------------------
/**
 * <p>Returns either the passed in String,
 * or if the String is <code>null</code>, an empty String ("""").</p>
 *
 * <pre>
 * StringUtils.defaultString(null)  = """"
 * StringUtils.defaultString("""")    = """"
 * StringUtils.defaultString(""bat"") = ""bat""
 * </pre>
 *
 * @see ObjectUtils#toString(Object)
 * @see String#valueOf(Object)
 * @param str  the String to check, may be null
 * @return the passed in String, or the empty String if it
 *  was <code>null</code>
 */
public static String defaultString(String str) {
    return str == null ? EMPTY : str;
}","public void test383426() throws Throwable {
    String string0 = StringUtils.defaultString((String) null);
    assertEquals("""", string0);
}",""
"public static String defaultString(String str, String defaultStr) {
    return str == null ? defaultStr : str;
}","public void test384427() throws Throwable {
    String string0 = StringUtils.defaultString(""x,LJ`sU"", (String) null);
    assertNotNull(string0);
}","/**
 * <p>Returns either the passed in String, or if the String is
 * <code>null</code>, the value of <code>defaultStr</code>.</p>
 *
 * <pre>
 * StringUtils.defaultString(null, ""NULL"")  = ""NULL""
 * StringUtils.defaultString("""", ""NULL"")    = """"
 * StringUtils.defaultString(""bat"", ""NULL"") = ""bat""
 * </pre>
 *
 * @see ObjectUtils#toString(Object,String)
 * @see String#valueOf(Object)
 * @param str  the String to check, may be null
 * @param defaultStr  the default String to return
 *  if the input is <code>null</code>, may be null
 * @return the passed in String, or the default if it was <code>null</code>
 */"
"public static String defaultString(String str, String defaultStr) {
    return str == null ? defaultStr : str;
}","public void test385429() throws Throwable {
    String string0 = StringUtils.defaultString((String) null, (String) null);
    assertNull(string0);
}","/**
 * <p>Returns either the passed in String, or if the String is
 * <code>null</code>, the value of <code>defaultStr</code>.</p>
 *
 * <pre>
 * StringUtils.defaultString(null, ""NULL"")  = ""NULL""
 * StringUtils.defaultString("""", ""NULL"")    = """"
 * StringUtils.defaultString(""bat"", ""NULL"") = ""bat""
 * </pre>
 *
 * @see ObjectUtils#toString(Object,String)
 * @see String#valueOf(Object)
 * @param str  the String to check, may be null
 * @param defaultStr  the default String to return
 *  if the input is <code>null</code>, may be null
 * @return the passed in String, or the default if it was <code>null</code>
 */"
"public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) {
    return StringUtils.isEmpty(str) ? defaultStr : str;
}","public void test386430() throws Throwable {
    String string0 = StringUtils.rightPad(""cc6V~i\""V$.% "", 4156, ""n  lU*so0YbH"");
    CharSequence charSequence0 = StringUtils.defaultIfEmpty((CharSequence) string0, (CharSequence) ""CqUNhrJr0;{'p,?"");
    assertNotNull(charSequence0);
}","/**
 * <p>Returns either the passed in CharSequence, or if the CharSequence is
 * empty or <code>null</code>, the value of <code>defaultStr</code>.</p>
 *
 * <pre>
 * StringUtils.defaultIfEmpty(null, ""NULL"")  = ""NULL""
 * StringUtils.defaultIfEmpty("""", ""NULL"")    = ""NULL""
 * StringUtils.defaultIfEmpty(""bat"", ""NULL"") = ""bat""
 * StringUtils.defaultIfEmpty("""", null)      = null
 * </pre>
 * @param <T> the specific kind of CharSequence
 * @param str  the CharSequence to check, may be null
 * @param defaultStr  the default CharSequence to return
 *  if the input is empty ("""") or <code>null</code>, may be null
 * @return the passed in CharSequence, or the default
 * @see StringUtils#defaultString(String, String)
 */"
"public static <T extends CharSequence> T defaultIfEmpty(T str, T defaultStr) {
    return StringUtils.isEmpty(str) ? defaultStr : str;
}","public void test387431() throws Throwable {
    CharSequence charSequence0 = StringUtils.defaultIfEmpty((CharSequence) null, (CharSequence) ""1IR`mR2MMLxzCaQi/oX"");
    assertEquals(""1IR`mR2MMLxzCaQi/oX"", charSequence0);
}","/**
 * <p>Returns either the passed in CharSequence, or if the CharSequence is
 * empty or <code>null</code>, the value of <code>defaultStr</code>.</p>
 *
 * <pre>
 * StringUtils.defaultIfEmpty(null, ""NULL"")  = ""NULL""
 * StringUtils.defaultIfEmpty("""", ""NULL"")    = ""NULL""
 * StringUtils.defaultIfEmpty(""bat"", ""NULL"") = ""bat""
 * StringUtils.defaultIfEmpty("""", null)      = null
 * </pre>
 * @param <T> the specific kind of CharSequence
 * @param str  the CharSequence to check, may be null
 * @param defaultStr  the default CharSequence to return
 *  if the input is empty ("""") or <code>null</code>, may be null
 * @return the passed in CharSequence, or the default
 * @see StringUtils#defaultString(String, String)
 */"
"// Reversing
//-----------------------------------------------------------------------
/**
 * <p>Reverses a String as per {@link StringBuilder#reverse()}.</p>
 *
 * <p>A <code>null</code> String returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.reverse(null)  = null
 * StringUtils.reverse("""")    = """"
 * StringUtils.reverse(""bat"") = ""tab""
 * </pre>
 *
 * @param str  the String to reverse, may be null
 * @return the reversed String, <code>null</code> if null String input
 */
public static String reverse(String str) {
    if (str == null) {
        return null;
    }
    return new StringBuilder(str).reverse().toString();
}","public void test388432() throws Throwable {
    String string0 = StringUtils.reverse(""c"");
    assertEquals(""c"", string0);
}",""
"// Reversing
//-----------------------------------------------------------------------
/**
 * <p>Reverses a String as per {@link StringBuilder#reverse()}.</p>
 *
 * <p>A <code>null</code> String returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.reverse(null)  = null
 * StringUtils.reverse("""")    = """"
 * StringUtils.reverse(""bat"") = ""tab""
 * </pre>
 *
 * @param str  the String to reverse, may be null
 * @return the reversed String, <code>null</code> if null String input
 */
public static String reverse(String str) {
    if (str == null) {
        return null;
    }
    return new StringBuilder(str).reverse().toString();
}","public void test389434() throws Throwable {
    String string0 = StringUtils.reverse((String) null);
    assertNull(string0);
}",""
"public static String reverseDelimited(String str, char separatorChar) {
    if (str == null) {
        return null;
    }
    // could implement manually, but simple way is to reuse other,
    // probably slower, methods.
    String[] strs = split(str, separatorChar);
    ArrayUtils.reverse(strs);
    return join(strs, separatorChar);
}","public void test390435() throws Throwable {
    String string0 = StringUtils.reverseDelimited((String) null, '3');
    assertNull(string0);
}","/**
 * <p>Reverses a String that is delimited by a specific character.</p>
 *
 * <p>The Strings between the delimiters are not reversed.
 * Thus java.lang.String becomes String.lang.java (if the delimiter
 * is <code>'.'</code>).</p>
 *
 * <pre>
 * StringUtils.reverseDelimited(null, *)      = null
 * StringUtils.reverseDelimited("""", *)        = """"
 * StringUtils.reverseDelimited(""a.b.c"", 'x') = ""a.b.c""
 * StringUtils.reverseDelimited(""a.b.c"", ""."") = ""c.b.a""
 * </pre>
 *
 * @param str  the String to reverse, may be null
 * @param separatorChar  the separator character to use
 * @return the reversed String, <code>null</code> if null String input
 * @since 2.0
 */"
"// Abbreviating
//-----------------------------------------------------------------------
/**
 * <p>Abbreviates a String using ellipses. This will turn
 * ""Now is the time for all good men"" into ""Now is the time for...""</p>
 *
 * <p>Specifically:
 * <ul>
 *   <li>If <code>str</code> is less than <code>maxWidth</code> characters
 *       long, return it.</li>
 *   <li>Else abbreviate it to <code>(substring(str, 0, max-3) + ""..."")</code>.</li>
 *   <li>If <code>maxWidth</code> is less than <code>4</code>, throw an
 *       <code>IllegalArgumentException</code>.</li>
 *   <li>In no case will it return a String of length greater than
 *       <code>maxWidth</code>.</li>
 * </ul>
 * </p>
 *
 * <pre>
 * StringUtils.abbreviate(null, *)      = null
 * StringUtils.abbreviate("""", 4)        = """"
 * StringUtils.abbreviate(""abcdefg"", 6) = ""abc...""
 * StringUtils.abbreviate(""abcdefg"", 7) = ""abcdefg""
 * StringUtils.abbreviate(""abcdefg"", 8) = ""abcdefg""
 * StringUtils.abbreviate(""abcdefg"", 4) = ""a...""
 * StringUtils.abbreviate(""abcdefg"", 3) = IllegalArgumentException
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param maxWidth  maximum length of result String, must be at least 4
 * @return abbreviated String, <code>null</code> if null String input
 * @throws IllegalArgumentException if the width is too small
 * @since 2.0
 */
public static String abbreviate(String str, int maxWidth) {
    return abbreviate(str, 0, maxWidth);
}","public void test391436() throws Throwable {
    String string0 = StringUtils.abbreviate((String) null, 4);
    assertNull(string0);
}",""
"// Abbreviating
//-----------------------------------------------------------------------
/**
 * <p>Abbreviates a String using ellipses. This will turn
 * ""Now is the time for all good men"" into ""Now is the time for...""</p>
 *
 * <p>Specifically:
 * <ul>
 *   <li>If <code>str</code> is less than <code>maxWidth</code> characters
 *       long, return it.</li>
 *   <li>Else abbreviate it to <code>(substring(str, 0, max-3) + ""..."")</code>.</li>
 *   <li>If <code>maxWidth</code> is less than <code>4</code>, throw an
 *       <code>IllegalArgumentException</code>.</li>
 *   <li>In no case will it return a String of length greater than
 *       <code>maxWidth</code>.</li>
 * </ul>
 * </p>
 *
 * <pre>
 * StringUtils.abbreviate(null, *)      = null
 * StringUtils.abbreviate("""", 4)        = """"
 * StringUtils.abbreviate(""abcdefg"", 6) = ""abc...""
 * StringUtils.abbreviate(""abcdefg"", 7) = ""abcdefg""
 * StringUtils.abbreviate(""abcdefg"", 8) = ""abcdefg""
 * StringUtils.abbreviate(""abcdefg"", 4) = ""a...""
 * StringUtils.abbreviate(""abcdefg"", 3) = IllegalArgumentException
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param maxWidth  maximum length of result String, must be at least 4
 * @return abbreviated String, <code>null</code> if null String input
 * @throws IllegalArgumentException if the width is too small
 * @since 2.0
 */
public static String abbreviate(String str, int maxWidth) {
    return abbreviate(str, 0, maxWidth);
}","public void test392437() throws Throwable {
    // Undeclared exception!
    try {
        StringUtils.abbreviate(""|"", (-236));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Minimum abbreviation width is 4
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}",""
"// Abbreviating
//-----------------------------------------------------------------------
/**
 * <p>Abbreviates a String using ellipses. This will turn
 * ""Now is the time for all good men"" into ""Now is the time for...""</p>
 *
 * <p>Specifically:
 * <ul>
 *   <li>If <code>str</code> is less than <code>maxWidth</code> characters
 *       long, return it.</li>
 *   <li>Else abbreviate it to <code>(substring(str, 0, max-3) + ""..."")</code>.</li>
 *   <li>If <code>maxWidth</code> is less than <code>4</code>, throw an
 *       <code>IllegalArgumentException</code>.</li>
 *   <li>In no case will it return a String of length greater than
 *       <code>maxWidth</code>.</li>
 * </ul>
 * </p>
 *
 * <pre>
 * StringUtils.abbreviate(null, *)      = null
 * StringUtils.abbreviate("""", 4)        = """"
 * StringUtils.abbreviate(""abcdefg"", 6) = ""abc...""
 * StringUtils.abbreviate(""abcdefg"", 7) = ""abcdefg""
 * StringUtils.abbreviate(""abcdefg"", 8) = ""abcdefg""
 * StringUtils.abbreviate(""abcdefg"", 4) = ""a...""
 * StringUtils.abbreviate(""abcdefg"", 3) = IllegalArgumentException
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param maxWidth  maximum length of result String, must be at least 4
 * @return abbreviated String, <code>null</code> if null String input
 * @throws IllegalArgumentException if the width is too small
 * @since 2.0
 */
public static String abbreviate(String str, int maxWidth) {
    return abbreviate(str, 0, maxWidth);
}","public void test393438() throws Throwable {
    String string0 = StringUtils.abbreviate(""Q"", 12);
    assertEquals(""Q"", string0);
}",""
"public static String abbreviate(String str, int offset, int maxWidth) {
    if (str == null) {
        return null;
    }
    if (maxWidth < 4) {
        throw new IllegalArgumentException(""Minimum abbreviation width is 4"");
    }
    if (str.length() <= maxWidth) {
        return str;
    }
    if (offset > str.length()) {
        offset = str.length();
    }
    if ((str.length() - offset) < (maxWidth - 3)) {
        offset = str.length() - (maxWidth - 3);
    }
    final String abrevMarker = ""..."";
    if (offset <= 4) {
        return str.substring(0, maxWidth - 3) + abrevMarker;
    }
    if (maxWidth < 7) {
        throw new IllegalArgumentException(""Minimum abbreviation width with offset is 7"");
    }
    if ((offset + (maxWidth - 3)) < str.length()) {
        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);
    }
    return abrevMarker + str.substring(str.length() - (maxWidth - 3));
}","public void test394439() throws Throwable {
    String string0 = StringUtils.abbreviate(""NoSuchFieldException occurred d|ring 1.6 backcompat code"", (int) '}', 14);
    assertEquals(""...compat code"", string0);
}","/**
 * <p>Abbreviates a String using ellipses. This will turn
 * ""Now is the time for all good men"" into ""...is the time for...""</p>
 *
 * <p>Works like <code>abbreviate(String, int)</code>, but allows you to specify
 * a ""left edge"" offset.  Note that this left edge is not necessarily going to
 * be the leftmost character in the result, or the first character following the
 * ellipses, but it will appear somewhere in the result.
 *
 * <p>In no case will it return a String of length greater than
 * <code>maxWidth</code>.</p>
 *
 * <pre>
 * StringUtils.abbreviate(null, *, *)                = null
 * StringUtils.abbreviate("""", 0, 4)                  = """"
 * StringUtils.abbreviate(""abcdefghijklmno"", -1, 10) = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 0, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 1, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 4, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 5, 10)  = ""...fghi...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 6, 10)  = ""...ghij...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 8, 10)  = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghijklmno"", 10, 10) = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghijklmno"", 12, 10) = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghij"", 0, 3)        = IllegalArgumentException
 * StringUtils.abbreviate(""abcdefghij"", 5, 6)        = IllegalArgumentException
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param offset  left edge of source String
 * @param maxWidth  maximum length of result String, must be at least 4
 * @return abbreviated String, <code>null</code> if null String input
 * @throws IllegalArgumentException if the width is too small
 * @since 2.0
 */"
"public static String abbreviate(String str, int offset, int maxWidth) {
    if (str == null) {
        return null;
    }
    if (maxWidth < 4) {
        throw new IllegalArgumentException(""Minimum abbreviation width is 4"");
    }
    if (str.length() <= maxWidth) {
        return str;
    }
    if (offset > str.length()) {
        offset = str.length();
    }
    if ((str.length() - offset) < (maxWidth - 3)) {
        offset = str.length() - (maxWidth - 3);
    }
    final String abrevMarker = ""..."";
    if (offset <= 4) {
        return str.substring(0, maxWidth - 3) + abrevMarker;
    }
    if (maxWidth < 7) {
        throw new IllegalArgumentException(""Minimum abbreviation width with offset is 7"");
    }
    if ((offset + (maxWidth - 3)) < str.length()) {
        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);
    }
    return abrevMarker + str.substring(str.length() - (maxWidth - 3));
}","public void test395440() throws Throwable {
    // Undeclared exception!
    try {
        StringUtils.abbreviate(""Cannot pad a negative amount:"", 5, 5);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Minimum abbreviation width with offset is 7
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}","/**
 * <p>Abbreviates a String using ellipses. This will turn
 * ""Now is the time for all good men"" into ""...is the time for...""</p>
 *
 * <p>Works like <code>abbreviate(String, int)</code>, but allows you to specify
 * a ""left edge"" offset.  Note that this left edge is not necessarily going to
 * be the leftmost character in the result, or the first character following the
 * ellipses, but it will appear somewhere in the result.
 *
 * <p>In no case will it return a String of length greater than
 * <code>maxWidth</code>.</p>
 *
 * <pre>
 * StringUtils.abbreviate(null, *, *)                = null
 * StringUtils.abbreviate("""", 0, 4)                  = """"
 * StringUtils.abbreviate(""abcdefghijklmno"", -1, 10) = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 0, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 1, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 4, 10)  = ""abcdefg...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 5, 10)  = ""...fghi...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 6, 10)  = ""...ghij...""
 * StringUtils.abbreviate(""abcdefghijklmno"", 8, 10)  = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghijklmno"", 10, 10) = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghijklmno"", 12, 10) = ""...ijklmno""
 * StringUtils.abbreviate(""abcdefghij"", 0, 3)        = IllegalArgumentException
 * StringUtils.abbreviate(""abcdefghij"", 5, 6)        = IllegalArgumentException
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param offset  left edge of source String
 * @param maxWidth  maximum length of result String, must be at least 4
 * @return abbreviated String, <code>null</code> if null String input
 * @throws IllegalArgumentException if the width is too small
 * @since 2.0
 */"
"public static String abbreviateMiddle(String str, String middle, int length) {
    if (isEmpty(str) || isEmpty(middle)) {
        return str;
    }
    if (length >= str.length() || length < (middle.length() + 2)) {
        return str;
    }
    int targetSting = length - middle.length();
    int startOffset = targetSting / 2 + targetSting % 2;
    int endOffset = str.length() - targetSting / 2;
    StringBuilder builder = new StringBuilder(length);
    builder.append(str.substring(0, startOffset));
    builder.append(middle);
    builder.append(str.substring(endOffset));
    return builder.toString();
}","public void test396441() throws Throwable {
    String string0 = StringUtils.abbreviateMiddle("""", """", 20);
    assertEquals("""", string0);
}","/**
 * <p>Abbreviates a String to the length passed, replacing the middle characters with the supplied
 * replacement String.</p>
 *
 * <p>This abbreviation only occurs if the following criteria is met:
 * <ul>
 * <li>Neither the String for abbreviation nor the replacement String are null or empty </li>
 * <li>The length to truncate to is less than the length of the supplied String</li>
 * <li>The length to truncate to is greater than 0</li>
 * <li>The abbreviated String will have enough room for the length supplied replacement String
 * and the first and last characters of the supplied String for abbreviation</li>
 * </ul>
 * Otherwise, the returned String will be the same as the supplied String for abbreviation.
 * </p>
 *
 * <pre>
 * StringUtils.abbreviateMiddle(null, null, 0)      = null
 * StringUtils.abbreviateMiddle(""abc"", null, 0)      = ""abc""
 * StringUtils.abbreviateMiddle(""abc"", ""."", 0)      = ""abc""
 * StringUtils.abbreviateMiddle(""abc"", ""."", 3)      = ""abc""
 * StringUtils.abbreviateMiddle(""abcdef"", ""."", 4)     = ""ab.f""
 * </pre>
 *
 * @param str  the String to abbreviate, may be null
 * @param middle the String to replace the middle characters with, may be null
 * @param length the length to abbreviate <code>str</code> to.
 * @return the abbreviated String if the above criteria is met, or the original String supplied for abbreviation.
 * @since 2.5
 */"
"public static String abbreviateMiddle(String str, String middle, int length) {
    if (isEmpty(str) || isEmpty(middle)) {
        return str;
    }
    if (length >= str.length() || length < (middle.length() + 2)) {
        return str;
    }
    int targetSting = length - middle.length();
    int startOffset = targetSting / 2 + targetSting % 2;
    int endOffset = str.length() - targetSting / 2;
    StringBuilder builder = new StringBuilder(length);
    builder.append(str.substring(0, startOffset));
    builder.append(middle);
    builder.append(str.substring(endOffset));
    return builder.toString();
}","public void test397442() throws Throwable {
    String string0 = StringUtils.abbreviateMiddle(""The Character must not be nullThe Character must not be null"", ""A2_<q"", 32);
    assertEquals(""The Character A2_<qt not be null"", string0);
}","/**
 * <p>Abbreviates a String to the length passed, replacing the middle characters with the supplied
 * replacement String.</p>
 *
 * <p>This abbreviation only occurs if the following criteria is met:
 * <ul>
 * <li>Neither the String for abbreviation nor the replacement String are null or empty </li>
 * <li>The length to truncate to is less than the length of the supplied String</li>
 * <li>The length to truncate to is greater than 0</li>
 * <li>The abbreviated String will have enough room for the length supplied replacement String
 * and the first and last characters of the supplied String for abbreviation</li>
 * </ul>
 * Otherwise, the returned String will be the same as the supplied String for abbreviation.
 * </p>
 *
 * <pre>
 * StringUtils.abbreviateMiddle(null, null, 0)      = null
 * StringUtils.abbreviateMiddle(""abc"", null, 0)      = ""abc""
 * StringUtils.abbreviateMiddle(""abc"", ""."", 0)      = ""abc""
 * StringUtils.abbreviateMiddle(""abc"", ""."", 3)      = ""abc""
 * StringUtils.abbreviateMiddle(""abcdef"", ""."", 4)     = ""ab.f""
 * </pre>
 *
 * @param str  the String to abbreviate, may be null
 * @param middle the String to replace the middle characters with, may be null
 * @param length the length to abbreviate <code>str</code> to.
 * @return the abbreviated String if the above criteria is met, or the original String supplied for abbreviation.
 * @since 2.5
 */"
"public static String abbreviateMiddle(String str, String middle, int length) {
    if (isEmpty(str) || isEmpty(middle)) {
        return str;
    }
    if (length >= str.length() || length < (middle.length() + 2)) {
        return str;
    }
    int targetSting = length - middle.length();
    int startOffset = targetSting / 2 + targetSting % 2;
    int endOffset = str.length() - targetSting / 2;
    StringBuilder builder = new StringBuilder(length);
    builder.append(str.substring(0, startOffset));
    builder.append(middle);
    builder.append(str.substring(endOffset));
    return builder.toString();
}","public void test398443() throws Throwable {
    String string0 = StringUtils.abbreviateMiddle(""s:"", """", 122);
    assertEquals(""s:"", string0);
}","/**
 * <p>Abbreviates a String to the length passed, replacing the middle characters with the supplied
 * replacement String.</p>
 *
 * <p>This abbreviation only occurs if the following criteria is met:
 * <ul>
 * <li>Neither the String for abbreviation nor the replacement String are null or empty </li>
 * <li>The length to truncate to is less than the length of the supplied String</li>
 * <li>The length to truncate to is greater than 0</li>
 * <li>The abbreviated String will have enough room for the length supplied replacement String
 * and the first and last characters of the supplied String for abbreviation</li>
 * </ul>
 * Otherwise, the returned String will be the same as the supplied String for abbreviation.
 * </p>
 *
 * <pre>
 * StringUtils.abbreviateMiddle(null, null, 0)      = null
 * StringUtils.abbreviateMiddle(""abc"", null, 0)      = ""abc""
 * StringUtils.abbreviateMiddle(""abc"", ""."", 0)      = ""abc""
 * StringUtils.abbreviateMiddle(""abc"", ""."", 3)      = ""abc""
 * StringUtils.abbreviateMiddle(""abcdef"", ""."", 4)     = ""ab.f""
 * </pre>
 *
 * @param str  the String to abbreviate, may be null
 * @param middle the String to replace the middle characters with, may be null
 * @param length the length to abbreviate <code>str</code> to.
 * @return the abbreviated String if the above criteria is met, or the original String supplied for abbreviation.
 * @since 2.5
 */"
"public static String abbreviateMiddle(String str, String middle, int length) {
    if (isEmpty(str) || isEmpty(middle)) {
        return str;
    }
    if (length >= str.length() || length < (middle.length() + 2)) {
        return str;
    }
    int targetSting = length - middle.length();
    int startOffset = targetSting / 2 + targetSting % 2;
    int endOffset = str.length() - targetSting / 2;
    StringBuilder builder = new StringBuilder(length);
    builder.append(str.substring(0, startOffset));
    builder.append(middle);
    builder.append(str.substring(endOffset));
    return builder.toString();
}","public void test399444() throws Throwable {
    String string0 = StringUtils.abbreviateMiddle("" "", "" "", 4);
    assertEquals("" "", string0);
}","/**
 * <p>Abbreviates a String to the length passed, replacing the middle characters with the supplied
 * replacement String.</p>
 *
 * <p>This abbreviation only occurs if the following criteria is met:
 * <ul>
 * <li>Neither the String for abbreviation nor the replacement String are null or empty </li>
 * <li>The length to truncate to is less than the length of the supplied String</li>
 * <li>The length to truncate to is greater than 0</li>
 * <li>The abbreviated String will have enough room for the length supplied replacement String
 * and the first and last characters of the supplied String for abbreviation</li>
 * </ul>
 * Otherwise, the returned String will be the same as the supplied String for abbreviation.
 * </p>
 *
 * <pre>
 * StringUtils.abbreviateMiddle(null, null, 0)      = null
 * StringUtils.abbreviateMiddle(""abc"", null, 0)      = ""abc""
 * StringUtils.abbreviateMiddle(""abc"", ""."", 0)      = ""abc""
 * StringUtils.abbreviateMiddle(""abc"", ""."", 3)      = ""abc""
 * StringUtils.abbreviateMiddle(""abcdef"", ""."", 4)     = ""ab.f""
 * </pre>
 *
 * @param str  the String to abbreviate, may be null
 * @param middle the String to replace the middle characters with, may be null
 * @param length the length to abbreviate <code>str</code> to.
 * @return the abbreviated String if the above criteria is met, or the original String supplied for abbreviation.
 * @since 2.5
 */"
"public static String abbreviateMiddle(String str, String middle, int length) {
    if (isEmpty(str) || isEmpty(middle)) {
        return str;
    }
    if (length >= str.length() || length < (middle.length() + 2)) {
        return str;
    }
    int targetSting = length - middle.length();
    int startOffset = targetSting / 2 + targetSting % 2;
    int endOffset = str.length() - targetSting / 2;
    StringBuilder builder = new StringBuilder(length);
    builder.append(str.substring(0, startOffset));
    builder.append(middle);
    builder.append(str.substring(endOffset));
    return builder.toString();
}","public void test400445() throws Throwable {
    String string0 = StringUtils.abbreviateMiddle(""*/gR`iz"", ""h#"", 0);
    assertEquals(""*/gR`iz"", string0);
}","/**
 * <p>Abbreviates a String to the length passed, replacing the middle characters with the supplied
 * replacement String.</p>
 *
 * <p>This abbreviation only occurs if the following criteria is met:
 * <ul>
 * <li>Neither the String for abbreviation nor the replacement String are null or empty </li>
 * <li>The length to truncate to is less than the length of the supplied String</li>
 * <li>The length to truncate to is greater than 0</li>
 * <li>The abbreviated String will have enough room for the length supplied replacement String
 * and the first and last characters of the supplied String for abbreviation</li>
 * </ul>
 * Otherwise, the returned String will be the same as the supplied String for abbreviation.
 * </p>
 *
 * <pre>
 * StringUtils.abbreviateMiddle(null, null, 0)      = null
 * StringUtils.abbreviateMiddle(""abc"", null, 0)      = ""abc""
 * StringUtils.abbreviateMiddle(""abc"", ""."", 0)      = ""abc""
 * StringUtils.abbreviateMiddle(""abc"", ""."", 3)      = ""abc""
 * StringUtils.abbreviateMiddle(""abcdef"", ""."", 4)     = ""ab.f""
 * </pre>
 *
 * @param str  the String to abbreviate, may be null
 * @param middle the String to replace the middle characters with, may be null
 * @param length the length to abbreviate <code>str</code> to.
 * @return the abbreviated String if the above criteria is met, or the original String supplied for abbreviation.
 * @since 2.5
 */"
"// Difference
//-----------------------------------------------------------------------
/**
 * <p>Compares two Strings, and returns the portion where they differ.
 * (More precisely, return the remainder of the second String,
 * starting from where it's different from the first.)</p>
 *
 * <p>For example,
 * <code>difference(""i am a machine"", ""i am a robot"") -> ""robot""</code>.</p>
 *
 * <pre>
 * StringUtils.difference(null, null) = null
 * StringUtils.difference("""", """") = """"
 * StringUtils.difference("""", ""abc"") = ""abc""
 * StringUtils.difference(""abc"", """") = """"
 * StringUtils.difference(""abc"", ""abc"") = """"
 * StringUtils.difference(""ab"", ""abxyz"") = ""xyz""
 * StringUtils.difference(""abcde"", ""abxyz"") = ""xyz""
 * StringUtils.difference(""abcde"", ""xyz"") = ""xyz""
 * </pre>
 *
 * @param str1  the first String, may be null
 * @param str2  the second String, may be null
 * @return the portion of str2 where it differs from str1; returns the
 * empty String if they are equal
 * @since 2.0
 */
public static String difference(String str1, String str2) {
    if (str1 == null) {
        return str2;
    }
    if (str2 == null) {
        return str1;
    }
    int at = indexOfDifference(str1, str2);
    if (at == INDEX_NOT_FOUND) {
        return EMPTY;
    }
    return str2.substring(at);
}","public void test401446() throws Throwable {
    String string0 = StringUtils.difference(""\u0000\u0001\u0002j#:'\u0004\u0005\u0006\u0007\b\n\u0000Z\u0002j#:'h\u0004Q\u0006\u0007\b"", ""\u0000\u0001\u0002j#:'\u0004\u0005\u0006\u0007\b\n\u0000Z\u0002j#:'h\u0004Q\u0006\u0007"");
    assertEquals("""", string0);
}",""
"// Difference
//-----------------------------------------------------------------------
/**
 * <p>Compares two Strings, and returns the portion where they differ.
 * (More precisely, return the remainder of the second String,
 * starting from where it's different from the first.)</p>
 *
 * <p>For example,
 * <code>difference(""i am a machine"", ""i am a robot"") -> ""robot""</code>.</p>
 *
 * <pre>
 * StringUtils.difference(null, null) = null
 * StringUtils.difference("""", """") = """"
 * StringUtils.difference("""", ""abc"") = ""abc""
 * StringUtils.difference(""abc"", """") = """"
 * StringUtils.difference(""abc"", ""abc"") = """"
 * StringUtils.difference(""ab"", ""abxyz"") = ""xyz""
 * StringUtils.difference(""abcde"", ""abxyz"") = ""xyz""
 * StringUtils.difference(""abcde"", ""xyz"") = ""xyz""
 * </pre>
 *
 * @param str1  the first String, may be null
 * @param str2  the second String, may be null
 * @return the portion of str2 where it differs from str1; returns the
 * empty String if they are equal
 * @since 2.0
 */
public static String difference(String str1, String str2) {
    if (str1 == null) {
        return str2;
    }
    if (str2 == null) {
        return str1;
    }
    int at = indexOfDifference(str1, str2);
    if (at == INDEX_NOT_FOUND) {
        return EMPTY;
    }
    return str2.substring(at);
}","public void test402447() throws Throwable {
    String string0 = StringUtils.difference((String) null, (String) null);
    assertNull(string0);
}",""
"// Difference
//-----------------------------------------------------------------------
/**
 * <p>Compares two Strings, and returns the portion where they differ.
 * (More precisely, return the remainder of the second String,
 * starting from where it's different from the first.)</p>
 *
 * <p>For example,
 * <code>difference(""i am a machine"", ""i am a robot"") -> ""robot""</code>.</p>
 *
 * <pre>
 * StringUtils.difference(null, null) = null
 * StringUtils.difference("""", """") = """"
 * StringUtils.difference("""", ""abc"") = ""abc""
 * StringUtils.difference(""abc"", """") = """"
 * StringUtils.difference(""abc"", ""abc"") = """"
 * StringUtils.difference(""ab"", ""abxyz"") = ""xyz""
 * StringUtils.difference(""abcde"", ""abxyz"") = ""xyz""
 * StringUtils.difference(""abcde"", ""xyz"") = ""xyz""
 * </pre>
 *
 * @param str1  the first String, may be null
 * @param str2  the second String, may be null
 * @return the portion of str2 where it differs from str1; returns the
 * empty String if they are equal
 * @since 2.0
 */
public static String difference(String str1, String str2) {
    if (str1 == null) {
        return str2;
    }
    if (str2 == null) {
        return str1;
    }
    int at = indexOfDifference(str1, str2);
    if (at == INDEX_NOT_FOUND) {
        return EMPTY;
    }
    return str2.substring(at);
}","public void test403448() throws Throwable {
    String string0 = StringUtils.difference(""-s<R|!"", (String) null);
    assertEquals(""-s<R|!"", string0);
}",""
"// Difference
//-----------------------------------------------------------------------
/**
 * <p>Compares two Strings, and returns the portion where they differ.
 * (More precisely, return the remainder of the second String,
 * starting from where it's different from the first.)</p>
 *
 * <p>For example,
 * <code>difference(""i am a machine"", ""i am a robot"") -> ""robot""</code>.</p>
 *
 * <pre>
 * StringUtils.difference(null, null) = null
 * StringUtils.difference("""", """") = """"
 * StringUtils.difference("""", ""abc"") = ""abc""
 * StringUtils.difference(""abc"", """") = """"
 * StringUtils.difference(""abc"", ""abc"") = """"
 * StringUtils.difference(""ab"", ""abxyz"") = ""xyz""
 * StringUtils.difference(""abcde"", ""abxyz"") = ""xyz""
 * StringUtils.difference(""abcde"", ""xyz"") = ""xyz""
 * </pre>
 *
 * @param str1  the first String, may be null
 * @param str2  the second String, may be null
 * @return the portion of str2 where it differs from str1; returns the
 * empty String if they are equal
 * @since 2.0
 */
public static String difference(String str1, String str2) {
    if (str1 == null) {
        return str2;
    }
    if (str2 == null) {
        return str1;
    }
    int at = indexOfDifference(str1, str2);
    if (at == INDEX_NOT_FOUND) {
        return EMPTY;
    }
    return str2.substring(at);
}","public void test404450() throws Throwable {
    String string0 = StringUtils.difference(""b`i2cAsL`9+n&Qrm#"", ""b`i2cAsL`9+n&Qrm#"");
    assertEquals("""", string0);
}",""
"public static int indexOfDifference(CharSequence cs1, CharSequence cs2) {
    if (cs1 == cs2) {
        return INDEX_NOT_FOUND;
    }
    if (cs1 == null || cs2 == null) {
        return 0;
    }
    int i;
    for (i = 0; i < cs1.length() && i < cs2.length(); ++i) {
        if (cs1.charAt(i) != cs2.charAt(i)) {
            break;
        }
    }
    if (i < cs2.length() || i < cs1.length()) {
        return i;
    }
    return INDEX_NOT_FOUND;
}","public void test405451() throws Throwable {
    int int0 = StringUtils.indexOfDifference((CharSequence) null, (CharSequence) ""hYuRL*IrBN5"");
    assertEquals(0, int0);
}","/**
 * <p>Compares two CharSequences, and returns the index at which the
 * CharSequences begin to differ.</p>
 *
 * <p>For example,
 * <code>indexOfDifference(""i am a machine"", ""i am a robot"") -> 7</code></p>
 *
 * <pre>
 * StringUtils.indexOfDifference(null, null) = -1
 * StringUtils.indexOfDifference("""", """") = -1
 * StringUtils.indexOfDifference("""", ""abc"") = 0
 * StringUtils.indexOfDifference(""abc"", """") = 0
 * StringUtils.indexOfDifference(""abc"", ""abc"") = -1
 * StringUtils.indexOfDifference(""ab"", ""abxyz"") = 2
 * StringUtils.indexOfDifference(""abcde"", ""abxyz"") = 2
 * StringUtils.indexOfDifference(""abcde"", ""xyz"") = 0
 * </pre>
 *
 * @param cs1  the first CharSequence, may be null
 * @param cs2  the second CharSequence, may be null
 * @return the index where cs1 and cs2 begin to differ; -1 if they are equal
 * @since 2.0
 */"
"public static int indexOfDifference(CharSequence cs1, CharSequence cs2) {
    if (cs1 == cs2) {
        return INDEX_NOT_FOUND;
    }
    if (cs1 == null || cs2 == null) {
        return 0;
    }
    int i;
    for (i = 0; i < cs1.length() && i < cs2.length(); ++i) {
        if (cs1.charAt(i) != cs2.charAt(i)) {
            break;
        }
    }
    if (i < cs2.length() || i < cs1.length()) {
        return i;
    }
    return INDEX_NOT_FOUND;
}","public void test406452() throws Throwable {
    int int0 = StringUtils.indexOfDifference((CharSequence) ""user.home"", (CharSequence) null);
    assertEquals(0, int0);
}","/**
 * <p>Compares two CharSequences, and returns the index at which the
 * CharSequences begin to differ.</p>
 *
 * <p>For example,
 * <code>indexOfDifference(""i am a machine"", ""i am a robot"") -> 7</code></p>
 *
 * <pre>
 * StringUtils.indexOfDifference(null, null) = -1
 * StringUtils.indexOfDifference("""", """") = -1
 * StringUtils.indexOfDifference("""", ""abc"") = 0
 * StringUtils.indexOfDifference(""abc"", """") = 0
 * StringUtils.indexOfDifference(""abc"", ""abc"") = -1
 * StringUtils.indexOfDifference(""ab"", ""abxyz"") = 2
 * StringUtils.indexOfDifference(""abcde"", ""abxyz"") = 2
 * StringUtils.indexOfDifference(""abcde"", ""xyz"") = 0
 * </pre>
 *
 * @param cs1  the first CharSequence, may be null
 * @param cs2  the second CharSequence, may be null
 * @return the index where cs1 and cs2 begin to differ; -1 if they are equal
 * @since 2.0
 */"
"public static int indexOfDifference(CharSequence cs1, CharSequence cs2) {
    if (cs1 == cs2) {
        return INDEX_NOT_FOUND;
    }
    if (cs1 == null || cs2 == null) {
        return 0;
    }
    int i;
    for (i = 0; i < cs1.length() && i < cs2.length(); ++i) {
        if (cs1.charAt(i) != cs2.charAt(i)) {
            break;
        }
    }
    if (i < cs2.length() || i < cs1.length()) {
        return i;
    }
    return INDEX_NOT_FOUND;
}","public void test407453() throws Throwable {
    int int0 = StringUtils.indexOfDifference((CharSequence) ""p"", (CharSequence) ""p"");
    assertEquals((-1), int0);
}","/**
 * <p>Compares two CharSequences, and returns the index at which the
 * CharSequences begin to differ.</p>
 *
 * <p>For example,
 * <code>indexOfDifference(""i am a machine"", ""i am a robot"") -> 7</code></p>
 *
 * <pre>
 * StringUtils.indexOfDifference(null, null) = -1
 * StringUtils.indexOfDifference("""", """") = -1
 * StringUtils.indexOfDifference("""", ""abc"") = 0
 * StringUtils.indexOfDifference(""abc"", """") = 0
 * StringUtils.indexOfDifference(""abc"", ""abc"") = -1
 * StringUtils.indexOfDifference(""ab"", ""abxyz"") = 2
 * StringUtils.indexOfDifference(""abcde"", ""abxyz"") = 2
 * StringUtils.indexOfDifference(""abcde"", ""xyz"") = 0
 * </pre>
 *
 * @param cs1  the first CharSequence, may be null
 * @param cs2  the second CharSequence, may be null
 * @return the index where cs1 and cs2 begin to differ; -1 if they are equal
 * @since 2.0
 */"
"// Difference
//-----------------------------------------------------------------------
/**
 * <p>Compares two Strings, and returns the portion where they differ.
 * (More precisely, return the remainder of the second String,
 * starting from where it's different from the first.)</p>
 *
 * <p>For example,
 * <code>difference(""i am a machine"", ""i am a robot"") -> ""robot""</code>.</p>
 *
 * <pre>
 * StringUtils.difference(null, null) = null
 * StringUtils.difference("""", """") = """"
 * StringUtils.difference("""", ""abc"") = ""abc""
 * StringUtils.difference(""abc"", """") = """"
 * StringUtils.difference(""abc"", ""abc"") = """"
 * StringUtils.difference(""ab"", ""abxyz"") = ""xyz""
 * StringUtils.difference(""abcde"", ""abxyz"") = ""xyz""
 * StringUtils.difference(""abcde"", ""xyz"") = ""xyz""
 * </pre>
 *
 * @param str1  the first String, may be null
 * @param str2  the second String, may be null
 * @return the portion of str2 where it differs from str1; returns the
 * empty String if they are equal
 * @since 2.0
 */
public static String difference(String str1, String str2) {
    if (str1 == null) {
        return str2;
    }
    if (str2 == null) {
        return str1;
    }
    int at = indexOfDifference(str1, str2);
    if (at == INDEX_NOT_FOUND) {
        return EMPTY;
    }
    return str2.substring(at);
}","public void test408454() throws Throwable {
    String string0 = StringUtils.difference(""3H,:Nj6KtpqUh6]u]2"", ""MDc OS X"");
    assertEquals(""MDc OS X"", string0);
}",""
"public static int indexOfDifference(CharSequence[] css) {
    if (css == null || css.length <= 1) {
        return INDEX_NOT_FOUND;
    }
    boolean anyStringNull = false;
    boolean allStringsNull = true;
    int arrayLen = css.length;
    int shortestStrLen = Integer.MAX_VALUE;
    int longestStrLen = 0;
    // find the min and max string lengths; this avoids checking to make
    // sure we are not exceeding the length of the string each time through
    // the bottom loop.
    for (int i = 0; i < arrayLen; i++) {
        if (css[i] == null) {
            anyStringNull = true;
            shortestStrLen = 0;
        } else {
            allStringsNull = false;
            shortestStrLen = Math.min(css[i].length(), shortestStrLen);
            longestStrLen = Math.max(css[i].length(), longestStrLen);
        }
    }
    // handle lists containing all nulls or all empty strings
    if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) {
        return INDEX_NOT_FOUND;
    }
    // handle lists containing some nulls or some empty strings
    if (shortestStrLen == 0) {
        return 0;
    }
    // find the position with the first difference across all strings
    int firstDiff = -1;
    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {
        char comparisonChar = css[0].charAt(stringPos);
        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {
            if (css[arrayPos].charAt(stringPos) != comparisonChar) {
                firstDiff = stringPos;
                break;
            }
        }
        if (firstDiff != -1) {
            break;
        }
    }
    if (firstDiff == -1 && shortestStrLen != longestStrLen) {
        // we compared all of the characters up to the length of the
        // shortest string and didn't find a match, but the string lengths
        // vary, so return the length of the shortest string.
        return shortestStrLen;
    }
    return firstDiff;
}","public void test409455() throws Throwable {
    int int0 = StringUtils.indexOfDifference((CharSequence[]) null);
    assertEquals((-1), int0);
}","/**
 * <p>Compares all CharSequences in an array and returns the index at which the
 * CharSequences begin to differ.</p>
 *
 * <p>For example,
 * <code>indexOfDifference(new String[] {""i am a machine"", ""i am a robot""}) -> 7</code></p>
 *
 * <pre>
 * StringUtils.indexOfDifference(null) = -1
 * StringUtils.indexOfDifference(new String[] {}) = -1
 * StringUtils.indexOfDifference(new String[] {""abc""}) = -1
 * StringUtils.indexOfDifference(new String[] {null, null}) = -1
 * StringUtils.indexOfDifference(new String[] {"""", """"}) = -1
 * StringUtils.indexOfDifference(new String[] {"""", null}) = 0
 * StringUtils.indexOfDifference(new String[] {""abc"", null, null}) = 0
 * StringUtils.indexOfDifference(new String[] {null, null, ""abc""}) = 0
 * StringUtils.indexOfDifference(new String[] {"""", ""abc""}) = 0
 * StringUtils.indexOfDifference(new String[] {""abc"", """"}) = 0
 * StringUtils.indexOfDifference(new String[] {""abc"", ""abc""}) = -1
 * StringUtils.indexOfDifference(new String[] {""abc"", ""a""}) = 1
 * StringUtils.indexOfDifference(new String[] {""ab"", ""abxyz""}) = 2
 * StringUtils.indexOfDifference(new String[] {""abcde"", ""abxyz""}) = 2
 * StringUtils.indexOfDifference(new String[] {""abcde"", ""xyz""}) = 0
 * StringUtils.indexOfDifference(new String[] {""xyz"", ""abcde""}) = 0
 * StringUtils.indexOfDifference(new String[] {""i am a machine"", ""i am a robot""}) = 7
 * </pre>
 *
 * @param css  array of CharSequences, entries may be null
 * @return the index where the strings begin to differ; -1 if they are all equal
 * @since 2.4
 */"
"public static String getCommonPrefix(String[] strs) {
    if (strs == null || strs.length == 0) {
        return EMPTY;
    }
    int smallestIndexOfDiff = indexOfDifference(strs);
    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {
        // all strings were identical
        if (strs[0] == null) {
            return EMPTY;
        }
        return strs[0];
    } else if (smallestIndexOfDiff == 0) {
        // there were no common initial characters
        return EMPTY;
    } else {
        // we found a common initial character sequence
        return strs[0].substring(0, smallestIndexOfDiff);
    }
}","public void test410456() throws Throwable {
    String[] stringArray0 = StringUtils.splitPreserveAllTokens(""wWmwZ\""<jC'Q[_VU9M"", ""wWmwZ\""<jC'Q[_VU9M"");
    String string0 = StringUtils.getCommonPrefix(stringArray0);
    assertEquals(18, stringArray0.length);
}","/**
 * <p>Compares all Strings in an array and returns the initial sequence of
 * characters that is common to all of them.</p>
 *
 * <p>For example,
 * <code>getCommonPrefix(new String[] {""i am a machine"", ""i am a robot""}) -> ""i am a ""</code></p>
 *
 * <pre>
 * StringUtils.getCommonPrefix(null) = """"
 * StringUtils.getCommonPrefix(new String[] {}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc""}) = ""abc""
 * StringUtils.getCommonPrefix(new String[] {null, null}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", """"}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", null}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", null, null}) = """"
 * StringUtils.getCommonPrefix(new String[] {null, null, ""abc""}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", ""abc""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", """"}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", ""abc""}) = ""abc""
 * StringUtils.getCommonPrefix(new String[] {""abc"", ""a""}) = ""a""
 * StringUtils.getCommonPrefix(new String[] {""ab"", ""abxyz""}) = ""ab""
 * StringUtils.getCommonPrefix(new String[] {""abcde"", ""abxyz""}) = ""ab""
 * StringUtils.getCommonPrefix(new String[] {""abcde"", ""xyz""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""xyz"", ""abcde""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""i am a machine"", ""i am a robot""}) = ""i am a ""
 * </pre>
 *
 * @param strs  array of String objects, entries may be null
 * @return the initial sequence of characters that are common to all Strings
 * in the array; empty String if the array is null, the elements are all null
 * or if there is no common prefix.
 * @since 2.4
 */"
"public static String getCommonPrefix(String[] strs) {
    if (strs == null || strs.length == 0) {
        return EMPTY;
    }
    int smallestIndexOfDiff = indexOfDifference(strs);
    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {
        // all strings were identical
        if (strs[0] == null) {
            return EMPTY;
        }
        return strs[0];
    } else if (smallestIndexOfDiff == 0) {
        // there were no common initial characters
        return EMPTY;
    } else {
        // we found a common initial character sequence
        return strs[0].substring(0, smallestIndexOfDiff);
    }
}","public void test411458() throws Throwable {
    String[] stringArray0 = StringUtils.split(""KRD]4{tF<jxufT]MX"", ')');
    String string0 = StringUtils.getCommonPrefix(stringArray0);
    assertEquals(""KRD]4{tF<jxufT]MX"", string0);
}","/**
 * <p>Compares all Strings in an array and returns the initial sequence of
 * characters that is common to all of them.</p>
 *
 * <p>For example,
 * <code>getCommonPrefix(new String[] {""i am a machine"", ""i am a robot""}) -> ""i am a ""</code></p>
 *
 * <pre>
 * StringUtils.getCommonPrefix(null) = """"
 * StringUtils.getCommonPrefix(new String[] {}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc""}) = ""abc""
 * StringUtils.getCommonPrefix(new String[] {null, null}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", """"}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", null}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", null, null}) = """"
 * StringUtils.getCommonPrefix(new String[] {null, null, ""abc""}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", ""abc""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", """"}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", ""abc""}) = ""abc""
 * StringUtils.getCommonPrefix(new String[] {""abc"", ""a""}) = ""a""
 * StringUtils.getCommonPrefix(new String[] {""ab"", ""abxyz""}) = ""ab""
 * StringUtils.getCommonPrefix(new String[] {""abcde"", ""abxyz""}) = ""ab""
 * StringUtils.getCommonPrefix(new String[] {""abcde"", ""xyz""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""xyz"", ""abcde""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""i am a machine"", ""i am a robot""}) = ""i am a ""
 * </pre>
 *
 * @param strs  array of String objects, entries may be null
 * @return the initial sequence of characters that are common to all Strings
 * in the array; empty String if the array is null, the elements are all null
 * or if there is no common prefix.
 * @since 2.4
 */"
"public static String getCommonPrefix(String[] strs) {
    if (strs == null || strs.length == 0) {
        return EMPTY;
    }
    int smallestIndexOfDiff = indexOfDifference(strs);
    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {
        // all strings were identical
        if (strs[0] == null) {
            return EMPTY;
        }
        return strs[0];
    } else if (smallestIndexOfDiff == 0) {
        // there were no common initial characters
        return EMPTY;
    } else {
        // we found a common initial character sequence
        return strs[0].substring(0, smallestIndexOfDiff);
    }
}","public void test412459() throws Throwable {
    String[] stringArray0 = new String[5];
    String string0 = StringUtils.getCommonPrefix(stringArray0);
    assertEquals("""", string0);
}","/**
 * <p>Compares all Strings in an array and returns the initial sequence of
 * characters that is common to all of them.</p>
 *
 * <p>For example,
 * <code>getCommonPrefix(new String[] {""i am a machine"", ""i am a robot""}) -> ""i am a ""</code></p>
 *
 * <pre>
 * StringUtils.getCommonPrefix(null) = """"
 * StringUtils.getCommonPrefix(new String[] {}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc""}) = ""abc""
 * StringUtils.getCommonPrefix(new String[] {null, null}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", """"}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", null}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", null, null}) = """"
 * StringUtils.getCommonPrefix(new String[] {null, null, ""abc""}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", ""abc""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", """"}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", ""abc""}) = ""abc""
 * StringUtils.getCommonPrefix(new String[] {""abc"", ""a""}) = ""a""
 * StringUtils.getCommonPrefix(new String[] {""ab"", ""abxyz""}) = ""ab""
 * StringUtils.getCommonPrefix(new String[] {""abcde"", ""abxyz""}) = ""ab""
 * StringUtils.getCommonPrefix(new String[] {""abcde"", ""xyz""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""xyz"", ""abcde""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""i am a machine"", ""i am a robot""}) = ""i am a ""
 * </pre>
 *
 * @param strs  array of String objects, entries may be null
 * @return the initial sequence of characters that are common to all Strings
 * in the array; empty String if the array is null, the elements are all null
 * or if there is no common prefix.
 * @since 2.4
 */"
"// Nested extraction
//-----------------------------------------------------------------------
// Splitting
//-----------------------------------------------------------------------
/**
 * <p>Splits the provided text into an array, using whitespace as the
 * separator.
 * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <p>The separator is not included in the returned String array.
 * Adjacent separators are treated as one separator.
 * For more control over the split use the StrTokenizer class.</p>
 *
 * <p>A <code>null</code> input String returns <code>null</code>.</p>
 *
 * <pre>
 * StringUtils.split(null)       = null
 * StringUtils.split("""")         = []
 * StringUtils.split(""abc def"")  = [""abc"", ""def""]
 * StringUtils.split(""abc  def"") = [""abc"", ""def""]
 * StringUtils.split("" abc "")    = [""abc""]
 * </pre>
 *
 * @param str  the String to parse, may be null
 * @return an array of parsed Strings, <code>null</code> if null String input
 */
public static String[] split(String str) {
    return split(str, null, -1);
}","public void test413460() throws Throwable {
    String[] stringArray0 = StringUtils.split(""_o~ihv Bn r $C2A"");
    assertNotNull(stringArray0);
}",""
"public static String getCommonPrefix(String[] strs) {
    if (strs == null || strs.length == 0) {
        return EMPTY;
    }
    int smallestIndexOfDiff = indexOfDifference(strs);
    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {
        // all strings were identical
        if (strs[0] == null) {
            return EMPTY;
        }
        return strs[0];
    } else if (smallestIndexOfDiff == 0) {
        // there were no common initial characters
        return EMPTY;
    } else {
        // we found a common initial character sequence
        return strs[0].substring(0, smallestIndexOfDiff);
    }
}","public void test413461() throws Throwable {
    String[] stringArray0 = StringUtils.split(""_o~ihv Bn r $C2A"");
    String string0 = StringUtils.getCommonPrefix(stringArray0);
    assertEquals(4, stringArray0.length);
}","/**
 * <p>Compares all Strings in an array and returns the initial sequence of
 * characters that is common to all of them.</p>
 *
 * <p>For example,
 * <code>getCommonPrefix(new String[] {""i am a machine"", ""i am a robot""}) -> ""i am a ""</code></p>
 *
 * <pre>
 * StringUtils.getCommonPrefix(null) = """"
 * StringUtils.getCommonPrefix(new String[] {}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc""}) = ""abc""
 * StringUtils.getCommonPrefix(new String[] {null, null}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", """"}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", null}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", null, null}) = """"
 * StringUtils.getCommonPrefix(new String[] {null, null, ""abc""}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", ""abc""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", """"}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", ""abc""}) = ""abc""
 * StringUtils.getCommonPrefix(new String[] {""abc"", ""a""}) = ""a""
 * StringUtils.getCommonPrefix(new String[] {""ab"", ""abxyz""}) = ""ab""
 * StringUtils.getCommonPrefix(new String[] {""abcde"", ""abxyz""}) = ""ab""
 * StringUtils.getCommonPrefix(new String[] {""abcde"", ""xyz""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""xyz"", ""abcde""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""i am a machine"", ""i am a robot""}) = ""i am a ""
 * </pre>
 *
 * @param strs  array of String objects, entries may be null
 * @return the initial sequence of characters that are common to all Strings
 * in the array; empty String if the array is null, the elements are all null
 * or if there is no common prefix.
 * @since 2.4
 */"
"public static String getCommonPrefix(String[] strs) {
    if (strs == null || strs.length == 0) {
        return EMPTY;
    }
    int smallestIndexOfDiff = indexOfDifference(strs);
    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {
        // all strings were identical
        if (strs[0] == null) {
            return EMPTY;
        }
        return strs[0];
    } else if (smallestIndexOfDiff == 0) {
        // there were no common initial characters
        return EMPTY;
    } else {
        // we found a common initial character sequence
        return strs[0].substring(0, smallestIndexOfDiff);
    }
}","public void test414463() throws Throwable {
    String[] stringArray0 = new String[3];
    stringArray0[0] = """";
    String string0 = StringUtils.getCommonPrefix(stringArray0);
    assertEquals("""", string0);
}","/**
 * <p>Compares all Strings in an array and returns the initial sequence of
 * characters that is common to all of them.</p>
 *
 * <p>For example,
 * <code>getCommonPrefix(new String[] {""i am a machine"", ""i am a robot""}) -> ""i am a ""</code></p>
 *
 * <pre>
 * StringUtils.getCommonPrefix(null) = """"
 * StringUtils.getCommonPrefix(new String[] {}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc""}) = ""abc""
 * StringUtils.getCommonPrefix(new String[] {null, null}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", """"}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", null}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", null, null}) = """"
 * StringUtils.getCommonPrefix(new String[] {null, null, ""abc""}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", ""abc""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", """"}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", ""abc""}) = ""abc""
 * StringUtils.getCommonPrefix(new String[] {""abc"", ""a""}) = ""a""
 * StringUtils.getCommonPrefix(new String[] {""ab"", ""abxyz""}) = ""ab""
 * StringUtils.getCommonPrefix(new String[] {""abcde"", ""abxyz""}) = ""ab""
 * StringUtils.getCommonPrefix(new String[] {""abcde"", ""xyz""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""xyz"", ""abcde""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""i am a machine"", ""i am a robot""}) = ""i am a ""
 * </pre>
 *
 * @param strs  array of String objects, entries may be null
 * @return the initial sequence of characters that are common to all Strings
 * in the array; empty String if the array is null, the elements are all null
 * or if there is no common prefix.
 * @since 2.4
 */"
"public static String getCommonPrefix(String[] strs) {
    if (strs == null || strs.length == 0) {
        return EMPTY;
    }
    int smallestIndexOfDiff = indexOfDifference(strs);
    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {
        // all strings were identical
        if (strs[0] == null) {
            return EMPTY;
        }
        return strs[0];
    } else if (smallestIndexOfDiff == 0) {
        // there were no common initial characters
        return EMPTY;
    } else {
        // we found a common initial character sequence
        return strs[0].substring(0, smallestIndexOfDiff);
    }
}","public void test415464() throws Throwable {
    String[] stringArray0 = new String[2];
    stringArray0[0] = ""}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J~<SS#SaM u}^}^1_J"";
    stringArray0[1] = ""}^}^1_J~<SS#SaM u"";
    String string0 = StringUtils.getCommonPrefix(stringArray0);
    assertEquals(""}^}^1_J~<SS#SaM u"", string0);
}","/**
 * <p>Compares all Strings in an array and returns the initial sequence of
 * characters that is common to all of them.</p>
 *
 * <p>For example,
 * <code>getCommonPrefix(new String[] {""i am a machine"", ""i am a robot""}) -> ""i am a ""</code></p>
 *
 * <pre>
 * StringUtils.getCommonPrefix(null) = """"
 * StringUtils.getCommonPrefix(new String[] {}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc""}) = ""abc""
 * StringUtils.getCommonPrefix(new String[] {null, null}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", """"}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", null}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", null, null}) = """"
 * StringUtils.getCommonPrefix(new String[] {null, null, ""abc""}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", ""abc""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", """"}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", ""abc""}) = ""abc""
 * StringUtils.getCommonPrefix(new String[] {""abc"", ""a""}) = ""a""
 * StringUtils.getCommonPrefix(new String[] {""ab"", ""abxyz""}) = ""ab""
 * StringUtils.getCommonPrefix(new String[] {""abcde"", ""abxyz""}) = ""ab""
 * StringUtils.getCommonPrefix(new String[] {""abcde"", ""xyz""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""xyz"", ""abcde""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""i am a machine"", ""i am a robot""}) = ""i am a ""
 * </pre>
 *
 * @param strs  array of String objects, entries may be null
 * @return the initial sequence of characters that are common to all Strings
 * in the array; empty String if the array is null, the elements are all null
 * or if there is no common prefix.
 * @since 2.4
 */"
"public static String getCommonPrefix(String[] strs) {
    if (strs == null || strs.length == 0) {
        return EMPTY;
    }
    int smallestIndexOfDiff = indexOfDifference(strs);
    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {
        // all strings were identical
        if (strs[0] == null) {
            return EMPTY;
        }
        return strs[0];
    } else if (smallestIndexOfDiff == 0) {
        // there were no common initial characters
        return EMPTY;
    } else {
        // we found a common initial character sequence
        return strs[0].substring(0, smallestIndexOfDiff);
    }
}","public void test416465() throws Throwable {
    String[] stringArray0 = new String[2];
    stringArray0[0] = ""Cannot pad a negative amount: "";
    stringArray0[1] = ""Cannot pad a negative amount: "";
    String string0 = StringUtils.getCommonPrefix(stringArray0);
    assertEquals(""Cannot pad a negative amount: "", string0);
}","/**
 * <p>Compares all Strings in an array and returns the initial sequence of
 * characters that is common to all of them.</p>
 *
 * <p>For example,
 * <code>getCommonPrefix(new String[] {""i am a machine"", ""i am a robot""}) -> ""i am a ""</code></p>
 *
 * <pre>
 * StringUtils.getCommonPrefix(null) = """"
 * StringUtils.getCommonPrefix(new String[] {}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc""}) = ""abc""
 * StringUtils.getCommonPrefix(new String[] {null, null}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", """"}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", null}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", null, null}) = """"
 * StringUtils.getCommonPrefix(new String[] {null, null, ""abc""}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", ""abc""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", """"}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", ""abc""}) = ""abc""
 * StringUtils.getCommonPrefix(new String[] {""abc"", ""a""}) = ""a""
 * StringUtils.getCommonPrefix(new String[] {""ab"", ""abxyz""}) = ""ab""
 * StringUtils.getCommonPrefix(new String[] {""abcde"", ""abxyz""}) = ""ab""
 * StringUtils.getCommonPrefix(new String[] {""abcde"", ""xyz""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""xyz"", ""abcde""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""i am a machine"", ""i am a robot""}) = ""i am a ""
 * </pre>
 *
 * @param strs  array of String objects, entries may be null
 * @return the initial sequence of characters that are common to all Strings
 * in the array; empty String if the array is null, the elements are all null
 * or if there is no common prefix.
 * @since 2.4
 */"
"public static String getCommonPrefix(String[] strs) {
    if (strs == null || strs.length == 0) {
        return EMPTY;
    }
    int smallestIndexOfDiff = indexOfDifference(strs);
    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {
        // all strings were identical
        if (strs[0] == null) {
            return EMPTY;
        }
        return strs[0];
    } else if (smallestIndexOfDiff == 0) {
        // there were no common initial characters
        return EMPTY;
    } else {
        // we found a common initial character sequence
        return strs[0].substring(0, smallestIndexOfDiff);
    }
}","public void test417466() throws Throwable {
    String string0 = StringUtils.getCommonPrefix((String[]) null);
    assertEquals("""", string0);
}","/**
 * <p>Compares all Strings in an array and returns the initial sequence of
 * characters that is common to all of them.</p>
 *
 * <p>For example,
 * <code>getCommonPrefix(new String[] {""i am a machine"", ""i am a robot""}) -> ""i am a ""</code></p>
 *
 * <pre>
 * StringUtils.getCommonPrefix(null) = """"
 * StringUtils.getCommonPrefix(new String[] {}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc""}) = ""abc""
 * StringUtils.getCommonPrefix(new String[] {null, null}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", """"}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", null}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", null, null}) = """"
 * StringUtils.getCommonPrefix(new String[] {null, null, ""abc""}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", ""abc""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", """"}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", ""abc""}) = ""abc""
 * StringUtils.getCommonPrefix(new String[] {""abc"", ""a""}) = ""a""
 * StringUtils.getCommonPrefix(new String[] {""ab"", ""abxyz""}) = ""ab""
 * StringUtils.getCommonPrefix(new String[] {""abcde"", ""abxyz""}) = ""ab""
 * StringUtils.getCommonPrefix(new String[] {""abcde"", ""xyz""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""xyz"", ""abcde""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""i am a machine"", ""i am a robot""}) = ""i am a ""
 * </pre>
 *
 * @param strs  array of String objects, entries may be null
 * @return the initial sequence of characters that are common to all Strings
 * in the array; empty String if the array is null, the elements are all null
 * or if there is no common prefix.
 * @since 2.4
 */"
"public static String getCommonPrefix(String[] strs) {
    if (strs == null || strs.length == 0) {
        return EMPTY;
    }
    int smallestIndexOfDiff = indexOfDifference(strs);
    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {
        // all strings were identical
        if (strs[0] == null) {
            return EMPTY;
        }
        return strs[0];
    } else if (smallestIndexOfDiff == 0) {
        // there were no common initial characters
        return EMPTY;
    } else {
        // we found a common initial character sequence
        return strs[0].substring(0, smallestIndexOfDiff);
    }
}","public void test418467() throws Throwable {
    String[] stringArray0 = new String[0];
    String string0 = StringUtils.getCommonPrefix(stringArray0);
    assertEquals("""", string0);
}","/**
 * <p>Compares all Strings in an array and returns the initial sequence of
 * characters that is common to all of them.</p>
 *
 * <p>For example,
 * <code>getCommonPrefix(new String[] {""i am a machine"", ""i am a robot""}) -> ""i am a ""</code></p>
 *
 * <pre>
 * StringUtils.getCommonPrefix(null) = """"
 * StringUtils.getCommonPrefix(new String[] {}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc""}) = ""abc""
 * StringUtils.getCommonPrefix(new String[] {null, null}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", """"}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", null}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", null, null}) = """"
 * StringUtils.getCommonPrefix(new String[] {null, null, ""abc""}) = """"
 * StringUtils.getCommonPrefix(new String[] {"""", ""abc""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", """"}) = """"
 * StringUtils.getCommonPrefix(new String[] {""abc"", ""abc""}) = ""abc""
 * StringUtils.getCommonPrefix(new String[] {""abc"", ""a""}) = ""a""
 * StringUtils.getCommonPrefix(new String[] {""ab"", ""abxyz""}) = ""ab""
 * StringUtils.getCommonPrefix(new String[] {""abcde"", ""abxyz""}) = ""ab""
 * StringUtils.getCommonPrefix(new String[] {""abcde"", ""xyz""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""xyz"", ""abcde""}) = """"
 * StringUtils.getCommonPrefix(new String[] {""i am a machine"", ""i am a robot""}) = ""i am a ""
 * </pre>
 *
 * @param strs  array of String objects, entries may be null
 * @return the initial sequence of characters that are common to all Strings
 * in the array; empty String if the array is null, the elements are all null
 * or if there is no common prefix.
 * @since 2.4
 */"
"// Misc
//-----------------------------------------------------------------------
/**
 * <p>Find the Levenshtein distance between two Strings.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>The previous implementation of the Levenshtein distance algorithm
 * was from <a href=""http://www.merriampark.com/ld.htm"">http://www.merriampark.com/ld.htm</a></p>
 *
 * <p>Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError
 * which can occur when my Java implementation is used with very large strings.<br>
 * This implementation of the Levenshtein distance algorithm
 * is from <a href=""http://www.merriampark.com/ldjava.htm"">http://www.merriampark.com/ldjava.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("""","""")               = 0
 * StringUtils.getLevenshteinDistance("""",""a"")              = 1
 * StringUtils.getLevenshteinDistance(""aaapppp"", """")       = 7
 * StringUtils.getLevenshteinDistance(""frog"", ""fog"")       = 1
 * StringUtils.getLevenshteinDistance(""fly"", ""ant"")        = 3
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""zzzzzzzz"") = 8
 * StringUtils.getLevenshteinDistance(""hello"", ""hallo"")    = 1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @return result distance
 * @throws IllegalArgumentException if either String input <code>null</code>
 */
public static int getLevenshteinDistance(CharSequence s, CharSequence t) {
    if (s == null || t == null) {
        throw new IllegalArgumentException(""Strings must not be null"");
    }
    /*
           The difference between this impl. and the previous is that, rather 
           than creating and retaining a matrix of size s.length()+1 by t.length()+1, 
           we maintain two single-dimensional arrays of length s.length()+1.  The first, d,
           is the 'current working' distance array that maintains the newest distance cost
           counts as we iterate through the characters of String s.  Each time we increment
           the index of String t we are comparing, d is copied to p, the second int[].  Doing so
           allows us to retain the previous cost counts as required by the algorithm (taking 
           the minimum of the cost count to the left, up one, and diagonally up and to the left
           of the current cost count being calculated).  (Note that the arrays aren't really 
           copied anymore, just switched...this is clearly much better than cloning an array 
           or doing a System.arraycopy() each time  through the outer loop.)

           Effectively, the difference between the two implementations is this one does not 
           cause an out of memory condition when calculating the LD over two very large strings.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    if (n == 0) {
        return m;
    } else if (m == 0) {
        return n;
    }
    if (n > m) {
        // swap the input strings to consume less memory
        CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    //'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    //placeholder to assist in swapping p and d
    int[] _d;
    // indexes into strings s and t
    // iterates through s
    int i;
    // iterates through t
    int j;
    // jth character of t
    char t_j;
    // cost
    int cost;
    for (i = 0; i <= n; i++) {
        p[i] = i;
    }
    for (j = 1; j <= m; j++) {
        t_j = t.charAt(j - 1);
        d[0] = j;
        for (i = 1; i <= n; i++) {
            cost = s.charAt(i - 1) == t_j ? 0 : 1;
            // minimum of cell to the left+1, to the top+1, diagonally left and up +cost
            d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost);
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // our last action in the above loop was to switch d and p, so p now
    // actually has the most recent cost counts
    return p[n];
}","public void test419468() throws Throwable {
    // Undeclared exception!
    try {
        StringUtils.getLevenshteinDistance((CharSequence) null, (CharSequence) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Strings must not be null
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}",""
"// Misc
//-----------------------------------------------------------------------
/**
 * <p>Find the Levenshtein distance between two Strings.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>The previous implementation of the Levenshtein distance algorithm
 * was from <a href=""http://www.merriampark.com/ld.htm"">http://www.merriampark.com/ld.htm</a></p>
 *
 * <p>Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError
 * which can occur when my Java implementation is used with very large strings.<br>
 * This implementation of the Levenshtein distance algorithm
 * is from <a href=""http://www.merriampark.com/ldjava.htm"">http://www.merriampark.com/ldjava.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("""","""")               = 0
 * StringUtils.getLevenshteinDistance("""",""a"")              = 1
 * StringUtils.getLevenshteinDistance(""aaapppp"", """")       = 7
 * StringUtils.getLevenshteinDistance(""frog"", ""fog"")       = 1
 * StringUtils.getLevenshteinDistance(""fly"", ""ant"")        = 3
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""zzzzzzzz"") = 8
 * StringUtils.getLevenshteinDistance(""hello"", ""hallo"")    = 1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @return result distance
 * @throws IllegalArgumentException if either String input <code>null</code>
 */
public static int getLevenshteinDistance(CharSequence s, CharSequence t) {
    if (s == null || t == null) {
        throw new IllegalArgumentException(""Strings must not be null"");
    }
    /*
           The difference between this impl. and the previous is that, rather 
           than creating and retaining a matrix of size s.length()+1 by t.length()+1, 
           we maintain two single-dimensional arrays of length s.length()+1.  The first, d,
           is the 'current working' distance array that maintains the newest distance cost
           counts as we iterate through the characters of String s.  Each time we increment
           the index of String t we are comparing, d is copied to p, the second int[].  Doing so
           allows us to retain the previous cost counts as required by the algorithm (taking 
           the minimum of the cost count to the left, up one, and diagonally up and to the left
           of the current cost count being calculated).  (Note that the arrays aren't really 
           copied anymore, just switched...this is clearly much better than cloning an array 
           or doing a System.arraycopy() each time  through the outer loop.)

           Effectively, the difference between the two implementations is this one does not 
           cause an out of memory condition when calculating the LD over two very large strings.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    if (n == 0) {
        return m;
    } else if (m == 0) {
        return n;
    }
    if (n > m) {
        // swap the input strings to consume less memory
        CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    //'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    //placeholder to assist in swapping p and d
    int[] _d;
    // indexes into strings s and t
    // iterates through s
    int i;
    // iterates through t
    int j;
    // jth character of t
    char t_j;
    // cost
    int cost;
    for (i = 0; i <= n; i++) {
        p[i] = i;
    }
    for (j = 1; j <= m; j++) {
        t_j = t.charAt(j - 1);
        d[0] = j;
        for (i = 1; i <= n; i++) {
            cost = s.charAt(i - 1) == t_j ? 0 : 1;
            // minimum of cell to the left+1, to the top+1, diagonally left and up +cost
            d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost);
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // our last action in the above loop was to switch d and p, so p now
    // actually has the most recent cost counts
    return p[n];
}","public void test420469() throws Throwable {
    int int0 = StringUtils.getLevenshteinDistance(""n  lU*so0YbH"", ""<6hV)z5xkC\""`I`0"");
    assertEquals(16, int0);
}",""
"// Misc
//-----------------------------------------------------------------------
/**
 * <p>Find the Levenshtein distance between two Strings.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>The previous implementation of the Levenshtein distance algorithm
 * was from <a href=""http://www.merriampark.com/ld.htm"">http://www.merriampark.com/ld.htm</a></p>
 *
 * <p>Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError
 * which can occur when my Java implementation is used with very large strings.<br>
 * This implementation of the Levenshtein distance algorithm
 * is from <a href=""http://www.merriampark.com/ldjava.htm"">http://www.merriampark.com/ldjava.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("""","""")               = 0
 * StringUtils.getLevenshteinDistance("""",""a"")              = 1
 * StringUtils.getLevenshteinDistance(""aaapppp"", """")       = 7
 * StringUtils.getLevenshteinDistance(""frog"", ""fog"")       = 1
 * StringUtils.getLevenshteinDistance(""fly"", ""ant"")        = 3
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""zzzzzzzz"") = 8
 * StringUtils.getLevenshteinDistance(""hello"", ""hallo"")    = 1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @return result distance
 * @throws IllegalArgumentException if either String input <code>null</code>
 */
public static int getLevenshteinDistance(CharSequence s, CharSequence t) {
    if (s == null || t == null) {
        throw new IllegalArgumentException(""Strings must not be null"");
    }
    /*
           The difference between this impl. and the previous is that, rather 
           than creating and retaining a matrix of size s.length()+1 by t.length()+1, 
           we maintain two single-dimensional arrays of length s.length()+1.  The first, d,
           is the 'current working' distance array that maintains the newest distance cost
           counts as we iterate through the characters of String s.  Each time we increment
           the index of String t we are comparing, d is copied to p, the second int[].  Doing so
           allows us to retain the previous cost counts as required by the algorithm (taking 
           the minimum of the cost count to the left, up one, and diagonally up and to the left
           of the current cost count being calculated).  (Note that the arrays aren't really 
           copied anymore, just switched...this is clearly much better than cloning an array 
           or doing a System.arraycopy() each time  through the outer loop.)

           Effectively, the difference between the two implementations is this one does not 
           cause an out of memory condition when calculating the LD over two very large strings.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    if (n == 0) {
        return m;
    } else if (m == 0) {
        return n;
    }
    if (n > m) {
        // swap the input strings to consume less memory
        CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    //'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    //placeholder to assist in swapping p and d
    int[] _d;
    // indexes into strings s and t
    // iterates through s
    int i;
    // iterates through t
    int j;
    // jth character of t
    char t_j;
    // cost
    int cost;
    for (i = 0; i <= n; i++) {
        p[i] = i;
    }
    for (j = 1; j <= m; j++) {
        t_j = t.charAt(j - 1);
        d[0] = j;
        for (i = 1; i <= n; i++) {
            cost = s.charAt(i - 1) == t_j ? 0 : 1;
            // minimum of cell to the left+1, to the top+1, diagonally left and up +cost
            d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost);
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // our last action in the above loop was to switch d and p, so p now
    // actually has the most recent cost counts
    return p[n];
}","public void test421470() throws Throwable {
    // Undeclared exception!
    try {
        StringUtils.getLevenshteinDistance(""n  lU*so0YbH"", (CharSequence) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Strings must not be null
        //
        verifyException(""org.apache.commons.lang3.StringUtils"", e);
    }
}",""
"// Misc
//-----------------------------------------------------------------------
/**
 * <p>Find the Levenshtein distance between two Strings.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>The previous implementation of the Levenshtein distance algorithm
 * was from <a href=""http://www.merriampark.com/ld.htm"">http://www.merriampark.com/ld.htm</a></p>
 *
 * <p>Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError
 * which can occur when my Java implementation is used with very large strings.<br>
 * This implementation of the Levenshtein distance algorithm
 * is from <a href=""http://www.merriampark.com/ldjava.htm"">http://www.merriampark.com/ldjava.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("""","""")               = 0
 * StringUtils.getLevenshteinDistance("""",""a"")              = 1
 * StringUtils.getLevenshteinDistance(""aaapppp"", """")       = 7
 * StringUtils.getLevenshteinDistance(""frog"", ""fog"")       = 1
 * StringUtils.getLevenshteinDistance(""fly"", ""ant"")        = 3
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""zzzzzzzz"") = 8
 * StringUtils.getLevenshteinDistance(""hello"", ""hallo"")    = 1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @return result distance
 * @throws IllegalArgumentException if either String input <code>null</code>
 */
public static int getLevenshteinDistance(CharSequence s, CharSequence t) {
    if (s == null || t == null) {
        throw new IllegalArgumentException(""Strings must not be null"");
    }
    /*
           The difference between this impl. and the previous is that, rather 
           than creating and retaining a matrix of size s.length()+1 by t.length()+1, 
           we maintain two single-dimensional arrays of length s.length()+1.  The first, d,
           is the 'current working' distance array that maintains the newest distance cost
           counts as we iterate through the characters of String s.  Each time we increment
           the index of String t we are comparing, d is copied to p, the second int[].  Doing so
           allows us to retain the previous cost counts as required by the algorithm (taking 
           the minimum of the cost count to the left, up one, and diagonally up and to the left
           of the current cost count being calculated).  (Note that the arrays aren't really 
           copied anymore, just switched...this is clearly much better than cloning an array 
           or doing a System.arraycopy() each time  through the outer loop.)

           Effectively, the difference between the two implementations is this one does not 
           cause an out of memory condition when calculating the LD over two very large strings.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    if (n == 0) {
        return m;
    } else if (m == 0) {
        return n;
    }
    if (n > m) {
        // swap the input strings to consume less memory
        CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    //'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    //placeholder to assist in swapping p and d
    int[] _d;
    // indexes into strings s and t
    // iterates through s
    int i;
    // iterates through t
    int j;
    // jth character of t
    char t_j;
    // cost
    int cost;
    for (i = 0; i <= n; i++) {
        p[i] = i;
    }
    for (j = 1; j <= m; j++) {
        t_j = t.charAt(j - 1);
        d[0] = j;
        for (i = 1; i <= n; i++) {
            cost = s.charAt(i - 1) == t_j ? 0 : 1;
            // minimum of cell to the left+1, to the top+1, diagonally left and up +cost
            d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost);
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // our last action in the above loop was to switch d and p, so p now
    // actually has the most recent cost counts
    return p[n];
}","public void test422471() throws Throwable {
    int int0 = StringUtils.getLevenshteinDistance("""", """");
    assertEquals(0, int0);
}",""
"// Misc
//-----------------------------------------------------------------------
/**
 * <p>Find the Levenshtein distance between two Strings.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>The previous implementation of the Levenshtein distance algorithm
 * was from <a href=""http://www.merriampark.com/ld.htm"">http://www.merriampark.com/ld.htm</a></p>
 *
 * <p>Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError
 * which can occur when my Java implementation is used with very large strings.<br>
 * This implementation of the Levenshtein distance algorithm
 * is from <a href=""http://www.merriampark.com/ldjava.htm"">http://www.merriampark.com/ldjava.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("""","""")               = 0
 * StringUtils.getLevenshteinDistance("""",""a"")              = 1
 * StringUtils.getLevenshteinDistance(""aaapppp"", """")       = 7
 * StringUtils.getLevenshteinDistance(""frog"", ""fog"")       = 1
 * StringUtils.getLevenshteinDistance(""fly"", ""ant"")        = 3
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""zzzzzzzz"") = 8
 * StringUtils.getLevenshteinDistance(""hello"", ""hallo"")    = 1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @return result distance
 * @throws IllegalArgumentException if either String input <code>null</code>
 */
public static int getLevenshteinDistance(CharSequence s, CharSequence t) {
    if (s == null || t == null) {
        throw new IllegalArgumentException(""Strings must not be null"");
    }
    /*
           The difference between this impl. and the previous is that, rather 
           than creating and retaining a matrix of size s.length()+1 by t.length()+1, 
           we maintain two single-dimensional arrays of length s.length()+1.  The first, d,
           is the 'current working' distance array that maintains the newest distance cost
           counts as we iterate through the characters of String s.  Each time we increment
           the index of String t we are comparing, d is copied to p, the second int[].  Doing so
           allows us to retain the previous cost counts as required by the algorithm (taking 
           the minimum of the cost count to the left, up one, and diagonally up and to the left
           of the current cost count being calculated).  (Note that the arrays aren't really 
           copied anymore, just switched...this is clearly much better than cloning an array 
           or doing a System.arraycopy() each time  through the outer loop.)

           Effectively, the difference between the two implementations is this one does not 
           cause an out of memory condition when calculating the LD over two very large strings.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    if (n == 0) {
        return m;
    } else if (m == 0) {
        return n;
    }
    if (n > m) {
        // swap the input strings to consume less memory
        CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    //'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    //placeholder to assist in swapping p and d
    int[] _d;
    // indexes into strings s and t
    // iterates through s
    int i;
    // iterates through t
    int j;
    // jth character of t
    char t_j;
    // cost
    int cost;
    for (i = 0; i <= n; i++) {
        p[i] = i;
    }
    for (j = 1; j <= m; j++) {
        t_j = t.charAt(j - 1);
        d[0] = j;
        for (i = 1; i <= n; i++) {
            cost = s.charAt(i - 1) == t_j ? 0 : 1;
            // minimum of cell to the left+1, to the top+1, diagonally left and up +cost
            d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost);
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // our last action in the above loop was to switch d and p, so p now
    // actually has the most recent cost counts
    return p[n];
}","public void test423472() throws Throwable {
    int int0 = StringUtils.getLevenshteinDistance(""Minimum abbreviation width with offset is 7"", """");
    assertEquals(43, int0);
}",""
"// Misc
//-----------------------------------------------------------------------
/**
 * <p>Find the Levenshtein distance between two Strings.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>The previous implementation of the Levenshtein distance algorithm
 * was from <a href=""http://www.merriampark.com/ld.htm"">http://www.merriampark.com/ld.htm</a></p>
 *
 * <p>Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError
 * which can occur when my Java implementation is used with very large strings.<br>
 * This implementation of the Levenshtein distance algorithm
 * is from <a href=""http://www.merriampark.com/ldjava.htm"">http://www.merriampark.com/ldjava.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("""","""")               = 0
 * StringUtils.getLevenshteinDistance("""",""a"")              = 1
 * StringUtils.getLevenshteinDistance(""aaapppp"", """")       = 7
 * StringUtils.getLevenshteinDistance(""frog"", ""fog"")       = 1
 * StringUtils.getLevenshteinDistance(""fly"", ""ant"")        = 3
 * StringUtils.getLevenshteinDistance(""elephant"", ""hippo"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""elephant"") = 7
 * StringUtils.getLevenshteinDistance(""hippo"", ""zzzzzzzz"") = 8
 * StringUtils.getLevenshteinDistance(""hello"", ""hallo"")    = 1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @return result distance
 * @throws IllegalArgumentException if either String input <code>null</code>
 */
public static int getLevenshteinDistance(CharSequence s, CharSequence t) {
    if (s == null || t == null) {
        throw new IllegalArgumentException(""Strings must not be null"");
    }
    /*
           The difference between this impl. and the previous is that, rather 
           than creating and retaining a matrix of size s.length()+1 by t.length()+1, 
           we maintain two single-dimensional arrays of length s.length()+1.  The first, d,
           is the 'current working' distance array that maintains the newest distance cost
           counts as we iterate through the characters of String s.  Each time we increment
           the index of String t we are comparing, d is copied to p, the second int[].  Doing so
           allows us to retain the previous cost counts as required by the algorithm (taking 
           the minimum of the cost count to the left, up one, and diagonally up and to the left
           of the current cost count being calculated).  (Note that the arrays aren't really 
           copied anymore, just switched...this is clearly much better than cloning an array 
           or doing a System.arraycopy() each time  through the outer loop.)

           Effectively, the difference between the two implementations is this one does not 
           cause an out of memory condition when calculating the LD over two very large strings.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    if (n == 0) {
        return m;
    } else if (m == 0) {
        return n;
    }
    if (n > m) {
        // swap the input strings to consume less memory
        CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    //'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    //placeholder to assist in swapping p and d
    int[] _d;
    // indexes into strings s and t
    // iterates through s
    int i;
    // iterates through t
    int j;
    // jth character of t
    char t_j;
    // cost
    int cost;
    for (i = 0; i <= n; i++) {
        p[i] = i;
    }
    for (j = 1; j <= m; j++) {
        t_j = t.charAt(j - 1);
        d[0] = j;
        for (i = 1; i <= n; i++) {
            cost = s.charAt(i - 1) == t_j ? 0 : 1;
            // minimum of cell to the left+1, to the top+1, diagonally left and up +cost
            d[i] = Math.min(Math.min(d[i - 1] + 1, p[i] + 1), p[i - 1] + cost);
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // our last action in the above loop was to switch d and p, so p now
    // actually has the most recent cost counts
    return p[n];
}","public void test424473() throws Throwable {
    int int0 = StringUtils.getLevenshteinDistance(""P{iNcOMBININGdIACRITICALmARKS}+"", ""wWmwZ\""<jC'Q[_VU9M"");
    assertEquals(30, int0);
}",""
"/*
    private static int min(int a, int b, int c) {
        // Method copied from NumberUtils to avoid dependency on subpackage
        if (b < a) {
            a = b;
        }
        if (c < a) {
            a = c;
        }
        return a;
    }
*/
// startsWith
//-----------------------------------------------------------------------
/**
 * <p>Check if a String starts with a specified prefix.</p>
 *
 * <p><code>null</code>s are handled without exceptions. Two <code>null</code>
 * references are considered to be equal. The comparison is case sensitive.</p>
 *
 * <pre>
 * StringUtils.startsWith(null, null)      = true
 * StringUtils.startsWith(null, ""abc"")     = false
 * StringUtils.startsWith(""abcdef"", null)  = false
 * StringUtils.startsWith(""abcdef"", ""abc"") = true
 * StringUtils.startsWith(""ABCDEF"", ""abc"") = false
 * </pre>
 *
 * @see java.lang.String#startsWith(String)
 * @param str  the String to check, may be null
 * @param prefix the prefix to find, may be null
 * @return <code>true</code> if the String starts with the prefix, case sensitive, or
 *  both <code>null</code>
 * @since 2.4
 */
public static boolean startsWith(String str, String prefix) {
    return startsWith(str, prefix, false);
}","public void test425474() throws Throwable {
    boolean boolean0 = StringUtils.startsWith((String) null, ""-s<R|!"");
    assertFalse(boolean0);
}","/**
 * <p>Gets the minimum of three <code>int</code> values.</p>
 *
 * @param a  value 1
 * @param b  value 2
 * @param c  value 3
 * @return  the smallest of the values
 */"
"/*
    private static int min(int a, int b, int c) {
        // Method copied from NumberUtils to avoid dependency on subpackage
        if (b < a) {
            a = b;
        }
        if (c < a) {
            a = c;
        }
        return a;
    }
*/
// startsWith
//-----------------------------------------------------------------------
/**
 * <p>Check if a String starts with a specified prefix.</p>
 *
 * <p><code>null</code>s are handled without exceptions. Two <code>null</code>
 * references are considered to be equal. The comparison is case sensitive.</p>
 *
 * <pre>
 * StringUtils.startsWith(null, null)      = true
 * StringUtils.startsWith(null, ""abc"")     = false
 * StringUtils.startsWith(""abcdef"", null)  = false
 * StringUtils.startsWith(""abcdef"", ""abc"") = true
 * StringUtils.startsWith(""ABCDEF"", ""abc"") = false
 * </pre>
 *
 * @see java.lang.String#startsWith(String)
 * @param str  the String to check, may be null
 * @param prefix the prefix to find, may be null
 * @return <code>true</code> if the String starts with the prefix, case sensitive, or
 *  both <code>null</code>
 * @since 2.4
 */
public static boolean startsWith(String str, String prefix) {
    return startsWith(str, prefix, false);
}","public void test426475() throws Throwable {
    boolean boolean0 = StringUtils.startsWith((String) null, (String) null);
    assertTrue(boolean0);
}","/**
 * <p>Gets the minimum of three <code>int</code> values.</p>
 *
 * @param a  value 1
 * @param b  value 2
 * @param c  value 3
 * @return  the smallest of the values
 */"
"public static boolean startsWithAny(String string, String[] searchStrings) {
    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {
        return false;
    }
    for (int i = 0; i < searchStrings.length; i++) {
        String searchString = searchStrings[i];
        if (StringUtils.startsWith(string, searchString)) {
            return true;
        }
    }
    return false;
}","public void test427476() throws Throwable {
    String[] stringArray0 = StringUtils.splitByCharacterTypeCamelCase("""");
    boolean boolean0 = StringUtils.startsWithAny("""", stringArray0);
    assertFalse(boolean0);
}","/**
 * <p>Check if a String starts with any of an array of specified strings.</p>
 *
 * <pre>
 * StringUtils.startsWithAny(null, null)      = false
 * StringUtils.startsWithAny(null, new String[] {""abc""})  = false
 * StringUtils.startsWithAny(""abcxyz"", null)     = false
 * StringUtils.startsWithAny(""abcxyz"", new String[] {""""}) = false
 * StringUtils.startsWithAny(""abcxyz"", new String[] {""abc""}) = true
 * StringUtils.startsWithAny(""abcxyz"", new String[] {null, ""xyz"", ""abc""}) = true
 * </pre>
 *
 * @param string  the String to check, may be null
 * @param searchStrings the Strings to find, may be null or empty
 * @return <code>true</code> if the String starts with any of the the prefixes, case insensitive, or
 *  both <code>null</code>
 * @since 2.5
 */"
"public static boolean startsWithAny(String string, String[] searchStrings) {
    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {
        return false;
    }
    for (int i = 0; i < searchStrings.length; i++) {
        String searchString = searchStrings[i];
        if (StringUtils.startsWith(string, searchString)) {
            return true;
        }
    }
    return false;
}","public void test428477() throws Throwable {
    boolean boolean0 = StringUtils.startsWithAny(""P9%~l}\""F==6"", (String[]) null);
    assertFalse(boolean0);
}","/**
 * <p>Check if a String starts with any of an array of specified strings.</p>
 *
 * <pre>
 * StringUtils.startsWithAny(null, null)      = false
 * StringUtils.startsWithAny(null, new String[] {""abc""})  = false
 * StringUtils.startsWithAny(""abcxyz"", null)     = false
 * StringUtils.startsWithAny(""abcxyz"", new String[] {""""}) = false
 * StringUtils.startsWithAny(""abcxyz"", new String[] {""abc""}) = true
 * StringUtils.startsWithAny(""abcxyz"", new String[] {null, ""xyz"", ""abc""}) = true
 * </pre>
 *
 * @param string  the String to check, may be null
 * @param searchStrings the Strings to find, may be null or empty
 * @return <code>true</code> if the String starts with any of the the prefixes, case insensitive, or
 *  both <code>null</code>
 * @since 2.5
 */"
"public static boolean startsWithAny(String string, String[] searchStrings) {
    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {
        return false;
    }
    for (int i = 0; i < searchStrings.length; i++) {
        String searchString = searchStrings[i];
        if (StringUtils.startsWith(string, searchString)) {
            return true;
        }
    }
    return false;
}","public void test429478() throws Throwable {
    String[] stringArray0 = new String[3];
    boolean boolean0 = StringUtils.startsWithAny(""P9%~l}\""F==6"", stringArray0);
    assertFalse(boolean0);
}","/**
 * <p>Check if a String starts with any of an array of specified strings.</p>
 *
 * <pre>
 * StringUtils.startsWithAny(null, null)      = false
 * StringUtils.startsWithAny(null, new String[] {""abc""})  = false
 * StringUtils.startsWithAny(""abcxyz"", null)     = false
 * StringUtils.startsWithAny(""abcxyz"", new String[] {""""}) = false
 * StringUtils.startsWithAny(""abcxyz"", new String[] {""abc""}) = true
 * StringUtils.startsWithAny(""abcxyz"", new String[] {null, ""xyz"", ""abc""}) = true
 * </pre>
 *
 * @param string  the String to check, may be null
 * @param searchStrings the Strings to find, may be null or empty
 * @return <code>true</code> if the String starts with any of the the prefixes, case insensitive, or
 *  both <code>null</code>
 * @since 2.5
 */"
"public static boolean startsWithAny(String string, String[] searchStrings) {
    if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {
        return false;
    }
    for (int i = 0; i < searchStrings.length; i++) {
        String searchString = searchStrings[i];
        if (StringUtils.startsWith(string, searchString)) {
            return true;
        }
    }
    return false;
}","public void test430479() throws Throwable {
    String[] stringArray0 = StringUtils.splitByWholeSeparatorPreserveAllTokens(""_o~ihv Bn r $C2A"", ""_o~ihv Bn r $C2A"");
    boolean boolean0 = StringUtils.startsWithAny(""q]TOkXBp#U_( ;.N"", stringArray0);
    assertTrue(boolean0);
}","/**
 * <p>Check if a String starts with any of an array of specified strings.</p>
 *
 * <pre>
 * StringUtils.startsWithAny(null, null)      = false
 * StringUtils.startsWithAny(null, new String[] {""abc""})  = false
 * StringUtils.startsWithAny(""abcxyz"", null)     = false
 * StringUtils.startsWithAny(""abcxyz"", new String[] {""""}) = false
 * StringUtils.startsWithAny(""abcxyz"", new String[] {""abc""}) = true
 * StringUtils.startsWithAny(""abcxyz"", new String[] {null, ""xyz"", ""abc""}) = true
 * </pre>
 *
 * @param string  the String to check, may be null
 * @param searchStrings the Strings to find, may be null or empty
 * @return <code>true</code> if the String starts with any of the the prefixes, case insensitive, or
 *  both <code>null</code>
 * @since 2.5
 */"
"public static boolean endsWithIgnoreCase(String str, String suffix) {
    return endsWith(str, suffix, true);
}","public void test431481() throws Throwable {
    boolean boolean0 = StringUtils.endsWithIgnoreCase(""!4#"", (String) null);
    assertFalse(boolean0);
}","/**
 * <p>Case insensitive check if a String ends with a specified suffix.</p>
 *
 * <p><code>null</code>s are handled without exceptions. Two <code>null</code>
 * references are considered to be equal. The comparison is case insensitive.</p>
 *
 * <pre>
 * StringUtils.endsWithIgnoreCase(null, null)      = true
 * StringUtils.endsWithIgnoreCase(null, ""def"")     = false
 * StringUtils.endsWithIgnoreCase(""abcdef"", null)  = false
 * StringUtils.endsWithIgnoreCase(""abcdef"", ""def"") = true
 * StringUtils.endsWithIgnoreCase(""ABCDEF"", ""def"") = true
 * StringUtils.endsWithIgnoreCase(""ABCDEF"", ""cde"") = false
 * </pre>
 *
 * @see java.lang.String#endsWith(String)
 * @param str  the String to check, may be null
 * @param suffix the suffix to find, may be null
 * @return <code>true</code> if the String ends with the suffix, case insensitive, or
 *  both <code>null</code>
 * @since 2.4
 */"
"public static boolean endsWithIgnoreCase(String str, String suffix) {
    return endsWith(str, suffix, true);
}","public void test432482() throws Throwable {
    boolean boolean0 = StringUtils.endsWithIgnoreCase((String) null, ""&hj_Y)"");
    assertFalse(boolean0);
}","/**
 * <p>Case insensitive check if a String ends with a specified suffix.</p>
 *
 * <p><code>null</code>s are handled without exceptions. Two <code>null</code>
 * references are considered to be equal. The comparison is case insensitive.</p>
 *
 * <pre>
 * StringUtils.endsWithIgnoreCase(null, null)      = true
 * StringUtils.endsWithIgnoreCase(null, ""def"")     = false
 * StringUtils.endsWithIgnoreCase(""abcdef"", null)  = false
 * StringUtils.endsWithIgnoreCase(""abcdef"", ""def"") = true
 * StringUtils.endsWithIgnoreCase(""ABCDEF"", ""def"") = true
 * StringUtils.endsWithIgnoreCase(""ABCDEF"", ""cde"") = false
 * </pre>
 *
 * @see java.lang.String#endsWith(String)
 * @param str  the String to check, may be null
 * @param suffix the suffix to find, may be null
 * @return <code>true</code> if the String ends with the suffix, case insensitive, or
 *  both <code>null</code>
 * @since 2.4
 */"
