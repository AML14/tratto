focal_method,test_prefix,docstring
"//-----------------------------------------------------------------------
/**
 * <p>Gets the time zone display name, using a cache for performance.</p>
 *
 * @param tz  the zone to query
 * @param daylight  true if daylight savings
 * @param style  the style to use <code>TimeZone.LONG</code>
 *  or <code>TimeZone.SHORT</code>
 * @param locale  the locale to use
 * @return the textual name of the time zone
 */
static synchronized String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {
    Object key = new TimeZoneDisplayKey(tz, daylight, style, locale);
    String value = (String) cTimeZoneDisplayCache.get(key);
    if (value == null) {
        // This is a very slow call, so cache the results.
        value = tz.getDisplayName(daylight, style, locale);
        cTimeZoneDisplayCache.put(key, value);
    }
    return value;
}","public void test0010() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.UK;
    // Undeclared exception!
    try {
        FastDateFormat.getTimeZoneDisplay(timeZone0, true, (-764), locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal style: -764
        //
        verifyException(""java.util.TimeZone"", e);
    }
}",""
"public static FastDateFormat getDateInstance(int style, Locale locale) {
    return getDateInstance(style, null, locale);
}","public void test0118() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, locale0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0129() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0130() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, locale0);
    assertEquals(""yyyy'\uB144' M'\uC6D4' d'\uC77C' EEEE"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0131() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, locale0);
    assertEquals(19, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test0147() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, locale0);
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3193, """");
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(simpleTimeZone0);
    Date date0 = mockGregorianCalendar0.getGregorianChange();
    assertEquals(""org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=1392409281320,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=java.util.SimpleTimeZone[id=,offset=3193,dstSavings=3600000,useDaylight=false,startYear=0,startMode=0,startMonth=0,startDay=0,startDayOfWeek=0,startTime=0,startTimeMode=0,endMode=0,endMonth=0,endDay=0,endDayOfWeek=0,endTime=0,endTimeMode=0],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2014,MONTH=1,WEEK_OF_YEAR=7,WEEK_OF_MONTH=3,DAY_OF_MONTH=14,DAY_OF_YEAR=45,DAY_OF_WEEK=6,DAY_OF_WEEK_IN_MONTH=2,AM_PM=1,HOUR=8,HOUR_OF_DAY=20,MINUTE=21,SECOND=24,MILLISECOND=513,ZONE_OFFSET=3193,DST_OFFSET=0]"", mockGregorianCalendar0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public StringBuffer format(Date date, StringBuffer buf) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, buf);
}","public void test0153() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, locale0);
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3193, """");
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(simpleTimeZone0);
    Date date0 = mockGregorianCalendar0.getGregorianChange();
    StringBuffer stringBuffer0 = new StringBuffer(""1970\uB144 1\uC6D4 1\uC77C \uBAA9\uC694\uC77C"");
    StringBuffer stringBuffer1 = fastDateFormat0.format(date0, stringBuffer0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Formats a <code>Date</code> object into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param date  the date to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0166() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, locale0);
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3193, """");
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(simpleTimeZone0);
    Date date0 = mockGregorianCalendar0.getGregorianChange();
    StringBuffer stringBuffer0 = new StringBuffer(""1970\uB144 1\uC6D4 1\uC77C \uBAA9\uC694\uC77C"");
    StringBuffer stringBuffer1 = fastDateFormat0.format(date0, stringBuffer0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0167() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, locale0);
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3193, """");
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(simpleTimeZone0);
    Date date0 = mockGregorianCalendar0.getGregorianChange();
    StringBuffer stringBuffer0 = new StringBuffer(""1970\uB144 1\uC6D4 1\uC77C \uBAA9\uC694\uC77C"");
    StringBuffer stringBuffer1 = fastDateFormat0.format(date0, stringBuffer0);
    assertEquals(""yyyy'\uB144' M'\uC6D4' d'\uC77C' EEEE"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0168() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, locale0);
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3193, """");
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(simpleTimeZone0);
    Date date0 = mockGregorianCalendar0.getGregorianChange();
    StringBuffer stringBuffer0 = new StringBuffer(""1970\uB144 1\uC6D4 1\uC77C \uBAA9\uC694\uC77C"");
    StringBuffer stringBuffer1 = fastDateFormat0.format(date0, stringBuffer0);
    assertEquals(19, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test0176() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, locale0);
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3193, """");
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(simpleTimeZone0);
    Date date0 = mockGregorianCalendar0.getGregorianChange();
    StringBuffer stringBuffer0 = new StringBuffer(""1970\uB144 1\uC6D4 1\uC77C \uBAA9\uC694\uC77C"");
    StringBuffer stringBuffer1 = fastDateFormat0.format(date0, stringBuffer0);
    assertEquals(""org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=1392409281320,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=java.util.SimpleTimeZone[id=,offset=3193,dstSavings=3600000,useDaylight=false,startYear=0,startMode=0,startMonth=0,startDay=0,startDayOfWeek=0,startTime=0,startTimeMode=0,endMode=0,endMonth=0,endDay=0,endDayOfWeek=0,endTime=0,endTimeMode=0],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2014,MONTH=1,WEEK_OF_YEAR=7,WEEK_OF_MONTH=3,DAY_OF_MONTH=14,DAY_OF_YEAR=45,DAY_OF_WEEK=6,DAY_OF_WEEK_IN_MONTH=2,AM_PM=1,HOUR=8,HOUR_OF_DAY=20,MINUTE=21,SECOND=24,MILLISECOND=513,ZONE_OFFSET=3193,DST_OFFSET=0]"", mockGregorianCalendar0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a date/time formatter instance using the specified style
 * in the default time zone and locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle) {
    return getDateTimeInstance(dateStyle, timeStyle, null, null);
}","public void test0283() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    assertEquals(1, FastDateFormat.LONG);
}",""
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0288() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    assertEquals(""EEEE, MMMM d, yyyy h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0289() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    assertEquals(50, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0290() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"protected void init() {
    List rulesList = parsePattern();
    mRules = (Rule[]) rulesList.toArray(new Rule[rulesList.size()]);
    int len = 0;
    for (int i = mRules.length; --i >= 0; ) {
        len += mRules[i].estimateLength();
    }
    mMaxLengthEstimate = len;
}","public void test0291() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    fastDateFormat0.init();
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Initializes the instance for first use.</p>
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0295() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    fastDateFormat0.init();
    assertEquals(""EEEE, MMMM d, yyyy h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0296() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    fastDateFormat0.init();
    assertEquals(50, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0297() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    fastDateFormat0.init();
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a formatter instance using the default pattern in the
 * default locale.</p>
 *
 * @return a date/time formatter
 */
public static FastDateFormat getInstance() {
    return getInstance(getDefaultPattern(), null, null);
}","public void test0398() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    assertEquals(0, FastDateFormat.FULL);
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test03103() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test03104() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test03105() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"protected String parseToken(String pattern, int[] indexRef) {
    StringBuffer buf = new StringBuffer();
    int i = indexRef[0];
    int length = pattern.length();
    char c = pattern.charAt(i);
    if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {
        // Scan a run of the same character, which indicates a time
        // pattern.
        buf.append(c);
        while (i + 1 < length) {
            char peek = pattern.charAt(i + 1);
            if (peek == c) {
                buf.append(c);
                i++;
            } else {
                break;
            }
        }
    } else {
        // This will identify token as text.
        buf.append('\'');
        boolean inLiteral = false;
        for (; i < length; i++) {
            c = pattern.charAt(i);
            if (c == '\'') {
                if (i + 1 < length && pattern.charAt(i + 1) == '\'') {
                    // '' is treated as escaped '
                    i++;
                    buf.append(c);
                } else {
                    inLiteral = !inLiteral;
                }
            } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {
                i--;
                break;
            } else {
                buf.append(c);
            }
        }
    }
    indexRef[0] = i;
    return buf.toString();
}","public void test03106() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    int[] intArray0 = new int[6];
    String string0 = fastDateFormat0.parseToken(""#fgg0XqGjy$K(D"", intArray0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Performs the parsing of tokens.</p>
 *
 * @param pattern  the pattern
 * @param indexRef  index references
 * @return parsed token
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test03114() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    int[] intArray0 = new int[6];
    String string0 = fastDateFormat0.parseToken(""#fgg0XqGjy$K(D"", intArray0);
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test03115() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    int[] intArray0 = new int[6];
    String string0 = fastDateFormat0.parseToken(""#fgg0XqGjy$K(D"", intArray0);
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test03116() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    int[] intArray0 = new int[6];
    String string0 = fastDateFormat0.parseToken(""#fgg0XqGjy$K(D"", intArray0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = (FastDateFormat) cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test04127() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofHoursMinutes(0, 0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test04139() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofHoursMinutes(0, 0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test04140() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofHoursMinutes(0, 0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test04141() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofHoursMinutes(0, 0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Parse the pattern
//-----------------------------------------------------------------------
/**
 * <p>Returns a list of Rules given a pattern.</p>
 *
 * @return a <code>List</code> of Rule objects
 * @throws IllegalArgumentException if pattern is invalid
 */
protected List parsePattern() {
    DateFormatSymbols symbols = new DateFormatSymbols(mLocale);
    List rules = new ArrayList();
    String[] ERAs = symbols.getEras();
    String[] months = symbols.getMonths();
    String[] shortMonths = symbols.getShortMonths();
    String[] weekdays = symbols.getWeekdays();
    String[] shortWeekdays = symbols.getShortWeekdays();
    String[] AmPmStrings = symbols.getAmPmStrings();
    int length = mPattern.length();
    int[] indexRef = new int[1];
    for (int i = 0; i < length; i++) {
        indexRef[0] = i;
        String token = parseToken(mPattern, indexRef);
        i = indexRef[0];
        int tokenLen = token.length();
        if (tokenLen == 0) {
            break;
        }
        Rule rule;
        char c = token.charAt(0);
        switch(c) {
            case // era designator (text)
            'G':
                rule = new TextField(Calendar.ERA, ERAs);
                break;
            case // year (number)
            'y':
                if (tokenLen >= 4) {
                    rule = selectNumberRule(Calendar.YEAR, tokenLen);
                } else {
                    rule = TwoDigitYearField.INSTANCE;
                }
                break;
            case // month in year (text and number)
            'M':
                if (tokenLen >= 4) {
                    rule = new TextField(Calendar.MONTH, months);
                } else if (tokenLen == 3) {
                    rule = new TextField(Calendar.MONTH, shortMonths);
                } else if (tokenLen == 2) {
                    rule = TwoDigitMonthField.INSTANCE;
                } else {
                    rule = UnpaddedMonthField.INSTANCE;
                }
                break;
            case // day in month (number)
            'd':
                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);
                break;
            case // hour in am/pm (number, 1..12)
            'h':
                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));
                break;
            case // hour in day (number, 0..23)
            'H':
                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);
                break;
            case // minute in hour (number)
            'm':
                rule = selectNumberRule(Calendar.MINUTE, tokenLen);
                break;
            case // second in minute (number)
            's':
                rule = selectNumberRule(Calendar.SECOND, tokenLen);
                break;
            case // millisecond (number)
            'S':
                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);
                break;
            case // day in week (text)
            'E':
                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);
                break;
            case // day in year (number)
            'D':
                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);
                break;
            case // day of week in month (number)
            'F':
                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);
                break;
            case // week in year (number)
            'w':
                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);
                break;
            case // week in month (number)
            'W':
                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);
                break;
            case // am/pm marker (text)
            'a':
                rule = new TextField(Calendar.AM_PM, AmPmStrings);
                break;
            case // hour in day (1..24)
            'k':
                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));
                break;
            case // hour in am/pm (0..11)
            'K':
                rule = selectNumberRule(Calendar.HOUR, tokenLen);
                break;
            case // time zone (text)
            'z':
                if (tokenLen >= 4) {
                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.LONG);
                } else {
                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.SHORT);
                }
                break;
            case // time zone (value)
            'Z':
                if (tokenLen == 1) {
                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;
                } else {
                    rule = TimeZoneNumberRule.INSTANCE_COLON;
                }
                break;
            case // literal text
            '\'':
                String sub = token.substring(1);
                if (sub.length() == 1) {
                    rule = new CharacterLiteral(sub.charAt(0));
                } else {
                    rule = new StringLiteral(sub);
                }
                break;
            default:
                throw new IllegalArgumentException(""Illegal pattern component: "" + token);
        }
        rules.add(rule);
    }
    return rules;
}","public void test04142() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofHoursMinutes(0, 0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    List list0 = fastDateFormat0.parsePattern();
    assertEquals(2, FastDateFormat.MEDIUM);
}",""
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test04154() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofHoursMinutes(0, 0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    List list0 = fastDateFormat0.parsePattern();
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test04155() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofHoursMinutes(0, 0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    List list0 = fastDateFormat0.parsePattern();
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test04156() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofHoursMinutes(0, 0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    List list0 = fastDateFormat0.parsePattern();
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Parse the pattern
//-----------------------------------------------------------------------
/**
 * <p>Returns a list of Rules given a pattern.</p>
 *
 * @return a <code>List</code> of Rule objects
 * @throws IllegalArgumentException if pattern is invalid
 */
protected List parsePattern() {
    DateFormatSymbols symbols = new DateFormatSymbols(mLocale);
    List rules = new ArrayList();
    String[] ERAs = symbols.getEras();
    String[] months = symbols.getMonths();
    String[] shortMonths = symbols.getShortMonths();
    String[] weekdays = symbols.getWeekdays();
    String[] shortWeekdays = symbols.getShortWeekdays();
    String[] AmPmStrings = symbols.getAmPmStrings();
    int length = mPattern.length();
    int[] indexRef = new int[1];
    for (int i = 0; i < length; i++) {
        indexRef[0] = i;
        String token = parseToken(mPattern, indexRef);
        i = indexRef[0];
        int tokenLen = token.length();
        if (tokenLen == 0) {
            break;
        }
        Rule rule;
        char c = token.charAt(0);
        switch(c) {
            case // era designator (text)
            'G':
                rule = new TextField(Calendar.ERA, ERAs);
                break;
            case // year (number)
            'y':
                if (tokenLen >= 4) {
                    rule = selectNumberRule(Calendar.YEAR, tokenLen);
                } else {
                    rule = TwoDigitYearField.INSTANCE;
                }
                break;
            case // month in year (text and number)
            'M':
                if (tokenLen >= 4) {
                    rule = new TextField(Calendar.MONTH, months);
                } else if (tokenLen == 3) {
                    rule = new TextField(Calendar.MONTH, shortMonths);
                } else if (tokenLen == 2) {
                    rule = TwoDigitMonthField.INSTANCE;
                } else {
                    rule = UnpaddedMonthField.INSTANCE;
                }
                break;
            case // day in month (number)
            'd':
                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);
                break;
            case // hour in am/pm (number, 1..12)
            'h':
                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));
                break;
            case // hour in day (number, 0..23)
            'H':
                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);
                break;
            case // minute in hour (number)
            'm':
                rule = selectNumberRule(Calendar.MINUTE, tokenLen);
                break;
            case // second in minute (number)
            's':
                rule = selectNumberRule(Calendar.SECOND, tokenLen);
                break;
            case // millisecond (number)
            'S':
                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);
                break;
            case // day in week (text)
            'E':
                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);
                break;
            case // day in year (number)
            'D':
                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);
                break;
            case // day of week in month (number)
            'F':
                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);
                break;
            case // week in year (number)
            'w':
                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);
                break;
            case // week in month (number)
            'W':
                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);
                break;
            case // am/pm marker (text)
            'a':
                rule = new TextField(Calendar.AM_PM, AmPmStrings);
                break;
            case // hour in day (1..24)
            'k':
                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));
                break;
            case // hour in am/pm (0..11)
            'K':
                rule = selectNumberRule(Calendar.HOUR, tokenLen);
                break;
            case // time zone (text)
            'z':
                if (tokenLen >= 4) {
                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.LONG);
                } else {
                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.SHORT);
                }
                break;
            case // time zone (value)
            'Z':
                if (tokenLen == 1) {
                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;
                } else {
                    rule = TimeZoneNumberRule.INSTANCE_COLON;
                }
                break;
            case // literal text
            '\'':
                String sub = token.substring(1);
                if (sub.length() == 1) {
                    rule = new CharacterLiteral(sub.charAt(0));
                } else {
                    rule = new StringLiteral(sub);
                }
                break;
            default:
                throw new IllegalArgumentException(""Illegal pattern component: "" + token);
        }
        rules.add(rule);
    }
    return rules;
}","public void test05167() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    List list0 = fastDateFormat0.parsePattern();
    assertEquals(2, FastDateFormat.MEDIUM);
}",""
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test05172() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    List list0 = fastDateFormat0.parsePattern();
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test05173() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    List list0 = fastDateFormat0.parsePattern();
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test05174() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    List list0 = fastDateFormat0.parsePattern();
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test06202() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofHoursMinutes(0, 0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    boolean boolean0 = fastDateFormat0.getTimeZoneOverridesCalendar();
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test06214() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofHoursMinutes(0, 0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    boolean boolean0 = fastDateFormat0.getTimeZoneOverridesCalendar();
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test06215() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofHoursMinutes(0, 0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    boolean boolean0 = fastDateFormat0.getTimeZoneOverridesCalendar();
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test06216() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofHoursMinutes(0, 0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    boolean boolean0 = fastDateFormat0.getTimeZoneOverridesCalendar();
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets the time zone display name, using a cache for performance.</p>
 *
 * @param tz  the zone to query
 * @param daylight  true if daylight savings
 * @param style  the style to use <code>TimeZone.LONG</code>
 *  or <code>TimeZone.SHORT</code>
 * @param locale  the locale to use
 * @return the textual name of the time zone
 */
static synchronized String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {
    Object key = new TimeZoneDisplayKey(tz, daylight, style, locale);
    String value = (String) cTimeZoneDisplayCache.get(key);
    if (value == null) {
        // This is a very slow call, so cache the results.
        value = tz.getDisplayName(daylight, style, locale);
        cTimeZoneDisplayCache.put(key, value);
    }
    return value;
}","public void test07227() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.MIN;
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.ENGLISH;
    String string0 = FastDateFormat.getTimeZoneDisplay(timeZone0, false, 0, locale0);
    assertNotNull(string0);
}",""
"public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {
    return getDateInstance(style, timeZone, null);
}","public void test08242() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(2596, ""0\""ED.Cahr1Cm/{Vt"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test08252() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(2596, ""0\""ED.Cahr1Cm/{Vt"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    assertEquals(31, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test08253() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(2596, ""0\""ED.Cahr1Cm/{Vt"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    assertEquals(""EEEE, MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test08254() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(2596, ""0\""ED.Cahr1Cm/{Vt"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public TimeZone getTimeZone() {
    return mTimeZone;
}","public void test08255() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(2596, ""0\""ED.Cahr1Cm/{Vt"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    TimeZone timeZone0 = fastDateFormat0.getTimeZone();
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets the time zone used by this formatter.</p>
 *
 * <p>This zone is always used for <code>Date</code> formatting.
 * If a <code>Calendar</code> is passed in to be formatted, the
 * time zone on that may be used depending on
 * {@link #getTimeZoneOverridesCalendar()}.</p>
 *
 * @return the time zone
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test08267() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(2596, ""0\""ED.Cahr1Cm/{Vt"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    TimeZone timeZone0 = fastDateFormat0.getTimeZone();
    assertEquals(31, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test08268() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(2596, ""0\""ED.Cahr1Cm/{Vt"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    TimeZone timeZone0 = fastDateFormat0.getTimeZone();
    assertEquals(""EEEE, MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test08269() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(2596, ""0\""ED.Cahr1Cm/{Vt"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    TimeZone timeZone0 = fastDateFormat0.getTimeZone();
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test08274() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(2596, ""0\""ED.Cahr1Cm/{Vt"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    TimeZone timeZone0 = fastDateFormat0.getTimeZone();
    assertEquals(""java.util.SimpleTimeZone[id=0\""ED.Cahr1Cm/{Vt,offset=2596,dstSavings=3600000,useDaylight=false,startYear=0,startMode=0,startMonth=0,startDay=0,startDayOfWeek=0,startTime=0,startTimeMode=0,endMode=0,endMonth=0,endDay=0,endDayOfWeek=0,endTime=0,endTimeMode=0]"", timeZone0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public static FastDateFormat getTimeInstance(int style, TimeZone timeZone) {
    return getTimeInstance(style, timeZone, null);
}","public void test09281() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a time formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted time
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test09291() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0);
    assertEquals(""h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test09292() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test09293() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0);
    assertEquals(23, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public TimeZone getTimeZone() {
    return mTimeZone;
}","public void test09294() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0);
    TimeZone timeZone0 = fastDateFormat0.getTimeZone();
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets the time zone used by this formatter.</p>
 *
 * <p>This zone is always used for <code>Date</code> formatting.
 * If a <code>Calendar</code> is passed in to be formatted, the
 * time zone on that may be used depending on
 * {@link #getTimeZoneOverridesCalendar()}.</p>
 *
 * @return the time zone
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test09306() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0);
    TimeZone timeZone0 = fastDateFormat0.getTimeZone();
    assertEquals(""h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test09307() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0);
    TimeZone timeZone0 = fastDateFormat0.getTimeZone();
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test09308() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0);
    TimeZone timeZone0 = fastDateFormat0.getTimeZone();
    assertEquals(23, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test09312() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0);
    TimeZone timeZone0 = fastDateFormat0.getTimeZone();
    assertEquals(""java.util.SimpleTimeZone[id=IH2,offset=0,dstSavings=3600000,useDaylight=false,startYear=0,startMode=0,startMonth=0,startDay=0,startDayOfWeek=0,startTime=0,startTimeMode=0,endMode=0,endMonth=0,endDay=0,endDayOfWeek=0,endTime=0,endTimeMode=0]"", timeZone0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test10321() throws Throwable {
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test10332() throws Throwable {
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test10333() throws Throwable {
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test10334() throws Throwable {
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test10335() throws Throwable {
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    String string0 = fastDateFormat0.getPattern();
    assertEquals(1, FastDateFormat.LONG);
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test10347() throws Throwable {
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    String string0 = fastDateFormat0.getPattern();
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test10348() throws Throwable {
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    String string0 = fastDateFormat0.getPattern();
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test10349() throws Throwable {
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    String string0 = fastDateFormat0.getPattern();
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test11357() throws Throwable {
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test11368() throws Throwable {
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test11369() throws Throwable {
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test11370() throws Throwable {
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test11371() throws Throwable {
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test11382() throws Throwable {
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test11383() throws Throwable {
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test11384() throws Throwable {
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = (FastDateFormat) cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test12398() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3193, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""yyyy'\uB144' M'\uC6D4' d'\uC77C' EEEE a h'\uC2DC' mm'\uBD84' ss'\uCD08' z"", (TimeZone) simpleTimeZone0, locale0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test12414() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3193, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""yyyy'\uB144' M'\uC6D4' d'\uC77C' EEEE a h'\uC2DC' mm'\uBD84' ss'\uCD08' z"", (TimeZone) simpleTimeZone0, locale0);
    assertEquals(46, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test12415() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3193, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""yyyy'\uB144' M'\uC6D4' d'\uC77C' EEEE a h'\uC2DC' mm'\uBD84' ss'\uCD08' z"", (TimeZone) simpleTimeZone0, locale0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test12416() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3193, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""yyyy'\uB144' M'\uC6D4' d'\uC77C' EEEE a h'\uC2DC' mm'\uBD84' ss'\uCD08' z"", (TimeZone) simpleTimeZone0, locale0);
    assertEquals(""yyyy'\uB144' M'\uC6D4' d'\uC77C' EEEE a h'\uC2DC' mm'\uBD84' ss'\uCD08' z"", fastDateFormat0.getPattern());
}",""
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test13417() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test13422() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test13423() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test13424() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test14432() throws Throwable {
    Locale locale0 = Locale.ITALIAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""'XETJC"", locale0);
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test14443() throws Throwable {
    Locale locale0 = Locale.ITALIAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""'XETJC"", locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test14444() throws Throwable {
    Locale locale0 = Locale.ITALIAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""'XETJC"", locale0);
    assertEquals(""'XETJC"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test14445() throws Throwable {
    Locale locale0 = Locale.ITALIAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""'XETJC"", locale0);
    assertEquals(5, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test15446() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""sa"");
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test15451() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""sa"");
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test15452() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""sa"");
    assertEquals(""sa"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test15453() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""sa"");
    assertEquals(6, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {
    return getDateInstance(style, timeZone, null);
}","public void test16454() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(1, (TimeZone) null);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test16459() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(1, (TimeZone) null);
    assertEquals(""MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test16460() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(1, (TimeZone) null);
    assertEquals(20, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test16461() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(1, (TimeZone) null);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = (FastDateFormat) cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test17469() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test17480() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test17481() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test17482() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public StringBuffer format(Date date, StringBuffer buf) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, buf);
}","public void test17484() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    MockDate mockDate0 = new MockDate();
    StringBuffer stringBuffer0 = fastDateFormat0.format((Date) mockDate0, (StringBuffer) null);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Formats a <code>Date</code> object into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param date  the date to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test17495() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    MockDate mockDate0 = new MockDate();
    StringBuffer stringBuffer0 = fastDateFormat0.format((Date) mockDate0, (StringBuffer) null);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test17496() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    MockDate mockDate0 = new MockDate();
    StringBuffer stringBuffer0 = fastDateFormat0.format((Date) mockDate0, (StringBuffer) null);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test17497() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    MockDate mockDate0 = new MockDate();
    StringBuffer stringBuffer0 = fastDateFormat0.format((Date) mockDate0, (StringBuffer) null);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test17498() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    MockDate mockDate0 = new MockDate();
    StringBuffer stringBuffer0 = fastDateFormat0.format((Date) mockDate0, (StringBuffer) null);
    assertEquals(""Fri Feb 14 20:21:21 GMT 2014"", mockDate0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public String format(Date date) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test18521() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    MockDate mockDate0 = new MockDate();
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Formats a <code>Date</code> object.</p>
 *
 * @param date  the date to format
 * @return the formatted string
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test18533() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    MockDate mockDate0 = new MockDate();
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test18534() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    MockDate mockDate0 = new MockDate();
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test18535() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    MockDate mockDate0 = new MockDate();
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test18536() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    MockDate mockDate0 = new MockDate();
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals(""Fri Feb 14 20:21:21 GMT 2014"", mockDate0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test19543() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, (-1), (-1), 0, (-1), 0, 4682, (-2182), (-2182), 9);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test19553() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, (-1), (-1), 0, (-1), 0, 4682, (-2182), (-2182), 9);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test19554() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, (-1), (-1), 0, (-1), 0, 4682, (-2182), (-2182), 9);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test19555() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, (-1), (-1), 0, (-1), 0, 4682, (-2182), (-2182), 9);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public StringBuffer format(Calendar calendar, StringBuffer buf) {
    if (mTimeZoneForced) {
        calendar = (Calendar) calendar.clone();
        calendar.setTimeZone(mTimeZone);
    }
    return applyRules(calendar, buf);
}","public void test19567() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, (-1), (-1), 0, (-1), 0, 4682, (-2182), (-2182), 9);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0);
    Locale locale0 = Locale.ITALY;
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) """");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Calendar) mockGregorianCalendar0, stringBuffer0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Formats a <code>Calendar</code> object into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param calendar  the calendar to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test19579() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, (-1), (-1), 0, (-1), 0, 4682, (-2182), (-2182), 9);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0);
    Locale locale0 = Locale.ITALY;
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) """");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Calendar) mockGregorianCalendar0, stringBuffer0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test19580() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, (-1), (-1), 0, (-1), 0, 4682, (-2182), (-2182), 9);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0);
    Locale locale0 = Locale.ITALY;
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) """");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Calendar) mockGregorianCalendar0, stringBuffer0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test19581() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, (-1), (-1), 0, (-1), 0, 4682, (-2182), (-2182), 9);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0);
    Locale locale0 = Locale.ITALY;
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) """");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Calendar) mockGregorianCalendar0, stringBuffer0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test19589() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, (-1), (-1), 0, (-1), 0, 4682, (-2182), (-2182), 9);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0);
    Locale locale0 = Locale.ITALY;
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) """");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Calendar) mockGregorianCalendar0, stringBuffer0);
    assertEquals(""org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=1392409281320,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\""GMT\"",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=2,minimalDaysInFirstWeek=4,ERA=1,YEAR=2014,MONTH=1,WEEK_OF_YEAR=7,WEEK_OF_MONTH=2,DAY_OF_MONTH=14,DAY_OF_YEAR=45,DAY_OF_WEEK=6,DAY_OF_WEEK_IN_MONTH=2,AM_PM=1,HOUR=8,HOUR_OF_DAY=20,MINUTE=21,SECOND=21,MILLISECOND=320,ZONE_OFFSET=0,DST_OFFSET=0]"", mockGregorianCalendar0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test20596() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test20601() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test20602() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test20603() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public String format(Calendar calendar) {
    return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test20613() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    Calendar calendar0 = mockSimpleDateFormat0.getCalendar();
    String string0 = fastDateFormat0.format(calendar0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Formats a <code>Calendar</code> object.</p>
 *
 * @param calendar  the calendar to format
 * @return the formatted string
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test20619() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    Calendar calendar0 = mockSimpleDateFormat0.getCalendar();
    String string0 = fastDateFormat0.format(calendar0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test20620() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    Calendar calendar0 = mockSimpleDateFormat0.getCalendar();
    String string0 = fastDateFormat0.format(calendar0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test20621() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    Calendar calendar0 = mockSimpleDateFormat0.getCalendar();
    String string0 = fastDateFormat0.format(calendar0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test21636() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test21647() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test21648() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test21649() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public String format(long millis) {
    return format(new Date(millis));
}","public void test21650() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    String string0 = fastDateFormat0.format(2480L);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Formats a millisecond <code>long</code> value.</p>
 *
 * @param millis  the millisecond value to format
 * @return the formatted string
 * @since 2.1
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test21662() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    String string0 = fastDateFormat0.format(2480L);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test21663() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    String string0 = fastDateFormat0.format(2480L);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test21664() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    String string0 = fastDateFormat0.format(2480L);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"protected String parseToken(String pattern, int[] indexRef) {
    StringBuffer buf = new StringBuffer();
    int i = indexRef[0];
    int length = pattern.length();
    char c = pattern.charAt(i);
    if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {
        // Scan a run of the same character, which indicates a time
        // pattern.
        buf.append(c);
        while (i + 1 < length) {
            char peek = pattern.charAt(i + 1);
            if (peek == c) {
                buf.append(c);
                i++;
            } else {
                break;
            }
        }
    } else {
        // This will identify token as text.
        buf.append('\'');
        boolean inLiteral = false;
        for (; i < length; i++) {
            c = pattern.charAt(i);
            if (c == '\'') {
                if (i + 1 < length && pattern.charAt(i + 1) == '\'') {
                    // '' is treated as escaped '
                    i++;
                    buf.append(c);
                } else {
                    inLiteral = !inLiteral;
                }
            } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {
                i--;
                break;
            } else {
                buf.append(c);
            }
        }
    }
    indexRef[0] = i;
    return buf.toString();
}","public void test22686() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, locale0);
    int[] intArray0 = new int[3];
    // Undeclared exception!
    try {
        fastDateFormat0.parseToken("""", intArray0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * <p>Performs the parsing of tokens.</p>
 *
 * @param pattern  the pattern
 * @param indexRef  index references
 * @return parsed token
 */"
"protected String parseToken(String pattern, int[] indexRef) {
    StringBuffer buf = new StringBuffer();
    int i = indexRef[0];
    int length = pattern.length();
    char c = pattern.charAt(i);
    if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {
        // Scan a run of the same character, which indicates a time
        // pattern.
        buf.append(c);
        while (i + 1 < length) {
            char peek = pattern.charAt(i + 1);
            if (peek == c) {
                buf.append(c);
                i++;
            } else {
                break;
            }
        }
    } else {
        // This will identify token as text.
        buf.append('\'');
        boolean inLiteral = false;
        for (; i < length; i++) {
            c = pattern.charAt(i);
            if (c == '\'') {
                if (i + 1 < length && pattern.charAt(i + 1) == '\'') {
                    // '' is treated as escaped '
                    i++;
                    buf.append(c);
                } else {
                    inLiteral = !inLiteral;
                }
            } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {
                i--;
                break;
            } else {
                buf.append(c);
            }
        }
    }
    indexRef[0] = i;
    return buf.toString();
}","public void test23695() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    // Undeclared exception!
    try {
        fastDateFormat0.parseToken("""", (int[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Performs the parsing of tokens.</p>
 *
 * @param pattern  the pattern
 * @param indexRef  index references
 * @return parsed token
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets the time zone display name, using a cache for performance.</p>
 *
 * @param tz  the zone to query
 * @param daylight  true if daylight savings
 * @param style  the style to use <code>TimeZone.LONG</code>
 *  or <code>TimeZone.SHORT</code>
 * @param locale  the locale to use
 * @return the textual name of the time zone
 */
static synchronized String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {
    Object key = new TimeZoneDisplayKey(tz, daylight, style, locale);
    String value = (String) cTimeZoneDisplayCache.get(key);
    if (value == null) {
        // This is a very slow call, so cache the results.
        value = tz.getDisplayName(daylight, style, locale);
        cTimeZoneDisplayCache.put(key, value);
    }
    return value;
}","public void test24703() throws Throwable {
    Locale locale0 = Locale.GERMAN;
    // Undeclared exception!
    try {
        FastDateFormat.getTimeZoneDisplay((TimeZone) null, false, 0, locale0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}",""
"public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = new Integer(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale != null) {
        key = new Pair(key, locale);
    }
    FastDateFormat format = (FastDateFormat) cTimeInstanceCache.get(key);
    if (format == null) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getTimeInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cTimeInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test25713() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.forLanguageTag(""A:="");
    // Undeclared exception!
    try {
        FastDateFormat.getTimeInstance(2623, timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style 2623
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a time formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted time
 * @param locale  optional locale, overrides system locale
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 */"
"public static FastDateFormat getTimeInstance(int style, TimeZone timeZone) {
    return getTimeInstance(style, timeZone, null);
}","public void test26720() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    // Undeclared exception!
    try {
        FastDateFormat.getTimeInstance(15, (TimeZone) simpleTimeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style 15
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a time formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted time
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */"
"public static FastDateFormat getTimeInstance(int style, Locale locale) {
    return getTimeInstance(style, null, locale);
}","public void test27728() throws Throwable {
    Locale locale0 = Locale.GERMAN;
    // Undeclared exception!
    try {
        FastDateFormat.getTimeInstance(739, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style 739
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a time formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a time formatter instance using the specified style in the
 * default time zone and locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getTimeInstance(int style) {
    return getTimeInstance(style, null, null);
}","public void test28729() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getTimeInstance(100);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style 100
        //
        verifyException(""java.text.DateFormat"", e);
    }
}",""
"public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone) {
    return getDateTimeInstance(dateStyle, timeStyle, timeZone, null);
}","public void test29732() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    // Undeclared exception!
    try {
        FastDateFormat.getDateTimeInstance((-339), (-339), timeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style -339
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date/time formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a date/time formatter instance using the specified style
 * in the default time zone and locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle) {
    return getDateTimeInstance(dateStyle, timeStyle, null, null);
}","public void test30733() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getDateTimeInstance(13, 31);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style 31
        //
        verifyException(""java.text.DateFormat"", e);
    }
}",""
"public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {
    return getDateInstance(style, timeZone, null);
}","public void test31740() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(6, ""`{,s8u`5e* '8 v"");
    // Undeclared exception!
    try {
        FastDateFormat.getDateInstance(6, (TimeZone) simpleTimeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style 6
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"public static FastDateFormat getDateInstance(int style, Locale locale) {
    return getDateInstance(style, null, locale);
}","public void test32748() throws Throwable {
    Locale locale0 = new Locale("""");
    // Undeclared exception!
    try {
        FastDateFormat.getDateInstance((-1), locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style -1
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a date formatter instance using the specified style in the
 * default time zone and locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getDateInstance(int style) {
    return getDateInstance(style, null, null);
}","public void test33749() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getDateInstance((-2289));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style -2289
        //
        verifyException(""java.text.DateFormat"", e);
    }
}",""
"public StringBuffer format(Date date, StringBuffer buf) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, buf);
}","public void test34759() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate(10, 835, 0);
    // Undeclared exception!
    try {
        fastDateFormat0.format((Date) mockDate0, (StringBuffer) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat$UnpaddedMonthField"", e);
    }
}","/**
 * <p>Formats a <code>Date</code> object into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param date  the date to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"public String format(Date date) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test35768() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    // Undeclared exception!
    try {
        fastDateFormat0.format((Date) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""java.util.Calendar"", e);
    }
}","/**
 * <p>Formats a <code>Date</code> object.</p>
 *
 * @param date  the date to format
 * @return the formatted string
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a time formatter instance using the specified style in the
 * default time zone and locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getTimeInstance(int style) {
    return getTimeInstance(style, null, null);
}","public void test36769() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0);
    assertEquals(3, FastDateFormat.SHORT);
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test36774() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test36775() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0);
    assertEquals(""h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test36776() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0);
    assertEquals(18, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public StringBuffer format(long millis, StringBuffer buf) {
    return format(new Date(millis), buf);
}","public void test36777() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0);
    // Undeclared exception!
    try {
        fastDateFormat0.format(0L, (StringBuffer) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat$UnpaddedNumberField"", e);
    }
}","/**
 * <p>Formats a milliseond <code>long</code> value into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param millis  the millisecond value to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 * @since 2.1
 */"
"// Constructor
//-----------------------------------------------------------------------
/**
 * <p>Constructs a new FastDateFormat.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  time zone to use, <code>null</code> means use
 *  default for <code>Date</code> and value within for
 *  <code>Calendar</code>
 * @param locale  locale, <code>null</code> means use system
 *  default
 * @throws IllegalArgumentException if pattern is invalid or
 *  <code>null</code>
 */
protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {
    super();
    if (pattern == null) {
        throw new IllegalArgumentException(""The pattern must not be null"");
    }
    mPattern = pattern;
    mTimeZoneForced = (timeZone != null);
    if (timeZone == null) {
        timeZone = TimeZone.getDefault();
    }
    mTimeZone = timeZone;
    mLocaleForced = (locale != null);
    if (locale == null) {
        locale = Locale.getDefault();
    }
    mLocale = locale;
}","public void test37787() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.ITALIAN;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    assertEquals(2, FastDateFormat.MEDIUM);
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test37799() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.ITALIAN;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test37800() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.ITALIAN;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test37801() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.ITALIAN;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public String format(long millis) {
    return format(new Date(millis));
}","public void test37802() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.ITALIAN;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    // Undeclared exception!
    try {
        fastDateFormat0.format(0L);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Formats a millisecond <code>long</code> value.</p>
 *
 * @param millis  the millisecond value to format
 * @return the formatted string
 * @since 2.1
 */"
"protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {
    Rule[] rules = mRules;
    int len = mRules.length;
    for (int i = 0; i < len; i++) {
        rules[i].appendTo(buf, calendar);
    }
    return buf;
}","public void test38814() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    StringBuffer stringBuffer0 = new StringBuffer(""No date time pattern for locale: "");
    // Undeclared exception!
    try {
        fastDateFormat0.applyRules((Calendar) null, stringBuffer0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat$TextField"", e);
    }
}","/**
 * <p>Performs the formatting by applying the rules to the
 * specified calendar.</p>
 *
 * @param calendar  the calendar to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"public String format(Calendar calendar) {
    return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test39843() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    Calendar calendar0 = mockSimpleDateFormat0.getCalendar();
    String string0 = fastDateFormat0.format(calendar0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Formats a <code>Calendar</code> object.</p>
 *
 * @param calendar  the calendar to format
 * @return the formatted string
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test39854() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    Calendar calendar0 = mockSimpleDateFormat0.getCalendar();
    String string0 = fastDateFormat0.format(calendar0);
    assertEquals(23, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test39855() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    Calendar calendar0 = mockSimpleDateFormat0.getCalendar();
    String string0 = fastDateFormat0.format(calendar0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test39856() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    Calendar calendar0 = mockSimpleDateFormat0.getCalendar();
    String string0 = fastDateFormat0.format(calendar0);
    assertEquals(""h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public int hashCode() {
    int total = 0;
    total += mPattern.hashCode();
    total += mTimeZone.hashCode();
    total += (mTimeZoneForced ? 1 : 0);
    total += mLocale.hashCode();
    total += (mLocaleForced ? 1 : 0);
    return total;
}","public void test40872() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    fastDateFormat0.hashCode();
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Returns a hashcode compatible with equals.</p>
 *
 * @return a hashcode compatible with equals
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test40876() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    fastDateFormat0.hashCode();
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test40877() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    fastDateFormat0.hashCode();
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test40878() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    fastDateFormat0.hashCode();
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public StringBuffer format(Calendar calendar, StringBuffer buf) {
    if (mTimeZoneForced) {
        calendar = (Calendar) calendar.clone();
        calendar.setTimeZone(mTimeZone);
    }
    return applyRules(calendar, buf);
}","public void test41895() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    Locale locale0 = Locale.US;
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(locale0);
    // Undeclared exception!
    try {
        fastDateFormat0.format((Calendar) mockGregorianCalendar0, (StringBuffer) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat$UnpaddedMonthField"", e);
    }
}","/**
 * <p>Formats a <code>Calendar</code> object into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param calendar  the calendar to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone, Locale locale) {
    Object key = new Pair(new Integer(dateStyle), new Integer(timeStyle));
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale != null) {
        key = new Pair(key, locale);
    }
    FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);
    if (format == null) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cDateTimeInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date time pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test42896() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getDateTimeInstance((-1105), 0, (TimeZone) null, (Locale) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style -1105
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date/time formatter instance using the specified style,
 * time zone and locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 */"
"public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone, Locale locale) {
    Object key = new Pair(new Integer(dateStyle), new Integer(timeStyle));
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale != null) {
        key = new Pair(key, locale);
    }
    FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);
    if (format == null) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cDateTimeInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date time pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test43906() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("" 9JtTd.$cJi'MXwGE"");
    Locale locale0 = Locale.KOREA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 2, timeZone0, locale0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a date/time formatter instance using the specified style,
 * time zone and locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test43918() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("" 9JtTd.$cJi'MXwGE"");
    Locale locale0 = Locale.KOREA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 2, timeZone0, locale0);
    assertEquals(33, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test43919() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("" 9JtTd.$cJi'MXwGE"");
    Locale locale0 = Locale.KOREA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 2, timeZone0, locale0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test43920() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("" 9JtTd.$cJi'MXwGE"");
    Locale locale0 = Locale.KOREA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 2, timeZone0, locale0);
    assertEquals(""yyyy'\uB144' M'\uC6D4' d'\uC77C' EEEE a h:mm:ss"", fastDateFormat0.getPattern());
}",""
"public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = new Integer(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale != null) {
        key = new Pair(key, locale);
    }
    FastDateFormat format = (FastDateFormat) cTimeInstanceCache.get(key);
    if (format == null) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getTimeInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cTimeInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test44928() throws Throwable {
    Locale locale0 = new Locale("""", """", """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) null, locale0);
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Gets a time formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted time
 * @param locale  optional locale, overrides system locale
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test44939() throws Throwable {
    Locale locale0 = new Locale("""", """", """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) null, locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test44940() throws Throwable {
    Locale locale0 = new Locale("""", """", """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) null, locale0);
    assertEquals(""h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test44941() throws Throwable {
    Locale locale0 = new Locale("""", """", """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) null, locale0);
    assertEquals(18, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = new Integer(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale != null) {
        key = new Pair(key, locale);
    }
    FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);
    if (format == null) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cDateInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test45955() throws Throwable {
    Locale locale0 = Locale.GERMANY;
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, 7, 2, 3, (-424), 0, 3, 1102, 7, 118);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0, locale0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a date formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test45971() throws Throwable {
    Locale locale0 = Locale.GERMANY;
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, 7, 2, 3, (-424), 0, 3, 1102, 7, 118);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0, locale0);
    assertEquals(32, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test45972() throws Throwable {
    Locale locale0 = Locale.GERMANY;
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, 7, 2, 3, (-424), 0, 3, 1102, 7, 118);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0, locale0);
    assertEquals(""EEEE, d. MMMM yyyy"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test45973() throws Throwable {
    Locale locale0 = Locale.GERMANY;
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, 7, 2, 3, (-424), 0, 3, 1102, 7, 118);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0, locale0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = new Integer(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale != null) {
        key = new Pair(key, locale);
    }
    FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);
    if (format == null) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cDateInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test46974() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getDateInstance(103, (TimeZone) null, (Locale) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style 103
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 */"
"public StringBuffer format(Date date, StringBuffer buf) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, buf);
}","public void test47987() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate(0, (-1), 2444, 0, (-1));
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""A:="");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Formats a <code>Date</code> object into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param date  the date to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test47994() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate(0, (-1), 2444, 0, (-1));
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""A:="");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test47995() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate(0, (-1), 2444, 0, (-1));
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""A:="");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test47996() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate(0, (-1), 2444, 0, (-1));
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""A:="");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test47997() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate(0, (-1), 2444, 0, (-1));
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""A:="");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertEquals(""Thu Aug 09 23:59:00 GMT 1906"", mockDate0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public String format(Date date) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test481011() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate(4120L);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Formats a <code>Date</code> object.</p>
 *
 * @param date  the date to format
 * @return the formatted string
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test481017() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate(4120L);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test481018() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate(4120L);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test481019() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate(4120L);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test481020() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate(4120L);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals(""Thu Jan 01 00:00:04 GMT 1970"", mockDate0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, Locale locale) {
    return getDateTimeInstance(dateStyle, timeStyle, null, locale);
}","public void test491021() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, (Locale) null);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a date/time formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test491026() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, (Locale) null);
    assertEquals(""EEEE, MMMM d, yyyy h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test491027() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, (Locale) null);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test491028() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, (Locale) null);
    assertEquals(50, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public String format(Calendar calendar) {
    return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test491030() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, (Locale) null);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 1466, 1, 0, (-1));
    String string0 = fastDateFormat0.format((Calendar) mockGregorianCalendar0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Formats a <code>Calendar</code> object.</p>
 *
 * @param calendar  the calendar to format
 * @return the formatted string
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test491036() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, (Locale) null);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 1466, 1, 0, (-1));
    String string0 = fastDateFormat0.format((Calendar) mockGregorianCalendar0);
    assertEquals(""EEEE, MMMM d, yyyy h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test491037() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, (Locale) null);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 1466, 1, 0, (-1));
    String string0 = fastDateFormat0.format((Calendar) mockGregorianCalendar0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test491038() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, (Locale) null);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 1466, 1, 0, (-1));
    String string0 = fastDateFormat0.format((Calendar) mockGregorianCalendar0);
    assertEquals(50, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test491042() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, (Locale) null);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 1466, 1, 0, (-1));
    String string0 = fastDateFormat0.format((Calendar) mockGregorianCalendar0);
    assertEquals(""org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=-58312224060000,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\""GMT\"",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=122,MONTH=1,WEEK_OF_YEAR=9,WEEK_OF_MONTH=5,DAY_OF_MONTH=28,DAY_OF_YEAR=59,DAY_OF_WEEK=6,DAY_OF_WEEK_IN_MONTH=4,AM_PM=1,HOUR=11,HOUR_OF_DAY=23,MINUTE=59,SECOND=0,MILLISECOND=0,ZONE_OFFSET=0,DST_OFFSET=0]"", mockGregorianCalendar0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test501052() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate();
    boolean boolean0 = fastDateFormat0.equals(mockDate0);
    assertEquals(2, FastDateFormat.MEDIUM);
}",""
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test501057() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate();
    boolean boolean0 = fastDateFormat0.equals(mockDate0);
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test501058() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate();
    boolean boolean0 = fastDateFormat0.equals(mockDate0);
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test501059() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate();
    boolean boolean0 = fastDateFormat0.equals(mockDate0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test501060() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate();
    boolean boolean0 = fastDateFormat0.equals(mockDate0);
    assertEquals(""Fri Feb 14 20:21:21 GMT 2014"", mockDate0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = new Integer(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale != null) {
        key = new Pair(key, locale);
    }
    FastDateFormat format = (FastDateFormat) cTimeInstanceCache.get(key);
    if (format == null) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getTimeInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cTimeInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test511074() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, 0, 0, 45, 0, 45, 0, 1);
    Locale locale0 = Locale.CHINA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a time formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted time
 * @param locale  optional locale, overrides system locale
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test511090() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, 0, 0, 45, 0, 45, 0, 1);
    Locale locale0 = Locale.CHINA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test511091() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, 0, 0, 45, 0, 45, 0, 1);
    Locale locale0 = Locale.CHINA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    assertEquals(""ahh'\u65F6'mm'\u5206'ss'\u79D2' z"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test511092() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, 0, 0, 45, 0, 45, 0, 1);
    Locale locale0 = Locale.CHINA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test511093() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, 0, 0, 45, 0, 45, 0, 1);
    Locale locale0 = Locale.CHINA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    Calendar calendar0 = MockCalendar.getInstance(locale0);
    assertNotNull(calendar0);
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public StringBuffer format(Calendar calendar, StringBuffer buf) {
    if (mTimeZoneForced) {
        calendar = (Calendar) calendar.clone();
        calendar.setTimeZone(mTimeZone);
    }
    return applyRules(calendar, buf);
}","public void test511107() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, 0, 0, 45, 0, 45, 0, 1);
    Locale locale0 = Locale.CHINA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    Calendar calendar0 = MockCalendar.getInstance(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""\u4E0A\u534812\u65F600\u520600\u79D2 GMT+00:00"");
    StringBuffer stringBuffer1 = fastDateFormat0.format(calendar0, stringBuffer0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Formats a <code>Calendar</code> object into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param calendar  the calendar to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test511125() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, 0, 0, 45, 0, 45, 0, 1);
    Locale locale0 = Locale.CHINA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    Calendar calendar0 = MockCalendar.getInstance(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""\u4E0A\u534812\u65F600\u520600\u79D2 GMT+00:00"");
    StringBuffer stringBuffer1 = fastDateFormat0.format(calendar0, stringBuffer0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test511126() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, 0, 0, 45, 0, 45, 0, 1);
    Locale locale0 = Locale.CHINA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    Calendar calendar0 = MockCalendar.getInstance(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""\u4E0A\u534812\u65F600\u520600\u79D2 GMT+00:00"");
    StringBuffer stringBuffer1 = fastDateFormat0.format(calendar0, stringBuffer0);
    assertEquals(""ahh'\u65F6'mm'\u5206'ss'\u79D2' z"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test511127() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, 0, 0, 45, 0, 45, 0, 1);
    Locale locale0 = Locale.CHINA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    Calendar calendar0 = MockCalendar.getInstance(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""\u4E0A\u534812\u65F600\u520600\u79D2 GMT+00:00"");
    StringBuffer stringBuffer1 = fastDateFormat0.format(calendar0, stringBuffer0);
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test521151() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    Long long0 = new Long((-1211L));
    AttributedCharacterIterator attributedCharacterIterator0 = fastDateFormat0.formatToCharacterIterator(long0);
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test521152() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    Long long0 = new Long((-1211L));
    AttributedCharacterIterator attributedCharacterIterator0 = fastDateFormat0.formatToCharacterIterator(long0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test521153() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    Long long0 = new Long((-1211L));
    AttributedCharacterIterator attributedCharacterIterator0 = fastDateFormat0.formatToCharacterIterator(long0);
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, Locale locale) {
    return getDateTimeInstance(dateStyle, timeStyle, null, locale);
}","public void test531166() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a date/time formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test531177() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    assertEquals(41, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test531178() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test531179() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    assertEquals(""yyyy'\uB144' M'\uC6D4' d'\uC77C' EEEE a h'\uC2DC' mm'\uBD84' ss'\uCD08' z"", fastDateFormat0.getPattern());
}",""
"// Format methods
//-----------------------------------------------------------------------
/**
 * <p>Formats a <code>Date</code>, <code>Calendar</code> or
 * <code>Long</code> (milliseconds) object.</p>
 *
 * @param obj  the object to format
 * @param toAppendTo  the buffer to append to
 * @param pos  the position - ignored
 * @return the buffer passed in
 */
public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
    if (obj instanceof Date) {
        return format((Date) obj, toAppendTo);
    } else if (obj instanceof Calendar) {
        return format((Calendar) obj, toAppendTo);
    } else if (obj instanceof Long) {
        return format(((Long) obj).longValue(), toAppendTo);
    } else {
        throw new IllegalArgumentException(""Unknown class: "" + (obj == null ? ""<null>"" : obj.getClass().getName()));
    }
}","public void test531188() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(11, 3, 2298);
    StringBuffer stringBuffer0 = new StringBuffer(3);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Object) mockGregorianCalendar0, stringBuffer0, fieldPosition0);
    assertEquals(2, FastDateFormat.MEDIUM);
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test531201() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(11, 3, 2298);
    StringBuffer stringBuffer0 = new StringBuffer(3);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Object) mockGregorianCalendar0, stringBuffer0, fieldPosition0);
    assertEquals(41, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test531202() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(11, 3, 2298);
    StringBuffer stringBuffer0 = new StringBuffer(3);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Object) mockGregorianCalendar0, stringBuffer0, fieldPosition0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test531203() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(11, 3, 2298);
    StringBuffer stringBuffer0 = new StringBuffer(3);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Object) mockGregorianCalendar0, stringBuffer0, fieldPosition0);
    assertEquals(""yyyy'\uB144' M'\uC6D4' d'\uC77C' EEEE a h'\uC2DC' mm'\uBD84' ss'\uCD08' z"", fastDateFormat0.getPattern());
}",""
"public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test531206() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(11, 3, 2298);
    StringBuffer stringBuffer0 = new StringBuffer(3);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Object) mockGregorianCalendar0, stringBuffer0, fieldPosition0);
    assertEquals(""org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=-61614000000000,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\""GMT\"",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=17,MONTH=6,WEEK_OF_YEAR=29,WEEK_OF_MONTH=3,DAY_OF_MONTH=15,DAY_OF_YEAR=196,DAY_OF_WEEK=5,DAY_OF_WEEK_IN_MONTH=3,AM_PM=0,HOUR=0,HOUR_OF_DAY=0,MINUTE=0,SECOND=0,MILLISECOND=0,ZONE_OFFSET=0,DST_OFFSET=0]"", mockGregorianCalendar0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"// Format methods
//-----------------------------------------------------------------------
/**
 * <p>Formats a <code>Date</code>, <code>Calendar</code> or
 * <code>Long</code> (milliseconds) object.</p>
 *
 * @param obj  the object to format
 * @param toAppendTo  the buffer to append to
 * @param pos  the position - ignored
 * @return the buffer passed in
 */
public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
    if (obj instanceof Date) {
        return format((Date) obj, toAppendTo);
    } else if (obj instanceof Calendar) {
        return format((Calendar) obj, toAppendTo);
    } else if (obj instanceof Long) {
        return format(((Long) obj).longValue(), toAppendTo);
    } else {
        throw new IllegalArgumentException(""Unknown class: "" + (obj == null ? ""<null>"" : obj.getClass().getName()));
    }
}","public void test541254() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, 0, 0, 45, 0, 45, 0, 1);
    Locale locale0 = Locale.CHINA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""\u4E0A\u534812\u65F600\u520600\u79D2 GMT+00:00"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    // Undeclared exception!
    try {
        fastDateFormat0.format((Object) """", stringBuffer0, fieldPosition0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unknown class: java.lang.String
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}",""
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test551255() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""HmEwv:<G%uK-&"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: v
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test561256() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""|~#+%|r<"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: r
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test571257() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance("".hp7jH`/1_94X/S#"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: p
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test581264() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""org.apache.commons.lang.time.FastDateFormat$TwoDigitMonthField"");
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""org.apache.commons.lang.time.FastDateFormat$TwoDigitMonthField"", (TimeZone) simpleTimeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: o
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test591265() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""<null>"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: n
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test601266() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""F|&l"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: l
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test611267() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""*y%[}sjm@y"", (Locale) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: j
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test621268() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""$h]hz[im+["", (TimeZone) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: i
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = (FastDateFormat) cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test631271() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    // Undeclared exception!
    try {
        FastDateFormat.getInstance("".y^g%D]]q!ZT"", timeZone0, (Locale) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: g
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test641272() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""*#m(F_fi<WsDs3"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: f
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test651280() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""&c+c"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: c
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = (FastDateFormat) cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test661290() throws Throwable {
    ZoneId zoneId0 = ZoneId.systemDefault();
    TimeZone timeZone0 = TimeZone.getTimeZone(zoneId0);
    Locale locale0 = new Locale("""", ""4Yaav@[swc8|"");
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""4Yaav@[swc8|"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: Y
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test671295() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.MIN;
    ZoneId zoneId0 = ZoneId.systemDefault();
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""W9"", timeZone0);
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test671301() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.MIN;
    ZoneId zoneId0 = ZoneId.systemDefault();
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""W9"", timeZone0);
    assertEquals(""W9"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test671302() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.MIN;
    ZoneId zoneId0 = ZoneId.systemDefault();
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""W9"", timeZone0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test671303() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.MIN;
    ZoneId zoneId0 = ZoneId.systemDefault();
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""W9"", timeZone0);
    assertEquals(5, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = (FastDateFormat) cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test681317() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, 0, 0, 45, 0, 45, 0, 1);
    Locale locale0 = Locale.GERMANY;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""Unknown class: "", (TimeZone) simpleTimeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: U
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test691323() throws Throwable {
    Locale locale0 = new Locale(""No date time pattern for locale: "", ""S<qo?y0"");
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""S<qo?y0"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: q
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test701326() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""{363RHP)"", timeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: R
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test711327() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""L"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: L
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test721335() throws Throwable {
    Locale locale0 = Locale.KOREA;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance("" 9JtTd.$cJi'MXwGE"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: J
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test731336() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""IWw|"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: I
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test741337() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""\u4E0A\u534812\u65F600\u520600\u79D2 GMT+00:00"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: T
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test751344() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone((-2446), """");
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""FastDateFormat[EEEE, MMMM d, yyyy h:mm:ss a z]"", (TimeZone) simpleTimeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: t
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test761345() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""C/"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: C
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test771353() throws Throwable {
    Locale locale0 = Locale.forLanguageTag(""%!6BqT/ 2.y"");
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""%!6BqT/ 2.y"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: B
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test781361() throws Throwable {
    Locale locale0 = Locale.CHINA;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""@AwdO6>Z*"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: A
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test791369() throws Throwable {
    Locale locale0 = Locale.CHINA;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance((String) null, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The pattern must not be null
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a formatter instance using the default pattern in the
 * default locale.</p>
 *
 * @return a date/time formatter
 */
public static FastDateFormat getInstance() {
    return getInstance(getDefaultPattern(), null, null);
}","public void test801370() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance();
    assertNotSame(fastDateFormat1, fastDateFormat0);
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test801371() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance();
    assertEquals(21, fastDateFormat1.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test801372() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance();
    assertFalse(fastDateFormat1.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone, Locale locale) {
    Object key = new Pair(new Integer(dateStyle), new Integer(timeStyle));
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale != null) {
        key = new Pair(key, locale);
    }
    FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);
    if (format == null) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cDateTimeInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date time pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test821375() throws Throwable {
    Locale locale0 = new Locale("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 2, (TimeZone) null, locale0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a date/time formatter instance using the specified style,
 * time zone and locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test831376() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    ZoneOffset.ofHoursMinutes(0, 0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    ZoneId.getAvailableZoneIds();
    timeZone0.setID(""sa"");
    zoneOffset0.getRules();
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""sa"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 0);
    decimalFormat0.format((long) 1, stringBuffer0, fieldPosition0);
    Locale locale0 = Locale.UK;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, locale0);
    assertEquals(""HH:mm:ss 'o''clock' z"", fastDateFormat0.getPattern());
}",""
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = (FastDateFormat) cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test841377() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""km\""=7X{|rJ"");
    Locale locale0 = new Locale(""4|<9 ,H| Do&/"", ""IUgG1T[MPmf6/yGLlvX"", ""km\""=7X{|rJ"");
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""km\""=7X{|rJ"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: X
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test851378() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    String string0 = fastDateFormat0.getPattern();
    assertEquals(""yyyy'\uB144' M'\uC6D4' d'\uC77C' EEEE a h'\uC2DC' mm'\uBD84' ss'\uCD08' z"", string0);
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test861380() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    fastDateFormat0.getLocale();
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test871382() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    ParsePosition parsePosition0 = new ParsePosition(1);
    fastDateFormat0.parseObject("""", parsePosition0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public String format(Calendar calendar) {
    return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test881383() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    // Undeclared exception!
    try {
        fastDateFormat0.format((Calendar) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat$TextField"", e);
    }
}","/**
 * <p>Formats a <code>Calendar</code> object.</p>
 *
 * @param calendar  the calendar to format
 * @return the formatted string
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test891384() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3193, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    assertEquals(""M/d/yy h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Gets a date formatter instance using the specified style in the
 * default time zone and locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getDateInstance(int style) {
    return getDateInstance(style, null, null);
}","public void test901385() throws Throwable {
    FastDateFormat.getTimeInstance(0);
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(2);
    assertEquals(2, FastDateFormat.MEDIUM);
}",""
"public String format(long millis) {
    return format(new Date(millis));
}","public void test911386() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    String string0 = fastDateFormat0.format((long) 0);
    assertEquals(""1970\uB144 1\uC6D4 1\uC77C \uBAA9\uC694\uC77C \uC624\uC804 12\uC2DC 00\uBD84 00\uCD08 GMT"", string0);
}","/**
 * <p>Formats a millisecond <code>long</code> value.</p>
 *
 * @param millis  the millisecond value to format
 * @return the formatted string
 * @since 2.1
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test921387() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    boolean boolean0 = fastDateFormat0.getTimeZoneOverridesCalendar();
    assertFalse(boolean0);
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, Locale locale) {
    return getDateTimeInstance(dateStyle, timeStyle, null, locale);
}","public void test931388() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getDateTimeInstance(1960, 0, (Locale) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style 1960
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date/time formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */"
"public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test941389() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0);
    String string0 = fastDateFormat0.toString();
    assertEquals(""FastDateFormat[h:mm:ss a z]"", string0);
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test951390() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0);
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    assertEquals(17, int0);
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Parsing
//-----------------------------------------------------------------------
/**
 * <p>Parsing is not supported.</p>
 *
 * @param source  the string to parse
 * @param pos  the parsing position
 * @return <code>null</code> as not supported
 */
public Object parseObject(String source, ParsePosition pos) {
    pos.setIndex(0);
    pos.setErrorIndex(0);
    return null;
}","public void test961391() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(1, timeZone0);
    // Undeclared exception!
    try {
        fastDateFormat0.parseObject(""\u683C\u6797\u5A01\u6CBB\u65F6\u95F4"", (ParsePosition) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}",""
"public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test971393() throws Throwable {
    Locale locale0 = Locale.CANADA_FRENCH;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(3, locale0);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 0, 3, 3, 337);
    StringBuffer stringBuffer0 = new StringBuffer();
    fastDateFormat0.applyRules(mockGregorianCalendar0, stringBuffer0);
    assertEquals(""org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=-62167188180000,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\""GMT\"",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=0,YEAR=1,MONTH=0,WEEK_OF_YEAR=1,WEEK_OF_MONTH=1,DAY_OF_MONTH=3,DAY_OF_YEAR=3,DAY_OF_WEEK=7,DAY_OF_WEEK_IN_MONTH=1,AM_PM=0,HOUR=8,HOUR_OF_DAY=8,MINUTE=37,SECOND=0,MILLISECOND=0,ZONE_OFFSET=0,DST_OFFSET=0]"", mockGregorianCalendar0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
