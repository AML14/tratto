focal_method,test_prefix,docstring
"public ExtendedMessageFormat(String pattern, Locale locale, Map registry) {
    super(DUMMY_PATTERN);
    setLocale(locale);
    this.registry = registry;
    applyPattern(pattern);
}","public void test000() throws Throwable {
    Locale locale0 = Locale.CANADA_FRENCH;
    HashMap<Locale.LanguageRange, Locale> hashMap0 = new HashMap<Locale.LanguageRange, Locale>();
    HashMap<Locale.LanguageRange, Locale> hashMap1 = new HashMap<Locale.LanguageRange, Locale>(hashMap0);
    ExtendedMessageFormat extendedMessageFormat0 = null;
    try {
        extendedMessageFormat0 = new ExtendedMessageFormat(""htC{kh"", locale0, hashMap1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format argument index at position 5: k
        //
        verifyException(""org.apache.commons.lang.text.ExtendedMessageFormat"", e);
    }
}","/**
 * Create a new ExtendedMessageFormat.
 *
 * @param pattern String
 * @param locale Locale
 * @param registry Registry of format factories:  Map<String, FormatFactory>
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"public void setFormats(Format[] newFormats) {
    throw new UnsupportedOperationException();
}","public void test011() throws Throwable {
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(""2<@Xu"");
    Format[] formatArray0 = new Format[8];
    formatArray0[0] = (Format) extendedMessageFormat0;
    formatArray0[1] = (Format) extendedMessageFormat0;
    formatArray0[2] = (Format) extendedMessageFormat0;
    formatArray0[3] = (Format) extendedMessageFormat0;
    formatArray0[4] = (Format) extendedMessageFormat0;
    formatArray0[5] = (Format) extendedMessageFormat0;
    formatArray0[6] = (Format) extendedMessageFormat0;
    formatArray0[7] = (Format) extendedMessageFormat0;
    // Undeclared exception!
    try {
        extendedMessageFormat0.setFormats(formatArray0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.text.ExtendedMessageFormat"", e);
    }
}","/**
 * {@inheritDoc}
 * @throws UnsupportedOperationException
 */"
"public void setFormatByArgumentIndex(int argumentIndex, Format newFormat) {
    throw new UnsupportedOperationException();
}","public void test022() throws Throwable {
    HashMap<String, Locale> hashMap0 = new HashMap<String, Locale>();
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(""g0E_WlA_<r,-T59|}"", hashMap0);
    int int0 = 184;
    ExtendedMessageFormat extendedMessageFormat1 = new ExtendedMessageFormat(""g0E_WlA_<r,-T59|}"", hashMap0);
    // Undeclared exception!
    try {
        extendedMessageFormat0.setFormatByArgumentIndex(184, extendedMessageFormat1);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.text.ExtendedMessageFormat"", e);
    }
}","/**
 * {@inheritDoc}
 * @throws UnsupportedOperationException
 */"
"public void setFormat(int formatElementIndex, Format newFormat) {
    throw new UnsupportedOperationException();
}","public void test033() throws Throwable {
    Locale locale0 = Locale.forLanguageTag("""");
    HashMap<Object, String> hashMap0 = new HashMap<Object, String>();
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat("""", locale0, hashMap0);
    int int0 = 102;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    Locale.FilteringMode locale_FilteringMode0 = Locale.FilteringMode.AUTOSELECT_FILTERING;
    Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) null, locale_FilteringMode0);
    hashMap0.putIfAbsent((Object) null, (String) null);
    HashMap<Integer, Integer> hashMap1 = new HashMap<Integer, Integer>();
    ExtendedMessageFormat extendedMessageFormat1 = new ExtendedMessageFormat("""", hashMap1);
    // Undeclared exception!
    try {
        extendedMessageFormat0.setFormat(102, extendedMessageFormat1);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.text.ExtendedMessageFormat"", e);
    }
}","/**
 * {@inheritDoc}
 * @throws UnsupportedOperationException
 */"
"public final void applyPattern(String pattern) {
    if (registry == null) {
        super.applyPattern(pattern);
        toPattern = super.toPattern();
        return;
    }
    ArrayList foundFormats = new ArrayList();
    ArrayList foundDescriptions = new ArrayList();
    StringBuffer stripCustom = new StringBuffer(pattern.length());
    ParsePosition pos = new ParsePosition(0);
    char[] c = pattern.toCharArray();
    int fmtCount = 0;
    while (pos.getIndex() < pattern.length()) {
        switch(c[pos.getIndex()]) {
            case QUOTE:
                appendQuotedString(pattern, pos, stripCustom, true);
                break;
            case START_FE:
                fmtCount++;
                seekNonWs(pattern, pos);
                int start = pos.getIndex();
                int index = readArgumentIndex(pattern, next(pos));
                stripCustom.append(START_FE).append(index);
                seekNonWs(pattern, pos);
                Format format = null;
                String formatDescription = null;
                if (c[pos.getIndex()] == START_FMT) {
                    formatDescription = parseFormatDescription(pattern, next(pos));
                    format = getFormat(formatDescription);
                    if (format == null) {
                        stripCustom.append(START_FMT).append(formatDescription);
                    }
                }
                foundFormats.add(format);
                foundDescriptions.add(format == null ? null : formatDescription);
                Validate.isTrue(foundFormats.size() == fmtCount);
                Validate.isTrue(foundDescriptions.size() == fmtCount);
                if (c[pos.getIndex()] != END_FE) {
                    throw new IllegalArgumentException(""Unreadable format element at position "" + start);
                }
            // fall through
            default:
                stripCustom.append(c[pos.getIndex()]);
                next(pos);
        }
    }
    super.applyPattern(stripCustom.toString());
    toPattern = insertFormats(super.toPattern(), foundDescriptions);
    if (containsElements(foundFormats)) {
        Format[] origFormats = getFormats();
        // only loop over what we know we have, as MessageFormat on Java 1.3
        // seems to provide an extra format element:
        int i = 0;
        for (Iterator it = foundFormats.iterator(); it.hasNext(); i++) {
            Format f = (Format) it.next();
            if (f != null) {
                origFormats[i] = f;
            }
        }
        super.setFormats(origFormats);
    }
}","public void test055() throws Throwable {
    HashMap<Integer, String> hashMap0 = new HashMap<Integer, String>();
    hashMap0.put((Integer) null, """");
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat("""", hashMap0);
    // Undeclared exception!
    try {
        extendedMessageFormat0.applyPattern(""--;{,i"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format argument index at position 4: ,
        //
        verifyException(""org.apache.commons.lang.text.ExtendedMessageFormat"", e);
    }
}","/**
 * Apply the specified pattern.
 *
 * @param pattern String
 */"
"public void setFormatsByArgumentIndex(Format[] newFormats) {
    throw new UnsupportedOperationException();
}","public void test077() throws Throwable {
    Locale locale0 = Locale.ENGLISH;
    HashMap<MockDateFormat, MessageFormat> hashMap0 = new HashMap<MockDateFormat, MessageFormat>();
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(""L!4EWV]xDAc?,fWity"", locale0, hashMap0);
    Format[] formatArray0 = new Format[0];
    // Undeclared exception!
    try {
        extendedMessageFormat0.setFormatsByArgumentIndex(formatArray0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.text.ExtendedMessageFormat"", e);
    }
}","/**
 * {@inheritDoc}
 * @throws UnsupportedOperationException
 */"
"public ExtendedMessageFormat(String pattern, Map registry) {
    this(pattern, Locale.getDefault(), registry);
}","public void test088() throws Throwable {
    String string0 = ""Tj>Crp\\ts''!gC0j"";
    HashMap<Locale.LanguageRange, String> hashMap0 = new HashMap<Locale.LanguageRange, String>();
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(""Tj>Crp\ts''!gC0j"", hashMap0);
}","/**
 * Create a new ExtendedMessageFormat for the default locale.
 *
 * @param pattern String
 * @param registry Registry of format factories:  Map<String, FormatFactory>
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"public ExtendedMessageFormat(String pattern, Map registry) {
    this(pattern, Locale.getDefault(), registry);
}","public void test099() throws Throwable {
    HashMap<Object, Object> hashMap0 = new HashMap<Object, Object>();
    ExtendedMessageFormat extendedMessageFormat0 = null;
    try {
        extendedMessageFormat0 = new ExtendedMessageFormat(""Z(Rqm{HtS$"", hashMap0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format argument index at position 6: H
        //
        verifyException(""org.apache.commons.lang.text.ExtendedMessageFormat"", e);
    }
}","/**
 * Create a new ExtendedMessageFormat for the default locale.
 *
 * @param pattern String
 * @param registry Registry of format factories:  Map<String, FormatFactory>
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"public void setFormat(int formatElementIndex, Format newFormat) {
    throw new UnsupportedOperationException();
}","public void test1010() throws Throwable {
    Locale locale0 = Locale.TAIWAN;
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat("""", locale0);
    Locale locale1 = Locale.JAPANESE;
    NumberFormat numberFormat0 = NumberFormat.getIntegerInstance(locale1);
    // Undeclared exception!
    try {
        extendedMessageFormat0.setFormat(0, numberFormat0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.text.ExtendedMessageFormat"", e);
    }
}","/**
 * {@inheritDoc}
 * @throws UnsupportedOperationException
 */"
"public String toPattern() {
    return toPattern;
}","public void test1111() throws Throwable {
    HashMap<Integer, DecimalFormat> hashMap0 = new HashMap<Integer, DecimalFormat>();
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(""Ubi*BVLuS\""c%"", hashMap0);
    extendedMessageFormat0.toPattern();
}","/**
 * {@inheritDoc}
 */"
"public void setFormat(int formatElementIndex, Format newFormat) {
    throw new UnsupportedOperationException();
}","public void test1212() throws Throwable {
    HashMap<MessageFormat, String> hashMap0 = new HashMap<MessageFormat, String>();
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(""org.apache.commons.lang.text.StrMatcher$StringMatcher"", hashMap0);
    extendedMessageFormat0.applyPattern(""org.apache.commons.lang.text.StrMatcher$StringMatcher"");
    NumberFormat numberFormat0 = NumberFormat.getInstance();
    // Undeclared exception!
    try {
        extendedMessageFormat0.setFormat(0, numberFormat0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.text.ExtendedMessageFormat"", e);
    }
}","/**
 * {@inheritDoc}
 * @throws UnsupportedOperationException
 */"
"public void setFormats(Format[] newFormats) {
    throw new UnsupportedOperationException();
}","public void test1313() throws Throwable {
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(""(le[JyF'8FT#C;Sb"");
    Format[] formatArray0 = new Format[2];
    formatArray0[0] = (Format) extendedMessageFormat0;
    formatArray0[1] = (Format) extendedMessageFormat0;
    // Undeclared exception!
    try {
        extendedMessageFormat0.setFormats(formatArray0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.text.ExtendedMessageFormat"", e);
    }
}","/**
 * {@inheritDoc}
 * @throws UnsupportedOperationException
 */"
"public ExtendedMessageFormat(String pattern) {
    this(pattern, Locale.getDefault());
}","public void test1414() throws Throwable {
    String string0 = null;
    ExtendedMessageFormat extendedMessageFormat0 = null;
    try {
        extendedMessageFormat0 = new ExtendedMessageFormat((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Create a new ExtendedMessageFormat for the default locale.
 *
 * @param pattern String
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"public String toPattern() {
    return toPattern;
}","public void test1515() throws Throwable {
    Locale locale0 = Locale.SIMPLIFIED_CHINESE;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    LinkedHashSet<Locale> linkedHashSet0 = new LinkedHashSet<Locale>();
    Locale.FilteringMode locale_FilteringMode0 = Locale.FilteringMode.EXTENDED_FILTERING;
    List<Locale> list0 = Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) linkedHashSet0, locale_FilteringMode0);
    Locale.filter((List<Locale.LanguageRange>) linkedList0, (Collection<Locale>) list0, locale_FilteringMode0);
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat("""", locale0);
    extendedMessageFormat0.toPattern();
}","/**
 * {@inheritDoc}
 */"
"public void setFormatsByArgumentIndex(Format[] newFormats) {
    throw new UnsupportedOperationException();
}","public void test1616() throws Throwable {
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(""a)BS[<b_S%1#Z7e}."");
    Format[] formatArray0 = new Format[5];
    formatArray0[0] = (Format) extendedMessageFormat0;
    formatArray0[1] = (Format) extendedMessageFormat0;
    formatArray0[2] = (Format) extendedMessageFormat0;
    formatArray0[3] = (Format) extendedMessageFormat0;
    formatArray0[4] = (Format) extendedMessageFormat0;
    // Undeclared exception!
    try {
        extendedMessageFormat0.setFormatsByArgumentIndex(formatArray0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.text.ExtendedMessageFormat"", e);
    }
}","/**
 * {@inheritDoc}
 * @throws UnsupportedOperationException
 */"
"public final void applyPattern(String pattern) {
    if (registry == null) {
        super.applyPattern(pattern);
        toPattern = super.toPattern();
        return;
    }
    ArrayList foundFormats = new ArrayList();
    ArrayList foundDescriptions = new ArrayList();
    StringBuffer stripCustom = new StringBuffer(pattern.length());
    ParsePosition pos = new ParsePosition(0);
    char[] c = pattern.toCharArray();
    int fmtCount = 0;
    while (pos.getIndex() < pattern.length()) {
        switch(c[pos.getIndex()]) {
            case QUOTE:
                appendQuotedString(pattern, pos, stripCustom, true);
                break;
            case START_FE:
                fmtCount++;
                seekNonWs(pattern, pos);
                int start = pos.getIndex();
                int index = readArgumentIndex(pattern, next(pos));
                stripCustom.append(START_FE).append(index);
                seekNonWs(pattern, pos);
                Format format = null;
                String formatDescription = null;
                if (c[pos.getIndex()] == START_FMT) {
                    formatDescription = parseFormatDescription(pattern, next(pos));
                    format = getFormat(formatDescription);
                    if (format == null) {
                        stripCustom.append(START_FMT).append(formatDescription);
                    }
                }
                foundFormats.add(format);
                foundDescriptions.add(format == null ? null : formatDescription);
                Validate.isTrue(foundFormats.size() == fmtCount);
                Validate.isTrue(foundDescriptions.size() == fmtCount);
                if (c[pos.getIndex()] != END_FE) {
                    throw new IllegalArgumentException(""Unreadable format element at position "" + start);
                }
            // fall through
            default:
                stripCustom.append(c[pos.getIndex()]);
                next(pos);
        }
    }
    super.applyPattern(stripCustom.toString());
    toPattern = insertFormats(super.toPattern(), foundDescriptions);
    if (containsElements(foundFormats)) {
        Format[] origFormats = getFormats();
        // only loop over what we know we have, as MessageFormat on Java 1.3
        // seems to provide an extra format element:
        int i = 0;
        for (Iterator it = foundFormats.iterator(); it.hasNext(); i++) {
            Format f = (Format) it.next();
            if (f != null) {
                origFormats[i] = f;
            }
        }
        super.setFormats(origFormats);
    }
}","public void test1717() throws Throwable {
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(""pA"");
    extendedMessageFormat0.applyPattern(""pA"");
    extendedMessageFormat0.applyPattern(""pA"");
}","/**
 * Apply the specified pattern.
 *
 * @param pattern String
 */"
"public ExtendedMessageFormat(String pattern, Locale locale, Map registry) {
    super(DUMMY_PATTERN);
    setLocale(locale);
    this.registry = registry;
    applyPattern(pattern);
}","public void test1818() throws Throwable {
    Locale locale0 = Locale.ENGLISH;
    HashMap<ChoiceFormat, NumberFormat> hashMap0 = new HashMap<ChoiceFormat, NumberFormat>();
    hashMap0.clear();
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(""'\"""", locale0, hashMap0);
}","/**
 * Create a new ExtendedMessageFormat.
 *
 * @param pattern String
 * @param locale Locale
 * @param registry Registry of format factories:  Map<String, FormatFactory>
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"public ExtendedMessageFormat(String pattern, Locale locale, Map registry) {
    super(DUMMY_PATTERN);
    setLocale(locale);
    this.registry = registry;
    applyPattern(pattern);
}","public void test1919() throws Throwable {
    Locale locale0 = Locale.KOREA;
    HashMap<MockDateFormat, Integer> hashMap0 = new HashMap<MockDateFormat, Integer>();
    ExtendedMessageFormat extendedMessageFormat0 = null;
    try {
        extendedMessageFormat0 = new ExtendedMessageFormat((String) null, locale0, hashMap0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.text.ExtendedMessageFormat"", e);
    }
}","/**
 * Create a new ExtendedMessageFormat.
 *
 * @param pattern String
 * @param locale Locale
 * @param registry Registry of format factories:  Map<String, FormatFactory>
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"public ExtendedMessageFormat(String pattern, Map registry) {
    this(pattern, Locale.getDefault(), registry);
}","public void test2121() throws Throwable {
    String string0 = ""''"";
    HashMap<Integer, MessageFormat> hashMap0 = new HashMap<Integer, MessageFormat>();
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(""''"", hashMap0);
}","/**
 * Create a new ExtendedMessageFormat for the default locale.
 *
 * @param pattern String
 * @param registry Registry of format factories:  Map<String, FormatFactory>
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"public void setFormatByArgumentIndex(int argumentIndex, Format newFormat) {
    throw new UnsupportedOperationException();
}","public void test2222() throws Throwable {
    Locale locale0 = Locale.CHINA;
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat("""", locale0);
    MessageFormat messageFormat0 = new MessageFormat("""", locale0);
    // Undeclared exception!
    try {
        extendedMessageFormat0.setFormatByArgumentIndex((-1), messageFormat0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.text.ExtendedMessageFormat"", e);
    }
}","/**
 * {@inheritDoc}
 * @throws UnsupportedOperationException
 */"
"public ExtendedMessageFormat(String pattern) {
    this(pattern, Locale.getDefault());
}","public void test2323() throws Throwable {
    ExtendedMessageFormat extendedMessageFormat0 = null;
    try {
        extendedMessageFormat0 = new ExtendedMessageFormat(""IA6{k"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unmatched braces in the pattern.
        //
        verifyException(""java.text.MessageFormat"", e);
    }
}","/**
 * Create a new ExtendedMessageFormat for the default locale.
 *
 * @param pattern String
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"public ExtendedMessageFormat(String pattern, Locale locale, Map registry) {
    super(DUMMY_PATTERN);
    setLocale(locale);
    this.registry = registry;
    applyPattern(pattern);
}","public void test2424() throws Throwable {
    String string0 = ""{t!"";
    Locale locale0 = Locale.TAIWAN;
    HashMap<NumberFormat, ChoiceFormat> hashMap0 = new HashMap<NumberFormat, ChoiceFormat>();
    ExtendedMessageFormat extendedMessageFormat0 = null;
    try {
        extendedMessageFormat0 = new ExtendedMessageFormat(""{t!"", locale0, hashMap0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format argument index at position 1: t
        //
        verifyException(""org.apache.commons.lang.text.ExtendedMessageFormat"", e);
    }
}","/**
 * Create a new ExtendedMessageFormat.
 *
 * @param pattern String
 * @param locale Locale
 * @param registry Registry of format factories:  Map<String, FormatFactory>
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"public void setFormatByArgumentIndex(int argumentIndex, Format newFormat) {
    throw new UnsupportedOperationException();
}","public void test2525() throws Throwable {
    Locale locale0 = new Locale(""org.apache.commons.lang.text.StrMatcher$CharSetMatcher"", ""org.apache.commons.lang.text.StrMatcher$CharSetMatcher"");
    HashMap<NumberFormat, String> hashMap0 = new HashMap<NumberFormat, String>();
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(""JS@oDv3U,B "", locale0, hashMap0);
    extendedMessageFormat0.parse(""JS@oDv3U,B "");
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    Set<String> set0 = locale0.getUnicodeLocaleKeys();
    Locale.filterTags((List<Locale.LanguageRange>) linkedList0, (Collection<String>) set0);
    DateFormat dateFormat0 = MockDateFormat.getDateInstance();
    // Undeclared exception!
    try {
        extendedMessageFormat0.setFormatByArgumentIndex(0, dateFormat0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.text.ExtendedMessageFormat"", e);
    }
}","/**
 * {@inheritDoc}
 * @throws UnsupportedOperationException
 */"
"public ExtendedMessageFormat(String pattern, Locale locale) {
    this(pattern, locale, null);
}","public void test2626() throws Throwable {
    String string0 = null;
    Locale locale0 = Locale.JAPAN;
    ExtendedMessageFormat extendedMessageFormat0 = null;
    try {
        extendedMessageFormat0 = new ExtendedMessageFormat((String) null, locale0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Create a new ExtendedMessageFormat.
 *
 * @param pattern String
 * @param locale Locale
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"public final void applyPattern(String pattern) {
    if (registry == null) {
        super.applyPattern(pattern);
        toPattern = super.toPattern();
        return;
    }
    ArrayList foundFormats = new ArrayList();
    ArrayList foundDescriptions = new ArrayList();
    StringBuffer stripCustom = new StringBuffer(pattern.length());
    ParsePosition pos = new ParsePosition(0);
    char[] c = pattern.toCharArray();
    int fmtCount = 0;
    while (pos.getIndex() < pattern.length()) {
        switch(c[pos.getIndex()]) {
            case QUOTE:
                appendQuotedString(pattern, pos, stripCustom, true);
                break;
            case START_FE:
                fmtCount++;
                seekNonWs(pattern, pos);
                int start = pos.getIndex();
                int index = readArgumentIndex(pattern, next(pos));
                stripCustom.append(START_FE).append(index);
                seekNonWs(pattern, pos);
                Format format = null;
                String formatDescription = null;
                if (c[pos.getIndex()] == START_FMT) {
                    formatDescription = parseFormatDescription(pattern, next(pos));
                    format = getFormat(formatDescription);
                    if (format == null) {
                        stripCustom.append(START_FMT).append(formatDescription);
                    }
                }
                foundFormats.add(format);
                foundDescriptions.add(format == null ? null : formatDescription);
                Validate.isTrue(foundFormats.size() == fmtCount);
                Validate.isTrue(foundDescriptions.size() == fmtCount);
                if (c[pos.getIndex()] != END_FE) {
                    throw new IllegalArgumentException(""Unreadable format element at position "" + start);
                }
            // fall through
            default:
                stripCustom.append(c[pos.getIndex()]);
                next(pos);
        }
    }
    super.applyPattern(stripCustom.toString());
    toPattern = insertFormats(super.toPattern(), foundDescriptions);
    if (containsElements(foundFormats)) {
        Format[] origFormats = getFormats();
        // only loop over what we know we have, as MessageFormat on Java 1.3
        // seems to provide an extra format element:
        int i = 0;
        for (Iterator it = foundFormats.iterator(); it.hasNext(); i++) {
            Format f = (Format) it.next();
            if (f != null) {
                origFormats[i] = f;
            }
        }
        super.setFormats(origFormats);
    }
}","public void test2727() throws Throwable {
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(""-P)u4%'Z\"":d*gb.0KJ"");
    extendedMessageFormat0.toPattern();
    // Undeclared exception!
    try {
        extendedMessageFormat0.applyPattern((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Apply the specified pattern.
 *
 * @param pattern String
 */"
"public ExtendedMessageFormat(String pattern, Locale locale) {
    this(pattern, locale, null);
}","public void test2828() throws Throwable {
    Locale locale0 = Locale.CANADA_FRENCH;
    ExtendedMessageFormat extendedMessageFormat0 = null;
    try {
        extendedMessageFormat0 = new ExtendedMessageFormat(""X{f``0u+\nSkS5"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unmatched braces in the pattern.
        //
        verifyException(""java.text.MessageFormat"", e);
    }
}","/**
 * Create a new ExtendedMessageFormat.
 *
 * @param pattern String
 * @param locale Locale
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"public ExtendedMessageFormat(String pattern, Map registry) {
    this(pattern, Locale.getDefault(), registry);
}","public void test2929() throws Throwable {
    HashMap<DecimalFormat, Integer> hashMap0 = new HashMap<DecimalFormat, Integer>();
    DecimalFormat decimalFormat0 = new DecimalFormat();
    int int0 = 2031;
    Integer integer0 = new Integer(2031);
    hashMap0.put(decimalFormat0, integer0);
    DecimalFormat decimalFormat1 = new DecimalFormat();
    BiFunction<Object, Integer, Integer> biFunction0 = (BiFunction<Object, Integer, Integer>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
    doReturn((Object) null).when(biFunction0).apply(any(), anyInt());
    hashMap0.computeIfPresent(decimalFormat1, biFunction0);
    ExtendedMessageFormat extendedMessageFormat0 = null;
    try {
        extendedMessageFormat0 = new ExtendedMessageFormat(""RRc{3^0ZZ"", hashMap0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format argument index at position 4: 3^
        //
        verifyException(""org.apache.commons.lang.text.ExtendedMessageFormat"", e);
    }
}","/**
 * Create a new ExtendedMessageFormat for the default locale.
 *
 * @param pattern String
 * @param registry Registry of format factories:  Map<String, FormatFactory>
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"public final void applyPattern(String pattern) {
    if (registry == null) {
        super.applyPattern(pattern);
        toPattern = super.toPattern();
        return;
    }
    ArrayList foundFormats = new ArrayList();
    ArrayList foundDescriptions = new ArrayList();
    StringBuffer stripCustom = new StringBuffer(pattern.length());
    ParsePosition pos = new ParsePosition(0);
    char[] c = pattern.toCharArray();
    int fmtCount = 0;
    while (pos.getIndex() < pattern.length()) {
        switch(c[pos.getIndex()]) {
            case QUOTE:
                appendQuotedString(pattern, pos, stripCustom, true);
                break;
            case START_FE:
                fmtCount++;
                seekNonWs(pattern, pos);
                int start = pos.getIndex();
                int index = readArgumentIndex(pattern, next(pos));
                stripCustom.append(START_FE).append(index);
                seekNonWs(pattern, pos);
                Format format = null;
                String formatDescription = null;
                if (c[pos.getIndex()] == START_FMT) {
                    formatDescription = parseFormatDescription(pattern, next(pos));
                    format = getFormat(formatDescription);
                    if (format == null) {
                        stripCustom.append(START_FMT).append(formatDescription);
                    }
                }
                foundFormats.add(format);
                foundDescriptions.add(format == null ? null : formatDescription);
                Validate.isTrue(foundFormats.size() == fmtCount);
                Validate.isTrue(foundDescriptions.size() == fmtCount);
                if (c[pos.getIndex()] != END_FE) {
                    throw new IllegalArgumentException(""Unreadable format element at position "" + start);
                }
            // fall through
            default:
                stripCustom.append(c[pos.getIndex()]);
                next(pos);
        }
    }
    super.applyPattern(stripCustom.toString());
    toPattern = insertFormats(super.toPattern(), foundDescriptions);
    if (containsElements(foundFormats)) {
        Format[] origFormats = getFormats();
        // only loop over what we know we have, as MessageFormat on Java 1.3
        // seems to provide an extra format element:
        int i = 0;
        for (Iterator it = foundFormats.iterator(); it.hasNext(); i++) {
            Format f = (Format) it.next();
            if (f != null) {
                origFormats[i] = f;
            }
        }
        super.setFormats(origFormats);
    }
}","public void test3030() throws Throwable {
    HashMap<String, MockDateFormat> hashMap0 = new HashMap<String, MockDateFormat>();
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(""DssVG34\""5~cIH#JECW"", hashMap0);
    int int0 = 1923;
    ParsePosition parsePosition0 = new ParsePosition(1923);
    parsePosition0.setIndex(734);
    extendedMessageFormat0.parseObject("" \t\n\r\f"", parsePosition0);
    // Undeclared exception!
    extendedMessageFormat0.applyPattern(""jHB0's~[?iM[2%y"");
}","/**
 * Apply the specified pattern.
 *
 * @param pattern String
 */"
"public final void applyPattern(String pattern) {
    if (registry == null) {
        super.applyPattern(pattern);
        toPattern = super.toPattern();
        return;
    }
    ArrayList foundFormats = new ArrayList();
    ArrayList foundDescriptions = new ArrayList();
    StringBuffer stripCustom = new StringBuffer(pattern.length());
    ParsePosition pos = new ParsePosition(0);
    char[] c = pattern.toCharArray();
    int fmtCount = 0;
    while (pos.getIndex() < pattern.length()) {
        switch(c[pos.getIndex()]) {
            case QUOTE:
                appendQuotedString(pattern, pos, stripCustom, true);
                break;
            case START_FE:
                fmtCount++;
                seekNonWs(pattern, pos);
                int start = pos.getIndex();
                int index = readArgumentIndex(pattern, next(pos));
                stripCustom.append(START_FE).append(index);
                seekNonWs(pattern, pos);
                Format format = null;
                String formatDescription = null;
                if (c[pos.getIndex()] == START_FMT) {
                    formatDescription = parseFormatDescription(pattern, next(pos));
                    format = getFormat(formatDescription);
                    if (format == null) {
                        stripCustom.append(START_FMT).append(formatDescription);
                    }
                }
                foundFormats.add(format);
                foundDescriptions.add(format == null ? null : formatDescription);
                Validate.isTrue(foundFormats.size() == fmtCount);
                Validate.isTrue(foundDescriptions.size() == fmtCount);
                if (c[pos.getIndex()] != END_FE) {
                    throw new IllegalArgumentException(""Unreadable format element at position "" + start);
                }
            // fall through
            default:
                stripCustom.append(c[pos.getIndex()]);
                next(pos);
        }
    }
    super.applyPattern(stripCustom.toString());
    toPattern = insertFormats(super.toPattern(), foundDescriptions);
    if (containsElements(foundFormats)) {
        Format[] origFormats = getFormats();
        // only loop over what we know we have, as MessageFormat on Java 1.3
        // seems to provide an extra format element:
        int i = 0;
        for (Iterator it = foundFormats.iterator(); it.hasNext(); i++) {
            Format f = (Format) it.next();
            if (f != null) {
                origFormats[i] = f;
            }
        }
        super.setFormats(origFormats);
    }
}","public void test3131() throws Throwable {
    HashMap<Integer, String> hashMap0 = new HashMap<Integer, String>();
    hashMap0.put((Integer) null, """");
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat("""");
    // Undeclared exception!
    try {
        extendedMessageFormat0.applyPattern(""--;{,i"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unmatched braces in the pattern.
        //
        verifyException(""java.text.MessageFormat"", e);
    }
}","/**
 * Apply the specified pattern.
 *
 * @param pattern String
 */"
"public ExtendedMessageFormat(String pattern, Locale locale, Map registry) {
    super(DUMMY_PATTERN);
    setLocale(locale);
    this.registry = registry;
    applyPattern(pattern);
}","public void test3232() throws Throwable {
    String string0 = ""{!"";
    Locale locale0 = Locale.TAIWAN;
    HashMap<NumberFormat, ChoiceFormat> hashMap0 = new HashMap<NumberFormat, ChoiceFormat>();
    ExtendedMessageFormat extendedMessageFormat0 = null;
    try {
        extendedMessageFormat0 = new ExtendedMessageFormat(""{!"", locale0, hashMap0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format argument index at position 1: !
        //
        verifyException(""org.apache.commons.lang.text.ExtendedMessageFormat"", e);
    }
}","/**
 * Create a new ExtendedMessageFormat.
 *
 * @param pattern String
 * @param locale Locale
 * @param registry Registry of format factories:  Map<String, FormatFactory>
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
