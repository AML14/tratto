focal_method,test_prefix,docstring
"public static char[] remove(char[] array, int index) {
    return (char[]) remove((Object) array, index);
}","public void test0000() throws Throwable {
    char[] charArray0 = new char[2];
    // Undeclared exception!
    try {
        ArrayUtils.remove(charArray0, 2);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // Index: 2, Length: 2
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}","/**
 * <p>Removes the element at the specified position from the specified array.
 * All subsequent elements are shifted to the left (substracts one from
 * their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException
 * will be thrown, because in that case no valid index can be specified.</p>
 *
 * <pre>
 * ArrayUtils.remove(['a'], 0)           = []
 * ArrayUtils.remove(['a', 'b'], 0)      = ['b']
 * ArrayUtils.remove(['a', 'b'], 1)      = ['a']
 * ArrayUtils.remove(['a', 'b', 'c'], 1) = ['a', 'c']
 * </pre>
 *
 * @param array  the array to remove the element from, may not be <code>null</code>
 * @param index  the position of the element to be removed
 * @return A new array containing the existing elements except the element
 *         at the specified position.
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index >= array.length), or if the array is <code>null</code>.
 * @since 2.1
 */"
"public static char[] add(char[] array, int index, char element) {
    return (char[]) add(array, index, Character.valueOf(element), Character.TYPE);
}","public void test0011() throws Throwable {
    // Undeclared exception!
    try {
        ArrayUtils.add((char[]) null, (-783), '&');
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // Index: -783, Length: 0
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}","/**
 * <p>Inserts the specified element at the specified position in the array.
 * Shifts the element currently at that position (if any) and any subsequent
 * elements to the right (adds one to their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array plus the given element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element.</p>
 *
 * <pre>
 * ArrayUtils.add(null, 0, 'a')            = ['a']
 * ArrayUtils.add(['a'], 0, 'b')           = ['b', 'a']
 * ArrayUtils.add(['a', 'b'], 0, 'c')      = ['c', 'a', 'b']
 * ArrayUtils.add(['a', 'b'], 1, 'k')      = ['a', 'k', 'b']
 * ArrayUtils.add(['a', 'b', 'c'], 1, 't') = ['a', 't', 'b', 'c']
 * </pre>
 *
 * @param array  the array to add the element to, may be <code>null</code>
 * @param index  the position of the new object
 * @param element  the object to add
 * @return A new array containing the existing elements and the new element
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index > array.length).
 */"
"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test0022() throws Throwable {
    float[] floatArray0 = new float[9];
    int int0 = ArrayUtils.lastIndexOf(floatArray0, 0.0F, 0);
    assertEquals(0, int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test0033() throws Throwable {
    float[] floatArray0 = new float[7];
    int int0 = ArrayUtils.indexOf(floatArray0, 0.0F, 735);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test0044() throws Throwable {
    double[] doubleArray0 = new double[5];
    int int0 = ArrayUtils.lastIndexOf(doubleArray0, 94.0, 5, 551.91);
    assertEquals(4, int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.
 * This method will return the index of the last value which falls between the region
 * defined by valueToFind - tolerance and valueToFind + tolerance.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @param tolerance  search for value within plus/minus this amount
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(double[] array, double valueToFind) {
    return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
}","public void test0055() throws Throwable {
    double[] doubleArray0 = new double[8];
    doubleArray0[2] = (double) (-3328);
    int int0 = ArrayUtils.lastIndexOf(doubleArray0, (-1.0));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value within the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to travers backwords looking for the object, may be <code>null</code>
 * @param valueToFind  the object to find
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i < array.length; i++) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test0066() throws Throwable {
    double[] doubleArray0 = new double[1];
    int int0 = ArrayUtils.indexOf(doubleArray0, 1516.4349, 459, 1516.4349);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.
 * This method will return the index of the first value which falls between the region
 * defined by valueToFind - tolerance and valueToFind + tolerance.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @param tolerance tolerance of the search
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(char[] array, char valueToFind) {
    return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
}","public void test0077() throws Throwable {
    char[] charArray0 = new char[5];
    charArray0[4] = '\\';
    int int0 = ArrayUtils.lastIndexOf(charArray0, 'B');
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value within the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to travers backwords looking for the object, may be <code>null</code>
 * @param valueToFind  the object to find
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 * @since 2.1
 */"
"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test0088() throws Throwable {
    char[] charArray0 = new char[0];
    int int0 = ArrayUtils.lastIndexOf(charArray0, 'c', 0);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 * @since 2.1
 */"
"public static char[] removeElement(char[] array, char element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test0099() throws Throwable {
    char[] charArray0 = new char[6];
    charArray0[0] = 's';
    char[] charArray1 = ArrayUtils.removeElement(charArray0, 'a');
    assertEquals(6, charArray1.length);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, 'a')            = null
 * ArrayUtils.removeElement([], 'a')              = []
 * ArrayUtils.removeElement(['a'], 'b')           = ['a']
 * ArrayUtils.removeElement(['a', 'b'], 'a')      = ['b']
 * ArrayUtils.removeElement(['a', 'b', 'a'], 'a') = ['b', 'a']
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test01010() throws Throwable {
    short[] shortArray0 = new short[7];
    int int0 = ArrayUtils.lastIndexOf(shortArray0, (short) 939, 7);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test01111() throws Throwable {
    int[] intArray0 = new int[8];
    intArray0[0] = (-806);
    int int0 = ArrayUtils.lastIndexOf(intArray0, (-562), 11);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(long[] array, long valueToFind) {
    return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
}","public void test01212() throws Throwable {
    long[] longArray0 = new long[6];
    int int0 = ArrayUtils.lastIndexOf(longArray0, 1849L);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value within the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to travers backwords looking for the object, may be <code>null</code>
 * @param valueToFind  the object to find
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else if (array.getClass().getComponentType().isInstance(objectToFind)) {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}","public void test01313() throws Throwable {
    Object[] objectArray0 = new Object[5];
    Object object0 = new Object();
    objectArray0[2] = object0;
    objectArray0[1] = objectArray0[2];
    int int0 = ArrayUtils.lastIndexOf(objectArray0, objectArray0[0], 2);
    assertEquals(0, int0);
}","/**
 * <p>Finds the last index of the given object in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than
 * the array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param objectToFind  the object to find, may be <code>null</code>
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the object within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else if (array.getClass().getComponentType().isInstance(objectToFind)) {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}","public void test01414() throws Throwable {
    Object[] objectArray0 = new Object[5];
    Object object0 = new Object();
    int int0 = ArrayUtils.lastIndexOf(objectArray0, object0, 0);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given object in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than
 * the array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param objectToFind  the object to find, may be <code>null</code>
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the object within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static void reverse(float[] array) {
    if (array == null) {
        return;
    }
    int i = 0;
    int j = array.length - 1;
    float tmp;
    while (j > i) {
        tmp = array[j];
        array[j] = array[i];
        array[i] = tmp;
        j--;
        i++;
    }
}","public void test01515() throws Throwable {
    float[] floatArray0 = new float[0];
    ArrayUtils.reverse(floatArray0);
    assertEquals(0, floatArray0.length);
}","/**
 * <p>Reverses the order of the given array.</p>
 *
 * <p>This method does nothing for a <code>null</code> input array.</p>
 *
 * @param array  the array to reverse, may be <code>null</code>
 */"
"public static void reverse(double[] array) {
    if (array == null) {
        return;
    }
    int i = 0;
    int j = array.length - 1;
    double tmp;
    while (j > i) {
        tmp = array[j];
        array[j] = array[i];
        array[i] = tmp;
        j--;
        i++;
    }
}","public void test01616() throws Throwable {
    ArrayUtils arrayUtils0 = new ArrayUtils();
    ArrayUtils.reverse(arrayUtils0.EMPTY_DOUBLE_ARRAY);
    assertEquals((-1), ArrayUtils.INDEX_NOT_FOUND);
}","/**
 * <p>Reverses the order of the given array.</p>
 *
 * <p>This method does nothing for a <code>null</code> input array.</p>
 *
 * @param array  the array to reverse, may be <code>null</code>
 */"
"public static void reverse(char[] array) {
    if (array == null) {
        return;
    }
    int i = 0;
    int j = array.length - 1;
    char tmp;
    while (j > i) {
        tmp = array[j];
        array[j] = array[i];
        array[i] = tmp;
        j--;
        i++;
    }
}","public void test01717() throws Throwable {
    char[] charArray0 = new char[0];
    ArrayUtils.reverse(charArray0);
    assertEquals(0, charArray0.length);
}","/**
 * <p>Reverses the order of the given array.</p>
 *
 * <p>This method does nothing for a <code>null</code> input array.</p>
 *
 * @param array  the array to reverse, may be <code>null</code>
 */"
"public static void reverse(short[] array) {
    if (array == null) {
        return;
    }
    int i = 0;
    int j = array.length - 1;
    short tmp;
    while (j > i) {
        tmp = array[j];
        array[j] = array[i];
        array[i] = tmp;
        j--;
        i++;
    }
}","public void test01818() throws Throwable {
    short[] shortArray0 = new short[3];
    ArrayUtils.reverse(shortArray0);
    assertArrayEquals(new short[] { (short) 0, (short) 0, (short) 0 }, shortArray0);
}","/**
 * <p>Reverses the order of the given array.</p>
 *
 * <p>This method does nothing for a <code>null</code> input array.</p>
 *
 * @param array  the array to reverse, may be <code>null</code>
 */"
"public static void reverse(int[] array) {
    if (array == null) {
        return;
    }
    int i = 0;
    int j = array.length - 1;
    int tmp;
    while (j > i) {
        tmp = array[j];
        array[j] = array[i];
        array[i] = tmp;
        j--;
        i++;
    }
}","public void test01919() throws Throwable {
    int[] intArray0 = new int[3];
    ArrayUtils.reverse(intArray0);
    assertArrayEquals(new int[] { 0, 0, 0 }, intArray0);
}","/**
 * <p>Reverses the order of the given array.</p>
 *
 * <p>This method does nothing for a <code>null</code> input array.</p>
 *
 * @param array  the array to reverse, may be <code>null</code>
 */"
"public static void reverse(long[] array) {
    if (array == null) {
        return;
    }
    int i = 0;
    int j = array.length - 1;
    long tmp;
    while (j > i) {
        tmp = array[j];
        array[j] = array[i];
        array[i] = tmp;
        j--;
        i++;
    }
}","public void test02020() throws Throwable {
    long[] longArray0 = new long[1];
    ArrayUtils.reverse(longArray0);
    assertArrayEquals(new long[] { 0L }, longArray0);
}","/**
 * <p>Reverses the order of the given array.</p>
 *
 * <p>This method does nothing for a <code>null</code> input array.</p>
 *
 * @param array  the array to reverse, may be <code>null</code>
 */"
"// Reverse
//-----------------------------------------------------------------------
/**
 * <p>Reverses the order of the given array.</p>
 *
 * <p>There is no special handling for multi-dimensional arrays.</p>
 *
 * <p>This method does nothing for a <code>null</code> input array.</p>
 *
 * @param array  the array to reverse, may be <code>null</code>
 */
public static void reverse(Object[] array) {
    if (array == null) {
        return;
    }
    int i = 0;
    int j = array.length - 1;
    Object tmp;
    while (j > i) {
        tmp = array[j];
        array[j] = array[i];
        array[i] = tmp;
        j--;
        i++;
    }
}","public void test02121() throws Throwable {
    Integer[] integerArray0 = new Integer[9];
    ArrayUtils.reverse((Object[]) integerArray0);
    assertEquals(9, integerArray0.length);
}",""
"public static boolean isSameLength(double[] array1, double[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test02222() throws Throwable {
    double[] doubleArray0 = new double[1];
    double[] doubleArray1 = new double[6];
    boolean boolean0 = ArrayUtils.isSameLength(doubleArray0, doubleArray1);
    assertFalse(boolean0);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static boolean isSameLength(byte[] array1, byte[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test02323() throws Throwable {
    ArrayUtils arrayUtils0 = new ArrayUtils();
    byte[] byteArray0 = new byte[3];
    boolean boolean0 = ArrayUtils.isSameLength(arrayUtils0.EMPTY_BYTE_ARRAY, byteArray0);
    assertFalse(boolean0);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static boolean isSameLength(int[] array1, int[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test02424() throws Throwable {
    int[] intArray0 = new int[5];
    int[] intArray1 = new int[0];
    boolean boolean0 = ArrayUtils.isSameLength(intArray0, intArray1);
    assertFalse(boolean0);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static boolean isSameLength(long[] array1, long[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test02525() throws Throwable {
    long[] longArray0 = new long[8];
    long[] longArray1 = new long[0];
    boolean boolean0 = ArrayUtils.isSameLength(longArray0, longArray1);
    assertFalse(boolean0);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }
    boolean[] subarray = new boolean[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test02626() throws Throwable {
    boolean[] booleanArray0 = new boolean[7];
    boolean[] booleanArray1 = ArrayUtils.subarray(booleanArray0, (-6108), 0);
    assertEquals(0, booleanArray1.length);
}","/**
 * <p>Produces a new <code>boolean</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }
    boolean[] subarray = new boolean[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test02727() throws Throwable {
    boolean[] booleanArray0 = new boolean[8];
    boolean[] booleanArray1 = ArrayUtils.subarray(booleanArray0, 0, 48);
    assertNotSame(booleanArray1, booleanArray0);
}","/**
 * <p>Produces a new <code>boolean</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_FLOAT_ARRAY;
    }
    float[] subarray = new float[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test02829() throws Throwable {
    float[] floatArray0 = new float[0];
    float[] floatArray1 = ArrayUtils.subarray(floatArray0, 1, 0);
    assertNotSame(floatArray0, floatArray1);
}","/**
 * <p>Produces a new <code>float</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_FLOAT_ARRAY;
    }
    float[] subarray = new float[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test02930() throws Throwable {
    float[] floatArray0 = new float[3];
    float[] floatArray1 = ArrayUtils.subarray(floatArray0, (int) (short) 0, 57);
    assertNotSame(floatArray1, floatArray0);
}","/**
 * <p>Produces a new <code>float</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_DOUBLE_ARRAY;
    }
    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test03032() throws Throwable {
    double[] doubleArray0 = new double[9];
    double[] doubleArray1 = ArrayUtils.subarray(doubleArray0, 1, 1);
    assertEquals(0, doubleArray1.length);
}","/**
 * <p>Produces a new <code>double</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_CHAR_ARRAY;
    }
    char[] subarray = new char[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test03133() throws Throwable {
    char[] charArray0 = new char[3];
    char[] charArray1 = ArrayUtils.subarray(charArray0, 2, 2);
    assertEquals(0, charArray1.length);
}","/**
 * <p>Produces a new <code>char</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_SHORT_ARRAY;
    }
    short[] subarray = new short[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test03335() throws Throwable {
    short[] shortArray0 = new short[5];
    short[] shortArray1 = ArrayUtils.subarray(shortArray0, (int) (short) 0, (int) (short) 64);
    assertNotSame(shortArray1, shortArray0);
}","/**
 * <p>Produces a new <code>short</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_INT_ARRAY;
    }
    int[] subarray = new int[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test03437() throws Throwable {
    int[] intArray0 = new int[0];
    int[] intArray1 = ArrayUtils.subarray(intArray0, 0, 0);
    assertArrayEquals(new int[] {}, intArray1);
}","/**
 * <p>Produces a new <code>int</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_LONG_ARRAY;
    }
    long[] subarray = new long[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test03538() throws Throwable {
    long[] longArray0 = new long[9];
    long[] longArray1 = ArrayUtils.subarray(longArray0, 5, 5);
    assertNotNull(longArray1);
}","/**
 * <p>Produces a new <code>long</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"// Subarrays
//-----------------------------------------------------------------------
/**
 * <p>Produces a new array containing the elements between
 * the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * <p>The component type of the subarray is always the same as
 * that of the input array. Thus, if the input is an array of type
 * <code>Date</code>, the following usage is envisaged:</p>
 *
 * <pre>
 * Date[] someDates = (Date[])ArrayUtils.subarray(allDates, 2, 5);
 * </pre>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */
public static <T> T[] subarray(T[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    Class<?> type = array.getClass().getComponentType();
    if (newSize <= 0) {
        // OK, because array is of type T
        @SuppressWarnings(""unchecked"")
        final T[] emptyArray = (T[]) Array.newInstance(type, 0);
        return emptyArray;
    }
    // OK, because array is of type T
    @SuppressWarnings(""unchecked"")
    T[] subarray = (T[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test03640() throws Throwable {
    String[] stringArray0 = new String[0];
    String[] stringArray1 = ArrayUtils.subarray(stringArray0, 106, 3);
    assertNotSame(stringArray1, stringArray0);
}",""
"// Generic array
//-----------------------------------------------------------------------
/**
 * Create a type-safe generic array.
 *
 * <p>Arrays are covariant i.e. they cannot be created from a generic type:</p>
 *
 * <pre>
 *    public static &lt;T&gt; T[] createAnArray(int size)
 *    {
 *        return T[size]; // compiler error here
 *    }
 *    public static &lt;T&gt; T[] createAnArray(int size)
 *    {
 *        return (T[])Object[size]; // ClassCastException at runtime
 *    }
 * </pre>
 *
 * <p>Therefore new arrays of generic types can be created with this method, e.g. an arrays
 * of Strings:</p>
 *
 * <pre>
 *    String[] array = ArrayUtils.toArray(""1"", ""2"");
 *    String[] emptyArray = ArrayUtils.&lt;String&gt;toArray();
 * </pre>
 *
 * The method is typically used in scenarios, where the caller itself uses generic types
 * that have to be combined into an array.
 *
 * Note, this method makes only sense to provide arguments of the same type so that the
 * compiler can deduce the type of the array itself. While it is possible to select the
 * type explicitly like in <code>Number[] array = ArrayUtils.<Number>toArray(new
 * Integer(42), new Double(Math.PI))</code>, there is no real advantage to <code>new
 * Number[] {new Integer(42), new Double(Math.PI)}</code> anymore.
 *
 * @param  <T>   the array's element type
 * @param  items the items of the array
 * @return the array
 * @since  3.0
 */
public static <T> T[] toArray(final T... items) {
    return items;
}","public void test03743() throws Throwable {
    String[] stringArray0 = ArrayUtils.toArray((String[]) null);
    assertNull(stringArray0);
}",""
"// Generic array
//-----------------------------------------------------------------------
/**
 * Create a type-safe generic array.
 *
 * <p>Arrays are covariant i.e. they cannot be created from a generic type:</p>
 *
 * <pre>
 *    public static &lt;T&gt; T[] createAnArray(int size)
 *    {
 *        return T[size]; // compiler error here
 *    }
 *    public static &lt;T&gt; T[] createAnArray(int size)
 *    {
 *        return (T[])Object[size]; // ClassCastException at runtime
 *    }
 * </pre>
 *
 * <p>Therefore new arrays of generic types can be created with this method, e.g. an arrays
 * of Strings:</p>
 *
 * <pre>
 *    String[] array = ArrayUtils.toArray(""1"", ""2"");
 *    String[] emptyArray = ArrayUtils.&lt;String&gt;toArray();
 * </pre>
 *
 * The method is typically used in scenarios, where the caller itself uses generic types
 * that have to be combined into an array.
 *
 * Note, this method makes only sense to provide arguments of the same type so that the
 * compiler can deduce the type of the array itself. While it is possible to select the
 * type explicitly like in <code>Number[] array = ArrayUtils.<Number>toArray(new
 * Integer(42), new Double(Math.PI))</code>, there is no real advantage to <code>new
 * Number[] {new Integer(42), new Double(Math.PI)}</code> anymore.
 *
 * @param  <T>   the array's element type
 * @param  items the items of the array
 * @return the array
 * @since  3.0
 */
public static <T> T[] toArray(final T... items) {
    return items;
}","public void test03844() throws Throwable {
    Integer[] integerArray0 = new Integer[3];
    Integer[] integerArray1 = ArrayUtils.toArray(integerArray0);
    assertSame(integerArray0, integerArray1);
}",""
"public static short[] removeElement(short[] array, short element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test03945() throws Throwable {
    short[] shortArray0 = new short[1];
    shortArray0[0] = (short) (-1116);
    short[] shortArray1 = ArrayUtils.removeElement(shortArray0, (short) (-1116));
    assertEquals(0, shortArray1.length);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, 1)      = null
 * ArrayUtils.removeElement([], 1)        = []
 * ArrayUtils.removeElement([1], 2)       = [1]
 * ArrayUtils.removeElement([1, 3], 1)    = [3]
 * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"public static <T> T[] removeElement(T[] array, Object element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test04046() throws Throwable {
    ArrayUtils arrayUtils0 = new ArrayUtils();
    Object[] objectArray0 = ArrayUtils.removeElement((Object[]) arrayUtils0.EMPTY_BYTE_OBJECT_ARRAY, (Object) arrayUtils0.INDEX_NOT_FOUND);
    assertEquals(0, objectArray0.length);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, ""a"")            = null
 * ArrayUtils.removeElement([], ""a"")              = []
 * ArrayUtils.removeElement([""a""], ""b"")           = [""a""]
 * ArrayUtils.removeElement([""a"", ""b""], ""a"")      = [""b""]
 * ArrayUtils.removeElement([""a"", ""b"", ""a""], ""a"") = [""b"", ""a""]
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"public static long[] removeElement(long[] array, long element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test04147() throws Throwable {
    ArrayUtils arrayUtils0 = new ArrayUtils();
    long[] longArray0 = ArrayUtils.removeElement(arrayUtils0.EMPTY_LONG_ARRAY, 2723L);
    assertEquals(0, longArray0.length);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, 1)      = null
 * ArrayUtils.removeElement([], 1)        = []
 * ArrayUtils.removeElement([1], 2)       = [1]
 * ArrayUtils.removeElement([1, 3], 1)    = [3]
 * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"public static int[] removeElement(int[] array, int element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test04248() throws Throwable {
    int[] intArray0 = new int[0];
    int[] intArray1 = ArrayUtils.removeElement(intArray0, 0);
    assertArrayEquals(new int[] {}, intArray1);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, 1)      = null
 * ArrayUtils.removeElement([], 1)        = []
 * ArrayUtils.removeElement([1], 2)       = [1]
 * ArrayUtils.removeElement([1, 3], 1)    = [3]
 * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"public static float[] removeElement(float[] array, float element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test04349() throws Throwable {
    float[] floatArray0 = new float[0];
    float[] floatArray1 = ArrayUtils.removeElement(floatArray0, 0.0F);
    assertNotSame(floatArray0, floatArray1);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, 1.1)            = null
 * ArrayUtils.removeElement([], 1.1)              = []
 * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]
 * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]
 * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"public static double[] removeElement(double[] array, double element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test04450() throws Throwable {
    double[] doubleArray0 = new double[0];
    double[] doubleArray1 = ArrayUtils.removeElement(doubleArray0, 2519.472655);
    assertNotSame(doubleArray0, doubleArray1);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, 1.1)            = null
 * ArrayUtils.removeElement([], 1.1)              = []
 * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]
 * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]
 * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"public static char[] removeElement(char[] array, char element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test04551() throws Throwable {
    char[] charArray0 = ArrayUtils.removeElement((char[]) null, 'X');
    assertNull(charArray0);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, 'a')            = null
 * ArrayUtils.removeElement([], 'a')              = []
 * ArrayUtils.removeElement(['a'], 'b')           = ['a']
 * ArrayUtils.removeElement(['a', 'b'], 'a')      = ['b']
 * ArrayUtils.removeElement(['a', 'b', 'a'], 'a') = ['b', 'a']
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"public static char[] removeElement(char[] array, char element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test04652() throws Throwable {
    ArrayUtils arrayUtils0 = new ArrayUtils();
    char[] charArray0 = ArrayUtils.removeElement(arrayUtils0.EMPTY_CHAR_ARRAY, 'R');
    assertArrayEquals(new char[] {}, charArray0);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, 'a')            = null
 * ArrayUtils.removeElement([], 'a')              = []
 * ArrayUtils.removeElement(['a'], 'b')           = ['a']
 * ArrayUtils.removeElement(['a', 'b'], 'a')      = ['b']
 * ArrayUtils.removeElement(['a', 'b', 'a'], 'a') = ['b', 'a']
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"public static byte[] removeElement(byte[] array, byte element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test04753() throws Throwable {
    byte[] byteArray0 = ArrayUtils.removeElement((byte[]) null, (byte) 98);
    assertNull(byteArray0);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, 1)        = null
 * ArrayUtils.removeElement([], 1)          = []
 * ArrayUtils.removeElement([1], 0)         = [1]
 * ArrayUtils.removeElement([1, 0], 0)      = [1]
 * ArrayUtils.removeElement([1, 0, 1], 1)   = [0, 1]
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"public static boolean[] remove(boolean[] array, int index) {
    return (boolean[]) remove((Object) array, index);
}","public void test04854() throws Throwable {
    boolean[] booleanArray0 = new boolean[4];
    boolean[] booleanArray1 = ArrayUtils.remove(booleanArray0, 3);
    assertEquals(3, booleanArray1.length);
}","/**
 * <p>Removes the element at the specified position from the specified array.
 * All subsequent elements are shifted to the left (substracts one from
 * their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException
 * will be thrown, because in that case no valid index can be specified.</p>
 *
 * <pre>
 * ArrayUtils.remove([true], 0)              = []
 * ArrayUtils.remove([true, false], 0)       = [false]
 * ArrayUtils.remove([true, false], 1)       = [true]
 * ArrayUtils.remove([true, true, false], 1) = [true, false]
 * </pre>
 *
 * @param array  the array to remove the element from, may not be <code>null</code>
 * @param index  the position of the element to be removed
 * @return A new array containing the existing elements except the element
 *         at the specified position.
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index >= array.length), or if the array is <code>null</code>.
 * @since 2.1
 */"
"public static long[] remove(long[] array, int index) {
    return (long[]) remove((Object) array, index);
}","public void test04955() throws Throwable {
    long[] longArray0 = new long[4];
    long[] longArray1 = ArrayUtils.remove(longArray0, 0);
    assertEquals(3, longArray1.length);
}","/**
 * <p>Removes the element at the specified position from the specified array.
 * All subsequent elements are shifted to the left (substracts one from
 * their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException
 * will be thrown, because in that case no valid index can be specified.</p>
 *
 * <pre>
 * ArrayUtils.remove([1], 0)         = []
 * ArrayUtils.remove([2, 6], 0)      = [6]
 * ArrayUtils.remove([2, 6], 1)      = [2]
 * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]
 * </pre>
 *
 * @param array  the array to remove the element from, may not be <code>null</code>
 * @param index  the position of the element to be removed
 * @return A new array containing the existing elements except the element
 *         at the specified position.
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index >= array.length), or if the array is <code>null</code>.
 * @since 2.1
 */"
"public static long[] remove(long[] array, int index) {
    return (long[]) remove((Object) array, index);
}","public void test05056() throws Throwable {
    long[] longArray0 = new long[1];
    long[] longArray1 = ArrayUtils.remove(longArray0, 0);
    assertEquals(0, longArray1.length);
}","/**
 * <p>Removes the element at the specified position from the specified array.
 * All subsequent elements are shifted to the left (substracts one from
 * their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException
 * will be thrown, because in that case no valid index can be specified.</p>
 *
 * <pre>
 * ArrayUtils.remove([1], 0)         = []
 * ArrayUtils.remove([2, 6], 0)      = [6]
 * ArrayUtils.remove([2, 6], 1)      = [2]
 * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]
 * </pre>
 *
 * @param array  the array to remove the element from, may not be <code>null</code>
 * @param index  the position of the element to be removed
 * @return A new array containing the existing elements except the element
 *         at the specified position.
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index >= array.length), or if the array is <code>null</code>.
 * @since 2.1
 */"
"public static int[] remove(int[] array, int index) {
    return (int[]) remove((Object) array, index);
}","public void test05157() throws Throwable {
    int[] intArray0 = new int[9];
    int[] intArray1 = ArrayUtils.remove(intArray0, 2);
    assertEquals(8, intArray1.length);
}","/**
 * <p>Removes the element at the specified position from the specified array.
 * All subsequent elements are shifted to the left (substracts one from
 * their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException
 * will be thrown, because in that case no valid index can be specified.</p>
 *
 * <pre>
 * ArrayUtils.remove([1], 0)         = []
 * ArrayUtils.remove([2, 6], 0)      = [6]
 * ArrayUtils.remove([2, 6], 1)      = [2]
 * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]
 * </pre>
 *
 * @param array  the array to remove the element from, may not be <code>null</code>
 * @param index  the position of the element to be removed
 * @return A new array containing the existing elements except the element
 *         at the specified position.
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index >= array.length), or if the array is <code>null</code>.
 * @since 2.1
 */"
"public static float[] remove(float[] array, int index) {
    return (float[]) remove((Object) array, index);
}","public void test05258() throws Throwable {
    float[] floatArray0 = new float[4];
    float[] floatArray1 = ArrayUtils.remove(floatArray0, 3);
    assertEquals(3, floatArray1.length);
}","/**
 * <p>Removes the element at the specified position from the specified array.
 * All subsequent elements are shifted to the left (substracts one from
 * their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException
 * will be thrown, because in that case no valid index can be specified.</p>
 *
 * <pre>
 * ArrayUtils.remove([1.1], 0)           = []
 * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]
 * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]
 * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]
 * </pre>
 *
 * @param array  the array to remove the element from, may not be <code>null</code>
 * @param index  the position of the element to be removed
 * @return A new array containing the existing elements except the element
 *         at the specified position.
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index >= array.length), or if the array is <code>null</code>.
 * @since 2.1
 */"
"public static char[] remove(char[] array, int index) {
    return (char[]) remove((Object) array, index);
}","public void test05359() throws Throwable {
    char[] charArray0 = new char[5];
    char[] charArray1 = ArrayUtils.remove(charArray0, 2);
    assertEquals(4, charArray1.length);
}","/**
 * <p>Removes the element at the specified position from the specified array.
 * All subsequent elements are shifted to the left (substracts one from
 * their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException
 * will be thrown, because in that case no valid index can be specified.</p>
 *
 * <pre>
 * ArrayUtils.remove(['a'], 0)           = []
 * ArrayUtils.remove(['a', 'b'], 0)      = ['b']
 * ArrayUtils.remove(['a', 'b'], 1)      = ['a']
 * ArrayUtils.remove(['a', 'b', 'c'], 1) = ['a', 'c']
 * </pre>
 *
 * @param array  the array to remove the element from, may not be <code>null</code>
 * @param index  the position of the element to be removed
 * @return A new array containing the existing elements except the element
 *         at the specified position.
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index >= array.length), or if the array is <code>null</code>.
 * @since 2.1
 */"
"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test05460() throws Throwable {
    boolean[] booleanArray0 = new boolean[3];
    booleanArray0[0] = true;
    int int0 = ArrayUtils.lastIndexOf(booleanArray0, true, 0);
    assertEquals(0, int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than
 * the array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(boolean[] array, boolean valueToFind) {
    return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
}","public void test05561() throws Throwable {
    boolean[] booleanArray0 = new boolean[4];
    int int0 = ArrayUtils.lastIndexOf(booleanArray0, false);
    assertEquals(3, int0);
}","/**
 * <p>Finds the last index of the given value within the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) if
 * <code>null</code> array input.</p>
 *
 * @param array  the array to travers backwords looking for the object, may be <code>null</code>
 * @param valueToFind  the object to find
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(boolean[] array, boolean valueToFind) {
    return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
}","public void test05662() throws Throwable {
    boolean[] booleanArray0 = new boolean[2];
    int int0 = ArrayUtils.lastIndexOf(booleanArray0, true);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value within the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) if
 * <code>null</code> array input.</p>
 *
 * @param array  the array to travers backwords looking for the object, may be <code>null</code>
 * @param valueToFind  the object to find
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test05763() throws Throwable {
    short[] shortArray0 = new short[9];
    int int0 = ArrayUtils.lastIndexOf(shortArray0, (short) 0, 0);
    assertEquals(0, int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(short[] array, short valueToFind) {
    return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
}","public void test05864() throws Throwable {
    short[] shortArray0 = new short[3];
    shortArray0[0] = (short) 64;
    int int0 = ArrayUtils.lastIndexOf(shortArray0, (short) 64);
    assertEquals(0, int0);
}","/**
 * <p>Finds the last index of the given value within the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to travers backwords looking for the object, may be <code>null</code>
 * @param valueToFind  the object to find
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(short[] array, short valueToFind) {
    return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
}","public void test05965() throws Throwable {
    short[] shortArray0 = new short[7];
    shortArray0[4] = (short) (-1);
    int int0 = ArrayUtils.lastIndexOf(shortArray0, (short) (-1));
    assertEquals(4, int0);
}","/**
 * <p>Finds the last index of the given value within the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to travers backwords looking for the object, may be <code>null</code>
 * @param valueToFind  the object to find
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(Object[] array, Object objectToFind) {
    return lastIndexOf(array, objectToFind, Integer.MAX_VALUE);
}","public void test06066() throws Throwable {
    Object[] objectArray0 = new Object[5];
    int int0 = ArrayUtils.lastIndexOf(objectArray0, objectArray0[0]);
    assertEquals(4, int0);
}","/**
 * <p>Finds the last index of the given object within the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to travers backwords looking for the object, may be <code>null</code>
 * @param objectToFind  the object to find, may be <code>null</code>
 * @return the last index of the object within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test06167() throws Throwable {
    long[] longArray0 = new long[1];
    int int0 = ArrayUtils.lastIndexOf(longArray0, 0L, (int) '=');
    assertEquals(0, int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(long[] array, long valueToFind) {
    return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
}","public void test06268() throws Throwable {
    long[] longArray0 = new long[1];
    int int0 = ArrayUtils.lastIndexOf(longArray0, (long) 0);
    assertEquals(0, int0);
}","/**
 * <p>Finds the last index of the given value within the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to travers backwords looking for the object, may be <code>null</code>
 * @param valueToFind  the object to find
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(long[] array, long valueToFind) {
    return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
}","public void test06369() throws Throwable {
    long[] longArray0 = new long[3];
    int int0 = ArrayUtils.lastIndexOf(longArray0, 0L);
    assertEquals(2, int0);
}","/**
 * <p>Finds the last index of the given value within the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to travers backwords looking for the object, may be <code>null</code>
 * @param valueToFind  the object to find
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(int[] array, int valueToFind) {
    return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
}","public void test06470() throws Throwable {
    int[] intArray0 = new int[3];
    intArray0[0] = (-672);
    int int0 = ArrayUtils.lastIndexOf(intArray0, (-672));
    assertEquals(0, int0);
}","/**
 * <p>Finds the last index of the given value within the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to travers backwords looking for the object, may be <code>null</code>
 * @param valueToFind  the object to find
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(int[] array, int valueToFind) {
    return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
}","public void test06571() throws Throwable {
    int[] intArray0 = new int[7];
    intArray0[1] = (-1);
    int int0 = ArrayUtils.lastIndexOf(intArray0, (-1));
    assertEquals(1, int0);
}","/**
 * <p>Finds the last index of the given value within the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to travers backwords looking for the object, may be <code>null</code>
 * @param valueToFind  the object to find
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test06672() throws Throwable {
    float[] floatArray0 = new float[9];
    int int0 = ArrayUtils.lastIndexOf(floatArray0, 0.0F, 64);
    assertEquals(8, int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(float[] array, float valueToFind) {
    return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
}","public void test06773() throws Throwable {
    float[] floatArray0 = new float[1];
    floatArray0[0] = (-98.0F);
    int int0 = ArrayUtils.lastIndexOf(floatArray0, (-98.0F));
    assertEquals(0, int0);
}","/**
 * <p>Finds the last index of the given value within the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to travers backwords looking for the object, may be <code>null</code>
 * @param valueToFind  the object to find
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test06874() throws Throwable {
    double[] doubleArray0 = new double[21];
    doubleArray0[0] = 938.37784;
    int int0 = ArrayUtils.lastIndexOf(doubleArray0, 938.37784, 1811, 1.0);
    assertEquals(0, int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.
 * This method will return the index of the last value which falls between the region
 * defined by valueToFind - tolerance and valueToFind + tolerance.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @param tolerance  search for value within plus/minus this amount
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test06975() throws Throwable {
    double[] doubleArray0 = new double[1];
    int int0 = ArrayUtils.lastIndexOf(doubleArray0, 0.0, 0);
    assertEquals(0, int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(double[] array, double valueToFind, double tolerance) {
    return lastIndexOf(array, valueToFind, Integer.MAX_VALUE, tolerance);
}","public void test07076() throws Throwable {
    double[] doubleArray0 = new double[1];
    int int0 = ArrayUtils.lastIndexOf(doubleArray0, 0.0, 0.0);
    assertEquals(0, int0);
}","/**
 * <p>Finds the last index of the given value within a given tolerance in the array.
 * This method will return the index of the last value which falls between the region
 * defined by valueToFind - tolerance and valueToFind + tolerance.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param tolerance tolerance of the search
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(double[] array, double valueToFind, double tolerance) {
    return lastIndexOf(array, valueToFind, Integer.MAX_VALUE, tolerance);
}","public void test07177() throws Throwable {
    double[] doubleArray0 = new double[0];
    int int0 = ArrayUtils.lastIndexOf(doubleArray0, 0.0, 0.0);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value within a given tolerance in the array.
 * This method will return the index of the last value which falls between the region
 * defined by valueToFind - tolerance and valueToFind + tolerance.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param tolerance tolerance of the search
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(double[] array, double valueToFind) {
    return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
}","public void test07278() throws Throwable {
    double[] doubleArray0 = new double[8];
    doubleArray0[0] = (double) (-1);
    int int0 = ArrayUtils.lastIndexOf(doubleArray0, (-1.0));
    assertEquals(0, int0);
}","/**
 * <p>Finds the last index of the given value within the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to travers backwords looking for the object, may be <code>null</code>
 * @param valueToFind  the object to find
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(double[] array, double valueToFind) {
    return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
}","public void test07379() throws Throwable {
    double[] doubleArray0 = new double[4];
    int int0 = ArrayUtils.lastIndexOf(doubleArray0, 0.0);
    assertEquals(3, int0);
}","/**
 * <p>Finds the last index of the given value within the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to travers backwords looking for the object, may be <code>null</code>
 * @param valueToFind  the object to find
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test07480() throws Throwable {
    char[] charArray0 = new char[3];
    charArray0[2] = 'R';
    int int0 = ArrayUtils.lastIndexOf(charArray0, 'R', (int) (byte) 5);
    assertEquals(2, int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 * @since 2.1
 */"
"public static int lastIndexOf(char[] array, char valueToFind) {
    return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
}","public void test07581() throws Throwable {
    char[] charArray0 = new char[3];
    charArray0[0] = '~';
    int int0 = ArrayUtils.lastIndexOf(charArray0, '~');
    assertEquals(0, int0);
}","/**
 * <p>Finds the last index of the given value within the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to travers backwords looking for the object, may be <code>null</code>
 * @param valueToFind  the object to find
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 * @since 2.1
 */"
"public static int lastIndexOf(char[] array, char valueToFind) {
    return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
}","public void test07682() throws Throwable {
    char[] charArray0 = new char[5];
    charArray0[4] = '4';
    int int0 = ArrayUtils.lastIndexOf(charArray0, '4');
    assertEquals(4, int0);
}","/**
 * <p>Finds the last index of the given value within the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to travers backwords looking for the object, may be <code>null</code>
 * @param valueToFind  the object to find
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 * @since 2.1
 */"
"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test07783() throws Throwable {
    byte[] byteArray0 = new byte[5];
    byteArray0[1] = (byte) 82;
    byteArray0[2] = (byte) 19;
    byteArray0[3] = (byte) 5;
    byteArray0[4] = (byte) 5;
    int int0 = ArrayUtils.lastIndexOf(byteArray0, (byte) 0, (int) (byte) 82);
    assertEquals(0, int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(byte[] array, byte valueToFind) {
    return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
}","public void test07884() throws Throwable {
    byte[] byteArray0 = new byte[1];
    int int0 = ArrayUtils.lastIndexOf(byteArray0, (byte) 0);
    assertEquals(0, int0);
}","/**
 * <p>Finds the last index of the given value within the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to travers backwords looking for the object, may be <code>null</code>
 * @param valueToFind  the object to find
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static boolean isSameType(Object array1, Object array2) {
    if (array1 == null || array2 == null) {
        throw new IllegalArgumentException(""The Array must not be null"");
    }
    return array1.getClass().getName().equals(array2.getClass().getName());
}","public void test07985() throws Throwable {
    Integer integer0 = new Integer(0);
    boolean boolean0 = ArrayUtils.isSameType(integer0, integer0);
    assertTrue(boolean0);
}","/**
 * <p>Checks whether two arrays are the same type taking into account
 * multi-dimensional arrays.</p>
 *
 * @param array1 the first array, must not be <code>null</code>
 * @param array2 the second array, must not be <code>null</code>
 * @return <code>true</code> if type of arrays matches
 * @throws IllegalArgumentException if either array is <code>null</code>
 */"
"public static boolean isEquals(Object array1, Object array2) {
    return new EqualsBuilder().append(array1, array2).isEquals();
}","public void test08086() throws Throwable {
    Object object0 = new Object();
    boolean boolean0 = ArrayUtils.isEquals(""java.awt.graphicsenv"", object0);
    assertFalse(boolean0);
}","/**
 * <p>Compares two arrays, using equals(), handling multi-dimensional arrays
 * correctly.</p>
 *
 * <p>Multi-dimensional primitive arrays are also handled correctly by this method.</p>
 *
 * @param array1  the left hand array to compare, may be <code>null</code>
 * @param array2  the right hand array to compare, may be <code>null</code>
 * @return <code>true</code> if the arrays are equal
 */"
"public static int indexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test08187() throws Throwable {
    boolean[] booleanArray0 = new boolean[4];
    booleanArray0[1] = true;
    int int0 = ArrayUtils.indexOf(booleanArray0, true, (int) (short) 0);
    assertEquals(1, int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code>
 *  array input
 */"
"// boolean IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the index of the given value in the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */
public static int indexOf(boolean[] array, boolean valueToFind) {
    return indexOf(array, valueToFind, 0);
}","public void test08288() throws Throwable {
    boolean[] booleanArray0 = new boolean[4];
    booleanArray0[0] = true;
    int int0 = ArrayUtils.indexOf(booleanArray0, false);
    assertEquals(1, int0);
}",""
"// short IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the index of the given value in the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */
public static int indexOf(short[] array, short valueToFind) {
    return indexOf(array, valueToFind, 0);
}","public void test08389() throws Throwable {
    short[] shortArray0 = new short[7];
    shortArray0[0] = (short) 2997;
    int int0 = ArrayUtils.indexOf(shortArray0, (short) 2997);
    assertEquals(0, int0);
}",""
"// short IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the index of the given value in the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */
public static int indexOf(short[] array, short valueToFind) {
    return indexOf(array, valueToFind, 0);
}","public void test08490() throws Throwable {
    short[] shortArray0 = new short[5];
    shortArray0[3] = (short) (-2811);
    int int0 = ArrayUtils.indexOf(shortArray0, (short) (-2811));
    assertEquals(3, int0);
}",""
"// IndexOf search
// ----------------------------------------------------------------------
// Object IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the index of the given object in the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param objectToFind  the object to find, may be <code>null</code>
 * @return the index of the object within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */
public static int indexOf(Object[] array, Object objectToFind) {
    return indexOf(array, objectToFind, 0);
}","public void test08591() throws Throwable {
    Object[] objectArray0 = new Object[3];
    Object object0 = new Object();
    objectArray0[1] = object0;
    int int0 = ArrayUtils.indexOf(objectArray0, object0);
    assertEquals(1, int0);
}",""
"// long IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the index of the given value in the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */
public static int indexOf(long[] array, long valueToFind) {
    return indexOf(array, valueToFind, 0);
}","public void test08692() throws Throwable {
    long[] longArray0 = new long[4];
    int int0 = ArrayUtils.indexOf(longArray0, 0L);
    assertEquals(0, int0);
}",""
"// long IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the index of the given value in the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */
public static int indexOf(long[] array, long valueToFind) {
    return indexOf(array, valueToFind, 0);
}","public void test08793() throws Throwable {
    long[] longArray0 = new long[5];
    longArray0[1] = (long) (-1);
    int int0 = ArrayUtils.indexOf(longArray0, (long) (-1));
    assertEquals(1, int0);
}",""
"public static int indexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test08894() throws Throwable {
    int[] intArray0 = new int[5];
    intArray0[2] = 58;
    int int0 = ArrayUtils.indexOf(intArray0, 58, (-2996));
    assertEquals(2, int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"// int IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the index of the given value in the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */
public static int indexOf(int[] array, int valueToFind) {
    return indexOf(array, valueToFind, 0);
}","public void test08995() throws Throwable {
    int[] intArray0 = new int[5];
    intArray0[1] = (-1990);
    int int0 = ArrayUtils.indexOf(intArray0, (-1990));
    assertEquals(1, int0);
}",""
"// float IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the index of the given value in the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */
public static int indexOf(float[] array, float valueToFind) {
    return indexOf(array, valueToFind, 0);
}","public void test09096() throws Throwable {
    float[] floatArray0 = new float[3];
    floatArray0[2] = (-1.0F);
    int int0 = ArrayUtils.indexOf(floatArray0, (-1.0F));
    assertEquals(2, int0);
}",""
"public static int indexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i < array.length; i++) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test09197() throws Throwable {
    double[] doubleArray0 = new double[7];
    doubleArray0[2] = 435.264886227;
    int int0 = ArrayUtils.indexOf(doubleArray0, 435.264886227, (int) (byte) 0, (double) (byte) 0);
    assertEquals(2, int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.
 * This method will return the index of the first value which falls between the region
 * defined by valueToFind - tolerance and valueToFind + tolerance.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @param tolerance tolerance of the search
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(double[] array, double valueToFind, double tolerance) {
    return indexOf(array, valueToFind, 0, tolerance);
}","public void test09298() throws Throwable {
    int int0 = ArrayUtils.indexOf((double[]) null, 1235.3909518515, 26.20243310753);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given value within a given tolerance in the array.
 * This method will return the index of the first value which falls between the region
 * defined by valueToFind - tolerance and valueToFind + tolerance.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param tolerance tolerance of the search
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"// double IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the index of the given value in the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */
public static int indexOf(double[] array, double valueToFind) {
    return indexOf(array, valueToFind, 0);
}","public void test09399() throws Throwable {
    double[] doubleArray0 = new double[9];
    doubleArray0[3] = (double) (byte) 109;
    int int0 = ArrayUtils.indexOf(doubleArray0, (double) (byte) 109);
    assertEquals(3, int0);
}",""
"public static int indexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test094100() throws Throwable {
    char[] charArray0 = new char[5];
    charArray0[1] = 'U';
    int int0 = ArrayUtils.indexOf(charArray0, 'U', (-1));
    assertEquals(1, int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 * @since 2.1
 */"
"// char IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the index of the given value in the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 * @since 2.1
 */
public static int indexOf(char[] array, char valueToFind) {
    return indexOf(array, valueToFind, 0);
}","public void test095101() throws Throwable {
    char[] charArray0 = new char[4];
    charArray0[0] = 'y';
    int int0 = ArrayUtils.indexOf(charArray0, 'y');
    assertEquals(0, int0);
}",""
"public static int indexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test096102() throws Throwable {
    byte[] byteArray0 = new byte[7];
    byteArray0[4] = (byte) 5;
    int int0 = ArrayUtils.indexOf(byteArray0, (byte) 5, 0);
    assertEquals(4, int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"// byte IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the index of the given value in the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */
public static int indexOf(byte[] array, byte valueToFind) {
    return indexOf(array, valueToFind, 0);
}","public void test097103() throws Throwable {
    byte[] byteArray0 = new byte[5];
    int int0 = ArrayUtils.indexOf(byteArray0, (byte) 0);
    assertEquals(0, int0);
}",""
"// byte IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the index of the given value in the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */
public static int indexOf(byte[] array, byte valueToFind) {
    return indexOf(array, valueToFind, 0);
}","public void test098104() throws Throwable {
    byte[] byteArray0 = new byte[5];
    byteArray0[2] = (byte) 19;
    int int0 = ArrayUtils.indexOf(byteArray0, (byte) 19);
    assertEquals(2, int0);
}",""
"public static boolean[] clone(boolean[] array) {
    if (array == null) {
        return null;
    }
    return array.clone();
}","public void test099105() throws Throwable {
    boolean[] booleanArray0 = new boolean[1];
    boolean[] booleanArray1 = ArrayUtils.clone(booleanArray0);
    assertEquals(1, booleanArray1.length);
}","/**
 * <p>Clones an array returning a typecast result and handling
 * <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  the array to clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */"
"public static short[] clone(short[] array) {
    if (array == null) {
        return null;
    }
    return array.clone();
}","public void test100106() throws Throwable {
    short[] shortArray0 = new short[0];
    short[] shortArray1 = ArrayUtils.clone(shortArray0);
    assertEquals(0, shortArray1.length);
}","/**
 * <p>Clones an array returning a typecast result and handling
 * <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  the array to clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */"
"// Clone
//-----------------------------------------------------------------------
/**
 * <p>Shallow clones an array returning a typecast result and handling
 * <code>null</code>.</p>
 *
 * <p>The objects in the array are not cloned, thus there is no special
 * handling for multi-dimensional arrays.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  the array to shallow clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */
public static <T> T[] clone(T[] array) {
    if (array == null) {
        return null;
    }
    return array.clone();
}","public void test101107() throws Throwable {
    ArrayUtils arrayUtils0 = new ArrayUtils();
    Integer[] integerArray0 = ArrayUtils.clone(arrayUtils0.EMPTY_INTEGER_OBJECT_ARRAY);
    assertEquals(0, integerArray0.length);
}",""
"public static long[] clone(long[] array) {
    if (array == null) {
        return null;
    }
    return array.clone();
}","public void test102108() throws Throwable {
    long[] longArray0 = new long[4];
    long[] longArray1 = ArrayUtils.clone(longArray0);
    assertEquals(4, longArray1.length);
}","/**
 * <p>Clones an array returning a typecast result and handling
 * <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  the array to clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */"
"public static int[] clone(int[] array) {
    if (array == null) {
        return null;
    }
    return array.clone();
}","public void test103109() throws Throwable {
    int[] intArray0 = new int[0];
    int[] intArray1 = ArrayUtils.clone(intArray0);
    assertNotSame(intArray0, intArray1);
}","/**
 * <p>Clones an array returning a typecast result and handling
 * <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  the array to clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */"
"public static char[] clone(char[] array) {
    if (array == null) {
        return null;
    }
    return array.clone();
}","public void test105111() throws Throwable {
    char[] charArray0 = new char[5];
    char[] charArray1 = ArrayUtils.clone(charArray0);
    assertEquals(5, charArray1.length);
}","/**
 * <p>Clones an array returning a typecast result and handling
 * <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  the array to clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */"
"public static byte[] clone(byte[] array) {
    if (array == null) {
        return null;
    }
    return array.clone();
}","public void test106112() throws Throwable {
    byte[] byteArray0 = new byte[7];
    byte[] byteArray1 = ArrayUtils.clone(byteArray0);
    assertEquals(7, byteArray1.length);
}","/**
 * <p>Clones an array returning a typecast result and handling
 * <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  the array to clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */"
"public static boolean[] addAll(boolean[] array1, boolean... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    boolean[] joinedArray = new boolean[array1.length + array2.length];
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    return joinedArray;
}","public void test107113() throws Throwable {
    boolean[] booleanArray0 = new boolean[0];
    boolean[] booleanArray1 = ArrayUtils.addAll(booleanArray0, booleanArray0);
    assertNotSame(booleanArray1, booleanArray0);
}","/**
 * <p>Adds all the elements of the given arrays into a new array.</p>
 * <p>The new array contains all of the element of <code>array1</code> followed
 * by all of the elements <code>array2</code>. When an array is returned, it is always
 * a new array.</p>
 *
 * <pre>
 * ArrayUtils.addAll(array1, null)   = cloned copy of array1
 * ArrayUtils.addAll(null, array2)   = cloned copy of array2
 * ArrayUtils.addAll([], [])         = []
 * </pre>
 *
 * @param array1  the first array whose elements are added to the new array.
 * @param array2  the second array whose elements are added to the new array.
 * @return The new boolean[] array.
 * @since 2.1
 */"
"public static short[] addAll(short[] array1, short... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    short[] joinedArray = new short[array1.length + array2.length];
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    return joinedArray;
}","public void test108114() throws Throwable {
    short[] shortArray0 = new short[0];
    short[] shortArray1 = ArrayUtils.addAll(shortArray0, shortArray0);
    assertNotSame(shortArray1, shortArray0);
}","/**
 * <p>Adds all the elements of the given arrays into a new array.</p>
 * <p>The new array contains all of the element of <code>array1</code> followed
 * by all of the elements <code>array2</code>. When an array is returned, it is always
 * a new array.</p>
 *
 * <pre>
 * ArrayUtils.addAll(array1, null)   = cloned copy of array1
 * ArrayUtils.addAll(null, array2)   = cloned copy of array2
 * ArrayUtils.addAll([], [])         = []
 * </pre>
 *
 * @param array1  the first array whose elements are added to the new array.
 * @param array2  the second array whose elements are added to the new array.
 * @return The new short[] array.
 * @since 2.1
 */"
"public static <T> T[] addAll(T[] array1, T... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    final Class<?> type1 = array1.getClass().getComponentType();
    // OK, because array is of type T
    @SuppressWarnings(""unchecked"")
    T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    try {
        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    } catch (ArrayStoreException ase) {
        // Check if problem was due to incompatible types
        /*
             * We do this here, rather than before the copy because:
             * - it would be a wasted check most of the time
             * - safer, in case check turns out to be too strict
             */
        final Class<?> type2 = array2.getClass().getComponentType();
        if (!type1.isAssignableFrom(type2)) {
            throw new IllegalArgumentException(""Cannot store "" + type2.getName() + "" in an array of "" + type1.getName(), ase);
        }
        // No, so rethrow original
        throw ase;
    }
    return joinedArray;
}","public void test109115() throws Throwable {
    AbstractMap.SimpleEntry<Object, String>[] abstractMap_SimpleEntryArray0 = (AbstractMap.SimpleEntry<Object, String>[]) Array.newInstance(AbstractMap.SimpleEntry.class, 0);
    AbstractMap.SimpleEntry<Object, String>[] abstractMap_SimpleEntryArray1 = ArrayUtils.addAll(abstractMap_SimpleEntryArray0, abstractMap_SimpleEntryArray0);
    assertNotSame(abstractMap_SimpleEntryArray1, abstractMap_SimpleEntryArray0);
}","/**
 * <p>Adds all the elements of the given arrays into a new array.</p>
 * <p>The new array contains all of the element of <code>array1</code> followed
 * by all of the elements <code>array2</code>. When an array is returned, it is always
 * a new array.</p>
 *
 * <pre>
 * ArrayUtils.addAll(null, null)     = null
 * ArrayUtils.addAll(array1, null)   = cloned copy of array1
 * ArrayUtils.addAll(null, array2)   = cloned copy of array2
 * ArrayUtils.addAll([], [])         = []
 * ArrayUtils.addAll([null], [null]) = [null, null]
 * ArrayUtils.addAll([""a"", ""b"", ""c""], [""1"", ""2"", ""3""]) = [""a"", ""b"", ""c"", ""1"", ""2"", ""3""]
 * </pre>
 *
 * @param array1  the first array whose elements are added to the new array, may be <code>null</code>
 * @param array2  the second array whose elements are added to the new array, may be <code>null</code>
 * @return The new array, <code>null</code> if both arrays are <code>null</code>.
 *      The type of the new array is the type of the first array,
 *      unless the first array is null, in which case the type is the same as the second array.
 * @since 2.1
 * @throws IllegalArgumentException if the array types are incompatible
 */"
"public static int[] addAll(int[] array1, int... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    int[] joinedArray = new int[array1.length + array2.length];
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    return joinedArray;
}","public void test110116() throws Throwable {
    int[] intArray0 = new int[0];
    int[] intArray1 = ArrayUtils.addAll(intArray0, intArray0);
    assertNotSame(intArray1, intArray0);
}","/**
 * <p>Adds all the elements of the given arrays into a new array.</p>
 * <p>The new array contains all of the element of <code>array1</code> followed
 * by all of the elements <code>array2</code>. When an array is returned, it is always
 * a new array.</p>
 *
 * <pre>
 * ArrayUtils.addAll(array1, null)   = cloned copy of array1
 * ArrayUtils.addAll(null, array2)   = cloned copy of array2
 * ArrayUtils.addAll([], [])         = []
 * </pre>
 *
 * @param array1  the first array whose elements are added to the new array.
 * @param array2  the second array whose elements are added to the new array.
 * @return The new int[] array.
 * @since 2.1
 */"
"public static float[] addAll(float[] array1, float... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    float[] joinedArray = new float[array1.length + array2.length];
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    return joinedArray;
}","public void test111117() throws Throwable {
    float[] floatArray0 = new float[0];
    float[] floatArray1 = ArrayUtils.addAll(floatArray0, floatArray0);
    assertNotSame(floatArray1, floatArray0);
}","/**
 * <p>Adds all the elements of the given arrays into a new array.</p>
 * <p>The new array contains all of the element of <code>array1</code> followed
 * by all of the elements <code>array2</code>. When an array is returned, it is always
 * a new array.</p>
 *
 * <pre>
 * ArrayUtils.addAll(array1, null)   = cloned copy of array1
 * ArrayUtils.addAll(null, array2)   = cloned copy of array2
 * ArrayUtils.addAll([], [])         = []
 * </pre>
 *
 * @param array1  the first array whose elements are added to the new array.
 * @param array2  the second array whose elements are added to the new array.
 * @return The new float[] array.
 * @since 2.1
 */"
"public static double[] addAll(double[] array1, double... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    double[] joinedArray = new double[array1.length + array2.length];
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    return joinedArray;
}","public void test112118() throws Throwable {
    double[] doubleArray0 = new double[0];
    double[] doubleArray1 = ArrayUtils.addAll(doubleArray0, doubleArray0);
    assertNotSame(doubleArray1, doubleArray0);
}","/**
 * <p>Adds all the elements of the given arrays into a new array.</p>
 * <p>The new array contains all of the element of <code>array1</code> followed
 * by all of the elements <code>array2</code>. When an array is returned, it is always
 * a new array.</p>
 *
 * <pre>
 * ArrayUtils.addAll(array1, null)   = cloned copy of array1
 * ArrayUtils.addAll(null, array2)   = cloned copy of array2
 * ArrayUtils.addAll([], [])         = []
 * </pre>
 *
 * @param array1  the first array whose elements are added to the new array.
 * @param array2  the second array whose elements are added to the new array.
 * @return The new double[] array.
 * @since 2.1
 */"
"public static char[] addAll(char[] array1, char... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    char[] joinedArray = new char[array1.length + array2.length];
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    return joinedArray;
}","public void test113119() throws Throwable {
    char[] charArray0 = new char[0];
    char[] charArray1 = ArrayUtils.addAll(charArray0, charArray0);
    assertNotSame(charArray1, charArray0);
}","/**
 * <p>Adds all the elements of the given arrays into a new array.</p>
 * <p>The new array contains all of the element of <code>array1</code> followed
 * by all of the elements <code>array2</code>. When an array is returned, it is always
 * a new array.</p>
 *
 * <pre>
 * ArrayUtils.addAll(array1, null)   = cloned copy of array1
 * ArrayUtils.addAll(null, array2)   = cloned copy of array2
 * ArrayUtils.addAll([], [])         = []
 * </pre>
 *
 * @param array1  the first array whose elements are added to the new array.
 * @param array2  the second array whose elements are added to the new array.
 * @return The new char[] array.
 * @since 2.1
 */"
"public static float[] add(float[] array, int index, float element) {
    return (float[]) add(array, index, Float.valueOf(element), Float.TYPE);
}","public void test115121() throws Throwable {
    float[] floatArray0 = new float[2];
    float[] floatArray1 = ArrayUtils.add(floatArray0, 1, 0.0F);
    assertArrayEquals(new float[] { 0.0F, 0.0F, 0.0F }, floatArray1, 0.01F);
}","/**
 * <p>Inserts the specified element at the specified position in the array.
 * Shifts the element currently at that position (if any) and any subsequent
 * elements to the right (adds one to their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array plus the given element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element.</p>
 *
 * <pre>
 * ArrayUtils.add([1.1f], 0, 2.2f)               = [2.2f, 1.1f]
 * ArrayUtils.add([2.3f, 6.4f], 2, 10.5f)        = [2.3f, 6.4f, 10.5f]
 * ArrayUtils.add([2.6f, 6.7f], 0, -4.8f)        = [-4.8f, 2.6f, 6.7f]
 * ArrayUtils.add([2.9f, 6.0f, 0.3f], 2, 1.0f)   = [2.9f, 6.0f, 1.0f, 0.3f]
 * </pre>
 *
 * @param array  the array to add the element to, may be <code>null</code>
 * @param index  the position of the new object
 * @param element  the object to add
 * @return A new array containing the existing elements and the new element
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index > array.length).
 */"
"public static double[] add(double[] array, int index, double element) {
    return (double[]) add(array, index, Double.valueOf(element), Double.TYPE);
}","public void test116122() throws Throwable {
    double[] doubleArray0 = new double[8];
    double[] doubleArray1 = ArrayUtils.add(doubleArray0, 0, (-1.0));
    assertArrayEquals(new double[] { (-1.0), 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 }, doubleArray1, 0.01);
}","/**
 * <p>Inserts the specified element at the specified position in the array.
 * Shifts the element currently at that position (if any) and any subsequent
 * elements to the right (adds one to their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array plus the given element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element.</p>
 *
 * <pre>
 * ArrayUtils.add([1.1], 0, 2.2)              = [2.2, 1.1]
 * ArrayUtils.add([2.3, 6.4], 2, 10.5)        = [2.3, 6.4, 10.5]
 * ArrayUtils.add([2.6, 6.7], 0, -4.8)        = [-4.8, 2.6, 6.7]
 * ArrayUtils.add([2.9, 6.0, 0.3], 2, 1.0)    = [2.9, 6.0, 1.0, 0.3]
 * </pre>
 *
 * @param array  the array to add the element to, may be <code>null</code>
 * @param index  the position of the new object
 * @param element  the object to add
 * @return A new array containing the existing elements and the new element
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index > array.length).
 */"
"public static char[] add(char[] array, int index, char element) {
    return (char[]) add(array, index, Character.valueOf(element), Character.TYPE);
}","public void test117123() throws Throwable {
    char[] charArray0 = new char[2];
    char[] charArray1 = ArrayUtils.add(charArray0, (int) (byte) 0, ')');
    assertArrayEquals(new char[] { ')', '\u0000', '\u0000' }, charArray1);
}","/**
 * <p>Inserts the specified element at the specified position in the array.
 * Shifts the element currently at that position (if any) and any subsequent
 * elements to the right (adds one to their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array plus the given element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element.</p>
 *
 * <pre>
 * ArrayUtils.add(null, 0, 'a')            = ['a']
 * ArrayUtils.add(['a'], 0, 'b')           = ['b', 'a']
 * ArrayUtils.add(['a', 'b'], 0, 'c')      = ['c', 'a', 'b']
 * ArrayUtils.add(['a', 'b'], 1, 'k')      = ['a', 'k', 'b']
 * ArrayUtils.add(['a', 'b', 'c'], 1, 't') = ['a', 't', 'b', 'c']
 * </pre>
 *
 * @param array  the array to add the element to, may be <code>null</code>
 * @param index  the position of the new object
 * @param element  the object to add
 * @return A new array containing the existing elements and the new element
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index > array.length).
 */"
"// Boolean array converters
// ----------------------------------------------------------------------
/**
 * <p>Converts an array of object Booleans to primitives.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Boolean</code> array, may be <code>null</code>
 * @return a <code>boolean</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
public static boolean[] toPrimitive(Boolean[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }
    final boolean[] result = new boolean[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = array[i].booleanValue();
    }
    return result;
}","public void test118124() throws Throwable {
    Boolean[] booleanArray0 = new Boolean[8];
    // Undeclared exception!
    try {
        ArrayUtils.toPrimitive(booleanArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}",""
"public static short[] remove(short[] array, int index) {
    return (short[]) remove((Object) array, index);
}","public void test119125() throws Throwable {
    short[] shortArray0 = new short[8];
    // Undeclared exception!
    try {
        ArrayUtils.remove(shortArray0, (-1));
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // Index: -1, Length: 8
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}","/**
 * <p>Removes the element at the specified position from the specified array.
 * All subsequent elements are shifted to the left (substracts one from
 * their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException
 * will be thrown, because in that case no valid index can be specified.</p>
 *
 * <pre>
 * ArrayUtils.remove([1], 0)         = []
 * ArrayUtils.remove([2, 6], 0)      = [6]
 * ArrayUtils.remove([2, 6], 1)      = [2]
 * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]
 * </pre>
 *
 * @param array  the array to remove the element from, may not be <code>null</code>
 * @param index  the position of the element to be removed
 * @return A new array containing the existing elements except the element
 *         at the specified position.
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index >= array.length), or if the array is <code>null</code>.
 * @since 2.1
 */"
"// remove() always creates an array of the same type as its input
@SuppressWarnings(""unchecked"")
public static <T> T[] remove(T[] array, int index) {
    return (T[]) remove((Object) array, index);
}","public void test120126() throws Throwable {
    // Undeclared exception!
    try {
        ArrayUtils.remove((Integer[]) null, (-246));
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // Index: -246, Length: 0
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}","/**
 * <p>Removes the element at the specified position from the specified array.
 * All subsequent elements are shifted to the left (substracts one from
 * their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException
 * will be thrown, because in that case no valid index can be specified.</p>
 *
 * <pre>
 * ArrayUtils.remove([""a""], 0)           = []
 * ArrayUtils.remove([""a"", ""b""], 0)      = [""b""]
 * ArrayUtils.remove([""a"", ""b""], 1)      = [""a""]
 * ArrayUtils.remove([""a"", ""b"", ""c""], 1) = [""a"", ""c""]
 * </pre>
 *
 * @param array  the array to remove the element from, may not be <code>null</code>
 * @param index  the position of the element to be removed
 * @return A new array containing the existing elements except the element
 *         at the specified position.
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index >= array.length), or if the array is <code>null</code>.
 * @since 2.1
 */"
"public static double[] remove(double[] array, int index) {
    return (double[]) remove((Object) array, index);
}","public void test121127() throws Throwable {
    double[] doubleArray0 = new double[5];
    // Undeclared exception!
    try {
        ArrayUtils.remove(doubleArray0, 415);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // Index: 415, Length: 5
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}","/**
 * <p>Removes the element at the specified position from the specified array.
 * All subsequent elements are shifted to the left (substracts one from
 * their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException
 * will be thrown, because in that case no valid index can be specified.</p>
 *
 * <pre>
 * ArrayUtils.remove([1.1], 0)           = []
 * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]
 * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]
 * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]
 * </pre>
 *
 * @param array  the array to remove the element from, may not be <code>null</code>
 * @param index  the position of the element to be removed
 * @return A new array containing the existing elements except the element
 *         at the specified position.
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index >= array.length), or if the array is <code>null</code>.
 * @since 2.1
 */"
"public static byte[] remove(byte[] array, int index) {
    return (byte[]) remove((Object) array, index);
}","public void test122128() throws Throwable {
    byte[] byteArray0 = new byte[9];
    // Undeclared exception!
    try {
        ArrayUtils.remove(byteArray0, (int) (byte) (-1));
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // Index: -1, Length: 9
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}","/**
 * <p>Removes the element at the specified position from the specified array.
 * All subsequent elements are shifted to the left (substracts one from
 * their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException
 * will be thrown, because in that case no valid index can be specified.</p>
 *
 * <pre>
 * ArrayUtils.remove([1], 0)          = []
 * ArrayUtils.remove([1, 0], 0)       = [0]
 * ArrayUtils.remove([1, 0], 1)       = [1]
 * ArrayUtils.remove([1, 0, 1], 1)    = [1, 1]
 * </pre>
 *
 * @param array  the array to remove the element from, may not be <code>null</code>
 * @param index  the position of the element to be removed
 * @return A new array containing the existing elements except the element
 *         at the specified position.
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index >= array.length), or if the array is <code>null</code>.
 * @since 2.1
 */"
"public static short[] add(short[] array, int index, short element) {
    return (short[]) add(array, index, Short.valueOf(element), Short.TYPE);
}","public void test123129() throws Throwable {
    short[] shortArray0 = new short[6];
    // Undeclared exception!
    try {
        ArrayUtils.add(shortArray0, (int) (short) 2847, (short) 2847);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // Index: 2847, Length: 6
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}","/**
 * <p>Inserts the specified element at the specified position in the array.
 * Shifts the element currently at that position (if any) and any subsequent
 * elements to the right (adds one to their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array plus the given element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element.</p>
 *
 * <pre>
 * ArrayUtils.add([1], 0, 2)         = [2, 1]
 * ArrayUtils.add([2, 6], 2, 10)     = [2, 6, 10]
 * ArrayUtils.add([2, 6], 0, -4)     = [-4, 2, 6]
 * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]
 * </pre>
 *
 * @param array  the array to add the element to, may be <code>null</code>
 * @param index  the position of the new object
 * @param element  the object to add
 * @return A new array containing the existing elements and the new element
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index > array.length).
 */"
"public static <T> T[] add(T[] array, T element) {
    Class<?> type;
    if (array != null) {
        type = array.getClass();
    } else if (element != null) {
        type = element.getClass();
    } else {
        type = Object.class;
    }
    // type must be T
    @SuppressWarnings(""unchecked"")
    T[] newArray = (T[]) copyArrayGrow1(array, type);
    newArray[newArray.length - 1] = element;
    return newArray;
}","public void test124130() throws Throwable {
    Object object0 = new Object();
    ArrayUtils arrayUtils0 = new ArrayUtils();
    // Undeclared exception!
    try {
        ArrayUtils.add((Object[]) arrayUtils0.EMPTY_CLASS_ARRAY, object0);
        fail(""Expecting exception: ArrayStoreException"");
    } catch (ArrayStoreException e) {
        //
        // java.lang.Object
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}","/**
 * <p>Copies the given array and adds the given element at the end of the new array.</p>
 *
 * <p>The new array contains the same elements of the input
 * array plus the given element in the last position. The component type of
 * the new array is the same as that of the input array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element, unless the element itself is null,
 *  in which case the return type is Object[]</p>
 *
 * <pre>
 * ArrayUtils.add(null, null)      = [null]
 * ArrayUtils.add(null, ""a"")       = [""a""]
 * ArrayUtils.add([""a""], null)     = [""a"", null]
 * ArrayUtils.add([""a""], ""b"")      = [""a"", ""b""]
 * ArrayUtils.add([""a"", ""b""], ""c"") = [""a"", ""b"", ""c""]
 * </pre>
 *
 * @param array  the array to ""add"" the element to, may be <code>null</code>
 * @param element  the object to add, may be <code>null</code>
 * @return A new array containing the existing elements plus the new element
 * The returned array type will be that of the input array (unless null),
 * in which case it will have the same type as the element.
 * If both are null, an IllegalArgumentException is thrown
 * @since 2.1
 * @throws IllegalArgumentException if both arguments are null
 */"
"public static int[] add(int[] array, int index, int element) {
    return (int[]) add(array, index, Integer.valueOf(element), Integer.TYPE);
}","public void test125131() throws Throwable {
    // Undeclared exception!
    try {
        ArrayUtils.add((int[]) null, (int) (short) 224, 36);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // Index: 224, Length: 0
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}","/**
 * <p>Inserts the specified element at the specified position in the array.
 * Shifts the element currently at that position (if any) and any subsequent
 * elements to the right (adds one to their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array plus the given element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element.</p>
 *
 * <pre>
 * ArrayUtils.add([1], 0, 2)         = [2, 1]
 * ArrayUtils.add([2, 6], 2, 10)     = [2, 6, 10]
 * ArrayUtils.add([2, 6], 0, -4)     = [-4, 2, 6]
 * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]
 * </pre>
 *
 * @param array  the array to add the element to, may be <code>null</code>
 * @param index  the position of the new object
 * @param element  the object to add
 * @return A new array containing the existing elements and the new element
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index > array.length).
 */"
"public static byte[] add(byte[] array, int index, byte element) {
    return (byte[]) add(array, index, Byte.valueOf(element), Byte.TYPE);
}","public void test126132() throws Throwable {
    byte[] byteArray0 = new byte[8];
    // Undeclared exception!
    try {
        ArrayUtils.add(byteArray0, (int) (byte) 49, (byte) 4);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // Index: 49, Length: 8
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}","/**
 * <p>Inserts the specified element at the specified position in the array.
 * Shifts the element currently at that position (if any) and any subsequent
 * elements to the right (adds one to their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array plus the given element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element.</p>
 *
 * <pre>
 * ArrayUtils.add([1], 0, 2)         = [2, 1]
 * ArrayUtils.add([2, 6], 2, 3)      = [2, 6, 3]
 * ArrayUtils.add([2, 6], 0, 1)      = [1, 2, 6]
 * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]
 * </pre>
 *
 * @param array  the array to add the element to, may be <code>null</code>
 * @param index  the position of the new object
 * @param element  the object to add
 * @return A new array containing the existing elements and the new element
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index > array.length).
 */"
"public static boolean isEmpty(boolean[] array) {
    if (array == null || array.length == 0) {
        return true;
    }
    return false;
}","public void test127133() throws Throwable {
    boolean[] booleanArray0 = new boolean[1];
    boolean boolean0 = ArrayUtils.isEmpty(booleanArray0);
    assertFalse(boolean0);
}","/**
 * <p>Checks if an array of primitive booleans is empty or <code>null</code>.</p>
 *
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */"
"public static boolean isEmpty(boolean[] array) {
    if (array == null || array.length == 0) {
        return true;
    }
    return false;
}","public void test128134() throws Throwable {
    boolean boolean0 = ArrayUtils.isEmpty((boolean[]) null);
    assertTrue(boolean0);
}","/**
 * <p>Checks if an array of primitive booleans is empty or <code>null</code>.</p>
 *
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */"
"public static boolean isEmpty(boolean[] array) {
    if (array == null || array.length == 0) {
        return true;
    }
    return false;
}","public void test129135() throws Throwable {
    boolean[] booleanArray0 = new boolean[0];
    boolean boolean0 = ArrayUtils.isEmpty(booleanArray0);
    assertTrue(boolean0);
}","/**
 * <p>Checks if an array of primitive booleans is empty or <code>null</code>.</p>
 *
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */"
"public static boolean isEmpty(float[] array) {
    if (array == null || array.length == 0) {
        return true;
    }
    return false;
}","public void test130136() throws Throwable {
    boolean boolean0 = ArrayUtils.isEmpty((float[]) null);
    assertTrue(boolean0);
}","/**
 * <p>Checks if an array of primitive floats is empty or <code>null</code>.</p>
 *
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */"
"public static boolean isEmpty(float[] array) {
    if (array == null || array.length == 0) {
        return true;
    }
    return false;
}","public void test131137() throws Throwable {
    float[] floatArray0 = new float[0];
    boolean boolean0 = ArrayUtils.isEmpty(floatArray0);
    assertTrue(boolean0);
}","/**
 * <p>Checks if an array of primitive floats is empty or <code>null</code>.</p>
 *
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */"
"public static boolean isEmpty(float[] array) {
    if (array == null || array.length == 0) {
        return true;
    }
    return false;
}","public void test132138() throws Throwable {
    float[] floatArray0 = new float[4];
    boolean boolean0 = ArrayUtils.isEmpty(floatArray0);
    assertFalse(boolean0);
}","/**
 * <p>Checks if an array of primitive floats is empty or <code>null</code>.</p>
 *
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */"
"public static boolean isEmpty(double[] array) {
    if (array == null || array.length == 0) {
        return true;
    }
    return false;
}","public void test133139() throws Throwable {
    boolean boolean0 = ArrayUtils.isEmpty((double[]) null);
    assertTrue(boolean0);
}","/**
 * <p>Checks if an array of primitive doubles is empty or <code>null</code>.</p>
 *
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */"
"public static boolean isEmpty(double[] array) {
    if (array == null || array.length == 0) {
        return true;
    }
    return false;
}","public void test134140() throws Throwable {
    double[] doubleArray0 = new double[1];
    boolean boolean0 = ArrayUtils.isEmpty(doubleArray0);
    assertFalse(boolean0);
}","/**
 * <p>Checks if an array of primitive doubles is empty or <code>null</code>.</p>
 *
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */"
"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test135141() throws Throwable {
    boolean[] booleanArray0 = new boolean[2];
    int int0 = ArrayUtils.lastIndexOf(booleanArray0, false, 2286);
    assertEquals(1, int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than
 * the array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test136142() throws Throwable {
    boolean[] booleanArray0 = new boolean[2];
    booleanArray0[0] = true;
    int int0 = ArrayUtils.indexOf(booleanArray0, true, (-1903));
    assertEquals(0, int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code>
 *  array input
 */"
"public static int indexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test137143() throws Throwable {
    boolean[] booleanArray0 = new boolean[6];
    int int0 = ArrayUtils.indexOf(booleanArray0, false, 1881);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code>
 *  array input
 */"
"public static int indexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test138144() throws Throwable {
    int int0 = ArrayUtils.indexOf((boolean[]) null, false, (int) (short) (-1697));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code>
 *  array input
 */"
"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test139145() throws Throwable {
    float[] floatArray0 = new float[1];
    int int0 = ArrayUtils.lastIndexOf(floatArray0, (float) 48, 48);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test140146() throws Throwable {
    float[] floatArray0 = new float[0];
    int int0 = ArrayUtils.lastIndexOf(floatArray0, (float) (short) 2, (-1867));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test141147() throws Throwable {
    float[] floatArray0 = new float[8];
    floatArray0[4] = (float) (byte) 19;
    int int0 = ArrayUtils.indexOf(floatArray0, 19.0F, (int) (byte) 0);
    assertEquals(4, int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test142148() throws Throwable {
    float[] floatArray0 = new float[8];
    int int0 = ArrayUtils.indexOf(floatArray0, 19.0F, (int) (byte) 0);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test143149() throws Throwable {
    float[] floatArray0 = new float[0];
    int int0 = ArrayUtils.indexOf(floatArray0, (float) 1, 1);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test144150() throws Throwable {
    double[] doubleArray0 = new double[21];
    doubleArray0[1] = 2250.7;
    int int0 = ArrayUtils.lastIndexOf(doubleArray0, 938.37784, 1811, 1.0);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.
 * This method will return the index of the last value which falls between the region
 * defined by valueToFind - tolerance and valueToFind + tolerance.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @param tolerance  search for value within plus/minus this amount
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i < array.length; i++) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test145151() throws Throwable {
    double[] doubleArray0 = new double[7];
    int int0 = ArrayUtils.indexOf(doubleArray0, (-1753.527353), 2, (-674.23487837027));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.
 * This method will return the index of the first value which falls between the region
 * defined by valueToFind - tolerance and valueToFind + tolerance.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @param tolerance tolerance of the search
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test146152() throws Throwable {
    double[] doubleArray0 = new double[1];
    doubleArray0[0] = (-1.0);
    int int0 = ArrayUtils.indexOf(doubleArray0, (-1.0), 0);
    assertEquals(0, int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test147153() throws Throwable {
    double[] doubleArray0 = new double[1];
    int int0 = ArrayUtils.indexOf(doubleArray0, 435.264886227, 2168);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test148154() throws Throwable {
    int int0 = ArrayUtils.indexOf((double[]) null, 155.64351735, 48);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test149155() throws Throwable {
    byte[] byteArray0 = new byte[5];
    int int0 = ArrayUtils.lastIndexOf(byteArray0, (byte) 0, (int) (byte) 82);
    assertEquals(4, int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test150156() throws Throwable {
    byte[] byteArray0 = new byte[5];
    int int0 = ArrayUtils.lastIndexOf(byteArray0, (byte) 26, 5);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test151157() throws Throwable {
    byte[] byteArray0 = new byte[1];
    byteArray0[0] = (byte) 2;
    int int0 = ArrayUtils.indexOf(byteArray0, (byte) 0, (-3328));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test152158() throws Throwable {
    byte[] byteArray0 = new byte[4];
    int int0 = ArrayUtils.indexOf(byteArray0, (byte) (-109), (int) (byte) 68);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test153159() throws Throwable {
    char[] charArray0 = new char[5];
    int int0 = ArrayUtils.indexOf(charArray0, '2', 17);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 * @since 2.1
 */"
"public static int indexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test154160() throws Throwable {
    int int0 = ArrayUtils.indexOf((char[]) null, ' ', 2145847248);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 * @since 2.1
 */"
"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test155161() throws Throwable {
    int int0 = ArrayUtils.lastIndexOf((short[]) null, (short) 1960, (int) (short) 0);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test156162() throws Throwable {
    short[] shortArray0 = new short[5];
    shortArray0[1] = (short) 2;
    int int0 = ArrayUtils.indexOf(shortArray0, (short) (byte) 2, (-931));
    assertEquals(1, int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test157163() throws Throwable {
    short[] shortArray0 = new short[8];
    int int0 = ArrayUtils.indexOf(shortArray0, (short) 37, (int) (short) 539);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test158164() throws Throwable {
    int[] intArray0 = new int[5];
    int int0 = ArrayUtils.indexOf(intArray0, 58, (-2996));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test159165() throws Throwable {
    int[] intArray0 = new int[1];
    int int0 = ArrayUtils.indexOf(intArray0, 2735, 53);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test160166() throws Throwable {
    long[] longArray0 = new long[1];
    int int0 = ArrayUtils.indexOf(longArray0, (-1127L), 2145847248);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test161167() throws Throwable {
    int int0 = ArrayUtils.indexOf((long[]) null, (long) (-1), 2);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else if (array.getClass().getComponentType().isInstance(objectToFind)) {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}","public void test162168() throws Throwable {
    Object[] objectArray0 = new Object[2];
    Object object0 = new Object();
    objectArray0[0] = object0;
    int int0 = ArrayUtils.lastIndexOf(objectArray0, object0, 58);
    assertEquals(0, int0);
}","/**
 * <p>Finds the last index of the given object in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than
 * the array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param objectToFind  the object to find, may be <code>null</code>
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the object within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i < array.length; i++) {
            if (array[i] == null) {
                return i;
            }
        }
    } else if (array.getClass().getComponentType().isInstance(objectToFind)) {
        for (int i = startIndex; i < array.length; i++) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}","public void test163169() throws Throwable {
    Object[] objectArray0 = new Object[6];
    Object object0 = new Object();
    objectArray0[0] = object0;
    int int0 = ArrayUtils.indexOf(objectArray0, objectArray0[0], 548);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given object in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param objectToFind  the object to find, may be <code>null</code>
 * @param startIndex  the index to start searching at
 * @return the index of the object within the array starting at the index,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i < array.length; i++) {
            if (array[i] == null) {
                return i;
            }
        }
    } else if (array.getClass().getComponentType().isInstance(objectToFind)) {
        for (int i = startIndex; i < array.length; i++) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}","public void test164170() throws Throwable {
    Object[] objectArray0 = new Object[8];
    Object object0 = new Object();
    objectArray0[2] = object0;
    objectArray0[4] = objectArray0[2];
    int int0 = ArrayUtils.indexOf(objectArray0, objectArray0[4], 0);
    assertEquals(2, int0);
}","/**
 * <p>Finds the index of the given object in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param objectToFind  the object to find, may be <code>null</code>
 * @param startIndex  the index to start searching at
 * @return the index of the object within the array starting at the index,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i < array.length; i++) {
            if (array[i] == null) {
                return i;
            }
        }
    } else if (array.getClass().getComponentType().isInstance(objectToFind)) {
        for (int i = startIndex; i < array.length; i++) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}","public void test165171() throws Throwable {
    Object[] objectArray0 = new Object[8];
    int int0 = ArrayUtils.indexOf(objectArray0, objectArray0[4], 0);
    assertEquals(0, int0);
}","/**
 * <p>Finds the index of the given object in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param objectToFind  the object to find, may be <code>null</code>
 * @param startIndex  the index to start searching at
 * @return the index of the object within the array starting at the index,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i < array.length; i++) {
            if (array[i] == null) {
                return i;
            }
        }
    } else if (array.getClass().getComponentType().isInstance(objectToFind)) {
        for (int i = startIndex; i < array.length; i++) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}","public void test166172() throws Throwable {
    Integer integer0 = new Integer((-2141337091));
    int int0 = ArrayUtils.indexOf((Object[]) null, (Object) integer0, 2);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given object in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param objectToFind  the object to find, may be <code>null</code>
 * @param startIndex  the index to start searching at
 * @return the index of the object within the array starting at the index,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Returns the length of the specified array.
 * This method can deal with <code>Object</code> arrays and with primitive arrays.</p>
 *
 * <p>If the input array is <code>null</code>, <code>0</code> is returned.</p>
 *
 * <pre>
 * ArrayUtils.getLength(null)            = 0
 * ArrayUtils.getLength([])              = 0
 * ArrayUtils.getLength([null])          = 1
 * ArrayUtils.getLength([true, false])   = 2
 * ArrayUtils.getLength([1, 2, 3])       = 3
 * ArrayUtils.getLength([""a"", ""b"", ""c""]) = 3
 * </pre>
 *
 * @param array  the array to retrieve the length from, may be null
 * @return The length of the array, or <code>0</code> if the array is <code>null</code>
 * @throws IllegalArgumentException if the object arguement is not an array.
 * @since 2.1
 */
public static int getLength(Object array) {
    if (array == null) {
        return 0;
    }
    return Array.getLength(array);
}","public void test167173() throws Throwable {
    Object object0 = new Object();
    // Undeclared exception!
    try {
        ArrayUtils.getLength(object0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Argument is not an array
        //
        verifyException(""java.lang.reflect.Array"", e);
    }
}",""
"public static boolean[] clone(boolean[] array) {
    if (array == null) {
        return null;
    }
    return array.clone();
}","public void test168174() throws Throwable {
    boolean[] booleanArray0 = ArrayUtils.clone((boolean[]) null);
    assertNull(booleanArray0);
}","/**
 * <p>Clones an array returning a typecast result and handling
 * <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  the array to clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */"
"public static boolean[] clone(boolean[] array) {
    if (array == null) {
        return null;
    }
    return array.clone();
}","public void test169175() throws Throwable {
    boolean[] booleanArray0 = new boolean[0];
    boolean[] booleanArray1 = ArrayUtils.clone(booleanArray0);
    assertEquals(0, booleanArray1.length);
}","/**
 * <p>Clones an array returning a typecast result and handling
 * <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  the array to clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */"
"public static float[] clone(float[] array) {
    if (array == null) {
        return null;
    }
    return array.clone();
}","public void test170176() throws Throwable {
    float[] floatArray0 = ArrayUtils.clone((float[]) null);
    assertNull(floatArray0);
}","/**
 * <p>Clones an array returning a typecast result and handling
 * <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  the array to clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */"
"public static double[] clone(double[] array) {
    if (array == null) {
        return null;
    }
    return array.clone();
}","public void test171177() throws Throwable {
    double[] doubleArray0 = ArrayUtils.clone((double[]) null);
    assertNull(doubleArray0);
}","/**
 * <p>Clones an array returning a typecast result and handling
 * <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  the array to clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */"
"public static char[] clone(char[] array) {
    if (array == null) {
        return null;
    }
    return array.clone();
}","public void test172178() throws Throwable {
    char[] charArray0 = new char[0];
    char[] charArray1 = ArrayUtils.clone(charArray0);
    assertEquals(0, charArray1.length);
}","/**
 * <p>Clones an array returning a typecast result and handling
 * <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  the array to clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */"
"public static short[] clone(short[] array) {
    if (array == null) {
        return null;
    }
    return array.clone();
}","public void test173179() throws Throwable {
    short[] shortArray0 = ArrayUtils.clone((short[]) null);
    assertNull(shortArray0);
}","/**
 * <p>Clones an array returning a typecast result and handling
 * <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  the array to clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */"
"public static int[] clone(int[] array) {
    if (array == null) {
        return null;
    }
    return array.clone();
}","public void test174180() throws Throwable {
    int[] intArray0 = new int[5];
    int[] intArray1 = ArrayUtils.clone(intArray0);
    assertEquals(5, intArray1.length);
}","/**
 * <p>Clones an array returning a typecast result and handling
 * <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  the array to clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */"
"public static int[] clone(int[] array) {
    if (array == null) {
        return null;
    }
    return array.clone();
}","public void test175181() throws Throwable {
    int[] intArray0 = ArrayUtils.clone((int[]) null);
    assertNull(intArray0);
}","/**
 * <p>Clones an array returning a typecast result and handling
 * <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  the array to clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */"
"public static long[] clone(long[] array) {
    if (array == null) {
        return null;
    }
    return array.clone();
}","public void test176182() throws Throwable {
    long[] longArray0 = ArrayUtils.clone((long[]) null);
    assertNull(longArray0);
}","/**
 * <p>Clones an array returning a typecast result and handling
 * <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  the array to clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */"
"// Clone
//-----------------------------------------------------------------------
/**
 * <p>Shallow clones an array returning a typecast result and handling
 * <code>null</code>.</p>
 *
 * <p>The objects in the array are not cloned, thus there is no special
 * handling for multi-dimensional arrays.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  the array to shallow clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */
public static <T> T[] clone(T[] array) {
    if (array == null) {
        return null;
    }
    return array.clone();
}","public void test177183() throws Throwable {
    String[] stringArray0 = new String[8];
    String[] stringArray1 = ArrayUtils.clone(stringArray0);
    assertEquals(8, stringArray1.length);
}",""
"// Clone
//-----------------------------------------------------------------------
/**
 * <p>Shallow clones an array returning a typecast result and handling
 * <code>null</code>.</p>
 *
 * <p>The objects in the array are not cloned, thus there is no special
 * handling for multi-dimensional arrays.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  the array to shallow clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */
public static <T> T[] clone(T[] array) {
    if (array == null) {
        return null;
    }
    return array.clone();
}","public void test178184() throws Throwable {
    Object[] objectArray0 = ArrayUtils.clone((Object[]) null);
    assertNull(objectArray0);
}",""
"public static String toString(Object array, String stringIfNull) {
    if (array == null) {
        return stringIfNull;
    }
    return new ToStringBuilder(array, ToStringStyle.SIMPLE_STYLE).append(array).toString();
}","public void test179185() throws Throwable {
    int[] intArray0 = new int[4];
    String string0 = ArrayUtils.toString((Object) intArray0[1], ""', is neither of type Map.Entry nor an Array"");
    assertEquals(""0"", string0);
}","/**
 * <p>Outputs an array as a String handling <code>null</code>s.</p>
 *
 * <p>Multi-dimensional arrays are handled correctly, including
 * multi-dimensional primitive arrays.</p>
 *
 * <p>The format is that of Java source code, for example <code>{a,b}</code>.</p>
 *
 * @param array  the array to get a toString for, may be <code>null</code>
 * @param stringIfNull  the String to return if the array is <code>null</code>
 * @return a String representation of the array
 */"
"// float IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the index of the given value in the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */
public static int indexOf(float[] array, float valueToFind) {
    return indexOf(array, valueToFind, 0);
}","public void test180186() throws Throwable {
    float[] floatArray0 = new float[3];
    int int0 = ArrayUtils.indexOf(floatArray0, (-1.0F));
    assertEquals((-1), int0);
}",""
"// char IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the index of the given value in the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 * @since 2.1
 */
public static int indexOf(char[] array, char valueToFind) {
    return indexOf(array, valueToFind, 0);
}","public void test181187() throws Throwable {
    char[] charArray0 = new char[4];
    int int0 = ArrayUtils.indexOf(charArray0, 'y');
    assertEquals((-1), int0);
}",""
"public static float[] remove(float[] array, int index) {
    return (float[]) remove((Object) array, index);
}","public void test182188() throws Throwable {
    float[] floatArray0 = new float[1];
    // Undeclared exception!
    try {
        ArrayUtils.remove(floatArray0, (-77));
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // Index: -77, Length: 1
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}","/**
 * <p>Removes the element at the specified position from the specified array.
 * All subsequent elements are shifted to the left (substracts one from
 * their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException
 * will be thrown, because in that case no valid index can be specified.</p>
 *
 * <pre>
 * ArrayUtils.remove([1.1], 0)           = []
 * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]
 * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]
 * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]
 * </pre>
 *
 * @param array  the array to remove the element from, may not be <code>null</code>
 * @param index  the position of the element to be removed
 * @return A new array containing the existing elements except the element
 *         at the specified position.
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index >= array.length), or if the array is <code>null</code>.
 * @since 2.1
 */"
"public static byte[] remove(byte[] array, int index) {
    return (byte[]) remove((Object) array, index);
}","public void test183189() throws Throwable {
    byte[] byteArray0 = new byte[5];
    byte[] byteArray1 = ArrayUtils.remove(byteArray0, 0);
    assertEquals(4, byteArray1.length);
}","/**
 * <p>Removes the element at the specified position from the specified array.
 * All subsequent elements are shifted to the left (substracts one from
 * their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException
 * will be thrown, because in that case no valid index can be specified.</p>
 *
 * <pre>
 * ArrayUtils.remove([1], 0)          = []
 * ArrayUtils.remove([1, 0], 0)       = [0]
 * ArrayUtils.remove([1, 0], 1)       = [1]
 * ArrayUtils.remove([1, 0, 1], 1)    = [1, 1]
 * </pre>
 *
 * @param array  the array to remove the element from, may not be <code>null</code>
 * @param index  the position of the element to be removed
 * @return A new array containing the existing elements except the element
 *         at the specified position.
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index >= array.length), or if the array is <code>null</code>.
 * @since 2.1
 */"
"// boolean IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the index of the given value in the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */
public static int indexOf(boolean[] array, boolean valueToFind) {
    return indexOf(array, valueToFind, 0);
}","public void test184190() throws Throwable {
    int int0 = ArrayUtils.indexOf((boolean[]) null, true);
    assertEquals((-1), int0);
}",""
"public static double[] remove(double[] array, int index) {
    return (double[]) remove((Object) array, index);
}","public void test185191() throws Throwable {
    double[] doubleArray0 = new double[4];
    double[] doubleArray1 = ArrayUtils.remove(doubleArray0, 2);
    assertEquals(3, doubleArray1.length);
}","/**
 * <p>Removes the element at the specified position from the specified array.
 * All subsequent elements are shifted to the left (substracts one from
 * their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException
 * will be thrown, because in that case no valid index can be specified.</p>
 *
 * <pre>
 * ArrayUtils.remove([1.1], 0)           = []
 * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]
 * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]
 * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]
 * </pre>
 *
 * @param array  the array to remove the element from, may not be <code>null</code>
 * @param index  the position of the element to be removed
 * @return A new array containing the existing elements except the element
 *         at the specified position.
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index >= array.length), or if the array is <code>null</code>.
 * @since 2.1
 */"
"// long IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the index of the given value in the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */
public static int indexOf(long[] array, long valueToFind) {
    return indexOf(array, valueToFind, 0);
}","public void test186192() throws Throwable {
    long[] longArray0 = new long[4];
    int int0 = ArrayUtils.indexOf(longArray0, (-3L));
    assertEquals((-1), int0);
}",""
"public static short[] remove(short[] array, int index) {
    return (short[]) remove((Object) array, index);
}","public void test187193() throws Throwable {
    short[] shortArray0 = new short[3];
    short[] shortArray1 = ArrayUtils.remove(shortArray0, (int) (short) 2);
    assertEquals(2, shortArray1.length);
}","/**
 * <p>Removes the element at the specified position from the specified array.
 * All subsequent elements are shifted to the left (substracts one from
 * their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException
 * will be thrown, because in that case no valid index can be specified.</p>
 *
 * <pre>
 * ArrayUtils.remove([1], 0)         = []
 * ArrayUtils.remove([2, 6], 0)      = [6]
 * ArrayUtils.remove([2, 6], 1)      = [2]
 * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]
 * </pre>
 *
 * @param array  the array to remove the element from, may not be <code>null</code>
 * @param index  the position of the element to be removed
 * @return A new array containing the existing elements except the element
 *         at the specified position.
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index >= array.length), or if the array is <code>null</code>.
 * @since 2.1
 */"
"// int IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the index of the given value in the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */
public static int indexOf(int[] array, int valueToFind) {
    return indexOf(array, valueToFind, 0);
}","public void test188194() throws Throwable {
    int int0 = ArrayUtils.indexOf((int[]) null, Integer.MAX_VALUE);
    assertEquals((-1), int0);
}",""
"// double IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the index of the given value in the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */
public static int indexOf(double[] array, double valueToFind) {
    return indexOf(array, valueToFind, 0);
}","public void test189195() throws Throwable {
    double[] doubleArray0 = new double[4];
    int int0 = ArrayUtils.indexOf(doubleArray0, (double) (-1));
    assertEquals((-1), int0);
}",""
"// short IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the index of the given value in the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */
public static int indexOf(short[] array, short valueToFind) {
    return indexOf(array, valueToFind, 0);
}","public void test190196() throws Throwable {
    short[] shortArray0 = new short[5];
    int int0 = ArrayUtils.indexOf(shortArray0, (short) (-2811));
    assertEquals((-1), int0);
}",""
"// remove() always creates an array of the same type as its input
@SuppressWarnings(""unchecked"")
public static <T> T[] remove(T[] array, int index) {
    return (T[]) remove((Object) array, index);
}","public void test191197() throws Throwable {
    String[] stringArray0 = new String[8];
    String[] stringArray1 = ArrayUtils.remove(stringArray0, 1);
    assertEquals(7, stringArray1.length);
}","/**
 * <p>Removes the element at the specified position from the specified array.
 * All subsequent elements are shifted to the left (substracts one from
 * their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException
 * will be thrown, because in that case no valid index can be specified.</p>
 *
 * <pre>
 * ArrayUtils.remove([""a""], 0)           = []
 * ArrayUtils.remove([""a"", ""b""], 0)      = [""b""]
 * ArrayUtils.remove([""a"", ""b""], 1)      = [""a""]
 * ArrayUtils.remove([""a"", ""b"", ""c""], 1) = [""a"", ""c""]
 * </pre>
 *
 * @param array  the array to remove the element from, may not be <code>null</code>
 * @param index  the position of the element to be removed
 * @return A new array containing the existing elements except the element
 *         at the specified position.
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index >= array.length), or if the array is <code>null</code>.
 * @since 2.1
 */"
"public static int[] remove(int[] array, int index) {
    return (int[]) remove((Object) array, index);
}","public void test192198() throws Throwable {
    int[] intArray0 = new int[3];
    // Undeclared exception!
    try {
        ArrayUtils.remove(intArray0, (int) (byte) 64);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // Index: 64, Length: 3
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}","/**
 * <p>Removes the element at the specified position from the specified array.
 * All subsequent elements are shifted to the left (substracts one from
 * their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException
 * will be thrown, because in that case no valid index can be specified.</p>
 *
 * <pre>
 * ArrayUtils.remove([1], 0)         = []
 * ArrayUtils.remove([2, 6], 0)      = [6]
 * ArrayUtils.remove([2, 6], 1)      = [2]
 * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]
 * </pre>
 *
 * @param array  the array to remove the element from, may not be <code>null</code>
 * @param index  the position of the element to be removed
 * @return A new array containing the existing elements except the element
 *         at the specified position.
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index >= array.length), or if the array is <code>null</code>.
 * @since 2.1
 */"
"public static long[] removeElement(long[] array, long element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test193199() throws Throwable {
    long[] longArray0 = new long[6];
    long[] longArray1 = ArrayUtils.removeElement(longArray0, 0L);
    assertEquals(5, longArray1.length);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, 1)      = null
 * ArrayUtils.removeElement([], 1)        = []
 * ArrayUtils.removeElement([1], 2)       = [1]
 * ArrayUtils.removeElement([1, 3], 1)    = [3]
 * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"public static int[] removeElement(int[] array, int element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test194200() throws Throwable {
    int[] intArray0 = new int[7];
    intArray0[0] = 1;
    int[] intArray1 = ArrayUtils.removeElement(intArray0, 1);
    assertArrayEquals(new int[] { 1, 0, 0, 0, 0, 0, 0 }, intArray0);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, 1)      = null
 * ArrayUtils.removeElement([], 1)        = []
 * ArrayUtils.removeElement([1], 2)       = [1]
 * ArrayUtils.removeElement([1, 3], 1)    = [3]
 * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"public static double[] removeElement(double[] array, double element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test195202() throws Throwable {
    double[] doubleArray0 = new double[1];
    double[] doubleArray1 = ArrayUtils.removeElement(doubleArray0, 118.04661);
    assertEquals(1, doubleArray1.length);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, 1.1)            = null
 * ArrayUtils.removeElement([], 1.1)              = []
 * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]
 * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]
 * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"public static char[] removeElement(char[] array, char element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test196203() throws Throwable {
    char[] charArray0 = new char[8];
    charArray0[2] = 'A';
    char[] charArray1 = ArrayUtils.removeElement(charArray0, 'A');
    assertArrayEquals(new char[] { '\u0000', '\u0000', 'A', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000' }, charArray0);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, 'a')            = null
 * ArrayUtils.removeElement([], 'a')              = []
 * ArrayUtils.removeElement(['a'], 'b')           = ['a']
 * ArrayUtils.removeElement(['a', 'b'], 'a')      = ['b']
 * ArrayUtils.removeElement(['a', 'b', 'a'], 'a') = ['b', 'a']
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"public static byte[] removeElement(byte[] array, byte element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test197205() throws Throwable {
    ArrayUtils arrayUtils0 = new ArrayUtils();
    byte[] byteArray0 = ArrayUtils.removeElement(arrayUtils0.EMPTY_BYTE_ARRAY, (byte) 0);
    assertArrayEquals(new byte[] {}, byteArray0);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, 1)        = null
 * ArrayUtils.removeElement([], 1)          = []
 * ArrayUtils.removeElement([1], 0)         = [1]
 * ArrayUtils.removeElement([1, 0], 0)      = [1]
 * ArrayUtils.removeElement([1, 0, 1], 1)   = [0, 1]
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"public static long[] add(long[] array, int index, long element) {
    return (long[]) add(array, index, Long.valueOf(element), Long.TYPE);
}","public void test198206() throws Throwable {
    // Undeclared exception!
    try {
        ArrayUtils.add((long[]) null, 58, 1233L);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // Index: 58, Length: 0
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}","/**
 * <p>Inserts the specified element at the specified position in the array.
 * Shifts the element currently at that position (if any) and any subsequent
 * elements to the right (adds one to their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array plus the given element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element.</p>
 *
 * <pre>
 * ArrayUtils.add([1L], 0, 2L)           = [2L, 1L]
 * ArrayUtils.add([2L, 6L], 2, 10L)      = [2L, 6L, 10L]
 * ArrayUtils.add([2L, 6L], 0, -4L)      = [-4L, 2L, 6L]
 * ArrayUtils.add([2L, 6L, 3L], 2, 1L)   = [2L, 6L, 1L, 3L]
 * </pre>
 *
 * @param array  the array to add the element to, may be <code>null</code>
 * @param index  the position of the new object
 * @param element  the object to add
 * @return A new array containing the existing elements and the new element
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index > array.length).
 */"
"public static <T> T[] add(T[] array, int index, T element) {
    Class<?> clss = null;
    if (array != null) {
        clss = array.getClass().getComponentType();
    } else if (element != null) {
        clss = element.getClass();
    } else {
        return (T[]) new Object[] { null };
    }
    // the add method creates an array of type clss, which is type T
    @SuppressWarnings(""unchecked"")
    final T[] newArray = (T[]) add(array, index, element, clss);
    return newArray;
}","public void test199207() throws Throwable {
    Integer[] integerArray0 = new Integer[4];
    Integer integer0 = new Integer(1286);
    // Undeclared exception!
    try {
        ArrayUtils.add(integerArray0, 8, integer0);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // Index: 8, Length: 4
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}","/**
 * <p>Inserts the specified element at the specified position in the array.
 * Shifts the element currently at that position (if any) and any subsequent
 * elements to the right (adds one to their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array plus the given element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element.</p>
 *
 * <pre>
 * ArrayUtils.add(null, 0, null)      = [null]
 * ArrayUtils.add(null, 0, ""a"")       = [""a""]
 * ArrayUtils.add([""a""], 1, null)     = [""a"", null]
 * ArrayUtils.add([""a""], 1, ""b"")      = [""a"", ""b""]
 * ArrayUtils.add([""a"", ""b""], 3, ""c"") = [""a"", ""b"", ""c""]
 * </pre>
 *
 * @param array  the array to add the element to, may be <code>null</code>
 * @param index  the position of the new object
 * @param element  the object to add
 * @return A new array containing the existing elements and the new element
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index > array.length).
 * @throws IllegalArgumentException if both array and element are null
 */"
"public static <T> T[] add(T[] array, int index, T element) {
    Class<?> clss = null;
    if (array != null) {
        clss = array.getClass().getComponentType();
    } else if (element != null) {
        clss = element.getClass();
    } else {
        return (T[]) new Object[] { null };
    }
    // the add method creates an array of type clss, which is type T
    @SuppressWarnings(""unchecked"")
    final T[] newArray = (T[]) add(array, index, element, clss);
    return newArray;
}","public void test200208() throws Throwable {
    Integer integer0 = new Integer(2);
    Object[] objectArray0 = ArrayUtils.add((Object[]) null, 0, (Object) integer0);
    assertNotNull(objectArray0);
}","/**
 * <p>Inserts the specified element at the specified position in the array.
 * Shifts the element currently at that position (if any) and any subsequent
 * elements to the right (adds one to their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array plus the given element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element.</p>
 *
 * <pre>
 * ArrayUtils.add(null, 0, null)      = [null]
 * ArrayUtils.add(null, 0, ""a"")       = [""a""]
 * ArrayUtils.add([""a""], 1, null)     = [""a"", null]
 * ArrayUtils.add([""a""], 1, ""b"")      = [""a"", ""b""]
 * ArrayUtils.add([""a"", ""b""], 3, ""c"") = [""a"", ""b"", ""c""]
 * </pre>
 *
 * @param array  the array to add the element to, may be <code>null</code>
 * @param index  the position of the new object
 * @param element  the object to add
 * @return A new array containing the existing elements and the new element
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index > array.length).
 * @throws IllegalArgumentException if both array and element are null
 */"
"public static <T> T[] add(T[] array, T element) {
    Class<?> type;
    if (array != null) {
        type = array.getClass();
    } else if (element != null) {
        type = element.getClass();
    } else {
        type = Object.class;
    }
    // type must be T
    @SuppressWarnings(""unchecked"")
    T[] newArray = (T[]) copyArrayGrow1(array, type);
    newArray[newArray.length - 1] = element;
    return newArray;
}","public void test201210() throws Throwable {
    ArrayUtils arrayUtils0 = new ArrayUtils();
    String[] stringArray0 = ArrayUtils.add(arrayUtils0.EMPTY_STRING_ARRAY, ""Array element "");
    assertEquals(1, stringArray0.length);
}","/**
 * <p>Copies the given array and adds the given element at the end of the new array.</p>
 *
 * <p>The new array contains the same elements of the input
 * array plus the given element in the last position. The component type of
 * the new array is the same as that of the input array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element, unless the element itself is null,
 *  in which case the return type is Object[]</p>
 *
 * <pre>
 * ArrayUtils.add(null, null)      = [null]
 * ArrayUtils.add(null, ""a"")       = [""a""]
 * ArrayUtils.add([""a""], null)     = [""a"", null]
 * ArrayUtils.add([""a""], ""b"")      = [""a"", ""b""]
 * ArrayUtils.add([""a"", ""b""], ""c"") = [""a"", ""b"", ""c""]
 * </pre>
 *
 * @param array  the array to ""add"" the element to, may be <code>null</code>
 * @param element  the object to add, may be <code>null</code>
 * @return A new array containing the existing elements plus the new element
 * The returned array type will be that of the input array (unless null),
 * in which case it will have the same type as the element.
 * If both are null, an IllegalArgumentException is thrown
 * @since 2.1
 * @throws IllegalArgumentException if both arguments are null
 */"
"public static float[] addAll(float[] array1, float... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    float[] joinedArray = new float[array1.length + array2.length];
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    return joinedArray;
}","public void test202211() throws Throwable {
    float[] floatArray0 = ArrayUtils.addAll((float[]) null, (float[]) null);
    assertNull(floatArray0);
}","/**
 * <p>Adds all the elements of the given arrays into a new array.</p>
 * <p>The new array contains all of the element of <code>array1</code> followed
 * by all of the elements <code>array2</code>. When an array is returned, it is always
 * a new array.</p>
 *
 * <pre>
 * ArrayUtils.addAll(array1, null)   = cloned copy of array1
 * ArrayUtils.addAll(null, array2)   = cloned copy of array2
 * ArrayUtils.addAll([], [])         = []
 * </pre>
 *
 * @param array1  the first array whose elements are added to the new array.
 * @param array2  the second array whose elements are added to the new array.
 * @return The new float[] array.
 * @since 2.1
 */"
"public static float[] addAll(float[] array1, float... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    float[] joinedArray = new float[array1.length + array2.length];
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    return joinedArray;
}","public void test203212() throws Throwable {
    float[] floatArray0 = new float[3];
    float[] floatArray1 = ArrayUtils.addAll(floatArray0, floatArray0);
    assertEquals(6, floatArray1.length);
}","/**
 * <p>Adds all the elements of the given arrays into a new array.</p>
 * <p>The new array contains all of the element of <code>array1</code> followed
 * by all of the elements <code>array2</code>. When an array is returned, it is always
 * a new array.</p>
 *
 * <pre>
 * ArrayUtils.addAll(array1, null)   = cloned copy of array1
 * ArrayUtils.addAll(null, array2)   = cloned copy of array2
 * ArrayUtils.addAll([], [])         = []
 * </pre>
 *
 * @param array1  the first array whose elements are added to the new array.
 * @param array2  the second array whose elements are added to the new array.
 * @return The new float[] array.
 * @since 2.1
 */"
"public static long[] addAll(long[] array1, long... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    long[] joinedArray = new long[array1.length + array2.length];
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    return joinedArray;
}","public void test204213() throws Throwable {
    long[] longArray0 = ArrayUtils.addAll((long[]) null, (long[]) null);
    assertNull(longArray0);
}","/**
 * <p>Adds all the elements of the given arrays into a new array.</p>
 * <p>The new array contains all of the element of <code>array1</code> followed
 * by all of the elements <code>array2</code>. When an array is returned, it is always
 * a new array.</p>
 *
 * <pre>
 * ArrayUtils.addAll(array1, null)   = cloned copy of array1
 * ArrayUtils.addAll(null, array2)   = cloned copy of array2
 * ArrayUtils.addAll([], [])         = []
 * </pre>
 *
 * @param array1  the first array whose elements are added to the new array.
 * @param array2  the second array whose elements are added to the new array.
 * @return The new long[] array.
 * @since 2.1
 */"
"public static long[] addAll(long[] array1, long... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    long[] joinedArray = new long[array1.length + array2.length];
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    return joinedArray;
}","public void test205214() throws Throwable {
    long[] longArray0 = new long[5];
    long[] longArray1 = ArrayUtils.addAll(longArray0, longArray0);
    assertEquals(10, longArray1.length);
}","/**
 * <p>Adds all the elements of the given arrays into a new array.</p>
 * <p>The new array contains all of the element of <code>array1</code> followed
 * by all of the elements <code>array2</code>. When an array is returned, it is always
 * a new array.</p>
 *
 * <pre>
 * ArrayUtils.addAll(array1, null)   = cloned copy of array1
 * ArrayUtils.addAll(null, array2)   = cloned copy of array2
 * ArrayUtils.addAll([], [])         = []
 * </pre>
 *
 * @param array1  the first array whose elements are added to the new array.
 * @param array2  the second array whose elements are added to the new array.
 * @return The new long[] array.
 * @since 2.1
 */"
"public static int[] addAll(int[] array1, int... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    int[] joinedArray = new int[array1.length + array2.length];
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    return joinedArray;
}","public void test206215() throws Throwable {
    int[] intArray0 = new int[8];
    int[] intArray1 = ArrayUtils.addAll(intArray0, intArray0);
    assertEquals(16, intArray1.length);
}","/**
 * <p>Adds all the elements of the given arrays into a new array.</p>
 * <p>The new array contains all of the element of <code>array1</code> followed
 * by all of the elements <code>array2</code>. When an array is returned, it is always
 * a new array.</p>
 *
 * <pre>
 * ArrayUtils.addAll(array1, null)   = cloned copy of array1
 * ArrayUtils.addAll(null, array2)   = cloned copy of array2
 * ArrayUtils.addAll([], [])         = []
 * </pre>
 *
 * @param array1  the first array whose elements are added to the new array.
 * @param array2  the second array whose elements are added to the new array.
 * @return The new int[] array.
 * @since 2.1
 */"
"public static short[] addAll(short[] array1, short... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    short[] joinedArray = new short[array1.length + array2.length];
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    return joinedArray;
}","public void test207216() throws Throwable {
    short[] shortArray0 = new short[1];
    short[] shortArray1 = ArrayUtils.addAll(shortArray0, shortArray0);
    assertEquals(2, shortArray1.length);
}","/**
 * <p>Adds all the elements of the given arrays into a new array.</p>
 * <p>The new array contains all of the element of <code>array1</code> followed
 * by all of the elements <code>array2</code>. When an array is returned, it is always
 * a new array.</p>
 *
 * <pre>
 * ArrayUtils.addAll(array1, null)   = cloned copy of array1
 * ArrayUtils.addAll(null, array2)   = cloned copy of array2
 * ArrayUtils.addAll([], [])         = []
 * </pre>
 *
 * @param array1  the first array whose elements are added to the new array.
 * @param array2  the second array whose elements are added to the new array.
 * @return The new short[] array.
 * @since 2.1
 */"
"public static byte[] addAll(byte[] array1, byte... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    byte[] joinedArray = new byte[array1.length + array2.length];
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    return joinedArray;
}","public void test208217() throws Throwable {
    byte[] byteArray0 = ArrayUtils.addAll((byte[]) null, (byte[]) null);
    assertNull(byteArray0);
}","/**
 * <p>Adds all the elements of the given arrays into a new array.</p>
 * <p>The new array contains all of the element of <code>array1</code> followed
 * by all of the elements <code>array2</code>. When an array is returned, it is always
 * a new array.</p>
 *
 * <pre>
 * ArrayUtils.addAll(array1, null)   = cloned copy of array1
 * ArrayUtils.addAll(null, array2)   = cloned copy of array2
 * ArrayUtils.addAll([], [])         = []
 * </pre>
 *
 * @param array1  the first array whose elements are added to the new array.
 * @param array2  the second array whose elements are added to the new array.
 * @return The new byte[] array.
 * @since 2.1
 */"
"public static byte[] addAll(byte[] array1, byte... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    byte[] joinedArray = new byte[array1.length + array2.length];
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    return joinedArray;
}","public void test209218() throws Throwable {
    byte[] byteArray0 = new byte[3];
    byte[] byteArray1 = ArrayUtils.addAll(byteArray0, byteArray0);
    assertEquals(6, byteArray1.length);
}","/**
 * <p>Adds all the elements of the given arrays into a new array.</p>
 * <p>The new array contains all of the element of <code>array1</code> followed
 * by all of the elements <code>array2</code>. When an array is returned, it is always
 * a new array.</p>
 *
 * <pre>
 * ArrayUtils.addAll(array1, null)   = cloned copy of array1
 * ArrayUtils.addAll(null, array2)   = cloned copy of array2
 * ArrayUtils.addAll([], [])         = []
 * </pre>
 *
 * @param array1  the first array whose elements are added to the new array.
 * @param array2  the second array whose elements are added to the new array.
 * @return The new byte[] array.
 * @since 2.1
 */"
"public static char[] addAll(char[] array1, char... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    char[] joinedArray = new char[array1.length + array2.length];
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    return joinedArray;
}","public void test210219() throws Throwable {
    char[] charArray0 = ArrayUtils.addAll((char[]) null, (char[]) null);
    assertNull(charArray0);
}","/**
 * <p>Adds all the elements of the given arrays into a new array.</p>
 * <p>The new array contains all of the element of <code>array1</code> followed
 * by all of the elements <code>array2</code>. When an array is returned, it is always
 * a new array.</p>
 *
 * <pre>
 * ArrayUtils.addAll(array1, null)   = cloned copy of array1
 * ArrayUtils.addAll(null, array2)   = cloned copy of array2
 * ArrayUtils.addAll([], [])         = []
 * </pre>
 *
 * @param array1  the first array whose elements are added to the new array.
 * @param array2  the second array whose elements are added to the new array.
 * @return The new char[] array.
 * @since 2.1
 */"
"public static boolean[] addAll(boolean[] array1, boolean... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    boolean[] joinedArray = new boolean[array1.length + array2.length];
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    return joinedArray;
}","public void test211220() throws Throwable {
    boolean[] booleanArray0 = ArrayUtils.addAll((boolean[]) null, (boolean[]) null);
    assertNull(booleanArray0);
}","/**
 * <p>Adds all the elements of the given arrays into a new array.</p>
 * <p>The new array contains all of the element of <code>array1</code> followed
 * by all of the elements <code>array2</code>. When an array is returned, it is always
 * a new array.</p>
 *
 * <pre>
 * ArrayUtils.addAll(array1, null)   = cloned copy of array1
 * ArrayUtils.addAll(null, array2)   = cloned copy of array2
 * ArrayUtils.addAll([], [])         = []
 * </pre>
 *
 * @param array1  the first array whose elements are added to the new array.
 * @param array2  the second array whose elements are added to the new array.
 * @return The new boolean[] array.
 * @since 2.1
 */"
"public static boolean[] addAll(boolean[] array1, boolean... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    boolean[] joinedArray = new boolean[array1.length + array2.length];
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    return joinedArray;
}","public void test212221() throws Throwable {
    boolean[] booleanArray0 = new boolean[3];
    boolean[] booleanArray1 = ArrayUtils.addAll(booleanArray0, booleanArray0);
    assertEquals(6, booleanArray1.length);
}","/**
 * <p>Adds all the elements of the given arrays into a new array.</p>
 * <p>The new array contains all of the element of <code>array1</code> followed
 * by all of the elements <code>array2</code>. When an array is returned, it is always
 * a new array.</p>
 *
 * <pre>
 * ArrayUtils.addAll(array1, null)   = cloned copy of array1
 * ArrayUtils.addAll(null, array2)   = cloned copy of array2
 * ArrayUtils.addAll([], [])         = []
 * </pre>
 *
 * @param array1  the first array whose elements are added to the new array.
 * @param array2  the second array whose elements are added to the new array.
 * @return The new boolean[] array.
 * @since 2.1
 */"
"public static <T> T[] addAll(T[] array1, T... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    final Class<?> type1 = array1.getClass().getComponentType();
    // OK, because array is of type T
    @SuppressWarnings(""unchecked"")
    T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    try {
        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    } catch (ArrayStoreException ase) {
        // Check if problem was due to incompatible types
        /*
             * We do this here, rather than before the copy because:
             * - it would be a wasted check most of the time
             * - safer, in case check turns out to be too strict
             */
        final Class<?> type2 = array2.getClass().getComponentType();
        if (!type1.isAssignableFrom(type2)) {
            throw new IllegalArgumentException(""Cannot store "" + type2.getName() + "" in an array of "" + type1.getName(), ase);
        }
        // No, so rethrow original
        throw ase;
    }
    return joinedArray;
}","public void test213222() throws Throwable {
    Double[] doubleArray0 = new Double[3];
    Object[] objectArray0 = ArrayUtils.addAll((Object[]) doubleArray0, (Object[]) null);
    assertNotNull(objectArray0);
}","/**
 * <p>Adds all the elements of the given arrays into a new array.</p>
 * <p>The new array contains all of the element of <code>array1</code> followed
 * by all of the elements <code>array2</code>. When an array is returned, it is always
 * a new array.</p>
 *
 * <pre>
 * ArrayUtils.addAll(null, null)     = null
 * ArrayUtils.addAll(array1, null)   = cloned copy of array1
 * ArrayUtils.addAll(null, array2)   = cloned copy of array2
 * ArrayUtils.addAll([], [])         = []
 * ArrayUtils.addAll([null], [null]) = [null, null]
 * ArrayUtils.addAll([""a"", ""b"", ""c""], [""1"", ""2"", ""3""]) = [""a"", ""b"", ""c"", ""1"", ""2"", ""3""]
 * </pre>
 *
 * @param array1  the first array whose elements are added to the new array, may be <code>null</code>
 * @param array2  the second array whose elements are added to the new array, may be <code>null</code>
 * @return The new array, <code>null</code> if both arrays are <code>null</code>.
 *      The type of the new array is the type of the first array,
 *      unless the first array is null, in which case the type is the same as the second array.
 * @since 2.1
 * @throws IllegalArgumentException if the array types are incompatible
 */"
"public static boolean contains(float[] array, float valueToFind) {
    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;
}","public void test214224() throws Throwable {
    float[] floatArray0 = new float[0];
    boolean boolean0 = ArrayUtils.contains(floatArray0, 1852.25F);
    assertFalse(boolean0);
}","/**
 * <p>Checks if the value is in the given array.</p>
 *
 * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>
 *
 * @param array  the array to search through
 * @param valueToFind  the value to find
 * @return <code>true</code> if the array contains the object
 */"
"public static boolean isEmpty(byte[] array) {
    if (array == null || array.length == 0) {
        return true;
    }
    return false;
}","public void test215225() throws Throwable {
    byte[] byteArray0 = new byte[0];
    boolean boolean0 = ArrayUtils.isEmpty(byteArray0);
    assertTrue(boolean0);
}","/**
 * <p>Checks if an array of primitive bytes is empty or <code>null</code>.</p>
 *
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */"
"public static boolean isEmpty(byte[] array) {
    if (array == null || array.length == 0) {
        return true;
    }
    return false;
}","public void test216226() throws Throwable {
    byte[] byteArray0 = new byte[5];
    boolean boolean0 = ArrayUtils.isEmpty(byteArray0);
    assertFalse(boolean0);
}","/**
 * <p>Checks if an array of primitive bytes is empty or <code>null</code>.</p>
 *
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */"
"public static boolean isEmpty(byte[] array) {
    if (array == null || array.length == 0) {
        return true;
    }
    return false;
}","public void test217227() throws Throwable {
    boolean boolean0 = ArrayUtils.isEmpty((byte[]) null);
    assertTrue(boolean0);
}","/**
 * <p>Checks if an array of primitive bytes is empty or <code>null</code>.</p>
 *
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */"
"public static boolean isEmpty(char[] array) {
    if (array == null || array.length == 0) {
        return true;
    }
    return false;
}","public void test218228() throws Throwable {
    char[] charArray0 = new char[7];
    boolean boolean0 = ArrayUtils.isEmpty(charArray0);
    assertFalse(boolean0);
}","/**
 * <p>Checks if an array of primitive chars is empty or <code>null</code>.</p>
 *
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */"
"public static boolean isEmpty(char[] array) {
    if (array == null || array.length == 0) {
        return true;
    }
    return false;
}","public void test219229() throws Throwable {
    ArrayUtils arrayUtils0 = new ArrayUtils();
    boolean boolean0 = ArrayUtils.isEmpty(arrayUtils0.EMPTY_CHAR_ARRAY);
    assertTrue(boolean0);
}","/**
 * <p>Checks if an array of primitive chars is empty or <code>null</code>.</p>
 *
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */"
"public static boolean isEmpty(char[] array) {
    if (array == null || array.length == 0) {
        return true;
    }
    return false;
}","public void test220230() throws Throwable {
    boolean boolean0 = ArrayUtils.isEmpty((char[]) null);
    assertTrue(boolean0);
}","/**
 * <p>Checks if an array of primitive chars is empty or <code>null</code>.</p>
 *
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */"
"public static boolean isEmpty(short[] array) {
    if (array == null || array.length == 0) {
        return true;
    }
    return false;
}","public void test221231() throws Throwable {
    short[] shortArray0 = new short[0];
    boolean boolean0 = ArrayUtils.isEmpty(shortArray0);
    assertTrue(boolean0);
}","/**
 * <p>Checks if an array of primitive shorts is empty or <code>null</code>.</p>
 *
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */"
"public static boolean isEmpty(short[] array) {
    if (array == null || array.length == 0) {
        return true;
    }
    return false;
}","public void test222232() throws Throwable {
    short[] shortArray0 = new short[7];
    boolean boolean0 = ArrayUtils.isEmpty(shortArray0);
    assertFalse(boolean0);
}","/**
 * <p>Checks if an array of primitive shorts is empty or <code>null</code>.</p>
 *
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */"
"public static boolean isEmpty(short[] array) {
    if (array == null || array.length == 0) {
        return true;
    }
    return false;
}","public void test223233() throws Throwable {
    boolean boolean0 = ArrayUtils.isEmpty((short[]) null);
    assertTrue(boolean0);
}","/**
 * <p>Checks if an array of primitive shorts is empty or <code>null</code>.</p>
 *
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */"
"public static boolean isEmpty(int[] array) {
    if (array == null || array.length == 0) {
        return true;
    }
    return false;
}","public void test224234() throws Throwable {
    int[] intArray0 = new int[6];
    boolean boolean0 = ArrayUtils.isEmpty(intArray0);
    assertFalse(boolean0);
}","/**
 * <p>Checks if an array of primitive ints is empty or <code>null</code>.</p>
 *
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */"
"public static boolean isEmpty(int[] array) {
    if (array == null || array.length == 0) {
        return true;
    }
    return false;
}","public void test225235() throws Throwable {
    int[] intArray0 = new int[0];
    boolean boolean0 = ArrayUtils.isEmpty(intArray0);
    assertTrue(boolean0);
}","/**
 * <p>Checks if an array of primitive ints is empty or <code>null</code>.</p>
 *
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */"
"public static boolean isEmpty(int[] array) {
    if (array == null || array.length == 0) {
        return true;
    }
    return false;
}","public void test226236() throws Throwable {
    boolean boolean0 = ArrayUtils.isEmpty((int[]) null);
    assertTrue(boolean0);
}","/**
 * <p>Checks if an array of primitive ints is empty or <code>null</code>.</p>
 *
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */"
"public static boolean isEmpty(long[] array) {
    if (array == null || array.length == 0) {
        return true;
    }
    return false;
}","public void test227237() throws Throwable {
    long[] longArray0 = new long[4];
    boolean boolean0 = ArrayUtils.isEmpty(longArray0);
    assertFalse(boolean0);
}","/**
 * <p>Checks if an array of primitive longs is empty or <code>null</code>.</p>
 *
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */"
"public static boolean isEmpty(long[] array) {
    if (array == null || array.length == 0) {
        return true;
    }
    return false;
}","public void test228238() throws Throwable {
    long[] longArray0 = new long[0];
    boolean boolean0 = ArrayUtils.isEmpty(longArray0);
    assertTrue(boolean0);
}","/**
 * <p>Checks if an array of primitive longs is empty or <code>null</code>.</p>
 *
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */"
"public static boolean isEmpty(long[] array) {
    if (array == null || array.length == 0) {
        return true;
    }
    return false;
}","public void test229239() throws Throwable {
    boolean boolean0 = ArrayUtils.isEmpty((long[]) null);
    assertTrue(boolean0);
}","/**
 * <p>Checks if an array of primitive longs is empty or <code>null</code>.</p>
 *
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */"
"// ----------------------------------------------------------------------
/**
 * <p>Checks if an array of Objects is empty or <code>null</code>.</p>
 *
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */
public static <T> boolean isEmpty(T[] array) {
    if (array == null || array.length == 0) {
        return true;
    }
    return false;
}","public void test230240() throws Throwable {
    String[] stringArray0 = new String[0];
    boolean boolean0 = ArrayUtils.isEmpty(stringArray0);
    assertTrue(boolean0);
}",""
"// ----------------------------------------------------------------------
/**
 * <p>Checks if an array of Objects is empty or <code>null</code>.</p>
 *
 * @param array  the array to test
 * @return <code>true</code> if the array is empty or <code>null</code>
 * @since 2.1
 */
public static <T> boolean isEmpty(T[] array) {
    if (array == null || array.length == 0) {
        return true;
    }
    return false;
}","public void test231241() throws Throwable {
    String[] stringArray0 = new String[8];
    boolean boolean0 = ArrayUtils.isEmpty(stringArray0);
    assertFalse(boolean0);
}",""
"public static Boolean[] toObject(boolean[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_BOOLEAN_OBJECT_ARRAY;
    }
    final Boolean[] result = new Boolean[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);
    }
    return result;
}","public void test232242() throws Throwable {
    boolean[] booleanArray0 = new boolean[7];
    booleanArray0[0] = true;
    Boolean[] booleanArray1 = ArrayUtils.toObject(booleanArray0);
    assertEquals(7, booleanArray1.length);
}","/**
 * <p>Converts an array of primitive booleans to objects.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>boolean</code> array
 * @return a <code>Boolean</code> array, <code>null</code> if null array input
 */"
"public static Boolean[] toObject(boolean[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_BOOLEAN_OBJECT_ARRAY;
    }
    final Boolean[] result = new Boolean[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);
    }
    return result;
}","public void test233243() throws Throwable {
    boolean[] booleanArray0 = new boolean[0];
    Boolean[] booleanArray1 = ArrayUtils.toObject(booleanArray0);
    assertEquals(0, booleanArray1.length);
}","/**
 * <p>Converts an array of primitive booleans to objects.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>boolean</code> array
 * @return a <code>Boolean</code> array, <code>null</code> if null array input
 */"
"public static Boolean[] toObject(boolean[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_BOOLEAN_OBJECT_ARRAY;
    }
    final Boolean[] result = new Boolean[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);
    }
    return result;
}","public void test234244() throws Throwable {
    Boolean[] booleanArray0 = ArrayUtils.toObject((boolean[]) null);
    assertNull(booleanArray0);
}","/**
 * <p>Converts an array of primitive booleans to objects.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>boolean</code> array
 * @return a <code>Boolean</code> array, <code>null</code> if null array input
 */"
"public static boolean[] toPrimitive(Boolean[] array, boolean valueForNull) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }
    final boolean[] result = new boolean[array.length];
    for (int i = 0; i < array.length; i++) {
        Boolean b = array[i];
        result[i] = (b == null ? valueForNull : b.booleanValue());
    }
    return result;
}","public void test237247() throws Throwable {
    boolean[] booleanArray0 = ArrayUtils.toPrimitive((Boolean[]) null, false);
    assertNull(booleanArray0);
}","/**
 * <p>Converts an array of object Booleans to primitives handling <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Boolean</code> array, may be <code>null</code>
 * @param valueForNull  the value to insert if <code>null</code> found
 * @return a <code>boolean</code> array, <code>null</code> if null array input
 */"
"// Boolean array converters
// ----------------------------------------------------------------------
/**
 * <p>Converts an array of object Booleans to primitives.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Boolean</code> array, may be <code>null</code>
 * @return a <code>boolean</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
public static boolean[] toPrimitive(Boolean[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }
    final boolean[] result = new boolean[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = array[i].booleanValue();
    }
    return result;
}","public void test238248() throws Throwable {
    Boolean[] booleanArray0 = new Boolean[0];
    boolean[] booleanArray1 = ArrayUtils.toPrimitive(booleanArray0);
    assertEquals(0, booleanArray1.length);
}",""
"// Boolean array converters
// ----------------------------------------------------------------------
/**
 * <p>Converts an array of object Booleans to primitives.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Boolean</code> array, may be <code>null</code>
 * @return a <code>boolean</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
public static boolean[] toPrimitive(Boolean[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }
    final boolean[] result = new boolean[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = array[i].booleanValue();
    }
    return result;
}","public void test239249() throws Throwable {
    boolean[] booleanArray0 = ArrayUtils.toPrimitive((Boolean[]) null);
    assertNull(booleanArray0);
}",""
"public static Float[] toObject(float[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_FLOAT_OBJECT_ARRAY;
    }
    final Float[] result = new Float[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = Float.valueOf(array[i]);
    }
    return result;
}","public void test240250() throws Throwable {
    float[] floatArray0 = new float[0];
    Float[] floatArray1 = ArrayUtils.toObject(floatArray0);
    assertEquals(0, floatArray1.length);
}","/**
 * <p>Converts an array of primitive floats to objects.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>float</code> array
 * @return a <code>Float</code> array, <code>null</code> if null array input
 */"
"public static float[] toPrimitive(Float[] array, float valueForNull) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_FLOAT_ARRAY;
    }
    final float[] result = new float[array.length];
    for (int i = 0; i < array.length; i++) {
        Float b = array[i];
        result[i] = (b == null ? valueForNull : b.floatValue());
    }
    return result;
}","public void test241251() throws Throwable {
    Float[] floatArray0 = new Float[7];
    Float float0 = new Float((float) 0);
    floatArray0[0] = float0;
    float[] floatArray1 = ArrayUtils.toPrimitive(floatArray0, (float) 0);
    assertArrayEquals(new float[] { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F }, floatArray1, 0.01F);
}","/**
 * <p>Converts an array of object Floats to primitives handling <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Float</code> array, may be <code>null</code>
 * @param valueForNull  the value to insert if <code>null</code> found
 * @return a <code>float</code> array, <code>null</code> if null array input
 */"
"public static float[] toPrimitive(Float[] array, float valueForNull) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_FLOAT_ARRAY;
    }
    final float[] result = new float[array.length];
    for (int i = 0; i < array.length; i++) {
        Float b = array[i];
        result[i] = (b == null ? valueForNull : b.floatValue());
    }
    return result;
}","public void test242252() throws Throwable {
    Float[] floatArray0 = new Float[0];
    float[] floatArray1 = ArrayUtils.toPrimitive(floatArray0, 0.0F);
    assertEquals(0, floatArray1.length);
}","/**
 * <p>Converts an array of object Floats to primitives handling <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Float</code> array, may be <code>null</code>
 * @param valueForNull  the value to insert if <code>null</code> found
 * @return a <code>float</code> array, <code>null</code> if null array input
 */"
"public static float[] toPrimitive(Float[] array, float valueForNull) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_FLOAT_ARRAY;
    }
    final float[] result = new float[array.length];
    for (int i = 0; i < array.length; i++) {
        Float b = array[i];
        result[i] = (b == null ? valueForNull : b.floatValue());
    }
    return result;
}","public void test243253() throws Throwable {
    float[] floatArray0 = ArrayUtils.toPrimitive((Float[]) null, (-1.0F));
    assertNull(floatArray0);
}","/**
 * <p>Converts an array of object Floats to primitives handling <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Float</code> array, may be <code>null</code>
 * @param valueForNull  the value to insert if <code>null</code> found
 * @return a <code>float</code> array, <code>null</code> if null array input
 */"
"//   Float array converters
// ----------------------------------------------------------------------
/**
 * <p>Converts an array of object Floats to primitives.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Float</code> array, may be <code>null</code>
 * @return a <code>float</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
public static float[] toPrimitive(Float[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_FLOAT_ARRAY;
    }
    final float[] result = new float[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = array[i].floatValue();
    }
    return result;
}","public void test244254() throws Throwable {
    Float[] floatArray0 = new Float[6];
    Float float0 = new Float((-1.0F));
    floatArray0[0] = float0;
    floatArray0[1] = float0;
    floatArray0[2] = floatArray0[0];
    floatArray0[3] = floatArray0[1];
    floatArray0[4] = float0;
    floatArray0[5] = float0;
    float[] floatArray1 = ArrayUtils.toPrimitive(floatArray0);
    assertNotNull(floatArray1);
}",""
"//   Float array converters
// ----------------------------------------------------------------------
/**
 * <p>Converts an array of object Floats to primitives.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Float</code> array, may be <code>null</code>
 * @return a <code>float</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
public static float[] toPrimitive(Float[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_FLOAT_ARRAY;
    }
    final float[] result = new float[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = array[i].floatValue();
    }
    return result;
}","public void test245256() throws Throwable {
    Float[] floatArray0 = new Float[9];
    // Undeclared exception!
    try {
        ArrayUtils.toPrimitive(floatArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}",""
"public static double[] toPrimitive(Double[] array, double valueForNull) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_DOUBLE_ARRAY;
    }
    final double[] result = new double[array.length];
    for (int i = 0; i < array.length; i++) {
        Double b = array[i];
        result[i] = (b == null ? valueForNull : b.doubleValue());
    }
    return result;
}","public void test246257() throws Throwable {
    Double[] doubleArray0 = new Double[12];
    Double double0 = new Double(0.0);
    doubleArray0[0] = double0;
    double[] doubleArray1 = ArrayUtils.toPrimitive(doubleArray0, 2552.4325229722544);
    assertEquals(12, doubleArray1.length);
}","/**
 * <p>Converts an array of object Doubles to primitives handling <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Double</code> array, may be <code>null</code>
 * @param valueForNull  the value to insert if <code>null</code> found
 * @return a <code>double</code> array, <code>null</code> if null array input
 */"
"public static double[] toPrimitive(Double[] array, double valueForNull) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_DOUBLE_ARRAY;
    }
    final double[] result = new double[array.length];
    for (int i = 0; i < array.length; i++) {
        Double b = array[i];
        result[i] = (b == null ? valueForNull : b.doubleValue());
    }
    return result;
}","public void test247258() throws Throwable {
    Double[] doubleArray0 = new Double[0];
    double[] doubleArray1 = ArrayUtils.toPrimitive(doubleArray0, 26.20243310753);
    assertEquals(0, doubleArray1.length);
}","/**
 * <p>Converts an array of object Doubles to primitives handling <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Double</code> array, may be <code>null</code>
 * @param valueForNull  the value to insert if <code>null</code> found
 * @return a <code>double</code> array, <code>null</code> if null array input
 */"
"public static double[] toPrimitive(Double[] array, double valueForNull) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_DOUBLE_ARRAY;
    }
    final double[] result = new double[array.length];
    for (int i = 0; i < array.length; i++) {
        Double b = array[i];
        result[i] = (b == null ? valueForNull : b.doubleValue());
    }
    return result;
}","public void test248259() throws Throwable {
    double[] doubleArray0 = ArrayUtils.toPrimitive((Double[]) null, 457.141);
    assertNull(doubleArray0);
}","/**
 * <p>Converts an array of object Doubles to primitives handling <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Double</code> array, may be <code>null</code>
 * @param valueForNull  the value to insert if <code>null</code> found
 * @return a <code>double</code> array, <code>null</code> if null array input
 */"
"// Double array converters
// ----------------------------------------------------------------------
/**
 * <p>Converts an array of object Doubles to primitives.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Double</code> array, may be <code>null</code>
 * @return a <code>double</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
public static double[] toPrimitive(Double[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_DOUBLE_ARRAY;
    }
    final double[] result = new double[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = array[i].doubleValue();
    }
    return result;
}","public void test249260() throws Throwable {
    Double[] doubleArray0 = new Double[1];
    doubleArray0[0] = (Double) (-1.0);
    double[] doubleArray1 = ArrayUtils.toPrimitive(doubleArray0);
    assertArrayEquals(new double[] { (-1.0) }, doubleArray1, 0.01);
}",""
"// Double array converters
// ----------------------------------------------------------------------
/**
 * <p>Converts an array of object Doubles to primitives.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Double</code> array, may be <code>null</code>
 * @return a <code>double</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
public static double[] toPrimitive(Double[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_DOUBLE_ARRAY;
    }
    final double[] result = new double[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = array[i].doubleValue();
    }
    return result;
}","public void test250261() throws Throwable {
    double[] doubleArray0 = ArrayUtils.toPrimitive((Double[]) null);
    assertNull(doubleArray0);
}",""
"// Double array converters
// ----------------------------------------------------------------------
/**
 * <p>Converts an array of object Doubles to primitives.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Double</code> array, may be <code>null</code>
 * @return a <code>double</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
public static double[] toPrimitive(Double[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_DOUBLE_ARRAY;
    }
    final double[] result = new double[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = array[i].doubleValue();
    }
    return result;
}","public void test251262() throws Throwable {
    Double[] doubleArray0 = new Double[1];
    // Undeclared exception!
    try {
        ArrayUtils.toPrimitive(doubleArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}",""
"public static Byte[] toObject(byte[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_BYTE_OBJECT_ARRAY;
    }
    final Byte[] result = new Byte[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = Byte.valueOf(array[i]);
    }
    return result;
}","public void test252263() throws Throwable {
    byte[] byteArray0 = new byte[7];
    Byte[] byteArray1 = ArrayUtils.toObject(byteArray0);
    assertEquals(7, byteArray1.length);
}","/**
 * <p>Converts an array of primitive bytes to objects.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>byte</code> array
 * @return a <code>Byte</code> array, <code>null</code> if null array input
 */"
"public static Byte[] toObject(byte[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_BYTE_OBJECT_ARRAY;
    }
    final Byte[] result = new Byte[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = Byte.valueOf(array[i]);
    }
    return result;
}","public void test253264() throws Throwable {
    Byte[] byteArray0 = ArrayUtils.toObject((byte[]) null);
    assertNull(byteArray0);
}","/**
 * <p>Converts an array of primitive bytes to objects.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>byte</code> array
 * @return a <code>Byte</code> array, <code>null</code> if null array input
 */"
"public static byte[] toPrimitive(Byte[] array, byte valueForNull) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_BYTE_ARRAY;
    }
    final byte[] result = new byte[array.length];
    for (int i = 0; i < array.length; i++) {
        Byte b = array[i];
        result[i] = (b == null ? valueForNull : b.byteValue());
    }
    return result;
}","public void test254265() throws Throwable {
    Byte[] byteArray0 = new Byte[3];
    Byte byte0 = new Byte((byte) 120);
    byteArray0[0] = byte0;
    byte[] byteArray1 = ArrayUtils.toPrimitive(byteArray0, (byte) 0);
    assertArrayEquals(new byte[] { (byte) 120, (byte) 0, (byte) 0 }, byteArray1);
}","/**
 * <p>Converts an array of object Bytes to primitives handling <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Byte</code> array, may be <code>null</code>
 * @param valueForNull  the value to insert if <code>null</code> found
 * @return a <code>byte</code> array, <code>null</code> if null array input
 */"
"public static byte[] toPrimitive(Byte[] array, byte valueForNull) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_BYTE_ARRAY;
    }
    final byte[] result = new byte[array.length];
    for (int i = 0; i < array.length; i++) {
        Byte b = array[i];
        result[i] = (b == null ? valueForNull : b.byteValue());
    }
    return result;
}","public void test255266() throws Throwable {
    ArrayUtils arrayUtils0 = new ArrayUtils();
    byte[] byteArray0 = ArrayUtils.toPrimitive(arrayUtils0.EMPTY_BYTE_OBJECT_ARRAY, (byte) 66);
    assertArrayEquals(new byte[] {}, byteArray0);
}","/**
 * <p>Converts an array of object Bytes to primitives handling <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Byte</code> array, may be <code>null</code>
 * @param valueForNull  the value to insert if <code>null</code> found
 * @return a <code>byte</code> array, <code>null</code> if null array input
 */"
"public static byte[] toPrimitive(Byte[] array, byte valueForNull) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_BYTE_ARRAY;
    }
    final byte[] result = new byte[array.length];
    for (int i = 0; i < array.length; i++) {
        Byte b = array[i];
        result[i] = (b == null ? valueForNull : b.byteValue());
    }
    return result;
}","public void test256267() throws Throwable {
    byte[] byteArray0 = ArrayUtils.toPrimitive((Byte[]) null, (byte) 5);
    assertNull(byteArray0);
}","/**
 * <p>Converts an array of object Bytes to primitives handling <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Byte</code> array, may be <code>null</code>
 * @param valueForNull  the value to insert if <code>null</code> found
 * @return a <code>byte</code> array, <code>null</code> if null array input
 */"
"// Byte array converters
// ----------------------------------------------------------------------
/**
 * <p>Converts an array of object Bytes to primitives.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Byte</code> array, may be <code>null</code>
 * @return a <code>byte</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
public static byte[] toPrimitive(Byte[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_BYTE_ARRAY;
    }
    final byte[] result = new byte[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = array[i].byteValue();
    }
    return result;
}","public void test257268() throws Throwable {
    Byte[] byteArray0 = new Byte[2];
    Byte byte0 = new Byte((byte) (-34));
    byteArray0[0] = byte0;
    byteArray0[1] = byte0;
    byte[] byteArray1 = ArrayUtils.toPrimitive(byteArray0);
    assertArrayEquals(new byte[] { (byte) (-34), (byte) (-34) }, byteArray1);
}",""
"// Byte array converters
// ----------------------------------------------------------------------
/**
 * <p>Converts an array of object Bytes to primitives.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Byte</code> array, may be <code>null</code>
 * @return a <code>byte</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
public static byte[] toPrimitive(Byte[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_BYTE_ARRAY;
    }
    final byte[] result = new byte[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = array[i].byteValue();
    }
    return result;
}","public void test258269() throws Throwable {
    byte[] byteArray0 = ArrayUtils.EMPTY_BYTE_ARRAY;
    Byte[] byteArray1 = ArrayUtils.toObject(byteArray0);
    byte[] byteArray2 = ArrayUtils.toPrimitive(byteArray1);
    assertSame(byteArray2, byteArray0);
}",""
"// Byte array converters
// ----------------------------------------------------------------------
/**
 * <p>Converts an array of object Bytes to primitives.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Byte</code> array, may be <code>null</code>
 * @return a <code>byte</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
public static byte[] toPrimitive(Byte[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_BYTE_ARRAY;
    }
    final byte[] result = new byte[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = array[i].byteValue();
    }
    return result;
}","public void test259271() throws Throwable {
    byte[] byteArray0 = ArrayUtils.toPrimitive((Byte[]) null);
    assertNull(byteArray0);
}",""
"// Byte array converters
// ----------------------------------------------------------------------
/**
 * <p>Converts an array of object Bytes to primitives.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Byte</code> array, may be <code>null</code>
 * @return a <code>byte</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
public static byte[] toPrimitive(Byte[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_BYTE_ARRAY;
    }
    final byte[] result = new byte[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = array[i].byteValue();
    }
    return result;
}","public void test260272() throws Throwable {
    Byte[] byteArray0 = new Byte[2];
    // Undeclared exception!
    try {
        ArrayUtils.toPrimitive(byteArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}",""
"public static Short[] toObject(short[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_SHORT_OBJECT_ARRAY;
    }
    final Short[] result = new Short[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = Short.valueOf(array[i]);
    }
    return result;
}","public void test261273() throws Throwable {
    short[] shortArray0 = new short[0];
    Short[] shortArray1 = ArrayUtils.toObject(shortArray0);
    assertEquals(0, shortArray1.length);
}","/**
 * <p>Converts an array of primitive shorts to objects.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>short</code> array
 * @return a <code>Short</code> array, <code>null</code> if null array input
 */"
"public static Short[] toObject(short[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_SHORT_OBJECT_ARRAY;
    }
    final Short[] result = new Short[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = Short.valueOf(array[i]);
    }
    return result;
}","public void test262274() throws Throwable {
    Short[] shortArray0 = ArrayUtils.toObject((short[]) null);
    assertNull(shortArray0);
}","/**
 * <p>Converts an array of primitive shorts to objects.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>short</code> array
 * @return a <code>Short</code> array, <code>null</code> if null array input
 */"
"public static Short[] toObject(short[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_SHORT_OBJECT_ARRAY;
    }
    final Short[] result = new Short[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = Short.valueOf(array[i]);
    }
    return result;
}","public void test263275() throws Throwable {
    short[] shortArray0 = new short[2];
    Short[] shortArray1 = ArrayUtils.toObject(shortArray0);
    assertNotNull(shortArray1);
}","/**
 * <p>Converts an array of primitive shorts to objects.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>short</code> array
 * @return a <code>Short</code> array, <code>null</code> if null array input
 */"
"public static short[] toPrimitive(Short[] array, short valueForNull) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_SHORT_ARRAY;
    }
    final short[] result = new short[array.length];
    for (int i = 0; i < array.length; i++) {
        Short b = array[i];
        result[i] = (b == null ? valueForNull : b.shortValue());
    }
    return result;
}","public void test264277() throws Throwable {
    Short[] shortArray0 = new Short[2];
    Short short0 = Short.decode(""6"");
    shortArray0[0] = short0;
    short[] shortArray1 = ArrayUtils.toPrimitive(shortArray0, (short) short0);
    assertArrayEquals(new short[] { (short) 6, (short) 6 }, shortArray1);
}","/**
 * <p>Converts an array of object Short to primitives handling <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Short</code> array, may be <code>null</code>
 * @param valueForNull  the value to insert if <code>null</code> found
 * @return a <code>byte</code> array, <code>null</code> if null array input
 */"
"public static short[] toPrimitive(Short[] array, short valueForNull) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_SHORT_ARRAY;
    }
    final short[] result = new short[array.length];
    for (int i = 0; i < array.length; i++) {
        Short b = array[i];
        result[i] = (b == null ? valueForNull : b.shortValue());
    }
    return result;
}","public void test265278() throws Throwable {
    short[] shortArray0 = ArrayUtils.toPrimitive((Short[]) null, (short) (byte) (-1));
    assertNull(shortArray0);
}","/**
 * <p>Converts an array of object Short to primitives handling <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Short</code> array, may be <code>null</code>
 * @param valueForNull  the value to insert if <code>null</code> found
 * @return a <code>byte</code> array, <code>null</code> if null array input
 */"
"// Short array converters
// ----------------------------------------------------------------------
/**
 * <p>Converts an array of object Shorts to primitives.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Short</code> array, may be <code>null</code>
 * @return a <code>byte</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
public static short[] toPrimitive(Short[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_SHORT_ARRAY;
    }
    final short[] result = new short[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = array[i].shortValue();
    }
    return result;
}","public void test266279() throws Throwable {
    Short[] shortArray0 = new Short[4];
    Short short0 = new Short((short) 26214);
    shortArray0[0] = short0;
    shortArray0[1] = short0;
    shortArray0[2] = short0;
    shortArray0[3] = short0;
    short[] shortArray1 = ArrayUtils.toPrimitive(shortArray0);
    assertNotNull(shortArray1);
}",""
"// Short array converters
// ----------------------------------------------------------------------
/**
 * <p>Converts an array of object Shorts to primitives.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Short</code> array, may be <code>null</code>
 * @return a <code>byte</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
public static short[] toPrimitive(Short[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_SHORT_ARRAY;
    }
    final short[] result = new short[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = array[i].shortValue();
    }
    return result;
}","public void test267281() throws Throwable {
    Short[] shortArray0 = new Short[0];
    short[] shortArray1 = ArrayUtils.toPrimitive(shortArray0);
    assertEquals(0, shortArray1.length);
}",""
"// Short array converters
// ----------------------------------------------------------------------
/**
 * <p>Converts an array of object Shorts to primitives.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Short</code> array, may be <code>null</code>
 * @return a <code>byte</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
public static short[] toPrimitive(Short[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_SHORT_ARRAY;
    }
    final short[] result = new short[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = array[i].shortValue();
    }
    return result;
}","public void test268282() throws Throwable {
    Short[] shortArray0 = new Short[4];
    // Undeclared exception!
    try {
        ArrayUtils.toPrimitive(shortArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}",""
"public static Integer[] toObject(int[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_INTEGER_OBJECT_ARRAY;
    }
    final Integer[] result = new Integer[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = Integer.valueOf(array[i]);
    }
    return result;
}","public void test269283() throws Throwable {
    int[] intArray0 = new int[0];
    Integer[] integerArray0 = ArrayUtils.toObject(intArray0);
    assertEquals(0, integerArray0.length);
}","/**
 * <p>Converts an array of primitive ints to objects.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  an <code>int</code> array
 * @return an <code>Integer</code> array, <code>null</code> if null array input
 */"
"public static Integer[] toObject(int[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_INTEGER_OBJECT_ARRAY;
    }
    final Integer[] result = new Integer[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = Integer.valueOf(array[i]);
    }
    return result;
}","public void test270284() throws Throwable {
    Integer[] integerArray0 = ArrayUtils.toObject((int[]) null);
    assertNull(integerArray0);
}","/**
 * <p>Converts an array of primitive ints to objects.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  an <code>int</code> array
 * @return an <code>Integer</code> array, <code>null</code> if null array input
 */"
"public static int[] toPrimitive(Integer[] array, int valueForNull) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_INT_ARRAY;
    }
    final int[] result = new int[array.length];
    for (int i = 0; i < array.length; i++) {
        Integer b = array[i];
        result[i] = (b == null ? valueForNull : b.intValue());
    }
    return result;
}","public void test271285() throws Throwable {
    Integer[] integerArray0 = new Integer[9];
    Integer integer0 = new Integer((-392));
    integerArray0[0] = integer0;
    int[] intArray0 = ArrayUtils.toPrimitive(integerArray0, 1);
    assertNotNull(intArray0);
}","/**
 * <p>Converts an array of object Integer to primitives handling <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Integer</code> array, may be <code>null</code>
 * @param valueForNull  the value to insert if <code>null</code> found
 * @return an <code>int</code> array, <code>null</code> if null array input
 */"
"public static int[] toPrimitive(Integer[] array, int valueForNull) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_INT_ARRAY;
    }
    final int[] result = new int[array.length];
    for (int i = 0; i < array.length; i++) {
        Integer b = array[i];
        result[i] = (b == null ? valueForNull : b.intValue());
    }
    return result;
}","public void test272287() throws Throwable {
    Integer[] integerArray0 = new Integer[0];
    int[] intArray0 = ArrayUtils.toPrimitive(integerArray0, (-851));
    assertEquals(0, intArray0.length);
}","/**
 * <p>Converts an array of object Integer to primitives handling <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Integer</code> array, may be <code>null</code>
 * @param valueForNull  the value to insert if <code>null</code> found
 * @return an <code>int</code> array, <code>null</code> if null array input
 */"
"// Int array converters
// ----------------------------------------------------------------------
/**
 * <p>Converts an array of object Integers to primitives.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Integer</code> array, may be <code>null</code>
 * @return an <code>int</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
public static int[] toPrimitive(Integer[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_INT_ARRAY;
    }
    final int[] result = new int[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = array[i].intValue();
    }
    return result;
}","public void test273288() throws Throwable {
    Integer[] integerArray0 = new Integer[0];
    int[] intArray0 = ArrayUtils.toPrimitive(integerArray0);
    assertEquals(0, intArray0.length);
}",""
"// Int array converters
// ----------------------------------------------------------------------
/**
 * <p>Converts an array of object Integers to primitives.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Integer</code> array, may be <code>null</code>
 * @return an <code>int</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
public static int[] toPrimitive(Integer[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_INT_ARRAY;
    }
    final int[] result = new int[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = array[i].intValue();
    }
    return result;
}","public void test274289() throws Throwable {
    int[] intArray0 = new int[8];
    Integer[] integerArray0 = ArrayUtils.toObject(intArray0);
    int[] intArray1 = ArrayUtils.toPrimitive(integerArray0);
    assertNotNull(intArray1);
}",""
"public static Long[] toObject(long[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_LONG_OBJECT_ARRAY;
    }
    final Long[] result = new Long[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = Long.valueOf(array[i]);
    }
    return result;
}","public void test275291() throws Throwable {
    ArrayUtils arrayUtils0 = new ArrayUtils();
    Long[] longArray0 = ArrayUtils.toObject(arrayUtils0.EMPTY_LONG_ARRAY);
    assertEquals(0, longArray0.length);
}","/**
 * <p>Converts an array of primitive longs to objects.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>long</code> array
 * @return a <code>Long</code> array, <code>null</code> if null array input
 */"
"public static Long[] toObject(long[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_LONG_OBJECT_ARRAY;
    }
    final Long[] result = new Long[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = Long.valueOf(array[i]);
    }
    return result;
}","public void test276292() throws Throwable {
    Long[] longArray0 = ArrayUtils.toObject((long[]) null);
    assertNull(longArray0);
}","/**
 * <p>Converts an array of primitive longs to objects.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>long</code> array
 * @return a <code>Long</code> array, <code>null</code> if null array input
 */"
"public static Long[] toObject(long[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_LONG_OBJECT_ARRAY;
    }
    final Long[] result = new Long[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = Long.valueOf(array[i]);
    }
    return result;
}","public void test277293() throws Throwable {
    long[] longArray0 = ArrayUtils.add((long[]) null, 0L);
    Long[] longArray1 = ArrayUtils.toObject(longArray0);
    assertNotNull(longArray1);
}","/**
 * <p>Converts an array of primitive longs to objects.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>long</code> array
 * @return a <code>Long</code> array, <code>null</code> if null array input
 */"
"public static long[] toPrimitive(Long[] array, long valueForNull) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_LONG_ARRAY;
    }
    final long[] result = new long[array.length];
    for (int i = 0; i < array.length; i++) {
        Long b = array[i];
        result[i] = (b == null ? valueForNull : b.longValue());
    }
    return result;
}","public void test278295() throws Throwable {
    Long[] longArray0 = new Long[0];
    long[] longArray1 = ArrayUtils.toPrimitive(longArray0, (-2360L));
    assertEquals(0, longArray1.length);
}","/**
 * <p>Converts an array of object Long to primitives handling <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Long</code> array, may be <code>null</code>
 * @param valueForNull  the value to insert if <code>null</code> found
 * @return a <code>long</code> array, <code>null</code> if null array input
 */"
"public static long[] toPrimitive(Long[] array, long valueForNull) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_LONG_ARRAY;
    }
    final long[] result = new long[array.length];
    for (int i = 0; i < array.length; i++) {
        Long b = array[i];
        result[i] = (b == null ? valueForNull : b.longValue());
    }
    return result;
}","public void test279296() throws Throwable {
    long[] longArray0 = ArrayUtils.toPrimitive((Long[]) null, 2465L);
    assertNull(longArray0);
}","/**
 * <p>Converts an array of object Long to primitives handling <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Long</code> array, may be <code>null</code>
 * @param valueForNull  the value to insert if <code>null</code> found
 * @return a <code>long</code> array, <code>null</code> if null array input
 */"
"public static long[] toPrimitive(Long[] array, long valueForNull) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_LONG_ARRAY;
    }
    final long[] result = new long[array.length];
    for (int i = 0; i < array.length; i++) {
        Long b = array[i];
        result[i] = (b == null ? valueForNull : b.longValue());
    }
    return result;
}","public void test280297() throws Throwable {
    Long[] longArray0 = new Long[1];
    Long long0 = new Long(375L);
    longArray0[0] = long0;
    long[] longArray1 = ArrayUtils.toPrimitive(longArray0, (long) longArray0[0]);
    assertArrayEquals(new long[] { 375L }, longArray1);
}","/**
 * <p>Converts an array of object Long to primitives handling <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Long</code> array, may be <code>null</code>
 * @param valueForNull  the value to insert if <code>null</code> found
 * @return a <code>long</code> array, <code>null</code> if null array input
 */"
"// Long array converters
// ----------------------------------------------------------------------
/**
 * <p>Converts an array of object Longs to primitives.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Long</code> array, may be <code>null</code>
 * @return a <code>long</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
public static long[] toPrimitive(Long[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_LONG_ARRAY;
    }
    final long[] result = new long[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = array[i].longValue();
    }
    return result;
}","public void test281299() throws Throwable {
    Long[] longArray0 = new Long[2];
    Long long0 = new Long(1L);
    longArray0[0] = long0;
    longArray0[1] = longArray0[0];
    long[] longArray1 = ArrayUtils.toPrimitive(longArray0);
    assertNotNull(longArray1);
}",""
"// Long array converters
// ----------------------------------------------------------------------
/**
 * <p>Converts an array of object Longs to primitives.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Long</code> array, may be <code>null</code>
 * @return a <code>long</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
public static long[] toPrimitive(Long[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_LONG_ARRAY;
    }
    final long[] result = new long[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = array[i].longValue();
    }
    return result;
}","public void test282301() throws Throwable {
    Long[] longArray0 = new Long[0];
    long[] longArray1 = ArrayUtils.toPrimitive(longArray0);
    assertEquals(0, longArray1.length);
}",""
"// Long array converters
// ----------------------------------------------------------------------
/**
 * <p>Converts an array of object Longs to primitives.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Long</code> array, may be <code>null</code>
 * @return a <code>long</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
public static long[] toPrimitive(Long[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_LONG_ARRAY;
    }
    final long[] result = new long[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = array[i].longValue();
    }
    return result;
}","public void test283302() throws Throwable {
    Long[] longArray0 = new Long[2];
    // Undeclared exception!
    try {
        ArrayUtils.toPrimitive(longArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}",""
"public static Character[] toObject(char[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_CHARACTER_OBJECT_ARRAY;
    }
    final Character[] result = new Character[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = Character.valueOf(array[i]);
    }
    return result;
}","public void test284303() throws Throwable {
    ArrayUtils arrayUtils0 = new ArrayUtils();
    Character[] characterArray0 = ArrayUtils.toObject(arrayUtils0.EMPTY_CHAR_ARRAY);
    assertEquals(0, characterArray0.length);
}","/**
 * <p>Converts an array of primitive chars to objects.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array a <code>char</code> array
 * @return a <code>Character</code> array, <code>null</code> if null array input
 */"
"public static Character[] toObject(char[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_CHARACTER_OBJECT_ARRAY;
    }
    final Character[] result = new Character[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = Character.valueOf(array[i]);
    }
    return result;
}","public void test285304() throws Throwable {
    Character[] characterArray0 = ArrayUtils.toObject((char[]) null);
    assertNull(characterArray0);
}","/**
 * <p>Converts an array of primitive chars to objects.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array a <code>char</code> array
 * @return a <code>Character</code> array, <code>null</code> if null array input
 */"
"public static char[] toPrimitive(Character[] array, char valueForNull) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_CHAR_ARRAY;
    }
    final char[] result = new char[array.length];
    for (int i = 0; i < array.length; i++) {
        Character b = array[i];
        result[i] = (b == null ? valueForNull : b.charValue());
    }
    return result;
}","public void test286305() throws Throwable {
    Character[] characterArray0 = new Character[2];
    Character character0 = new Character('`');
    characterArray0[0] = character0;
    char[] charArray0 = ArrayUtils.toPrimitive(characterArray0, '&');
    assertArrayEquals(new char[] { '`', '&' }, charArray0);
}","/**
 * <p>Converts an array of object Character to primitives handling <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Character</code> array, may be <code>null</code>
 * @param valueForNull  the value to insert if <code>null</code> found
 * @return a <code>char</code> array, <code>null</code> if null array input
 */"
"public static char[] toPrimitive(Character[] array, char valueForNull) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_CHAR_ARRAY;
    }
    final char[] result = new char[array.length];
    for (int i = 0; i < array.length; i++) {
        Character b = array[i];
        result[i] = (b == null ? valueForNull : b.charValue());
    }
    return result;
}","public void test287306() throws Throwable {
    char[] charArray0 = ArrayUtils.toPrimitive((Character[]) null, 'a');
    assertNull(charArray0);
}","/**
 * <p>Converts an array of object Character to primitives handling <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Character</code> array, may be <code>null</code>
 * @param valueForNull  the value to insert if <code>null</code> found
 * @return a <code>char</code> array, <code>null</code> if null array input
 */"
"// Primitive/Object array converters
// ----------------------------------------------------------------------
// Character array converters
// ----------------------------------------------------------------------
/**
 * <p>Converts an array of object Characters to primitives.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Character</code> array, may be <code>null</code>
 * @return a <code>char</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
public static char[] toPrimitive(Character[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_CHAR_ARRAY;
    }
    final char[] result = new char[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = array[i].charValue();
    }
    return result;
}","public void test288307() throws Throwable {
    Character[] characterArray0 = new Character[1];
    characterArray0[0] = (Character) 'G';
    char[] charArray0 = ArrayUtils.toPrimitive(characterArray0);
    assertArrayEquals(new char[] { 'G' }, charArray0);
}",""
"// Primitive/Object array converters
// ----------------------------------------------------------------------
// Character array converters
// ----------------------------------------------------------------------
/**
 * <p>Converts an array of object Characters to primitives.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Character</code> array, may be <code>null</code>
 * @return a <code>char</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
public static char[] toPrimitive(Character[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_CHAR_ARRAY;
    }
    final char[] result = new char[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = array[i].charValue();
    }
    return result;
}","public void test289308() throws Throwable {
    Character[] characterArray0 = new Character[0];
    char[] charArray0 = ArrayUtils.toPrimitive(characterArray0);
    assertEquals(0, charArray0.length);
}",""
"// Primitive/Object array converters
// ----------------------------------------------------------------------
// Character array converters
// ----------------------------------------------------------------------
/**
 * <p>Converts an array of object Characters to primitives.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Character</code> array, may be <code>null</code>
 * @return a <code>char</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
public static char[] toPrimitive(Character[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_CHAR_ARRAY;
    }
    final char[] result = new char[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = array[i].charValue();
    }
    return result;
}","public void test290309() throws Throwable {
    char[] charArray0 = ArrayUtils.toPrimitive((Character[]) null);
    assertNull(charArray0);
}",""
"// Primitive/Object array converters
// ----------------------------------------------------------------------
// Character array converters
// ----------------------------------------------------------------------
/**
 * <p>Converts an array of object Characters to primitives.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>Character</code> array, may be <code>null</code>
 * @return a <code>char</code> array, <code>null</code> if null array input
 * @throws NullPointerException if array content is <code>null</code>
 */
public static char[] toPrimitive(Character[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_CHAR_ARRAY;
    }
    final char[] result = new char[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = array[i].charValue();
    }
    return result;
}","public void test291310() throws Throwable {
    Character[] characterArray0 = new Character[1];
    // Undeclared exception!
    try {
        ArrayUtils.toPrimitive(characterArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}",""
"public static boolean contains(boolean[] array, boolean valueToFind) {
    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;
}","public void test292311() throws Throwable {
    boolean[] booleanArray0 = new boolean[5];
    boolean boolean0 = ArrayUtils.contains(booleanArray0, false);
    assertTrue(boolean0);
}","/**
 * <p>Checks if the value is in the given array.</p>
 *
 * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>
 *
 * @param array  the array to search through
 * @param valueToFind  the value to find
 * @return <code>true</code> if the array contains the object
 */"
"public static boolean contains(boolean[] array, boolean valueToFind) {
    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;
}","public void test293312() throws Throwable {
    boolean[] booleanArray0 = new boolean[0];
    boolean boolean0 = ArrayUtils.contains(booleanArray0, true);
    assertFalse(boolean0);
}","/**
 * <p>Checks if the value is in the given array.</p>
 *
 * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>
 *
 * @param array  the array to search through
 * @param valueToFind  the value to find
 * @return <code>true</code> if the array contains the object
 */"
"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test294313() throws Throwable {
    boolean[] booleanArray0 = new boolean[7];
    booleanArray0[0] = true;
    booleanArray0[1] = true;
    booleanArray0[2] = true;
    booleanArray0[3] = true;
    int int0 = ArrayUtils.lastIndexOf(booleanArray0, false, 3);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than
 * the array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test295314() throws Throwable {
    boolean[] booleanArray0 = new boolean[2];
    int int0 = ArrayUtils.lastIndexOf(booleanArray0, false, (-3397));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than
 * the array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test296315() throws Throwable {
    int int0 = ArrayUtils.lastIndexOf((boolean[]) null, false, 118);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than
 * the array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(boolean[] array, boolean valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test297316() throws Throwable {
    boolean[] booleanArray0 = new boolean[2];
    int int0 = ArrayUtils.indexOf(booleanArray0, true, (-1903));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code>
 *  array input
 */"
"public static boolean contains(float[] array, float valueToFind) {
    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;
}","public void test298317() throws Throwable {
    float[] floatArray0 = new float[5];
    floatArray0[3] = (float) (short) (-1);
    boolean boolean0 = ArrayUtils.contains(floatArray0, (-1.0F));
    assertTrue(boolean0);
}","/**
 * <p>Checks if the value is in the given array.</p>
 *
 * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>
 *
 * @param array  the array to search through
 * @param valueToFind  the value to find
 * @return <code>true</code> if the array contains the object
 */"
"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test299318() throws Throwable {
    float[] floatArray0 = new float[7];
    int int0 = ArrayUtils.lastIndexOf(floatArray0, (-1152.65F), 2);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test300319() throws Throwable {
    float[] floatArray0 = new float[4];
    int int0 = ArrayUtils.lastIndexOf(floatArray0, 0.0F, (-943));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(float[] array, float valueToFind) {
    return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
}","public void test301320() throws Throwable {
    int int0 = ArrayUtils.lastIndexOf((float[]) null, (float) (byte) 64);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value within the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to travers backwords looking for the object, may be <code>null</code>
 * @param valueToFind  the object to find
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(float[] array, float valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test302321() throws Throwable {
    float[] floatArray0 = new float[4];
    int int0 = ArrayUtils.indexOf(floatArray0, 3301.3457F, (-3067));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static boolean contains(double[] array, double valueToFind, double tolerance) {
    return indexOf(array, valueToFind, 0, tolerance) != INDEX_NOT_FOUND;
}","public void test303322() throws Throwable {
    double[] doubleArray0 = new double[9];
    doubleArray0[4] = (double) (short) 2168;
    boolean boolean0 = ArrayUtils.contains(doubleArray0, 2168.0, (double) 4);
    assertTrue(boolean0);
}","/**
 * <p>Checks if a value falling within the given tolerance is in the
 * given array.  If the array contains a value within the inclusive range
 * defined by (value - tolerance) to (value + tolerance).</p>
 *
 * <p>The method returns <code>false</code> if a <code>null</code> array
 * is passed in.</p>
 *
 * @param array  the array to search
 * @param valueToFind  the value to find
 * @param tolerance  the array contains the tolerance of the search
 * @return true if value falling within tolerance is in array
 */"
"public static boolean contains(double[] array, double valueToFind, double tolerance) {
    return indexOf(array, valueToFind, 0, tolerance) != INDEX_NOT_FOUND;
}","public void test304323() throws Throwable {
    double[] doubleArray0 = new double[8];
    boolean boolean0 = ArrayUtils.contains(doubleArray0, (double) (short) 26214, 939.37784);
    assertFalse(boolean0);
}","/**
 * <p>Checks if a value falling within the given tolerance is in the
 * given array.  If the array contains a value within the inclusive range
 * defined by (value - tolerance) to (value + tolerance).</p>
 *
 * <p>The method returns <code>false</code> if a <code>null</code> array
 * is passed in.</p>
 *
 * @param array  the array to search
 * @param valueToFind  the value to find
 * @param tolerance  the array contains the tolerance of the search
 * @return true if value falling within tolerance is in array
 */"
"public static boolean contains(double[] array, double valueToFind) {
    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;
}","public void test305324() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[4] = 852.772538765;
    boolean boolean0 = ArrayUtils.contains(doubleArray0, 852.772538765);
    assertTrue(boolean0);
}","/**
 * <p>Checks if the value is in the given array.</p>
 *
 * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>
 *
 * @param array  the array to search through
 * @param valueToFind  the value to find
 * @return <code>true</code> if the array contains the object
 */"
"public static int lastIndexOf(double[] array, double valueToFind, double tolerance) {
    return lastIndexOf(array, valueToFind, Integer.MAX_VALUE, tolerance);
}","public void test306325() throws Throwable {
    double[] doubleArray0 = new double[3];
    doubleArray0[2] = 2269.0511557721948;
    int int0 = ArrayUtils.lastIndexOf(doubleArray0, 1.0, 1.0);
    assertEquals(1, int0);
}","/**
 * <p>Finds the last index of the given value within a given tolerance in the array.
 * This method will return the index of the last value which falls between the region
 * defined by valueToFind - tolerance and valueToFind + tolerance.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param tolerance tolerance of the search
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test307326() throws Throwable {
    double[] doubleArray0 = new double[6];
    int int0 = ArrayUtils.lastIndexOf(doubleArray0, (-32.706932), (int) (short) 1, 1310.6);
    assertEquals(1, int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.
 * This method will return the index of the last value which falls between the region
 * defined by valueToFind - tolerance and valueToFind + tolerance.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @param tolerance  search for value within plus/minus this amount
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test308327() throws Throwable {
    double[] doubleArray0 = new double[9];
    int int0 = ArrayUtils.lastIndexOf(doubleArray0, 554.94136, (-3084), (double) (byte) (-49));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.
 * This method will return the index of the last value which falls between the region
 * defined by valueToFind - tolerance and valueToFind + tolerance.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @param tolerance  search for value within plus/minus this amount
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i >= 0; i--) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test309328() throws Throwable {
    int int0 = ArrayUtils.lastIndexOf((double[]) null, (double) 0.0F, (int) (byte) 0, (-1476.73027527364));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.
 * This method will return the index of the last value which falls between the region
 * defined by valueToFind - tolerance and valueToFind + tolerance.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @param tolerance  search for value within plus/minus this amount
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test310329() throws Throwable {
    double[] doubleArray0 = new double[2];
    int int0 = ArrayUtils.lastIndexOf(doubleArray0, 0.0, 48);
    assertEquals(1, int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test311330() throws Throwable {
    double[] doubleArray0 = new double[6];
    int int0 = ArrayUtils.lastIndexOf(doubleArray0, (double) (-330.81F), 2);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test312331() throws Throwable {
    double[] doubleArray0 = new double[7];
    int int0 = ArrayUtils.lastIndexOf(doubleArray0, (-1178.3237168008875), (-1717986918));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test313332() throws Throwable {
    double[] doubleArray0 = new double[0];
    int int0 = ArrayUtils.lastIndexOf(doubleArray0, (double) (-1), 3282);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(double[] array, double valueToFind, double tolerance) {
    return indexOf(array, valueToFind, 0, tolerance);
}","public void test314333() throws Throwable {
    double[] doubleArray0 = new double[4];
    doubleArray0[0] = 603.0;
    int int0 = ArrayUtils.indexOf(doubleArray0, (double) 0L, 0.0);
    assertEquals(1, int0);
}","/**
 * <p>Finds the index of the given value within a given tolerance in the array.
 * This method will return the index of the first value which falls between the region
 * defined by valueToFind - tolerance and valueToFind + tolerance.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param tolerance tolerance of the search
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i < array.length; i++) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test315334() throws Throwable {
    double[] doubleArray0 = new double[9];
    int int0 = ArrayUtils.indexOf(doubleArray0, 0.0, (-875), 1.5);
    assertEquals(0, int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.
 * This method will return the index of the first value which falls between the region
 * defined by valueToFind - tolerance and valueToFind + tolerance.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @param tolerance tolerance of the search
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(double[] array, double valueToFind, int startIndex, double tolerance) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    double min = valueToFind - tolerance;
    double max = valueToFind + tolerance;
    for (int i = startIndex; i < array.length; i++) {
        if (array[i] >= min && array[i] <= max) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test316335() throws Throwable {
    ArrayUtils arrayUtils0 = new ArrayUtils();
    int int0 = ArrayUtils.indexOf(arrayUtils0.EMPTY_DOUBLE_ARRAY, 1.5, (-370), 1.0);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.
 * This method will return the index of the first value which falls between the region
 * defined by valueToFind - tolerance and valueToFind + tolerance.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @param tolerance tolerance of the search
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(double[] array, double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test317336() throws Throwable {
    double[] doubleArray0 = new double[5];
    int int0 = ArrayUtils.indexOf(doubleArray0, (-1.0), (-449));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static boolean contains(byte[] array, byte valueToFind) {
    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;
}","public void test318337() throws Throwable {
    byte[] byteArray0 = new byte[9];
    byteArray0[3] = (byte) 4;
    boolean boolean0 = ArrayUtils.contains(byteArray0, (byte) 4);
    assertTrue(boolean0);
}","/**
 * <p>Checks if the value is in the given array.</p>
 *
 * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>
 *
 * @param array  the array to search through
 * @param valueToFind  the value to find
 * @return <code>true</code> if the array contains the object
 */"
"public static boolean contains(byte[] array, byte valueToFind) {
    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;
}","public void test319338() throws Throwable {
    byte[] byteArray0 = new byte[1];
    byteArray0[0] = (byte) 2;
    boolean boolean0 = ArrayUtils.contains(byteArray0, (byte) 0);
    assertFalse(boolean0);
}","/**
 * <p>Checks if the value is in the given array.</p>
 *
 * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>
 *
 * @param array  the array to search through
 * @param valueToFind  the value to find
 * @return <code>true</code> if the array contains the object
 */"
"public static int lastIndexOf(byte[] array, byte valueToFind) {
    return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
}","public void test320339() throws Throwable {
    byte[] byteArray0 = new byte[5];
    byteArray0[2] = (byte) 19;
    int int0 = ArrayUtils.lastIndexOf(byteArray0, (byte) 19);
    assertEquals(2, int0);
}","/**
 * <p>Finds the last index of the given value within the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to travers backwords looking for the object, may be <code>null</code>
 * @param valueToFind  the object to find
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test321340() throws Throwable {
    byte[] byteArray0 = new byte[2];
    int int0 = ArrayUtils.lastIndexOf(byteArray0, (byte) 0, (-1768));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test322341() throws Throwable {
    int int0 = ArrayUtils.lastIndexOf((byte[]) null, (byte) 0, 0);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test323342() throws Throwable {
    byte[] byteArray0 = new byte[1];
    int int0 = ArrayUtils.indexOf(byteArray0, (byte) 0, (-3328));
    assertEquals(0, int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(byte[] array, byte valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test324343() throws Throwable {
    int int0 = ArrayUtils.indexOf((byte[]) null, (byte) 33, (-650));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static boolean contains(char[] array, char valueToFind) {
    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;
}","public void test325344() throws Throwable {
    char[] charArray0 = new char[8];
    charArray0[6] = ']';
    boolean boolean0 = ArrayUtils.contains(charArray0, ']');
    assertTrue(boolean0);
}","/**
 * <p>Checks if the value is in the given array.</p>
 *
 * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>
 *
 * @param array  the array to search through
 * @param valueToFind  the value to find
 * @return <code>true</code> if the array contains the object
 * @since 2.1
 */"
"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test326345() throws Throwable {
    char[] charArray0 = new char[1];
    charArray0[0] = '7';
    int int0 = ArrayUtils.lastIndexOf(charArray0, '7', 1);
    assertEquals(0, int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 * @since 2.1
 */"
"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test327346() throws Throwable {
    char[] charArray0 = new char[4];
    int int0 = ArrayUtils.lastIndexOf(charArray0, 'I', 2);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 * @since 2.1
 */"
"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test328347() throws Throwable {
    char[] charArray0 = new char[6];
    int int0 = ArrayUtils.lastIndexOf(charArray0, 'v', (-1));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 * @since 2.1
 */"
"public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test329348() throws Throwable {
    int int0 = ArrayUtils.lastIndexOf((char[]) null, '!', 2);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 * @since 2.1
 */"
"public static int indexOf(char[] array, char valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test330349() throws Throwable {
    char[] charArray0 = new char[2];
    charArray0[0] = '>';
    int int0 = ArrayUtils.indexOf(charArray0, '>', (int) (short) (-2181));
    assertEquals(0, int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 * @since 2.1
 */"
"public static boolean contains(char[] array, char valueToFind) {
    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;
}","public void test331350() throws Throwable {
    boolean boolean0 = ArrayUtils.contains((char[]) null, 'T');
    assertFalse(boolean0);
}","/**
 * <p>Checks if the value is in the given array.</p>
 *
 * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>
 *
 * @param array  the array to search through
 * @param valueToFind  the value to find
 * @return <code>true</code> if the array contains the object
 * @since 2.1
 */"
"public static boolean contains(short[] array, short valueToFind) {
    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;
}","public void test332351() throws Throwable {
    short[] shortArray0 = new short[7];
    shortArray0[0] = (short) (-26);
    boolean boolean0 = ArrayUtils.contains(shortArray0, (short) (-26));
    assertTrue(boolean0);
}","/**
 * <p>Checks if the value is in the given array.</p>
 *
 * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>
 *
 * @param array  the array to search through
 * @param valueToFind  the value to find
 * @return <code>true</code> if the array contains the object
 */"
"public static boolean contains(short[] array, short valueToFind) {
    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;
}","public void test333352() throws Throwable {
    short[] shortArray0 = new short[2];
    boolean boolean0 = ArrayUtils.contains(shortArray0, (short) (-64));
    assertFalse(boolean0);
}","/**
 * <p>Checks if the value is in the given array.</p>
 *
 * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>
 *
 * @param array  the array to search through
 * @param valueToFind  the value to find
 * @return <code>true</code> if the array contains the object
 */"
"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test334353() throws Throwable {
    short[] shortArray0 = new short[2];
    shortArray0[1] = (short) 2168;
    int int0 = ArrayUtils.lastIndexOf(shortArray0, (short) 2168, 13);
    assertEquals(1, int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test335354() throws Throwable {
    short[] shortArray0 = new short[9];
    int int0 = ArrayUtils.lastIndexOf(shortArray0, (short) 1, (-648));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(short[] array, short valueToFind) {
    return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
}","public void test336355() throws Throwable {
    int int0 = ArrayUtils.lastIndexOf((short[]) null, (short) (-1697));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value within the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to travers backwords looking for the object, may be <code>null</code>
 * @param valueToFind  the object to find
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static boolean contains(int[] array, int valueToFind) {
    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;
}","public void test337356() throws Throwable {
    int[] intArray0 = new int[5];
    intArray0[3] = 57;
    boolean boolean0 = ArrayUtils.contains(intArray0, 57);
    assertTrue(boolean0);
}","/**
 * <p>Checks if the value is in the given array.</p>
 *
 * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>
 *
 * @param array  the array to search through
 * @param valueToFind  the value to find
 * @return <code>true</code> if the array contains the object
 */"
"public static boolean contains(int[] array, int valueToFind) {
    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;
}","public void test338357() throws Throwable {
    int[] intArray0 = new int[1];
    boolean boolean0 = ArrayUtils.contains(intArray0, (-1408));
    assertFalse(boolean0);
}","/**
 * <p>Checks if the value is in the given array.</p>
 *
 * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>
 *
 * @param array  the array to search through
 * @param valueToFind  the value to find
 * @return <code>true</code> if the array contains the object
 */"
"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test339358() throws Throwable {
    int[] intArray0 = new int[8];
    intArray0[2] = (-562);
    int int0 = ArrayUtils.lastIndexOf(intArray0, (-562), 11);
    assertEquals(2, int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test340359() throws Throwable {
    int[] intArray0 = new int[8];
    int int0 = ArrayUtils.lastIndexOf(intArray0, 5, (-1));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test341360() throws Throwable {
    int int0 = ArrayUtils.lastIndexOf((int[]) null, (-4227), 69);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test342361() throws Throwable {
    int[] intArray0 = new int[1];
    int int0 = ArrayUtils.indexOf(intArray0, 0, (-1596));
    assertEquals(0, int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(int[] array, int valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test343362() throws Throwable {
    int int0 = ArrayUtils.indexOf((int[]) null, 18, (int) (byte) 0);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static boolean contains(long[] array, long valueToFind) {
    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;
}","public void test344363() throws Throwable {
    long[] longArray0 = new long[2];
    longArray0[0] = (-221L);
    boolean boolean0 = ArrayUtils.contains(longArray0, (-221L));
    assertTrue(boolean0);
}","/**
 * <p>Checks if the value is in the given array.</p>
 *
 * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>
 *
 * @param array  the array to search through
 * @param valueToFind  the value to find
 * @return <code>true</code> if the array contains the object
 */"
"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test345364() throws Throwable {
    long[] longArray0 = new long[9];
    longArray0[1] = (-1894L);
    int int0 = ArrayUtils.lastIndexOf(longArray0, (-1894L), Integer.MAX_VALUE);
    assertEquals(1, int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test346365() throws Throwable {
    long[] longArray0 = new long[6];
    int int0 = ArrayUtils.lastIndexOf(longArray0, (-1L), 3);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test347366() throws Throwable {
    long[] longArray0 = new long[6];
    int int0 = ArrayUtils.lastIndexOf(longArray0, 317L, (-1));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test348367() throws Throwable {
    int int0 = ArrayUtils.lastIndexOf((long[]) null, 1L, 0);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
 * array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int indexOf(long[] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i < array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}","public void test349368() throws Throwable {
    long[] longArray0 = new long[9];
    longArray0[5] = 1L;
    int int0 = ArrayUtils.indexOf(longArray0, 1L, (-1073741824));
    assertEquals(5, int0);
}","/**
 * <p>Finds the index of the given value in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param startIndex  the index to start searching at
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static boolean contains(Object[] array, Object objectToFind) {
    return indexOf(array, objectToFind) != INDEX_NOT_FOUND;
}","public void test350369() throws Throwable {
    Object[] objectArray0 = new Object[7];
    boolean boolean0 = ArrayUtils.contains(objectArray0, objectArray0[0]);
    assertTrue(boolean0);
}","/**
 * <p>Checks if the object is in the given array.</p>
 *
 * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>
 *
 * @param array  the array to search through
 * @param objectToFind  the object to find
 * @return <code>true</code> if the array contains the object
 */"
"public static boolean contains(Object[] array, Object objectToFind) {
    return indexOf(array, objectToFind) != INDEX_NOT_FOUND;
}","public void test351370() throws Throwable {
    Object[] objectArray0 = new Object[1];
    Object object0 = new Object();
    boolean boolean0 = ArrayUtils.contains(objectArray0, object0);
    assertFalse(boolean0);
}","/**
 * <p>Checks if the object is in the given array.</p>
 *
 * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>
 *
 * @param array  the array to search through
 * @param objectToFind  the object to find
 * @return <code>true</code> if the array contains the object
 */"
"public static Character[] toObject(char[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_CHARACTER_OBJECT_ARRAY;
    }
    final Character[] result = new Character[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = Character.valueOf(array[i]);
    }
    return result;
}","public void test352371() throws Throwable {
    char[] charArray0 = new char[6];
    Character[] characterArray0 = ArrayUtils.toObject(charArray0);
    assertNotNull(characterArray0);
}","/**
 * <p>Converts an array of primitive chars to objects.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array a <code>char</code> array
 * @return a <code>Character</code> array, <code>null</code> if null array input
 */"
"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else if (array.getClass().getComponentType().isInstance(objectToFind)) {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}","public void test352372() throws Throwable {
    char[] charArray0 = new char[6];
    Character[] characterArray0 = ArrayUtils.toObject(charArray0);
    Integer integer0 = new Integer(55);
    int int0 = ArrayUtils.lastIndexOf((Object[]) characterArray0, (Object) integer0, 647);
    assertEquals(6, characterArray0.length);
}","/**
 * <p>Finds the last index of the given object in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than
 * the array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param objectToFind  the object to find, may be <code>null</code>
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the object within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else if (array.getClass().getComponentType().isInstance(objectToFind)) {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}","public void test353374() throws Throwable {
    Object[] objectArray0 = new Object[4];
    objectArray0[3] = (Object) 'i';
    int int0 = ArrayUtils.lastIndexOf(objectArray0, objectArray0[2], (int) 'U');
    assertEquals(2, int0);
}","/**
 * <p>Finds the last index of the given object in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than
 * the array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param objectToFind  the object to find, may be <code>null</code>
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the object within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(Object[] array, Object objectToFind) {
    return lastIndexOf(array, objectToFind, Integer.MAX_VALUE);
}","public void test354375() throws Throwable {
    Object[] objectArray0 = new Object[5];
    objectArray0[0] = (Object) (short) 0;
    int int0 = ArrayUtils.lastIndexOf(objectArray0, objectArray0[0]);
    assertEquals(0, int0);
}","/**
 * <p>Finds the last index of the given object within the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to travers backwords looking for the object, may be <code>null</code>
 * @param objectToFind  the object to find, may be <code>null</code>
 * @return the last index of the object within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else if (array.getClass().getComponentType().isInstance(objectToFind)) {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}","public void test355376() throws Throwable {
    ArrayUtils arrayUtils0 = new ArrayUtils();
    int int0 = ArrayUtils.lastIndexOf((Object[]) arrayUtils0.EMPTY_STRING_ARRAY, (Object) arrayUtils0, (-1));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given object in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than
 * the array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param objectToFind  the object to find, may be <code>null</code>
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the object within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    } else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i--) {
            if (array[i] == null) {
                return i;
            }
        }
    } else if (array.getClass().getComponentType().isInstance(objectToFind)) {
        for (int i = startIndex; i >= 0; i--) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}","public void test356377() throws Throwable {
    int int0 = ArrayUtils.lastIndexOf((Object[]) null, (Object) ""org.apache.commons.lang3.ArrayUtils"", Integer.MAX_VALUE);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given object in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than
 * the array length will search from the end of the array.</p>
 *
 * @param array  the array to traverse for looking for the object, may be <code>null</code>
 * @param objectToFind  the object to find, may be <code>null</code>
 * @param startIndex  the start index to travers backwards from
 * @return the last index of the object within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"// IndexOf search
// ----------------------------------------------------------------------
// Object IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the index of the given object in the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param objectToFind  the object to find, may be <code>null</code>
 * @return the index of the object within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */
public static int indexOf(Object[] array, Object objectToFind) {
    return indexOf(array, objectToFind, 0);
}","public void test357378() throws Throwable {
    Object[] objectArray0 = new Object[2];
    Object object0 = new Object();
    objectArray0[0] = object0;
    int int0 = ArrayUtils.indexOf(objectArray0, object0);
    assertEquals(0, int0);
}",""
"// IndexOf search
// ----------------------------------------------------------------------
// Object IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the index of the given object in the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param objectToFind  the object to find, may be <code>null</code>
 * @return the index of the object within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */
public static int indexOf(Object[] array, Object objectToFind) {
    return indexOf(array, objectToFind, 0);
}","public void test358379() throws Throwable {
    Object[] objectArray0 = new Object[2];
    int int0 = ArrayUtils.indexOf(objectArray0, (Object) ""gp^{:T6UR^jb1"");
    assertEquals((-1), int0);
}",""
"public static int indexOf(Object[] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        startIndex = 0;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i < array.length; i++) {
            if (array[i] == null) {
                return i;
            }
        }
    } else if (array.getClass().getComponentType().isInstance(objectToFind)) {
        for (int i = startIndex; i < array.length; i++) {
            if (objectToFind.equals(array[i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}","public void test359380() throws Throwable {
    Object[] objectArray0 = new Object[8];
    Object object0 = new Object();
    objectArray0[0] = object0;
    objectArray0[1] = objectArray0[0];
    objectArray0[2] = objectArray0[1];
    objectArray0[3] = objectArray0[1];
    objectArray0[4] = objectArray0[0];
    objectArray0[5] = objectArray0[0];
    objectArray0[6] = objectArray0[0];
    objectArray0[7] = objectArray0[1];
    int int0 = ArrayUtils.indexOf(objectArray0, (Object) null, (-348));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the index of the given object in the array starting at the given index.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * <p>A negative startIndex is treated as zero. A startIndex larger than the array
 * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param objectToFind  the object to find, may be <code>null</code>
 * @param startIndex  the index to start searching at
 * @return the index of the object within the array starting at the index,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static void reverse(boolean[] array) {
    if (array == null) {
        return;
    }
    int i = 0;
    int j = array.length - 1;
    boolean tmp;
    while (j > i) {
        tmp = array[j];
        array[j] = array[i];
        array[i] = tmp;
        j--;
        i++;
    }
}","public void test361382() throws Throwable {
    ArrayUtils.reverse((boolean[]) null);
}","/**
 * <p>Reverses the order of the given array.</p>
 *
 * <p>This method does nothing for a <code>null</code> input array.</p>
 *
 * @param array  the array to reverse, may be <code>null</code>
 */"
"public static void reverse(boolean[] array) {
    if (array == null) {
        return;
    }
    int i = 0;
    int j = array.length - 1;
    boolean tmp;
    while (j > i) {
        tmp = array[j];
        array[j] = array[i];
        array[i] = tmp;
        j--;
        i++;
    }
}","public void test362383() throws Throwable {
    boolean[] booleanArray0 = new boolean[0];
    ArrayUtils.reverse(booleanArray0);
    assertEquals(0, booleanArray0.length);
}","/**
 * <p>Reverses the order of the given array.</p>
 *
 * <p>This method does nothing for a <code>null</code> input array.</p>
 *
 * @param array  the array to reverse, may be <code>null</code>
 */"
"public static void reverse(float[] array) {
    if (array == null) {
        return;
    }
    int i = 0;
    int j = array.length - 1;
    float tmp;
    while (j > i) {
        tmp = array[j];
        array[j] = array[i];
        array[i] = tmp;
        j--;
        i++;
    }
}","public void test363384() throws Throwable {
    ArrayUtils.reverse((float[]) null);
}","/**
 * <p>Reverses the order of the given array.</p>
 *
 * <p>This method does nothing for a <code>null</code> input array.</p>
 *
 * @param array  the array to reverse, may be <code>null</code>
 */"
"public static void reverse(float[] array) {
    if (array == null) {
        return;
    }
    int i = 0;
    int j = array.length - 1;
    float tmp;
    while (j > i) {
        tmp = array[j];
        array[j] = array[i];
        array[i] = tmp;
        j--;
        i++;
    }
}","public void test364385() throws Throwable {
    float[] floatArray0 = new float[7];
    ArrayUtils.reverse(floatArray0);
    assertArrayEquals(new float[] { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F }, floatArray0, 0.01F);
}","/**
 * <p>Reverses the order of the given array.</p>
 *
 * <p>This method does nothing for a <code>null</code> input array.</p>
 *
 * @param array  the array to reverse, may be <code>null</code>
 */"
"public static void reverse(double[] array) {
    if (array == null) {
        return;
    }
    int i = 0;
    int j = array.length - 1;
    double tmp;
    while (j > i) {
        tmp = array[j];
        array[j] = array[i];
        array[i] = tmp;
        j--;
        i++;
    }
}","public void test365386() throws Throwable {
    double[] doubleArray0 = new double[9];
    ArrayUtils.reverse(doubleArray0);
    assertArrayEquals(new double[] { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 }, doubleArray0, 0.01);
}","/**
 * <p>Reverses the order of the given array.</p>
 *
 * <p>This method does nothing for a <code>null</code> input array.</p>
 *
 * @param array  the array to reverse, may be <code>null</code>
 */"
"public static void reverse(byte[] array) {
    if (array == null) {
        return;
    }
    int i = 0;
    int j = array.length - 1;
    byte tmp;
    while (j > i) {
        tmp = array[j];
        array[j] = array[i];
        array[i] = tmp;
        j--;
        i++;
    }
}","public void test366387() throws Throwable {
    byte[] byteArray0 = new byte[4];
    ArrayUtils.reverse(byteArray0);
    assertArrayEquals(new byte[] { (byte) 0, (byte) 0, (byte) 0, (byte) 0 }, byteArray0);
}","/**
 * <p>Reverses the order of the given array.</p>
 *
 * <p>This method does nothing for a <code>null</code> input array.</p>
 *
 * @param array  the array to reverse, may be <code>null</code>
 */"
"public static void reverse(byte[] array) {
    if (array == null) {
        return;
    }
    int i = 0;
    int j = array.length - 1;
    byte tmp;
    while (j > i) {
        tmp = array[j];
        array[j] = array[i];
        array[i] = tmp;
        j--;
        i++;
    }
}","public void test367388() throws Throwable {
    ArrayUtils.reverse((byte[]) null);
}","/**
 * <p>Reverses the order of the given array.</p>
 *
 * <p>This method does nothing for a <code>null</code> input array.</p>
 *
 * @param array  the array to reverse, may be <code>null</code>
 */"
"public static byte[] add(byte[] array, byte element) {
    byte[] newArray = (byte[]) copyArrayGrow1(array, Byte.TYPE);
    newArray[newArray.length - 1] = element;
    return newArray;
}","public void test368389() throws Throwable {
    byte[] byteArray0 = ArrayUtils.add((byte[]) null, (byte) 0);
    assertNotNull(byteArray0);
}","/**
 * <p>Copies the given array and adds the given element at the end of the new array.</p>
 *
 * <p>The new array contains the same elements of the input
 * array plus the given element in the last position. The component type of
 * the new array is the same as that of the input array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element.</p>
 *
 * <pre>
 * ArrayUtils.add(null, 0)   = [0]
 * ArrayUtils.add([1], 0)    = [1, 0]
 * ArrayUtils.add([1, 0], 1) = [1, 0, 1]
 * </pre>
 *
 * @param array  the array to copy and add the element to, may be <code>null</code>
 * @param element  the object to add at the last index of the new array
 * @return A new array containing the existing elements plus the new element
 * @since 2.1
 */"
"public static void reverse(byte[] array) {
    if (array == null) {
        return;
    }
    int i = 0;
    int j = array.length - 1;
    byte tmp;
    while (j > i) {
        tmp = array[j];
        array[j] = array[i];
        array[i] = tmp;
        j--;
        i++;
    }
}","public void test368390() throws Throwable {
    byte[] byteArray0 = ArrayUtils.add((byte[]) null, (byte) 0);
    ArrayUtils.reverse(byteArray0);
    assertArrayEquals(new byte[] { (byte) 0 }, byteArray0);
}","/**
 * <p>Reverses the order of the given array.</p>
 *
 * <p>This method does nothing for a <code>null</code> input array.</p>
 *
 * @param array  the array to reverse, may be <code>null</code>
 */"
"public static void reverse(char[] array) {
    if (array == null) {
        return;
    }
    int i = 0;
    int j = array.length - 1;
    char tmp;
    while (j > i) {
        tmp = array[j];
        array[j] = array[i];
        array[i] = tmp;
        j--;
        i++;
    }
}","public void test369391() throws Throwable {
    ArrayUtils.reverse((char[]) null);
}","/**
 * <p>Reverses the order of the given array.</p>
 *
 * <p>This method does nothing for a <code>null</code> input array.</p>
 *
 * @param array  the array to reverse, may be <code>null</code>
 */"
"public static void reverse(char[] array) {
    if (array == null) {
        return;
    }
    int i = 0;
    int j = array.length - 1;
    char tmp;
    while (j > i) {
        tmp = array[j];
        array[j] = array[i];
        array[i] = tmp;
        j--;
        i++;
    }
}","public void test370392() throws Throwable {
    char[] charArray0 = new char[3];
    ArrayUtils.reverse(charArray0);
    assertArrayEquals(new char[] { '\u0000', '\u0000', '\u0000' }, charArray0);
}","/**
 * <p>Reverses the order of the given array.</p>
 *
 * <p>This method does nothing for a <code>null</code> input array.</p>
 *
 * @param array  the array to reverse, may be <code>null</code>
 */"
"public static void reverse(short[] array) {
    if (array == null) {
        return;
    }
    int i = 0;
    int j = array.length - 1;
    short tmp;
    while (j > i) {
        tmp = array[j];
        array[j] = array[i];
        array[i] = tmp;
        j--;
        i++;
    }
}","public void test371393() throws Throwable {
    short[] shortArray0 = new short[2];
    ArrayUtils.reverse(shortArray0);
    assertArrayEquals(new short[] { (short) 0, (short) 0 }, shortArray0);
}","/**
 * <p>Reverses the order of the given array.</p>
 *
 * <p>This method does nothing for a <code>null</code> input array.</p>
 *
 * @param array  the array to reverse, may be <code>null</code>
 */"
"public static void reverse(int[] array) {
    if (array == null) {
        return;
    }
    int i = 0;
    int j = array.length - 1;
    int tmp;
    while (j > i) {
        tmp = array[j];
        array[j] = array[i];
        array[i] = tmp;
        j--;
        i++;
    }
}","public void test372394() throws Throwable {
    ArrayUtils.reverse((int[]) null);
}","/**
 * <p>Reverses the order of the given array.</p>
 *
 * <p>This method does nothing for a <code>null</code> input array.</p>
 *
 * @param array  the array to reverse, may be <code>null</code>
 */"
"public static void reverse(int[] array) {
    if (array == null) {
        return;
    }
    int i = 0;
    int j = array.length - 1;
    int tmp;
    while (j > i) {
        tmp = array[j];
        array[j] = array[i];
        array[i] = tmp;
        j--;
        i++;
    }
}","public void test373395() throws Throwable {
    int[] intArray0 = new int[4];
    ArrayUtils.reverse(intArray0);
    assertArrayEquals(new int[] { 0, 0, 0, 0 }, intArray0);
}","/**
 * <p>Reverses the order of the given array.</p>
 *
 * <p>This method does nothing for a <code>null</code> input array.</p>
 *
 * @param array  the array to reverse, may be <code>null</code>
 */"
"public static void reverse(long[] array) {
    if (array == null) {
        return;
    }
    int i = 0;
    int j = array.length - 1;
    long tmp;
    while (j > i) {
        tmp = array[j];
        array[j] = array[i];
        array[i] = tmp;
        j--;
        i++;
    }
}","public void test374396() throws Throwable {
    ArrayUtils.reverse((long[]) null);
}","/**
 * <p>Reverses the order of the given array.</p>
 *
 * <p>This method does nothing for a <code>null</code> input array.</p>
 *
 * @param array  the array to reverse, may be <code>null</code>
 */"
"public static void reverse(long[] array) {
    if (array == null) {
        return;
    }
    int i = 0;
    int j = array.length - 1;
    long tmp;
    while (j > i) {
        tmp = array[j];
        array[j] = array[i];
        array[i] = tmp;
        j--;
        i++;
    }
}","public void test375397() throws Throwable {
    long[] longArray0 = new long[4];
    ArrayUtils.reverse(longArray0);
    assertEquals(4, longArray0.length);
}","/**
 * <p>Reverses the order of the given array.</p>
 *
 * <p>This method does nothing for a <code>null</code> input array.</p>
 *
 * @param array  the array to reverse, may be <code>null</code>
 */"
"// Reverse
//-----------------------------------------------------------------------
/**
 * <p>Reverses the order of the given array.</p>
 *
 * <p>There is no special handling for multi-dimensional arrays.</p>
 *
 * <p>This method does nothing for a <code>null</code> input array.</p>
 *
 * @param array  the array to reverse, may be <code>null</code>
 */
public static void reverse(Object[] array) {
    if (array == null) {
        return;
    }
    int i = 0;
    int j = array.length - 1;
    Object tmp;
    while (j > i) {
        tmp = array[j];
        array[j] = array[i];
        array[i] = tmp;
        j--;
        i++;
    }
}","public void test376398() throws Throwable {
    Byte[] byteArray0 = new Byte[2];
    ArrayUtils.reverse((Object[]) byteArray0);
    assertEquals(2, byteArray0.length);
}",""
"public static boolean isSameType(Object array1, Object array2) {
    if (array1 == null || array2 == null) {
        throw new IllegalArgumentException(""The Array must not be null"");
    }
    return array1.getClass().getName().equals(array2.getClass().getName());
}","public void test377399() throws Throwable {
    Object object0 = new Object();
    boolean boolean0 = ArrayUtils.isSameType(""Array element "", object0);
    assertFalse(boolean0);
}","/**
 * <p>Checks whether two arrays are the same type taking into account
 * multi-dimensional arrays.</p>
 *
 * @param array1 the first array, must not be <code>null</code>
 * @param array2 the second array, must not be <code>null</code>
 * @return <code>true</code> if type of arrays matches
 * @throws IllegalArgumentException if either array is <code>null</code>
 */"
"public static boolean isSameType(Object array1, Object array2) {
    if (array1 == null || array2 == null) {
        throw new IllegalArgumentException(""The Array must not be null"");
    }
    return array1.getClass().getName().equals(array2.getClass().getName());
}","public void test378400() throws Throwable {
    // Undeclared exception!
    try {
        ArrayUtils.isSameType((Object) null, ""jzYHQb-AJ"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The Array must not be null
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}","/**
 * <p>Checks whether two arrays are the same type taking into account
 * multi-dimensional arrays.</p>
 *
 * @param array1 the first array, must not be <code>null</code>
 * @param array2 the second array, must not be <code>null</code>
 * @return <code>true</code> if type of arrays matches
 * @throws IllegalArgumentException if either array is <code>null</code>
 */"
"public static boolean[] remove(boolean[] array, int index) {
    return (boolean[]) remove((Object) array, index);
}","public void test379401() throws Throwable {
    // Undeclared exception!
    try {
        ArrayUtils.remove((boolean[]) null, (-1));
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // Index: -1, Length: 0
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}","/**
 * <p>Removes the element at the specified position from the specified array.
 * All subsequent elements are shifted to the left (substracts one from
 * their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException
 * will be thrown, because in that case no valid index can be specified.</p>
 *
 * <pre>
 * ArrayUtils.remove([true], 0)              = []
 * ArrayUtils.remove([true, false], 0)       = [false]
 * ArrayUtils.remove([true, false], 1)       = [true]
 * ArrayUtils.remove([true, true, false], 1) = [true, false]
 * </pre>
 *
 * @param array  the array to remove the element from, may not be <code>null</code>
 * @param index  the position of the element to be removed
 * @return A new array containing the existing elements except the element
 *         at the specified position.
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index >= array.length), or if the array is <code>null</code>.
 * @since 2.1
 */"
"public static boolean isSameLength(boolean[] array1, boolean[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test380402() throws Throwable {
    boolean[] booleanArray0 = new boolean[2];
    boolean[] booleanArray1 = new boolean[8];
    boolean boolean0 = ArrayUtils.isSameLength(booleanArray0, booleanArray1);
    assertFalse(boolean0);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static boolean isSameLength(boolean[] array1, boolean[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test381403() throws Throwable {
    Boolean[] booleanArray0 = new Boolean[4];
    Boolean boolean0 = Boolean.TRUE;
    booleanArray0[0] = boolean0;
    booleanArray0[1] = boolean0;
    booleanArray0[2] = booleanArray0[0];
    booleanArray0[3] = booleanArray0[0];
    boolean[] booleanArray1 = ArrayUtils.toPrimitive(booleanArray0);
    boolean boolean1 = ArrayUtils.isSameLength((boolean[]) null, booleanArray1);
    assertFalse(boolean1);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static boolean isSameLength(boolean[] array1, boolean[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test382405() throws Throwable {
    boolean boolean0 = ArrayUtils.isSameLength((boolean[]) null, (boolean[]) null);
    assertTrue(boolean0);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static boolean isSameLength(boolean[] array1, boolean[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test383406() throws Throwable {
    boolean[] booleanArray0 = new boolean[9];
    boolean boolean0 = ArrayUtils.isSameLength(booleanArray0, booleanArray0);
    assertTrue(boolean0);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static boolean isSameLength(float[] array1, float[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test384407() throws Throwable {
    float[] floatArray0 = new float[7];
    float[] floatArray1 = new float[3];
    boolean boolean0 = ArrayUtils.isSameLength(floatArray0, floatArray1);
    assertFalse(boolean0);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static boolean isSameLength(float[] array1, float[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test385408() throws Throwable {
    float[] floatArray0 = new float[1];
    boolean boolean0 = ArrayUtils.isSameLength((float[]) null, floatArray0);
    assertFalse(boolean0);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static boolean isSameLength(float[] array1, float[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test386409() throws Throwable {
    boolean boolean0 = ArrayUtils.isSameLength((float[]) null, (float[]) null);
    assertTrue(boolean0);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static boolean isSameLength(float[] array1, float[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test387410() throws Throwable {
    float[] floatArray0 = new float[2];
    boolean boolean0 = ArrayUtils.isSameLength(floatArray0, floatArray0);
    assertTrue(boolean0);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static boolean isSameLength(double[] array1, double[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test388411() throws Throwable {
    double[] doubleArray0 = new double[8];
    double[] doubleArray1 = ArrayUtils.addAll(doubleArray0, doubleArray0);
    boolean boolean0 = ArrayUtils.isSameLength(doubleArray1, doubleArray0);
    assertEquals(16, doubleArray1.length);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static boolean isSameLength(double[] array1, double[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test389413() throws Throwable {
    double[] doubleArray0 = new double[0];
    boolean boolean0 = ArrayUtils.isSameLength(doubleArray0, doubleArray0);
    assertTrue(boolean0);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static boolean isSameLength(byte[] array1, byte[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test390414() throws Throwable {
    byte[] byteArray0 = new byte[9];
    byte[] byteArray1 = new byte[5];
    boolean boolean0 = ArrayUtils.isSameLength(byteArray0, byteArray1);
    assertFalse(boolean0);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static boolean isSameLength(byte[] array1, byte[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test391415() throws Throwable {
    byte[] byteArray0 = new byte[9];
    boolean boolean0 = ArrayUtils.isSameLength(byteArray0, byteArray0);
    assertTrue(boolean0);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static boolean isSameLength(char[] array1, char[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test392416() throws Throwable {
    char[] charArray0 = new char[6];
    char[] charArray1 = ArrayUtils.addAll(charArray0, charArray0);
    boolean boolean0 = ArrayUtils.isSameLength(charArray1, charArray0);
    assertEquals(12, charArray1.length);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static boolean isSameLength(char[] array1, char[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test393418() throws Throwable {
    boolean boolean0 = ArrayUtils.isSameLength((char[]) null, (char[]) null);
    assertTrue(boolean0);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static boolean isSameLength(char[] array1, char[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test394419() throws Throwable {
    char[] charArray0 = new char[6];
    boolean boolean0 = ArrayUtils.isSameLength(charArray0, charArray0);
    assertTrue(boolean0);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static boolean isSameLength(short[] array1, short[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test395420() throws Throwable {
    short[] shortArray0 = new short[7];
    short[] shortArray1 = new short[4];
    boolean boolean0 = ArrayUtils.isSameLength(shortArray1, shortArray0);
    assertFalse(boolean0);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static boolean isSameLength(short[] array1, short[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test396421() throws Throwable {
    boolean boolean0 = ArrayUtils.isSameLength((short[]) null, (short[]) null);
    assertTrue(boolean0);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static boolean isSameLength(short[] array1, short[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test397422() throws Throwable {
    short[] shortArray0 = new short[4];
    boolean boolean0 = ArrayUtils.isSameLength(shortArray0, shortArray0);
    assertTrue(boolean0);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static boolean isSameLength(int[] array1, int[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test398423() throws Throwable {
    boolean boolean0 = ArrayUtils.isSameLength((int[]) null, (int[]) null);
    assertTrue(boolean0);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static boolean isSameLength(int[] array1, int[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test399424() throws Throwable {
    int[] intArray0 = new int[1];
    boolean boolean0 = ArrayUtils.isSameLength(intArray0, intArray0);
    assertTrue(boolean0);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static boolean isSameLength(long[] array1, long[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test400425() throws Throwable {
    long[] longArray0 = new long[5];
    long[] longArray1 = new long[8];
    boolean boolean0 = ArrayUtils.isSameLength(longArray0, longArray1);
    assertFalse(boolean0);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static boolean isSameLength(long[] array1, long[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test401426() throws Throwable {
    boolean boolean0 = ArrayUtils.isSameLength((long[]) null, (long[]) null);
    assertTrue(boolean0);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static boolean isSameLength(long[] array1, long[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test402427() throws Throwable {
    long[] longArray0 = new long[2];
    boolean boolean0 = ArrayUtils.isSameLength(longArray0, longArray0);
    assertTrue(boolean0);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"// Is same length
//-----------------------------------------------------------------------
/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.
 *
 * <p>Any multi-dimensional aspects of the arrays are ignored.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */
public static boolean isSameLength(Object[] array1, Object[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test403428() throws Throwable {
    Object[] objectArray0 = new Object[7];
    boolean boolean0 = ArrayUtils.isSameLength(objectArray0, objectArray0);
    assertTrue(boolean0);
}",""
"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }
    boolean[] subarray = new boolean[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test404429() throws Throwable {
    boolean[] booleanArray0 = new boolean[9];
    boolean[] booleanArray1 = ArrayUtils.subarray(booleanArray0, 1479, 1479);
    assertEquals(0, booleanArray1.length);
}","/**
 * <p>Produces a new <code>boolean</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BOOLEAN_ARRAY;
    }
    boolean[] subarray = new boolean[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test405430() throws Throwable {
    boolean[] booleanArray0 = ArrayUtils.subarray((boolean[]) null, 1, 1);
    assertNull(booleanArray0);
}","/**
 * <p>Produces a new <code>boolean</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_FLOAT_ARRAY;
    }
    float[] subarray = new float[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test406431() throws Throwable {
    float[] floatArray0 = new float[4];
    float[] floatArray1 = ArrayUtils.subarray(floatArray0, (-265), (-1));
    assertEquals(0, floatArray1.length);
}","/**
 * <p>Produces a new <code>float</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_FLOAT_ARRAY;
    }
    float[] subarray = new float[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test407432() throws Throwable {
    float[] floatArray0 = ArrayUtils.subarray((float[]) null, 0, Integer.MAX_VALUE);
    assertNull(floatArray0);
}","/**
 * <p>Produces a new <code>float</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_DOUBLE_ARRAY;
    }
    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test408433() throws Throwable {
    double[] doubleArray0 = new double[5];
    double[] doubleArray1 = ArrayUtils.subarray(doubleArray0, (int) (byte) 0, 2);
    assertEquals(2, doubleArray1.length);
}","/**
 * <p>Produces a new <code>double</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_DOUBLE_ARRAY;
    }
    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test409434() throws Throwable {
    double[] doubleArray0 = new double[6];
    double[] doubleArray1 = ArrayUtils.subarray(doubleArray0, (-3311), (-3311));
    assertEquals(0, doubleArray1.length);
}","/**
 * <p>Produces a new <code>double</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_DOUBLE_ARRAY;
    }
    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test410435() throws Throwable {
    double[] doubleArray0 = ArrayUtils.subarray((double[]) null, 58, 58);
    assertNull(doubleArray0);
}","/**
 * <p>Produces a new <code>double</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_DOUBLE_ARRAY;
    }
    double[] subarray = new double[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test411436() throws Throwable {
    double[] doubleArray0 = new double[1];
    double[] doubleArray1 = ArrayUtils.subarray(doubleArray0, 57, 4);
    assertEquals(0, doubleArray1.length);
}","/**
 * <p>Produces a new <code>double</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BYTE_ARRAY;
    }
    byte[] subarray = new byte[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test412438() throws Throwable {
    byte[] byteArray0 = new byte[2];
    byte[] byteArray1 = ArrayUtils.subarray(byteArray0, 0, 520);
    assertEquals(2, byteArray1.length);
}","/**
 * <p>Produces a new <code>byte</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BYTE_ARRAY;
    }
    byte[] subarray = new byte[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test413440() throws Throwable {
    byte[] byteArray0 = new byte[9];
    byte[] byteArray1 = ArrayUtils.subarray(byteArray0, (int) (byte) 58, (int) (byte) 102);
    assertEquals(0, byteArray1.length);
}","/**
 * <p>Produces a new <code>byte</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BYTE_ARRAY;
    }
    byte[] subarray = new byte[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test414441() throws Throwable {
    byte[] byteArray0 = new byte[4];
    byte[] byteArray1 = ArrayUtils.subarray(byteArray0, (int) (byte) (-82), (int) (byte) (-1));
    assertEquals(0, byteArray1.length);
}","/**
 * <p>Produces a new <code>byte</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_BYTE_ARRAY;
    }
    byte[] subarray = new byte[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test415442() throws Throwable {
    byte[] byteArray0 = ArrayUtils.subarray((byte[]) null, 0, 0);
    assertNull(byteArray0);
}","/**
 * <p>Produces a new <code>byte</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_CHAR_ARRAY;
    }
    char[] subarray = new char[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test416443() throws Throwable {
    char[] charArray0 = new char[7];
    char[] charArray1 = ArrayUtils.subarray(charArray0, 0, Integer.MAX_VALUE);
    assertNotSame(charArray1, charArray0);
}","/**
 * <p>Produces a new <code>char</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_CHAR_ARRAY;
    }
    char[] subarray = new char[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test417445() throws Throwable {
    char[] charArray0 = new char[7];
    char[] charArray1 = ArrayUtils.subarray(charArray0, (int) (short) (-4227), (-2146065914));
    assertEquals(0, charArray1.length);
}","/**
 * <p>Produces a new <code>char</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_CHAR_ARRAY;
    }
    char[] subarray = new char[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test418446() throws Throwable {
    char[] charArray0 = ArrayUtils.subarray((char[]) null, (-3067), 2145847248);
    assertNull(charArray0);
}","/**
 * <p>Produces a new <code>char</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_SHORT_ARRAY;
    }
    short[] subarray = new short[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test419447() throws Throwable {
    short[] shortArray0 = new short[1];
    short[] shortArray1 = ArrayUtils.subarray(shortArray0, (-2211), 836);
    assertEquals(1, shortArray1.length);
}","/**
 * <p>Produces a new <code>short</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_SHORT_ARRAY;
    }
    short[] subarray = new short[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test420449() throws Throwable {
    short[] shortArray0 = new short[8];
    short[] shortArray1 = ArrayUtils.subarray(shortArray0, (int) (short) (-648), (int) (short) 0);
    assertEquals(0, shortArray1.length);
}","/**
 * <p>Produces a new <code>short</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_SHORT_ARRAY;
    }
    short[] subarray = new short[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test421450() throws Throwable {
    short[] shortArray0 = ArrayUtils.subarray((short[]) null, (-608), (-608));
    assertNull(shortArray0);
}","/**
 * <p>Produces a new <code>short</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_INT_ARRAY;
    }
    int[] subarray = new int[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test422451() throws Throwable {
    int[] intArray0 = new int[1];
    int[] intArray1 = ArrayUtils.subarray(intArray0, (-1578), 3);
    assertEquals(1, intArray1.length);
}","/**
 * <p>Produces a new <code>int</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_INT_ARRAY;
    }
    int[] subarray = new int[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test423453() throws Throwable {
    int[] intArray0 = ArrayUtils.subarray((int[]) null, 1092, 1092);
    assertNull(intArray0);
}","/**
 * <p>Produces a new <code>int</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_INT_ARRAY;
    }
    int[] subarray = new int[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test424454() throws Throwable {
    int[] intArray0 = new int[6];
    int[] intArray1 = ArrayUtils.subarray(intArray0, 1190, 0);
    assertNotNull(intArray1);
}","/**
 * <p>Produces a new <code>int</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static boolean isSameLength(int[] array1, int[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test424455() throws Throwable {
    int[] intArray0 = new int[6];
    int[] intArray1 = ArrayUtils.subarray(intArray0, 1190, 0);
    boolean boolean0 = ArrayUtils.isSameLength(intArray1, intArray0);
    assertFalse(boolean0);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_LONG_ARRAY;
    }
    long[] subarray = new long[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test425456() throws Throwable {
    long[] longArray0 = new long[4];
    long[] longArray1 = ArrayUtils.subarray(longArray0, 0, 2);
    assertNotNull(longArray1);
}","/**
 * <p>Produces a new <code>long</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_LONG_ARRAY;
    }
    long[] subarray = new long[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test426458() throws Throwable {
    long[] longArray0 = new long[5];
    long[] longArray1 = ArrayUtils.subarray(longArray0, 57, 204);
    assertEquals(0, longArray1.length);
}","/**
 * <p>Produces a new <code>long</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    if (newSize <= 0) {
        return EMPTY_LONG_ARRAY;
    }
    long[] subarray = new long[newSize];
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test427460() throws Throwable {
    long[] longArray0 = new long[2];
    long[] longArray1 = ArrayUtils.subarray(longArray0, (-386), (int) (byte) (-80));
    assertNotNull(longArray1);
}","/**
 * <p>Produces a new <code>long</code> array containing the elements
 * between the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */"
"// Subarrays
//-----------------------------------------------------------------------
/**
 * <p>Produces a new array containing the elements between
 * the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * <p>The component type of the subarray is always the same as
 * that of the input array. Thus, if the input is an array of type
 * <code>Date</code>, the following usage is envisaged:</p>
 *
 * <pre>
 * Date[] someDates = (Date[])ArrayUtils.subarray(allDates, 2, 5);
 * </pre>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */
public static <T> T[] subarray(T[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    Class<?> type = array.getClass().getComponentType();
    if (newSize <= 0) {
        // OK, because array is of type T
        @SuppressWarnings(""unchecked"")
        final T[] emptyArray = (T[]) Array.newInstance(type, 0);
        return emptyArray;
    }
    // OK, because array is of type T
    @SuppressWarnings(""unchecked"")
    T[] subarray = (T[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test428462() throws Throwable {
    Object[] objectArray0 = new Object[1];
    Object[] objectArray1 = ArrayUtils.subarray(objectArray0, (-110), 414);
    assertEquals(1, objectArray1.length);
}",""
"// Subarrays
//-----------------------------------------------------------------------
/**
 * <p>Produces a new array containing the elements between
 * the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * <p>The component type of the subarray is always the same as
 * that of the input array. Thus, if the input is an array of type
 * <code>Date</code>, the following usage is envisaged:</p>
 *
 * <pre>
 * Date[] someDates = (Date[])ArrayUtils.subarray(allDates, 2, 5);
 * </pre>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */
public static <T> T[] subarray(T[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    Class<?> type = array.getClass().getComponentType();
    if (newSize <= 0) {
        // OK, because array is of type T
        @SuppressWarnings(""unchecked"")
        final T[] emptyArray = (T[]) Array.newInstance(type, 0);
        return emptyArray;
    }
    // OK, because array is of type T
    @SuppressWarnings(""unchecked"")
    T[] subarray = (T[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test429465() throws Throwable {
    Integer[] integerArray0 = new Integer[4];
    Integer[] integerArray1 = ArrayUtils.subarray(integerArray0, 0, 0);
    assertEquals(0, integerArray1.length);
}",""
"// Subarrays
//-----------------------------------------------------------------------
/**
 * <p>Produces a new array containing the elements between
 * the start and end indices.</p>
 *
 * <p>The start index is inclusive, the end index exclusive.
 * Null array input produces null output.</p>
 *
 * <p>The component type of the subarray is always the same as
 * that of the input array. Thus, if the input is an array of type
 * <code>Date</code>, the following usage is envisaged:</p>
 *
 * <pre>
 * Date[] someDates = (Date[])ArrayUtils.subarray(allDates, 2, 5);
 * </pre>
 *
 * @param array  the array
 * @param startIndexInclusive  the starting index. Undervalue (&lt;0)
 *      is promoted to 0, overvalue (&gt;array.length) results
 *      in an empty array.
 * @param endIndexExclusive  elements up to endIndex-1 are present in the
 *      returned subarray. Undervalue (&lt; startIndex) produces
 *      empty array, overvalue (&gt;array.length) is demoted to
 *      array length.
 * @return a new array containing the elements between
 *      the start and end indices.
 * @since 2.1
 */
public static <T> T[] subarray(T[] array, int startIndexInclusive, int endIndexExclusive) {
    if (array == null) {
        return null;
    }
    if (startIndexInclusive < 0) {
        startIndexInclusive = 0;
    }
    if (endIndexExclusive > array.length) {
        endIndexExclusive = array.length;
    }
    int newSize = endIndexExclusive - startIndexInclusive;
    Class<?> type = array.getClass().getComponentType();
    if (newSize <= 0) {
        // OK, because array is of type T
        @SuppressWarnings(""unchecked"")
        final T[] emptyArray = (T[]) Array.newInstance(type, 0);
        return emptyArray;
    }
    // OK, because array is of type T
    @SuppressWarnings(""unchecked"")
    T[] subarray = (T[]) Array.newInstance(type, newSize);
    System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);
    return subarray;
}","public void test430467() throws Throwable {
    float[] floatArray0 = new float[4];
    Float[] floatArray1 = ArrayUtils.toObject(floatArray0);
    Object[] objectArray0 = ArrayUtils.subarray((Object[]) floatArray1, (-1), (-1));
    assertEquals(0, objectArray0.length);
}",""
"public static boolean[] removeElement(boolean[] array, boolean element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test431470() throws Throwable {
    boolean[] booleanArray0 = ArrayUtils.removeElement((boolean[]) null, true);
    assertNull(booleanArray0);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, true)                = null
 * ArrayUtils.removeElement([], true)                  = []
 * ArrayUtils.removeElement([true], false)             = [true]
 * ArrayUtils.removeElement([true, false], false)      = [true]
 * ArrayUtils.removeElement([true, false, true], true) = [false, true]
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"public static boolean[] removeElement(boolean[] array, boolean element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test432471() throws Throwable {
    boolean[] booleanArray0 = new boolean[0];
    boolean[] booleanArray1 = ArrayUtils.removeElement(booleanArray0, true);
    assertEquals(0, booleanArray1.length);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, true)                = null
 * ArrayUtils.removeElement([], true)                  = []
 * ArrayUtils.removeElement([true], false)             = [true]
 * ArrayUtils.removeElement([true, false], false)      = [true]
 * ArrayUtils.removeElement([true, false, true], true) = [false, true]
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"public static float[] removeElement(float[] array, float element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test433472() throws Throwable {
    float[] floatArray0 = ArrayUtils.removeElement((float[]) null, (float) 0L);
    assertNull(floatArray0);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, 1.1)            = null
 * ArrayUtils.removeElement([], 1.1)              = []
 * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]
 * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]
 * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"public static float[] clone(float[] array) {
    if (array == null) {
        return null;
    }
    return array.clone();
}","public void test434473() throws Throwable {
    float[] floatArray0 = new float[4];
    float[] floatArray1 = ArrayUtils.clone(floatArray0);
    assertNotNull(floatArray1);
}","/**
 * <p>Clones an array returning a typecast result and handling
 * <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  the array to clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */"
"public static double[] addAll(double[] array1, double... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    double[] joinedArray = new double[array1.length + array2.length];
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    return joinedArray;
}","public void test435475() throws Throwable {
    double[] doubleArray0 = ArrayUtils.addAll((double[]) null, (double[]) null);
    assertNull(doubleArray0);
}","/**
 * <p>Adds all the elements of the given arrays into a new array.</p>
 * <p>The new array contains all of the element of <code>array1</code> followed
 * by all of the elements <code>array2</code>. When an array is returned, it is always
 * a new array.</p>
 *
 * <pre>
 * ArrayUtils.addAll(array1, null)   = cloned copy of array1
 * ArrayUtils.addAll(null, array2)   = cloned copy of array2
 * ArrayUtils.addAll([], [])         = []
 * </pre>
 *
 * @param array1  the first array whose elements are added to the new array.
 * @param array2  the second array whose elements are added to the new array.
 * @return The new double[] array.
 * @since 2.1
 */"
"public static double[] clone(double[] array) {
    if (array == null) {
        return null;
    }
    return array.clone();
}","public void test436476() throws Throwable {
    double[] doubleArray0 = new double[7];
    double[] doubleArray1 = ArrayUtils.clone(doubleArray0);
    assertEquals(7, doubleArray1.length);
}","/**
 * <p>Clones an array returning a typecast result and handling
 * <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  the array to clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */"
"public static byte[] clone(byte[] array) {
    if (array == null) {
        return null;
    }
    return array.clone();
}","public void test437478() throws Throwable {
    byte[] byteArray0 = ArrayUtils.clone((byte[]) null);
    assertNull(byteArray0);
}","/**
 * <p>Clones an array returning a typecast result and handling
 * <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  the array to clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */"
"public static char[] clone(char[] array) {
    if (array == null) {
        return null;
    }
    return array.clone();
}","public void test439480() throws Throwable {
    char[] charArray0 = ArrayUtils.clone((char[]) null);
    assertNull(charArray0);
}","/**
 * <p>Clones an array returning a typecast result and handling
 * <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  the array to clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */"
"public static short[] removeElement(short[] array, short element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test440481() throws Throwable {
    short[] shortArray0 = ArrayUtils.removeElement((short[]) null, (short) 0);
    assertNull(shortArray0);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, 1)      = null
 * ArrayUtils.removeElement([], 1)        = []
 * ArrayUtils.removeElement([1], 2)       = [1]
 * ArrayUtils.removeElement([1, 3], 1)    = [3]
 * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"public static short[] clone(short[] array) {
    if (array == null) {
        return null;
    }
    return array.clone();
}","public void test441482() throws Throwable {
    short[] shortArray0 = new short[6];
    short[] shortArray1 = ArrayUtils.clone(shortArray0);
    assertNotNull(shortArray1);
}","/**
 * <p>Clones an array returning a typecast result and handling
 * <code>null</code>.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  the array to clone, may be <code>null</code>
 * @return the cloned array, <code>null</code> if <code>null</code> input
 */"
"public static int[] addAll(int[] array1, int... array2) {
    if (array1 == null) {
        return clone(array2);
    } else if (array2 == null) {
        return clone(array1);
    }
    int[] joinedArray = new int[array1.length + array2.length];
    System.arraycopy(array1, 0, joinedArray, 0, array1.length);
    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
    return joinedArray;
}","public void test442484() throws Throwable {
    int[] intArray0 = ArrayUtils.addAll((int[]) null, (int[]) null);
    assertNull(intArray0);
}","/**
 * <p>Adds all the elements of the given arrays into a new array.</p>
 * <p>The new array contains all of the element of <code>array1</code> followed
 * by all of the elements <code>array2</code>. When an array is returned, it is always
 * a new array.</p>
 *
 * <pre>
 * ArrayUtils.addAll(array1, null)   = cloned copy of array1
 * ArrayUtils.addAll(null, array2)   = cloned copy of array2
 * ArrayUtils.addAll([], [])         = []
 * </pre>
 *
 * @param array1  the first array whose elements are added to the new array.
 * @param array2  the second array whose elements are added to the new array.
 * @return The new int[] array.
 * @since 2.1
 */"
"public static long[] removeElement(long[] array, long element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test443485() throws Throwable {
    long[] longArray0 = ArrayUtils.removeElement((long[]) null, 1L);
    assertNull(longArray0);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, 1)      = null
 * ArrayUtils.removeElement([], 1)        = []
 * ArrayUtils.removeElement([1], 2)       = [1]
 * ArrayUtils.removeElement([1, 3], 1)    = [3]
 * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"public static <T> T[] removeElement(T[] array, Object element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test445487() throws Throwable {
    Object[] objectArray0 = ArrayUtils.removeElement((Object[]) null, (Object) ""org.apache.commons.lang3.ArrayUtils"");
    assertNull(objectArray0);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, ""a"")            = null
 * ArrayUtils.removeElement([], ""a"")              = []
 * ArrayUtils.removeElement([""a""], ""b"")           = [""a""]
 * ArrayUtils.removeElement([""a"", ""b""], ""a"")      = [""b""]
 * ArrayUtils.removeElement([""a"", ""b"", ""a""], ""a"") = [""b"", ""a""]
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"public static <T> T[] removeElement(T[] array, Object element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test446488() throws Throwable {
    Object object0 = new Object();
    String[] stringArray0 = new String[8];
    String[] stringArray1 = ArrayUtils.removeElement(stringArray0, object0);
    assertNotNull(stringArray1);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, ""a"")            = null
 * ArrayUtils.removeElement([], ""a"")              = []
 * ArrayUtils.removeElement([""a""], ""b"")           = [""a""]
 * ArrayUtils.removeElement([""a"", ""b""], ""a"")      = [""b""]
 * ArrayUtils.removeElement([""a"", ""b"", ""a""], ""a"") = [""b"", ""a""]
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"// To map
//-----------------------------------------------------------------------
/**
 * <p>Converts the given array into a {@link java.util.Map}. Each element of the array
 * must be either a {@link java.util.Map.Entry} or an Array, containing at least two
 * elements, where the first element is used as key and the second as
 * value.</p>
 *
 * <p>This method can be used to initialize:</p>
 * <pre>
 * // Create a Map mapping colors.
 * Map colorMap = MapUtils.toMap(new String[][] {{
 *     {""RED"", ""#FF0000""},
 *     {""GREEN"", ""#00FF00""},
 *     {""BLUE"", ""#0000FF""}});
 * </pre>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  an array whose elements are either a {@link java.util.Map.Entry} or
 *  an Array containing at least two elements, may be <code>null</code>
 * @return a <code>Map</code> that was created from the array
 * @throws IllegalArgumentException  if one element of this Array is
 *  itself an Array containing less then two elements
 * @throws IllegalArgumentException  if the array contains elements other
 *  than {@link java.util.Map.Entry} and an Array
 */
public static Map<Object, Object> toMap(Object[] array) {
    if (array == null) {
        return null;
    }
    final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5));
    for (int i = 0; i < array.length; i++) {
        Object object = array[i];
        if (object instanceof Map.Entry<?, ?>) {
            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) object;
            map.put(entry.getKey(), entry.getValue());
        } else if (object instanceof Object[]) {
            Object[] entry = (Object[]) object;
            if (entry.length < 2) {
                throw new IllegalArgumentException(""Array element "" + i + "", '"" + object + ""', has a length less than 2"");
            }
            map.put(entry[0], entry[1]);
        } else {
            throw new IllegalArgumentException(""Array element "" + i + "", '"" + object + ""', is neither of type Map.Entry nor an Array"");
        }
    }
    return map;
}","public void test448491() throws Throwable {
    double[] doubleArray0 = new double[5];
    Double[] doubleArray1 = ArrayUtils.toObject(doubleArray0);
    // Undeclared exception!
    try {
        ArrayUtils.toMap(doubleArray1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Array element 0, '0.0', is neither of type Map.Entry nor an Array
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}",""
"public static String toString(Object array, String stringIfNull) {
    if (array == null) {
        return stringIfNull;
    }
    return new ToStringBuilder(array, ToStringStyle.SIMPLE_STYLE).append(array).toString();
}","public void test449492() throws Throwable {
    String string0 = ArrayUtils.toString((Object) null, ""java.lang.Object"");
    assertEquals(""java.lang.Object"", string0);
}","/**
 * <p>Outputs an array as a String handling <code>null</code>s.</p>
 *
 * <p>Multi-dimensional arrays are handled correctly, including
 * multi-dimensional primitive arrays.</p>
 *
 * <p>The format is that of Java source code, for example <code>{a,b}</code>.</p>
 *
 * @param array  the array to get a toString for, may be <code>null</code>
 * @param stringIfNull  the String to return if the array is <code>null</code>
 * @return a String representation of the array
 */"
"public static byte[] removeElement(byte[] array, byte element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test450493() throws Throwable {
    byte[] byteArray0 = new byte[5];
    byteArray0[1] = (byte) 82;
    byte[] byteArray1 = ArrayUtils.removeElement(byteArray0, (byte) 82);
    assertArrayEquals(new byte[] { (byte) 0, (byte) 0, (byte) 0, (byte) 0 }, byteArray1);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, 1)        = null
 * ArrayUtils.removeElement([], 1)          = []
 * ArrayUtils.removeElement([1], 0)         = [1]
 * ArrayUtils.removeElement([1, 0], 0)      = [1]
 * ArrayUtils.removeElement([1, 0, 1], 1)   = [0, 1]
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"public static char[] add(char[] array, int index, char element) {
    return (char[]) add(array, index, Character.valueOf(element), Character.TYPE);
}","public void test451495() throws Throwable {
    char[] charArray0 = new char[5];
    // Undeclared exception!
    try {
        ArrayUtils.add(charArray0, (-4227), 'a');
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // Index: -4227, Length: 5
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}","/**
 * <p>Inserts the specified element at the specified position in the array.
 * Shifts the element currently at that position (if any) and any subsequent
 * elements to the right (adds one to their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array plus the given element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element.</p>
 *
 * <pre>
 * ArrayUtils.add(null, 0, 'a')            = ['a']
 * ArrayUtils.add(['a'], 0, 'b')           = ['b', 'a']
 * ArrayUtils.add(['a', 'b'], 0, 'c')      = ['c', 'a', 'b']
 * ArrayUtils.add(['a', 'b'], 1, 'k')      = ['a', 'k', 'b']
 * ArrayUtils.add(['a', 'b', 'c'], 1, 't') = ['a', 't', 'b', 'c']
 * </pre>
 *
 * @param array  the array to add the element to, may be <code>null</code>
 * @param index  the position of the new object
 * @param element  the object to add
 * @return A new array containing the existing elements and the new element
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index > array.length).
 */"
"public static long[] remove(long[] array, int index) {
    return (long[]) remove((Object) array, index);
}","public void test452496() throws Throwable {
    long[] longArray0 = new long[3];
    // Undeclared exception!
    try {
        ArrayUtils.remove(longArray0, (-2023));
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // Index: -2023, Length: 3
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}","/**
 * <p>Removes the element at the specified position from the specified array.
 * All subsequent elements are shifted to the left (substracts one from
 * their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException
 * will be thrown, because in that case no valid index can be specified.</p>
 *
 * <pre>
 * ArrayUtils.remove([1], 0)         = []
 * ArrayUtils.remove([2, 6], 0)      = [6]
 * ArrayUtils.remove([2, 6], 1)      = [2]
 * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]
 * </pre>
 *
 * @param array  the array to remove the element from, may not be <code>null</code>
 * @param index  the position of the element to be removed
 * @return A new array containing the existing elements except the element
 *         at the specified position.
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index >= array.length), or if the array is <code>null</code>.
 * @since 2.1
 */"
"// Generic array
//-----------------------------------------------------------------------
/**
 * Create a type-safe generic array.
 *
 * <p>Arrays are covariant i.e. they cannot be created from a generic type:</p>
 *
 * <pre>
 *    public static &lt;T&gt; T[] createAnArray(int size)
 *    {
 *        return T[size]; // compiler error here
 *    }
 *    public static &lt;T&gt; T[] createAnArray(int size)
 *    {
 *        return (T[])Object[size]; // ClassCastException at runtime
 *    }
 * </pre>
 *
 * <p>Therefore new arrays of generic types can be created with this method, e.g. an arrays
 * of Strings:</p>
 *
 * <pre>
 *    String[] array = ArrayUtils.toArray(""1"", ""2"");
 *    String[] emptyArray = ArrayUtils.&lt;String&gt;toArray();
 * </pre>
 *
 * The method is typically used in scenarios, where the caller itself uses generic types
 * that have to be combined into an array.
 *
 * Note, this method makes only sense to provide arguments of the same type so that the
 * compiler can deduce the type of the array itself. While it is possible to select the
 * type explicitly like in <code>Number[] array = ArrayUtils.<Number>toArray(new
 * Integer(42), new Double(Math.PI))</code>, there is no real advantage to <code>new
 * Number[] {new Integer(42), new Double(Math.PI)}</code> anymore.
 *
 * @param  <T>   the array's element type
 * @param  items the items of the array
 * @return the array
 * @since  3.0
 */
public static <T> T[] toArray(final T... items) {
    return items;
}","public void test453497() throws Throwable {
    Object[] objectArray0 = new Object[0];
    Object[] objectArray1 = ArrayUtils.toArray(objectArray0);
    assertSame(objectArray1, objectArray0);
}",""
"public static double[] removeElement(double[] array, double element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test454498() throws Throwable {
    double[] doubleArray0 = new double[5];
    doubleArray0[3] = (-1420.8574896);
    double[] doubleArray1 = ArrayUtils.removeElement(doubleArray0, (-1420.8574896));
    assertArrayEquals(new double[] { 0.0, 0.0, 0.0, 0.0 }, doubleArray1, 0.01);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, 1.1)            = null
 * ArrayUtils.removeElement([], 1.1)              = []
 * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]
 * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]
 * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"public static float[] add(float[] array, int index, float element) {
    return (float[]) add(array, index, Float.valueOf(element), Float.TYPE);
}","public void test455499() throws Throwable {
    float[] floatArray0 = new float[3];
    // Undeclared exception!
    try {
        ArrayUtils.add(floatArray0, 2203, 0.0F);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // Index: 2203, Length: 3
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}","/**
 * <p>Inserts the specified element at the specified position in the array.
 * Shifts the element currently at that position (if any) and any subsequent
 * elements to the right (adds one to their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array plus the given element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element.</p>
 *
 * <pre>
 * ArrayUtils.add([1.1f], 0, 2.2f)               = [2.2f, 1.1f]
 * ArrayUtils.add([2.3f, 6.4f], 2, 10.5f)        = [2.3f, 6.4f, 10.5f]
 * ArrayUtils.add([2.6f, 6.7f], 0, -4.8f)        = [-4.8f, 2.6f, 6.7f]
 * ArrayUtils.add([2.9f, 6.0f, 0.3f], 2, 1.0f)   = [2.9f, 6.0f, 1.0f, 0.3f]
 * </pre>
 *
 * @param array  the array to add the element to, may be <code>null</code>
 * @param index  the position of the new object
 * @param element  the object to add
 * @return A new array containing the existing elements and the new element
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index > array.length).
 */"
"public static boolean isSameLength(byte[] array1, byte[] array2) {
    if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) {
        return false;
    }
    return true;
}","public void test456500() throws Throwable {
    byte[] byteArray0 = ArrayUtils.add((byte[]) null, (byte) 0);
    boolean boolean0 = ArrayUtils.isSameLength(byteArray0, (byte[]) null);
    assertFalse(boolean0);
}","/**
 * <p>Checks whether two arrays are the same length, treating
 * <code>null</code> arrays as length <code>0</code>.</p>
 *
 * @param array1 the first array, may be <code>null</code>
 * @param array2 the second array, may be <code>null</code>
 * @return <code>true</code> if length of arrays matches, treating
 *  <code>null</code> as an empty array
 */"
"public static double[] add(double[] array, int index, double element) {
    return (double[]) add(array, index, Double.valueOf(element), Double.TYPE);
}","public void test457502() throws Throwable {
    double[] doubleArray0 = new double[6];
    // Undeclared exception!
    try {
        ArrayUtils.add(doubleArray0, (-1), 0.0);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // Index: -1, Length: 6
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}","/**
 * <p>Inserts the specified element at the specified position in the array.
 * Shifts the element currently at that position (if any) and any subsequent
 * elements to the right (adds one to their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array plus the given element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element.</p>
 *
 * <pre>
 * ArrayUtils.add([1.1], 0, 2.2)              = [2.2, 1.1]
 * ArrayUtils.add([2.3, 6.4], 2, 10.5)        = [2.3, 6.4, 10.5]
 * ArrayUtils.add([2.6, 6.7], 0, -4.8)        = [-4.8, 2.6, 6.7]
 * ArrayUtils.add([2.9, 6.0, 0.3], 2, 1.0)    = [2.9, 6.0, 1.0, 0.3]
 * </pre>
 *
 * @param array  the array to add the element to, may be <code>null</code>
 * @param index  the position of the new object
 * @param element  the object to add
 * @return A new array containing the existing elements and the new element
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index > array.length).
 */"
"public static boolean contains(long[] array, long valueToFind) {
    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;
}","public void test458503() throws Throwable {
    long[] longArray0 = new long[5];
    boolean boolean0 = ArrayUtils.contains(longArray0, (-1380L));
    assertFalse(boolean0);
}","/**
 * <p>Checks if the value is in the given array.</p>
 *
 * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>
 *
 * @param array  the array to search through
 * @param valueToFind  the value to find
 * @return <code>true</code> if the array contains the object
 */"
"// byte IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the index of the given value in the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */
public static int indexOf(byte[] array, byte valueToFind) {
    return indexOf(array, valueToFind, 0);
}","public void test459504() throws Throwable {
    byte[] byteArray0 = new byte[5];
    int int0 = ArrayUtils.indexOf(byteArray0, (byte) 19);
    assertEquals((-1), int0);
}",""
"public static boolean[] removeElement(boolean[] array, boolean element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test460505() throws Throwable {
    boolean[] booleanArray0 = new boolean[7];
    boolean[] booleanArray1 = ArrayUtils.removeElement(booleanArray0, false);
    assertEquals(6, booleanArray1.length);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, true)                = null
 * ArrayUtils.removeElement([], true)                  = []
 * ArrayUtils.removeElement([true], false)             = [true]
 * ArrayUtils.removeElement([true, false], false)      = [true]
 * ArrayUtils.removeElement([true, false, true], true) = [false, true]
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"public static int indexOf(double[] array, double valueToFind, double tolerance) {
    return indexOf(array, valueToFind, 0, tolerance);
}","public void test461506() throws Throwable {
    double[] doubleArray0 = new double[4];
    int int0 = ArrayUtils.indexOf(doubleArray0, (double) 0L, 0.0);
    assertEquals(0, int0);
}","/**
 * <p>Finds the index of the given value within a given tolerance in the array.
 * This method will return the index of the first value which falls between the region
 * defined by valueToFind - tolerance and valueToFind + tolerance.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @param tolerance tolerance of the search
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static short[] add(short[] array, int index, short element) {
    return (short[]) add(array, index, Short.valueOf(element), Short.TYPE);
}","public void test462507() throws Throwable {
    ArrayUtils arrayUtils0 = new ArrayUtils();
    short[] shortArray0 = ArrayUtils.add(arrayUtils0.EMPTY_SHORT_ARRAY, 0, (short) (-1447));
    assertArrayEquals(new short[] { (short) (-1447) }, shortArray0);
}","/**
 * <p>Inserts the specified element at the specified position in the array.
 * Shifts the element currently at that position (if any) and any subsequent
 * elements to the right (adds one to their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array plus the given element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element.</p>
 *
 * <pre>
 * ArrayUtils.add([1], 0, 2)         = [2, 1]
 * ArrayUtils.add([2, 6], 2, 10)     = [2, 6, 10]
 * ArrayUtils.add([2, 6], 0, -4)     = [-4, 2, 6]
 * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]
 * </pre>
 *
 * @param array  the array to add the element to, may be <code>null</code>
 * @param index  the position of the new object
 * @param element  the object to add
 * @return A new array containing the existing elements and the new element
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index > array.length).
 */"
"public static float[] removeElement(float[] array, float element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test463508() throws Throwable {
    float[] floatArray0 = new float[3];
    float[] floatArray1 = ArrayUtils.removeElement(floatArray0, (float) (byte) 0);
    assertEquals(2, floatArray1.length);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, 1.1)            = null
 * ArrayUtils.removeElement([], 1.1)              = []
 * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]
 * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]
 * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"public static double[] add(double[] array, double element) {
    double[] newArray = (double[]) copyArrayGrow1(array, Double.TYPE);
    newArray[newArray.length - 1] = element;
    return newArray;
}","public void test464509() throws Throwable {
    ArrayUtils arrayUtils0 = new ArrayUtils();
    double[] doubleArray0 = ArrayUtils.add(arrayUtils0.EMPTY_DOUBLE_ARRAY, (-1.0));
    assertArrayEquals(new double[] { (-1.0) }, doubleArray0, 0.01);
}","/**
 * <p>Copies the given array and adds the given element at the end of the new array.</p>
 *
 * <p>The new array contains the same elements of the input
 * array plus the given element in the last position. The component type of
 * the new array is the same as that of the input array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element.</p>
 *
 * <pre>
 * ArrayUtils.add(null, 0)   = [0]
 * ArrayUtils.add([1], 0)    = [1, 0]
 * ArrayUtils.add([1, 0], 1) = [1, 0, 1]
 * </pre>
 *
 * @param array  the array to copy and add the element to, may be <code>null</code>
 * @param element  the object to add at the last index of the new array
 * @return A new array containing the existing elements plus the new element
 * @since 2.1
 */"
"public static boolean isEquals(Object array1, Object array2) {
    return new EqualsBuilder().append(array1, array2).isEquals();
}","public void test465510() throws Throwable {
    boolean boolean0 = ArrayUtils.isEquals((Object) null, (Object) null);
    assertTrue(boolean0);
}","/**
 * <p>Compares two arrays, using equals(), handling multi-dimensional arrays
 * correctly.</p>
 *
 * <p>Multi-dimensional primitive arrays are also handled correctly by this method.</p>
 *
 * @param array1  the left hand array to compare, may be <code>null</code>
 * @param array2  the right hand array to compare, may be <code>null</code>
 * @return <code>true</code> if the arrays are equal
 */"
"public static byte[] add(byte[] array, int index, byte element) {
    return (byte[]) add(array, index, Byte.valueOf(element), Byte.TYPE);
}","public void test466511() throws Throwable {
    byte[] byteArray0 = new byte[8];
    byte[] byteArray1 = ArrayUtils.add(byteArray0, 1, (byte) (-113));
    assertArrayEquals(new byte[] { (byte) 0, (byte) (-113), (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0, (byte) 0 }, byteArray1);
}","/**
 * <p>Inserts the specified element at the specified position in the array.
 * Shifts the element currently at that position (if any) and any subsequent
 * elements to the right (adds one to their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array plus the given element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element.</p>
 *
 * <pre>
 * ArrayUtils.add([1], 0, 2)         = [2, 1]
 * ArrayUtils.add([2, 6], 2, 3)      = [2, 6, 3]
 * ArrayUtils.add([2, 6], 0, 1)      = [1, 2, 6]
 * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]
 * </pre>
 *
 * @param array  the array to add the element to, may be <code>null</code>
 * @param index  the position of the new object
 * @param element  the object to add
 * @return A new array containing the existing elements and the new element
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index > array.length).
 */"
"public static int[] add(int[] array, int index, int element) {
    return (int[]) add(array, index, Integer.valueOf(element), Integer.TYPE);
}","public void test467512() throws Throwable {
    int[] intArray0 = new int[2];
    int[] intArray1 = ArrayUtils.add(intArray0, 0, (int) (byte) 98);
    assertArrayEquals(new int[] { 98, 0, 0 }, intArray1);
}","/**
 * <p>Inserts the specified element at the specified position in the array.
 * Shifts the element currently at that position (if any) and any subsequent
 * elements to the right (adds one to their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array plus the given element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element.</p>
 *
 * <pre>
 * ArrayUtils.add([1], 0, 2)         = [2, 1]
 * ArrayUtils.add([2, 6], 2, 10)     = [2, 6, 10]
 * ArrayUtils.add([2, 6], 0, -4)     = [-4, 2, 6]
 * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]
 * </pre>
 *
 * @param array  the array to add the element to, may be <code>null</code>
 * @param index  the position of the new object
 * @param element  the object to add
 * @return A new array containing the existing elements and the new element
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index > array.length).
 */"
"public static short[] add(short[] array, short element) {
    short[] newArray = (short[]) copyArrayGrow1(array, Short.TYPE);
    newArray[newArray.length - 1] = element;
    return newArray;
}","public void test468513() throws Throwable {
    short[] shortArray0 = new short[9];
    short[] shortArray1 = ArrayUtils.add(shortArray0, (short) 0);
    assertArrayEquals(new short[] { (short) 0, (short) 0, (short) 0, (short) 0, (short) 0, (short) 0, (short) 0, (short) 0, (short) 0, (short) 0 }, shortArray1);
}","/**
 * <p>Copies the given array and adds the given element at the end of the new array.</p>
 *
 * <p>The new array contains the same elements of the input
 * array plus the given element in the last position. The component type of
 * the new array is the same as that of the input array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element.</p>
 *
 * <pre>
 * ArrayUtils.add(null, 0)   = [0]
 * ArrayUtils.add([1], 0)    = [1, 0]
 * ArrayUtils.add([1, 0], 1) = [1, 0, 1]
 * </pre>
 *
 * @param array  the array to copy and add the element to, may be <code>null</code>
 * @param element  the object to add at the last index of the new array
 * @return A new array containing the existing elements plus the new element
 * @since 2.1
 */"
"public static boolean[] add(boolean[] array, int index, boolean element) {
    return (boolean[]) add(array, index, Boolean.valueOf(element), Boolean.TYPE);
}","public void test469514() throws Throwable {
    boolean[] booleanArray0 = new boolean[3];
    // Undeclared exception!
    try {
        ArrayUtils.add(booleanArray0, 4064, true);
        fail(""Expecting exception: IndexOutOfBoundsException"");
    } catch (IndexOutOfBoundsException e) {
        //
        // Index: 4064, Length: 3
        //
        verifyException(""org.apache.commons.lang3.ArrayUtils"", e);
    }
}","/**
 * <p>Inserts the specified element at the specified position in the array.
 * Shifts the element currently at that position (if any) and any subsequent
 * elements to the right (adds one to their indices).</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array plus the given element on the specified position. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element.</p>
 *
 * <pre>
 * ArrayUtils.add(null, 0, true)          = [true]
 * ArrayUtils.add([true], 0, false)       = [false, true]
 * ArrayUtils.add([false], 1, true)       = [false, true]
 * ArrayUtils.add([true, false], 1, true) = [true, true, false]
 * </pre>
 *
 * @param array  the array to add the element to, may be <code>null</code>
 * @param index  the position of the new object
 * @param element  the object to add
 * @return A new array containing the existing elements and the new element
 * @throws IndexOutOfBoundsException if the index is out of range
 * (index < 0 || index > array.length).
 */"
"public static int lastIndexOf(boolean[] array, boolean valueToFind) {
    return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
}","public void test470515() throws Throwable {
    boolean[] booleanArray0 = new boolean[1];
    int int0 = ArrayUtils.lastIndexOf(booleanArray0, false);
    assertEquals(0, int0);
}","/**
 * <p>Finds the last index of the given value within the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) if
 * <code>null</code> array input.</p>
 *
 * @param array  the array to travers backwords looking for the object, may be <code>null</code>
 * @param valueToFind  the object to find
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static int lastIndexOf(byte[] array, byte valueToFind) {
    return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
}","public void test471516() throws Throwable {
    byte[] byteArray0 = new byte[5];
    int int0 = ArrayUtils.lastIndexOf(byteArray0, (byte) 19);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value within the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to travers backwords looking for the object, may be <code>null</code>
 * @param valueToFind  the object to find
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"// Basic methods handling multi-dimensional arrays
//-----------------------------------------------------------------------
/**
 * <p>Outputs an array as a String, treating <code>null</code> as an empty array.</p>
 *
 * <p>Multi-dimensional arrays are handled correctly, including
 * multi-dimensional primitive arrays.</p>
 *
 * <p>The format is that of Java source code, for example <code>{a,b}</code>.</p>
 *
 * @param array  the array to get a toString for, may be <code>null</code>
 * @return a String representation of the array, '{}' if null array input
 */
public static String toString(Object array) {
    return toString(array, ""{}"");
}","public void test472517() throws Throwable {
    String string0 = ArrayUtils.toString((Object) ""java.lang.String"");
    assertEquals(""java.lang.String"", string0);
}",""
"public static int lastIndexOf(float[] array, float valueToFind) {
    return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
}","public void test473518() throws Throwable {
    float[] floatArray0 = new float[7];
    int int0 = ArrayUtils.lastIndexOf(floatArray0, 0.0F);
    assertEquals(6, int0);
}","/**
 * <p>Finds the last index of the given value within the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to travers backwords looking for the object, may be <code>null</code>
 * @param valueToFind  the object to find
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"// boolean IndexOf
//-----------------------------------------------------------------------
/**
 * <p>Finds the index of the given value in the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to search through for the object, may be <code>null</code>
 * @param valueToFind  the value to find
 * @return the index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */
public static int indexOf(boolean[] array, boolean valueToFind) {
    return indexOf(array, valueToFind, 0);
}","public void test474519() throws Throwable {
    boolean[] booleanArray0 = ArrayUtils.add((boolean[]) null, true);
    int int0 = ArrayUtils.indexOf(booleanArray0, true);
    assertEquals(0, int0);
}",""
"public static <T> T[] removeElement(T[] array, Object element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test475520() throws Throwable {
    Object[] objectArray0 = new Object[3];
    String[] stringArray0 = new String[8];
    String[] stringArray1 = ArrayUtils.removeElement(stringArray0, objectArray0[0]);
    assertEquals(7, stringArray1.length);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, ""a"")            = null
 * ArrayUtils.removeElement([], ""a"")              = []
 * ArrayUtils.removeElement([""a""], ""b"")           = [""a""]
 * ArrayUtils.removeElement([""a"", ""b""], ""a"")      = [""b""]
 * ArrayUtils.removeElement([""a"", ""b"", ""a""], ""a"") = [""b"", ""a""]
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"public static Double[] toObject(double[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return EMPTY_DOUBLE_OBJECT_ARRAY;
    }
    final Double[] result = new Double[array.length];
    for (int i = 0; i < array.length; i++) {
        result[i] = Double.valueOf(array[i]);
    }
    return result;
}","public void test476521() throws Throwable {
    double[] doubleArray0 = new double[0];
    Double[] doubleArray1 = ArrayUtils.toObject(doubleArray0);
    assertNotNull(doubleArray1);
}","/**
 * <p>Converts an array of primitive doubles to objects.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array  a <code>double</code> array
 * @return a <code>Double</code> array, <code>null</code> if null array input
 */"
"public static int lastIndexOf(Object[] array, Object objectToFind) {
    return lastIndexOf(array, objectToFind, Integer.MAX_VALUE);
}","public void test476522() throws Throwable {
    double[] doubleArray0 = new double[0];
    Double[] doubleArray1 = ArrayUtils.toObject(doubleArray0);
    int int0 = ArrayUtils.lastIndexOf((Object[]) doubleArray1, (Object) null);
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given object within the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to travers backwords looking for the object, may be <code>null</code>
 * @param objectToFind  the object to find, may be <code>null</code>
 * @return the last index of the object within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
"public static short[] removeElement(short[] array, short element) {
    int index = indexOf(array, element);
    if (index == INDEX_NOT_FOUND) {
        return clone(array);
    }
    return remove(array, index);
}","public void test477523() throws Throwable {
    short[] shortArray0 = new short[8];
    shortArray0[7] = (short) 64;
    short[] shortArray1 = ArrayUtils.removeElement(shortArray0, (short) 64);
    assertArrayEquals(new short[] { (short) 0, (short) 0, (short) 0, (short) 0, (short) 0, (short) 0, (short) 0 }, shortArray1);
}","/**
 * <p>Removes the first occurrence of the specified element from the
 * specified array. All subsequent elements are shifted to the left
 * (substracts one from their indices). If the array doesn't contains
 * such an element, no elements are removed from the array.</p>
 *
 * <p>This method returns a new array with the same elements of the input
 * array except the first occurrence of the specified element. The component
 * type of the returned array is always the same as that of the input
 * array.</p>
 *
 * <pre>
 * ArrayUtils.removeElement(null, 1)      = null
 * ArrayUtils.removeElement([], 1)        = []
 * ArrayUtils.removeElement([1], 2)       = [1]
 * ArrayUtils.removeElement([1, 3], 1)    = [3]
 * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]
 * </pre>
 *
 * @param array  the array to remove the element from, may be <code>null</code>
 * @param element  the element to be removed
 * @return A new array containing the existing elements except the first
 *         occurrence of the specified element.
 * @since 2.1
 */"
"public static int[] add(int[] array, int element) {
    int[] newArray = (int[]) copyArrayGrow1(array, Integer.TYPE);
    newArray[newArray.length - 1] = element;
    return newArray;
}","public void test478524() throws Throwable {
    Byte[] byteArray0 = new Byte[3];
    Byte byte0 = new Byte((byte) 120);
    byteArray0[0] = byte0;
    int[] intArray0 = ArrayUtils.add((int[]) null, (int) byteArray0[0]);
    assertArrayEquals(new int[] { 120 }, intArray0);
}","/**
 * <p>Copies the given array and adds the given element at the end of the new array.</p>
 *
 * <p>The new array contains the same elements of the input
 * array plus the given element in the last position. The component type of
 * the new array is the same as that of the input array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element.</p>
 *
 * <pre>
 * ArrayUtils.add(null, 0)   = [0]
 * ArrayUtils.add([1], 0)    = [1, 0]
 * ArrayUtils.add([1, 0], 1) = [1, 0, 1]
 * </pre>
 *
 * @param array  the array to copy and add the element to, may be <code>null</code>
 * @param element  the object to add at the last index of the new array
 * @return A new array containing the existing elements plus the new element
 * @since 2.1
 */"
"public static boolean contains(double[] array, double valueToFind) {
    return indexOf(array, valueToFind) != INDEX_NOT_FOUND;
}","public void test479526() throws Throwable {
    ArrayUtils arrayUtils0 = new ArrayUtils();
    boolean boolean0 = ArrayUtils.contains(arrayUtils0.EMPTY_DOUBLE_ARRAY, (double) (-1));
    assertFalse(boolean0);
}","/**
 * <p>Checks if the value is in the given array.</p>
 *
 * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>
 *
 * @param array  the array to search through
 * @param valueToFind  the value to find
 * @return <code>true</code> if the array contains the object
 */"
"public static long[] add(long[] array, long element) {
    long[] newArray = (long[]) copyArrayGrow1(array, Long.TYPE);
    newArray[newArray.length - 1] = element;
    return newArray;
}","public void test480527() throws Throwable {
    long[] longArray0 = new long[0];
    long[] longArray1 = ArrayUtils.add(longArray0, 0, (long) 0);
    long[] longArray2 = ArrayUtils.add(longArray1, (-1L));
    assertArrayEquals(new long[] { 0L, (-1L) }, longArray2);
}","/**
 * <p>Copies the given array and adds the given element at the end of the new array.</p>
 *
 * <p>The new array contains the same elements of the input
 * array plus the given element in the last position. The component type of
 * the new array is the same as that of the input array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element.</p>
 *
 * <pre>
 * ArrayUtils.add(null, 0)   = [0]
 * ArrayUtils.add([1], 0)    = [1, 0]
 * ArrayUtils.add([1, 0], 1) = [1, 0, 1]
 * </pre>
 *
 * @param array  the array to copy and add the element to, may be <code>null</code>
 * @param element  the object to add at the last index of the new array
 * @return A new array containing the existing elements plus the new element
 * @since 2.1
 */"
"public static char[] add(char[] array, char element) {
    char[] newArray = (char[]) copyArrayGrow1(array, Character.TYPE);
    newArray[newArray.length - 1] = element;
    return newArray;
}","public void test481528() throws Throwable {
    char[] charArray0 = new char[3];
    char[] charArray1 = ArrayUtils.add(charArray0, '^');
    assertArrayEquals(new char[] { '\u0000', '\u0000', '\u0000', '^' }, charArray1);
}","/**
 * <p>Copies the given array and adds the given element at the end of the new array.</p>
 *
 * <p>The new array contains the same elements of the input
 * array plus the given element in the last position. The component type of
 * the new array is the same as that of the input array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element.</p>
 *
 * <pre>
 * ArrayUtils.add(null, '0')       = ['0']
 * ArrayUtils.add(['1'], '0')      = ['1', '0']
 * ArrayUtils.add(['1', '0'], '1') = ['1', '0', '1']
 * </pre>
 *
 * @param array  the array to copy and add the element to, may be <code>null</code>
 * @param element  the object to add at the last index of the new array
 * @return A new array containing the existing elements plus the new element
 * @since 2.1
 */"
"public static float[] add(float[] array, float element) {
    float[] newArray = (float[]) copyArrayGrow1(array, Float.TYPE);
    newArray[newArray.length - 1] = element;
    return newArray;
}","public void test482529() throws Throwable {
    float[] floatArray0 = new float[7];
    float[] floatArray1 = ArrayUtils.add(floatArray0, 0.0F);
    assertArrayEquals(new float[] { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F }, floatArray1, 0.01F);
}","/**
 * <p>Copies the given array and adds the given element at the end of the new array.</p>
 *
 * <p>The new array contains the same elements of the input
 * array plus the given element in the last position. The component type of
 * the new array is the same as that of the input array.</p>
 *
 * <p>If the input array is <code>null</code>, a new one element array is returned
 *  whose component type is the same as the element.</p>
 *
 * <pre>
 * ArrayUtils.add(null, 0)   = [0]
 * ArrayUtils.add([1], 0)    = [1, 0]
 * ArrayUtils.add([1, 0], 1) = [1, 0, 1]
 * </pre>
 *
 * @param array  the array to copy and add the element to, may be <code>null</code>
 * @param element  the object to add at the last index of the new array
 * @return A new array containing the existing elements plus the new element
 * @since 2.1
 */"
"public static int lastIndexOf(int[] array, int valueToFind) {
    return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);
}","public void test483530() throws Throwable {
    int[] intArray0 = new int[3];
    int int0 = ArrayUtils.lastIndexOf(intArray0, (-672));
    assertEquals((-1), int0);
}","/**
 * <p>Finds the last index of the given value within the array.</p>
 *
 * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
 *
 * @param array  the array to travers backwords looking for the object, may be <code>null</code>
 * @param valueToFind  the object to find
 * @return the last index of the value within the array,
 *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
 */"
