focal_method,test_prefix,docstring
"//-----------------------------------------------------------------------
/**
 * <p>Gets a date/time formatter instance using the specified style
 * in the default time zone and locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle) {
    return getDateTimeInstance(dateStyle, timeStyle, null, null);
}","public void test0000() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    assertEquals(1, FastDateFormat.LONG);
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0005() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    assertEquals(50, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0006() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0007() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    assertEquals(""EEEE, MMMM d, yyyy h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"protected void init() {
    List rulesList = parsePattern();
    mRules = (Rule[]) rulesList.toArray(new Rule[rulesList.size()]);
    int len = 0;
    for (int i = mRules.length; --i >= 0; ) {
        len += mRules[i].estimateLength();
    }
    mMaxLengthEstimate = len;
}","public void test0008() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    fastDateFormat0.init();
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Initializes the instance for first use.</p>
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test00012() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    fastDateFormat0.init();
    assertEquals(50, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test00013() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    fastDateFormat0.init();
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test00014() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    fastDateFormat0.init();
    assertEquals(""EEEE, MMMM d, yyyy h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Gets a formatter instance using the default pattern in the
 * default locale.</p>
 *
 * @return a date/time formatter
 */
public static FastDateFormat getInstance() {
    return getInstance(getDefaultPattern(), null, null);
}","public void test00115() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    assertEquals(0, FastDateFormat.FULL);
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test00120() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test00121() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test00122() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"protected String parseToken(String pattern, int[] indexRef) {
    StringBuffer buf = new StringBuffer();
    int i = indexRef[0];
    int length = pattern.length();
    char c = pattern.charAt(i);
    if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {
        // Scan a run of the same character, which indicates a time
        // pattern.
        buf.append(c);
        while (i + 1 < length) {
            char peek = pattern.charAt(i + 1);
            if (peek == c) {
                buf.append(c);
                i++;
            } else {
                break;
            }
        }
    } else {
        // This will identify token as text.
        buf.append('\'');
        boolean inLiteral = false;
        for (; i < length; i++) {
            c = pattern.charAt(i);
            if (c == '\'') {
                if (i + 1 < length && pattern.charAt(i + 1) == '\'') {
                    // '' is treated as escaped '
                    i++;
                    buf.append(c);
                } else {
                    inLiteral = !inLiteral;
                }
            } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {
                i--;
                break;
            } else {
                buf.append(c);
            }
        }
    }
    indexRef[0] = i;
    return buf.toString();
}","public void test00123() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    int[] intArray0 = new int[6];
    String string0 = fastDateFormat0.parseToken(""#fgg0XqGjy$K(D"", intArray0);
    assertEquals(""'#"", string0);
}","/**
 * <p>Performs the parsing of tokens.</p>
 *
 * @param pattern  the pattern
 * @param indexRef  index references
 * @return parsed token
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test00129() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    int[] intArray0 = new int[6];
    String string0 = fastDateFormat0.parseToken(""#fgg0XqGjy$K(D"", intArray0);
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test00130() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    int[] intArray0 = new int[6];
    String string0 = fastDateFormat0.parseToken(""#fgg0XqGjy$K(D"", intArray0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test00131() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    int[] intArray0 = new int[6];
    String string0 = fastDateFormat0.parseToken(""#fgg0XqGjy$K(D"", intArray0);
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = (FastDateFormat) cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test00244() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofHoursMinutes(0, 0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test00256() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofHoursMinutes(0, 0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test00257() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofHoursMinutes(0, 0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test00258() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofHoursMinutes(0, 0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Parse the pattern
//-----------------------------------------------------------------------
/**
 * <p>Returns a list of Rules given a pattern.</p>
 *
 * @return a <code>List</code> of Rule objects
 * @throws IllegalArgumentException if pattern is invalid
 */
protected List parsePattern() {
    DateFormatSymbols symbols = new DateFormatSymbols(mLocale);
    List rules = new ArrayList();
    String[] ERAs = symbols.getEras();
    String[] months = symbols.getMonths();
    String[] shortMonths = symbols.getShortMonths();
    String[] weekdays = symbols.getWeekdays();
    String[] shortWeekdays = symbols.getShortWeekdays();
    String[] AmPmStrings = symbols.getAmPmStrings();
    int length = mPattern.length();
    int[] indexRef = new int[1];
    for (int i = 0; i < length; i++) {
        indexRef[0] = i;
        String token = parseToken(mPattern, indexRef);
        i = indexRef[0];
        int tokenLen = token.length();
        if (tokenLen == 0) {
            break;
        }
        Rule rule;
        char c = token.charAt(0);
        switch(c) {
            case // era designator (text)
            'G':
                rule = new TextField(Calendar.ERA, ERAs);
                break;
            case // year (number)
            'y':
                if (tokenLen >= 4) {
                    rule = selectNumberRule(Calendar.YEAR, tokenLen);
                } else {
                    rule = TwoDigitYearField.INSTANCE;
                }
                break;
            case // month in year (text and number)
            'M':
                if (tokenLen >= 4) {
                    rule = new TextField(Calendar.MONTH, months);
                } else if (tokenLen == 3) {
                    rule = new TextField(Calendar.MONTH, shortMonths);
                } else if (tokenLen == 2) {
                    rule = TwoDigitMonthField.INSTANCE;
                } else {
                    rule = UnpaddedMonthField.INSTANCE;
                }
                break;
            case // day in month (number)
            'd':
                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);
                break;
            case // hour in am/pm (number, 1..12)
            'h':
                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));
                break;
            case // hour in day (number, 0..23)
            'H':
                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);
                break;
            case // minute in hour (number)
            'm':
                rule = selectNumberRule(Calendar.MINUTE, tokenLen);
                break;
            case // second in minute (number)
            's':
                rule = selectNumberRule(Calendar.SECOND, tokenLen);
                break;
            case // millisecond (number)
            'S':
                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);
                break;
            case // day in week (text)
            'E':
                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);
                break;
            case // day in year (number)
            'D':
                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);
                break;
            case // day of week in month (number)
            'F':
                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);
                break;
            case // week in year (number)
            'w':
                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);
                break;
            case // week in month (number)
            'W':
                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);
                break;
            case // am/pm marker (text)
            'a':
                rule = new TextField(Calendar.AM_PM, AmPmStrings);
                break;
            case // hour in day (1..24)
            'k':
                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));
                break;
            case // hour in am/pm (0..11)
            'K':
                rule = selectNumberRule(Calendar.HOUR, tokenLen);
                break;
            case // time zone (text)
            'z':
                if (tokenLen >= 4) {
                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.LONG);
                } else {
                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.SHORT);
                }
                break;
            case // time zone (value)
            'Z':
                if (tokenLen == 1) {
                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;
                } else {
                    rule = TimeZoneNumberRule.INSTANCE_COLON;
                }
                break;
            case // literal text
            '\'':
                String sub = token.substring(1);
                if (sub.length() == 1) {
                    rule = new CharacterLiteral(sub.charAt(0));
                } else {
                    rule = new StringLiteral(sub);
                }
                break;
            default:
                throw new IllegalArgumentException(""Illegal pattern component: "" + token);
        }
        rules.add(rule);
    }
    return rules;
}","public void test00259() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofHoursMinutes(0, 0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    List list0 = fastDateFormat0.parsePattern();
    assertEquals(2, FastDateFormat.MEDIUM);
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test00271() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofHoursMinutes(0, 0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    List list0 = fastDateFormat0.parsePattern();
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test00272() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofHoursMinutes(0, 0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    List list0 = fastDateFormat0.parsePattern();
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test00273() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofHoursMinutes(0, 0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    List list0 = fastDateFormat0.parsePattern();
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test003101() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofHoursMinutes(0, 0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    boolean boolean0 = fastDateFormat0.getTimeZoneOverridesCalendar();
    assertTrue(boolean0);
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test003113() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofHoursMinutes(0, 0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    boolean boolean0 = fastDateFormat0.getTimeZoneOverridesCalendar();
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test003114() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofHoursMinutes(0, 0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    boolean boolean0 = fastDateFormat0.getTimeZoneOverridesCalendar();
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test003115() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofHoursMinutes(0, 0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.JAPANESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", timeZone0, locale0);
    boolean boolean0 = fastDateFormat0.getTimeZoneOverridesCalendar();
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets the time zone display name, using a cache for performance.</p>
 *
 * @param tz  the zone to query
 * @param daylight  true if daylight savings
 * @param style  the style to use <code>TimeZone.LONG</code>
 *  or <code>TimeZone.SHORT</code>
 * @param locale  the locale to use
 * @return the textual name of the time zone
 */
static synchronized String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {
    Object key = new TimeZoneDisplayKey(tz, daylight, style, locale);
    String value = (String) cTimeZoneDisplayCache.get(key);
    if (value == null) {
        // This is a very slow call, so cache the results.
        value = tz.getDisplayName(daylight, style, locale);
        cTimeZoneDisplayCache.put(key, value);
    }
    return value;
}","public void test004126() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.MIN;
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    Locale locale0 = Locale.ENGLISH;
    String string0 = FastDateFormat.getTimeZoneDisplay(timeZone0, false, 0, locale0);
    assertEquals(""GMT-18:00"", string0);
}",""
"public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {
    return getDateInstance(style, timeZone, null);
}","public void test005141() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(2596, ""0\""ED.Cahr1Cm/{Vt"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test005151() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(2596, ""0\""ED.Cahr1Cm/{Vt"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    assertEquals(""EEEE, MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test005152() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(2596, ""0\""ED.Cahr1Cm/{Vt"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    assertEquals(31, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test005153() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(2596, ""0\""ED.Cahr1Cm/{Vt"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public TimeZone getTimeZone() {
    return mTimeZone;
}","public void test005154() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(2596, ""0\""ED.Cahr1Cm/{Vt"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    TimeZone timeZone0 = fastDateFormat0.getTimeZone();
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets the time zone used by this formatter.</p>
 *
 * <p>This zone is always used for <code>Date</code> formatting.
 * If a <code>Calendar</code> is passed in to be formatted, the
 * time zone on that may be used depending on
 * {@link #getTimeZoneOverridesCalendar()}.</p>
 *
 * @return the time zone
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test005164() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(2596, ""0\""ED.Cahr1Cm/{Vt"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    TimeZone timeZone0 = fastDateFormat0.getTimeZone();
    assertEquals(""EEEE, MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test005165() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(2596, ""0\""ED.Cahr1Cm/{Vt"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    TimeZone timeZone0 = fastDateFormat0.getTimeZone();
    assertEquals(31, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test005166() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(2596, ""0\""ED.Cahr1Cm/{Vt"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    TimeZone timeZone0 = fastDateFormat0.getTimeZone();
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test005169() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(2596, ""0\""ED.Cahr1Cm/{Vt"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0);
    TimeZone timeZone0 = fastDateFormat0.getTimeZone();
    assertEquals(""java.util.SimpleTimeZone[id=0\""ED.Cahr1Cm/{Vt,offset=2596,dstSavings=3600000,useDaylight=false,startYear=0,startMode=0,startMonth=0,startDay=0,startDayOfWeek=0,startTime=0,startTimeMode=0,endMode=0,endMonth=0,endDay=0,endDayOfWeek=0,endTime=0,endTimeMode=0]"", timeZone0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public static FastDateFormat getTimeInstance(int style, TimeZone timeZone) {
    return getTimeInstance(style, timeZone, null);
}","public void test006180() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a time formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted time
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test006190() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0);
    assertEquals(""h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test006191() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test006192() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0);
    assertEquals(23, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public TimeZone getTimeZone() {
    return mTimeZone;
}","public void test006193() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0);
    TimeZone timeZone0 = fastDateFormat0.getTimeZone();
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets the time zone used by this formatter.</p>
 *
 * <p>This zone is always used for <code>Date</code> formatting.
 * If a <code>Calendar</code> is passed in to be formatted, the
 * time zone on that may be used depending on
 * {@link #getTimeZoneOverridesCalendar()}.</p>
 *
 * @return the time zone
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test006203() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0);
    TimeZone timeZone0 = fastDateFormat0.getTimeZone();
    assertEquals(""h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test006204() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0);
    TimeZone timeZone0 = fastDateFormat0.getTimeZone();
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test006205() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0);
    TimeZone timeZone0 = fastDateFormat0.getTimeZone();
    assertEquals(23, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test006209() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0);
    TimeZone timeZone0 = fastDateFormat0.getTimeZone();
    assertEquals(""java.util.SimpleTimeZone[id=IH2,offset=0,dstSavings=3600000,useDaylight=false,startYear=0,startMode=0,startMonth=0,startDay=0,startDayOfWeek=0,startTime=0,startTimeMode=0,endMode=0,endMonth=0,endDay=0,endDayOfWeek=0,endTime=0,endTimeMode=0]"", timeZone0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test007220() throws Throwable {
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test007231() throws Throwable {
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test007232() throws Throwable {
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test007233() throws Throwable {
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test007234() throws Throwable {
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    String string0 = fastDateFormat0.getPattern();
    assertEquals("""", string0);
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test007246() throws Throwable {
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    String string0 = fastDateFormat0.getPattern();
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test007247() throws Throwable {
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    String string0 = fastDateFormat0.getPattern();
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test007248() throws Throwable {
    Locale locale0 = Locale.GERMANY;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    String string0 = fastDateFormat0.getPattern();
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test008256() throws Throwable {
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test008267() throws Throwable {
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test008268() throws Throwable {
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test008269() throws Throwable {
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test008270() throws Throwable {
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    assertEquals(0, int0);
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test008281() throws Throwable {
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test008282() throws Throwable {
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test008283() throws Throwable {
    Locale locale0 = Locale.CANADA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = (FastDateFormat) cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test009297() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3193, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""yyyy'\uB144' M'\uC6D4' d'\uC77C' EEEE a h'\uC2DC' mm'\uBD84' ss'\uCD08' z"", (TimeZone) simpleTimeZone0, locale0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test009313() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3193, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""yyyy'\uB144' M'\uC6D4' d'\uC77C' EEEE a h'\uC2DC' mm'\uBD84' ss'\uCD08' z"", (TimeZone) simpleTimeZone0, locale0);
    assertEquals(46, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test009314() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3193, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""yyyy'\uB144' M'\uC6D4' d'\uC77C' EEEE a h'\uC2DC' mm'\uBD84' ss'\uCD08' z"", (TimeZone) simpleTimeZone0, locale0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test009315() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3193, """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""yyyy'\uB144' M'\uC6D4' d'\uC77C' EEEE a h'\uC2DC' mm'\uBD84' ss'\uCD08' z"", (TimeZone) simpleTimeZone0, locale0);
    assertEquals(""yyyy'\uB144' M'\uC6D4' d'\uC77C' EEEE a h'\uC2DC' mm'\uBD84' ss'\uCD08' z"", fastDateFormat0.getPattern());
}",""
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test010316() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test010321() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test010322() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test010323() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test011331() throws Throwable {
    Locale locale0 = Locale.ITALIAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""'XETJC"", locale0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test011342() throws Throwable {
    Locale locale0 = Locale.ITALIAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""'XETJC"", locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test011343() throws Throwable {
    Locale locale0 = Locale.ITALIAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""'XETJC"", locale0);
    assertEquals(""'XETJC"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test011344() throws Throwable {
    Locale locale0 = Locale.ITALIAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""'XETJC"", locale0);
    assertEquals(5, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {
    return getDateInstance(style, timeZone, null);
}","public void test012345() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(1, (TimeZone) null);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test012350() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(1, (TimeZone) null);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test012351() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(1, (TimeZone) null);
    assertEquals(20, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test012352() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(1, (TimeZone) null);
    assertEquals(""MMMM d, yyyy"", fastDateFormat0.getPattern());
}",""
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = (FastDateFormat) cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test013360() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test013371() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test013372() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test013373() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public StringBuffer format(Date date, StringBuffer buf) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, buf);
}","public void test013375() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    MockDate mockDate0 = new MockDate();
    StringBuffer stringBuffer0 = fastDateFormat0.format((Date) mockDate0, (StringBuffer) null);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Formats a <code>Date</code> object into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param date  the date to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test013386() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    MockDate mockDate0 = new MockDate();
    StringBuffer stringBuffer0 = fastDateFormat0.format((Date) mockDate0, (StringBuffer) null);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test013387() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    MockDate mockDate0 = new MockDate();
    StringBuffer stringBuffer0 = fastDateFormat0.format((Date) mockDate0, (StringBuffer) null);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test013388() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    MockDate mockDate0 = new MockDate();
    StringBuffer stringBuffer0 = fastDateFormat0.format((Date) mockDate0, (StringBuffer) null);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test013389() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    MockDate mockDate0 = new MockDate();
    StringBuffer stringBuffer0 = fastDateFormat0.format((Date) mockDate0, (StringBuffer) null);
    assertEquals(""Fri Feb 14 20:21:21 GMT 2014"", mockDate0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public String format(Date date) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test014412() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    MockDate mockDate0 = new MockDate();
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals("""", string0);
}","/**
 * <p>Formats a <code>Date</code> object.</p>
 *
 * @param date  the date to format
 * @return the formatted string
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test014424() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    MockDate mockDate0 = new MockDate();
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test014425() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    MockDate mockDate0 = new MockDate();
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test014426() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    MockDate mockDate0 = new MockDate();
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test014427() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    MockDate mockDate0 = new MockDate();
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals(""Fri Feb 14 20:21:21 GMT 2014"", mockDate0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a formatter instance using the default pattern in the
 * default locale.</p>
 *
 * @return a date/time formatter
 */
public static FastDateFormat getInstance() {
    return getInstance(getDefaultPattern(), null, null);
}","public void test015436() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    Calendar calendar0 = MockCalendar.getInstance();
    assertNotNull(calendar0);
}",""
"public StringBuffer format(Calendar calendar, StringBuffer buf) {
    if (mTimeZoneForced) {
        calendar = (Calendar) calendar.clone();
        calendar.setTimeZone(mTimeZone);
    }
    return applyRules(calendar, buf);
}","public void test015444() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    Calendar calendar0 = MockCalendar.getInstance();
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""A:="");
    StringBuffer stringBuffer1 = fastDateFormat0.format(calendar0, stringBuffer0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Formats a <code>Calendar</code> object into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param calendar  the calendar to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test015449() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    Calendar calendar0 = MockCalendar.getInstance();
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""A:="");
    StringBuffer stringBuffer1 = fastDateFormat0.format(calendar0, stringBuffer0);
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test015450() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    Calendar calendar0 = MockCalendar.getInstance();
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""A:="");
    StringBuffer stringBuffer1 = fastDateFormat0.format(calendar0, stringBuffer0);
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test015451() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    Calendar calendar0 = MockCalendar.getInstance();
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""A:="");
    StringBuffer stringBuffer1 = fastDateFormat0.format(calendar0, stringBuffer0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test016462() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test016467() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test016468() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test016469() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public String format(Calendar calendar) {
    return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test016479() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    Calendar calendar0 = mockSimpleDateFormat0.getCalendar();
    String string0 = fastDateFormat0.format(calendar0);
    assertEquals("""", string0);
}","/**
 * <p>Formats a <code>Calendar</code> object.</p>
 *
 * @param calendar  the calendar to format
 * @return the formatted string
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test016485() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    Calendar calendar0 = mockSimpleDateFormat0.getCalendar();
    String string0 = fastDateFormat0.format(calendar0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test016486() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    Calendar calendar0 = mockSimpleDateFormat0.getCalendar();
    String string0 = fastDateFormat0.format(calendar0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test016487() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    Calendar calendar0 = mockSimpleDateFormat0.getCalendar();
    String string0 = fastDateFormat0.format(calendar0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test017502() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test017513() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test017514() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test017515() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public String format(long millis) {
    return format(new Date(millis));
}","public void test017516() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    String string0 = fastDateFormat0.format(2480L);
    assertEquals("""", string0);
}","/**
 * <p>Formats a millisecond <code>long</code> value.</p>
 *
 * @param millis  the millisecond value to format
 * @return the formatted string
 * @since 2.1
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test017528() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    String string0 = fastDateFormat0.format(2480L);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test017529() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    String string0 = fastDateFormat0.format(2480L);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test017530() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", locale0);
    String string0 = fastDateFormat0.format(2480L);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public static FastDateFormat getDateInstance(int style, Locale locale) {
    return getDateInstance(style, null, locale);
}","public void test018538() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, locale0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test018549() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test018550() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, locale0);
    assertEquals(""yyyy'\uB144' M'\uC6D4' d'\uC77C' EEEE"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test018551() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, locale0);
    assertEquals(19, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"protected String parseToken(String pattern, int[] indexRef) {
    StringBuffer buf = new StringBuffer();
    int i = indexRef[0];
    int length = pattern.length();
    char c = pattern.charAt(i);
    if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {
        // Scan a run of the same character, which indicates a time
        // pattern.
        buf.append(c);
        while (i + 1 < length) {
            char peek = pattern.charAt(i + 1);
            if (peek == c) {
                buf.append(c);
                i++;
            } else {
                break;
            }
        }
    } else {
        // This will identify token as text.
        buf.append('\'');
        boolean inLiteral = false;
        for (; i < length; i++) {
            c = pattern.charAt(i);
            if (c == '\'') {
                if (i + 1 < length && pattern.charAt(i + 1) == '\'') {
                    // '' is treated as escaped '
                    i++;
                    buf.append(c);
                } else {
                    inLiteral = !inLiteral;
                }
            } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {
                i--;
                break;
            } else {
                buf.append(c);
            }
        }
    }
    indexRef[0] = i;
    return buf.toString();
}","public void test018552() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, locale0);
    int[] intArray0 = new int[3];
    // Undeclared exception!
    try {
        fastDateFormat0.parseToken("""", intArray0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * <p>Performs the parsing of tokens.</p>
 *
 * @param pattern  the pattern
 * @param indexRef  index references
 * @return parsed token
 */"
"protected String parseToken(String pattern, int[] indexRef) {
    StringBuffer buf = new StringBuffer();
    int i = indexRef[0];
    int length = pattern.length();
    char c = pattern.charAt(i);
    if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {
        // Scan a run of the same character, which indicates a time
        // pattern.
        buf.append(c);
        while (i + 1 < length) {
            char peek = pattern.charAt(i + 1);
            if (peek == c) {
                buf.append(c);
                i++;
            } else {
                break;
            }
        }
    } else {
        // This will identify token as text.
        buf.append('\'');
        boolean inLiteral = false;
        for (; i < length; i++) {
            c = pattern.charAt(i);
            if (c == '\'') {
                if (i + 1 < length && pattern.charAt(i + 1) == '\'') {
                    // '' is treated as escaped '
                    i++;
                    buf.append(c);
                } else {
                    inLiteral = !inLiteral;
                }
            } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {
                i--;
                break;
            } else {
                buf.append(c);
            }
        }
    }
    indexRef[0] = i;
    return buf.toString();
}","public void test019561() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    // Undeclared exception!
    try {
        fastDateFormat0.parseToken("""", (int[]) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Performs the parsing of tokens.</p>
 *
 * @param pattern  the pattern
 * @param indexRef  index references
 * @return parsed token
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets the time zone display name, using a cache for performance.</p>
 *
 * @param tz  the zone to query
 * @param daylight  true if daylight savings
 * @param style  the style to use <code>TimeZone.LONG</code>
 *  or <code>TimeZone.SHORT</code>
 * @param locale  the locale to use
 * @return the textual name of the time zone
 */
static synchronized String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {
    Object key = new TimeZoneDisplayKey(tz, daylight, style, locale);
    String value = (String) cTimeZoneDisplayCache.get(key);
    if (value == null) {
        // This is a very slow call, so cache the results.
        value = tz.getDisplayName(daylight, style, locale);
        cTimeZoneDisplayCache.put(key, value);
    }
    return value;
}","public void test020569() throws Throwable {
    Locale locale0 = Locale.GERMAN;
    // Undeclared exception!
    try {
        FastDateFormat.getTimeZoneDisplay((TimeZone) null, false, 0, locale0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}",""
"//-----------------------------------------------------------------------
/**
 * <p>Gets the time zone display name, using a cache for performance.</p>
 *
 * @param tz  the zone to query
 * @param daylight  true if daylight savings
 * @param style  the style to use <code>TimeZone.LONG</code>
 *  or <code>TimeZone.SHORT</code>
 * @param locale  the locale to use
 * @return the textual name of the time zone
 */
static synchronized String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {
    Object key = new TimeZoneDisplayKey(tz, daylight, style, locale);
    String value = (String) cTimeZoneDisplayCache.get(key);
    if (value == null) {
        // This is a very slow call, so cache the results.
        value = tz.getDisplayName(daylight, style, locale);
        cTimeZoneDisplayCache.put(key, value);
    }
    return value;
}","public void test021578() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""n;P:<ffkD7dzT1_@'"");
    Locale locale0 = new Locale(""n;P:<ffkD7dzT1_@'"");
    // Undeclared exception!
    try {
        FastDateFormat.getTimeZoneDisplay(timeZone0, false, 13, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal style: 13
        //
        verifyException(""java.util.TimeZone"", e);
    }
}",""
"public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = new Integer(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale != null) {
        key = new Pair(key, locale);
    }
    FastDateFormat format = (FastDateFormat) cTimeInstanceCache.get(key);
    if (format == null) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getTimeInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cTimeInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test022588() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.forLanguageTag(""A:="");
    // Undeclared exception!
    try {
        FastDateFormat.getTimeInstance(2623, timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style 2623
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a time formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted time
 * @param locale  optional locale, overrides system locale
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 */"
"public static FastDateFormat getTimeInstance(int style, TimeZone timeZone) {
    return getTimeInstance(style, timeZone, null);
}","public void test023595() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    // Undeclared exception!
    try {
        FastDateFormat.getTimeInstance(15, (TimeZone) simpleTimeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style 15
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a time formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted time
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */"
"public static FastDateFormat getTimeInstance(int style, Locale locale) {
    return getTimeInstance(style, null, locale);
}","public void test024603() throws Throwable {
    Locale locale0 = Locale.GERMAN;
    // Undeclared exception!
    try {
        FastDateFormat.getTimeInstance(739, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style 739
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a time formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a time formatter instance using the specified style in the
 * default time zone and locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getTimeInstance(int style) {
    return getTimeInstance(style, null, null);
}","public void test025604() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getTimeInstance(100);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style 100
        //
        verifyException(""java.text.DateFormat"", e);
    }
}",""
"public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone) {
    return getDateTimeInstance(dateStyle, timeStyle, timeZone, null);
}","public void test026607() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""FastDateFormat["");
    // Undeclared exception!
    try {
        FastDateFormat.getDateTimeInstance(16, 1668, timeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style 1668
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date/time formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a date/time formatter instance using the specified style
 * in the default time zone and locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle) {
    return getDateTimeInstance(dateStyle, timeStyle, null, null);
}","public void test027608() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getDateTimeInstance(13, 31);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal time style 31
        //
        verifyException(""java.text.DateFormat"", e);
    }
}",""
"public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {
    return getDateInstance(style, timeZone, null);
}","public void test028615() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone((-186), """");
    // Undeclared exception!
    try {
        FastDateFormat.getDateInstance(1667, (TimeZone) simpleTimeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style 1667
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"public static FastDateFormat getDateInstance(int style, Locale locale) {
    return getDateInstance(style, null, locale);
}","public void test029622() throws Throwable {
    Locale locale0 = new Locale(""elDq# !hTb"");
    // Undeclared exception!
    try {
        FastDateFormat.getDateInstance(1502, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style 1502
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a date formatter instance using the specified style in the
 * default time zone and locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getDateInstance(int style) {
    return getDateInstance(style, null, null);
}","public void test030623() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getDateInstance((-2289));
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style -2289
        //
        verifyException(""java.text.DateFormat"", e);
    }
}",""
"public StringBuffer format(Date date, StringBuffer buf) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, buf);
}","public void test031633() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate(10, 835, 0);
    // Undeclared exception!
    try {
        fastDateFormat0.format((Date) mockDate0, (StringBuffer) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat$UnpaddedMonthField"", e);
    }
}","/**
 * <p>Formats a <code>Date</code> object into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param date  the date to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"public String format(Date date) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test032642() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    // Undeclared exception!
    try {
        fastDateFormat0.format((Date) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * <p>Formats a <code>Date</code> object.</p>
 *
 * @param date  the date to format
 * @return the formatted string
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a time formatter instance using the specified style in the
 * default time zone and locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */
public static FastDateFormat getTimeInstance(int style) {
    return getTimeInstance(style, null, null);
}","public void test033643() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0);
    assertEquals(2, FastDateFormat.MEDIUM);
}",""
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test033648() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0);
    assertEquals(""h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test033649() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0);
    assertEquals(18, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test033650() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public StringBuffer format(long millis, StringBuffer buf) {
    return format(new Date(millis), buf);
}","public void test033651() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0);
    // Undeclared exception!
    try {
        fastDateFormat0.format(0L, (StringBuffer) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat$UnpaddedNumberField"", e);
    }
}","/**
 * <p>Formats a milliseond <code>long</code> value into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param millis  the millisecond value to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 * @since 2.1
 */"
"// Constructor
//-----------------------------------------------------------------------
/**
 * <p>Constructs a new FastDateFormat.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  time zone to use, <code>null</code> means use
 *  default for <code>Date</code> and value within for
 *  <code>Calendar</code>
 * @param locale  locale, <code>null</code> means use system
 *  default
 * @throws IllegalArgumentException if pattern is invalid or
 *  <code>null</code>
 */
protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {
    super();
    if (pattern == null) {
        throw new IllegalArgumentException(""The pattern must not be null"");
    }
    mPattern = pattern;
    mTimeZoneForced = (timeZone != null);
    if (timeZone == null) {
        timeZone = TimeZone.getDefault();
    }
    mTimeZone = timeZone;
    mLocaleForced = (locale != null);
    if (locale == null) {
        locale = Locale.getDefault();
    }
    mLocale = locale;
}","public void test034661() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.ITALIAN;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    assertEquals(3, FastDateFormat.SHORT);
}",""
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test034673() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.ITALIAN;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test034674() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.ITALIAN;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test034675() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.ITALIAN;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public String format(long millis) {
    return format(new Date(millis));
}","public void test034676() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("""");
    Locale locale0 = Locale.ITALIAN;
    FastDateFormat fastDateFormat0 = new FastDateFormat("""", timeZone0, locale0);
    // Undeclared exception!
    try {
        fastDateFormat0.format(0L);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Formats a millisecond <code>long</code> value.</p>
 *
 * @param millis  the millisecond value to format
 * @return the formatted string
 * @since 2.1
 */"
"protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {
    Rule[] rules = mRules;
    int len = mRules.length;
    for (int i = 0; i < len; i++) {
        rules[i].appendTo(buf, calendar);
    }
    return buf;
}","public void test035688() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    StringBuffer stringBuffer0 = new StringBuffer(""No date time pattern for locale: "");
    // Undeclared exception!
    try {
        fastDateFormat0.applyRules((Calendar) null, stringBuffer0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat$TextField"", e);
    }
}","/**
 * <p>Performs the formatting by applying the rules to the
 * specified calendar.</p>
 *
 * @param calendar  the calendar to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"public int hashCode() {
    int total = 0;
    total += mPattern.hashCode();
    total += mTimeZone.hashCode();
    total += (mTimeZoneForced ? 1 : 0);
    total += mLocale.hashCode();
    total += (mLocaleForced ? 1 : 0);
    return total;
}","public void test036697() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    fastDateFormat0.hashCode();
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Returns a hashcode compatible with equals.</p>
 *
 * @return a hashcode compatible with equals
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test036701() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    fastDateFormat0.hashCode();
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test036702() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    fastDateFormat0.hashCode();
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test036703() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    fastDateFormat0.hashCode();
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public static FastDateFormat getTimeInstance(int style, TimeZone timeZone) {
    return getTimeInstance(style, timeZone, null);
}","public void test037707() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets a time formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted time
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 * @since 2.1
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test037713() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0);
    assertEquals(""h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test037714() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test037715() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0);
    assertEquals(17, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public int hashCode() {
    int total = 0;
    total += mPattern.hashCode();
    total += mTimeZone.hashCode();
    total += (mTimeZoneForced ? 1 : 0);
    total += mLocale.hashCode();
    total += (mLocaleForced ? 1 : 0);
    return total;
}","public void test037716() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0);
    fastDateFormat0.hashCode();
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Returns a hashcode compatible with equals.</p>
 *
 * @return a hashcode compatible with equals
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test037721() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0);
    fastDateFormat0.hashCode();
    assertEquals(""h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test037722() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0);
    fastDateFormat0.hashCode();
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test037723() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0);
    fastDateFormat0.hashCode();
    assertEquals(17, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test038736() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat0);
    assertTrue(boolean0);
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test038742() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat0);
    assertEquals(17, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test038743() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat0);
    assertEquals(""h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test038744() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test039751() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, (-1), (-1), 0, (-1), 0, 4682, (-2182), (-2182), 9);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test039761() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, (-1), (-1), 0, (-1), 0, 4682, (-2182), (-2182), 9);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test039762() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, (-1), (-1), 0, (-1), 0, 4682, (-2182), (-2182), 9);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test039763() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, (-1), (-1), 0, (-1), 0, 4682, (-2182), (-2182), 9);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public StringBuffer format(Calendar calendar, StringBuffer buf) {
    if (mTimeZoneForced) {
        calendar = (Calendar) calendar.clone();
        calendar.setTimeZone(mTimeZone);
    }
    return applyRules(calendar, buf);
}","public void test039775() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, (-1), (-1), 0, (-1), 0, 4682, (-2182), (-2182), 9);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0);
    Locale locale0 = Locale.ITALY;
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) """");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Calendar) mockGregorianCalendar0, stringBuffer0);
    assertEquals(0, FastDateFormat.FULL);
}","/**
 * <p>Formats a <code>Calendar</code> object into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param calendar  the calendar to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test039785() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, (-1), (-1), 0, (-1), 0, 4682, (-2182), (-2182), 9);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0);
    Locale locale0 = Locale.ITALY;
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) """");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Calendar) mockGregorianCalendar0, stringBuffer0);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test039786() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, (-1), (-1), 0, (-1), 0, 4682, (-2182), (-2182), 9);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0);
    Locale locale0 = Locale.ITALY;
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) """");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Calendar) mockGregorianCalendar0, stringBuffer0);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test039787() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, (-1), (-1), 0, (-1), 0, 4682, (-2182), (-2182), 9);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0);
    Locale locale0 = Locale.ITALY;
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) """");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Calendar) mockGregorianCalendar0, stringBuffer0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test039794() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, (-1), (-1), 0, (-1), 0, 4682, (-2182), (-2182), 9);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) simpleTimeZone0);
    Locale locale0 = Locale.ITALY;
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) """");
    StringBuffer stringBuffer1 = fastDateFormat0.format((Calendar) mockGregorianCalendar0, stringBuffer0);
    assertEquals(""org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=1392409281320,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\""GMT\"",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=2,minimalDaysInFirstWeek=4,ERA=1,YEAR=2014,MONTH=1,WEEK_OF_YEAR=7,WEEK_OF_MONTH=2,DAY_OF_MONTH=14,DAY_OF_YEAR=45,DAY_OF_WEEK=6,DAY_OF_WEEK_IN_MONTH=2,AM_PM=1,HOUR=8,HOUR_OF_DAY=20,MINUTE=21,SECOND=21,MILLISECOND=320,ZONE_OFFSET=0,DST_OFFSET=0]"", mockGregorianCalendar0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public StringBuffer format(Calendar calendar, StringBuffer buf) {
    if (mTimeZoneForced) {
        calendar = (Calendar) calendar.clone();
        calendar.setTimeZone(mTimeZone);
    }
    return applyRules(calendar, buf);
}","public void test040820() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    Locale locale0 = Locale.US;
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(locale0);
    // Undeclared exception!
    try {
        fastDateFormat0.format((Calendar) mockGregorianCalendar0, (StringBuffer) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat$UnpaddedMonthField"", e);
    }
}","/**
 * <p>Formats a <code>Calendar</code> object into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param calendar  the calendar to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone, Locale locale) {
    Object key = new Pair(new Integer(dateStyle), new Integer(timeStyle));
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale != null) {
        key = new Pair(key, locale);
    }
    FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);
    if (format == null) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cDateTimeInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date time pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test041821() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getDateTimeInstance((-1105), 0, (TimeZone) null, (Locale) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style -1105
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date/time formatter instance using the specified style,
 * time zone and locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 */"
"public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone, Locale locale) {
    Object key = new Pair(new Integer(dateStyle), new Integer(timeStyle));
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale != null) {
        key = new Pair(key, locale);
    }
    FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);
    if (format == null) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cDateTimeInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date time pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test042831() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("" 9JtTd.$cJi'MXwGE"");
    Locale locale0 = Locale.KOREA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 2, timeZone0, locale0);
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Gets a date/time formatter instance using the specified style,
 * time zone and locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test042843() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("" 9JtTd.$cJi'MXwGE"");
    Locale locale0 = Locale.KOREA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 2, timeZone0, locale0);
    assertEquals(""yyyy'\uB144' M'\uC6D4' d'\uC77C' EEEE a h:mm:ss"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test042844() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("" 9JtTd.$cJi'MXwGE"");
    Locale locale0 = Locale.KOREA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 2, timeZone0, locale0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test042845() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("" 9JtTd.$cJi'MXwGE"");
    Locale locale0 = Locale.KOREA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 2, timeZone0, locale0);
    assertEquals(33, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone, Locale locale) {
    Object key = new Pair(new Integer(dateStyle), new Integer(timeStyle));
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale != null) {
        key = new Pair(key, locale);
    }
    FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);
    if (format == null) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cDateTimeInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date time pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test043853() throws Throwable {
    Locale locale0 = new Locale("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 2, (TimeZone) null, locale0);
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Gets a date/time formatter instance using the specified style,
 * time zone and locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test043864() throws Throwable {
    Locale locale0 = new Locale("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 2, (TimeZone) null, locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test043865() throws Throwable {
    Locale locale0 = new Locale("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 2, (TimeZone) null, locale0);
    assertEquals(45, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test043866() throws Throwable {
    Locale locale0 = new Locale("""");
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 2, (TimeZone) null, locale0);
    assertEquals(""EEEE, MMMM d, yyyy h:mm:ss a"", fastDateFormat0.getPattern());
}",""
"public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = new Integer(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale != null) {
        key = new Pair(key, locale);
    }
    FastDateFormat format = (FastDateFormat) cTimeInstanceCache.get(key);
    if (format == null) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getTimeInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cTimeInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test044880() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, 0, 0, 45, 0, 45, 0, 1);
    Locale locale0 = Locale.CHINA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a time formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted time
 * @param locale  optional locale, overrides system locale
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test044896() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, 0, 0, 45, 0, 45, 0, 1);
    Locale locale0 = Locale.CHINA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    assertEquals(""ahh'\u65F6'mm'\u5206'ss'\u79D2' z"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test044897() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, 0, 0, 45, 0, 45, 0, 1);
    Locale locale0 = Locale.CHINA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test044898() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, 0, 0, 45, 0, 45, 0, 1);
    Locale locale0 = Locale.CHINA;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) simpleTimeZone0, locale0);
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = new Integer(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale != null) {
        key = new Pair(key, locale);
    }
    FastDateFormat format = (FastDateFormat) cTimeInstanceCache.get(key);
    if (format == null) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getTimeInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cTimeInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test045906() throws Throwable {
    Locale locale0 = new Locale("""", """", """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) null, locale0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a time formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted time
 * @param locale  optional locale, overrides system locale
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test045917() throws Throwable {
    Locale locale0 = new Locale("""", """", """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) null, locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test045918() throws Throwable {
    Locale locale0 = new Locale("""", """", """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) null, locale0);
    assertEquals(18, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test045919() throws Throwable {
    Locale locale0 = new Locale("""", """", """");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, (TimeZone) null, locale0);
    assertEquals(""h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = new Integer(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale != null) {
        key = new Pair(key, locale);
    }
    FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);
    if (format == null) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cDateInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test046933() throws Throwable {
    Locale locale0 = Locale.GERMANY;
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, 7, 2, 3, (-424), 0, 3, 1102, 7, 118);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0, locale0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a date formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test046949() throws Throwable {
    Locale locale0 = Locale.GERMANY;
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, 7, 2, 3, (-424), 0, 3, 1102, 7, 118);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0, locale0);
    assertEquals(32, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test046950() throws Throwable {
    Locale locale0 = Locale.GERMANY;
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, 7, 2, 3, (-424), 0, 3, 1102, 7, 118);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0, locale0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test046951() throws Throwable {
    Locale locale0 = Locale.GERMANY;
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, """", 0, 0, 7, 2, 3, (-424), 0, 3, 1102, 7, 118);
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, (TimeZone) simpleTimeZone0, locale0);
    assertEquals(""EEEE, d. MMMM yyyy"", fastDateFormat0.getPattern());
}",""
"public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = new Integer(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale != null) {
        key = new Pair(key, locale);
    }
    FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);
    if (format == null) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cDateInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test047952() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getDateInstance(103, (TimeZone) null, (Locale) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style 103
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 */"
"public StringBuffer format(Date date, StringBuffer buf) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, buf);
}","public void test048965() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate(1, (-1), (-416));
    StringBuffer stringBuffer0 = new StringBuffer();
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Formats a <code>Date</code> object into the
 * supplied <code>StringBuffer</code>.</p>
 *
 * @param date  the date to format
 * @param buf  the buffer to format into
 * @return the specified string buffer
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test048970() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate(1, (-1), (-416));
    StringBuffer stringBuffer0 = new StringBuffer();
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test048971() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate(1, (-1), (-416));
    StringBuffer stringBuffer0 = new StringBuffer();
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test048972() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate(1, (-1), (-416));
    StringBuffer stringBuffer0 = new StringBuffer();
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test048973() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate(1, (-1), (-416));
    StringBuffer stringBuffer0 = new StringBuffer();
    StringBuffer stringBuffer1 = fastDateFormat0.format((Date) mockDate0, stringBuffer0);
    assertEquals(""Tue Oct 10 00:00:00 GMT 1899"", mockDate0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public String format(Date date) {
    Calendar c = new GregorianCalendar(mTimeZone);
    c.setTime(date);
    return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test049989() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate(4120L);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals(""1/1/70 12:00 AM"", string0);
}","/**
 * <p>Formats a <code>Date</code> object.</p>
 *
 * @param date  the date to format
 * @return the formatted string
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test049995() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate(4120L);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test049996() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate(4120L);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test049997() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate(4120L);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test049998() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    MockDate mockDate0 = new MockDate(4120L);
    String string0 = fastDateFormat0.format((Date) mockDate0);
    assertEquals(""Thu Jan 01 00:00:04 GMT 1970"", mockDate0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, Locale locale) {
    return getDateTimeInstance(dateStyle, timeStyle, null, locale);
}","public void test050999() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, (Locale) null);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a date/time formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0501004() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, (Locale) null);
    assertEquals(50, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0501005() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, (Locale) null);
    assertEquals(""EEEE, MMMM d, yyyy h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0501006() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, (Locale) null);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public String format(Calendar calendar) {
    return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test0501008() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, (Locale) null);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 1466, 1, 0, (-1));
    String string0 = fastDateFormat0.format((Calendar) mockGregorianCalendar0);
    assertEquals(""Friday, February 28, 0122 11:59:00 PM GMT"", string0);
}","/**
 * <p>Formats a <code>Calendar</code> object.</p>
 *
 * @param calendar  the calendar to format
 * @return the formatted string
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0501014() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, (Locale) null);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 1466, 1, 0, (-1));
    String string0 = fastDateFormat0.format((Calendar) mockGregorianCalendar0);
    assertEquals(50, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0501015() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, (Locale) null);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 1466, 1, 0, (-1));
    String string0 = fastDateFormat0.format((Calendar) mockGregorianCalendar0);
    assertEquals(""EEEE, MMMM d, yyyy h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0501016() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, (Locale) null);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 1466, 1, 0, (-1));
    String string0 = fastDateFormat0.format((Calendar) mockGregorianCalendar0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test0501017() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, (Locale) null);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(0, 1466, 1, 0, (-1));
    String string0 = fastDateFormat0.format((Calendar) mockGregorianCalendar0);
    assertEquals(""org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=-58312224060000,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\""GMT\"",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=122,MONTH=1,WEEK_OF_YEAR=9,WEEK_OF_MONTH=5,DAY_OF_MONTH=28,DAY_OF_YEAR=59,DAY_OF_WEEK=6,DAY_OF_WEEK_IN_MONTH=4,AM_PM=1,HOUR=11,HOUR_OF_DAY=23,MINUTE=59,SECOND=0,MILLISECOND=0,ZONE_OFFSET=0,DST_OFFSET=0]"", mockGregorianCalendar0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test0511024() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""sa"");
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0511029() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""sa"");
    assertEquals(""sa"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0511030() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""sa"");
    assertEquals(6, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0511031() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""sa"");
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test0511032() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""sa"");
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance(""sa"", timeZone0);
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0511038() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""sa"");
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance(""sa"", timeZone0);
    assertTrue(fastDateFormat1.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0511039() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""sa"");
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance(""sa"", timeZone0);
    assertEquals(""sa"", fastDateFormat1.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0511040() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""sa"");
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance(""sa"", timeZone0);
    assertEquals(6, fastDateFormat1.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test0511042() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""sa"");
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance(""sa"", timeZone0);
    assertFalse(fastDateFormat1.equals((Object) fastDateFormat0));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test0511043() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""sa"");
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance(""sa"", timeZone0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat1);
    assertFalse(boolean0);
}",""
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0511053() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""sa"");
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance(""sa"", timeZone0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat1);
    assertEquals(""sa"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0511054() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""sa"");
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance(""sa"", timeZone0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat1);
    assertEquals(6, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0511055() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""sa"");
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance(""sa"", timeZone0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat1);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0511056() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""sa"");
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance(""sa"", timeZone0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat1);
    assertTrue(fastDateFormat1.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0511057() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""sa"");
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance(""sa"", timeZone0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat1);
    assertEquals(""sa"", fastDateFormat1.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0511058() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""sa"");
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance(""sa"", timeZone0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat1);
    assertEquals(6, fastDateFormat1.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test0511061() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""sa"");
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance(""sa"", timeZone0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat1);
    assertFalse(fastDateFormat0.equals((Object) fastDateFormat1));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test0511062() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""sa"");
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance(""sa"", timeZone0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat1);
    assertFalse(fastDateFormat1.equals((Object) fastDateFormat0));
}",""
"public static FastDateFormat getDateInstance(int style, Locale locale) {
    return getDateInstance(style, null, locale);
}","public void test0521078() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0);
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(0, locale0);
    assertEquals(3, FastDateFormat.SHORT);
}","/**
 * <p>Gets a date formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param style  date style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date formatter
 * @throws IllegalArgumentException if the Locale has no date
 *  pattern defined
 * @since 2.1
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0521089() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0);
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(0, locale0);
    assertFalse(fastDateFormat1.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0521090() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0);
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(0, locale0);
    assertEquals(17, fastDateFormat1.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0521091() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0);
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(0, locale0);
    assertEquals(""yyyy'\u5E74'M'\u6708'd'\u65E5' EEEE"", fastDateFormat1.getPattern());
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test0521093() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0);
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(0, locale0);
    assertFalse(fastDateFormat1.equals((Object) fastDateFormat0));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test0521094() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0);
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(0, locale0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat1);
    assertFalse(boolean0);
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0521103() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0);
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(0, locale0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat1);
    assertEquals(18, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0521104() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0);
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(0, locale0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat1);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0521105() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0);
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(0, locale0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat1);
    assertEquals(""h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0521112() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0);
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(0, locale0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat1);
    assertFalse(fastDateFormat1.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0521113() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0);
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(0, locale0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat1);
    assertEquals(17, fastDateFormat1.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0521114() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0);
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(0, locale0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat1);
    assertEquals(""yyyy'\u5E74'M'\u6708'd'\u65E5' EEEE"", fastDateFormat1.getPattern());
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test0521117() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0);
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(0, locale0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat1);
    assertFalse(fastDateFormat0.equals((Object) fastDateFormat1));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test0521118() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0);
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(0, locale0);
    boolean boolean0 = fastDateFormat0.equals(fastDateFormat1);
    assertFalse(fastDateFormat1.equals((Object) fastDateFormat0));
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test0531140() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    boolean boolean0 = fastDateFormat0.equals((Object) null);
    assertFalse(boolean0);
}",""
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0531151() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    boolean boolean0 = fastDateFormat0.equals((Object) null);
    assertEquals("""", fastDateFormat0.getPattern());
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0531152() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    boolean boolean0 = fastDateFormat0.equals((Object) null);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0531153() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""", (TimeZone) null, locale0);
    boolean boolean0 = fastDateFormat0.equals((Object) null);
    assertEquals(0, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public String format(Calendar calendar) {
    return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test0541182() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    Calendar calendar0 = mockSimpleDateFormat0.getCalendar();
    String string0 = fastDateFormat0.format(calendar0);
    assertEquals(""8:21:21 PM GMT+00:00"", string0);
}","/**
 * <p>Formats a <code>Calendar</code> object.</p>
 *
 * @param calendar  the calendar to format
 * @return the formatted string
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0541193() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    Calendar calendar0 = mockSimpleDateFormat0.getCalendar();
    String string0 = fastDateFormat0.format(calendar0);
    assertEquals(23, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0541194() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    Calendar calendar0 = mockSimpleDateFormat0.getCalendar();
    String string0 = fastDateFormat0.format(calendar0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0541195() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""IH2"");
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0);
    MockSimpleDateFormat mockSimpleDateFormat0 = new MockSimpleDateFormat();
    Calendar calendar0 = mockSimpleDateFormat0.getCalendar();
    String string0 = fastDateFormat0.format(calendar0);
    assertEquals(""h:mm:ss a z"", fastDateFormat0.getPattern());
}",""
"public Locale getLocale() {
    return mLocale;
}","public void test0551211() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    Locale locale0 = fastDateFormat0.getLocale();
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets the locale used by this formatter.</p>
 *
 * @return the locale
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0551216() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    Locale locale0 = fastDateFormat0.getLocale();
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0551217() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    Locale locale0 = fastDateFormat0.getLocale();
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0551218() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    Locale locale0 = fastDateFormat0.getLocale();
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"// Format methods
//-----------------------------------------------------------------------
/**
 * <p>Formats a <code>Date</code>, <code>Calendar</code> or
 * <code>Long</code> (milliseconds) object.</p>
 *
 * @param obj  the object to format
 * @param toAppendTo  the buffer to append to
 * @param pos  the position - ignored
 * @return the buffer passed in
 */
public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
    if (obj instanceof Date) {
        return format((Date) obj, toAppendTo);
    } else if (obj instanceof Calendar) {
        return format((Calendar) obj, toAppendTo);
    } else if (obj instanceof Long) {
        return format(((Long) obj).longValue(), toAppendTo);
    } else {
        throw new IllegalArgumentException(""Unknown class: "" + (obj == null ? ""<null>"" : obj.getClass().getName()));
    }
}","public void test0551232() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    Locale locale0 = fastDateFormat0.getLocale();
    StringBuffer stringBuffer0 = new StringBuffer("""");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 0);
    // Undeclared exception!
    try {
        fastDateFormat0.format((Object) locale0, stringBuffer0, fieldPosition0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unknown class: java.util.Locale
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0561248() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    Long long0 = new Long((-1150L));
    AttributedCharacterIterator attributedCharacterIterator0 = fastDateFormat0.formatToCharacterIterator(long0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0561249() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    Long long0 = new Long((-1150L));
    AttributedCharacterIterator attributedCharacterIterator0 = fastDateFormat0.formatToCharacterIterator(long0);
    assertEquals(21, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0561250() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    Long long0 = new Long((-1150L));
    AttributedCharacterIterator attributedCharacterIterator0 = fastDateFormat0.formatToCharacterIterator(long0);
    assertEquals(""M/d/yy h:mm a"", fastDateFormat0.getPattern());
}",""
"public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, Locale locale) {
    return getDateTimeInstance(dateStyle, timeStyle, null, locale);
}","public void test0571263() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Gets a date/time formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0571274() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0571275() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    assertEquals(41, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0571276() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    assertEquals(""yyyy'\uB144' M'\uC6D4' d'\uC77C' EEEE a h'\uC2DC' mm'\uBD84' ss'\uCD08' z"", fastDateFormat0.getPattern());
}",""
"// Format methods
//-----------------------------------------------------------------------
/**
 * <p>Formats a <code>Date</code>, <code>Calendar</code> or
 * <code>Long</code> (milliseconds) object.</p>
 *
 * @param obj  the object to format
 * @param toAppendTo  the buffer to append to
 * @param pos  the position - ignored
 * @return the buffer passed in
 */
public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
    if (obj instanceof Date) {
        return format((Date) obj, toAppendTo);
    } else if (obj instanceof Calendar) {
        return format((Calendar) obj, toAppendTo);
    } else if (obj instanceof Long) {
        return format(((Long) obj).longValue(), toAppendTo);
    } else {
        throw new IllegalArgumentException(""Unknown class: "" + (obj == null ? ""<null>"" : obj.getClass().getName()));
    }
}","public void test0571285() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(11, 3, 2298);
    StringBuffer stringBuffer0 = new StringBuffer(3);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Object) mockGregorianCalendar0, stringBuffer0, fieldPosition0);
    assertEquals(1, FastDateFormat.LONG);
}",""
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0571296() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(11, 3, 2298);
    StringBuffer stringBuffer0 = new StringBuffer(3);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Object) mockGregorianCalendar0, stringBuffer0, fieldPosition0);
    assertFalse(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0571297() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(11, 3, 2298);
    StringBuffer stringBuffer0 = new StringBuffer(3);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Object) mockGregorianCalendar0, stringBuffer0, fieldPosition0);
    assertEquals(41, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0571298() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(11, 3, 2298);
    StringBuffer stringBuffer0 = new StringBuffer(3);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Object) mockGregorianCalendar0, stringBuffer0, fieldPosition0);
    assertEquals(""yyyy'\uB144' M'\uC6D4' d'\uC77C' EEEE a h'\uC2DC' mm'\uBD84' ss'\uCD08' z"", fastDateFormat0.getPattern());
}",""
"public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test0571299() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    MockGregorianCalendar mockGregorianCalendar0 = new MockGregorianCalendar(11, 3, 2298);
    StringBuffer stringBuffer0 = new StringBuffer(3);
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0);
    StringBuffer stringBuffer1 = fastDateFormat0.format((Object) mockGregorianCalendar0, stringBuffer0, fieldPosition0);
    assertEquals(""org.evosuite.runtime.mock.java.util.MockGregorianCalendar[time=-61614000000000,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\""GMT\"",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=17,MONTH=6,WEEK_OF_YEAR=29,WEEK_OF_MONTH=3,DAY_OF_MONTH=15,DAY_OF_YEAR=196,DAY_OF_WEEK=5,DAY_OF_WEEK_IN_MONTH=3,AM_PM=0,HOUR=0,HOUR_OF_DAY=0,MINUTE=0,SECOND=0,MILLISECOND=0,ZONE_OFFSET=0,DST_OFFSET=0]"", mockGregorianCalendar0.toString());
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"// Format methods
//-----------------------------------------------------------------------
/**
 * <p>Formats a <code>Date</code>, <code>Calendar</code> or
 * <code>Long</code> (milliseconds) object.</p>
 *
 * @param obj  the object to format
 * @param toAppendTo  the buffer to append to
 * @param pos  the position - ignored
 * @return the buffer passed in
 */
public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
    if (obj instanceof Date) {
        return format((Date) obj, toAppendTo);
    } else if (obj instanceof Calendar) {
        return format((Calendar) obj, toAppendTo);
    } else if (obj instanceof Long) {
        return format(((Long) obj).longValue(), toAppendTo);
    } else {
        throw new IllegalArgumentException(""Unknown class: "" + (obj == null ? ""<null>"" : obj.getClass().getName()));
    }
}","public void test0581341() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""1970\uB144 1\uC6D4 1\uC77C \uBAA9\uC694\uC77C \uC624\uC804 12\uC2DC 00\uBD84 00\uCD08 GMT"");
    FieldPosition fieldPosition0 = new FieldPosition((-542));
    // Undeclared exception!
    try {
        fastDateFormat0.format((Object) null, stringBuffer0, fieldPosition0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unknown class: <null>
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}",""
"public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {
    Object key = new Integer(style);
    if (timeZone != null) {
        key = new Pair(key, timeZone);
    }
    if (locale != null) {
        key = new Pair(key, locale);
    }
    FastDateFormat format = (FastDateFormat) cTimeInstanceCache.get(key);
    if (format == null) {
        if (locale == null) {
            locale = Locale.getDefault();
        }
        try {
            SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getTimeInstance(style, locale);
            String pattern = formatter.toPattern();
            format = getInstance(pattern, timeZone, locale);
            cTimeInstanceCache.put(key, format);
        } catch (ClassCastException ex) {
            throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
        }
    }
    return format;
}","public void test0591361() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3193, """");
    ParsePosition parsePosition0 = new ParsePosition(1);
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0, locale0);
    assertEquals(2, FastDateFormat.MEDIUM);
}","/**
 * <p>Gets a time formatter instance using the specified style, time
 * zone and locale.</p>
 *
 * @param style  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted time
 * @param locale  optional locale, overrides system locale
 * @return a localized standard time formatter
 * @throws IllegalArgumentException if the Locale has no time
 *  pattern defined
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0591377() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3193, """");
    ParsePosition parsePosition0 = new ParsePosition(1);
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0, locale0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0591378() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3193, """");
    ParsePosition parsePosition0 = new ParsePosition(1);
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0, locale0);
    assertEquals(16, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0591379() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3193, """");
    ParsePosition parsePosition0 = new ParsePosition(1);
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(1, (TimeZone) simpleTimeZone0, locale0);
    assertEquals(""a h'\uC2DC' mm'\uBD84' ss'\uCD08'"", fastDateFormat0.getPattern());
}",""
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test0601380() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""HmEwv:<G%uK-&"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: v
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test0611381() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""kv"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: v
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test0621382() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""|~#+%|r<"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: r
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test0631383() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance("".hp7jH`/1_94X/S#"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: p
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test0641390() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(0, ""org.apache.commons.lang.time.FastDateFormat$TwoDigitMonthField"");
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""org.apache.commons.lang.time.FastDateFormat$TwoDigitMonthField"", (TimeZone) simpleTimeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: o
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test0651391() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""<null>"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: n
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test0661392() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""F|&l"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: l
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test0671393() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""*y%[}sjm@y"", (Locale) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: j
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test0681394() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""$h]hz[im+["", (TimeZone) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: i
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = (FastDateFormat) cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test0691397() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    // Undeclared exception!
    try {
        FastDateFormat.getInstance("".y^g%D]]q!ZT"", timeZone0, (Locale) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: g
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test0701398() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""@ye"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: e
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test0711406() throws Throwable {
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""&c+c"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: c
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = (FastDateFormat) cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test0721414() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone(""km\""=7X{|rJ"");
    Locale locale0 = new Locale(""4|<9 ,H| Do&/"", ""IUgG1T[MPmf6/yGLlvX"", ""km\""=7X{|rJ"");
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""km\""=7X{|rJ"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: X
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test0731419() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.MIN;
    ZoneId zoneId0 = ZoneId.systemDefault();
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""W9"", timeZone0);
    assertEquals(1, FastDateFormat.LONG);
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0731425() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.MIN;
    ZoneId zoneId0 = ZoneId.systemDefault();
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""W9"", timeZone0);
    assertTrue(fastDateFormat0.getTimeZoneOverridesCalendar());
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0731426() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.MIN;
    ZoneId zoneId0 = ZoneId.systemDefault();
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""W9"", timeZone0);
    assertEquals(5, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0731427() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.MIN;
    ZoneId zoneId0 = ZoneId.systemDefault();
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance(""W9"", timeZone0);
    assertEquals(""W9"", fastDateFormat0.getPattern());
}",""
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test0741428() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance("")?V4+K`M;J xIF"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: V
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test0751436() throws Throwable {
    Locale locale0 = Locale.ITALIAN;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""-kU[P"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: U
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test0761442() throws Throwable {
    Locale locale0 = new Locale(""No date time pattern for locale: "", ""S<qo?y0"");
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""S<qo?y0"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: q
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test0771445() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""{363RHP)"", timeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: R
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {
    FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);
    FastDateFormat format = (FastDateFormat) cInstanceCache.get(emptyFormat);
    if (format == null) {
        format = emptyFormat;
        // convert shell format into usable one
        format.init();
        // this is OK!
        cInstanceCache.put(format, format);
    }
    return format;
}","public void test0781455() throws Throwable {
    TimeZone timeZone0 = TimeZone.getTimeZone("" at index: "");
    Locale locale0 = Locale.KOREA;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""Q\""~ejLg;=`mCF'-$"", timeZone0, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: Q
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern, time zone
 * and locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 *  or <code>null</code>
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test0791456() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""L"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: L
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test0801464() throws Throwable {
    Locale locale0 = Locale.KOREA;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance("" 9JtTd.$cJi'MXwGE"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: J
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test0811465() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""@I5wyU}+$"", (Locale) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: I
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test0821466() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""\u4E0A\u534812\u65F600\u520600\u79D2 GMT+00:00"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: T
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {
    return getInstance(pattern, timeZone, null);
}","public void test0831473() throws Throwable {
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone((-2446), """");
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""FastDateFormat[EEEE, MMMM d, yyyy h:mm:ss a z]"", (TimeZone) simpleTimeZone0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: t
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * time zone.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test0841474() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""C/"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: C
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern) {
    return getInstance(pattern, null, null);
}","public void test0851475() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""B67F8w -"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: B
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern in the
 * default locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test0861476() throws Throwable {
    Locale locale0 = Locale.CHINA;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance((String) null, locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // The pattern must not be null
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone) {
    return getDateTimeInstance(dateStyle, timeStyle, timeZone, null);
}","public void test0871478() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    List list0 = fastDateFormat0.parsePattern();
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3193, """");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    assertNotNull(fastDateFormat1);
}","/**
 * <p>Gets a date/time formatter instance using the specified style and
 * time zone in the default locale.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param timeZone  optional time zone, overrides time zone of
 *  formatted date
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */"
"public String format(long millis) {
    return format(new Date(millis));
}","public void test0871479() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    List list0 = fastDateFormat0.parsePattern();
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3193, """");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    fastDateFormat0.getPattern();
    ParsePosition parsePosition0 = new ParsePosition(1);
    fastDateFormat1.parseObject("""", parsePosition0);
    fastDateFormat0.format((long) 0);
    String string0 = fastDateFormat0.format((long) 1);
    assertEquals(""1970\uB144 1\uC6D4 1\uC77C \uBAA9\uC694\uC77C \uC624\uC804 12\uC2DC 00\uBD84 00\uCD08 GMT"", string0);
}","/**
 * <p>Formats a millisecond <code>long</code> value.</p>
 *
 * @param millis  the millisecond value to format
 * @return the formatted string
 * @since 2.1
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0871480() throws Throwable {
    Locale locale0 = Locale.KOREAN;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0, locale0);
    List list0 = fastDateFormat0.parsePattern();
    SimpleTimeZone simpleTimeZone0 = new SimpleTimeZone(3193, """");
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateTimeInstance(3, 0, (TimeZone) simpleTimeZone0);
    fastDateFormat0.getPattern();
    ParsePosition parsePosition0 = new ParsePosition(1);
    fastDateFormat1.parseObject("""", parsePosition0);
    fastDateFormat0.format((long) 0);
    String string0 = fastDateFormat0.format((long) 1);
    fastDateFormat1.getPattern();
    assertEquals(34, fastDateFormat1.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0881481() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    ZoneOffset.ofHoursMinutes(0, 0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    ZoneId.getAvailableZoneIds();
    timeZone0.setID(""sa"");
    zoneOffset0.getRules();
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""sa"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 0);
    decimalFormat0.format((long) 1, stringBuffer0, fieldPosition0);
    Locale locale0 = Locale.UK;
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, locale0);
    assertEquals(""HH:mm:ss 'o''clock' z"", fastDateFormat0.getPattern());
}",""
"// Basics
//-----------------------------------------------------------------------
/**
 * <p>Compares two objects for equality.</p>
 *
 * @param obj  the object to compare to
 * @return <code>true</code> if equal
 */
public boolean equals(Object obj) {
    if (obj instanceof FastDateFormat == false) {
        return false;
    }
    FastDateFormat other = (FastDateFormat) obj;
    if ((mPattern == other.mPattern || mPattern.equals(other.mPattern)) && (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) && (mLocale == other.mLocale || mLocale.equals(other.mLocale)) && (mTimeZoneForced == other.mTimeZoneForced) && (mLocaleForced == other.mLocaleForced)) {
        return true;
    }
    return false;
}","public void test0891482() throws Throwable {
    FastDateFormat.getTimeInstance(0);
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    locale0.getUnicodeLocaleAttributes();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, locale0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(2);
    assertFalse(fastDateFormat1.equals((Object) fastDateFormat0));
}",""
"// Accessors
//-----------------------------------------------------------------------
/**
 * <p>Gets the pattern used by this formatter.</p>
 *
 * @return the pattern, {@link java.text.SimpleDateFormat} compatible
 */
public String getPattern() {
    return mPattern;
}","public void test0891483() throws Throwable {
    FastDateFormat.getTimeInstance(0);
    Locale locale0 = Locale.TRADITIONAL_CHINESE;
    LinkedList<Locale.LanguageRange> linkedList0 = new LinkedList<Locale.LanguageRange>();
    locale0.getUnicodeLocaleAttributes();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(0, locale0);
    FastDateFormat fastDateFormat1 = FastDateFormat.getDateInstance(2);
    assertEquals(""MMM d, yyyy"", fastDateFormat1.getPattern());
}",""
"public static FastDateFormat getInstance(String pattern, Locale locale) {
    return getInstance(pattern, null, locale);
}","public void test0901484() throws Throwable {
    Locale locale0 = Locale.CANADA_FRENCH;
    // Undeclared exception!
    try {
        FastDateFormat.getInstance(""`k>PoY=[]c2"", locale0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal pattern component: P
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}","/**
 * <p>Gets a formatter instance using the specified pattern and
 * locale.</p>
 *
 * @param pattern  {@link java.text.SimpleDateFormat} compatible
 *  pattern
 * @param locale  optional locale, overrides system locale
 * @return a pattern based date/time formatter
 * @throws IllegalArgumentException if pattern is invalid
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0911485() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance();
    assertEquals(21, fastDateFormat1.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"//-----------------------------------------------------------------------
/**
 * <p>Gets a formatter instance using the default pattern in the
 * default locale.</p>
 *
 * @return a date/time formatter
 */
public static FastDateFormat getInstance() {
    return getInstance(getDefaultPattern(), null, null);
}","public void test0911486() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance();
    FastDateFormat fastDateFormat1 = FastDateFormat.getInstance();
    assertNotSame(fastDateFormat1, fastDateFormat0);
}",""
"public String format(Calendar calendar) {
    return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();
}","public void test0921487() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateTimeInstance(0, 0);
    // Undeclared exception!
    try {
        fastDateFormat0.format((Calendar) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat$TextField"", e);
    }
}","/**
 * <p>Formats a <code>Calendar</code> object.</p>
 *
 * @param calendar  the calendar to format
 * @return the formatted string
 */"
"public boolean getTimeZoneOverridesCalendar() {
    return mTimeZoneForced;
}","public void test0941490() throws Throwable {
    FastDateFormat fastDateFormat0 = FastDateFormat.getInstance("""");
    boolean boolean0 = fastDateFormat0.getTimeZoneOverridesCalendar();
    assertFalse(boolean0);
}","/**
 * <p>Returns <code>true</code> if the time zone of the
 * calendar overrides the time zone of the formatter.</p>
 *
 * @return <code>true</code> if time zone of formatter
 *  overridden for calendars
 */"
"public static FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, Locale locale) {
    return getDateTimeInstance(dateStyle, timeStyle, null, locale);
}","public void test0951491() throws Throwable {
    // Undeclared exception!
    try {
        FastDateFormat.getDateTimeInstance(1960, 0, (Locale) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Illegal date style 1960
        //
        verifyException(""java.text.DateFormat"", e);
    }
}","/**
 * <p>Gets a date/time formatter instance using the specified style and
 * locale in the default time zone.</p>
 *
 * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT
 * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT
 * @param locale  optional locale, overrides system locale
 * @return a localized standard date/time formatter
 * @throws IllegalArgumentException if the Locale has no date/time
 *  pattern defined
 * @since 2.1
 */"
"public String toString() {
    return ""FastDateFormat["" + mPattern + ""]"";
}","public void test0961492() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0);
    String string0 = fastDateFormat0.toString();
    assertEquals(""FastDateFormat[h:mm:ss a z]"", string0);
}","/**
 * <p>Gets a debugging string version of this formatter.</p>
 *
 * @return a debugging string
 */"
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0971493() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    FastDateFormat fastDateFormat0 = FastDateFormat.getTimeInstance(0, timeZone0);
    int int0 = fastDateFormat0.getMaxLengthEstimate();
    assertEquals(17, int0);
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
"// Parsing
//-----------------------------------------------------------------------
/**
 * <p>Parsing is not supported.</p>
 *
 * @param source  the string to parse
 * @param pos  the parsing position
 * @return <code>null</code> as not supported
 */
public Object parseObject(String source, ParsePosition pos) {
    pos.setIndex(0);
    pos.setErrorIndex(0);
    return null;
}","public void test0981494() throws Throwable {
    TimeZone timeZone0 = TimeZone.getDefault();
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(1, timeZone0);
    // Undeclared exception!
    try {
        fastDateFormat0.parseObject(""\u683C\u6797\u5A01\u6CBB\u65F6\u95F4"", (ParsePosition) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.time.FastDateFormat"", e);
    }
}",""
"public int getMaxLengthEstimate() {
    return mMaxLengthEstimate;
}","public void test0991495() throws Throwable {
    ZoneOffset zoneOffset0 = ZoneOffset.ofTotalSeconds(0);
    ZoneOffset.ofHoursMinutes(0, 0);
    TimeZone timeZone0 = TimeZone.getTimeZone((ZoneId) zoneOffset0);
    ZoneId.getAvailableZoneIds();
    timeZone0.setID(""sa"");
    zoneOffset0.getRules();
    DecimalFormat decimalFormat0 = new DecimalFormat();
    StringBuffer stringBuffer0 = new StringBuffer((CharSequence) ""sa"");
    Format.Field format_Field0 = mock(Format.Field.class, new ViolatedAssumptionAnswer());
    FieldPosition fieldPosition0 = new FieldPosition(format_Field0, 0);
    decimalFormat0.format((long) 1, stringBuffer0, fieldPosition0);
    Locale locale0 = Locale.UK;
    FastDateFormat fastDateFormat0 = FastDateFormat.getDateInstance(3, locale0);
    assertEquals(8, fastDateFormat0.getMaxLengthEstimate());
}","/**
 * <p>Gets an estimate for the maximum string length that the
 * formatter will produce.</p>
 *
 * <p>The actual formatted length will almost always be less than or
 * equal to this amount.</p>
 *
 * @return the maximum formatted length
 */"
