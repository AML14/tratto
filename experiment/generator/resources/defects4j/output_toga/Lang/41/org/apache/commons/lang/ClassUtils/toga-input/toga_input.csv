focal_method,test_prefix,docstring
"public static String getPackageName(Class<?> cls) {
    if (cls == null) {
        return StringUtils.EMPTY;
    }
    return getPackageName(cls.getName());
}","public void test000() throws Throwable {
    ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
    classLoader0.clearAssertionStatus();
    Class<?> class0 = ClassUtils.getClass(classLoader0, ""short"", false);
    Class<Integer>[] classArray0 = (Class<Integer>[]) Array.newInstance(Class.class, 7);
    Class<Integer> class1 = Integer.class;
    classArray0[0] = class1;
    Class<Integer> class2 = Integer.class;
    classArray0[4] = class2;
    Class<Integer> class3 = Integer.class;
    classArray0[2] = class3;
    Class<Integer> class4 = Integer.class;
    classArray0[3] = class4;
    Class<Integer> class5 = Integer.class;
    classArray0[4] = class5;
    Class<Integer> class6 = Integer.class;
    classArray0[5] = class6;
    Class<Integer> class7 = Integer.class;
    classArray0[6] = class7;
    ClassUtils.wrappersToPrimitives(classArray0);
    Class<Byte> class8 = Byte.class;
    ClassUtils.getPackageCanonicalName(class8);
    ClassUtils.getPackageName(""4B9o"");
    ClassUtils.getShortClassName((Object) class1, """");
    Class<Object>[] classArray1 = (Class<Object>[]) Array.newInstance(Class.class, 9);
    ClassUtils.isAssignable(classArray1, classArray1);
    ClassUtils.getShortClassName((Object) """", ""|"");
    ClassUtils.getPackageCanonicalName((Object) class0, ""java.lang"");
    ClassUtils.getPackageName(class1);
}","/**
 * <p>Gets the package name of a <code>Class</code>.</p>
 *
 * @param cls  the class to get the package name for, may be <code>null</code>.
 * @return the package name or an empty string
 */"
"public static String getPackageCanonicalName(Class<?> cls) {
    if (cls == null) {
        return StringUtils.EMPTY;
    }
    return getPackageCanonicalName(cls.getName());
}","public void test011() throws Throwable {
    ClassUtils classUtils0 = new ClassUtils();
    LinkedList<String> linkedList0 = new LinkedList<String>();
    linkedList0.pollLast();
    ClassUtils.convertClassNamesToClasses(linkedList0);
    Class<Long> class0 = Long.class;
    Class<String> class1 = String.class;
    boolean boolean0 = true;
    Class<String>[] classArray0 = (Class<String>[]) Array.newInstance(Class.class, 5);
    classArray0[0] = class1;
    classArray0[1] = class1;
    classArray0[2] = class1;
    Class<String> class2 = String.class;
    classArray0[3] = class2;
    classArray0[4] = class1;
    Predicate<Object> predicate0 = Predicate.isEqual((Object) null);
    Predicate<Object> predicate1 = predicate0.and(predicate0);
    Predicate<Object> predicate2 = predicate1.or(predicate0);
    Predicate<Object> predicate3 = predicate2.negate();
    linkedList0.removeIf(predicate3);
    ClassUtils.convertClassNamesToClasses(linkedList0);
    ClassUtils.isAssignable(classArray0, classArray0);
    ClassUtils.isAssignable(class0, class1, true);
    ClassUtils.getShortCanonicalName(""$"");
    ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
    ClassUtils.getClass(classLoader0, "";"", true);
    Class<ClassUtils> class3 = ClassUtils.class;
    // Undeclared exception!
    try {
        ClassUtils.getPackageCanonicalName(class3);
        fail(""Expecting exception: ClassNotFoundException"");
    } catch (Throwable e) {
    }
}","/**
 * <p>Gets the package name from the canonical name of a <code>Class</code>.</p>
 *
 * @param cls  the class to get the package name for, may be <code>null</code>.
 * @return the package name or an empty string
 * @since 2.4
 */"
"public static Class<?> wrapperToPrimitive(Class<?> cls) {
    return wrapperPrimitiveMap.get(cls);
}","public void test022() throws Throwable {
    Class<Byte>[] classArray0 = (Class<Byte>[]) Array.newInstance(Class.class, 6);
    Class<Byte> class0 = Byte.class;
    classArray0[0] = class0;
    Class<Byte> class1 = Byte.class;
    Class<Byte> class2 = Byte.class;
    classArray0[3] = class2;
    Class<Byte> class3 = Byte.class;
    classArray0[5] = class3;
    ClassUtils.isAssignable(classArray0, classArray0, true);
    Class<Long> class4 = Long.TYPE;
    ClassUtils.isAssignable(classArray0[1], class4);
    Class<ClassUtils> class5 = ClassUtils.class;
    ClassUtils.isAssignable(class0, class5);
    ClassUtils.getAllSuperclasses(classArray0[1]);
    String string0 = null;
    ClassUtils.isInnerClass(class1);
    ClassUtils.getShortCanonicalName(""]$;)"");
    ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
    ClassLoader classLoader1 = classLoader0.getParent();
    classLoader0.setDefaultAssertionStatus(true);
    Class<?> class6 = ClassUtils.getClass(classLoader1, ""]$;)"");
    ClassUtils.getAllSuperclasses(class6);
    ClassUtils.getPackageCanonicalName(string0);
    ClassUtils.getShortClassName(string0);
    Class<Object> class7 = Object.class;
    ClassUtils.wrapperToPrimitive(class7);
}","/**
 * <p>Converts the specified wrapper class to its corresponding primitive
 * class.</p>
 *
 * <p>This method is the counter part of <code>primitiveToWrapper()</code>.
 * If the passed in class is a wrapper class for a primitive type, this
 * primitive type will be returned (e.g. <code>Integer.TYPE</code> for
 * <code>Integer.class</code>). For other classes, or if the parameter is
 * <b>null</b>, the return value is <b>null</b>.</p>
 *
 * @param cls the class to convert, may be <b>null</b>
 * @return the corresponding primitive type if <code>cls</code> is a
 * wrapper class, <b>null</b> otherwise
 * @see #primitiveToWrapper(Class)
 * @since 2.4
 */"
"// Package name
// ----------------------------------------------------------------------
/**
 * <p>Gets the package name from the canonical name of an <code>Object</code>.</p>
 *
 * @param object  the class to get the package name for, may be null
 * @param valueIfNull  the value to return if null
 * @return the package name of the object, or the null value
 * @since 2.4
 */
public static String getPackageCanonicalName(Object object, String valueIfNull) {
    if (object == null) {
        return valueIfNull;
    }
    return getPackageCanonicalName(object.getClass().getName());
}","public void test033() throws Throwable {
    Class<Object> class0 = Object.class;
    ClassUtils.wrapperToPrimitive(class0);
    Object object0 = new Object();
    Class<String>[] classArray0 = (Class<String>[]) Array.newInstance(Class.class, 0);
    ClassUtils.primitivesToWrappers(classArray0);
    ClassUtils.getAllSuperclasses((Class<?>) null);
    ClassUtils.getPackageCanonicalName((Class<?>) null);
    ClassUtils.getShortClassName((Object) null, ""Windows 9"");
    ClassLoader.getSystemClassLoader();
    Class<Integer> class1 = Integer.class;
    ClassUtils.primitiveToWrapper(class1);
    Class<Integer> class2 = Integer.class;
    ClassUtils.wrapperToPrimitive(class2);
    Class<Double> class3 = Double.class;
    ClassUtils.getShortClassName(class3);
    ClassUtils.getPackageCanonicalName((Object) null, """");
}",""
"public static String getPackageName(String className) {
    if (className == null) {
        return StringUtils.EMPTY;
    }
    // Strip array encoding
    // Strip Object type encoding
    int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    if (i == -1) {
        return StringUtils.EMPTY;
    }
    return className.substring(0, i);
}","public void test066() throws Throwable {
    LinkedList<String> linkedList0 = new LinkedList<String>();
    linkedList0.add(""Ua"");
    linkedList0.set(0, ""java.vm.specification.name"");
    linkedList0.add(""Ua"");
    linkedList0.add(""Ua"");
    List<Class<?>> list0 = ClassUtils.convertClassNamesToClasses(linkedList0);
    Object[] objectArray0 = new Object[2];
    Object object0 = new Object();
    objectArray0[0] = object0;
    linkedList0.clone();
    objectArray0[1] = (Object) ""Ua"";
    Class<?>[] classArray0 = ClassUtils.toClass(objectArray0);
    ClassUtils.getShortCanonicalName(""Ua"");
    Class<Short> class0 = Short.class;
    linkedList0.add(""java.vm.specification.name"");
    Class<?> class1 = ClassUtils.primitiveToWrapper(class0);
    ClassUtils.convertClassesToClassNames(list0);
    linkedList0.add(""Ua"");
    Class<Long> class2 = Long.class;
    Class<Byte> class3 = Byte.TYPE;
    ClassUtils.isAssignable(class2, class3, true);
    ClassUtils.isAssignable(classArray0, classArray0, true);
    Class<Object> class4 = Object.class;
    ClassUtils.isAssignable(class1, class4);
    Class<String> class5 = String.class;
    ClassUtils.isInnerClass(class5);
    ClassUtils.getShortClassName((Class<?>) null);
    ClassUtils.getPackageName(""I"");
}","/**
 * <p>Gets the package name from a <code>String</code>.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 * <p>If the class is unpackaged, return an empty string.</p>
 *
 * @param className  the className to get the package name for, may be <code>null</code>
 * @return the package name or an empty string
 */"
"public static Class<?> primitiveToWrapper(Class<?> cls) {
    Class<?> convertedClass = cls;
    if (cls != null && cls.isPrimitive()) {
        convertedClass = primitiveWrapperMap.get(cls);
    }
    return convertedClass;
}","public void test077() throws Throwable {
    Class<Short>[] classArray0 = (Class<Short>[]) Array.newInstance(Class.class, 3);
    Class<Short> class0 = Short.class;
    classArray0[0] = class0;
    Class<Short> class1 = Short.class;
    classArray0[1] = class1;
    Class<Short> class2 = Short.class;
    classArray0[2] = class2;
    ClassUtils.wrappersToPrimitives((Class<?>[]) null);
    ClassUtils.primitivesToWrappers(classArray0);
    ClassUtils.getPackageCanonicalName(""H#SP\""<<\""O6D3V"");
    ClassUtils.primitivesToWrappers((Class<?>[]) null);
    ClassUtils.getAllInterfaces(class0);
    ClassUtils.convertClassNamesToClasses((List<String>) null);
    ClassUtils.wrappersToPrimitives(classArray0);
    Class<String> class3 = String.class;
    ClassUtils.primitiveToWrapper(class3);
}","/**
 * <p>Converts the specified primitive Class object to its corresponding
 * wrapper Class object.</p>
 *
 * <p>NOTE: From v2.2, this method handles <code>Void.TYPE</code>,
 * returning <code>Void.TYPE</code>.</p>
 *
 * @param cls  the class to convert, may be null
 * @return the wrapper class for <code>cls</code> or <code>cls</code> if
 * <code>cls</code> is not a primitive. <code>null</code> if null input.
 * @since 2.1
 */"
"public static List<Class<?>> getAllInterfaces(Class<?> cls) {
    if (cls == null) {
        return null;
    }
    LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<Class<?>>();
    getAllInterfaces(cls, interfacesFound);
    return new ArrayList<Class<?>>(interfacesFound);
}","public void test088() throws Throwable {
    Class<Short>[] classArray0 = (Class<Short>[]) Array.newInstance(Class.class, 3);
    Class<Short> class0 = Short.class;
    Class<Short> class1 = Short.class;
    classArray0[1] = class1;
    Class<Short> class2 = Short.class;
    classArray0[2] = class2;
    Class<?>[] classArray1 = ClassUtils.wrappersToPrimitives(classArray0);
    Object object0 = new Object();
    ClassUtils.getShortCanonicalName(object0, ""long"");
    ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
    classLoader0.getParent();
    Class<?> class3 = ClassUtils.getClass(classLoader0, ""long"", true);
    classLoader0.setClassAssertionStatus(""long"", false);
    Class<Object> class4 = Object.class;
    ClassUtils.isAssignable(class3, class4, true);
    ClassUtils.primitivesToWrappers(classArray0);
    ClassUtils.getPackageCanonicalName(""H#SP\""<<\""O6D3V"");
    ClassUtils.getAllInterfaces(class3);
    ClassUtils.getAllSuperclasses(class3);
    ClassUtils.primitivesToWrappers(classArray1);
    ClassUtils.getAllInterfaces(class0);
}","/**
 * <p>Gets a <code>List</code> of all interfaces implemented by the given
 * class and its superclasses.</p>
 *
 * <p>The order is determined by looking through each interface in turn as
 * declared in the source file and following its hierarchy up. Then each
 * superclass is considered in the same way. Later duplicates are ignored,
 * so the order is maintained.</p>
 *
 * @param cls  the class to look up, may be <code>null</code>
 * @return the <code>List</code> of interfaces in order,
 *  <code>null</code> if null input
 */"
"public static Class<?> getClass(String className) throws ClassNotFoundException {
    return getClass(className, true);
}","public void test099() throws Throwable {
    ClassUtils.getShortCanonicalName(""["");
    ClassUtils.getClass(""', has a length less than 2"");
}","/**
 * Returns the (initialized) class represented by <code>className</code>
 * using the current thread's context class loader. This implementation
 * supports names like ""<code>java.lang.String[]</code>"" as well as
 * ""<code>[Ljava.lang.String;</code>"".
 *
 * @param className  the class name
 * @return the class represented by <code>className</code> using the current thread's context class loader
 * @throws ClassNotFoundException if the class is not found
 */"
"public static String getPackageCanonicalName(String canonicalName) {
    return ClassUtils.getPackageName(getCanonicalName(canonicalName));
}","public void test1111() throws Throwable {
    Class<Byte>[] classArray0 = (Class<Byte>[]) Array.newInstance(Class.class, 1);
    Class<Byte> class0 = Byte.TYPE;
    classArray0[0] = class0;
    ClassUtils.isAssignable(classArray0, classArray0, true);
    ClassUtils.getShortCanonicalName(""LINUX"");
    ClassUtils.isAssignable(classArray0, classArray0, true);
    ClassUtils.getShortCanonicalName((Object) class0, ""LINUX"");
    List<Class<?>> list0 = ClassUtils.getAllSuperclasses(class0);
    ClassUtils.getPackageCanonicalName(""char"");
    Class<Object>[] classArray1 = (Class<Object>[]) Array.newInstance(Class.class, 3);
    Class<Object> class1 = Object.class;
    classArray1[0] = class1;
    Class<Object> class2 = Object.class;
    classArray1[1] = class2;
    Class<Object> class3 = Object.class;
    classArray1[2] = class3;
    ClassUtils.isAssignable(classArray0, classArray1, true);
    String string0 = ClassUtils.getShortCanonicalName((Object) list0, ""[java.lang.Float"");
    ClassUtils.getShortCanonicalName((Object) class1, ""char"");
    Class<Character> class4 = Character.class;
    Class<Short> class5 = Short.class;
    ClassUtils.isAssignable(class4, class5, true);
    ClassUtils.isAssignable(classArray1, classArray1, true);
    ClassUtils.getShortCanonicalName(class5);
    Long long0 = new Long((-1779L));
    String string1 = ""[H#SP\""<<\""O6D3V"";
    ClassUtils.getShortClassName((Object) long0, ""[H#SP\""<<\""O6D3V"");
    ClassUtils.getClass(""'bmrz{'p6)Kn q#X"", true);
    ClassUtils.toClass(classArray1);
    ClassUtils.getShortClassName(string1);
    ClassUtils.getPackageCanonicalName(string0);
}","/**
 * <p>Gets the package name from the canonical name. </p>
 *
 * <p>The string passed in is assumed to be a canonical name - it is not checked.</p>
 * <p>If the class is unpackaged, return an empty string.</p>
 *
 * @param canonicalName  the canonical name to get the package name for, may be <code>null</code>
 * @return the package name or an empty string
 * @since 2.4
 */"
"public static List<Class<?>> getAllInterfaces(Class<?> cls) {
    if (cls == null) {
        return null;
    }
    LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<Class<?>>();
    getAllInterfaces(cls, interfacesFound);
    return new ArrayList<Class<?>>(interfacesFound);
}","public void test1212() throws Throwable {
    Byte byte0 = new Byte((byte) 104);
    Byte.toUnsignedInt((byte) (-7));
    ClassUtils.getShortCanonicalName((Object) byte0, ""[]"");
    ClassUtils.getShortCanonicalName((Object) ""X2T+@,f`tEZ{O7]i/yT"", ""Byte"");
    Class<Short>[] classArray0 = (Class<Short>[]) Array.newInstance(Class.class, 2);
    Class<Short> class0 = Short.class;
    classArray0[0] = class0;
    Class<Short> class1 = Short.class;
    classArray0[1] = class1;
    ClassUtils.wrappersToPrimitives(classArray0);
    ClassUtils.toClass(classArray0);
    ClassUtils.isInnerClass(class0);
    ClassUtils.getAllInterfaces(class0);
}","/**
 * <p>Gets a <code>List</code> of all interfaces implemented by the given
 * class and its superclasses.</p>
 *
 * <p>The order is determined by looking through each interface in turn as
 * declared in the source file and following its hierarchy up. Then each
 * superclass is considered in the same way. Later duplicates are ignored,
 * so the order is maintained.</p>
 *
 * @param cls  the class to look up, may be <code>null</code>
 * @return the <code>List</code> of interfaces in order,
 *  <code>null</code> if null input
 */"
"// Public method
// ----------------------------------------------------------------------
/**
 * <p>Returns the desired Method much like <code>Class.getMethod</code>, however
 * it ensures that the returned Method is from a public class or interface and not
 * from an anonymous inner class. This means that the Method is invokable and
 * doesn't fall foul of Java bug
 * <a href=""http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4071957"">4071957</a>).
 *
 *  <code><pre>Set set = Collections.unmodifiableSet(...);
 *  Method method = ClassUtils.getPublicMethod(set.getClass(), ""isEmpty"",  new Class[0]);
 *  Object result = method.invoke(set, new Object[]);</pre></code>
 * </p>
 *
 * @param cls  the class to check, not null
 * @param methodName  the name of the method
 * @param parameterTypes  the list of parameters
 * @return the method
 * @throws NullPointerException if the class is null
 * @throws SecurityException if a a security violation occured
 * @throws NoSuchMethodException if the method is not found in the given class
 *  or if the metothod doen't conform with the requirements
 */
public static Method getPublicMethod(Class<?> cls, String methodName, Class<?>[] parameterTypes) throws SecurityException, NoSuchMethodException {
    Method declaredMethod = cls.getMethod(methodName, parameterTypes);
    if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) {
        return declaredMethod;
    }
    List<Class<?>> candidateClasses = new ArrayList<Class<?>>();
    candidateClasses.addAll(getAllInterfaces(cls));
    candidateClasses.addAll(getAllSuperclasses(cls));
    for (Class<?> candidateClass : candidateClasses) {
        if (!Modifier.isPublic(candidateClass.getModifiers())) {
            continue;
        }
        Method candidateMethod;
        try {
            candidateMethod = candidateClass.getMethod(methodName, parameterTypes);
        } catch (NoSuchMethodException ex) {
            continue;
        }
        if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) {
            return candidateMethod;
        }
    }
    throw new NoSuchMethodException(""Can't find a public method for "" + methodName + "" "" + ArrayUtils.toString(parameterTypes));
}","public void test1313() throws Throwable {
    Class<Double> class0 = Double.class;
    Class<String>[] classArray0 = (Class<String>[]) Array.newInstance(Class.class, 2);
    Class<String> class1 = String.class;
    classArray0[0] = class1;
    Class<String> class2 = String.class;
    classArray0[1] = class2;
    ClassUtils.getPublicMethod(class0, ""%"", classArray0);
}",""
"// Package name
// ----------------------------------------------------------------------
/**
 * <p>Gets the package name of an <code>Object</code>.</p>
 *
 * @param object  the class to get the package name for, may be null
 * @param valueIfNull  the value to return if null
 * @return the package name of the object, or the null value
 */
public static String getPackageName(Object object, String valueIfNull) {
    if (object == null) {
        return valueIfNull;
    }
    return getPackageName(object.getClass());
}","public void test1414() throws Throwable {
    ClassUtils classUtils0 = new ClassUtils();
    ClassUtils.getPackageName((Object) classUtils0, ""Lz+O_j{lD'oz@1"");
}",""
"public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {
    if (toClass == null) {
        return false;
    }
    // have to check for null, as isAssignableFrom doesn't
    if (cls == null) {
        return !(toClass.isPrimitive());
    }
    //autoboxing:
    if (autoboxing) {
        if (cls.isPrimitive() && !toClass.isPrimitive()) {
            cls = primitiveToWrapper(cls);
            if (cls == null) {
                return false;
            }
        }
        if (toClass.isPrimitive() && !cls.isPrimitive()) {
            cls = wrapperToPrimitive(cls);
            if (cls == null) {
                return false;
            }
        }
    }
    if (cls.equals(toClass)) {
        return true;
    }
    if (cls.isPrimitive()) {
        if (toClass.isPrimitive() == false) {
            return false;
        }
        if (Integer.TYPE.equals(cls)) {
            return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Long.TYPE.equals(cls)) {
            return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Boolean.TYPE.equals(cls)) {
            return false;
        }
        if (Double.TYPE.equals(cls)) {
            return false;
        }
        if (Float.TYPE.equals(cls)) {
            return Double.TYPE.equals(toClass);
        }
        if (Character.TYPE.equals(cls)) {
            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Short.TYPE.equals(cls)) {
            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Byte.TYPE.equals(cls)) {
            return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        // should never get here
        return false;
    }
    return toClass.isAssignableFrom(cls);
}","public void test1515() throws Throwable {
    ClassUtils.isAssignable((Class<?>[]) null, (Class<?>[]) null, true);
    ClassUtils.getPackageName(""-:_V0F`3B~Za`#m<!"");
    ClassUtils.getShortClassName("""");
    ClassUtils.getShortCanonicalName(""org.apache.commons.lang.builder.ToStringStyle$MultiLineToStringStyle"");
    Integer integer0 = new Integer(2343);
    Integer.toUnsignedString((-4785));
    Integer.getInteger(""org.apache.commons.lang.builder.ToStringStyle$MultiLineToStringStyle"");
    ClassUtils.getShortCanonicalName((Object) integer0, """");
    Class<Float> class0 = Float.class;
    Class<Float> class1 = Float.class;
    ClassUtils.isAssignable(class0, class1, true);
}","/**
 * <p>Checks if one <code>Class</code> can be assigned to a variable of
 * another <code>Class</code>.</p>
 *
 * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,
 * this method takes into account widenings of primitive classes and
 * <code>null</code>s.</p>
 *
 * <p>Primitive widenings allow an int to be assigned to a long, float or
 * double. This method returns the correct result for these cases.</p>
 *
 * <p><code>Null</code> may be assigned to any reference type. This method
 * will return <code>true</code> if <code>null</code> is passed in and the
 * toClass is non-primitive.</p>
 *
 * <p>Specifically, this method tests whether the type represented by the
 * specified <code>Class</code> parameter can be converted to the type
 * represented by this <code>Class</code> object via an identity conversion
 * widening primitive or widening reference conversion. See
 * <em><a href=""http://java.sun.com/docs/books/jls/"">The Java Language Specification</a></em>,
 * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>
 *
 * @param cls  the Class to check, may be null
 * @param toClass  the Class to try to assign into, returns false if null
 * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers
 * @return <code>true</code> if assignment possible
 */"
"public static String getPackageCanonicalName(String canonicalName) {
    return ClassUtils.getPackageName(getCanonicalName(canonicalName));
}","public void test1616() throws Throwable {
    Class<Float> class0 = Float.class;
    Class<String> class1 = String.class;
    ClassUtils.isAssignable(class0, class1);
    ClassUtils.getPackageCanonicalName((String) null);
}","/**
 * <p>Gets the package name from the canonical name. </p>
 *
 * <p>The string passed in is assumed to be a canonical name - it is not checked.</p>
 * <p>If the class is unpackaged, return an empty string.</p>
 *
 * @param canonicalName  the canonical name to get the package name for, may be <code>null</code>
 * @return the package name or an empty string
 * @since 2.4
 */"
"public static String getShortClassName(Class<?> cls) {
    if (cls == null) {
        return StringUtils.EMPTY;
    }
    return getShortClassName(cls.getName());
}","public void test1717() throws Throwable {
    Class<?> class0 = ClassUtils.getClass(""QrF>JH`"");
    // Undeclared exception!
    try {
        ClassUtils.getShortClassName(class0);
        fail(""Expecting exception: ClassNotFoundException"");
    } catch (Throwable e) {
    }
}","/**
 * <p>Gets the class name minus the package name from a <code>Class</code>.</p>
 *
 * @param cls  the class to get the short name for.
 * @return the class name without the package name or an empty string
 */"
"public static String getPackageCanonicalName(String canonicalName) {
    return ClassUtils.getPackageName(getCanonicalName(canonicalName));
}","public void test1818() throws Throwable {
    Class<Byte> class0 = Byte.class;
    ClassUtils.isAssignable(class0, class0, false);
    Class<Short>[] classArray0 = (Class<Short>[]) Array.newInstance(Class.class, 0);
    ClassUtils.primitivesToWrappers(classArray0);
    ClassUtils.getPackageCanonicalName((Object) class0, "";O=/!]h"");
    ClassUtils.getPackageCanonicalName("";O=/!]h"");
}","/**
 * <p>Gets the package name from the canonical name. </p>
 *
 * <p>The string passed in is assumed to be a canonical name - it is not checked.</p>
 * <p>If the class is unpackaged, return an empty string.</p>
 *
 * @param canonicalName  the canonical name to get the package name for, may be <code>null</code>
 * @return the package name or an empty string
 * @since 2.4
 */"
"public static List<Class<?>> getAllInterfaces(Class<?> cls) {
    if (cls == null) {
        return null;
    }
    LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<Class<?>>();
    getAllInterfaces(cls, interfacesFound);
    return new ArrayList<Class<?>>(interfacesFound);
}","public void test1919() throws Throwable {
    Class<Float> class0 = Float.class;
    ClassUtils.getShortClassName(class0);
    ClassUtils.isInnerClass(class0);
    ClassUtils.getShortCanonicalName(class0);
    ClassUtils.getShortCanonicalName("":50>3?9"");
    ClassUtils.getAllInterfaces(class0);
}","/**
 * <p>Gets a <code>List</code> of all interfaces implemented by the given
 * class and its superclasses.</p>
 *
 * <p>The order is determined by looking through each interface in turn as
 * declared in the source file and following its hierarchy up. Then each
 * superclass is considered in the same way. Later duplicates are ignored,
 * so the order is maintained.</p>
 *
 * @param cls  the class to look up, may be <code>null</code>
 * @return the <code>List</code> of interfaces in order,
 *  <code>null</code> if null input
 */"
"public static Class<?>[] primitivesToWrappers(Class<?>[] classes) {
    if (classes == null) {
        return null;
    }
    if (classes.length == 0) {
        return classes;
    }
    Class<?>[] convertedClasses = new Class[classes.length];
    for (int i = 0; i < classes.length; i++) {
        convertedClasses[i] = primitiveToWrapper(classes[i]);
    }
    return convertedClasses;
}","public void test2020() throws Throwable {
    Class<Integer> class0 = Integer.class;
    ClassUtils.getShortCanonicalName(class0);
    Class<Character>[] classArray0 = (Class<Character>[]) Array.newInstance(Class.class, 4);
    Class<Character> class1 = Character.class;
    classArray0[0] = class1;
    Class<Character> class2 = Character.class;
    classArray0[1] = class2;
    Class<Character> class3 = Character.class;
    classArray0[2] = class3;
    Class<Character> class4 = Character.class;
    classArray0[3] = class4;
    ClassUtils.primitivesToWrappers(classArray0);
}","/**
 * <p>Converts the specified array of primitive Class objects to an array of
 * its corresponding wrapper Class objects.</p>
 *
 * @param classes  the class array to convert, may be null or empty
 * @return an array which contains for each given class, the wrapper class or
 * the original class if class is not a primitive. <code>null</code> if null input.
 * Empty array if an empty array passed in.
 * @since 2.1
 */"
"// Public method
// ----------------------------------------------------------------------
/**
 * <p>Returns the desired Method much like <code>Class.getMethod</code>, however
 * it ensures that the returned Method is from a public class or interface and not
 * from an anonymous inner class. This means that the Method is invokable and
 * doesn't fall foul of Java bug
 * <a href=""http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4071957"">4071957</a>).
 *
 *  <code><pre>Set set = Collections.unmodifiableSet(...);
 *  Method method = ClassUtils.getPublicMethod(set.getClass(), ""isEmpty"",  new Class[0]);
 *  Object result = method.invoke(set, new Object[]);</pre></code>
 * </p>
 *
 * @param cls  the class to check, not null
 * @param methodName  the name of the method
 * @param parameterTypes  the list of parameters
 * @return the method
 * @throws NullPointerException if the class is null
 * @throws SecurityException if a a security violation occured
 * @throws NoSuchMethodException if the method is not found in the given class
 *  or if the metothod doen't conform with the requirements
 */
public static Method getPublicMethod(Class<?> cls, String methodName, Class<?>[] parameterTypes) throws SecurityException, NoSuchMethodException {
    Method declaredMethod = cls.getMethod(methodName, parameterTypes);
    if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) {
        return declaredMethod;
    }
    List<Class<?>> candidateClasses = new ArrayList<Class<?>>();
    candidateClasses.addAll(getAllInterfaces(cls));
    candidateClasses.addAll(getAllSuperclasses(cls));
    for (Class<?> candidateClass : candidateClasses) {
        if (!Modifier.isPublic(candidateClass.getModifiers())) {
            continue;
        }
        Method candidateMethod;
        try {
            candidateMethod = candidateClass.getMethod(methodName, parameterTypes);
        } catch (NoSuchMethodException ex) {
            continue;
        }
        if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) {
            return candidateMethod;
        }
    }
    throw new NoSuchMethodException(""Can't find a public method for "" + methodName + "" "" + ArrayUtils.toString(parameterTypes));
}","public void test2121() throws Throwable {
    Class<Object> class0 = Object.class;
    ClassUtils.getPackageName(class0);
    Class<Double> class1 = Double.class;
    Class<Object>[] classArray0 = (Class<Object>[]) Array.newInstance(Class.class, 0);
    try {
        ClassUtils.getPublicMethod(class1, ""java.lang"", classArray0);
        fail(""Expecting exception: NoSuchMethodException"");
    } catch (NoSuchMethodException e) {
    }
}",""
"public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException {
    return getClass(classLoader, className, true);
}","public void test2525() throws Throwable {
    Class<String> class0 = String.class;
    ClassUtils.getShortClassName(class0);
    ClassUtils.getShortCanonicalName(class0);
    Class<ClassUtils> class1 = ClassUtils.class;
    ClassUtils.getAllInterfaces(class1);
    ClassUtils.getPackageCanonicalName(class1);
    Class<Long> class2 = Long.class;
    ClassUtils.getPackageName(class2);
    Class<Float> class3 = Float.class;
    ClassUtils.wrapperToPrimitive(class3);
    ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
    try {
        ClassUtils.getClass(classLoader0, ""org.apache.commons.lang"");
        fail(""Expecting exception: ClassNotFoundException"");
    } catch (ClassNotFoundException e) {
    }
}","/**
 * Returns the (initialized) class represented by <code>className</code>
 * using the <code>classLoader</code>.  This implementation supports names
 * like ""<code>java.lang.String[]</code>"" as well as
 * ""<code>[Ljava.lang.String;</code>"".
 *
 * @param classLoader  the class loader to use to load the class
 * @param className  the class name
 * @return the class represented by <code>className</code> using the <code>classLoader</code>
 * @throws ClassNotFoundException if the class is not found
 */"
"public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) {
    if (ArrayUtils.isSameLength(classArray, toClassArray) == false) {
        return false;
    }
    if (classArray == null) {
        classArray = ArrayUtils.EMPTY_CLASS_ARRAY;
    }
    if (toClassArray == null) {
        toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY;
    }
    for (int i = 0; i < classArray.length; i++) {
        if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) {
            return false;
        }
    }
    return true;
}","public void test2626() throws Throwable {
    ClassUtils.toClass((Object[]) null);
    ClassUtils.isAssignable((Class<?>[]) null, (Class<?>[]) null, false);
}","/**
 * <p>Checks if an array of Classes can be assigned to another array of Classes.</p>
 *
 * <p>This method calls {@link #isAssignable(Class, Class) isAssignable} for each
 * Class pair in the input arrays. It can be used to check if a set of arguments
 * (the first parameter) are suitably compatible with a set of method parameter types
 * (the second parameter).</p>
 *
 * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this
 * method takes into account widenings of primitive classes and
 * <code>null</code>s.</p>
 *
 * <p>Primitive widenings allow an int to be assigned to a <code>long</code>,
 * <code>float</code> or <code>double</code>. This method returns the correct
 * result for these cases.</p>
 *
 * <p><code>Null</code> may be assigned to any reference type. This method will
 * return <code>true</code> if <code>null</code> is passed in and the toClass is
 * non-primitive.</p>
 *
 * <p>Specifically, this method tests whether the type represented by the
 * specified <code>Class</code> parameter can be converted to the type
 * represented by this <code>Class</code> object via an identity conversion
 * widening primitive or widening reference conversion. See
 * <em><a href=""http://java.sun.com/docs/books/jls/"">The Java Language Specification</a></em>,
 * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>
 *
 * @param classArray  the array of Classes to check, may be <code>null</code>
 * @param toClassArray  the array of Classes to try to assign into, may be <code>null</code>
 * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers
 * @return <code>true</code> if assignment possible
 */"
"public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {
    if (toClass == null) {
        return false;
    }
    // have to check for null, as isAssignableFrom doesn't
    if (cls == null) {
        return !(toClass.isPrimitive());
    }
    //autoboxing:
    if (autoboxing) {
        if (cls.isPrimitive() && !toClass.isPrimitive()) {
            cls = primitiveToWrapper(cls);
            if (cls == null) {
                return false;
            }
        }
        if (toClass.isPrimitive() && !cls.isPrimitive()) {
            cls = wrapperToPrimitive(cls);
            if (cls == null) {
                return false;
            }
        }
    }
    if (cls.equals(toClass)) {
        return true;
    }
    if (cls.isPrimitive()) {
        if (toClass.isPrimitive() == false) {
            return false;
        }
        if (Integer.TYPE.equals(cls)) {
            return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Long.TYPE.equals(cls)) {
            return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Boolean.TYPE.equals(cls)) {
            return false;
        }
        if (Double.TYPE.equals(cls)) {
            return false;
        }
        if (Float.TYPE.equals(cls)) {
            return Double.TYPE.equals(toClass);
        }
        if (Character.TYPE.equals(cls)) {
            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Short.TYPE.equals(cls)) {
            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Byte.TYPE.equals(cls)) {
            return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        // should never get here
        return false;
    }
    return toClass.isAssignableFrom(cls);
}","public void test2727() throws Throwable {
    Class<String>[] classArray0 = (Class<String>[]) Array.newInstance(Class.class, 1);
    Class<String> class0 = String.class;
    classArray0[0] = class0;
    Class<?>[] classArray1 = ClassUtils.primitivesToWrappers(classArray0);
    Class<Object> class1 = Object.class;
    ClassUtils.getPackageName(class1);
    Class<?>[] classArray2 = ClassUtils.wrappersToPrimitives(classArray1);
    ClassUtils.isAssignable(classArray2, classArray2, true);
    ClassUtils.getPackageName(""java.lang"");
    Class<Integer> class2 = Integer.class;
    Class<Character> class3 = Character.class;
    ClassUtils.isAssignable(class2, class3, false);
}","/**
 * <p>Checks if one <code>Class</code> can be assigned to a variable of
 * another <code>Class</code>.</p>
 *
 * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,
 * this method takes into account widenings of primitive classes and
 * <code>null</code>s.</p>
 *
 * <p>Primitive widenings allow an int to be assigned to a long, float or
 * double. This method returns the correct result for these cases.</p>
 *
 * <p><code>Null</code> may be assigned to any reference type. This method
 * will return <code>true</code> if <code>null</code> is passed in and the
 * toClass is non-primitive.</p>
 *
 * <p>Specifically, this method tests whether the type represented by the
 * specified <code>Class</code> parameter can be converted to the type
 * represented by this <code>Class</code> object via an identity conversion
 * widening primitive or widening reference conversion. See
 * <em><a href=""http://java.sun.com/docs/books/jls/"">The Java Language Specification</a></em>,
 * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>
 *
 * @param cls  the Class to check, may be null
 * @param toClass  the Class to try to assign into, returns false if null
 * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers
 * @return <code>true</code> if assignment possible
 */"
"//TODO when we bump the major version we should default autoboxing to true on platforms >= 1.5
public static boolean isAssignable(Class<?> cls, Class<?> toClass) {
    return isAssignable(cls, toClass, false);
}","public void test2828() throws Throwable {
    Class<Character> class0 = Character.class;
    ClassUtils.getPackageCanonicalName(class0);
    ClassUtils.isAssignable(class0, class0);
}","/**
 * <p>Checks if one <code>Class</code> can be assigned to a variable of
 * another <code>Class</code>.</p>
 *
 * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,
 * this method takes into account widenings of primitive classes and
 * <code>null</code>s.</p>
 *
 * <p>Primitive widenings allow an int to be assigned to a long, float or
 * double. This method returns the correct result for these cases.</p>
 *
 * <p><code>Null</code> may be assigned to any reference type. This method
 * will return <code>true</code> if <code>null</code> is passed in and the
 * toClass is non-primitive.</p>
 *
 * <p>Specifically, this method tests whether the type represented by the
 * specified <code>Class</code> parameter can be converted to the type
 * represented by this <code>Class</code> object via an identity conversion
 * widening primitive or widening reference conversion. See
 * <em><a href=""http://java.sun.com/docs/books/jls/"">The Java Language Specification</a></em>,
 * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>
 *
 * @param cls  the Class to check, may be null
 * @param toClass  the Class to try to assign into, returns false if null
 * @return <code>true</code> if assignment possible
 */"
"public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException {
    return getClass(classLoader, className, true);
}","public void test2929() throws Throwable {
    ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
    ClassUtils.getClass(classLoader0, ""q,*d"");
}","/**
 * Returns the (initialized) class represented by <code>className</code>
 * using the <code>classLoader</code>.  This implementation supports names
 * like ""<code>java.lang.String[]</code>"" as well as
 * ""<code>[Ljava.lang.String;</code>"".
 *
 * @param classLoader  the class loader to use to load the class
 * @param className  the class name
 * @return the class represented by <code>className</code> using the <code>classLoader</code>
 * @throws ClassNotFoundException if the class is not found
 */"
"public static Class<?> getClass(String className) throws ClassNotFoundException {
    return getClass(className, true);
}","public void test3030() throws Throwable {
    ClassUtils.getShortCanonicalName(""["");
    Object[] objectArray0 = new Object[5];
    objectArray0[0] = (Object) ""[]"";
    objectArray0[1] = (Object) ""[]"";
    objectArray0[2] = (Object) ""[]"";
    objectArray0[3] = (Object) ""["";
    objectArray0[4] = (Object) ""["";
    ClassUtils.toClass(objectArray0);
    Float float0 = new Float(3.912323F);
    ClassUtils.getPackageName((Object) float0, (String) null);
    ClassUtils.getClass(""', has a length less than 2"");
}","/**
 * Returns the (initialized) class represented by <code>className</code>
 * using the current thread's context class loader. This implementation
 * supports names like ""<code>java.lang.String[]</code>"" as well as
 * ""<code>[Ljava.lang.String;</code>"".
 *
 * @param className  the class name
 * @return the class represented by <code>className</code> using the current thread's context class loader
 * @throws ClassNotFoundException if the class is not found
 */"
"public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException {
    return getClass(classLoader, className, true);
}","public void test3131() throws Throwable {
    ClassUtils classUtils0 = new ClassUtils();
    ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
    try {
        ClassUtils.getClass(classLoader0, ""."");
        fail(""Expecting exception: ClassNotFoundException"");
    } catch (ClassNotFoundException e) {
    }
}","/**
 * Returns the (initialized) class represented by <code>className</code>
 * using the <code>classLoader</code>.  This implementation supports names
 * like ""<code>java.lang.String[]</code>"" as well as
 * ""<code>[Ljava.lang.String;</code>"".
 *
 * @param classLoader  the class loader to use to load the class
 * @param className  the class name
 * @return the class represented by <code>className</code> using the <code>classLoader</code>
 * @throws ClassNotFoundException if the class is not found
 */"
"public static String getPackageCanonicalName(String canonicalName) {
    return ClassUtils.getPackageName(getCanonicalName(canonicalName));
}","public void test3232() throws Throwable {
    Class<Object> class0 = Object.class;
    String string0 = ClassUtils.getPackageCanonicalName(class0);
    ClassUtils.getClass((ClassLoader) null, ""java.lang"");
    // Undeclared exception!
    try {
        ClassUtils.getPackageCanonicalName(string0);
        fail(""Expecting exception: ClassNotFoundException"");
    } catch (Throwable e) {
    }
}","/**
 * <p>Gets the package name from the canonical name. </p>
 *
 * <p>The string passed in is assumed to be a canonical name - it is not checked.</p>
 * <p>If the class is unpackaged, return an empty string.</p>
 *
 * @param canonicalName  the canonical name to get the package name for, may be <code>null</code>
 * @return the package name or an empty string
 * @since 2.4
 */"
"public static String getPackageName(Class<?> cls) {
    if (cls == null) {
        return StringUtils.EMPTY;
    }
    return getPackageName(cls.getName());
}","public void test3333() throws Throwable {
    ClassUtils classUtils0 = new ClassUtils();
    ClassUtils.getShortClassName((Object) classUtils0, ""$"");
    Class<Double> class0 = Double.class;
    ClassUtils.getPackageName(class0);
}","/**
 * <p>Gets the package name of a <code>Class</code>.</p>
 *
 * @param cls  the class to get the package name for, may be <code>null</code>.
 * @return the package name or an empty string
 */"
"public static String getPackageCanonicalName(Class<?> cls) {
    if (cls == null) {
        return StringUtils.EMPTY;
    }
    return getPackageCanonicalName(cls.getName());
}","public void test3434() throws Throwable {
    Class<Double>[] classArray0 = (Class<Double>[]) Array.newInstance(Class.class, 0);
    ClassUtils.isAssignable(classArray0, classArray0);
    ClassUtils.getPackageCanonicalName(""user.region"");
    Class<?>[] classArray1 = ClassUtils.primitivesToWrappers(classArray0);
    Class<Boolean> class0 = Boolean.class;
    Class<String> class1 = String.class;
    ClassUtils.isAssignable(class0, class1, true);
    ClassUtils.toClass(classArray1);
    Class<Byte> class2 = Byte.class;
    ClassUtils.getPackageCanonicalName(class2);
}","/**
 * <p>Gets the package name from the canonical name of a <code>Class</code>.</p>
 *
 * @param cls  the class to get the package name for, may be <code>null</code>.
 * @return the package name or an empty string
 * @since 2.4
 */"
"// Package name
// ----------------------------------------------------------------------
/**
 * <p>Gets the package name of an <code>Object</code>.</p>
 *
 * @param object  the class to get the package name for, may be null
 * @param valueIfNull  the value to return if null
 * @return the package name of the object, or the null value
 */
public static String getPackageName(Object object, String valueIfNull) {
    if (object == null) {
        return valueIfNull;
    }
    return getPackageName(object.getClass());
}","public void test3535() throws Throwable {
    Float float0 = new Float(1579.2F);
    ClassUtils.getShortClassName((Object) float0, ""J"");
    Class<Character> class0 = Character.class;
    ClassUtils.getShortClassName(class0);
    ClassUtils.getPackageName((Object) class0, ""o E;9F@*T"");
}",""
"public static String getShortCanonicalName(String canonicalName) {
    return ClassUtils.getShortClassName(getCanonicalName(canonicalName));
}","public void test3636() throws Throwable {
    ClassUtils.getShortClassName(""]{?}"");
    Class<Double> class0 = Double.class;
    ClassUtils.isAssignable(class0, class0, true);
    ClassUtils.getShortCanonicalName(""]{?}"");
}","/**
 * <p>Gets the canonical name minus the package name from a String.</p>
 *
 * <p>The string passed in is assumed to be a canonical name - it is not checked.</p>
 *
 * @param canonicalName  the class name to get the short name for
 * @return the canonical name of the class without the package name or an empty string
 * @since 2.4
 */"
"public static String getShortCanonicalName(Class<?> cls) {
    if (cls == null) {
        return StringUtils.EMPTY;
    }
    return getShortCanonicalName(cls.getName());
}","public void test3737() throws Throwable {
    Class<Object> class0 = Object.class;
    Class<Short> class1 = Short.class;
    ClassUtils.isAssignable(class0, class1);
    ClassUtils.getPackageCanonicalName((Object) class0, """");
    Class<Short> class2 = Short.class;
    Class<?> class3 = ClassUtils.wrapperToPrimitive(class2);
    ClassUtils.isAssignable(class3, class1, false);
    ClassUtils.getShortCanonicalName(class0);
}","/**
 * <p>Gets the canonical name minus the package name from a <code>Class</code>.</p>
 *
 * @param cls  the class to get the short name for.
 * @return the canonical name without the package name or an empty string
 * @since 2.4
 */"
"public static String getShortClassName(String className) {
    if (className == null) {
        return StringUtils.EMPTY;
    }
    if (className.length() == 0) {
        return StringUtils.EMPTY;
    }
    // Handle array encoding
    // Strip Object type encoding
    int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);
    String out = className.substring(lastDotIdx + 1);
    if (innerIdx != -1) {
        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
    }
    return out;
}","public void test3838() throws Throwable {
    Class<Double> class0 = Double.class;
    ClassUtils.primitiveToWrapper(class0);
    Class<Float>[] classArray0 = (Class<Float>[]) Array.newInstance(Class.class, 4);
    Class<Float> class1 = Float.class;
    classArray0[0] = class1;
    Class<Float> class2 = Float.class;
    classArray0[1] = class2;
    Class<Float> class3 = Float.class;
    classArray0[2] = class3;
    Class<Float> class4 = Float.class;
    classArray0[3] = class4;
    ClassUtils.isAssignable(classArray0, classArray0, true);
    Class<Short>[] classArray1 = (Class<Short>[]) Array.newInstance(Class.class, 0);
    ClassUtils.isAssignable(classArray0, classArray1, true);
    ClassUtils.getShortClassName(""5#EFG"");
}","/**
 * <p>Gets the class name minus the package name from a String.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 *
 * @param className  the className to get the short name for
 * @return the class name of the class without the package name or an empty string
 */"
"public static Class<?> wrapperToPrimitive(Class<?> cls) {
    return wrapperPrimitiveMap.get(cls);
}","public void test3939() throws Throwable {
    Object object0 = new Object();
    ClassUtils.getPackageCanonicalName(object0, ""org.apache.commons.lang.ClassUtils"");
    LinkedList<String> linkedList0 = new LinkedList<String>();
    List<String> list0 = linkedList0.subList(0, 0);
    ClassUtils.convertClassNamesToClasses(list0);
    Class<?> class0 = ClassUtils.getClass((String) null);
    ClassUtils.wrapperToPrimitive(class0);
}","/**
 * <p>Converts the specified wrapper class to its corresponding primitive
 * class.</p>
 *
 * <p>This method is the counter part of <code>primitiveToWrapper()</code>.
 * If the passed in class is a wrapper class for a primitive type, this
 * primitive type will be returned (e.g. <code>Integer.TYPE</code> for
 * <code>Integer.class</code>). For other classes, or if the parameter is
 * <b>null</b>, the return value is <b>null</b>.</p>
 *
 * @param cls the class to convert, may be <b>null</b>
 * @return the corresponding primitive type if <code>cls</code> is a
 * wrapper class, <b>null</b> otherwise
 * @see #primitiveToWrapper(Class)
 * @since 2.4
 */"
"public static String getPackageName(String className) {
    if (className == null) {
        return StringUtils.EMPTY;
    }
    // Strip array encoding
    // Strip Object type encoding
    int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    if (i == -1) {
        return StringUtils.EMPTY;
    }
    return className.substring(0, i);
}","public void test4040() throws Throwable {
    Class<Integer> class0 = Integer.class;
    ClassUtils.getAllSuperclasses(class0);
    ClassUtils.getPackageName(""q0U!|^"");
}","/**
 * <p>Gets the package name from a <code>String</code>.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 * <p>If the class is unpackaged, return an empty string.</p>
 *
 * @param className  the className to get the package name for, may be <code>null</code>
 * @return the package name or an empty string
 */"
"// Superclasses/Superinterfaces
// ----------------------------------------------------------------------
/**
 * <p>Gets a <code>List</code> of superclasses for the given class.</p>
 *
 * @param cls  the class to look up, may be <code>null</code>
 * @return the <code>List</code> of superclasses in order going up from this one
 *  <code>null</code> if null input
 */
public static List<Class<?>> getAllSuperclasses(Class<?> cls) {
    if (cls == null) {
        return null;
    }
    List<Class<?>> classes = new ArrayList<Class<?>>();
    Class<?> superclass = cls.getSuperclass();
    while (superclass != null) {
        classes.add(superclass);
        superclass = superclass.getSuperclass();
    }
    return classes;
}","public void test4242() throws Throwable {
    ClassUtils classUtils0 = new ClassUtils();
    ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
    ClassUtils.getClass(classLoader0, (String) null, true);
    Class<Double> class0 = Double.class;
    // Undeclared exception!
    try {
        ClassUtils.getAllSuperclasses(class0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // className must not be null.
        //
        verifyException(""org.apache.commons.lang.ClassUtils"", e);
    }
}",""
"// Package name
// ----------------------------------------------------------------------
/**
 * <p>Gets the package name of an <code>Object</code>.</p>
 *
 * @param object  the class to get the package name for, may be null
 * @param valueIfNull  the value to return if null
 * @return the package name of the object, or the null value
 */
public static String getPackageName(Object object, String valueIfNull) {
    if (object == null) {
        return valueIfNull;
    }
    return getPackageName(object.getClass());
}","public void test4545() throws Throwable {
    ClassUtils.getPackageName((Object) ""eu"", "";&uT dnc"");
    Class<Short> class0 = Short.class;
    ClassUtils.getAllSuperclasses(class0);
    List<Class<?>> list0 = ClassUtils.getAllSuperclasses(class0);
    ClassUtils.getPackageName("";&uT dnc"");
    Class<Integer>[] classArray0 = (Class<Integer>[]) Array.newInstance(Class.class, 1);
    Class<Integer> class1 = Integer.class;
    classArray0[0] = class1;
    ClassUtils.isAssignable(classArray0, classArray0);
    ClassUtils.getShortClassName(""fd~=8m"");
    ClassUtils classUtils0 = new ClassUtils();
    Class<Double> class2 = Double.class;
    Class<Boolean> class3 = Boolean.class;
    ClassUtils.isAssignable(class2, class3, false);
    ClassUtils.convertClassesToClassNames(list0);
    ClassUtils.getAllSuperclasses(class0);
    Byte byte0 = new Byte((byte) 0);
    ClassUtils.getPackageName((Object) byte0, ""eu"");
}",""
"public static String getShortClassName(String className) {
    if (className == null) {
        return StringUtils.EMPTY;
    }
    if (className.length() == 0) {
        return StringUtils.EMPTY;
    }
    // Handle array encoding
    // Strip Object type encoding
    int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);
    String out = className.substring(lastDotIdx + 1);
    if (innerIdx != -1) {
        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
    }
    return out;
}","public void test4646() throws Throwable {
    Class<Boolean> class0 = Boolean.class;
    ClassUtils.getPackageCanonicalName(class0);
    ClassUtils.getShortCanonicalName((Object) ""java.lang"", ""java.ext.dirs"");
    ClassUtils.getShortClassName(""java.ext.dirs"");
}","/**
 * <p>Gets the class name minus the package name from a String.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 *
 * @param className  the className to get the short name for
 * @return the class name of the class without the package name or an empty string
 */"
"// Package name
// ----------------------------------------------------------------------
/**
 * <p>Gets the package name of an <code>Object</code>.</p>
 *
 * @param object  the class to get the package name for, may be null
 * @param valueIfNull  the value to return if null
 * @return the package name of the object, or the null value
 */
public static String getPackageName(Object object, String valueIfNull) {
    if (object == null) {
        return valueIfNull;
    }
    return getPackageName(object.getClass());
}","public void test4747() throws Throwable {
    ClassUtils.isAssignable((Class<?>[]) null, (Class<?>[]) null, false);
    Byte byte0 = new Byte((byte) 5);
    Byte.toUnsignedInt((byte) 5);
    Byte.compare((byte) 5, (byte) 5);
    Byte.compare((byte) 5, (byte) (-1));
    ClassUtils.getPackageCanonicalName((Object) byte0, ""pyCu!"");
    LinkedList<String> linkedList0 = new LinkedList<String>();
    linkedList0.add(""pyCu!"");
    linkedList0.removeLast();
    ClassUtils.convertClassNamesToClasses(linkedList0);
    ClassUtils.getShortCanonicalName(""9.kY)aq|X\"""");
    linkedList0.add((String) null);
    ClassUtils.isAssignable((Class<?>[]) null, (Class<?>[]) null);
    Class<Long> class0 = Long.class;
    String string0 = ClassUtils.getPackageName(class0);
    linkedList0.poll();
    Class<Double> class1 = Double.TYPE;
    ClassUtils.getShortClassName((Object) class1, ""pyCu!"");
    ClassUtils.getPackageCanonicalName(""java.lang"");
    ClassUtils.convertClassNamesToClasses(linkedList0);
    Class<String> class2 = String.class;
    ClassUtils.isAssignable(class1, class2, true);
    ClassUtils.getClass(""Class"");
    ClassUtils.getPackageName(string0);
    Object object0 = new Object();
    String string1 = ""', is neither of type Map.Entry nor an Array"";
    ClassUtils.getPackageName(object0, string1);
}",""
"public static String getShortClassName(String className) {
    if (className == null) {
        return StringUtils.EMPTY;
    }
    if (className.length() == 0) {
        return StringUtils.EMPTY;
    }
    // Handle array encoding
    // Strip Object type encoding
    int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);
    String out = className.substring(lastDotIdx + 1);
    if (innerIdx != -1) {
        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
    }
    return out;
}","public void test4848() throws Throwable {
    Object[] objectArray0 = new Object[4];
    Object object0 = new Object();
    objectArray0[0] = object0;
    Object object1 = new Object();
    objectArray0[1] = object1;
    Object object2 = new Object();
    objectArray0[2] = object2;
    Object object3 = new Object();
    objectArray0[3] = object3;
    Class<?>[] classArray0 = ClassUtils.toClass(objectArray0);
    Class<Boolean> class0 = Boolean.class;
    ClassUtils.getAllSuperclasses(class0);
    Class<?>[] classArray1 = ClassUtils.toClass(classArray0);
    ClassUtils.getShortClassName(""ENlz#w5Z"");
    ClassUtils.getPublicMethod(class0, (String) null, classArray1);
    String string0 = """";
    // Undeclared exception!
    try {
        ClassUtils.getShortClassName(string0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
    }
}","/**
 * <p>Gets the class name minus the package name from a String.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 *
 * @param className  the className to get the short name for
 * @return the class name of the class without the package name or an empty string
 */"
"public static Class<?>[] wrappersToPrimitives(Class<?>[] classes) {
    if (classes == null) {
        return null;
    }
    if (classes.length == 0) {
        return classes;
    }
    Class<?>[] convertedClasses = new Class[classes.length];
    for (int i = 0; i < classes.length; i++) {
        convertedClasses[i] = wrapperToPrimitive(classes[i]);
    }
    return convertedClasses;
}","public void test4949() throws Throwable {
    Class<Object> class0 = Object.class;
    ClassUtils.getShortClassName(class0);
    ClassUtils.primitivesToWrappers((Class<?>[]) null);
    ClassUtils.isAssignable((Class<?>[]) null, (Class<?>[]) null, true);
    ClassUtils.getShortClassName("""");
    ClassUtils.primitivesToWrappers((Class<?>[]) null);
    ClassUtils.wrappersToPrimitives((Class<?>[]) null);
}","/**
 * <p>Converts the specified array of wrapper Class objects to an array of
 * its corresponding primitive Class objects.</p>
 *
 * <p>This method invokes <code>wrapperToPrimitive()</code> for each element
 * of the passed in array.</p>
 *
 * @param classes  the class array to convert, may be null or empty
 * @return an array which contains for each given class, the primitive class or
 * <b>null</b> if the original class is not a wrapper class. <code>null</code> if null input.
 * Empty array if an empty array passed in.
 * @see #wrapperToPrimitive(Class)
 * @since 2.4
 */"
"public static String getPackageCanonicalName(Class<?> cls) {
    if (cls == null) {
        return StringUtils.EMPTY;
    }
    return getPackageCanonicalName(cls.getName());
}","public void test5050() throws Throwable {
    Integer integer0 = new Integer((-1));
    Integer.toUnsignedString(48);
    ClassUtils.getPackageName((Object) integer0, """");
    ClassUtils classUtils0 = new ClassUtils();
    ClassUtils.getPackageCanonicalName((Object) null, ""java.awt.headless"");
    Class<Long> class0 = Long.class;
    ClassUtils.isInnerClass(class0);
    ClassUtils.getPackageCanonicalName(class0);
}","/**
 * <p>Gets the package name from the canonical name of a <code>Class</code>.</p>
 *
 * @param cls  the class to get the package name for, may be <code>null</code>.
 * @return the package name or an empty string
 * @since 2.4
 */"
"public static Class<?> primitiveToWrapper(Class<?> cls) {
    Class<?> convertedClass = cls;
    if (cls != null && cls.isPrimitive()) {
        convertedClass = primitiveWrapperMap.get(cls);
    }
    return convertedClass;
}","public void test5151() throws Throwable {
    Class<Object> class0 = Object.class;
    ClassUtils.wrapperToPrimitive(class0);
    Object object0 = new Object();
    ClassUtils.getShortClassName(object0, ""java.awt.printerjob"");
    Class<String>[] classArray0 = (Class<String>[]) Array.newInstance(Class.class, 0);
    ClassUtils.primitivesToWrappers(classArray0);
    ClassUtils.getAllSuperclasses((Class<?>) null);
    ClassUtils.getPackageCanonicalName((Class<?>) null);
    ClassUtils.getPackageCanonicalName((Object) ""java.awt.printerjob"", ""eX5A[>%C8Kn=k]"");
    ClassUtils.getShortClassName((Object) null, ""Windows 9"");
    ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
    ClassUtils.getClass(classLoader0, ""java.lang"");
    Class<Integer> class1 = Integer.class;
    ClassUtils.primitiveToWrapper(class1);
}","/**
 * <p>Converts the specified primitive Class object to its corresponding
 * wrapper Class object.</p>
 *
 * <p>NOTE: From v2.2, this method handles <code>Void.TYPE</code>,
 * returning <code>Void.TYPE</code>.</p>
 *
 * @param cls  the class to convert, may be null
 * @return the wrapper class for <code>cls</code> or <code>cls</code> if
 * <code>cls</code> is not a primitive. <code>null</code> if null input.
 * @since 2.1
 */"
"public static String getPackageCanonicalName(String canonicalName) {
    return ClassUtils.getPackageName(getCanonicalName(canonicalName));
}","public void test5252() throws Throwable {
    Class<Byte> class0 = Byte.TYPE;
    ClassUtils.getPackageName((Object) class0, ""&gHsATfMT<)UJA "");
    Class<Long> class1 = Long.TYPE;
    ClassUtils.getPackageName((Object) class1, ""&gHsATfMT<)UJA "");
    ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
    classLoader0.clearAssertionStatus();
    ClassLoader classLoader1 = classLoader0.getParent();
    classLoader0.setPackageAssertionStatus("""", true);
    ClassUtils.getClass(classLoader1, ""byte"", false);
    Class<String> class2 = String.class;
    ClassUtils.isAssignable(class0, class2);
    ClassUtils.getPackageCanonicalName(""S"");
}","/**
 * <p>Gets the package name from the canonical name. </p>
 *
 * <p>The string passed in is assumed to be a canonical name - it is not checked.</p>
 * <p>If the class is unpackaged, return an empty string.</p>
 *
 * @param canonicalName  the canonical name to get the package name for, may be <code>null</code>
 * @return the package name or an empty string
 * @since 2.4
 */"
"// Package name
// ----------------------------------------------------------------------
/**
 * <p>Gets the package name of an <code>Object</code>.</p>
 *
 * @param object  the class to get the package name for, may be null
 * @param valueIfNull  the value to return if null
 * @return the package name of the object, or the null value
 */
public static String getPackageName(Object object, String valueIfNull) {
    if (object == null) {
        return valueIfNull;
    }
    return getPackageName(object.getClass());
}","public void test5353() throws Throwable {
    ClassUtils.getPackageName("",wS"");
    Class<Boolean> class0 = Boolean.class;
    ClassUtils.getShortClassName(class0);
    ClassUtils classUtils0 = new ClassUtils();
    Class<String>[] classArray0 = (Class<String>[]) Array.newInstance(Class.class, 6);
    Class<String> class1 = String.class;
    classArray0[0] = class1;
    Class<String> class2 = String.class;
    classArray0[1] = class2;
    Class<String> class3 = String.class;
    classArray0[2] = class3;
    Class<String> class4 = String.class;
    classArray0[3] = class4;
    Class<String> class5 = String.class;
    classArray0[4] = class5;
    Class<String> class6 = String.class;
    classArray0[5] = class6;
    Class<Character>[] classArray1 = (Class<Character>[]) Array.newInstance(Class.class, 2);
    Class<Character> class7 = Character.class;
    classArray1[0] = class7;
    Class<Character> class8 = Character.class;
    classArray1[1] = class8;
    ClassUtils.isAssignable(classArray0, classArray1);
    ClassUtils.getPackageName((Object) classUtils0, (String) null);
}",""
"// Is assignable
// ----------------------------------------------------------------------
/**
 * <p>Checks if an array of Classes can be assigned to another array of Classes.</p>
 *
 * <p>This method calls {@link #isAssignable(Class, Class) isAssignable} for each
 * Class pair in the input arrays. It can be used to check if a set of arguments
 * (the first parameter) are suitably compatible with a set of method parameter types
 * (the second parameter).</p>
 *
 * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this
 * method takes into account widenings of primitive classes and
 * <code>null</code>s.</p>
 *
 * <p>Primitive widenings allow an int to be assigned to a <code>long</code>,
 * <code>float</code> or <code>double</code>. This method returns the correct
 * result for these cases.</p>
 *
 * <p><code>Null</code> may be assigned to any reference type. This method will
 * return <code>true</code> if <code>null</code> is passed in and the toClass is
 * non-primitive.</p>
 *
 * <p>Specifically, this method tests whether the type represented by the
 * specified <code>Class</code> parameter can be converted to the type
 * represented by this <code>Class</code> object via an identity conversion
 * widening primitive or widening reference conversion. See
 * <em><a href=""http://java.sun.com/docs/books/jls/"">The Java Language Specification</a></em>,
 * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>
 *
 * @param classArray  the array of Classes to check, may be <code>null</code>
 * @param toClassArray  the array of Classes to try to assign into, may be <code>null</code>
 * @return <code>true</code> if assignment possible
 */
//TODO when we bump the major version we should default autoboxing to true on platforms >= 1.5
public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray) {
    return isAssignable(classArray, toClassArray, false);
}","public void test5555() throws Throwable {
    ClassUtils classUtils0 = new ClassUtils();
    Character character0 = Character.valueOf('9');
    Character.lowSurrogate(228);
    ClassUtils.getShortClassName((Object) character0, "";"");
    Boolean boolean0 = new Boolean(false);
    Boolean.getBoolean(""!"");
    ClassUtils.getPackageName((Object) boolean0, ""double"");
    ClassUtils.getPackageName((Object) classUtils0, ""."");
    Class<Short> class0 = Short.class;
    ClassUtils.wrapperToPrimitive(class0);
    Class<?> class1 = ClassUtils.getClass(""double"");
    ClassUtils.getShortClassName(""NmYS($&ki{sz7UeHgw6"");
    ClassUtils.getPackageName(class1);
    ClassUtils.getShortClassName(""org.apache.commons.lang"");
    List<Class<?>> list0 = ClassUtils.getAllSuperclasses(class0);
    ClassUtils.getPackageName((Object) list0, ""$"");
    Class<String>[] classArray0 = (Class<String>[]) Array.newInstance(Class.class, 4);
    Class<String> class2 = String.class;
    classArray0[0] = class2;
    Class<String> class3 = String.class;
    classArray0[1] = class3;
    Class<String> class4 = String.class;
    classArray0[2] = class4;
    Class<String> class5 = String.class;
    classArray0[3] = class5;
    Class<Object>[] classArray1 = (Class<Object>[]) Array.newInstance(Class.class, 5);
    Class<Object> class6 = Object.class;
    classArray1[0] = class6;
    Class<Object> class7 = Object.class;
    classArray1[1] = class7;
    Class<Object> class8 = Object.class;
    classArray1[2] = class8;
    Class<Object> class9 = Object.class;
    classArray1[3] = class9;
    Class<Object> class10 = Object.class;
    classArray1[4] = class10;
    ClassUtils.isAssignable(classArray0, classArray1);
}",""
"public static String getShortClassName(String className) {
    if (className == null) {
        return StringUtils.EMPTY;
    }
    if (className.length() == 0) {
        return StringUtils.EMPTY;
    }
    // Handle array encoding
    // Strip Object type encoding
    int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);
    String out = className.substring(lastDotIdx + 1);
    if (innerIdx != -1) {
        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
    }
    return out;
}","public void test5656() throws Throwable {
    Class<Character>[] classArray0 = (Class<Character>[]) Array.newInstance(Class.class, 8);
    Class<Character> class0 = Character.class;
    classArray0[0] = class0;
    Class<Character> class1 = Character.class;
    classArray0[1] = class1;
    Class<Character> class2 = Character.class;
    classArray0[2] = class2;
    Class<Character> class3 = Character.class;
    classArray0[3] = class3;
    Class<Character> class4 = Character.class;
    classArray0[4] = class4;
    Class<Character> class5 = Character.class;
    classArray0[5] = class5;
    Class<Character> class6 = Character.class;
    classArray0[6] = class6;
    Class<Character> class7 = Character.class;
    classArray0[7] = class7;
    ClassUtils.primitivesToWrappers(classArray0);
    Class<String> class8 = String.class;
    ClassUtils.getAllInterfaces(class8);
    ClassUtils classUtils0 = new ClassUtils();
    ClassUtils.isAssignable(classArray0, classArray0);
    Class<Object> class9 = Object.class;
    ClassUtils.getAllSuperclasses(class9);
    Class<Object> class10 = Object.class;
    ClassUtils.isInnerClass(class10);
    ClassUtils.getShortClassName("""");
}","/**
 * <p>Gets the class name minus the package name from a String.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 *
 * @param className  the className to get the short name for
 * @return the class name of the class without the package name or an empty string
 */"
"public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) {
    if (ArrayUtils.isSameLength(classArray, toClassArray) == false) {
        return false;
    }
    if (classArray == null) {
        classArray = ArrayUtils.EMPTY_CLASS_ARRAY;
    }
    if (toClassArray == null) {
        toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY;
    }
    for (int i = 0; i < classArray.length; i++) {
        if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) {
            return false;
        }
    }
    return true;
}","public void test5757() throws Throwable {
    Character character0 = new Character('3');
    Character.highSurrogate(3);
    Character.lowSurrogate(3);
    ClassUtils.getShortClassName((Object) character0, """");
    ClassUtils.getPackageName((Object) null, ""B"");
    Class<String>[] classArray0 = (Class<String>[]) Array.newInstance(Class.class, 6);
    Class<String> class0 = String.class;
    classArray0[0] = class0;
    Class<String> class1 = String.class;
    classArray0[1] = class1;
    Class<String> class2 = String.class;
    classArray0[2] = class2;
    Class<String> class3 = String.class;
    classArray0[3] = class3;
    Class<String> class4 = String.class;
    classArray0[4] = class4;
    Class<String> class5 = String.class;
    classArray0[5] = class5;
    ClassUtils.isAssignable(classArray0, classArray0, true);
}","/**
 * <p>Checks if an array of Classes can be assigned to another array of Classes.</p>
 *
 * <p>This method calls {@link #isAssignable(Class, Class) isAssignable} for each
 * Class pair in the input arrays. It can be used to check if a set of arguments
 * (the first parameter) are suitably compatible with a set of method parameter types
 * (the second parameter).</p>
 *
 * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this
 * method takes into account widenings of primitive classes and
 * <code>null</code>s.</p>
 *
 * <p>Primitive widenings allow an int to be assigned to a <code>long</code>,
 * <code>float</code> or <code>double</code>. This method returns the correct
 * result for these cases.</p>
 *
 * <p><code>Null</code> may be assigned to any reference type. This method will
 * return <code>true</code> if <code>null</code> is passed in and the toClass is
 * non-primitive.</p>
 *
 * <p>Specifically, this method tests whether the type represented by the
 * specified <code>Class</code> parameter can be converted to the type
 * represented by this <code>Class</code> object via an identity conversion
 * widening primitive or widening reference conversion. See
 * <em><a href=""http://java.sun.com/docs/books/jls/"">The Java Language Specification</a></em>,
 * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>
 *
 * @param classArray  the array of Classes to check, may be <code>null</code>
 * @param toClassArray  the array of Classes to try to assign into, may be <code>null</code>
 * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers
 * @return <code>true</code> if assignment possible
 */"
"// Inner class
// ----------------------------------------------------------------------
/**
 * <p>Is the specified class an inner class or static nested class.</p>
 *
 * @param cls  the class to check, may be null
 * @return <code>true</code> if the class is an inner or static nested class,
 *  false if not or <code>null</code>
 */
public static boolean isInnerClass(Class<?> cls) {
    if (cls == null) {
        return false;
    }
    return cls.getName().indexOf(INNER_CLASS_SEPARATOR_CHAR) >= 0;
}","public void test5959() throws Throwable {
    Class<Object> class0 = Object.class;
    ClassUtils.getPackageName(class0);
    ClassUtils.getShortCanonicalName((Object) ""java.lang"", ""java.lang"");
    Class<String> class1 = String.class;
    ClassUtils.getShortClassName(class1);
    ClassUtils.getShortCanonicalName((String) null);
    Class<Double> class2 = Double.class;
    ClassUtils.isAssignable(class2, class2, false);
    Class<Boolean>[] classArray0 = (Class<Boolean>[]) Array.newInstance(Class.class, 7);
    Class<Boolean> class3 = Boolean.class;
    classArray0[0] = class3;
    Class<Boolean> class4 = Boolean.class;
    classArray0[1] = class4;
    Class<Boolean> class5 = Boolean.class;
    classArray0[2] = class5;
    Class<Boolean> class6 = Boolean.class;
    classArray0[3] = class6;
    Class<Boolean> class7 = Boolean.class;
    classArray0[4] = class7;
    Class<Boolean> class8 = Boolean.class;
    classArray0[5] = class8;
    Class<Boolean> class9 = Boolean.class;
    classArray0[6] = class9;
    ClassUtils.wrappersToPrimitives(classArray0);
    Class<Long> class10 = Long.class;
    ClassUtils.primitiveToWrapper(class10);
    ClassUtils.isInnerClass(class7);
}",""
"public static String getShortCanonicalName(String canonicalName) {
    return ClassUtils.getShortClassName(getCanonicalName(canonicalName));
}","public void test6060() throws Throwable {
    Class<Byte>[] classArray0 = (Class<Byte>[]) Array.newInstance(Class.class, 6);
    Class<Byte> class0 = Byte.class;
    classArray0[0] = class0;
    Class<Byte> class1 = Byte.class;
    classArray0[1] = class1;
    Class<Byte> class2 = Byte.class;
    classArray0[2] = class2;
    Class<Byte> class3 = Byte.class;
    classArray0[3] = class3;
    Class<Byte> class4 = Byte.class;
    classArray0[4] = class4;
    Class<Byte> class5 = Byte.class;
    classArray0[5] = class5;
    ClassUtils.isAssignable(classArray0, classArray0, true);
    Class<Long> class6 = Long.class;
    ClassUtils.isAssignable(class0, class6);
    Class<ClassUtils> class7 = ClassUtils.class;
    ClassUtils.isAssignable(class0, class7);
    ClassUtils.getAllSuperclasses(class0);
    String string0 = null;
    ClassUtils.getShortClassName((String) null);
    ClassUtils.isInnerClass(class2);
    ClassUtils.getClass("""", true);
    String string1 = ""]$;)"";
    // Undeclared exception!
    try {
        ClassUtils.getShortCanonicalName(string1);
        fail(""Expecting exception: ClassNotFoundException"");
    } catch (Throwable e) {
    }
}","/**
 * <p>Gets the canonical name minus the package name from a String.</p>
 *
 * <p>The string passed in is assumed to be a canonical name - it is not checked.</p>
 *
 * @param canonicalName  the class name to get the short name for
 * @return the canonical name of the class without the package name or an empty string
 * @since 2.4
 */"
"// Class loading
// ----------------------------------------------------------------------
/**
 * Returns the class represented by <code>className</code> using the
 * <code>classLoader</code>.  This implementation supports names like
 * ""<code>java.lang.String[]</code>"" as well as ""<code>[Ljava.lang.String;</code>"".
 *
 * @param classLoader  the class loader to use to load the class
 * @param className  the class name
 * @param initialize  whether the class must be initialized
 * @return the class represented by <code>className</code> using the <code>classLoader</code>
 * @throws ClassNotFoundException if the class is not found
 */
public static Class<?> getClass(ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException {
    Class<?> clazz;
    if (abbreviationMap.containsKey(className)) {
        String clsName = ""["" + abbreviationMap.get(className);
        clazz = Class.forName(clsName, initialize, classLoader).getComponentType();
    } else {
        clazz = Class.forName(toCanonicalName(className), initialize, classLoader);
    }
    return clazz;
}","public void test6161() throws Throwable {
    ClassUtils classUtils0 = new ClassUtils();
    Class<Object> class0 = Object.class;
    List<Class<?>> list0 = ClassUtils.getAllSuperclasses(class0);
    ClassUtils.getPackageCanonicalName((Object) classUtils0, ""$"");
    Class<String> class1 = String.class;
    boolean boolean0 = true;
    List<String> list1 = ClassUtils.convertClassesToClassNames(list0);
    ClassUtils.convertClassNamesToClasses(list1);
    ClassLoader classLoader0 = null;
    try {
        ClassUtils.getClass((ClassLoader) null, ""."", true);
        fail(""Expecting exception: ClassNotFoundException"");
    } catch (ClassNotFoundException e) {
    }
}",""
"public static String getShortCanonicalName(String canonicalName) {
    return ClassUtils.getShortClassName(getCanonicalName(canonicalName));
}","public void test6262() throws Throwable {
    Class<Float> class0 = Float.TYPE;
    ClassUtils.getShortClassName(class0);
    ClassUtils.isInnerClass(class0);
    ClassUtils.getShortCanonicalName((Class<?>) null);
    ClassUtils.getShortCanonicalName("":50>3?9"");
}","/**
 * <p>Gets the canonical name minus the package name from a String.</p>
 *
 * <p>The string passed in is assumed to be a canonical name - it is not checked.</p>
 *
 * @param canonicalName  the class name to get the short name for
 * @return the canonical name of the class without the package name or an empty string
 * @since 2.4
 */"
"public static Class<?> wrapperToPrimitive(Class<?> cls) {
    return wrapperPrimitiveMap.get(cls);
}","public void test6363() throws Throwable {
    Class<Short> class0 = Short.class;
    Class<Long> class1 = Long.TYPE;
    ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
    ClassLoader classLoader1 = classLoader0.getParent();
    classLoader1.setPackageAssertionStatus(""0Fl;Q-3Y"", false);
    Class<Double> class2 = Double.class;
    List<Class<?>> list0 = ClassUtils.getAllInterfaces(class2);
    ClassUtils.getPackageName((Object) list0, """");
    ClassUtils.getShortCanonicalName(class0);
    ClassUtils.getPackageCanonicalName("""");
    Class<Long> class3 = Long.class;
    ClassUtils.isInnerClass(class3);
    classLoader1.clearAssertionStatus();
    List<String> list1 = ClassUtils.convertClassesToClassNames(list0);
    ClassUtils.convertClassNamesToClasses(list1);
    Integer integer0 = new Integer(64);
    ClassUtils.getShortClassName((Object) integer0, ""J"");
    classLoader1.setPackageAssertionStatus(""0Fl;Q-3Y"", false);
    ClassUtils.getClass(classLoader0, """", true);
    Class<Object> class4 = Object.class;
    ClassUtils.wrapperToPrimitive(class4);
}","/**
 * <p>Converts the specified wrapper class to its corresponding primitive
 * class.</p>
 *
 * <p>This method is the counter part of <code>primitiveToWrapper()</code>.
 * If the passed in class is a wrapper class for a primitive type, this
 * primitive type will be returned (e.g. <code>Integer.TYPE</code> for
 * <code>Integer.class</code>). For other classes, or if the parameter is
 * <b>null</b>, the return value is <b>null</b>.</p>
 *
 * @param cls the class to convert, may be <b>null</b>
 * @return the corresponding primitive type if <code>cls</code> is a
 * wrapper class, <b>null</b> otherwise
 * @see #primitiveToWrapper(Class)
 * @since 2.4
 */"
"public static Class<?>[] toClass(Object[] array) {
    if (array == null) {
        return null;
    } else if (array.length == 0) {
        return ArrayUtils.EMPTY_CLASS_ARRAY;
    }
    Class<?>[] classes = new Class[array.length];
    for (int i = 0; i < array.length; i++) {
        classes[i] = array[i].getClass();
    }
    return classes;
}","public void test6464() throws Throwable {
    Object object0 = new Object();
    Object[] objectArray0 = new Object[8];
    objectArray0[3] = object0;
    objectArray0[4] = object0;
    objectArray0[7] = object0;
    // Undeclared exception!
    try {
        ClassUtils.toClass(objectArray0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang.ClassUtils"", e);
    }
}","/**
 * <p>Converts an array of <code>Object</code> in to an array of <code>Class</code> objects.</p>
 *
 * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
 *
 * @param array an <code>Object</code> array
 * @return a <code>Class</code> array, <code>null</code> if null array input
 * @since 2.4
 */"
"public static Class<?> getClass(String className, boolean initialize) throws ClassNotFoundException {
    ClassLoader contextCL = Thread.currentThread().getContextClassLoader();
    ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;
    return getClass(loader, className, initialize);
}","public void test6565() throws Throwable {
    Class<Object> class0 = Object.class;
    ClassUtils.getShortClassName(class0);
    ClassUtils.primitivesToWrappers((Class<?>[]) null);
    ClassUtils.getShortClassName("""");
    ClassUtils.primitivesToWrappers((Class<?>[]) null);
    ClassUtils.wrappersToPrimitives((Class<?>[]) null);
    ClassUtils.getClass((String) null, false);
}","/**
 * Returns the class represented by <code>className</code> using the
 * current thread's context class loader. This implementation supports
 * names like ""<code>java.lang.String[]</code>"" as well as
 * ""<code>[Ljava.lang.String;</code>"".
 *
 * @param className  the class name
 * @param initialize  whether the class must be initialized
 * @return the class represented by <code>className</code> using the current thread's context class loader
 * @throws ClassNotFoundException if the class is not found
 */"
"public static String getShortCanonicalName(String canonicalName) {
    return ClassUtils.getShortClassName(getCanonicalName(canonicalName));
}","public void test6666() throws Throwable {
    Class<Double> class0 = Double.class;
    ClassUtils.getPackageName(class0);
    ClassUtils.getPackageName(class0);
    ClassUtils classUtils0 = new ClassUtils();
    LinkedList<String> linkedList0 = new LinkedList<String>();
    linkedList0.add(""java.lang"");
    ClassUtils.convertClassNamesToClasses(linkedList0);
    Class<Double>[] classArray0 = (Class<Double>[]) Array.newInstance(Class.class, 3);
    Class<Double> class1 = Double.class;
    classArray0[0] = class1;
    classArray0[1] = class0;
    classArray0[2] = class0;
    ClassUtils.isAssignable(classArray0, classArray0);
    Byte byte0 = new Byte((byte) (-48));
    ClassUtils.getPackageCanonicalName((Object) byte0, ""java.lang"");
    Class<Double> class2 = Double.class;
    ClassUtils.primitiveToWrapper(class2);
    ClassUtils.getShortCanonicalName((Object) class2, ""$"");
    Class<Boolean> class3 = Boolean.class;
    ClassUtils.getAllSuperclasses(class3);
    Class<?>[] classArray1 = ClassUtils.wrappersToPrimitives(classArray0);
    ClassUtils.isAssignable(classArray1, classArray0, false);
    ClassUtils.getShortCanonicalName(""[IvWC:-J"");
}","/**
 * <p>Gets the canonical name minus the package name from a String.</p>
 *
 * <p>The string passed in is assumed to be a canonical name - it is not checked.</p>
 *
 * @param canonicalName  the class name to get the short name for
 * @return the canonical name of the class without the package name or an empty string
 * @since 2.4
 */"
"public static String getShortCanonicalName(String canonicalName) {
    return ClassUtils.getShortClassName(getCanonicalName(canonicalName));
}","public void test6868() throws Throwable {
    Class<Double> class0 = Double.class;
    ClassUtils.getPackageName(class0);
    ClassUtils.getPackageName(class0);
    ClassUtils classUtils0 = new ClassUtils();
    Class<Double>[] classArray0 = (Class<Double>[]) Array.newInstance(Class.class, 3);
    Class<Double> class1 = Double.class;
    classArray0[0] = class1;
    classArray0[1] = class0;
    classArray0[2] = class0;
    ClassUtils.isAssignable(classArray0, classArray0);
    Byte byte0 = new Byte((byte) (-48));
    ClassUtils.getPackageCanonicalName((Object) byte0, ""java.lang"");
    Class<Double> class2 = Double.TYPE;
    ClassUtils.primitiveToWrapper(class2);
    ClassUtils.getShortCanonicalName((Object) class2, ""$"");
    Class<Boolean> class3 = Boolean.class;
    ClassUtils.getAllSuperclasses(class3);
    Class<?>[] classArray1 = ClassUtils.wrappersToPrimitives(classArray0);
    ClassUtils.isAssignable(classArray1, classArray0, true);
    ClassUtils.getShortCanonicalName(""[IvWC:-J"");
}","/**
 * <p>Gets the canonical name minus the package name from a String.</p>
 *
 * <p>The string passed in is assumed to be a canonical name - it is not checked.</p>
 *
 * @param canonicalName  the class name to get the short name for
 * @return the canonical name of the class without the package name or an empty string
 * @since 2.4
 */"
"public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException {
    return getClass(classLoader, className, true);
}","public void test6969() throws Throwable {
    ClassUtils.toClass((Object[]) null);
    boolean boolean0 = new Boolean(false);
    ClassUtils.getPackageCanonicalName((String) null);
    ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
    classLoader0.setPackageAssertionStatus(""Z1NJriX"", false);
    ClassUtils.getClass(classLoader0, (String) null);
}","/**
 * Returns the (initialized) class represented by <code>className</code>
 * using the <code>classLoader</code>.  This implementation supports names
 * like ""<code>java.lang.String[]</code>"" as well as
 * ""<code>[Ljava.lang.String;</code>"".
 *
 * @param classLoader  the class loader to use to load the class
 * @param className  the class name
 * @return the class represented by <code>className</code> using the <code>classLoader</code>
 * @throws ClassNotFoundException if the class is not found
 */"
"public static String getShortClassName(String className) {
    if (className == null) {
        return StringUtils.EMPTY;
    }
    if (className.length() == 0) {
        return StringUtils.EMPTY;
    }
    // Handle array encoding
    // Strip Object type encoding
    int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
    int innerIdx = className.indexOf(INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);
    String out = className.substring(lastDotIdx + 1);
    if (innerIdx != -1) {
        out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
    }
    return out;
}","public void test7070() throws Throwable {
    Class<Short>[] classArray0 = (Class<Short>[]) Array.newInstance(Class.class, 3);
    Class<Short> class0 = Short.class;
    classArray0[0] = class0;
    Class<Short> class1 = Short.class;
    classArray0[1] = class1;
    Class<Short> class2 = Short.class;
    classArray0[2] = class2;
    Class<?>[] classArray1 = ClassUtils.wrappersToPrimitives(classArray0);
    Object object0 = new Object();
    ClassUtils.getShortCanonicalName(object0, ""long"");
    ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
    classLoader0.getParent();
    Class<?> class3 = ClassUtils.getClass(classLoader0, ""long"", true);
    classLoader0.setClassAssertionStatus(""long"", false);
    Class<Object> class4 = Object.class;
    ClassUtils.isAssignable(class3, class4, false);
    ClassUtils.primitivesToWrappers(classArray0);
    ClassUtils.getPackageCanonicalName(""H#SP\""<<\""O6D3V"");
    ClassUtils.getAllInterfaces(class3);
    List<Class<?>> list0 = ClassUtils.getAllSuperclasses(class3);
    ClassUtils.primitivesToWrappers(classArray1);
    ClassUtils.getAllInterfaces(class0);
    Class<Double> class5 = Double.class;
    ClassUtils.getAllInterfaces(class5);
    ClassUtils.getClass(classLoader0, ""long"");
    ClassUtils.convertClassesToClassNames(list0);
    ClassUtils.getShortClassName(""<rG8,Zq"");
}","/**
 * <p>Gets the class name minus the package name from a String.</p>
 *
 * <p>The string passed in is assumed to be a class name - it is not checked.</p>
 *
 * @param className  the className to get the short name for
 * @return the class name of the class without the package name or an empty string
 */"
"public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) {
    if (ArrayUtils.isSameLength(classArray, toClassArray) == false) {
        return false;
    }
    if (classArray == null) {
        classArray = ArrayUtils.EMPTY_CLASS_ARRAY;
    }
    if (toClassArray == null) {
        toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY;
    }
    for (int i = 0; i < classArray.length; i++) {
        if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) {
            return false;
        }
    }
    return true;
}","public void test7171() throws Throwable {
    Class<Object> class0 = Object.class;
    ClassUtils.wrapperToPrimitive(class0);
    ClassUtils.getShortClassName(""EMW"");
    ClassUtils.primitiveToWrapper((Class<?>) null);
    Class<String>[] classArray0 = (Class<String>[]) Array.newInstance(Class.class, 5);
    Class<String> class1 = String.class;
    classArray0[0] = class1;
    Class<String> class2 = String.class;
    classArray0[1] = class2;
    Class<String> class3 = String.class;
    classArray0[2] = class3;
    Class<String> class4 = String.class;
    classArray0[3] = class4;
    Class<String> class5 = String.class;
    classArray0[4] = class5;
    ClassUtils.isAssignable(classArray0, classArray0, false);
}","/**
 * <p>Checks if an array of Classes can be assigned to another array of Classes.</p>
 *
 * <p>This method calls {@link #isAssignable(Class, Class) isAssignable} for each
 * Class pair in the input arrays. It can be used to check if a set of arguments
 * (the first parameter) are suitably compatible with a set of method parameter types
 * (the second parameter).</p>
 *
 * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this
 * method takes into account widenings of primitive classes and
 * <code>null</code>s.</p>
 *
 * <p>Primitive widenings allow an int to be assigned to a <code>long</code>,
 * <code>float</code> or <code>double</code>. This method returns the correct
 * result for these cases.</p>
 *
 * <p><code>Null</code> may be assigned to any reference type. This method will
 * return <code>true</code> if <code>null</code> is passed in and the toClass is
 * non-primitive.</p>
 *
 * <p>Specifically, this method tests whether the type represented by the
 * specified <code>Class</code> parameter can be converted to the type
 * represented by this <code>Class</code> object via an identity conversion
 * widening primitive or widening reference conversion. See
 * <em><a href=""http://java.sun.com/docs/books/jls/"">The Java Language Specification</a></em>,
 * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>
 *
 * @param classArray  the array of Classes to check, may be <code>null</code>
 * @param toClassArray  the array of Classes to try to assign into, may be <code>null</code>
 * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers
 * @return <code>true</code> if assignment possible
 */"
"// Class loading
// ----------------------------------------------------------------------
/**
 * Returns the class represented by <code>className</code> using the
 * <code>classLoader</code>.  This implementation supports names like
 * ""<code>java.lang.String[]</code>"" as well as ""<code>[Ljava.lang.String;</code>"".
 *
 * @param classLoader  the class loader to use to load the class
 * @param className  the class name
 * @param initialize  whether the class must be initialized
 * @return the class represented by <code>className</code> using the <code>classLoader</code>
 * @throws ClassNotFoundException if the class is not found
 */
public static Class<?> getClass(ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException {
    Class<?> clazz;
    if (abbreviationMap.containsKey(className)) {
        String clsName = ""["" + abbreviationMap.get(className);
        clazz = Class.forName(clsName, initialize, classLoader).getComponentType();
    } else {
        clazz = Class.forName(toCanonicalName(className), initialize, classLoader);
    }
    return clazz;
}","public void test7272() throws Throwable {
    Class<Integer> class0 = Integer.TYPE;
    ClassUtils.isInnerClass(class0);
    Class<Double> class1 = Double.TYPE;
    ClassUtils.isInnerClass(class1);
    ClassUtils.getPackageName(""byte"");
    ClassUtils.isAssignable(class1, class0, true);
    ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
    classLoader0.getParent();
    classLoader0.setClassAssertionStatus((String) null, true);
    ClassUtils.getClass(classLoader0, """", true);
}",""
"public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {
    if (toClass == null) {
        return false;
    }
    // have to check for null, as isAssignableFrom doesn't
    if (cls == null) {
        return !(toClass.isPrimitive());
    }
    //autoboxing:
    if (autoboxing) {
        if (cls.isPrimitive() && !toClass.isPrimitive()) {
            cls = primitiveToWrapper(cls);
            if (cls == null) {
                return false;
            }
        }
        if (toClass.isPrimitive() && !cls.isPrimitive()) {
            cls = wrapperToPrimitive(cls);
            if (cls == null) {
                return false;
            }
        }
    }
    if (cls.equals(toClass)) {
        return true;
    }
    if (cls.isPrimitive()) {
        if (toClass.isPrimitive() == false) {
            return false;
        }
        if (Integer.TYPE.equals(cls)) {
            return Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Long.TYPE.equals(cls)) {
            return Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Boolean.TYPE.equals(cls)) {
            return false;
        }
        if (Double.TYPE.equals(cls)) {
            return false;
        }
        if (Float.TYPE.equals(cls)) {
            return Double.TYPE.equals(toClass);
        }
        if (Character.TYPE.equals(cls)) {
            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Short.TYPE.equals(cls)) {
            return Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        if (Byte.TYPE.equals(cls)) {
            return Short.TYPE.equals(toClass) || Integer.TYPE.equals(toClass) || Long.TYPE.equals(toClass) || Float.TYPE.equals(toClass) || Double.TYPE.equals(toClass);
        }
        // should never get here
        return false;
    }
    return toClass.isAssignableFrom(cls);
}","public void test7373() throws Throwable {
    Class<Short> class0 = Short.class;
    ClassUtils.getAllInterfaces((Class<?>) null);
    ClassUtils.getPackageCanonicalName(""@<E"");
    ClassUtils.getShortCanonicalName(class0);
    Class<Long> class1 = Long.class;
    Class<Integer> class2 = Integer.class;
    ClassUtils.isAssignable(class1, class2, false);
    ClassUtils.getShortCanonicalName(""Short"");
    Class<String> class3 = String.class;
    ClassUtils.primitiveToWrapper(class3);
    ClassUtils.getPackageCanonicalName(class0);
    Class<Object> class4 = Object.class;
    ClassUtils.isInnerClass(class4);
    ClassUtils.getPackageName(""@<E"");
    Object[] objectArray0 = new Object[3];
    objectArray0[0] = (Object) """";
    objectArray0[1] = (Object) """";
    ClassUtils.getShortClassName(""5.@N4S"");
    objectArray0[2] = (Object) null;
    ClassUtils.toClass(objectArray0);
    Class<ClassUtils> class5 = ClassUtils.class;
    boolean boolean0 = true;
    ClassUtils.isAssignable(class5, class5, boolean0);
}","/**
 * <p>Checks if one <code>Class</code> can be assigned to a variable of
 * another <code>Class</code>.</p>
 *
 * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,
 * this method takes into account widenings of primitive classes and
 * <code>null</code>s.</p>
 *
 * <p>Primitive widenings allow an int to be assigned to a long, float or
 * double. This method returns the correct result for these cases.</p>
 *
 * <p><code>Null</code> may be assigned to any reference type. This method
 * will return <code>true</code> if <code>null</code> is passed in and the
 * toClass is non-primitive.</p>
 *
 * <p>Specifically, this method tests whether the type represented by the
 * specified <code>Class</code> parameter can be converted to the type
 * represented by this <code>Class</code> object via an identity conversion
 * widening primitive or widening reference conversion. See
 * <em><a href=""http://java.sun.com/docs/books/jls/"">The Java Language Specification</a></em>,
 * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>
 *
 * @param cls  the Class to check, may be null
 * @param toClass  the Class to try to assign into, returns false if null
 * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers
 * @return <code>true</code> if assignment possible
 */"
"public static String getShortCanonicalName(String canonicalName) {
    return ClassUtils.getShortClassName(getCanonicalName(canonicalName));
}","public void test7474() throws Throwable {
    Class<Byte>[] classArray0 = (Class<Byte>[]) Array.newInstance(Class.class, 6);
    Class<Byte> class0 = Byte.class;
    Class<Byte> class1 = Byte.class;
    classArray0[1] = class1;
    Class<Byte> class2 = Byte.class;
    classArray0[2] = class2;
    Class<Byte> class3 = Byte.class;
    classArray0[3] = class3;
    Class<Byte> class4 = Byte.class;
    classArray0[4] = class4;
    Class<Byte> class5 = Byte.class;
    classArray0[5] = class5;
    ClassUtils.isAssignable(classArray0, classArray0, true);
    Class<Long> class6 = Long.class;
    ClassUtils.isAssignable(class0, class6);
    Class<ClassUtils> class7 = ClassUtils.class;
    ClassUtils.isAssignable(classArray0[0], class7);
    ClassUtils.getAllSuperclasses(class0);
    String string0 = null;
    ClassUtils.getShortClassName((String) null);
    ClassUtils.isInnerClass(class2);
    ClassUtils.getClass("""", true);
    String string1 = ""]$;)"";
    // Undeclared exception!
    try {
        ClassUtils.getShortCanonicalName(string1);
        fail(""Expecting exception: ClassNotFoundException"");
    } catch (Throwable e) {
    }
}","/**
 * <p>Gets the canonical name minus the package name from a String.</p>
 *
 * <p>The string passed in is assumed to be a canonical name - it is not checked.</p>
 *
 * @param canonicalName  the class name to get the short name for
 * @return the canonical name of the class without the package name or an empty string
 * @since 2.4
 */"
"public static Class<?> primitiveToWrapper(Class<?> cls) {
    Class<?> convertedClass = cls;
    if (cls != null && cls.isPrimitive()) {
        convertedClass = primitiveWrapperMap.get(cls);
    }
    return convertedClass;
}","public void test7575() throws Throwable {
    Class<Object> class0 = Object.class;
    ClassUtils.wrapperToPrimitive(class0);
    Object object0 = new Object();
    Class<String>[] classArray0 = (Class<String>[]) Array.newInstance(Class.class, 0);
    ClassUtils.getAllSuperclasses((Class<?>) null);
    ClassUtils.getPackageName((Class<?>) null);
    ClassLoader.getSystemClassLoader();
    ClassUtils.getAllSuperclasses(class0);
    Class<Integer> class1 = Integer.class;
    ClassUtils.primitiveToWrapper(class1);
}","/**
 * <p>Converts the specified primitive Class object to its corresponding
 * wrapper Class object.</p>
 *
 * <p>NOTE: From v2.2, this method handles <code>Void.TYPE</code>,
 * returning <code>Void.TYPE</code>.</p>
 *
 * @param cls  the class to convert, may be null
 * @return the wrapper class for <code>cls</code> or <code>cls</code> if
 * <code>cls</code> is not a primitive. <code>null</code> if null input.
 * @since 2.1
 */"
"// Short class name
// ----------------------------------------------------------------------
/**
 * <p>Gets the class name minus the package name for an <code>Object</code>.</p>
 *
 * @param object  the class to get the short name for, may be null
 * @param valueIfNull  the value to return if null
 * @return the class name of the object without the package name, or the null value
 */
public static String getShortClassName(Object object, String valueIfNull) {
    if (object == null) {
        return valueIfNull;
    }
    return getShortClassName(object.getClass());
}","public void test7676() throws Throwable {
    Class<Float> class0 = Float.TYPE;
    ClassUtils.getPackageCanonicalName((Object) class0, ""', has a length less than 2"");
    ClassUtils.getShortCanonicalName(""java.lang"");
    ClassUtils.isAssignable(class0, class0);
    Class<Boolean> class1 = Boolean.class;
    Class<Object> class2 = Object.class;
    ClassUtils.getPackageName(class2);
    ClassUtils.isAssignable(class1, class0, true);
    ClassUtils.getShortClassName((Object) class2, "")EwTIK69F*ws["");
}",""
"public static String getShortClassName(Class<?> cls) {
    if (cls == null) {
        return StringUtils.EMPTY;
    }
    return getShortClassName(cls.getName());
}","public void test7878() throws Throwable {
    Class<Short>[] classArray0 = (Class<Short>[]) Array.newInstance(Class.class, 0);
    ClassUtils.wrappersToPrimitives(classArray0);
    Boolean boolean0 = Boolean.valueOf(""k2?"");
    ClassUtils.getPackageName((Object) boolean0, ""MAn5ru"");
    Class<Character> class0 = Character.class;
    ClassUtils.getShortClassName(class0);
}","/**
 * <p>Gets the class name minus the package name from a <code>Class</code>.</p>
 *
 * @param cls  the class to get the short name for.
 * @return the class name without the package name or an empty string
 */"
"public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException {
    return getClass(classLoader, className, true);
}","public void test7979() throws Throwable {
    Class<Object> class0 = Object.class;
    ClassUtils.wrapperToPrimitive(class0);
    Class<Object> class1 = Object.class;
    ClassUtils.isInnerClass(class1);
    ClassUtils.getShortCanonicalName((Class<?>) null);
    ClassUtils.isInnerClass((Class<?>) null);
    ClassLoader classLoader0 = ClassLoader.getSystemClassLoader();
    try {
        ClassUtils.getClass(classLoader0, """");
        fail(""Expecting exception: ClassNotFoundException"");
    } catch (ClassNotFoundException e) {
    }
}","/**
 * Returns the (initialized) class represented by <code>className</code>
 * using the <code>classLoader</code>.  This implementation supports names
 * like ""<code>java.lang.String[]</code>"" as well as
 * ""<code>[Ljava.lang.String;</code>"".
 *
 * @param classLoader  the class loader to use to load the class
 * @param className  the class name
 * @return the class represented by <code>className</code> using the <code>classLoader</code>
 * @throws ClassNotFoundException if the class is not found
 */"
"public static List<String> convertClassesToClassNames(List<Class<?>> classes) {
    if (classes == null) {
        return null;
    }
    List<String> classNames = new ArrayList<String>(classes.size());
    for (Class<?> cls : classes) {
        if (cls == null) {
            classNames.add(null);
        } else {
            classNames.add(cls.getName());
        }
    }
    return classNames;
}","public void test8080() throws Throwable {
    Class<Object> class0 = Object.class;
    ClassUtils.wrapperToPrimitive(class0);
    Object object0 = new Object();
    Class<String>[] classArray0 = (Class<String>[]) Array.newInstance(Class.class, 0);
    ClassUtils.primitivesToWrappers(classArray0);
    ClassUtils.getAllSuperclasses((Class<?>) null);
    ClassUtils.getPackageCanonicalName((Class<?>) null);
    ClassUtils.getShortClassName((Object) null, ""Windows 9"");
    ClassLoader.getSystemClassLoader();
    Class<Integer> class1 = Integer.class;
    ClassUtils.primitiveToWrapper(class1);
    Class<Integer> class2 = Integer.class;
    ClassUtils.wrapperToPrimitive(class2);
    ClassUtils.convertClassesToClassNames((List<Class<?>>) null);
}","/**
 * <p>Given a <code>List</code> of <code>Class</code> objects, this method converts
 * them into class names.</p>
 *
 * <p>A new <code>List</code> is returned. <code>null</code> objects will be copied into
 * the returned list as <code>null</code>.</p>
 *
 * @param classes  the classes to change
 * @return a <code>List</code> of class names corresponding to the Class objects,
 *  <code>null</code> if null input
 * @throws ClassCastException if <code>classes</code> contains a non-<code>Class</code> entry
 */"
