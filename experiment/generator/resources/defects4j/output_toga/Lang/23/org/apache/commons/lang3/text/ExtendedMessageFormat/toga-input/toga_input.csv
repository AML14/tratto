focal_method,test_prefix,docstring
"public ExtendedMessageFormat(String pattern, Map<String, ? extends FormatFactory> registry) {
    this(pattern, Locale.getDefault(), registry);
}","public void test000() throws Throwable {
    HashMap<String, FormatFactory> hashMap0 = new HashMap<String, FormatFactory>();
    ExtendedMessageFormat extendedMessageFormat0 = null;
    try {
        extendedMessageFormat0 = new ExtendedMessageFormat(""b6;C^v*{0 "", hashMap0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format argument index at position 8: 
        //
        verifyException(""org.apache.commons.lang3.text.ExtendedMessageFormat"", e);
    }
}","/**
 * Create a new ExtendedMessageFormat for the default locale.
 *
 * @param pattern  the pattern to use, not null
 * @param registry  the registry of format factories, may be null
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"public ExtendedMessageFormat(String pattern, Map<String, ? extends FormatFactory> registry) {
    this(pattern, Locale.getDefault(), registry);
}","public void test011() throws Throwable {
    HashMap<String, FormatFactory> hashMap0 = new HashMap<String, FormatFactory>();
    ExtendedMessageFormat extendedMessageFormat0 = null;
    try {
        extendedMessageFormat0 = new ExtendedMessageFormat(""79'nT<U(1uE7{+]["", hashMap0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format argument index at position 13: +
        //
        verifyException(""org.apache.commons.lang3.text.ExtendedMessageFormat"", e);
    }
}","/**
 * Create a new ExtendedMessageFormat for the default locale.
 *
 * @param pattern  the pattern to use, not null
 * @param registry  the registry of format factories, may be null
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"@Override
public String toPattern() {
    return toPattern;
}","public void test022() throws Throwable {
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(""/"");
    String string0 = extendedMessageFormat0.toPattern();
    assertEquals(""/"", string0);
}","/**
 * {@inheritDoc}
 */"
"@Override
public final void applyPattern(String pattern) {
    if (registry == null) {
        super.applyPattern(pattern);
        toPattern = super.toPattern();
        return;
    }
    ArrayList<Format> foundFormats = new ArrayList<Format>();
    ArrayList<String> foundDescriptions = new ArrayList<String>();
    StringBuilder stripCustom = new StringBuilder(pattern.length());
    ParsePosition pos = new ParsePosition(0);
    char[] c = pattern.toCharArray();
    int fmtCount = 0;
    while (pos.getIndex() < pattern.length()) {
        switch(c[pos.getIndex()]) {
            case QUOTE:
                appendQuotedString(pattern, pos, stripCustom, true);
                break;
            case START_FE:
                fmtCount++;
                seekNonWs(pattern, pos);
                int start = pos.getIndex();
                int index = readArgumentIndex(pattern, next(pos));
                stripCustom.append(START_FE).append(index);
                seekNonWs(pattern, pos);
                Format format = null;
                String formatDescription = null;
                if (c[pos.getIndex()] == START_FMT) {
                    formatDescription = parseFormatDescription(pattern, next(pos));
                    format = getFormat(formatDescription);
                    if (format == null) {
                        stripCustom.append(START_FMT).append(formatDescription);
                    }
                }
                foundFormats.add(format);
                foundDescriptions.add(format == null ? null : formatDescription);
                Validate.isTrue(foundFormats.size() == fmtCount);
                Validate.isTrue(foundDescriptions.size() == fmtCount);
                if (c[pos.getIndex()] != END_FE) {
                    throw new IllegalArgumentException(""Unreadable format element at position "" + start);
                }
            //$FALL-THROUGH$
            default:
                stripCustom.append(c[pos.getIndex()]);
                next(pos);
        }
    }
    super.applyPattern(stripCustom.toString());
    toPattern = insertFormats(super.toPattern(), foundDescriptions);
    if (containsElements(foundFormats)) {
        Format[] origFormats = getFormats();
        // only loop over what we know we have, as MessageFormat on Java 1.3
        // seems to provide an extra format element:
        int i = 0;
        for (Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) {
            Format f = it.next();
            if (f != null) {
                origFormats[i] = f;
            }
        }
        super.setFormats(origFormats);
    }
}","public void test033() throws Throwable {
    HashMap<String, FormatFactory> hashMap0 = new HashMap<String, FormatFactory>();
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(""-!(v"", hashMap0);
    // Undeclared exception!
    try {
        extendedMessageFormat0.applyPattern((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Apply the specified pattern.
 *
 * @param pattern String
 */"
"@Override
public final void applyPattern(String pattern) {
    if (registry == null) {
        super.applyPattern(pattern);
        toPattern = super.toPattern();
        return;
    }
    ArrayList<Format> foundFormats = new ArrayList<Format>();
    ArrayList<String> foundDescriptions = new ArrayList<String>();
    StringBuilder stripCustom = new StringBuilder(pattern.length());
    ParsePosition pos = new ParsePosition(0);
    char[] c = pattern.toCharArray();
    int fmtCount = 0;
    while (pos.getIndex() < pattern.length()) {
        switch(c[pos.getIndex()]) {
            case QUOTE:
                appendQuotedString(pattern, pos, stripCustom, true);
                break;
            case START_FE:
                fmtCount++;
                seekNonWs(pattern, pos);
                int start = pos.getIndex();
                int index = readArgumentIndex(pattern, next(pos));
                stripCustom.append(START_FE).append(index);
                seekNonWs(pattern, pos);
                Format format = null;
                String formatDescription = null;
                if (c[pos.getIndex()] == START_FMT) {
                    formatDescription = parseFormatDescription(pattern, next(pos));
                    format = getFormat(formatDescription);
                    if (format == null) {
                        stripCustom.append(START_FMT).append(formatDescription);
                    }
                }
                foundFormats.add(format);
                foundDescriptions.add(format == null ? null : formatDescription);
                Validate.isTrue(foundFormats.size() == fmtCount);
                Validate.isTrue(foundDescriptions.size() == fmtCount);
                if (c[pos.getIndex()] != END_FE) {
                    throw new IllegalArgumentException(""Unreadable format element at position "" + start);
                }
            //$FALL-THROUGH$
            default:
                stripCustom.append(c[pos.getIndex()]);
                next(pos);
        }
    }
    super.applyPattern(stripCustom.toString());
    toPattern = insertFormats(super.toPattern(), foundDescriptions);
    if (containsElements(foundFormats)) {
        Format[] origFormats = getFormats();
        // only loop over what we know we have, as MessageFormat on Java 1.3
        // seems to provide an extra format element:
        int i = 0;
        for (Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) {
            Format f = it.next();
            if (f != null) {
                origFormats[i] = f;
            }
        }
        super.setFormats(origFormats);
    }
}","public void test044() throws Throwable {
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(""Z&x+C.H}Pqj}}5E"");
    // Undeclared exception!
    try {
        extendedMessageFormat0.applyPattern("">T5Q{`F`&<mi5"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unmatched braces in the pattern.
        //
        verifyException(""java.text.MessageFormat"", e);
    }
}","/**
 * Apply the specified pattern.
 *
 * @param pattern String
 */"
"public ExtendedMessageFormat(String pattern, Map<String, ? extends FormatFactory> registry) {
    this(pattern, Locale.getDefault(), registry);
}","public void test055() throws Throwable {
    ExtendedMessageFormat extendedMessageFormat0 = null;
    try {
        extendedMessageFormat0 = new ExtendedMessageFormat((String) null, (Map<String, ? extends FormatFactory>) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Create a new ExtendedMessageFormat for the default locale.
 *
 * @param pattern  the pattern to use, not null
 * @param registry  the registry of format factories, may be null
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"public ExtendedMessageFormat(String pattern, Map<String, ? extends FormatFactory> registry) {
    this(pattern, Locale.getDefault(), registry);
}","public void test066() throws Throwable {
    ExtendedMessageFormat extendedMessageFormat0 = null;
    try {
        extendedMessageFormat0 = new ExtendedMessageFormat(""mZ{gPq"", (Map<String, ? extends FormatFactory>) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unmatched braces in the pattern.
        //
        verifyException(""java.text.MessageFormat"", e);
    }
}","/**
 * Create a new ExtendedMessageFormat for the default locale.
 *
 * @param pattern  the pattern to use, not null
 * @param registry  the registry of format factories, may be null
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"public ExtendedMessageFormat(String pattern, Map<String, ? extends FormatFactory> registry) {
    this(pattern, Locale.getDefault(), registry);
}","public void test077() throws Throwable {
    HashMap<String, FormatFactory> hashMap0 = new HashMap<String, FormatFactory>();
    ExtendedMessageFormat extendedMessageFormat0 = null;
    try {
        extendedMessageFormat0 = new ExtendedMessageFormat(""`P2:,BT%)r TUIkegA{"", hashMap0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Create a new ExtendedMessageFormat for the default locale.
 *
 * @param pattern  the pattern to use, not null
 * @param registry  the registry of format factories, may be null
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"public ExtendedMessageFormat(String pattern, Locale locale, Map<String, ? extends FormatFactory> registry) {
    super(DUMMY_PATTERN);
    setLocale(locale);
    this.registry = registry;
    applyPattern(pattern);
}","public void test088() throws Throwable {
    Locale locale0 = Locale.ITALY;
    ExtendedMessageFormat extendedMessageFormat0 = null;
    try {
        extendedMessageFormat0 = new ExtendedMessageFormat((String) null, locale0, (Map<String, ? extends FormatFactory>) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Create a new ExtendedMessageFormat.
 *
 * @param pattern  the pattern to use, not null
 * @param locale  the locale to use, not null
 * @param registry  the registry of format factories, may be null
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"public ExtendedMessageFormat(String pattern, Locale locale, Map<String, ? extends FormatFactory> registry) {
    super(DUMMY_PATTERN);
    setLocale(locale);
    this.registry = registry;
    applyPattern(pattern);
}","public void test099() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    ExtendedMessageFormat extendedMessageFormat0 = null;
    try {
        extendedMessageFormat0 = new ExtendedMessageFormat(""kH{,-}\""jpGIED/"", locale0, (Map<String, ? extends FormatFactory>) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // can't parse argument number:
        //
        verifyException(""java.text.MessageFormat"", e);
    }
}","/**
 * Create a new ExtendedMessageFormat.
 *
 * @param pattern  the pattern to use, not null
 * @param locale  the locale to use, not null
 * @param registry  the registry of format factories, may be null
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"public ExtendedMessageFormat(String pattern, Locale locale, Map<String, ? extends FormatFactory> registry) {
    super(DUMMY_PATTERN);
    setLocale(locale);
    this.registry = registry;
    applyPattern(pattern);
}","public void test1010() throws Throwable {
    HashMap<String, FormatFactory> hashMap0 = new HashMap<String, FormatFactory>();
    Locale locale0 = Locale.GERMANY;
    ExtendedMessageFormat extendedMessageFormat0 = null;
    try {
        extendedMessageFormat0 = new ExtendedMessageFormat(""W^>#&s9LcA_-#0){"", locale0, hashMap0);
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Create a new ExtendedMessageFormat.
 *
 * @param pattern  the pattern to use, not null
 * @param locale  the locale to use, not null
 * @param registry  the registry of format factories, may be null
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"public ExtendedMessageFormat(String pattern, Locale locale) {
    this(pattern, locale, null);
}","public void test1111() throws Throwable {
    Locale locale0 = Locale.PRC;
    ExtendedMessageFormat extendedMessageFormat0 = null;
    try {
        extendedMessageFormat0 = new ExtendedMessageFormat((String) null, locale0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Create a new ExtendedMessageFormat.
 *
 * @param pattern  the pattern to use, not null
 * @param locale  the locale to use, not null
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"public ExtendedMessageFormat(String pattern, Locale locale) {
    this(pattern, locale, null);
}","public void test1212() throws Throwable {
    ExtendedMessageFormat extendedMessageFormat0 = null;
    try {
        extendedMessageFormat0 = new ExtendedMessageFormat(""rQ]69>0KK$J{YU2%"", (Locale) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unmatched braces in the pattern.
        //
        verifyException(""java.text.MessageFormat"", e);
    }
}","/**
 * Create a new ExtendedMessageFormat.
 *
 * @param pattern  the pattern to use, not null
 * @param locale  the locale to use, not null
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"public ExtendedMessageFormat(String pattern) {
    this(pattern, Locale.getDefault());
}","public void test1313() throws Throwable {
    ExtendedMessageFormat extendedMessageFormat0 = null;
    try {
        extendedMessageFormat0 = new ExtendedMessageFormat((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Create a new ExtendedMessageFormat for the default locale.
 *
 * @param pattern  the pattern to use, not null
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"public ExtendedMessageFormat(String pattern) {
    this(pattern, Locale.getDefault());
}","public void test1414() throws Throwable {
    ExtendedMessageFormat extendedMessageFormat0 = null;
    try {
        extendedMessageFormat0 = new ExtendedMessageFormat(""1:{`^"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unmatched braces in the pattern.
        //
        verifyException(""java.text.MessageFormat"", e);
    }
}","/**
 * Create a new ExtendedMessageFormat for the default locale.
 *
 * @param pattern  the pattern to use, not null
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"public ExtendedMessageFormat(String pattern, Map<String, ? extends FormatFactory> registry) {
    this(pattern, Locale.getDefault(), registry);
}","public void test1515() throws Throwable {
    HashMap<String, FormatFactory> hashMap0 = new HashMap<String, FormatFactory>();
    ExtendedMessageFormat extendedMessageFormat0 = null;
    try {
        extendedMessageFormat0 = new ExtendedMessageFormat(""b6;C^v*{0 "", hashMap0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * Create a new ExtendedMessageFormat for the default locale.
 *
 * @param pattern  the pattern to use, not null
 * @param registry  the registry of format factories, may be null
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"@Override
public String toPattern() {
    return toPattern;
}","public void test1616() throws Throwable {
    HashMap<String, FormatFactory> hashMap0 = new HashMap<String, FormatFactory>();
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(""n!+;^v(A{00}"", hashMap0);
    extendedMessageFormat0.applyPattern(""n!+;^v(A{00}"");
    assertEquals(""n!+;^v(A{0}"", extendedMessageFormat0.toPattern());
}","/**
 * {@inheritDoc}
 */"
"@Override
public final void applyPattern(String pattern) {
    if (registry == null) {
        super.applyPattern(pattern);
        toPattern = super.toPattern();
        return;
    }
    ArrayList<Format> foundFormats = new ArrayList<Format>();
    ArrayList<String> foundDescriptions = new ArrayList<String>();
    StringBuilder stripCustom = new StringBuilder(pattern.length());
    ParsePosition pos = new ParsePosition(0);
    char[] c = pattern.toCharArray();
    int fmtCount = 0;
    while (pos.getIndex() < pattern.length()) {
        switch(c[pos.getIndex()]) {
            case QUOTE:
                appendQuotedString(pattern, pos, stripCustom, true);
                break;
            case START_FE:
                fmtCount++;
                seekNonWs(pattern, pos);
                int start = pos.getIndex();
                int index = readArgumentIndex(pattern, next(pos));
                stripCustom.append(START_FE).append(index);
                seekNonWs(pattern, pos);
                Format format = null;
                String formatDescription = null;
                if (c[pos.getIndex()] == START_FMT) {
                    formatDescription = parseFormatDescription(pattern, next(pos));
                    format = getFormat(formatDescription);
                    if (format == null) {
                        stripCustom.append(START_FMT).append(formatDescription);
                    }
                }
                foundFormats.add(format);
                foundDescriptions.add(format == null ? null : formatDescription);
                Validate.isTrue(foundFormats.size() == fmtCount);
                Validate.isTrue(foundDescriptions.size() == fmtCount);
                if (c[pos.getIndex()] != END_FE) {
                    throw new IllegalArgumentException(""Unreadable format element at position "" + start);
                }
            //$FALL-THROUGH$
            default:
                stripCustom.append(c[pos.getIndex()]);
                next(pos);
        }
    }
    super.applyPattern(stripCustom.toString());
    toPattern = insertFormats(super.toPattern(), foundDescriptions);
    if (containsElements(foundFormats)) {
        Format[] origFormats = getFormats();
        // only loop over what we know we have, as MessageFormat on Java 1.3
        // seems to provide an extra format element:
        int i = 0;
        for (Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) {
            Format f = it.next();
            if (f != null) {
                origFormats[i] = f;
            }
        }
        super.setFormats(origFormats);
    }
}","public void test1717() throws Throwable {
    HashMap<String, FormatFactory> hashMap0 = new HashMap<String, FormatFactory>();
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(""VRplBWKp#D"", hashMap0);
    // Undeclared exception!
    try {
        extendedMessageFormat0.applyPattern(""iD'K?bn'aYdH3!{"");
        fail(""Expecting exception: ArrayIndexOutOfBoundsException"");
    } catch (ArrayIndexOutOfBoundsException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Apply the specified pattern.
 *
 * @param pattern String
 */"
"@Override
public String toPattern() {
    return toPattern;
}","public void test1818() throws Throwable {
    Locale locale0 = Locale.CHINESE;
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(""09(#(_5$50![#K.lmr7"", locale0);
    extendedMessageFormat0.applyPattern(""!|6e#1J"");
    assertEquals(""!|6e#1J"", extendedMessageFormat0.toPattern());
}","/**
 * {@inheritDoc}
 */"
"public ExtendedMessageFormat(String pattern, Locale locale, Map<String, ? extends FormatFactory> registry) {
    super(DUMMY_PATTERN);
    setLocale(locale);
    this.registry = registry;
    applyPattern(pattern);
}","public void test1919() throws Throwable {
    Locale locale0 = Locale.FRANCE;
    HashMap<String, FormatFactory> hashMap0 = new HashMap<String, FormatFactory>();
    ExtendedMessageFormat extendedMessageFormat0 = null;
    try {
        extendedMessageFormat0 = new ExtendedMessageFormat(""ks{,-}\""jpGIED/"", locale0, hashMap0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format argument index at position 3: ,
        //
        verifyException(""org.apache.commons.lang3.text.ExtendedMessageFormat"", e);
    }
}","/**
 * Create a new ExtendedMessageFormat.
 *
 * @param pattern  the pattern to use, not null
 * @param locale  the locale to use, not null
 * @param registry  the registry of format factories, may be null
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"public ExtendedMessageFormat(String pattern, Locale locale, Map<String, ? extends FormatFactory> registry) {
    super(DUMMY_PATTERN);
    setLocale(locale);
    this.registry = registry;
    applyPattern(pattern);
}","public void test2020() throws Throwable {
    Locale locale0 = Locale.FRENCH;
    HashMap<String, FormatFactory> hashMap0 = new HashMap<String, FormatFactory>();
    ExtendedMessageFormat extendedMessageFormat0 = null;
    try {
        extendedMessageFormat0 = new ExtendedMessageFormat(""b6;C^v*{0 "", locale0, hashMap0);
        fail(""Expecting exception: StringIndexOutOfBoundsException"");
    } catch (StringIndexOutOfBoundsException e) {
    }
}","/**
 * Create a new ExtendedMessageFormat.
 *
 * @param pattern  the pattern to use, not null
 * @param locale  the locale to use, not null
 * @param registry  the registry of format factories, may be null
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"public ExtendedMessageFormat(String pattern, Map<String, ? extends FormatFactory> registry) {
    this(pattern, Locale.getDefault(), registry);
}","public void test2121() throws Throwable {
    HashMap<String, FormatFactory> hashMap0 = new HashMap<String, FormatFactory>();
    ExtendedMessageFormat extendedMessageFormat0 = null;
    try {
        extendedMessageFormat0 = new ExtendedMessageFormat(""nb6;C^v*{00"", hashMap0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Unterminated format element at position 9
        //
        verifyException(""org.apache.commons.lang3.text.ExtendedMessageFormat"", e);
    }
}","/**
 * Create a new ExtendedMessageFormat for the default locale.
 *
 * @param pattern  the pattern to use, not null
 * @param registry  the registry of format factories, may be null
 * @throws IllegalArgumentException in case of a bad pattern.
 */"
"@Override
public final void applyPattern(String pattern) {
    if (registry == null) {
        super.applyPattern(pattern);
        toPattern = super.toPattern();
        return;
    }
    ArrayList<Format> foundFormats = new ArrayList<Format>();
    ArrayList<String> foundDescriptions = new ArrayList<String>();
    StringBuilder stripCustom = new StringBuilder(pattern.length());
    ParsePosition pos = new ParsePosition(0);
    char[] c = pattern.toCharArray();
    int fmtCount = 0;
    while (pos.getIndex() < pattern.length()) {
        switch(c[pos.getIndex()]) {
            case QUOTE:
                appendQuotedString(pattern, pos, stripCustom, true);
                break;
            case START_FE:
                fmtCount++;
                seekNonWs(pattern, pos);
                int start = pos.getIndex();
                int index = readArgumentIndex(pattern, next(pos));
                stripCustom.append(START_FE).append(index);
                seekNonWs(pattern, pos);
                Format format = null;
                String formatDescription = null;
                if (c[pos.getIndex()] == START_FMT) {
                    formatDescription = parseFormatDescription(pattern, next(pos));
                    format = getFormat(formatDescription);
                    if (format == null) {
                        stripCustom.append(START_FMT).append(formatDescription);
                    }
                }
                foundFormats.add(format);
                foundDescriptions.add(format == null ? null : formatDescription);
                Validate.isTrue(foundFormats.size() == fmtCount);
                Validate.isTrue(foundDescriptions.size() == fmtCount);
                if (c[pos.getIndex()] != END_FE) {
                    throw new IllegalArgumentException(""Unreadable format element at position "" + start);
                }
            //$FALL-THROUGH$
            default:
                stripCustom.append(c[pos.getIndex()]);
                next(pos);
        }
    }
    super.applyPattern(stripCustom.toString());
    toPattern = insertFormats(super.toPattern(), foundDescriptions);
    if (containsElements(foundFormats)) {
        Format[] origFormats = getFormats();
        // only loop over what we know we have, as MessageFormat on Java 1.3
        // seems to provide an extra format element:
        int i = 0;
        for (Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) {
            Format f = it.next();
            if (f != null) {
                origFormats[i] = f;
            }
        }
        super.setFormats(origFormats);
    }
}","public void test2222() throws Throwable {
    HashMap<String, FormatFactory> hashMap0 = new HashMap<String, FormatFactory>();
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(""org.apache.commons.lang3.text.ExtendedMessageFormat"", hashMap0);
    // Undeclared exception!
    try {
        extendedMessageFormat0.applyPattern(""jG<*#~<!+2DYQ*g/{O"");
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Invalid format argument index at position 17: O
        //
        verifyException(""org.apache.commons.lang3.text.ExtendedMessageFormat"", e);
    }
}","/**
 * Apply the specified pattern.
 *
 * @param pattern String
 */"
"@Override
public void setFormatByArgumentIndex(int argumentIndex, Format newFormat) {
    throw new UnsupportedOperationException();
}","public void test2323() throws Throwable {
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat("""");
    // Undeclared exception!
    try {
        extendedMessageFormat0.setFormatByArgumentIndex((-1710), extendedMessageFormat0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.text.ExtendedMessageFormat"", e);
    }
}","/**
 * Throws UnsupportedOperationException - see class Javadoc for details.
 *
 * @param argumentIndex argument index
 * @param newFormat the new format
 * @throws UnsupportedOperationException
 */"
"@Override
public void setFormats(Format[] newFormats) {
    throw new UnsupportedOperationException();
}","public void test2424() throws Throwable {
    Locale locale0 = Locale.TAIWAN;
    HashMap<String, FormatFactory> hashMap0 = new HashMap<String, FormatFactory>();
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(""''"", locale0, hashMap0);
    // Undeclared exception!
    try {
        extendedMessageFormat0.setFormats((Format[]) null);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.text.ExtendedMessageFormat"", e);
    }
}","/**
 * Throws UnsupportedOperationException - see class Javadoc for details.
 *
 * @param newFormats new formats
 * @throws UnsupportedOperationException
 */"
"@Override
public void setFormatsByArgumentIndex(Format[] newFormats) {
    throw new UnsupportedOperationException();
}","public void test2525() throws Throwable {
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat("")dfmbSqvb9b:dxf"");
    Format[] formatArray0 = new Format[2];
    // Undeclared exception!
    try {
        extendedMessageFormat0.setFormatsByArgumentIndex(formatArray0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.text.ExtendedMessageFormat"", e);
    }
}","/**
 * Throws UnsupportedOperationException - see class Javadoc for details.
 *
 * @param newFormats new formats
 * @throws UnsupportedOperationException
 */"
"@Override
public void setFormat(int formatElementIndex, Format newFormat) {
    throw new UnsupportedOperationException();
}","public void test2626() throws Throwable {
    HashMap<String, FormatFactory> hashMap0 = new HashMap<String, FormatFactory>();
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat(""n!+l^vA{ 0}"", hashMap0);
    // Undeclared exception!
    try {
        extendedMessageFormat0.setFormat(3062, extendedMessageFormat0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.apache.commons.lang3.text.ExtendedMessageFormat"", e);
    }
}","/**
 * Throws UnsupportedOperationException - see class Javadoc for details.
 *
 * @param formatElementIndex format element index
 * @param newFormat the new format
 * @throws UnsupportedOperationException
 */"
"@Override
public String toPattern() {
    return toPattern;
}","public void test2727() throws Throwable {
    ExtendedMessageFormat extendedMessageFormat0 = new ExtendedMessageFormat("""");
    String string0 = extendedMessageFormat0.toPattern();
    assertEquals("""", string0);
}","/**
 * {@inheritDoc}
 */"
