{
  "test0000" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test0000() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"\", \"\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    Node node1 = Node.newString(120, \"\");\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test0000"
  },
  "test0088" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test0088() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"\", \"\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;\n    controlFlowGraph0.connectToImplicitReturn(node0, controlFlowGraph_Branch0);\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node0, linkedFlowScope0);\n}",
    "testName" : "test0088"
  },
  "test107107" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test107107() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"IXR?t[&_\", \"IXR?t[&_\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(116, \"IXR?t[&_\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test107107"
  },
  "test03636" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test03636() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseTestCode(\"IXR?t[&_\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(38, \"IXR?t[&_\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test03636"
  },
  "test02424" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test02424() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"CtHS]E&!#v\", \"CtHS]E&!#v\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    Node node1 = new Node(21, node0, node0, node0, 47, (-1901));\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test02424"
  },
  "test130130" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test130130() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"RK\", \"RK\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(100, \"RK\");\n    Node node2 = new Node(100, node1, node0);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, true, true);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    typeInference0.branchedFlowThrough(node2, linkedFlowScope0);\n}",
    "testName" : "test130130"
  },
  "test04848" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04848() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0P \", \"[0P \");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(50, \"[0P \");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test04848"
  },
  "test01212" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test01212() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(6, \"[0l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test01212"
  },
  "test05656" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test05656() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseTestCode(\"B%sS4))nNU\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(58, \"B%sS4))nNU\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test05656"
  },
  "test06868" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test06868() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    Node node1 = Node.newString(71, \"[0l\");\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test06868"
  },
  "test02828" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test02828() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"l\", \"l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(26, \"l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test02828"
  },
  "test01616" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test01616() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(12, \"[0l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test01616"
  },
  "test08484" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test08484() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"zS![bjzy3P47yGpUNx\", \"zS![bjzy3P47yGpUNx\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(89, \"zS![bjzy3P47yGpUNx\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test08484"
  },
  "test07272" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test07272() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    Node node1 = Node.newString(76, \"[0l\");\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test07272"
  },
  "test04040" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04040() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"\", \"\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    Node node1 = Node.newString(42, \"\");\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test04040"
  },
  "test0011" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test0011() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[5l\", \"[5l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(33, \"[5l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test0011"
  },
  "test0099" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test0099() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"\", \"\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;\n    controlFlowGraph0.connectToImplicitReturn(node0, controlFlowGraph_Branch0);\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node0, linkedFlowScope0);\n}",
    "testName" : "test0099"
  },
  "test09292" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test09292() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[5l\", \"[5l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(99, \"[5l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test09292"
  },
  "test03232" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test03232() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0P \", \"[0P \");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(32, \"[0P \");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test03232"
  },
  "test08888" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test08888() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"com.google.javascripn.jscomp.EypandJqueryAliases$FindCallbackAgumentR7ferences\", \"com.google.javascripn.jscomp.EypandJqueryAliases$FindCallbackAgumentR7ferences\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(94, node0, node0, node0, node0, 200000, 40);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test08888"
  },
  "test102102" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test102102() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    Node node1 = Node.newString(111, \"[0l\");\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test102102"
  },
  "test02020" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test02020() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[5l\", \"[5l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(17, \"[5l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test02020"
  },
  "test04444" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04444() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[l\", \"[l\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    Node node1 = Node.newString(46, \"[l\");\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test04444"
  },
  "test07676" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test07676() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    Node node1 = Node.newString(80, \"[0l\");\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test07676"
  },
  "test05252" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test05252() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(54, \"[0l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test05252"
  },
  "test09696" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test09696() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"CtHS]E&!#v\", \"CtHS]E&!#v\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(105, \"CtHS]E&!#v\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test09696"
  },
  "test06464" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test06464() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"\", \"\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(67, \"\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test06464"
  },
  "test110110" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test110110() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"(ffhI\", \"(ffhI\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    Node node1 = Node.newString(119, \"(ffhI\");\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test110110"
  },
  "test08080" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test08080() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"CtHS]E&!#v\", \"CtHS]E&!#v\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(84, \"CtHS]E&!#v\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test08080"
  },
  "test118118" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test118118() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[5l\", \"[5l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(128, \"[5l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test118118"
  },
  "test122122" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test122122() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    Node node1 = new Node(4, node0, node0, node0, node0, 46, 16);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test122122"
  },
  "test0022" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test0022() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(63, \"[0l\");\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, hashMap0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test0022"
  },
  "test105105" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test105105() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"P0l\", \"P0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(114, \"P0l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test105105"
  },
  "test01313" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test01313() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(7, \"com.google.javascript.jscomp.InlineVariables\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test01313"
  },
  "test06969" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test06969() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(72, \"[0l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test06969"
  },
  "test03737" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test03737() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"QQFG[\", \"QQFG[\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    Node node1 = Node.newString(39, \"QQFG[\");\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test03737"
  },
  "test04545" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04545() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(47, \"[0l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test04545"
  },
  "test132132" : {
    "methodSignature" : "static BooleanLiteralSet getBooleanOutcomes(BooleanLiteralSet left, BooleanLiteralSet right, boolean condition)",
    "methodName" : "getBooleanOutcomes",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test132132() throws Throwable {\n    BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;\n    BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);\n}",
    "testName" : "test132132"
  },
  "test02525" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test02525() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"\", \"\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(23, \"\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test02525"
  },
  "test05757" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test05757() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(59, \"[0l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test05757"
  },
  "test01717" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test01717() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"IrS\", \"IrS\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    Node node1 = new Node(13, node0, node0, node0, 47, (-1901));\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test01717"
  },
  "test119119" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test119119() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(129, \"[0l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test119119"
  },
  "test111111" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test111111() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"l:m>$PE*}`E<^oeb.*!\", \"l:m>$PE*}`E<^oeb.*!\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(121, \"l:m>$PE*}`E<^oeb.*!\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test111111"
  },
  "test04949" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04949() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseTestCode(\"ejg(;]Gi=r\\\"4\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(51, \"ejg(;]Gi=r\\\"4\");\n    Node node2 = new Node(30, node1, node1, node0);\n    typeInference0.branchedFlowThrough(node2, linkedFlowScope0);\n}",
    "testName" : "test04949"
  },
  "test02929" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test02929() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(27, \"[0l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test02929"
  },
  "test06161" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test06161() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    Node node1 = Node.newString(64, \"[0l\");\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test06161"
  },
  "test07373" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test07373() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"\", \"\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    Node node1 = Node.newString(77, \"\");\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test07373"
  },
  "test09393" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test09393() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(102, \"[0l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test09393"
  },
  "test0033" : {
    "methodSignature" : "FlowScope createEntryLattice()",
    "methodName" : "createEntryLattice",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test0033() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    FlowScope flowScope0 = typeInference0.createEntryLattice();\n}",
    "testName" : "test0033"
  },
  "test08181" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test08181() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(85, node0, node0, node0, node0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test08181"
  },
  "test07777" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test07777() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    Node node1 = Node.newString(81, \"[0l\");\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test07777"
  },
  "test06565" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test06565() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"CtHS]E&!#v\", \"CtHS]E&!#v\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    Node node1 = Node.newString(68, \"/FP\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test06565"
  },
  "test03333" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test03333() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseTestCode(\"T0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, (CodingConvention) null);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(34, \"\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test03333"
  },
  "test127127" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test127127() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseTestCode(\"ejg(;]Gi=r\\\"4\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(30, node0, node0, node0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test127127"
  },
  "test100100" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test100100() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(109, \"[0l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test100100"
  },
  "test04141" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04141() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    Node node1 = Node.newString(43, \"[0l\");\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test04141"
  },
  "test09797" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test09797() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"l:m$PE*}`E<^oeb.*!\", \"l:m$PE*}`E<^oeb.*!\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(106, \"JSC_TEMPLATE_TYPE_NOT_OBJECT_TYPE\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test09797"
  },
  "test08585" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test08585() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(90, \"[0l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test08585"
  },
  "test02121" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test02121() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[5l\", \"[5l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(18, \"[5l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test02121"
  },
  "test05353" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test05353() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"zyG?!j4SXtg!e(\", \"0ai\\\"I<8TY@l+gBW\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(55, node0, node0, node0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test05353"
  },
  "test108108" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test108108() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"55i-oSY(;w\", \"55i-oSY(;w\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    Node node1 = Node.newString(117, \"55i-oSY(;w\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test108108"
  },
  "test116116" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test116116() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0P \", \"[0P \");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(126, \"[0P \");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test116116"
  },
  "test120120" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test120120() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(130, \"[0l\");\n    node1.addChildToBack(node0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test120120"
  },
  "test103103" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test103103() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"\", \"\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);\n    Node node1 = Node.newString(112, \"\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test103103"
  },
  "test05858" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test05858() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    Node node1 = Node.newString(60, \"[0l\");\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test05858"
  },
  "test02626" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test02626() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[5l\", \"[5l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(24, \"[5l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test02626"
  },
  "test04646" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04646() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"IXR?t[&_\", \"6HIE<,LP=%Uz-e\\\"\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(48, \"IXR?t[&_\");\n    Node node2 = new Node(93, node0);\n    node2.addChildToBack(node1);\n    typeInference0.branchedFlowThrough(node2, linkedFlowScope0);\n}",
    "testName" : "test04646"
  },
  "test07878" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test07878() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    Node node1 = Node.newString(82, \"[0l\");\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test07878"
  },
  "test01414" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test01414() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"J[0l\", \"J[0l\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    Node node1 = Node.newString(8, \"J[0l\");\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test01414"
  },
  "test117117" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test117117() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"(ffhI\", \"(ffhI\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    Node node1 = Node.newString(127, \"(ffhI\");\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test117117"
  },
  "test03838" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test03838() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[5l\", \"[5l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(40, \"[5l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test03838"
  },
  "test01818" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test01818() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"*;w?Q\", \"*;w?Q\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(14, node0, node0);\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test01818"
  },
  "test05050" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test05050() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0P \", \"[0P \");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    Node node1 = Node.newString(52, \"[0P \");\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test05050"
  },
  "test09494" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test09494() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseSyntheticCode(\"com.google.javascripn.jscomp.EypandJqueryAliases$FindCallbackAgumentR7ferences\", \"com.google.javascripn.jscomp.EypandJqueryAliases$FindCallbackAgumentR7ferences\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    Node node1 = Node.newString(103, \"com.google.javascripn.jscomp.EypandJqueryAliases$FindCallbackAgumentR7ferences\");\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test09494"
  },
  "test06262" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test06262() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"P0l\", \"P0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(65, \"P0l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test06262"
  },
  "test08282" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test08282() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(87, \"[0l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test08282"
  },
  "test125125" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test125125() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(37, \"[0l\");\n    node1.addChildToBack(node0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test125125"
  },
  "test0055" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test0055() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"\", \"\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = new Node(86, node0, node0);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test0055"
  },
  "test05454" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test05454() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseTestCode(\"1RG%\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(56, \"1RG%\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test05454"
  },
  "test09898" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test09898() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"P0l\", \"P0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(107, \"P0l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test09898"
  },
  "test06666" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test06666() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \".\", \".\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(69, \"69WJ6\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test06666"
  },
  "test03030" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test03030() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseTestCode(\"U7b\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(28, \"U7b\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test03030"
  },
  "test08686" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test08686() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"l:m$PE*}`E<^oeb.*!\", \"l:m$PE*}`E<^oeb.*!\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(91, \"l:m$PE*}`E<^oeb.*!\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test08686"
  },
  "test02222" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test02222() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseTestCode(\"B%sS))nNVU\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(19, \"B%sS))nNVU\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test02222"
  },
  "test07474" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test07474() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"\", \"\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(78, \"s'nXWf%\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test07474"
  },
  "test04242" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04242() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    Node node1 = Node.newString(44, \"[0l\");\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test04242"
  },
  "test106106" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test106106() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseTestCode(\"B%sS4))nNU\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(115, \"B%sS4))nNU\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test106106"
  },
  "test01010" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test01010() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"l:m$PE*}`E<^oeb.*!\", \"l:m$PE*}`E<^oeb.*!\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(4, \"l:m$PE*}`E<^oeb.*!\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test01010"
  },
  "test09090" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test09090() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0P \", \"[0P \");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    Node node1 = Node.newString(96, \"[0P \");\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test09090"
  },
  "test114114" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test114114() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(124, \"[0l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test114114"
  },
  "test126126" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test126126() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"*;w?Q\", \"*;w?Q\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);\n    Comparator<String> comparator0 = (Comparator<String>) mock(Comparator.class, new ViolatedAssumptionAnswer());\n    doReturn(36, 0).when(comparator0).compare(anyString(), anyString());\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>(comparator0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeMap0);\n    FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();\n    TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeMap0);\n    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(\"*;w?Q\");\n    treeMap0.put(\"*;w?Q\", codingConvention_AssertionFunctionSpec0);\n    Node node1 = new Node(37, node0);\n    typeInference1.branchedFlowThrough(node1, flowScope0);\n}",
    "testName" : "test126126"
  },
  "test101101" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test101101() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(110, \"[0l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test101101"
  },
  "test109109" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test109109() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"l:m$PE*}`E<^oeb.*!\", \"l:m$PE*}`E<^oeb.*!\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(118, \"cu\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test109109"
  },
  "test04747" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04747() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    Node node1 = new Node(49, node0, node0, node0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test04747"
  },
  "test02323" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test02323() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(20, \"[0l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test02323"
  },
  "test07979" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test07979() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(83, \"[0l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test07979"
  },
  "test01515" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test01515() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(9, \"[0l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test01515"
  },
  "test06767" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test06767() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(70, \"[0l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test06767"
  },
  "test03535" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test03535() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[l\", \"[l\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    Node node1 = Node.newString(36, \"[l\");\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test03535"
  },
  "test02727" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test02727() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    Node node1 = Node.newString(25, \"c;U<\");\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test02727"
  },
  "test115115" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test115115() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseTestCode(\"msg.isnt.function.in\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(125, \"msg.isnt.function.in\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test115115"
  },
  "test01919" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test01919() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"P0l\", \"P0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(15, \"P0l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test01919"
  },
  "test03939" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test03939() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"\", \"\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(41, \"\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test03939"
  },
  "test09595" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test09595() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[ \", \"[ \");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    Node node1 = Node.newString(104, \"[ \");\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test09595"
  },
  "test08383" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test08383() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0P \", \"[0P \");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(88, \"[0P \");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test08383"
  },
  "test05151" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test05151() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"IXR?t[&_\", \"IXR?t[&_\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(53, \"IXR?t[&_\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test05151"
  },
  "test123123" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test123123() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseTestCode(\"IXR?t[&_\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(38, \"IXR?t[&_\");\n    node1.addChildToBack(node0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test123123"
  },
  "test07171" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test07171() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    Node node1 = Node.newString(74, \"[0l\");\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test07171"
  },
  "test04343" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test04343() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[ \", \"[ \");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(45, \"[ \");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test04343"
  },
  "test09999" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test09999() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(108, \"\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test09999"
  },
  "test104104" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test104104() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"CtHS]E&!#v\", \"CtHS]E&!#v\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    Node node1 = new Node(113, node0, node0, node0, 49, 2);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test104104"
  },
  "test08787" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test08787() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0P \", \"[0P \");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(92, \"[0P \");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test08787"
  },
  "test05555" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test05555() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = compiler0.parseTestCode(\"B%sS4))nNU\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(57, \"B%sS4))nNU\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test05555"
  },
  "test01111" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test01111() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(5, \"[0l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test01111"
  },
  "test06363" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test06363() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"com.google.javascript.jscomp.ExpandJqueryAliases$FindCallbackArgumentReferences\", \"com.google.javascript.jscomp.ExpandJqueryAliases$FindCallbackArgumentReferences\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(66, \"Y\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test06363"
  },
  "test03131" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test03131() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[l\", \"[l\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    Node node1 = Node.newString(29, \"[l\");\n    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test03131"
  },
  "test07575" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test07575() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"zS![bjzy3P47yGpUNx\", \"zS![bjzy3P47yGpUNx\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    Node node1 = Node.newString(79, \"zS![bjzy3P47yGpUNx\");\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test07575"
  },
  "test131131" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test131131() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(101, \"[0l\");\n    Node node2 = new Node(101, node1, node0);\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, true, true);\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    typeInference0.branchedFlowThrough(node2, linkedFlowScope0);\n}",
    "testName" : "test131131"
  },
  "test09191" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test09191() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"[0l\", \"[0l\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(97, \"[0l\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test09191"
  },
  "test112112" : {
    "methodSignature" : "List<FlowScope> branchedFlowThrough(Node source, FlowScope input)",
    "methodName" : "branchedFlowThrough",
    "className" : "com.google.javascript.jscomp.TypeInference",
    "testPrefix" : "@Test(timeout = 4000)\npublic void test112112() throws Throwable {\n    Compiler compiler0 = new Compiler();\n    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, \"55i-oSY(5;w\", \"55i-oSY(5;w\");\n    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);\n    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);\n    Scope scope0 = typedScopeCreator0.createInitialScope(node0);\n    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();\n    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();\n    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);\n    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);\n    Node node1 = Node.newString(122, \"],SR|mpyJ\");\n    typeInference0.branchedFlowThrough(node1, linkedFlowScope0);\n}",
    "testName" : "test112112"
  }
}