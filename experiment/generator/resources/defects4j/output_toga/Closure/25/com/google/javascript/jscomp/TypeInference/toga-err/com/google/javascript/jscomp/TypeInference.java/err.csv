com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test0044() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(31, ""[0l"");
    Node node2 = new Node(101, node1, node0);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, true, true);
    node0.detachFromParent();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_25b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test0066() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[CP9"", ""[CP9"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, flowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_25b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test0077() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0P "", ""[0P "");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.UNCOND;
    controlFlowGraph0.connectToImplicitReturn(node0, controlFlowGraph_Branch0);
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_25b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test03434() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""RB"", ""RB"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(35, node0, node0);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, false, false);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_25b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test05959() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[5l"", ""[5l"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(61, node0, node0);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node1, true, true);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_25b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test06060() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(62, ""[0l"");
    Node node2 = new Node(101, node1, node0);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, true, true);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_25b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test07070() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(73, ""[0l"");
    Node node2 = new Node(10, node1, node0);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, true, true);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_25b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test08989() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(95, ""[0l"");
    Node node2 = new Node(93, node1, node0);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, true, true);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
    list0.isEmpty();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_25b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test113113() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0"", ""[0"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    node0.setType(123);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    list0.isEmpty();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_25b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test121121() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0P "", ""[0P "");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    node0.addSuppression(""[0P "");
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_25b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test124124() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(31, ""[0l"");
    Node node2 = new Node(98, node1, node0);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, false, false);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
    list0.isEmpty();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_25b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test128128() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""RB"", ""RB"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(16, ""RB"");
    Node node2 = new Node(35, node1, node0);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, false, false);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_25b/src/java/util/List.java
com.google.javascript.jscomp.TypeInference,@Test(timeout = 4000)
public void test129129() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(95, ""[0l"");
    Node node2 = new Node(101, node1, node0);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, true, true);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    List<FlowScope> list0 = typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
    list0.size();
},ERROR,java.nio.file.NoSuchFileException,/home/star_usit_group/tratto/experiment/generator/resources/defects4j/temp/Closure_25b/src/java/util/List.java
