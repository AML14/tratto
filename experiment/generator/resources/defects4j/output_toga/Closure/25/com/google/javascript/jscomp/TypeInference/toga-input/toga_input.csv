focal_method,test_prefix,docstring
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test0000() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, """", """");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    Node node1 = Node.newString(120, """");
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test0011() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[5l"", ""[5l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(33, ""[5l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test0022() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(63, ""[0l"");
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, hashMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ARRAYLIT [0l : Array does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
FlowScope createEntryLattice() {
    return functionScope;
}","public void test0033() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    FlowScope flowScope0 = typeInference0.createEntryLattice();
    assertNotNull(flowScope0);
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test0055() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, """", """");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(86, node0, node0);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN : ? does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test0088() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, """", """");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_TRUE;
    controlFlowGraph0.connectToImplicitReturn(node0, controlFlowGraph_Branch0);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SCRIPT 1 [synthetic: com.google.javascript.rhino.Node$IntPropListItem@0000000501] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000502] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000503] does not have a condition.
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test0099() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, """", """");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    ControlFlowGraph.Branch controlFlowGraph_Branch0 = ControlFlowGraph.Branch.ON_FALSE;
    controlFlowGraph0.connectToImplicitReturn(node0, controlFlowGraph_Branch0);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node0, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SCRIPT 1 [synthetic: com.google.javascript.rhino.Node$IntPropListItem@0000000501] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000502] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000503] does not have a condition.
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test01010() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""l:m$PE*}`E<^oeb.*!"", ""l:m$PE*}`E<^oeb.*!"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(4, ""l:m$PE*}`E<^oeb.*!"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // RETURN l:m$PE*}`E<^oeb.*! does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test01111() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(5, ""[0l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 5
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test01212() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(6, ""[0l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 6
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test01313() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(7, ""com.google.javascript.jscomp.InlineVariables"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 7
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test01414() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""J[0l"", ""J[0l"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    Node node1 = Node.newString(8, ""J[0l"");
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 8
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test01515() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(9, ""[0l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BITOR [0l : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test01616() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(12, ""[0l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // EQ [0l : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test01717() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""IrS"", ""IrS"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    Node node1 = new Node(13, node0, node0, node0, 47, (-1901));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // NE : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test01818() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""*;w?Q"", ""*;w?Q"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(14, node0, node0);
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LT : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test01919() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""P0l"", ""P0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(15, ""P0l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LE P0l : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test02020() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[5l"", ""[5l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(17, ""[5l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // GE [5l : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test02121() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[5l"", ""[5l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(18, ""[5l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LSH [5l : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test02222() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""B%sS))nNVU"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(19, ""B%sS))nNVU"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // RSH B%sS))nNVU : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test02323() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(20, ""[0l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // URSH [0l : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test02424() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""CtHS]E&!#v"", ""CtHS]E&!#v"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    Node node1 = new Node(21, node0, node0, node0, 47, (-1901));
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test02525() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, """", """");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(23, """");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // MUL  : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test02626() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[5l"", ""[5l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(24, ""[5l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // DIV [5l : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test02727() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    Node node1 = Node.newString(25, ""c;U<"");
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // MOD c;U< : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test02828() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""l"", ""l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(26, ""l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // NOT l : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test02929() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(27, ""[0l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BITNOT [0l : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test03030() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""U7b"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(28, ""U7b"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test03131() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[l"", ""[l"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    Node node1 = Node.newString(29, ""[l"");
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test03232() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0P "", ""[0P "");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(32, ""[0P "");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // TYPEOF [0P  : string does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test03333() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""T0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, (CodingConvention) null);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(34, """");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 34
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test03535() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[l"", ""[l"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    Node node1 = Node.newString(36, ""[l"");
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 36
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test03636() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""IXR?t[&_"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(38, ""IXR?t[&_"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // NAME IXR?t[&_ does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test03737() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""QQFG["", ""QQFG["");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    Node node1 = Node.newString(39, ""QQFG["");
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // NUMBER QQFG[ does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test03838() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[5l"", ""[5l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(40, ""[5l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // STRING [5l does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test03939() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, """", """");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(41, """");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // NULL  does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04040() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, """", """");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    Node node1 = Node.newString(42, """");
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // THIS  : global this does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04141() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    Node node1 = Node.newString(43, ""[0l"");
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // FALSE [0l does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04242() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    Node node1 = Node.newString(44, ""[0l"");
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // TRUE [0l does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04343() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[ "", ""[ "");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(45, ""[ "");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SHEQ [  : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04444() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[l"", ""[l"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    Node node1 = Node.newString(46, ""[l"");
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // SHNE [l : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04545() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(47, ""[0l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // REGEXP [0l does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04646() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""IXR?t[&_"", ""6HIE<,LP=%Uz-e\"""");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(48, ""IXR?t[&_"");
    Node node2 = new Node(93, node0);
    node2.addChildToBack(node1);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_ADD : ? does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04747() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    Node node1 = new Node(49, node0, node0, node0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // THROW does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04848() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0P "", ""[0P "");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(50, ""[0P "");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 50
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test04949() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""ejg(;]Gi=r\""4"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(51, ""ejg(;]Gi=r\""4"");
    Node node2 = new Node(30, node1, node1, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // NEW does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test05050() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0P "", ""[0P "");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    Node node1 = Node.newString(52, ""[0P "");
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // INSTANCEOF [0P  : boolean does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test05151() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""IXR?t[&_"", ""IXR?t[&_"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(53, ""IXR?t[&_"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 53
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test05252() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(54, ""[0l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 54
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test05353() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""zyG?!j4SXtg!e("", ""0ai\""I<8TY@l+gBW"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(55, node0, node0, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 55
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test05454() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""1RG%"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(56, ""1RG%"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 56
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test05555() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""B%sS4))nNU"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(57, ""B%sS4))nNU"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 57
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test05656() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""B%sS4))nNU"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(58, ""B%sS4))nNU"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 58
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test05757() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(59, ""[0l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 59
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test05858() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    Node node1 = Node.newString(60, ""[0l"");
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 60
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test06161() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    Node node1 = Node.newString(64, ""[0l"");
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test06262() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""P0l"", ""P0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(65, ""P0l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 65
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test06363() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""com.google.javascript.jscomp.ExpandJqueryAliases$FindCallbackArgumentReferences"", ""com.google.javascript.jscomp.ExpandJqueryAliases$FindCallbackArgumentReferences"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(66, ""Y"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 66
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test06464() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, """", """");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(67, """");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 67
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test06565() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""CtHS]E&!#v"", ""CtHS]E&!#v"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    Node node1 = Node.newString(68, ""/FP"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 68
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test06666() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""."", ""."");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(69, ""69WJ6"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 69
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test06767() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(70, ""[0l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 70
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test06868() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    Node node1 = Node.newString(71, ""[0l"");
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 71
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test06969() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(72, ""[0l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 72
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test07171() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    Node node1 = Node.newString(74, ""[0l"");
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 74
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test07272() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    Node node1 = Node.newString(76, ""[0l"");
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 76
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test07373() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, """", """");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    Node node1 = Node.newString(77, """");
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // TRY  does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test07474() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, """", """");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(78, ""s'nXWf%"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 78
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test07575() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""zS![bjzy3P47yGpUNx"", ""zS![bjzy3P47yGpUNx"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    Node node1 = Node.newString(79, ""zS![bjzy3P47yGpUNx"");
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 79
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test07676() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    Node node1 = Node.newString(80, ""[0l"");
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 80
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test07777() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    Node node1 = Node.newString(81, ""[0l"");
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 81
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test07878() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    Node node1 = Node.newString(82, ""[0l"");
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 82
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test07979() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(83, ""[0l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test08080() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""CtHS]E&!#v"", ""CtHS]E&!#v"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(84, ""CtHS]E&!#v"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 84
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test08181() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(85, node0, node0, node0, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // COMMA : ? does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test08282() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(87, ""[0l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_BITOR [0l : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test08383() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0P "", ""[0P "");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(88, ""[0P "");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_BITXOR [0P  : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test08484() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""zS![bjzy3P47yGpUNx"", ""zS![bjzy3P47yGpUNx"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(89, ""zS![bjzy3P47yGpUNx"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_BITAND zS![bjzy3P47yGpUNx : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test08585() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(90, ""[0l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_LSH [0l : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test08686() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""l:m$PE*}`E<^oeb.*!"", ""l:m$PE*}`E<^oeb.*!"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(91, ""l:m$PE*}`E<^oeb.*!"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_RSH l:m$PE*}`E<^oeb.*! : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test08787() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0P "", ""[0P "");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(92, ""[0P "");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_URSH [0P  : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test08888() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""com.google.javascripn.jscomp.EypandJqueryAliases$FindCallbackAgumentR7ferences"", ""com.google.javascripn.jscomp.EypandJqueryAliases$FindCallbackAgumentR7ferences"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(94, node0, node0, node0, node0, 200000, 40);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_SUB 200000 : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test09090() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0P "", ""[0P "");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    Node node1 = Node.newString(96, ""[0P "");
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_DIV [0P  : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test09191() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(97, ""[0l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // ASSIGN_MOD [0l : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test09292() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[5l"", ""[5l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(99, ""[5l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 99
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test09393() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(102, ""[0l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // INC [0l : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test09494() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""com.google.javascripn.jscomp.EypandJqueryAliases$FindCallbackAgumentR7ferences"", ""com.google.javascripn.jscomp.EypandJqueryAliases$FindCallbackAgumentR7ferences"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    Node node1 = Node.newString(103, ""com.google.javascripn.jscomp.EypandJqueryAliases$FindCallbackAgumentR7ferences"");
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // DEC com.google.javascripn.jscomp.EypandJqueryAliases$FindCallbackAgumentR7ferences : number does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test09595() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[ "", ""[ "");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    Node node1 = Node.newString(104, ""[ "");
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 104
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test09696() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""CtHS]E&!#v"", ""CtHS]E&!#v"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(105, ""CtHS]E&!#v"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // FUNCTION CtHS]E&!#v does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test09797() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""l:m$PE*}`E<^oeb.*!"", ""l:m$PE*}`E<^oeb.*!"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(106, ""JSC_TEMPLATE_TYPE_NOT_OBJECT_TYPE"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 106
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test09898() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""P0l"", ""P0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(107, ""P0l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 107
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test09999() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(108, """");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // IF  does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test100100() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(109, ""[0l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 109
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test101101() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(110, ""[0l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test102102() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    Node node1 = Node.newString(111, ""[0l"");
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CASE [0l does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test103103() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, """", """");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice((Scope) null);
    Node node1 = Node.newString(112, """");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // DEFAULT_CASE  does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test104104() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""CtHS]E&!#v"", ""CtHS]E&!#v"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    Node node1 = new Node(113, node0, node0, node0, 49, 2);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // WHILE 49 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test105105() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""P0l"", ""P0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(114, ""P0l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // DO P0l does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test106106() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""B%sS4))nNU"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(115, ""B%sS4))nNU"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // FOR B%sS4))nNU does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test107107() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""IXR?t[&_"", ""IXR?t[&_"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(116, ""IXR?t[&_"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BREAK IXR?t[&_ does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test108108() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""55i-oSY(;w"", ""55i-oSY(;w"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    Node node1 = Node.newString(117, ""55i-oSY(;w"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CONTINUE 55i-oSY(;w does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test109109() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""l:m$PE*}`E<^oeb.*!"", ""l:m$PE*}`E<^oeb.*!"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(118, ""cu"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // VAR cu does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test110110() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""(ffhI"", ""(ffhI"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    Node node1 = Node.newString(119, ""(ffhI"");
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // WITH (ffhI does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test111111() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""l:m>$PE*}`E<^oeb.*!"", ""l:m>$PE*}`E<^oeb.*!"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(121, ""l:m>$PE*}`E<^oeb.*!"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 121
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test112112() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""55i-oSY(5;w"", ""55i-oSY(5;w"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(122, ""],SR|mpyJ"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // VOID ],SR|mpyJ does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test114114() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(124, ""[0l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // EMPTY [0l does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test115115() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""msg.isnt.function.in"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(125, ""msg.isnt.function.in"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // BLOCK msg.isnt.function.in does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test116116() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0P "", ""[0P "");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(126, ""[0P "");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // LABEL [0P  does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test117117() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""(ffhI"", ""(ffhI"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    Node node1 = Node.newString(127, ""(ffhI"");
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 127
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test118118() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[5l"", ""[5l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(128, ""[5l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 128
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test119119() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(129, ""[0l"");
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 129
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test120120() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(130, ""[0l"");
    node1.addChildToBack(node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // EXPR_RESULT [0l does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test122122() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    Node node1 = new Node(4, node0, node0, node0, node0, 46, 16);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // RETURN 46 does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test123123() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""IXR?t[&_"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(38, ""IXR?t[&_"");
    node1.addChildToBack(node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // NAME IXR?t[&_ : ? does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test125125() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(37, ""[0l"");
    node1.addChildToBack(node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CALL [0l does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test126126() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""*;w?Q"", ""*;w?Q"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, false);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Comparator<String> comparator0 = (Comparator<String>) mock(Comparator.class, new ViolatedAssumptionAnswer());
    doReturn(36, 0).when(comparator0).compare(anyString(), anyString());
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>(comparator0);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeMap0);
    FlowScope flowScope0 = typeInference0.createInitialEstimateLattice();
    TypeInference typeInference1 = new TypeInference(compiler0, controlFlowGraph0, semanticReverseAbstractInterpreter0, scope0, treeMap0);
    CodingConvention.AssertionFunctionSpec codingConvention_AssertionFunctionSpec0 = new CodingConvention.AssertionFunctionSpec(""*;w?Q"");
    treeMap0.put(""*;w?Q"", codingConvention_AssertionFunctionSpec0);
    Node node1 = new Node(37, node0);
    // Undeclared exception!
    try {
        typeInference1.branchedFlowThrough(node1, flowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // CALL does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test127127() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""ejg(;]Gi=r\""4"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    HashMap<String, CodingConvention.AssertionFunctionSpec> hashMap0 = new HashMap<String, CodingConvention.AssertionFunctionSpec>();
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, googleCodingConvention0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, hashMap0);
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = new Node(30, node0, node0, node0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node1, linkedFlowScope0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // NEW does not exist in graph
        //
        verifyException(""com.google.javascript.jscomp.graph.Graph"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test130130() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""RK"", ""RK"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(100, ""RK"");
    Node node2 = new Node(100, node1, node0);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, true, true);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",""
"@Override
@SuppressWarnings(""fallthrough"")
List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
    // edges. If we wanted to be perfect, we'd actually JOIN all the out
    // lattices of this flow with the in lattice, and then make that the out
    // lattice for the ON_EX edge. But it's probably to expensive to be
    // worthwhile.
    FlowScope output = flowThrough(source, input);
    Node condition = null;
    FlowScope conditionFlowScope = null;
    BooleanOutcomePair conditionOutcomes = null;
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
        Branch branch = branchEdge.getValue();
        FlowScope newScope = output;
        switch(branch) {
            case ON_TRUE:
                if (NodeUtil.isForIn(source)) {
                    // item is assigned a property name, so its type should be string.
                    Node item = source.getFirstChild();
                    Node obj = item.getNext();
                    FlowScope informed = traverse(obj, output.createChildFlowScope());
                    if (item.isVar()) {
                        item = item.getFirstChild();
                    }
                    if (item.isName()) {
                        JSType iterKeyType = getNativeType(STRING_TYPE);
                        ObjectType objType = getJSType(obj).dereference();
                        JSType objIndexType = objType == null ? null : objType.getIndexType();
                        if (objIndexType != null && !objIndexType.isUnknownType()) {
                            JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType);
                            if (!narrowedKeyType.isEmptyType()) {
                                iterKeyType = narrowedKeyType;
                            }
                        }
                        redeclareSimpleVar(informed, item, iterKeyType);
                    }
                    newScope = informed;
                    break;
                }
            // FALL THROUGH
            case ON_FALSE:
                if (condition == null) {
                    condition = NodeUtil.getConditionExpression(source);
                    if (condition == null && source.isCase()) {
                        condition = source;
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope());
                        }
                    }
                }
                if (condition != null) {
                    if (condition.isAnd() || condition.isOr()) {
                        // When handling the short-circuiting binary operators,
                        // the outcome scope on true can be different than the outcome
                        // scope on false.
                        //
                        // TODO(nicksantos): The ""right"" way to do this is to
                        // carry the known outcome all the way through the
                        // recursive traversal, so that we can construct a
                        // different flow scope based on the outcome. However,
                        // this would require a bunch of code and a bunch of
                        // extra computation for an edge case. This seems to be
                        // a ""good enough"" approximation.
                        // conditionOutcomes is cached from previous iterations
                        // of the loop.
                        if (conditionOutcomes == null) {
                            conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE);
                    } else {
                        // conditionFlowScope is cached from previous iterations
                        // of the loop.
                        if (conditionFlowScope == null) {
                            conditionFlowScope = traverse(condition, output.createChildFlowScope());
                        }
                        newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE);
                    }
                }
                break;
        }
        result.add(newScope.optimize());
    }
    return result;
}","public void test131131() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""[0l"", ""[0l"");
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    Scope scope0 = typedScopeCreator0.createInitialScope(node0);
    TreeMap<String, CodingConvention.AssertionFunctionSpec> treeMap0 = new TreeMap<String, CodingConvention.AssertionFunctionSpec>();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    LinkedFlowScope linkedFlowScope0 = LinkedFlowScope.createEntryLattice(scope0);
    Node node1 = Node.newString(101, ""[0l"");
    Node node2 = new Node(101, node1, node0);
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node2, true, true);
    TypeInference typeInference0 = new TypeInference(compiler0, controlFlowGraph0, reverseAbstractInterpreter0, scope0, treeMap0);
    // Undeclared exception!
    try {
        typeInference0.branchedFlowThrough(node2, linkedFlowScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeInference"", e);
    }
}",""
"static BooleanLiteralSet getBooleanOutcomes(BooleanLiteralSet left, BooleanLiteralSet right, boolean condition) {
    return right.union(left.intersection(BooleanLiteralSet.get(!condition)));
}","public void test132132() throws Throwable {
    BooleanLiteralSet booleanLiteralSet0 = BooleanLiteralSet.BOTH;
    BooleanLiteralSet booleanLiteralSet1 = TypeInference.getBooleanOutcomes(booleanLiteralSet0, booleanLiteralSet0, false);
    assertSame(booleanLiteralSet1, booleanLiteralSet0);
}","/**
 * Infers the boolean literal set that can be taken by a
 * short-circuiting binary operation ({@code &&} or {@code ||}).
 * @param left the set of possible {@code ToBoolean} predicate results for
 *    the expression on the left side of the operator
 * @param right the set of possible {@code ToBoolean} predicate results for
 *    the expression on the right side of the operator
 * @param condition the left side {@code ToBoolean} predicate result that
 *    causes the right side to get evaluated (i.e. not short-circuited)
 * @return a set of possible {@code ToBoolean} predicate results for the
 *    entire expression
 */"
