focal_method,test_prefix,docstring
"@Deprecated
protected void initOptionsFromFlags(CompilerOptions options) {
}","public void test000() throws Throwable {
    String[] stringArray0 = new String[1];
    stringArray0[0] = ""qnH@O@Rg"";
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0);
    CompilerOptions compilerOptions0 = new CompilerOptions();
    commandLineRunner0.initOptionsFromFlags(compilerOptions0);
    assertFalse(compilerOptions0.inlineLocalVariables);
}","/**
 * No longer does anything.
 */"
"final protected A getCompiler() {
    return compiler;
}","public void test011() throws Throwable {
    String[] stringArray0 = new String[1];
    stringArray0[0] = ""qnH@O@Rg"";
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0);
    Compiler compiler0 = commandLineRunner0.getCompiler();
    assertNull(compiler0);
}",""
"List<JSModule> createJsModules(List<String> specs, List<String> jsFiles) throws FlagUsageException, IOException {
    if (isInTestMode()) {
        return modulesSupplierForTesting.get();
    }
    Preconditions.checkState(specs != null);
    Preconditions.checkState(!specs.isEmpty());
    Preconditions.checkState(jsFiles != null);
    final int totalNumJsFiles = jsFiles.size();
    int nextJsFileIndex = 0;
    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();
    for (String spec : specs) {
        // Format is ""<name>:<num-js-files>[:[<dep>,...][:]]"".
        String[] parts = spec.split("":"");
        if (parts.length < 2 || parts.length > 4) {
            throw new FlagUsageException(""Expected 2-4 colon-delimited parts in "" + ""module spec: "" + spec);
        }
        // Parse module name.
        String name = parts[0];
        checkModuleName(name);
        if (modulesByName.containsKey(name)) {
            throw new FlagUsageException(""Duplicate module name: "" + name);
        }
        JSModule module = new JSModule(name);
        // Parse module inputs.
        int numJsFiles = -1;
        try {
            numJsFiles = Integer.parseInt(parts[1]);
        } catch (NumberFormatException ignored) {
            numJsFiles = -1;
        }
        // We will allow modules of zero input.
        if (numJsFiles < 0) {
            throw new FlagUsageException(""Invalid js file count '"" + parts[1] + ""' for module: "" + name);
        }
        if (nextJsFileIndex + numJsFiles > totalNumJsFiles) {
            throw new FlagUsageException(""Not enough js files specified. Expected "" + (nextJsFileIndex + numJsFiles - totalNumJsFiles) + "" more in module:"" + name);
        }
        List<String> moduleJsFiles = jsFiles.subList(nextJsFileIndex, nextJsFileIndex + numJsFiles);
        for (JSSourceFile input : createInputs(moduleJsFiles, false)) {
            module.add(input);
        }
        nextJsFileIndex += numJsFiles;
        if (parts.length > 2) {
            // Parse module dependencies.
            String depList = parts[2];
            if (depList.length() > 0) {
                String[] deps = depList.split("","");
                for (String dep : deps) {
                    JSModule other = modulesByName.get(dep);
                    if (other == null) {
                        throw new FlagUsageException(""Module '"" + name + ""' depends on unknown module '"" + dep + ""'. Be sure to list modules in dependency order."");
                    }
                    module.addDependency(other);
                }
            }
        }
        modulesByName.put(name, module);
    }
    if (nextJsFileIndex < totalNumJsFiles) {
        throw new FlagUsageException(""Too many js files specified. Expected "" + nextJsFileIndex + "" but found "" + totalNumJsFiles);
    }
    return Lists.newArrayList(modulesByName.values());
}","public void test022() throws Throwable {
    String[] stringArray0 = new String[0];
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0);
    List<String> list0 = ResourceBundle.Control.FORMAT_DEFAULT;
    try {
        commandLineRunner0.createJsModules(list0, list0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Expected 2-4 colon-delimited parts in module spec: java.class
        //
        verifyException(""com.google.javascript.jscomp.AbstractCommandLineRunner"", e);
    }
}","/**
 * Creates module objects from a list of module specifications.
 *
 * @param specs A list of module specifications, not null or empty. The spec
 *        format is: <code>name:num-js-files[:[dep,...][:]]</code>. Module
 *        names must not contain the ':' character.
 * @param jsFiles A list of js file paths, not null
 * @return An array of module objects
 */"
"final protected void setRunOptions(CompilerOptions options) throws FlagUsageException, IOException {
    DiagnosticGroups diagnosticGroups = getDiagnosticGroups();
    diagnosticGroups.setWarningLevels(options, config.jscompError, CheckLevel.ERROR);
    diagnosticGroups.setWarningLevels(options, config.jscompWarning, CheckLevel.WARNING);
    diagnosticGroups.setWarningLevels(options, config.jscompOff, CheckLevel.OFF);
    createDefineOrTweakReplacements(config.define, options, false);
    options.setTweakProcessing(config.tweakProcessing);
    createDefineOrTweakReplacements(config.tweak, options, true);
    options.manageClosureDependencies = config.manageClosureDependencies;
    if (config.closureEntryPoints.size() > 0) {
        options.setManageClosureDependencies(config.closureEntryPoints);
    }
    options.devMode = config.jscompDevMode;
    options.setCodingConvention(config.codingConvention);
    options.setSummaryDetailLevel(config.summaryDetailLevel);
    outputCharset = options.outputCharset = getOutputCharset();
    inputCharset = getInputCharset();
    if (config.jsOutputFile.length() > 0) {
        options.jsOutputFile = config.jsOutputFile;
    }
    if (config.createSourceMap.length() > 0) {
        options.sourceMapOutputPath = config.createSourceMap;
    }
    options.sourceMapDetailLevel = config.sourceMapDetailLevel;
    options.sourceMapFormat = config.sourceMapFormat;
    if (!config.variableMapInputFile.equals("""")) {
        options.inputVariableMapSerialized = VariableMap.load(config.variableMapInputFile).toBytes();
    }
    if (!config.propertyMapInputFile.equals("""")) {
        options.inputPropertyMapSerialized = VariableMap.load(config.propertyMapInputFile).toBytes();
    }
    if (config.languageIn.length() > 0) {
        if (config.languageIn.equals(""ECMASCRIPT5_STRICT"") || config.languageIn.equals(""ES5_STRICT"")) {
            options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);
        } else if (config.languageIn.equals(""ECMASCRIPT5"") || config.languageIn.equals(""ES5"")) {
            options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);
        } else if (config.languageIn.equals(""ECMASCRIPT3"") || config.languageIn.equals(""ES3"")) {
            options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT3);
        } else {
            throw new FlagUsageException(""Unknown language `"" + config.languageIn + ""' specified."");
        }
    }
    options.acceptConstKeyword = config.acceptConstKeyword;
}","public void test077() throws Throwable {
    String[] stringArray0 = new String[1];
    stringArray0[0] = "" from module "";
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0);
    CompilerOptions compilerOptions0 = commandLineRunner0.createOptions();
    commandLineRunner0.setRunOptions(compilerOptions0);
    assertFalse(compilerOptions0.ideMode);
}","/**
 * Sets options based on the configurations set flags API.
 * Called during the run() run() method.
 * If you want to ignore the flags API, or intepret flags your own way,
 * then you should override this method.
 */"
"final public void run() {
    int result = 0;
    int runs = 1;
    if (config.computePhaseOrdering) {
        runs = NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER;
        PhaseOptimizer.randomizeLoops();
    }
    try {
        for (int i = 0; i < runs && result == 0; i++) {
            runTimeStats.recordStartRun();
            result = doRun();
            runTimeStats.recordEndRun();
        }
    } catch (AbstractCommandLineRunner.FlagUsageException e) {
        System.err.println(e.getMessage());
        result = -1;
    } catch (Throwable t) {
        t.printStackTrace();
        result = -2;
    }
    if (config.computePhaseOrdering) {
        runTimeStats.outputBestPhaseOrdering();
    }
    if (testMode) {
        exitCodeReceiverForTesting.apply(result);
    } else {
        System.exit(result);
    }
}","public void test088() throws Throwable {
    String[] stringArray0 = new String[0];
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0);
    LinkedList<JSSourceFile> linkedList0 = new LinkedList<JSSourceFile>();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""NU(TMkCa"");
    linkedList0.add(jSSourceFile0);
    Supplier<List<JSSourceFile>> supplier0 = (Supplier<List<JSSourceFile>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
    doReturn(linkedList0, linkedList0).when(supplier0).get();
    commandLineRunner0.enableTestMode(supplier0, supplier0, (Supplier<List<JSModule>>) null, (Function<Integer, Boolean>) null);
    // Undeclared exception!
    try {
        commandLineRunner0.run();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.AbstractCommandLineRunner"", e);
    }
}","/**
 * Runs the Compiler and calls System.exit() with the exit status of the
 * compiler.
 */"
"protected List<JSSourceFile> createInputs(List<String> files, boolean allowStdIn) throws FlagUsageException, IOException {
    List<JSSourceFile> inputs = new ArrayList<JSSourceFile>(files.size());
    boolean usingStdin = false;
    for (String filename : files) {
        if (!""-"".equals(filename)) {
            JSSourceFile newFile = JSSourceFile.fromFile(filename, inputCharset);
            inputs.add(newFile);
        } else {
            if (!allowStdIn) {
                throw new FlagUsageException(""Can't specify stdin."");
            }
            if (usingStdin) {
                throw new FlagUsageException(""Can't specify stdin twice."");
            }
            inputs.add(JSSourceFile.fromInputStream(""stdin"", System.in));
            usingStdin = true;
        }
    }
    return inputs;
}","public void test1111() throws Throwable {
    String[] stringArray0 = new String[0];
    ArrayList<String> arrayList0 = new ArrayList<String>();
    arrayList0.add(""-"");
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0);
    try {
        commandLineRunner0.createInputs(arrayList0, false);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Can't specify stdin.
        //
        verifyException(""com.google.javascript.jscomp.AbstractCommandLineRunner"", e);
    }
}","/**
 * Creates inputs from a list of files.
 *
 * Can be overridden by subclasses who want to pull files from different
 * places.
 *
 * @param files A list of filenames
 * @param allowStdIn Whether '-' is allowed appear as a filename to represent
 *        stdin. If true, '-' is only allowed to appear once.
 * @return An array of inputs
 */"
"List<JSModule> createJsModules(List<String> specs, List<String> jsFiles) throws FlagUsageException, IOException {
    if (isInTestMode()) {
        return modulesSupplierForTesting.get();
    }
    Preconditions.checkState(specs != null);
    Preconditions.checkState(!specs.isEmpty());
    Preconditions.checkState(jsFiles != null);
    final int totalNumJsFiles = jsFiles.size();
    int nextJsFileIndex = 0;
    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();
    for (String spec : specs) {
        // Format is ""<name>:<num-js-files>[:[<dep>,...][:]]"".
        String[] parts = spec.split("":"");
        if (parts.length < 2 || parts.length > 4) {
            throw new FlagUsageException(""Expected 2-4 colon-delimited parts in "" + ""module spec: "" + spec);
        }
        // Parse module name.
        String name = parts[0];
        checkModuleName(name);
        if (modulesByName.containsKey(name)) {
            throw new FlagUsageException(""Duplicate module name: "" + name);
        }
        JSModule module = new JSModule(name);
        // Parse module inputs.
        int numJsFiles = -1;
        try {
            numJsFiles = Integer.parseInt(parts[1]);
        } catch (NumberFormatException ignored) {
            numJsFiles = -1;
        }
        // We will allow modules of zero input.
        if (numJsFiles < 0) {
            throw new FlagUsageException(""Invalid js file count '"" + parts[1] + ""' for module: "" + name);
        }
        if (nextJsFileIndex + numJsFiles > totalNumJsFiles) {
            throw new FlagUsageException(""Not enough js files specified. Expected "" + (nextJsFileIndex + numJsFiles - totalNumJsFiles) + "" more in module:"" + name);
        }
        List<String> moduleJsFiles = jsFiles.subList(nextJsFileIndex, nextJsFileIndex + numJsFiles);
        for (JSSourceFile input : createInputs(moduleJsFiles, false)) {
            module.add(input);
        }
        nextJsFileIndex += numJsFiles;
        if (parts.length > 2) {
            // Parse module dependencies.
            String depList = parts[2];
            if (depList.length() > 0) {
                String[] deps = depList.split("","");
                for (String dep : deps) {
                    JSModule other = modulesByName.get(dep);
                    if (other == null) {
                        throw new FlagUsageException(""Module '"" + name + ""' depends on unknown module '"" + dep + ""'. Be sure to list modules in dependency order."");
                    }
                    module.addDependency(other);
                }
            }
        }
        modulesByName.put(name, module);
    }
    if (nextJsFileIndex < totalNumJsFiles) {
        throw new FlagUsageException(""Too many js files specified. Expected "" + nextJsFileIndex + "" but found "" + totalNumJsFiles);
    }
    return Lists.newArrayList(modulesByName.values());
}","public void test1212() throws Throwable {
    String[] stringArray0 = new String[0];
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0);
    Supplier<List<JSModule>> supplier0 = (Supplier<List<JSModule>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
    doReturn((Object) null).when(supplier0).get();
    Function<Integer, Boolean> function0 = (Function<Integer, Boolean>) mock(Function.class, new ViolatedAssumptionAnswer());
    commandLineRunner0.enableTestMode((Supplier<List<JSSourceFile>>) null, (Supplier<List<JSSourceFile>>) null, supplier0, function0);
    List<String> list0 = ResourceBundle.Control.FORMAT_DEFAULT;
    List<JSModule> list1 = commandLineRunner0.createJsModules(list0, list0);
    assertNull(list1);
}","/**
 * Creates module objects from a list of module specifications.
 *
 * @param specs A list of module specifications, not null or empty. The spec
 *        format is: <code>name:num-js-files[:[dep,...][:]]</code>. Module
 *        names must not contain the ':' character.
 * @param jsFiles A list of js file paths, not null
 * @return An array of module objects
 */"
"List<JSModule> createJsModules(List<String> specs, List<String> jsFiles) throws FlagUsageException, IOException {
    if (isInTestMode()) {
        return modulesSupplierForTesting.get();
    }
    Preconditions.checkState(specs != null);
    Preconditions.checkState(!specs.isEmpty());
    Preconditions.checkState(jsFiles != null);
    final int totalNumJsFiles = jsFiles.size();
    int nextJsFileIndex = 0;
    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();
    for (String spec : specs) {
        // Format is ""<name>:<num-js-files>[:[<dep>,...][:]]"".
        String[] parts = spec.split("":"");
        if (parts.length < 2 || parts.length > 4) {
            throw new FlagUsageException(""Expected 2-4 colon-delimited parts in "" + ""module spec: "" + spec);
        }
        // Parse module name.
        String name = parts[0];
        checkModuleName(name);
        if (modulesByName.containsKey(name)) {
            throw new FlagUsageException(""Duplicate module name: "" + name);
        }
        JSModule module = new JSModule(name);
        // Parse module inputs.
        int numJsFiles = -1;
        try {
            numJsFiles = Integer.parseInt(parts[1]);
        } catch (NumberFormatException ignored) {
            numJsFiles = -1;
        }
        // We will allow modules of zero input.
        if (numJsFiles < 0) {
            throw new FlagUsageException(""Invalid js file count '"" + parts[1] + ""' for module: "" + name);
        }
        if (nextJsFileIndex + numJsFiles > totalNumJsFiles) {
            throw new FlagUsageException(""Not enough js files specified. Expected "" + (nextJsFileIndex + numJsFiles - totalNumJsFiles) + "" more in module:"" + name);
        }
        List<String> moduleJsFiles = jsFiles.subList(nextJsFileIndex, nextJsFileIndex + numJsFiles);
        for (JSSourceFile input : createInputs(moduleJsFiles, false)) {
            module.add(input);
        }
        nextJsFileIndex += numJsFiles;
        if (parts.length > 2) {
            // Parse module dependencies.
            String depList = parts[2];
            if (depList.length() > 0) {
                String[] deps = depList.split("","");
                for (String dep : deps) {
                    JSModule other = modulesByName.get(dep);
                    if (other == null) {
                        throw new FlagUsageException(""Module '"" + name + ""' depends on unknown module '"" + dep + ""'. Be sure to list modules in dependency order."");
                    }
                    module.addDependency(other);
                }
            }
        }
        modulesByName.put(name, module);
    }
    if (nextJsFileIndex < totalNumJsFiles) {
        throw new FlagUsageException(""Too many js files specified. Expected "" + nextJsFileIndex + "" but found "" + totalNumJsFiles);
    }
    return Lists.newArrayList(modulesByName.values());
}","public void test1313() throws Throwable {
    String[] stringArray0 = new String[0];
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0);
    // Undeclared exception!
    try {
        commandLineRunner0.createJsModules((List<String>) null, (List<String>) null);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Creates module objects from a list of module specifications.
 *
 * @param specs A list of module specifications, not null or empty. The spec
 *        format is: <code>name:num-js-files[:[dep,...][:]]</code>. Module
 *        names must not contain the ':' character.
 * @param jsFiles A list of js file paths, not null
 * @return An array of module objects
 */"
"List<JSModule> createJsModules(List<String> specs, List<String> jsFiles) throws FlagUsageException, IOException {
    if (isInTestMode()) {
        return modulesSupplierForTesting.get();
    }
    Preconditions.checkState(specs != null);
    Preconditions.checkState(!specs.isEmpty());
    Preconditions.checkState(jsFiles != null);
    final int totalNumJsFiles = jsFiles.size();
    int nextJsFileIndex = 0;
    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();
    for (String spec : specs) {
        // Format is ""<name>:<num-js-files>[:[<dep>,...][:]]"".
        String[] parts = spec.split("":"");
        if (parts.length < 2 || parts.length > 4) {
            throw new FlagUsageException(""Expected 2-4 colon-delimited parts in "" + ""module spec: "" + spec);
        }
        // Parse module name.
        String name = parts[0];
        checkModuleName(name);
        if (modulesByName.containsKey(name)) {
            throw new FlagUsageException(""Duplicate module name: "" + name);
        }
        JSModule module = new JSModule(name);
        // Parse module inputs.
        int numJsFiles = -1;
        try {
            numJsFiles = Integer.parseInt(parts[1]);
        } catch (NumberFormatException ignored) {
            numJsFiles = -1;
        }
        // We will allow modules of zero input.
        if (numJsFiles < 0) {
            throw new FlagUsageException(""Invalid js file count '"" + parts[1] + ""' for module: "" + name);
        }
        if (nextJsFileIndex + numJsFiles > totalNumJsFiles) {
            throw new FlagUsageException(""Not enough js files specified. Expected "" + (nextJsFileIndex + numJsFiles - totalNumJsFiles) + "" more in module:"" + name);
        }
        List<String> moduleJsFiles = jsFiles.subList(nextJsFileIndex, nextJsFileIndex + numJsFiles);
        for (JSSourceFile input : createInputs(moduleJsFiles, false)) {
            module.add(input);
        }
        nextJsFileIndex += numJsFiles;
        if (parts.length > 2) {
            // Parse module dependencies.
            String depList = parts[2];
            if (depList.length() > 0) {
                String[] deps = depList.split("","");
                for (String dep : deps) {
                    JSModule other = modulesByName.get(dep);
                    if (other == null) {
                        throw new FlagUsageException(""Module '"" + name + ""' depends on unknown module '"" + dep + ""'. Be sure to list modules in dependency order."");
                    }
                    module.addDependency(other);
                }
            }
        }
        modulesByName.put(name, module);
    }
    if (nextJsFileIndex < totalNumJsFiles) {
        throw new FlagUsageException(""Too many js files specified. Expected "" + nextJsFileIndex + "" but found "" + totalNumJsFiles);
    }
    return Lists.newArrayList(modulesByName.values());
}","public void test1414() throws Throwable {
    String[] stringArray0 = new String[0];
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0);
    LinkedList<String> linkedList0 = new LinkedList<String>();
    // Undeclared exception!
    try {
        commandLineRunner0.createJsModules(linkedList0, linkedList0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Creates module objects from a list of module specifications.
 *
 * @param specs A list of module specifications, not null or empty. The spec
 *        format is: <code>name:num-js-files[:[dep,...][:]]</code>. Module
 *        names must not contain the ':' character.
 * @param jsFiles A list of js file paths, not null
 * @return An array of module objects
 */"
"List<JSModule> createJsModules(List<String> specs, List<String> jsFiles) throws FlagUsageException, IOException {
    if (isInTestMode()) {
        return modulesSupplierForTesting.get();
    }
    Preconditions.checkState(specs != null);
    Preconditions.checkState(!specs.isEmpty());
    Preconditions.checkState(jsFiles != null);
    final int totalNumJsFiles = jsFiles.size();
    int nextJsFileIndex = 0;
    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();
    for (String spec : specs) {
        // Format is ""<name>:<num-js-files>[:[<dep>,...][:]]"".
        String[] parts = spec.split("":"");
        if (parts.length < 2 || parts.length > 4) {
            throw new FlagUsageException(""Expected 2-4 colon-delimited parts in "" + ""module spec: "" + spec);
        }
        // Parse module name.
        String name = parts[0];
        checkModuleName(name);
        if (modulesByName.containsKey(name)) {
            throw new FlagUsageException(""Duplicate module name: "" + name);
        }
        JSModule module = new JSModule(name);
        // Parse module inputs.
        int numJsFiles = -1;
        try {
            numJsFiles = Integer.parseInt(parts[1]);
        } catch (NumberFormatException ignored) {
            numJsFiles = -1;
        }
        // We will allow modules of zero input.
        if (numJsFiles < 0) {
            throw new FlagUsageException(""Invalid js file count '"" + parts[1] + ""' for module: "" + name);
        }
        if (nextJsFileIndex + numJsFiles > totalNumJsFiles) {
            throw new FlagUsageException(""Not enough js files specified. Expected "" + (nextJsFileIndex + numJsFiles - totalNumJsFiles) + "" more in module:"" + name);
        }
        List<String> moduleJsFiles = jsFiles.subList(nextJsFileIndex, nextJsFileIndex + numJsFiles);
        for (JSSourceFile input : createInputs(moduleJsFiles, false)) {
            module.add(input);
        }
        nextJsFileIndex += numJsFiles;
        if (parts.length > 2) {
            // Parse module dependencies.
            String depList = parts[2];
            if (depList.length() > 0) {
                String[] deps = depList.split("","");
                for (String dep : deps) {
                    JSModule other = modulesByName.get(dep);
                    if (other == null) {
                        throw new FlagUsageException(""Module '"" + name + ""' depends on unknown module '"" + dep + ""'. Be sure to list modules in dependency order."");
                    }
                    module.addDependency(other);
                }
            }
        }
        modulesByName.put(name, module);
    }
    if (nextJsFileIndex < totalNumJsFiles) {
        throw new FlagUsageException(""Too many js files specified. Expected "" + nextJsFileIndex + "" but found "" + totalNumJsFiles);
    }
    return Lists.newArrayList(modulesByName.values());
}","public void test1515() throws Throwable {
    String[] stringArray0 = new String[0];
    JSModule jSModule0 = new JSModule(""}QEjGXC2%_l"");
    List<String> list0 = jSModule0.getProvides();
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0);
    // Undeclared exception!
    try {
        commandLineRunner0.createJsModules(list0, (List<String>) null);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Creates module objects from a list of module specifications.
 *
 * @param specs A list of module specifications, not null or empty. The spec
 *        format is: <code>name:num-js-files[:[dep,...][:]]</code>. Module
 *        names must not contain the ':' character.
 * @param jsFiles A list of js file paths, not null
 * @return An array of module objects
 */"
"List<JSModule> createJsModules(List<String> specs, List<String> jsFiles) throws FlagUsageException, IOException {
    if (isInTestMode()) {
        return modulesSupplierForTesting.get();
    }
    Preconditions.checkState(specs != null);
    Preconditions.checkState(!specs.isEmpty());
    Preconditions.checkState(jsFiles != null);
    final int totalNumJsFiles = jsFiles.size();
    int nextJsFileIndex = 0;
    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();
    for (String spec : specs) {
        // Format is ""<name>:<num-js-files>[:[<dep>,...][:]]"".
        String[] parts = spec.split("":"");
        if (parts.length < 2 || parts.length > 4) {
            throw new FlagUsageException(""Expected 2-4 colon-delimited parts in "" + ""module spec: "" + spec);
        }
        // Parse module name.
        String name = parts[0];
        checkModuleName(name);
        if (modulesByName.containsKey(name)) {
            throw new FlagUsageException(""Duplicate module name: "" + name);
        }
        JSModule module = new JSModule(name);
        // Parse module inputs.
        int numJsFiles = -1;
        try {
            numJsFiles = Integer.parseInt(parts[1]);
        } catch (NumberFormatException ignored) {
            numJsFiles = -1;
        }
        // We will allow modules of zero input.
        if (numJsFiles < 0) {
            throw new FlagUsageException(""Invalid js file count '"" + parts[1] + ""' for module: "" + name);
        }
        if (nextJsFileIndex + numJsFiles > totalNumJsFiles) {
            throw new FlagUsageException(""Not enough js files specified. Expected "" + (nextJsFileIndex + numJsFiles - totalNumJsFiles) + "" more in module:"" + name);
        }
        List<String> moduleJsFiles = jsFiles.subList(nextJsFileIndex, nextJsFileIndex + numJsFiles);
        for (JSSourceFile input : createInputs(moduleJsFiles, false)) {
            module.add(input);
        }
        nextJsFileIndex += numJsFiles;
        if (parts.length > 2) {
            // Parse module dependencies.
            String depList = parts[2];
            if (depList.length() > 0) {
                String[] deps = depList.split("","");
                for (String dep : deps) {
                    JSModule other = modulesByName.get(dep);
                    if (other == null) {
                        throw new FlagUsageException(""Module '"" + name + ""' depends on unknown module '"" + dep + ""'. Be sure to list modules in dependency order."");
                    }
                    module.addDependency(other);
                }
            }
        }
        modulesByName.put(name, module);
    }
    if (nextJsFileIndex < totalNumJsFiles) {
        throw new FlagUsageException(""Too many js files specified. Expected "" + nextJsFileIndex + "" but found "" + totalNumJsFiles);
    }
    return Lists.newArrayList(modulesByName.values());
}","public void test1616() throws Throwable {
    String[] stringArray0 = new String[0];
    ArrayList<String> arrayList0 = new ArrayList<String>();
    arrayList0.add(""Z:c_lk|)="");
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0);
    try {
        commandLineRunner0.createJsModules(arrayList0, arrayList0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Invalid js file count 'c_lk|)=' for module: Z
        //
        verifyException(""com.google.javascript.jscomp.AbstractCommandLineRunner"", e);
    }
}","/**
 * Creates module objects from a list of module specifications.
 *
 * @param specs A list of module specifications, not null or empty. The spec
 *        format is: <code>name:num-js-files[:[dep,...][:]]</code>. Module
 *        names must not contain the ':' character.
 * @param jsFiles A list of js file paths, not null
 * @return An array of module objects
 */"
"protected void checkModuleName(String name) throws FlagUsageException {
    if (!TokenStream.isJSIdentifier(name)) {
        throw new FlagUsageException(""Invalid module name: '"" + name + ""'"");
    }
}","public void test1717() throws Throwable {
    String[] stringArray0 = new String[0];
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0);
    try {
        commandLineRunner0.checkModuleName("">"");
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Invalid module name: '>'
        //
        verifyException(""com.google.javascript.jscomp.AbstractCommandLineRunner"", e);
    }
}","/**
 * Validates the module name. Can be overridden by subclasses.
 * @param name The module name
 * @throws FlagUsageException if the validation fails
 */"
"static Map<String, String> parseModuleWrappers(List<String> specs, List<JSModule> modules) throws FlagUsageException {
    Preconditions.checkState(specs != null);
    Map<String, String> wrappers = Maps.newHashMapWithExpectedSize(modules.size());
    // Prepopulate the map with module names.
    for (JSModule m : modules) {
        wrappers.put(m.getName(), """");
    }
    for (String spec : specs) {
        // Format is ""<name>:<wrapper>"".
        int pos = spec.indexOf(':');
        if (pos == -1) {
            throw new FlagUsageException(""Expected module wrapper to have "" + ""<name>:<wrapper> format: "" + spec);
        }
        // Parse module name.
        String name = spec.substring(0, pos);
        if (!wrappers.containsKey(name)) {
            throw new FlagUsageException(""Unknown module: '"" + name + ""'"");
        }
        String wrapper = spec.substring(pos + 1);
        if (!wrapper.contains(""%s"")) {
            throw new FlagUsageException(""No %s placeholder in module wrapper: '"" + wrapper + ""'"");
        }
        wrappers.put(name, wrapper);
    }
    return wrappers;
}","public void test1818() throws Throwable {
    LinkedList<JSModule> linkedList0 = new LinkedList<JSModule>();
    // Undeclared exception!
    try {
        AbstractCommandLineRunner.parseModuleWrappers((List<String>) null, linkedList0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Parses module wrapper specifications.
 *
 * @param specs A list of module wrapper specifications, not null. The spec
 *        format is: <code>name:wrapper</code>. Wrappers.
 * @param modules The JS modules whose wrappers are specified
 * @return A map from module name to module wrapper. Modules with no wrapper
 *         will have the empty string as their value in this map.
 */"
"int processResults(Result result, List<JSModule> modules, B options) throws FlagUsageException, IOException {
    if (config.computePhaseOrdering) {
        return 0;
    }
    if (config.printPassGraph) {
        if (compiler.getRoot() == null) {
            return 1;
        } else {
            out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));
            out.append('\n');
            return 0;
        }
    }
    if (config.printAst) {
        if (compiler.getRoot() == null) {
            return 1;
        } else {
            ControlFlowGraph<Node> cfg = compiler.computeCFG();
            DotFormatter.appendDot(compiler.getRoot().getLastChild(), cfg, out);
            out.append('\n');
            return 0;
        }
    }
    if (config.printTree) {
        if (compiler.getRoot() == null) {
            out.append(""Code contains errors; no tree was generated.\n"");
            return 1;
        } else {
            compiler.getRoot().appendStringTree(out);
            out.append(""\n"");
            return 0;
        }
    }
    if (result.success) {
        if (modules == null) {
            writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, OUTPUT_WRAPPER_MARKER);
            // Output the source map if requested.
            outputSourceMap(options);
        } else {
            String moduleFilePrefix = config.moduleOutputPathPrefix;
            maybeCreateDirsForPath(moduleFilePrefix);
            Map<String, String> moduleWrappers = parseModuleWrappers(config.moduleWrapper, modules);
            // If the source map path is in fact a pattern for each
            // module, create a stream per-module. Otherwise, create
            // a single source map.
            Writer mapOut = null;
            if (!shouldGenerateMapPerModule(options)) {
                mapOut = fileNameToOutputWriter(expandSourceMapPath(options, null));
            }
            for (JSModule m : modules) {
                if (shouldGenerateMapPerModule(options)) {
                    mapOut = fileNameToOutputWriter(expandSourceMapPath(options, m));
                }
                Writer writer = fileNameToOutputWriter(moduleFilePrefix + m.getName() + "".js"");
                if (options.sourceMapOutputPath != null) {
                    compiler.getSourceMap().reset();
                }
                writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), ""%s"");
                if (options.sourceMapOutputPath != null) {
                    compiler.getSourceMap().appendTo(mapOut, m.getName());
                }
                writer.close();
                if (shouldGenerateMapPerModule(options) && mapOut != null) {
                    mapOut.close();
                    mapOut = null;
                }
            }
            if (mapOut != null) {
                mapOut.close();
            }
        }
        // Output the externs if required.
        if (options.externExportsPath != null) {
            Writer eeOut = openExternExportsStream(options, options.jsOutputFile);
            eeOut.append(result.externExport);
            eeOut.close();
        }
        // Output the variable and property name maps if requested.
        outputNameMaps(options);
        // Output the manifest if requested.
        outputManifest();
    }
    // return 0 if no errors, the error count otherwise
    return Math.min(result.errors.length, 0x7f);
}","public void test1919() throws Throwable {
    String[] stringArray0 = new String[0];
    JSError[] jSErrorArray0 = new JSError[0];
    MockPrintStream mockPrintStream0 = new MockPrintStream(""j|A,z]Ypxx4pY(+Ur1W"");
    Compiler compiler0 = new Compiler(mockPrintStream0);
    Result result0 = new Result(jSErrorArray0, jSErrorArray0, ""j|A,z]Ypxx4pY(+Ur1W"", (VariableMap) null, (VariableMap) null, (VariableMap) null, (FunctionInformationMap) null, (SourceMap) null, ""j|A,z]Ypxx4pY(+Ur1W"");
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0, mockPrintStream0, mockPrintStream0);
    LinkedList<JSModule> linkedList0 = new LinkedList<JSModule>();
    CompilerOptions compilerOptions0 = compiler0.options;
    // Undeclared exception!
    try {
        commandLineRunner0.processResults(result0, linkedList0, compilerOptions0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.AbstractCommandLineRunner"", e);
    }
}","/**
 * Processes the results of the compile job, and returns an error code.
 */"
"static Map<String, String> parseModuleWrappers(List<String> specs, List<JSModule> modules) throws FlagUsageException {
    Preconditions.checkState(specs != null);
    Map<String, String> wrappers = Maps.newHashMapWithExpectedSize(modules.size());
    // Prepopulate the map with module names.
    for (JSModule m : modules) {
        wrappers.put(m.getName(), """");
    }
    for (String spec : specs) {
        // Format is ""<name>:<wrapper>"".
        int pos = spec.indexOf(':');
        if (pos == -1) {
            throw new FlagUsageException(""Expected module wrapper to have "" + ""<name>:<wrapper> format: "" + spec);
        }
        // Parse module name.
        String name = spec.substring(0, pos);
        if (!wrappers.containsKey(name)) {
            throw new FlagUsageException(""Unknown module: '"" + name + ""'"");
        }
        String wrapper = spec.substring(pos + 1);
        if (!wrapper.contains(""%s"")) {
            throw new FlagUsageException(""No %s placeholder in module wrapper: '"" + wrapper + ""'"");
        }
        wrappers.put(name, wrapper);
    }
    return wrappers;
}","public void test2020() throws Throwable {
    JSModule jSModule0 = new JSModule(""XhKqF;P[:N"");
    List<String> list0 = jSModule0.getProvides();
    LinkedList<JSModule> linkedList0 = new LinkedList<JSModule>();
    linkedList0.add(jSModule0);
    try {
        AbstractCommandLineRunner.parseModuleWrappers(list0, linkedList0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Unknown module: 'XhKqF;P['
        //
        verifyException(""com.google.javascript.jscomp.AbstractCommandLineRunner"", e);
    }
}","/**
 * Parses module wrapper specifications.
 *
 * @param specs A list of module wrapper specifications, not null. The spec
 *        format is: <code>name:wrapper</code>. Wrappers.
 * @param modules The JS modules whose wrappers are specified
 * @return A map from module name to module wrapper. Modules with no wrapper
 *         will have the empty string as their value in this map.
 */"
"static Map<String, String> parseModuleWrappers(List<String> specs, List<JSModule> modules) throws FlagUsageException {
    Preconditions.checkState(specs != null);
    Map<String, String> wrappers = Maps.newHashMapWithExpectedSize(modules.size());
    // Prepopulate the map with module names.
    for (JSModule m : modules) {
        wrappers.put(m.getName(), """");
    }
    for (String spec : specs) {
        // Format is ""<name>:<wrapper>"".
        int pos = spec.indexOf(':');
        if (pos == -1) {
            throw new FlagUsageException(""Expected module wrapper to have "" + ""<name>:<wrapper> format: "" + spec);
        }
        // Parse module name.
        String name = spec.substring(0, pos);
        if (!wrappers.containsKey(name)) {
            throw new FlagUsageException(""Unknown module: '"" + name + ""'"");
        }
        String wrapper = spec.substring(pos + 1);
        if (!wrapper.contains(""%s"")) {
            throw new FlagUsageException(""No %s placeholder in module wrapper: '"" + wrapper + ""'"");
        }
        wrappers.put(name, wrapper);
    }
    return wrappers;
}","public void test2121() throws Throwable {
    List<String> list0 = ResourceBundle.Control.FORMAT_DEFAULT;
    LinkedList<JSModule> linkedList0 = new LinkedList<JSModule>();
    try {
        AbstractCommandLineRunner.parseModuleWrappers(list0, linkedList0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Expected module wrapper to have <name>:<wrapper> format: java.class
        //
        verifyException(""com.google.javascript.jscomp.AbstractCommandLineRunner"", e);
    }
}","/**
 * Parses module wrapper specifications.
 *
 * @param specs A list of module wrapper specifications, not null. The spec
 *        format is: <code>name:wrapper</code>. Wrappers.
 * @param modules The JS modules whose wrappers are specified
 * @return A map from module name to module wrapper. Modules with no wrapper
 *         will have the empty string as their value in this map.
 */"
"static void writeOutput(Appendable out, Compiler compiler, String code, String wrapper, String codePlaceholder) throws IOException {
    int pos = wrapper.indexOf(codePlaceholder);
    if (pos != -1) {
        String prefix = """";
        if (pos > 0) {
            prefix = wrapper.substring(0, pos);
            out.append(prefix);
        }
        out.append(code);
        int suffixStart = pos + codePlaceholder.length();
        if (suffixStart != wrapper.length()) {
            // Something after placeholder?
            out.append(wrapper.substring(suffixStart));
        }
        // Make sure we always end output with a line feed.
        out.append('\n');
        // If we have a source map, adjust its offsets to match
        // the code WITHIN the wrapper.
        if (compiler != null && compiler.getSourceMap() != null) {
            compiler.getSourceMap().setWrapperPrefix(prefix);
        }
    } else {
        out.append(code);
        out.append('\n');
    }
}","public void test2222() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        AbstractCommandLineRunner.writeOutput((Appendable) null, compiler0, (String) null, """", ""// Input %num%"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.AbstractCommandLineRunner"", e);
    }
}","/**
 * Writes code to an output stream, optionally wrapping it in an arbitrary
 * wrapper that contains a placeholder where the code should be inserted.
 */"
"int processResults(Result result, List<JSModule> modules, B options) throws FlagUsageException, IOException {
    if (config.computePhaseOrdering) {
        return 0;
    }
    if (config.printPassGraph) {
        if (compiler.getRoot() == null) {
            return 1;
        } else {
            out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));
            out.append('\n');
            return 0;
        }
    }
    if (config.printAst) {
        if (compiler.getRoot() == null) {
            return 1;
        } else {
            ControlFlowGraph<Node> cfg = compiler.computeCFG();
            DotFormatter.appendDot(compiler.getRoot().getLastChild(), cfg, out);
            out.append('\n');
            return 0;
        }
    }
    if (config.printTree) {
        if (compiler.getRoot() == null) {
            out.append(""Code contains errors; no tree was generated.\n"");
            return 1;
        } else {
            compiler.getRoot().appendStringTree(out);
            out.append(""\n"");
            return 0;
        }
    }
    if (result.success) {
        if (modules == null) {
            writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, OUTPUT_WRAPPER_MARKER);
            // Output the source map if requested.
            outputSourceMap(options);
        } else {
            String moduleFilePrefix = config.moduleOutputPathPrefix;
            maybeCreateDirsForPath(moduleFilePrefix);
            Map<String, String> moduleWrappers = parseModuleWrappers(config.moduleWrapper, modules);
            // If the source map path is in fact a pattern for each
            // module, create a stream per-module. Otherwise, create
            // a single source map.
            Writer mapOut = null;
            if (!shouldGenerateMapPerModule(options)) {
                mapOut = fileNameToOutputWriter(expandSourceMapPath(options, null));
            }
            for (JSModule m : modules) {
                if (shouldGenerateMapPerModule(options)) {
                    mapOut = fileNameToOutputWriter(expandSourceMapPath(options, m));
                }
                Writer writer = fileNameToOutputWriter(moduleFilePrefix + m.getName() + "".js"");
                if (options.sourceMapOutputPath != null) {
                    compiler.getSourceMap().reset();
                }
                writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), ""%s"");
                if (options.sourceMapOutputPath != null) {
                    compiler.getSourceMap().appendTo(mapOut, m.getName());
                }
                writer.close();
                if (shouldGenerateMapPerModule(options) && mapOut != null) {
                    mapOut.close();
                    mapOut = null;
                }
            }
            if (mapOut != null) {
                mapOut.close();
            }
        }
        // Output the externs if required.
        if (options.externExportsPath != null) {
            Writer eeOut = openExternExportsStream(options, options.jsOutputFile);
            eeOut.append(result.externExport);
            eeOut.close();
        }
        // Output the variable and property name maps if requested.
        outputNameMaps(options);
        // Output the manifest if requested.
        outputManifest();
    }
    // return 0 if no errors, the error count otherwise
    return Math.min(result.errors.length, 0x7f);
}","public void test2525() throws Throwable {
    JSError[] jSErrorArray0 = new JSError[0];
    MockPrintStream mockPrintStream0 = new MockPrintStream(""j|A,z]Ypxx4pY(+Ur1W"");
    Result result0 = new Result(jSErrorArray0, jSErrorArray0, ""kYt7=&y0K/?[6b#sx"", (VariableMap) null, (VariableMap) null, (VariableMap) null, (FunctionInformationMap) null, (SourceMap) null, ""{ "");
    String[] stringArray0 = new String[9];
    stringArray0[0] = ""{ "";
    stringArray0[1] = ""{ "";
    stringArray0[2] = ""j|A,z]Ypxx4pY(+Ur1W"";
    stringArray0[3] = ""j|A,z]Ypxx4pY(+Ur1W"";
    stringArray0[4] = ""kYt7=&y0K/?[6b#sx"";
    stringArray0[5] = ""j|A,z]Ypxx4pY(+Ur1W"";
    stringArray0[6] = ""{ "";
    stringArray0[7] = ""{ "";
    stringArray0[8] = ""{ "";
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0, mockPrintStream0, mockPrintStream0);
    LinkedList<JSModule> linkedList0 = new LinkedList<JSModule>();
    CompilerOptions compilerOptions0 = commandLineRunner0.createOptions();
    int int0 = commandLineRunner0.processResults(result0, linkedList0, compilerOptions0);
    assertEquals(0, int0);
}","/**
 * Processes the results of the compile job, and returns an error code.
 */"
"final public void run() {
    int result = 0;
    int runs = 1;
    if (config.computePhaseOrdering) {
        runs = NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER;
        PhaseOptimizer.randomizeLoops();
    }
    try {
        for (int i = 0; i < runs && result == 0; i++) {
            runTimeStats.recordStartRun();
            result = doRun();
            runTimeStats.recordEndRun();
        }
    } catch (AbstractCommandLineRunner.FlagUsageException e) {
        System.err.println(e.getMessage());
        result = -1;
    } catch (Throwable t) {
        t.printStackTrace();
        result = -2;
    }
    if (config.computePhaseOrdering) {
        runTimeStats.outputBestPhaseOrdering();
    }
    if (testMode) {
        exitCodeReceiverForTesting.apply(result);
    } else {
        System.exit(result);
    }
}","public void test2626() throws Throwable {
    String[] stringArray0 = new String[0];
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0, (PrintStream) null, (PrintStream) null);
    Supplier<List<JSSourceFile>> supplier0 = (Supplier<List<JSSourceFile>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
    doReturn((Object) null, (Object) null).when(supplier0).get();
    commandLineRunner0.enableTestMode(supplier0, supplier0, (Supplier<List<JSModule>>) null, (Function<Integer, Boolean>) null);
    // Undeclared exception!
    try {
        commandLineRunner0.run();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.AbstractCommandLineRunner"", e);
    }
}","/**
 * Runs the Compiler and calls System.exit() with the exit status of the
 * compiler.
 */"
"@VisibleForTesting
String expandManifest(JSModule forModule) {
    if (Strings.isEmpty(config.outputManifest)) {
        return null;
    }
    return expandCommandLinePath(config.outputManifest, forModule);
}","public void test2727() throws Throwable {
    String[] stringArray0 = new String[0];
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0);
    String string0 = commandLineRunner0.expandManifest((JSModule) null);
    assertNull(string0);
}","/**
 * Expansion function for the manifest.
 */"
"protected OutputStream filenameToOutputStream(String fileName) throws IOException {
    if (fileName == null) {
        return null;
    }
    return new FileOutputStream(fileName);
}","public void test2828() throws Throwable {
    String[] stringArray0 = new String[0];
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0);
    OutputStream outputStream0 = commandLineRunner0.filenameToOutputStream(""VwmI67V5f11$l"");
    assertNotNull(outputStream0);
}","/**
 * Converts a file name into a Ouputstream.
 * Returns null if the file name is null.
 */"
"protected OutputStream filenameToOutputStream(String fileName) throws IOException {
    if (fileName == null) {
        return null;
    }
    return new FileOutputStream(fileName);
}","public void test2929() throws Throwable {
    String[] stringArray0 = new String[0];
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0);
    OutputStream outputStream0 = commandLineRunner0.filenameToOutputStream((String) null);
    assertNull(outputStream0);
}","/**
 * Converts a file name into a Ouputstream.
 * Returns null if the file name is null.
 */"
"@VisibleForTesting
static void createDefineOrTweakReplacements(List<String> definitions, CompilerOptions options, boolean tweaks) {
    // Parse the definitions
    for (String override : definitions) {
        String[] assignment = override.split(""="", 2);
        String defName = assignment[0];
        if (defName.length() > 0) {
            String defValue = assignment.length == 1 ? ""true"" : assignment[1];
            boolean isTrue = defValue.equals(""true"");
            boolean isFalse = defValue.equals(""false"");
            if (isTrue || isFalse) {
                if (tweaks) {
                    options.setTweakToBooleanLiteral(defName, isTrue);
                } else {
                    options.setDefineToBooleanLiteral(defName, isTrue);
                }
                continue;
            } else if (defValue.length() > 1 && ((defValue.charAt(0) == '\'' && defValue.charAt(defValue.length() - 1) == '\'') || (defValue.charAt(0) == '\""' && defValue.charAt(defValue.length() - 1) == '\""'))) {
                // If the value starts and ends with a single quote,
                // we assume that it's a string.
                String maybeStringVal = defValue.substring(1, defValue.length() - 1);
                if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) {
                    if (tweaks) {
                        options.setTweakToStringLiteral(defName, maybeStringVal);
                    } else {
                        options.setDefineToStringLiteral(defName, maybeStringVal);
                    }
                    continue;
                }
            } else {
                try {
                    double value = Double.parseDouble(defValue);
                    if (tweaks) {
                        options.setTweakToDoubleLiteral(defName, value);
                    } else {
                        options.setDefineToDoubleLiteral(defName, value);
                    }
                    continue;
                } catch (NumberFormatException e) {
                    // do nothing, it will be caught at the end
                }
            }
        }
        if (tweaks) {
            throw new RuntimeException(""--tweak flag syntax invalid: "" + override);
        }
        throw new RuntimeException(""--define flag syntax invalid: "" + override);
    }
}","public void test3030() throws Throwable {
    ArrayList<String> arrayList0 = new ArrayList<String>();
    arrayList0.add("""");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    // Undeclared exception!
    try {
        AbstractCommandLineRunner.createDefineOrTweakReplacements(arrayList0, compilerOptions0, false);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // --define flag syntax invalid:
        //
        verifyException(""com.google.javascript.jscomp.AbstractCommandLineRunner"", e);
    }
}","/**
 * Create a map of constant names to constant values from a textual
 * description of the map.
 *
 * @param definitions A list of overriding definitions for defines in
 *     the form <name>[=<val>], where <val> is a number, boolean, or
 *     single-quoted string without single quotes.
 */"
"@VisibleForTesting
static void createDefineOrTweakReplacements(List<String> definitions, CompilerOptions options, boolean tweaks) {
    // Parse the definitions
    for (String override : definitions) {
        String[] assignment = override.split(""="", 2);
        String defName = assignment[0];
        if (defName.length() > 0) {
            String defValue = assignment.length == 1 ? ""true"" : assignment[1];
            boolean isTrue = defValue.equals(""true"");
            boolean isFalse = defValue.equals(""false"");
            if (isTrue || isFalse) {
                if (tweaks) {
                    options.setTweakToBooleanLiteral(defName, isTrue);
                } else {
                    options.setDefineToBooleanLiteral(defName, isTrue);
                }
                continue;
            } else if (defValue.length() > 1 && ((defValue.charAt(0) == '\'' && defValue.charAt(defValue.length() - 1) == '\'') || (defValue.charAt(0) == '\""' && defValue.charAt(defValue.length() - 1) == '\""'))) {
                // If the value starts and ends with a single quote,
                // we assume that it's a string.
                String maybeStringVal = defValue.substring(1, defValue.length() - 1);
                if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) {
                    if (tweaks) {
                        options.setTweakToStringLiteral(defName, maybeStringVal);
                    } else {
                        options.setDefineToStringLiteral(defName, maybeStringVal);
                    }
                    continue;
                }
            } else {
                try {
                    double value = Double.parseDouble(defValue);
                    if (tweaks) {
                        options.setTweakToDoubleLiteral(defName, value);
                    } else {
                        options.setDefineToDoubleLiteral(defName, value);
                    }
                    continue;
                } catch (NumberFormatException e) {
                    // do nothing, it will be caught at the end
                }
            }
        }
        if (tweaks) {
            throw new RuntimeException(""--tweak flag syntax invalid: "" + override);
        }
        throw new RuntimeException(""--define flag syntax invalid: "" + override);
    }
}","public void test3131() throws Throwable {
    ArrayList<String> arrayList0 = new ArrayList<String>();
    arrayList0.add(""7m=$i4^t"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    // Undeclared exception!
    try {
        AbstractCommandLineRunner.createDefineOrTweakReplacements(arrayList0, compilerOptions0, true);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // --tweak flag syntax invalid: 7m=$i4^t
        //
        verifyException(""com.google.javascript.jscomp.AbstractCommandLineRunner"", e);
    }
}","/**
 * Create a map of constant names to constant values from a textual
 * description of the map.
 *
 * @param definitions A list of overriding definitions for defines in
 *     the form <name>[=<val>], where <val> is a number, boolean, or
 *     single-quoted string without single quotes.
 */"
"@VisibleForTesting
static void createDefineOrTweakReplacements(List<String> definitions, CompilerOptions options, boolean tweaks) {
    // Parse the definitions
    for (String override : definitions) {
        String[] assignment = override.split(""="", 2);
        String defName = assignment[0];
        if (defName.length() > 0) {
            String defValue = assignment.length == 1 ? ""true"" : assignment[1];
            boolean isTrue = defValue.equals(""true"");
            boolean isFalse = defValue.equals(""false"");
            if (isTrue || isFalse) {
                if (tweaks) {
                    options.setTweakToBooleanLiteral(defName, isTrue);
                } else {
                    options.setDefineToBooleanLiteral(defName, isTrue);
                }
                continue;
            } else if (defValue.length() > 1 && ((defValue.charAt(0) == '\'' && defValue.charAt(defValue.length() - 1) == '\'') || (defValue.charAt(0) == '\""' && defValue.charAt(defValue.length() - 1) == '\""'))) {
                // If the value starts and ends with a single quote,
                // we assume that it's a string.
                String maybeStringVal = defValue.substring(1, defValue.length() - 1);
                if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) {
                    if (tweaks) {
                        options.setTweakToStringLiteral(defName, maybeStringVal);
                    } else {
                        options.setDefineToStringLiteral(defName, maybeStringVal);
                    }
                    continue;
                }
            } else {
                try {
                    double value = Double.parseDouble(defValue);
                    if (tweaks) {
                        options.setTweakToDoubleLiteral(defName, value);
                    } else {
                        options.setDefineToDoubleLiteral(defName, value);
                    }
                    continue;
                } catch (NumberFormatException e) {
                    // do nothing, it will be caught at the end
                }
            }
        }
        if (tweaks) {
            throw new RuntimeException(""--tweak flag syntax invalid: "" + override);
        }
        throw new RuntimeException(""--define flag syntax invalid: "" + override);
    }
}","public void test3232() throws Throwable {
    String[] stringArray0 = new String[0];
    List<String> list0 = ResourceBundle.Control.FORMAT_DEFAULT;
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0);
    CompilerOptions compilerOptions0 = commandLineRunner0.createOptions();
    AbstractCommandLineRunner.createDefineOrTweakReplacements(list0, compilerOptions0, true);
    assertFalse(compilerOptions0.gatherCssNames);
}","/**
 * Create a map of constant names to constant values from a textual
 * description of the map.
 *
 * @param definitions A list of overriding definitions for defines in
 *     the form <name>[=<val>], where <val> is a number, boolean, or
 *     single-quoted string without single quotes.
 */"
"@VisibleForTesting
static void createDefineOrTweakReplacements(List<String> definitions, CompilerOptions options, boolean tweaks) {
    // Parse the definitions
    for (String override : definitions) {
        String[] assignment = override.split(""="", 2);
        String defName = assignment[0];
        if (defName.length() > 0) {
            String defValue = assignment.length == 1 ? ""true"" : assignment[1];
            boolean isTrue = defValue.equals(""true"");
            boolean isFalse = defValue.equals(""false"");
            if (isTrue || isFalse) {
                if (tweaks) {
                    options.setTweakToBooleanLiteral(defName, isTrue);
                } else {
                    options.setDefineToBooleanLiteral(defName, isTrue);
                }
                continue;
            } else if (defValue.length() > 1 && ((defValue.charAt(0) == '\'' && defValue.charAt(defValue.length() - 1) == '\'') || (defValue.charAt(0) == '\""' && defValue.charAt(defValue.length() - 1) == '\""'))) {
                // If the value starts and ends with a single quote,
                // we assume that it's a string.
                String maybeStringVal = defValue.substring(1, defValue.length() - 1);
                if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) {
                    if (tweaks) {
                        options.setTweakToStringLiteral(defName, maybeStringVal);
                    } else {
                        options.setDefineToStringLiteral(defName, maybeStringVal);
                    }
                    continue;
                }
            } else {
                try {
                    double value = Double.parseDouble(defValue);
                    if (tweaks) {
                        options.setTweakToDoubleLiteral(defName, value);
                    } else {
                        options.setDefineToDoubleLiteral(defName, value);
                    }
                    continue;
                } catch (NumberFormatException e) {
                    // do nothing, it will be caught at the end
                }
            }
        }
        if (tweaks) {
            throw new RuntimeException(""--tweak flag syntax invalid: "" + override);
        }
        throw new RuntimeException(""--define flag syntax invalid: "" + override);
    }
}","public void test3333() throws Throwable {
    List<String> list0 = ResourceBundle.Control.FORMAT_DEFAULT;
    CompilerOptions compilerOptions0 = new CompilerOptions();
    AbstractCommandLineRunner.createDefineOrTweakReplacements(list0, compilerOptions0, false);
    assertFalse(compilerOptions0.checkCaja);
}","/**
 * Create a map of constant names to constant values from a textual
 * description of the map.
 *
 * @param definitions A list of overriding definitions for defines in
 *     the form <name>[=<val>], where <val> is a number, boolean, or
 *     single-quoted string without single quotes.
 */"
"@VisibleForTesting
static void createDefineOrTweakReplacements(List<String> definitions, CompilerOptions options, boolean tweaks) {
    // Parse the definitions
    for (String override : definitions) {
        String[] assignment = override.split(""="", 2);
        String defName = assignment[0];
        if (defName.length() > 0) {
            String defValue = assignment.length == 1 ? ""true"" : assignment[1];
            boolean isTrue = defValue.equals(""true"");
            boolean isFalse = defValue.equals(""false"");
            if (isTrue || isFalse) {
                if (tweaks) {
                    options.setTweakToBooleanLiteral(defName, isTrue);
                } else {
                    options.setDefineToBooleanLiteral(defName, isTrue);
                }
                continue;
            } else if (defValue.length() > 1 && ((defValue.charAt(0) == '\'' && defValue.charAt(defValue.length() - 1) == '\'') || (defValue.charAt(0) == '\""' && defValue.charAt(defValue.length() - 1) == '\""'))) {
                // If the value starts and ends with a single quote,
                // we assume that it's a string.
                String maybeStringVal = defValue.substring(1, defValue.length() - 1);
                if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) {
                    if (tweaks) {
                        options.setTweakToStringLiteral(defName, maybeStringVal);
                    } else {
                        options.setDefineToStringLiteral(defName, maybeStringVal);
                    }
                    continue;
                }
            } else {
                try {
                    double value = Double.parseDouble(defValue);
                    if (tweaks) {
                        options.setTweakToDoubleLiteral(defName, value);
                    } else {
                        options.setDefineToDoubleLiteral(defName, value);
                    }
                    continue;
                } catch (NumberFormatException e) {
                    // do nothing, it will be caught at the end
                }
            }
        }
        if (tweaks) {
            throw new RuntimeException(""--tweak flag syntax invalid: "" + override);
        }
        throw new RuntimeException(""--define flag syntax invalid: "" + override);
    }
}","public void test3434() throws Throwable {
    ArrayList<String> arrayList0 = new ArrayList<String>();
    arrayList0.add(""Z:c_lk|)="");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    // Undeclared exception!
    try {
        AbstractCommandLineRunner.createDefineOrTweakReplacements(arrayList0, compilerOptions0, false);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // --define flag syntax invalid: Z:c_lk|)=
        //
        verifyException(""com.google.javascript.jscomp.AbstractCommandLineRunner"", e);
    }
}","/**
 * Create a map of constant names to constant values from a textual
 * description of the map.
 *
 * @param definitions A list of overriding definitions for defines in
 *     the form <name>[=<val>], where <val> is a number, boolean, or
 *     single-quoted string without single quotes.
 */"
"public boolean shouldRunCompiler() {
    return this.isConfigValid;
}","public void test3535() throws Throwable {
    JSModule jSModule0 = new JSModule(""Xh7KqF;c[:N"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(""Xh7KqF;c[:N"");
    String[] stringArray0 = new String[1];
    stringArray0[0] = ""Xh7KqF;c[:N"";
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0, mockPrintStream0, mockPrintStream0);
    JSModule jSModule1 = new JSModule(""?RJ]oX"");
    JSModule[] jSModuleArray0 = new JSModule[5];
    jSModuleArray0[0] = jSModule1;
    jSModuleArray0[1] = jSModule0;
    jSModuleArray0[2] = jSModule1;
    jSModuleArray0[3] = jSModule0;
    jSModuleArray0[4] = jSModule1;
    JSModuleGraph jSModuleGraph0 = new JSModuleGraph(jSModuleArray0);
    commandLineRunner0.printModuleGraphManifestTo(jSModuleGraph0, mockPrintStream0);
    assertFalse(commandLineRunner0.shouldRunCompiler());
}","/**
 * @return Whether the configuration is valid.
 */"
"public boolean shouldRunCompiler() {
    return this.isConfigValid;
}","public void test3636() throws Throwable {
    String[] stringArray0 = new String[0];
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0);
    MockPrintStream mockPrintStream0 = new MockPrintStream(""8N<21uc"");
    JSModule jSModule0 = new JSModule(""8N<21uc"");
    JSModule[] jSModuleArray0 = new JSModule[3];
    jSModuleArray0[0] = jSModule0;
    jSModuleArray0[1] = jSModule0;
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""8N<21uc"");
    jSModule0.addFirst(jSSourceFile0);
    jSModuleArray0[2] = jSModule0;
    JSModuleGraph jSModuleGraph0 = new JSModuleGraph(jSModuleArray0);
    commandLineRunner0.printModuleGraphManifestTo(jSModuleGraph0, mockPrintStream0);
    assertTrue(commandLineRunner0.shouldRunCompiler());
}","/**
 * @return Whether the configuration is valid.
 */"
