focal_method,test_prefix,docstring
"public boolean isAllType() {
    return false;
}","public void test000() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    assertFalse(nullType0.isAllType());
}",""
"public final boolean isEmptyType() {
    return isNoType() || isNoObjectType();
}","public void test001() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    assertFalse(nullType0.isEmptyType());
}",""
"public boolean isRecordType() {
    return false;
}","public void test002() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    assertFalse(nullType0.isRecordType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test003() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    nullType0.getTypesUnderShallowEquality(nullType0);
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test014() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    LinkedHashSet<JSType> linkedHashSet0 = new LinkedHashSet<JSType>();
    UnionType unionType0 = new UnionType(jSTypeRegistry0, linkedHashSet0);
    boolean boolean0 = unionType0.isResolved();
    assertFalse(boolean0);
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isStringValueType() {
    return false;
}","public void test025() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    UnknownType unknownType0 = new UnknownType(jSTypeRegistry0, true);
    boolean boolean0 = unknownType0.isStringValueType();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test026() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    UnknownType unknownType0 = new UnknownType(jSTypeRegistry0, true);
    boolean boolean0 = unknownType0.isStringValueType();
    assertFalse(unknownType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isBooleanObjectType() {
    return false;
}","public void test037() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.isBooleanObjectType();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test038() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.isBooleanObjectType();
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test049() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    nullType0.getJSDocInfo();
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test0510() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    String string0 = nullType0.toDebugHashCodeString();
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public String toDebugHashCodeString() {
    return ""{"" + this.hashCode() + ""}"";
}","public void test0511() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    String string0 = nullType0.toDebugHashCodeString();
    assertEquals(""{1}"", string0);
}","/**
 * A hash code function for diagnosing complicated issues
 * around type-identity.
 */"
"public boolean isRegexpType() {
    return false;
}","public void test0612() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.isRegexpType();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test0613() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.isRegexpType();
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isString() {
    return this.isSubtype(getNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE));
}","public void test0714() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    // Undeclared exception!
    try {
        nullType0.isString();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Tests whether the type is a string (value or Object).
 * @return {@code this &lt;: (String, string)}
 */"
"public boolean isDateType() {
    return false;
}","public void test0815() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.isDateType();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test0816() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.isDateType();
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test0917() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(noObjectType0);
    assertTrue(noObjectType0.hasCachedValues());
}",""
"public boolean isVoidType() {
    return false;
}","public void test0918() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(noObjectType0);
    jSType0.getTypesUnderEquality(noObjectType0);
    assertFalse(noObjectType0.isVoidType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test1019() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.isStringObjectType();
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isStringObjectType() {
    return false;
}","public void test1020() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.isStringObjectType();
    assertFalse(boolean0);
}",""
"@Override
public boolean matchesObjectContext() {
    return primitiveType.matchesObjectContext();
}","public void test1121() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""IjEkeL]}N]vpO"");
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, arrowType0, ""Named type with empty name component"");
    boolean boolean0 = enumElementType0.matchesObjectContext();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test1122() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""IjEkeL]}N]vpO"");
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, arrowType0, ""Named type with empty name component"");
    boolean boolean0 = enumElementType0.matchesObjectContext();
    assertFalse(enumElementType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNumberObjectType() {
    return false;
}","public void test1223() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.isNumberObjectType();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test1224() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.isNumberObjectType();
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean matchesStringContext() {
    return false;
}","public void test1325() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""R-l|d*+"");
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    boolean boolean0 = arrowType0.matchesStringContext();
    assertFalse(boolean0);
}","/**
 * This predicate is used to test whether a given type can appear in a
 * {@code String} context, such as an operand of a string concat (+) operator.
 *
 * All types have at least the potential for converting to {@code String}.
 * When we add externally defined types, such as a browser OM, we may choose
 * to add types that do not automatically convert to {@code String}.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test1326() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""R-l|d*+"");
    ArrowType arrowType0 = errorFunctionType0.getInternalArrowType();
    boolean boolean0 = arrowType0.matchesStringContext();
    assertFalse(arrowType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test1427() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    nullType0.unboxesTo();
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean hasCachedValues() {
    return !unknown;
}","public void test1528() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    EnumElementType enumElementType0 = new EnumElementType((JSTypeRegistry) null, nullType0, ""Unknown class name"");
    boolean boolean0 = nullType0.canTestForEqualityWith(enumElementType0);
    assertTrue(enumElementType0.hasCachedValues());
}","/**
 * Returns true if any cached valeus have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"public final boolean canTestForEqualityWith(JSType that) {
    return this.testForEquality(that).equals(UNKNOWN);
}","public void test1529() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    EnumElementType enumElementType0 = new EnumElementType((JSTypeRegistry) null, nullType0, ""Unknown class name"");
    boolean boolean0 = nullType0.canTestForEqualityWith(enumElementType0);
    assertTrue(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable. By meaningfully, we mean compatible types that do not lead
 * to step 22 of the definition of the Abstract Equality Comparison
 * Algorithm (11.9.3, page 55&ndash;56) of the ECMA-262 specification.<p>
 */"
"@Override
public boolean isConstructor() {
    return referencedType.isConstructor();
}","public void test1630() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""@kM3iq[dpI1#d`9~5"");
    boolean boolean0 = templateType0.isConstructor();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test1631() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, ""@kM3iq[dpI1#d`9~5"");
    boolean boolean0 = templateType0.isConstructor();
    assertFalse(templateType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isArrayType() {
    return false;
}","public void test1732() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.isArrayType();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test1733() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.isArrayType();
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isBooleanValueType() {
    return false;
}","public void test1834() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.isBooleanValueType();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test1835() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.isBooleanValueType();
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean canBeCalled() {
    return false;
}","public void test1936() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.canBeCalled();
    assertFalse(boolean0);
}","/**
 * This predicate is used to test whether a given type can be used as the
 * 'function' in a function call.
 *
 * @return {@code true} if this type might be callable.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test1937() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.canBeCalled();
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isNumber() {
    return this.isSubtype(getNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE));
}","public void test2038() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    // Undeclared exception!
    try {
        nullType0.isNumber();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Tests whether the type is a number (value or Object).
 * @return {@code this &lt;: (Number, number)}
 */"
"public boolean isTemplateType() {
    return false;
}","public void test2139() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    boolean boolean0 = errorFunctionType0.isTemplateType();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test2140() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    boolean boolean0 = errorFunctionType0.isTemplateType();
    assertFalse(errorFunctionType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
public boolean isOrdinaryFunction() {
    return referencedType.isOrdinaryFunction();
}","public void test2241() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, """");
    boolean boolean0 = templateType0.isOrdinaryFunction();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test2242() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, """");
    boolean boolean0 = templateType0.isOrdinaryFunction();
    assertFalse(templateType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test2343() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    JSType jSType0 = jSTypeRegistry0.createOptionalNullableType(nullType0);
    JSType jSType1 = errorFunctionType0.getGreatestSubtype(jSType0);
    nullType0.getTypesUnderEquality(jSType1);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public final boolean isEmptyType() {
    return isNoType() || isNoObjectType();
}","public void test2344() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    JSType jSType0 = jSTypeRegistry0.createOptionalNullableType(nullType0);
    JSType jSType1 = errorFunctionType0.getGreatestSubtype(jSType0);
    nullType0.getTypesUnderEquality(jSType1);
    assertTrue(jSType1.isEmptyType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test2445() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    boolean boolean0 = nullType0.isNamedType();
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"boolean isNamedType() {
    return false;
}","public void test2446() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    boolean boolean0 = nullType0.isNamedType();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test2547() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    ObjectType objectType0 = numberType0.dereference();
    assertFalse(objectType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final ObjectType dereference() {
    JSType restricted = restrictByNotNullOrUndefined();
    JSType autobox = restricted.autoboxesTo();
    return ObjectType.cast(autobox == null ? restricted : autobox);
}","public void test2548() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    ObjectType objectType0 = numberType0.dereference();
    assertNotNull(objectType0);
}","/**
 * Dereference a type for property access.
 *
 * Autoboxes the type, filters null/undefined, and returns the result
 * iff it's an object.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test2649() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    nullType0.matchesInt32Context();
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
public boolean isInterface() {
    return referencedType.isInterface();
}","public void test2750() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Unknown class name"", ""Unknown class name"", (-523), (-523));
    boolean boolean0 = namedType0.isInterface();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test2751() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Unknown class name"", ""Unknown class name"", (-523), (-523));
    boolean boolean0 = namedType0.isInterface();
    assertFalse(namedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test2852() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.isInstanceType();
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isInstanceType() {
    return false;
}","public void test2853() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.isInstanceType();
    assertFalse(boolean0);
}","/**
 * Whether this type is an Instance object of some constructor.
 */"
"public final boolean isEmptyType() {
    return isNoType() || isNoObjectType();
}","public void test2954() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    ProxyObjectType proxyObjectType0 = new ProxyObjectType(jSTypeRegistry0, noType0);
    boolean boolean0 = proxyObjectType0.isCheckedUnknownType();
    assertTrue(noType0.isEmptyType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test2955() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    ProxyObjectType proxyObjectType0 = new ProxyObjectType(jSTypeRegistry0, noType0);
    boolean boolean0 = proxyObjectType0.isCheckedUnknownType();
    assertFalse(proxyObjectType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
public boolean isCheckedUnknownType() {
    return referencedType.isCheckedUnknownType();
}","public void test2956() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    ProxyObjectType proxyObjectType0 = new ProxyObjectType(jSTypeRegistry0, noType0);
    boolean boolean0 = proxyObjectType0.isCheckedUnknownType();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test3057() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test3058() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    nullType0.forceResolve(simpleErrorReporter0, (StaticScope<JSType>) null);
    assertTrue(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"boolean isTheObjectType() {
    return false;
}","public void test3159() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.isTheObjectType();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test3160() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.isTheObjectType();
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isFunctionType() {
    return false;
}","public void test3261() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    ObjectType objectType0 = errorFunctionType0.getTypeOfThis();
    assertFalse(objectType0.isFunctionType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test3262() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    ObjectType objectType0 = errorFunctionType0.getTypeOfThis();
    JSType jSType0 = objectType0.getGreatestSubtype(errorFunctionType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isEmptyType() {
    return isNoType() || isNoObjectType();
}","public void test3263() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    ObjectType objectType0 = errorFunctionType0.getTypeOfThis();
    JSType jSType0 = objectType0.getGreatestSubtype(errorFunctionType0);
    assertTrue(jSType0.isEmptyType());
}",""
"public boolean isNominalType() {
    return false;
}","public void test3264() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    ObjectType objectType0 = errorFunctionType0.getTypeOfThis();
    JSType jSType0 = objectType0.getGreatestSubtype(errorFunctionType0);
    assertFalse(errorFunctionType0.isNominalType());
}","/**
 * Whether this type is a nominal type (a named instance object or
 * a named enum).
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test3365() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    nullType0.matchesUint32Context();
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean matchesNumberContext() {
    return false;
}","public void test3466() throws Throwable {
    AllType allType0 = new AllType((JSTypeRegistry) null);
    boolean boolean0 = allType0.matchesNumberContext();
    assertFalse(boolean0);
}","/**
 * This predicate is used to test whether a given type can appear in a
 * numeric context, such as an operand of a multiply operator.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test3467() throws Throwable {
    AllType allType0 = new AllType((JSTypeRegistry) null);
    boolean boolean0 = allType0.matchesNumberContext();
    assertFalse(allType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test3568() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, "">A^X:rb@:"");
    boolean boolean0 = templateType0.isEnumType();
    assertFalse(templateType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
public boolean isEnumType() {
    return referencedType.isEnumType();
}","public void test3569() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TemplateType templateType0 = new TemplateType(jSTypeRegistry0, "">A^X:rb@:"");
    boolean boolean0 = templateType0.isEnumType();
    assertFalse(boolean0);
}",""
"public boolean isNumberValueType() {
    return false;
}","public void test3670() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.isNumberValueType();
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test3671() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.isNumberValueType();
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test3772() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    nullType0.forgiveUnknownNames();
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test3873() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    nullType0.clearResolved();
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test3974() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    ParameterizedType parameterizedType0 = jSTypeRegistry0.createParameterizedType(noType0, noType0);
    boolean boolean0 = parameterizedType0.isFunctionPrototypeType();
    assertFalse(parameterizedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
public boolean isFunctionPrototypeType() {
    return referencedType.isFunctionPrototypeType();
}","public void test3975() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    ParameterizedType parameterizedType0 = jSTypeRegistry0.createParameterizedType(noType0, noType0);
    boolean boolean0 = parameterizedType0.isFunctionPrototypeType();
    assertFalse(boolean0);
}",""
"public final boolean isEmptyType() {
    return isNoType() || isNoObjectType();
}","public void test3976() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    ParameterizedType parameterizedType0 = jSTypeRegistry0.createParameterizedType(noType0, noType0);
    boolean boolean0 = parameterizedType0.isFunctionPrototypeType();
    assertTrue(noType0.isEmptyType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test4077() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(nullType0);
    ((UnionType) jSType0).toString();
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public static boolean isEquivalent(JSType typeA, JSType typeB) {
    return (typeA == null || typeB == null) ? typeA == typeB : typeA.isEquivalentTo(typeB);
}","public void test4178() throws Throwable {
    boolean boolean0 = JSType.isEquivalent((JSType) null, (JSType) null);
    assertTrue(boolean0);
}",""
"public static boolean isEquivalent(JSType typeA, JSType typeB) {
    return (typeA == null || typeB == null) ? typeA == typeB : typeA.isEquivalentTo(typeB);
}","public void test4279() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = JSType.isEquivalent(nullType0, (JSType) null);
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test4280() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = JSType.isEquivalent(nullType0, (JSType) null);
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test4381() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    JSType.isEquivalent(nullType0, nullType0);
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
public boolean equals(Object jsType) {
    return (jsType instanceof JSType) ? isEquivalentTo((JSType) jsType) : false;
}","public void test4482() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.equals((Object) null);
    assertFalse(boolean0);
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test4483() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.equals((Object) null);
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test4584() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    NumberType numberType0 = new NumberType((JSTypeRegistry) null);
    nullType0.equals(numberType0);
    assertFalse(numberType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test4585() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    NumberType numberType0 = new NumberType((JSTypeRegistry) null);
    nullType0.equals(numberType0);
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test4686() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    nullType0.findPropertyType(""Not declared as a type name"");
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test4787() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    StringType stringType0 = new StringType(jSTypeRegistry0);
    stringType0.findPropertyType(""TYPE_ERROR_FUNCTION_TYPE"");
    assertFalse(stringType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean canAssignTo(JSType that) {
    if (this.isSubtype(that)) {
        return true;
    }
    return false;
}","public void test4888() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    StringType stringType0 = new StringType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.canAssignTo(stringType0);
    assertFalse(boolean0);
}","/**
 * Tests whether values of {@code this} type can be safely assigned
 * to values of {@code that} type.<p>
 *
 * The default implementation verifies that {@code this} is a subtype
 * of {@code that}.<p>
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test4889() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    StringType stringType0 = new StringType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.canAssignTo(stringType0);
    assertFalse(stringType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean canAssignTo(JSType that) {
    if (this.isSubtype(that)) {
        return true;
    }
    return false;
}","public void test4990() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.canAssignTo(nullType0);
    assertTrue(boolean0);
}","/**
 * Tests whether values of {@code this} type can be safely assigned
 * to values of {@code that} type.<p>
 *
 * The default implementation verifies that {@code this} is a subtype
 * of {@code that}.<p>
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test4991() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.canAssignTo(nullType0);
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isEmptyType() {
    return isNoType() || isNoObjectType();
}","public void test5092() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    ObjectType objectType0 = nullType0.dereference();
    assertTrue(objectType0.isEmptyType());
}",""
"public final ObjectType dereference() {
    JSType restricted = restrictByNotNullOrUndefined();
    JSType autobox = restricted.autoboxesTo();
    return ObjectType.cast(autobox == null ? restricted : autobox);
}","public void test5093() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    ObjectType objectType0 = nullType0.dereference();
    assertNotNull(objectType0);
}","/**
 * Dereference a type for property access.
 *
 * Autoboxes the type, filters null/undefined, and returns the result
 * iff it's an object.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test5094() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    ObjectType objectType0 = nullType0.dereference();
    assertFalse(objectType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test5195() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    AllType allType0 = new AllType((JSTypeRegistry) null);
    nullType0.getTypesUnderEquality(allType0);
    assertFalse(allType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test5196() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    AllType allType0 = new AllType((JSTypeRegistry) null);
    nullType0.getTypesUnderEquality(allType0);
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test5297() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    UnknownType unknownType0 = new UnknownType((JSTypeRegistry) null, false);
    nullType0.getTypesUnderInequality(unknownType0);
    assertFalse(unknownType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test5298() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    UnknownType unknownType0 = new UnknownType((JSTypeRegistry) null, false);
    nullType0.getTypesUnderInequality(unknownType0);
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test5399() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(numberType0);
    numberType0.testForEquality(jSType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test53100() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(numberType0);
    numberType0.testForEquality(jSType0);
    assertFalse(numberType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test54101() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(voidType0);
    voidType0.testForEquality(jSType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test54102() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(voidType0);
    voidType0.testForEquality(jSType0);
    assertFalse(voidType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test55103() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    AllType allType0 = new AllType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.canTestForShallowEqualityWith(allType0);
    assertFalse(allType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean canTestForShallowEqualityWith(JSType that) {
    return this.isSubtype(that) || that.isSubtype(this);
}","public void test55104() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    AllType allType0 = new AllType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.canTestForShallowEqualityWith(allType0);
    assertTrue(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable using shallow comparison. By meaningfully, we mean compatible
 * types that are not rejected by step 1 of the definition of the Strict
 * Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the
 * ECMA-262 specification.<p>
 */"
"public boolean hasCachedValues() {
    return !unknown;
}","public void test56105() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    EnumElementType enumElementType0 = new EnumElementType((JSTypeRegistry) null, nullType0, ""Named type with empty name component"");
    boolean boolean0 = nullType0.canTestForShallowEqualityWith(enumElementType0);
    assertTrue(enumElementType0.hasCachedValues());
}","/**
 * Returns true if any cached valeus have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"public final boolean canTestForShallowEqualityWith(JSType that) {
    return this.isSubtype(that) || that.isSubtype(this);
}","public void test56106() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    EnumElementType enumElementType0 = new EnumElementType((JSTypeRegistry) null, nullType0, ""Named type with empty name component"");
    boolean boolean0 = nullType0.canTestForShallowEqualityWith(enumElementType0);
    assertTrue(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable using shallow comparison. By meaningfully, we mean compatible
 * types that are not rejected by step 1 of the definition of the Strict
 * Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the
 * ECMA-262 specification.<p>
 */"
"public final boolean canTestForShallowEqualityWith(JSType that) {
    return this.isSubtype(that) || that.isSubtype(this);
}","public void test57107() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    NullType nullType1 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType1.canTestForShallowEqualityWith(nullType0);
    assertFalse(boolean0);
}","/**
 * Tests whether {@code this} and {@code that} are meaningfully
 * comparable using shallow comparison. By meaningfully, we mean compatible
 * types that are not rejected by step 1 of the definition of the Strict
 * Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the
 * ECMA-262 specification.<p>
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test57108() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    NullType nullType1 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType1.canTestForShallowEqualityWith(nullType0);
    assertFalse(nullType1.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test58109() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    AllType allType0 = new AllType((JSTypeRegistry) null);
    JSType jSType0 = nullType0.getLeastSupertype(allType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public JSType getLeastSupertype(JSType that) {
    if (that.isUnionType()) {
        // Union types have their own implementation of getLeastSupertype.
        return that.getLeastSupertype(this);
    }
    return getLeastSupertype(this, that);
}","public void test59110() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    LinkedHashSet<JSType> linkedHashSet0 = new LinkedHashSet<JSType>();
    UnionType unionType0 = new UnionType((JSTypeRegistry) null, linkedHashSet0);
    // Undeclared exception!
    try {
        nullType0.getLeastSupertype(unionType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.jstype.JSType"", e);
    }
}","/**
 * Gets the least supertype of {@code this} and {@code that}.
 * The least supertype is the join (&#8744;) or supremum of both types in the
 * type lattice.<p>
 * Examples:
 * <ul>
 * <li>{@code number &#8744; *} = {@code *}</li>
 * <li>{@code number &#8744; Object} = {@code (number, Object)}</li>
 * <li>{@code Number &#8744; Object} = {@code Object}</li>
 * </ul>
 * @return {@code this &#8744; that}
 */"
"static JSType getLeastSupertype(JSType thisType, JSType thatType) {
    if (thatType.isEmptyType() || thatType.isAllType()) {
        // Defer to the implementations of the end lattice elements when
        // possible.
        return thatType.getLeastSupertype(thisType);
    }
    return thisType.registry.createUnionType(thisType, thatType);
}","public void test60111() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    JSType jSType0 = JSType.getLeastSupertype((JSType) noType0, (JSType) noType0);
    assertSame(jSType0, noType0);
}","/**
 * A generic implementation meant to be used as a helper for common
 * getLeastSupertype implementations.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test60112() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    JSType jSType0 = JSType.getLeastSupertype((JSType) noType0, (JSType) noType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test61113() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    StringType stringType0 = new StringType(jSTypeRegistry0);
    HashMap<String, JSType> hashMap0 = new HashMap<String, JSType>();
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    JSType jSType0 = stringType0.getGreatestSubtype(recordType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isEmptyType() {
    return isNoType() || isNoObjectType();
}","public void test61114() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    StringType stringType0 = new StringType(jSTypeRegistry0);
    HashMap<String, JSType> hashMap0 = new HashMap<String, JSType>();
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    JSType jSType0 = stringType0.getGreatestSubtype(recordType0);
    assertTrue(jSType0.isEmptyType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test62115() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null, true);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    JSType jSType0 = JSType.getGreatestSubtype((JSType) noObjectType0, (JSType) noObjectType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isEmptyType() {
    return isNoType() || isNoObjectType();
}","public void test62116() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null, true);
    NoObjectType noObjectType0 = new NoObjectType(jSTypeRegistry0);
    JSType jSType0 = JSType.getGreatestSubtype((JSType) noObjectType0, (JSType) noObjectType0);
    assertTrue(jSType0.isEmptyType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test63117() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    AllType allType0 = new AllType(jSTypeRegistry0);
    JSType jSType0 = JSType.getGreatestSubtype((JSType) allType0, (JSType) allType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
public String getReferenceName() {
    return isChecked ? ""??"" : ""?"";
}","public void test64118() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    UnknownType unknownType0 = new UnknownType(jSTypeRegistry0, true);
    UnknownType unknownType1 = (UnknownType) JSType.getGreatestSubtype((JSType) unknownType0, (JSType) unknownType0);
    assertEquals(""??"", unknownType1.getReferenceName());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test64119() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    UnknownType unknownType0 = new UnknownType(jSTypeRegistry0, true);
    UnknownType unknownType1 = (UnknownType) JSType.getGreatestSubtype((JSType) unknownType0, (JSType) unknownType0);
    assertFalse(unknownType1.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test65120() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Unknown class name"", ""Named type with empty name component"", 1, 0);
    JSType jSType0 = nullType0.getGreatestSubtype(namedType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean hasCachedValues() {
    return !unknown;
}","public void test66121() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    EnumElementType enumElementType0 = new EnumElementType((JSTypeRegistry) null, nullType0, ""Unknown class name"");
    nullType0.getGreatestSubtype(enumElementType0);
    assertTrue(enumElementType0.hasCachedValues());
}","/**
 * Returns true if any cached valeus have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test66122() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    EnumElementType enumElementType0 = new EnumElementType((JSTypeRegistry) null, nullType0, ""Unknown class name"");
    nullType0.getGreatestSubtype(enumElementType0);
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isEmptyType() {
    return isNoType() || isNoObjectType();
}","public void test67123() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(nullType0);
    Node node0 = Node.newString(1, ""Not declared as a type name"", 0, 2);
    ArrowType arrowType0 = new ArrowType(jSTypeRegistry0, node0, nullType0, false);
    JSType jSType1 = JSType.getGreatestSubtype(jSType0, (JSType) arrowType0);
    assertTrue(jSType1.isEmptyType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test67124() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(nullType0);
    Node node0 = Node.newString(1, ""Not declared as a type name"", 0, 2);
    ArrowType arrowType0 = new ArrowType(jSTypeRegistry0, node0, nullType0, false);
    JSType jSType1 = JSType.getGreatestSubtype(jSType0, (JSType) arrowType0);
    assertFalse(jSType1.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public JSType getGreatestSubtype(JSType that) {
    if (that.isRecordType()) {
        // Record types have their own implementation of getGreatestSubtype.
        return that.getGreatestSubtype(this);
    }
    return getGreatestSubtype(this, that);
}","public void test68125() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    NullType nullType1 = new NullType((JSTypeRegistry) null);
    // Undeclared exception!
    try {
        nullType1.getGreatestSubtype(nullType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Gets the greatest subtype of {@code this} and {@code that}.
 * The greatest subtype is the meet (&#8743;) or infimum of both types in the
 * type lattice.<p>
 * Examples
 * <ul>
 * <li>{@code Number &#8743; Any} = {@code Any}</li>
 * <li>{@code number &#8743; Object} = {@code Any}</li>
 * <li>{@code Number &#8743; Object} = {@code Number}</li>
 * </ul>
 * @return {@code this &#8744; that}
 */"
"public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) {
    BooleanLiteralSet literals = getPossibleToBooleanOutcomes();
    if (literals.contains(outcome)) {
        return this;
    } else {
        return getNativeType(JSTypeNative.NO_TYPE);
    }
}","public void test69126() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    // Undeclared exception!
    try {
        nullType0.getRestrictedTypeGivenToBooleanOutcome(true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Computes the restricted type of this type knowing that the
 * {@code ToBoolean} predicate has a specific value. For more information
 * about the {@code ToBoolean} predicate, see
 * {@link #getPossibleToBooleanOutcomes}.
 *
 * @param outcome the value of the {@code ToBoolean} predicate
 *
 * @return the restricted type, or the Any Type if the underlying type could
 *         not have yielded this ToBoolean value
 *
 * TODO(user): Move this method to the SemanticRAI and use the visit
 * method of types to get the restricted type.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test70127() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    JSType jSType0 = nullType0.getRestrictedTypeGivenToBooleanOutcome(false);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test71128() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(nullType0);
    nullType0.getTypesUnderEquality(jSType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test71129() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(nullType0);
    nullType0.getTypesUnderEquality(jSType0);
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test72130() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(nullType0);
    nullType0.getTypesUnderInequality(jSType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test72131() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createDefaultObjectUnion(nullType0);
    nullType0.getTypesUnderInequality(jSType0);
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test73132() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    nullType0.getTypesUnderInequality(errorFunctionType0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test74133() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    voidType0.getTypesUnderShallowInequality(voidType0);
    assertFalse(voidType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNullType() {
    return false;
}","public void test74134() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    voidType0.getTypesUnderShallowInequality(voidType0);
    assertFalse(voidType0.isNullType());
}",""
"public boolean isVoidType() {
    return false;
}","public void test75135() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(nullType0);
    nullType0.getTypesUnderShallowInequality(jSType0);
    assertFalse(jSType0.isVoidType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test75136() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(nullType0);
    nullType0.getTypesUnderShallowInequality(jSType0);
    assertFalse(jSType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isNullType() {
    return false;
}","public void test75137() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(nullType0);
    nullType0.getTypesUnderShallowInequality(jSType0);
    assertFalse(jSType0.isNullType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test75138() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(nullType0);
    nullType0.getTypesUnderShallowInequality(jSType0);
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean isVoidType() {
    return false;
}","public void test76139() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    nullType0.getTypesUnderShallowInequality(voidType0);
    assertFalse(nullType0.isVoidType());
}",""
"public boolean isNullType() {
    return false;
}","public void test76140() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    nullType0.getTypesUnderShallowInequality(voidType0);
    assertFalse(voidType0.isNullType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test76141() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    VoidType voidType0 = new VoidType((JSTypeRegistry) null);
    nullType0.getTypesUnderShallowInequality(voidType0);
    assertFalse(voidType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean differsFrom(JSType that) {
    // if there are no unknowns, just use normal equality.
    if (!this.isUnknownType() && !that.isUnknownType()) {
        return !this.isEquivalentTo(that);
    }
    // otherwise, they're different iff one is unknown and the other is not.
    return this.isUnknownType() ^ that.isUnknownType();
}","public void test77142() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Unknown class name"", ""Named type with empty name component"", 1, 0);
    boolean boolean0 = namedType0.differsFrom(nullType0);
    assertTrue(boolean0);
}","/**
 * Whether this type is meaningfully different from {@code that} type.
 * This is a trickier check than pure equality, because it has to properly
 * handle unknown types.
 *
 * @see <a href=""http://www.youtube.com/watch?v=_RpSv3HjpEw"">Unknown
 *     unknowns</a>
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test77143() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Unknown class name"", ""Named type with empty name component"", 1, 0);
    boolean boolean0 = namedType0.differsFrom(nullType0);
    assertFalse(namedType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean differsFrom(JSType that) {
    // if there are no unknowns, just use normal equality.
    if (!this.isUnknownType() && !that.isUnknownType()) {
        return !this.isEquivalentTo(that);
    }
    // otherwise, they're different iff one is unknown and the other is not.
    return this.isUnknownType() ^ that.isUnknownType();
}","public void test78144() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    UnknownType unknownType0 = new UnknownType((JSTypeRegistry) null, true);
    boolean boolean0 = nullType0.differsFrom(unknownType0);
    assertTrue(boolean0);
}","/**
 * Whether this type is meaningfully different from {@code that} type.
 * This is a trickier check than pure equality, because it has to properly
 * handle unknown types.
 *
 * @see <a href=""http://www.youtube.com/watch?v=_RpSv3HjpEw"">Unknown
 *     unknowns</a>
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test78145() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    UnknownType unknownType0 = new UnknownType((JSTypeRegistry) null, true);
    boolean boolean0 = nullType0.differsFrom(unknownType0);
    assertFalse(unknownType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test79146() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.differsFrom(nullType0);
    assertFalse(nullType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean differsFrom(JSType that) {
    // if there are no unknowns, just use normal equality.
    if (!this.isUnknownType() && !that.isUnknownType()) {
        return !this.isEquivalentTo(that);
    }
    // otherwise, they're different iff one is unknown and the other is not.
    return this.isUnknownType() ^ that.isUnknownType();
}","public void test79147() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.differsFrom(nullType0);
    assertFalse(boolean0);
}","/**
 * Whether this type is meaningfully different from {@code that} type.
 * This is a trickier check than pure equality, because it has to properly
 * handle unknown types.
 *
 * @see <a href=""http://www.youtube.com/watch?v=_RpSv3HjpEw"">Unknown
 *     unknowns</a>
 */"
"public boolean differsFrom(JSType that) {
    // if there are no unknowns, just use normal equality.
    if (!this.isUnknownType() && !that.isUnknownType()) {
        return !this.isEquivalentTo(that);
    }
    // otherwise, they're different iff one is unknown and the other is not.
    return this.isUnknownType() ^ that.isUnknownType();
}","public void test80148() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    AllType allType0 = new AllType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.differsFrom(allType0);
    assertTrue(boolean0);
}","/**
 * Whether this type is meaningfully different from {@code that} type.
 * This is a trickier check than pure equality, because it has to properly
 * handle unknown types.
 *
 * @see <a href=""http://www.youtube.com/watch?v=_RpSv3HjpEw"">Unknown
 *     unknowns</a>
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test80149() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    AllType allType0 = new AllType((JSTypeRegistry) null);
    boolean boolean0 = nullType0.differsFrom(allType0);
    assertFalse(allType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"static boolean isSubtype(JSType thisType, JSType thatType) {
    // unknown
    if (thatType.isUnknownType()) {
        return true;
    }
    // equality
    if (thisType.isEquivalentTo(thatType)) {
        return true;
    }
    // all type
    if (thatType.isAllType()) {
        return true;
    }
    // unions
    if (thatType instanceof UnionType) {
        UnionType union = (UnionType) thatType;
        for (JSType element : union.alternates) {
            if (thisType.isSubtype(element)) {
                return true;
            }
        }
    }
    // named types
    if (thatType instanceof NamedType) {
        return thisType.isSubtype(((NamedType) thatType).referencedType);
    }
    return false;
}","public void test81150() throws Throwable {
    UnknownType unknownType0 = new UnknownType((JSTypeRegistry) null, false);
    boolean boolean0 = JSType.isSubtype((JSType) unknownType0, (JSType) unknownType0);
    assertTrue(boolean0);
}","/**
 * A generic implementation meant to be used as a helper for common subtyping
 * cases.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test81151() throws Throwable {
    UnknownType unknownType0 = new UnknownType((JSTypeRegistry) null, false);
    boolean boolean0 = JSType.isSubtype((JSType) unknownType0, (JSType) unknownType0);
    assertFalse(unknownType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public boolean hasCachedValues() {
    return !unknown;
}","public void test82152() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, objectType0, ""Named type with empty name component"");
    objectType0.getTypesUnderEquality(enumElementType0);
    assertTrue(enumElementType0.hasCachedValues());
}","/**
 * Returns true if any cached valeus have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"public boolean hasCachedValues() {
    return !unknown;
}","public void test82153() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
    EnumElementType enumElementType0 = new EnumElementType(jSTypeRegistry0, objectType0, ""Named type with empty name component"");
    objectType0.getTypesUnderEquality(enumElementType0);
    assertTrue(objectType0.hasCachedValues());
}","/**
 * Returns true if any cached valeus have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test83154() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    NullType nullType0 = new NullType(jSTypeRegistry0);
    NamedType namedType0 = new NamedType(jSTypeRegistry0, ""Unknown class name"", ""Named type with empty name component"", 1, 0);
    JSType.TypePair jSType_TypePair0 = namedType0.getTypesUnderEquality(nullType0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""VE{}$JQ=GG44llaSQ=."");
    JSType[] jSTypeArray0 = new JSType[5];
    namedType0.referencedType = (ObjectType) errorFunctionType0;
    jSTypeArray0[4] = (JSType) namedType0;
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType(jSType_TypePair0.typeB, true, jSTypeArray0);
    assertFalse(functionType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test84155() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    assertFalse(errorFunctionType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"public final boolean isResolved() {
    return resolved;
}","public void test84156() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Unknown class name"");
    EmptyScope emptyScope0 = new EmptyScope();
    errorFunctionType0.resolveInternal(simpleErrorReporter0, emptyScope0);
    assertTrue(errorFunctionType0.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"static final JSType safeResolve(JSType type, ErrorReporter t, StaticScope<JSType> scope) {
    return type == null ? null : type.resolve(t, scope);
}","public void test85157() throws Throwable {
    NullType nullType0 = new NullType((JSTypeRegistry) null);
    nullType0.setResolvedTypeInternal((JSType) null);
    EmptyScope emptyScope0 = new EmptyScope();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    // Undeclared exception!
    try {
        JSType.safeResolve(nullType0, simpleErrorReporter0, emptyScope0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.jstype.JSType"", e);
    }
}","/**
 * A null-safe resolve.
 * @see #resolve
 */"
