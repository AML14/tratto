focal_method,test_prefix,docstring
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test000() throws Throwable {
    Node node0 = Node.newString("""");
    Node node1 = new Node(4, node0, node0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"public boolean isVar() {
    return this.getType() == Token.VAR;
}","public void test011() throws Throwable {
    Node node0 = new Node(14);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node1 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertFalse(node1.isVar());
}",""
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test022() throws Throwable {
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node0 = new Node(43, 43, 43);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test033() throws Throwable {
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node0 = Node.newNumber(4.67371955799455);
    Node node1 = new Node(44, node0, node0);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
    assertSame(node2, node1);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test044() throws Throwable {
    Node node0 = new Node(100);
    Node node1 = new Node(98, node0, node0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test055() throws Throwable {
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node0 = new Node(113);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test066() throws Throwable {
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node0 = new Node(114);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test077() throws Throwable {
    Node node0 = new Node(115);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // malformed 'for' statement FOR
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test088() throws Throwable {
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node0 = new Node(130);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test099() throws Throwable {
    Node node0 = new Node(4);
    Node node1 = new Node(4095, node0, node0);
    Compiler compiler0 = new Compiler();
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    peepholeSubstituteAlternateSyntax0.beginTraversal(compiler0);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertNull(node2);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1010() throws Throwable {
    Node node0 = Node.newNumber(65.25581514511606);
    Node node1 = new Node(30, node0, node0);
    Compiler compiler0 = new Compiler();
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    peepholeSubstituteAlternateSyntax0.beginTraversal(compiler0);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
    assertEquals(50, Node.FREE_CALL);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1111() throws Throwable {
    Node node0 = new Node(106);
    Node node1 = new Node(115, node0, node0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // malformed 'for' statement FOR
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1212() throws Throwable {
    Node node0 = new Node(106);
    Node node1 = new Node(115, node0, node0);
    node1.replaceChild(node0, node1);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // malformed 'for' statement FOR
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1313() throws Throwable {
    Node node0 = new Node(37, 37, 37);
    Compiler compiler0 = new Compiler();
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    peepholeSubstituteAlternateSyntax0.beginTraversal(compiler0);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"public int getType() {
    return type;
}","public void test1414() throws Throwable {
    Node node0 = new Node((-913));
    Node node1 = new Node(37, node0, node0);
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
    compiler0.initOptions(compilerOptions0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    peepholeSubstituteAlternateSyntax0.beginTraversal(compiler0);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
    assertEquals(37, node2.getType());
}",""
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1515() throws Throwable {
    Node node0 = new Node(85);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node1 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertSame(node0, node1);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1616() throws Throwable {
    Node node0 = new Node(85);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node1 = new Node(41, node0, node0, node0, node0, 1, 30);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertNotNull(node2);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"public int getLineno() {
    return extractLineno(sourcePosition);
}","public void test1617() throws Throwable {
    Node node0 = new Node(85);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node1 = new Node(41, node0, node0, node0, node0, 1, 30);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertEquals((-1), node2.getLineno());
}",""
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1718() throws Throwable {
    Node node0 = new Node(125, 125, 125);
    Node node1 = new Node(125, node0, node0, node0, 38, 30);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
    assertEquals(35, Node.PARENTHESIZED_PROP);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"public boolean isFalse() {
    return this.getType() == Token.FALSE;
}","public void test1819() throws Throwable {
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Compiler compiler0 = new Compiler();
    peepholeSubstituteAlternateSyntax0.beginTraversal(compiler0);
    Node node0 = new Node(38);
    Node node1 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertFalse(node1.isFalse());
}",""
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test1920() throws Throwable {
    Compiler compiler0 = new Compiler();
    AbstractCompiler.LifeCycleStage abstractCompiler_LifeCycleStage0 = AbstractCompiler.LifeCycleStage.NORMALIZED;
    compiler0.setLifeCycleStage(abstractCompiler_LifeCycleStage0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    peepholeSubstituteAlternateSyntax0.beginTraversal(compiler0);
    Node node0 = Node.newString(38, ""NT4"", 38, 38);
    Node node1 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertEquals(1, Node.FLAG_GLOBAL_STATE_UNMODIFIED);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test2021() throws Throwable {
    Node node0 = new Node(49, 49, 49);
    Node node1 = new Node(110, node0, node0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertNotNull(node2);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"public int getCharno() {
    return extractCharno(sourcePosition);
}","public void test2022() throws Throwable {
    Node node0 = new Node(49, 49, 49);
    Node node1 = new Node(110, node0, node0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertEquals(49, node2.getCharno());
}",""
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test2123() throws Throwable {
    Node node0 = new Node(49);
    Node node1 = new Node(105, node0, node0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertNotNull(node2);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"public int getType() {
    return type;
}","public void test2124() throws Throwable {
    Node node0 = new Node(49);
    Node node1 = new Node(105, node0, node0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertEquals(49, node2.getType());
}",""
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test2225() throws Throwable {
    Node node0 = new Node(49);
    Node node1 = new Node(132, node0, node0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertNotNull(node2);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"public boolean hasOneChild() {
    return first != null && first == last;
}","public void test2226() throws Throwable {
    Node node0 = new Node(49);
    Node node1 = new Node(132, node0, node0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertFalse(node2.hasOneChild());
}","/**
 * Check for one child more efficiently than by iterating over all the
 * children as is done with Node.getChildCount().
 *
 * @return Whether the node has exactly one child.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test2327() throws Throwable {
    Node node0 = new Node(49);
    Node node1 = Node.newNumber((double) 45);
    Node node2 = new Node(16, node0, node1);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"boolean isPure(Node n) {
    return n == null || (!NodeUtil.canBeSideEffected(n) && !NodeUtil.mayHaveSideEffects(n));
}","public void test2428() throws Throwable {
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    boolean boolean0 = peepholeSubstituteAlternateSyntax0.isPure((Node) null);
    assertTrue(boolean0);
}","/**
 * @return Whether the expression does not produces and can not be affected
 * by side-effects.
 */"
"boolean isPure(Node n) {
    return n == null || (!NodeUtil.canBeSideEffected(n) && !NodeUtil.mayHaveSideEffects(n));
}","public void test2529() throws Throwable {
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node0 = new Node(144);
    boolean boolean0 = peepholeSubstituteAlternateSyntax0.isPure(node0);
    assertFalse(boolean0);
}","/**
 * @return Whether the expression does not produces and can not be affected
 * by side-effects.
 */"
"boolean isPure(Node n) {
    return n == null || (!NodeUtil.canBeSideEffected(n) && !NodeUtil.mayHaveSideEffects(n));
}","public void test2630() throws Throwable {
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node0 = new Node(30);
    boolean boolean0 = peepholeSubstituteAlternateSyntax0.isPure(node0);
    assertFalse(boolean0);
}","/**
 * @return Whether the expression does not produces and can not be affected
 * by side-effects.
 */"
"boolean isPure(Node n) {
    return n == null || (!NodeUtil.canBeSideEffected(n) && !NodeUtil.mayHaveSideEffects(n));
}","public void test2731() throws Throwable {
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node0 = new Node(125, 125, 125);
    boolean boolean0 = peepholeSubstituteAlternateSyntax0.isPure(node0);
    assertTrue(boolean0);
}","/**
 * @return Whether the expression does not produces and can not be affected
 * by side-effects.
 */"
"boolean areMatchingExits(Node nodeThis, Node nodeThat) {
    return nodeThis.isEquivalentTo(nodeThat) && (!isExceptionPossible(nodeThis) || getExceptionHandler(nodeThis) == getExceptionHandler(nodeThat));
}","public void test2832() throws Throwable {
    Node node0 = Node.newString(""com.moXgle.common.colle\t.Re`ularImmutableMap$TerminalEntry"");
    Node node1 = new Node(4, node0, node0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    boolean boolean0 = peepholeSubstituteAlternateSyntax0.areMatchingExits(node1, node1);
    assertTrue(boolean0);
}","/**
 * Check whether one exit can be replaced with another. Verify:
 * 1) They are identical expressions
 * 2) If an exception is possible that the statements, the original
 * and the potential replacement are in the same exception handler.
 */"
"boolean areMatchingExits(Node nodeThis, Node nodeThat) {
    return nodeThis.isEquivalentTo(nodeThat) && (!isExceptionPossible(nodeThis) || getExceptionHandler(nodeThis) == getExceptionHandler(nodeThat));
}","public void test2933() throws Throwable {
    Node node0 = new Node(49);
    Node node1 = new Node(132, node0, node0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    boolean boolean0 = peepholeSubstituteAlternateSyntax0.areMatchingExits(node0, node0);
    assertTrue(boolean0);
}","/**
 * Check whether one exit can be replaced with another. Verify:
 * 1) They are identical expressions
 * 2) If an exception is possible that the statements, the original
 * and the potential replacement are in the same exception handler.
 */"
"boolean isExceptionPossible(Node n) {
    // TODO(johnlenz): maybe use ControlFlowAnalysis.mayThrowException?
    Preconditions.checkState(n.isReturn() || n.isThrow());
    return n.isThrow() || (n.hasChildren() && !NodeUtil.isLiteralValue(n.getLastChild(), true));
}","public void test3034() throws Throwable {
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node0 = new Node(125, 125, 125);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.isExceptionPossible(node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"boolean areMatchingExits(Node nodeThis, Node nodeThat) {
    return nodeThis.isEquivalentTo(nodeThat) && (!isExceptionPossible(nodeThis) || getExceptionHandler(nodeThis) == getExceptionHandler(nodeThat));
}","public void test3135() throws Throwable {
    Node node0 = new Node(4);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    boolean boolean0 = peepholeSubstituteAlternateSyntax0.areMatchingExits(node0, node0);
    assertTrue(boolean0);
}","/**
 * Check whether one exit can be replaced with another. Verify:
 * 1) They are identical expressions
 * 2) If an exception is possible that the statements, the original
 * and the potential replacement are in the same exception handler.
 */"
"boolean areMatchingExits(Node nodeThis, Node nodeThat) {
    return nodeThis.isEquivalentTo(nodeThat) && (!isExceptionPossible(nodeThis) || getExceptionHandler(nodeThis) == getExceptionHandler(nodeThat));
}","public void test3236() throws Throwable {
    Node node0 = new Node(101, 101, 101);
    Node node1 = new Node(4, node0, node0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.areMatchingExits(node1, node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.ControlFlowAnalysis"", e);
    }
}","/**
 * Check whether one exit can be replaced with another. Verify:
 * 1) They are identical expressions
 * 2) If an exception is possible that the statements, the original
 * and the potential replacement are in the same exception handler.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test3337() throws Throwable {
    Node node0 = new Node(12, 12, 12);
    Node node1 = new Node(26, node0, node0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test3438() throws Throwable {
    Node node0 = new Node(45, 45, 45);
    Node node1 = new Node(26, node0, node0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test3539() throws Throwable {
    Node node0 = new Node(46, 46, 46);
    Node node1 = new Node(26, node0, node0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test3640() throws Throwable {
    Node node0 = new Node(63);
    Node node1 = Node.newNumber((double) 0);
    Node node2 = new Node(108, node1, node0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node3 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node2);
    assertNotNull(node3);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"public boolean isIf() {
    return this.getType() == Token.IF;
}","public void test3641() throws Throwable {
    Node node0 = new Node(63);
    Node node1 = Node.newNumber((double) 0);
    Node node2 = new Node(108, node1, node0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node3 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node2);
    assertTrue(node3.isIf());
}",""
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test3742() throws Throwable {
    Node node0 = new Node(28, 28, 28);
    Node node1 = new Node(46, 45, 54);
    Node node2 = new Node(108, node1, node0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node3 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node2);
    assertEquals(4, Node.FLAG_ARGUMENTS_UNMODIFIED);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test3843() throws Throwable {
    Node node0 = new Node(14);
    Node node1 = new Node(26, node0, node0);
    Node node2 = new Node(108, node1, node1);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node2);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test3944() throws Throwable {
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node0 = new Node(98, 98, 98);
    Node node1 = new Node(98, node0, node0, node0, 38, 37);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test4045() throws Throwable {
    Node node0 = new Node(26);
    node0.addChildToFront(node0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test4146() throws Throwable {
    Node node0 = new Node(101, 101, 101);
    SyntheticAst syntheticAst0 = new SyntheticAst(""151w8 cNpDxf\""e;%n&/"");
    Compiler compiler0 = new Compiler();
    Node node1 = syntheticAst0.getAstRoot(compiler0);
    node0.addChildToBack(node1);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node2 = new Node(26, node0, node0);
    Node node3 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node2);
    assertNotNull(node3);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"public boolean isAnd() {
    return this.getType() == Token.AND;
}","public void test4147() throws Throwable {
    Node node0 = new Node(101, 101, 101);
    SyntheticAst syntheticAst0 = new SyntheticAst(""151w8 cNpDxf\""e;%n&/"");
    Compiler compiler0 = new Compiler();
    Node node1 = syntheticAst0.getAstRoot(compiler0);
    node0.addChildToBack(node1);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node2 = new Node(26, node0, node0);
    Node node3 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node2);
    assertFalse(node3.isAnd());
}",""
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test4248() throws Throwable {
    Node node0 = Node.newNumber((double) 26);
    Node node1 = new Node(26, node0, node0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test4349() throws Throwable {
    Node node0 = new Node(15);
    Node node1 = new Node(30, node0, node0, node0, 12, 2);
    Compiler compiler0 = new Compiler();
    AbstractCompiler.LifeCycleStage abstractCompiler_LifeCycleStage0 = AbstractCompiler.LifeCycleStage.NORMALIZED_OBFUSCATED;
    compiler0.setLifeCycleStage(abstractCompiler_LifeCycleStage0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    peepholeSubstituteAlternateSyntax0.beginTraversal(compiler0);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
    assertEquals(48, Node.DIRECTIVES);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test4450() throws Throwable {
    Node node0 = new Node((-891));
    Node node1 = new Node(37, node0, node0);
    Compiler compiler0 = new Compiler();
    AbstractCompiler.LifeCycleStage abstractCompiler_LifeCycleStage0 = AbstractCompiler.LifeCycleStage.NORMALIZED;
    compiler0.setLifeCycleStage(abstractCompiler_LifeCycleStage0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    peepholeSubstituteAlternateSyntax0.beginTraversal(compiler0);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test4551() throws Throwable {
    Node node0 = new Node(49, 49, 49);
    Node node1 = new Node(44, node0, node0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    // Undeclared exception!
    try {
        peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"", e);
    }
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"@Override
@SuppressWarnings(""fallthrough"")
public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
        case Token.RETURN:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                result = tryReplaceExitWithBreak(node);
                if (result != node) {
                    return result;
                }
                return tryReduceReturn(node);
            }
        case Token.THROW:
            {
                Node result = tryRemoveRedundantExit(node);
                if (result != node) {
                    return result;
                }
                return tryReplaceExitWithBreak(node);
            }
        // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
        // with MinimizeExitPoints.
        case Token.NOT:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeNot(node);
        case Token.IF:
            tryMinimizeCondition(node.getFirstChild());
            return tryMinimizeIf(node);
        case Token.EXPR_RESULT:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.HOOK:
            tryMinimizeCondition(node.getFirstChild());
            return node;
        case Token.WHILE:
        case Token.DO:
            tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            return node;
        case Token.FOR:
            if (!NodeUtil.isForIn(node)) {
                tryJoinForCondition(node);
                tryMinimizeCondition(NodeUtil.getConditionExpression(node));
            }
            return node;
        case Token.TRUE:
        case Token.FALSE:
            return reduceTrueFalse(node);
        case Token.NEW:
            node = tryFoldStandardConstructors(node);
            if (!node.isCall()) {
                return node;
            }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
        case Token.CALL:
            Node result = tryFoldLiteralConstructor(node);
            if (result == node) {
                result = tryFoldSimpleFunctionCall(node);
                if (result == node) {
                    result = tryFoldImmediateCallToBoundFunction(node);
                }
            }
            return result;
        case Token.COMMA:
            return trySplitComma(node);
        case Token.NAME:
            return tryReplaceUndefined(node);
        case Token.BLOCK:
            return tryReplaceIf(node);
        case Token.ARRAYLIT:
            return tryMinimizeArrayLiteral(node);
        default:
            //Nothing changed
            return node;
    }
}","public void test4652() throws Throwable {
    Node node0 = Node.newString(63, ""GK^Q."");
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node1 = new Node(63, node0, node0);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
    assertEquals(4, Node.FLAG_ARGUMENTS_UNMODIFIED);
}","/**
 * Tries apply our various peephole minimizations on the passed in node.
 */"
"public boolean isGetterDef() {
    return this.getType() == Token.GETTER_DEF;
}","public void test4753() throws Throwable {
    Node node0 = Node.newString("""");
    Node node1 = new Node(63, node0, node0);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(true);
    Node node2 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node1);
    assertFalse(node2.isGetterDef());
}",""
"public boolean isName() {
    return this.getType() == Token.NAME;
}","public void test4854() throws Throwable {
    Node node0 = new Node(63);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Node node1 = peepholeSubstituteAlternateSyntax0.optimizeSubtree(node0);
    assertFalse(node1.isName());
}",""
"static boolean containsUnicodeEscape(String s) {
    String esc = CodeGenerator.regexpEscape(s);
    for (int i = -1; (i = esc.indexOf(""\\u"", i + 1)) >= 0; ) {
        int nSlashes = 0;
        while (i - nSlashes > 0 && '\\' == esc.charAt(i - nSlashes - 1)) {
            ++nSlashes;
        }
        // if there are an even number of slashes before the \ u then it is a
        // Unicode literal.
        if (0 == (nSlashes & 1)) {
            return true;
        }
    }
    return false;
}","public void test4955() throws Throwable {
    boolean boolean0 = PeepholeSubstituteAlternateSyntax.containsUnicodeEscape(""\\u"");
    assertTrue(boolean0);
}","/**
 * true if the JavaScript string would contain a Unicode escape when written
 * out as the body of a regular expression literal.
 */"
