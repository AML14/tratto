focal_method,test_prefix,docstring
"@Override
public void enterScope(NodeTraversal t) {
    if (t.inGlobalScope()) {
        // Don't even brother. All global variables are likely escaped.
        return;
    }
    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {
        return;
    }
    // Compute the forward reaching definition.
    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);
    // Process the body of the function.
    Preconditions.checkState(t.getScopeRoot().isFunction());
    cfa.process(null, t.getScopeRoot().getLastChild());
    cfg = cfa.getCfg();
    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);
    reachingDef.analyze();
    candidates = Lists.newLinkedList();
    // Using the forward reaching definition search to find all the inline
    // candidates
    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());
    // Compute the backward reaching use. The CFG can be reused.
    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);
    reachingUses.analyze();
    for (Candidate c : candidates) {
        if (c.canInline(t.getScope())) {
            c.inlineVariable();
            // If definition c has dependencies, then inlining it may have
            // introduced new dependencies for our other inlining candidates.
            //
            // MustBeReachingVariableDef uses this dependency graph in its
            // analysis, so some of these candidates may no longer be valid.
            // We keep track of when the variable dependency graph changed
            // so that we can back off appropriately.
            if (!c.defMetadata.depends.isEmpty()) {
                inlinedNewDependencies.add(t.getScope().getVar(c.varName));
            }
        }
    }
}","public void test00() throws Throwable {
    Compiler compiler0 = new Compiler();
    FlowSensitiveInlineVariables flowSensitiveInlineVariables0 = new FlowSensitiveInlineVariables(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, flowSensitiveInlineVariables0);
    flowSensitiveInlineVariables0.enterScope(nodeTraversal0);
}",""
"@Override
public void process(Node externs, Node root) {
    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);
}","public void test11() throws Throwable {
    Compiler compiler0 = new Compiler();
    FlowSensitiveInlineVariables flowSensitiveInlineVariables0 = new FlowSensitiveInlineVariables(compiler0);
    Node node0 = compiler0.externsRoot;
    // Undeclared exception!
    try {
        flowSensitiveInlineVariables0.process((Node) null, (Node) null);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"@Override
public void exitScope(NodeTraversal t) {
}","public void test22() throws Throwable {
    FlowSensitiveInlineVariables flowSensitiveInlineVariables0 = new FlowSensitiveInlineVariables((AbstractCompiler) null);
    NodeTraversal nodeTraversal0 = new NodeTraversal((AbstractCompiler) null, flowSensitiveInlineVariables0, (ScopeCreator) null);
    flowSensitiveInlineVariables0.exitScope(nodeTraversal0);
}",""
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    // TODO(user): While the helpers do a subtree traversal on the AST, the
    // compiler pass itself only traverse the AST to look for function
    // declarations to perform dataflow analysis on. We could combine
    // the traversal in DataFlowAnalysis's computeEscaped later to save some
    // time.
}","public void test33() throws Throwable {
    Compiler compiler0 = new Compiler();
    FlowSensitiveInlineVariables flowSensitiveInlineVariables0 = new FlowSensitiveInlineVariables(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, flowSensitiveInlineVariables0);
    Node node0 = Node.newNumber(1281.0);
    flowSensitiveInlineVariables0.visit(nodeTraversal0, node0, node0);
}",""
