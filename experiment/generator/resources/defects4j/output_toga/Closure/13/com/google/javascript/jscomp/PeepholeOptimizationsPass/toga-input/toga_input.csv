focal_method,test_prefix,docstring
"public AbstractCompiler getCompiler() {
    return compiler;
}","public void test00() throws Throwable {
    Compiler compiler0 = new Compiler();
    AbstractPeepholeOptimization[] abstractPeepholeOptimizationArray0 = new AbstractPeepholeOptimization[3];
    PeepholeOptimizationsPass peepholeOptimizationsPass0 = new PeepholeOptimizationsPass(compiler0, abstractPeepholeOptimizationArray0);
    AbstractCompiler abstractCompiler0 = peepholeOptimizationsPass0.getCompiler();
    assertSame(abstractCompiler0, compiler0);
}",""
"public boolean isBreak() {
    return this.getType() == Token.BREAK;
}","public void test11() throws Throwable {
    Compiler compiler0 = new Compiler();
    AbstractPeepholeOptimization[] abstractPeepholeOptimizationArray0 = new AbstractPeepholeOptimization[0];
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""3OY>dm"", ""3OY>dm"");
    PeepholeOptimizationsPass peepholeOptimizationsPass0 = new PeepholeOptimizationsPass(compiler0, abstractPeepholeOptimizationArray0);
    peepholeOptimizationsPass0.process(node0, node0);
    peepholeOptimizationsPass0.process(node0, node0);
    assertFalse(node0.isBreak());
}",""
"public boolean hasMoreThanOneChild() {
    return first != null && first != last;
}","public void test22() throws Throwable {
    PeepholeFoldConstants peepholeFoldConstants0 = new PeepholeFoldConstants(false);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""com.google.javascript.jscomp.PreprocessorSymbolTable"", ""com.google.javascript.jscomp.PreprocessorSymbolTable"");
    PeepholeRemoveDeadCode peepholeRemoveDeadCode0 = new PeepholeRemoveDeadCode();
    AbstractPeepholeOptimization[] abstractPeepholeOptimizationArray0 = new AbstractPeepholeOptimization[4];
    abstractPeepholeOptimizationArray0[0] = (AbstractPeepholeOptimization) peepholeFoldConstants0;
    abstractPeepholeOptimizationArray0[1] = (AbstractPeepholeOptimization) peepholeRemoveDeadCode0;
    abstractPeepholeOptimizationArray0[2] = (AbstractPeepholeOptimization) peepholeFoldConstants0;
    abstractPeepholeOptimizationArray0[3] = (AbstractPeepholeOptimization) peepholeSubstituteAlternateSyntax0;
    node0.addChildToBack(node0);
    PeepholeOptimizationsPass peepholeOptimizationsPass0 = new PeepholeOptimizationsPass(compiler0, abstractPeepholeOptimizationArray0);
    peepholeOptimizationsPass0.process(node0, node0);
    assertFalse(node0.hasMoreThanOneChild());
}","/**
 * Check for more than one child more efficiently than by iterating over all
 * the children as is done with Node.getChildCount().
 *
 * @return Whether the node more than one child.
 */"
"public int getChildCount() {
    int c = 0;
    for (Node n = first; n != null; n = n.next) c++;
    return c;
}","public void test23() throws Throwable {
    PeepholeFoldConstants peepholeFoldConstants0 = new PeepholeFoldConstants(false);
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""com.google.javascript.jscomp.PreprocessorSymbolTable"", ""com.google.javascript.jscomp.PreprocessorSymbolTable"");
    PeepholeRemoveDeadCode peepholeRemoveDeadCode0 = new PeepholeRemoveDeadCode();
    AbstractPeepholeOptimization[] abstractPeepholeOptimizationArray0 = new AbstractPeepholeOptimization[4];
    abstractPeepholeOptimizationArray0[0] = (AbstractPeepholeOptimization) peepholeFoldConstants0;
    abstractPeepholeOptimizationArray0[1] = (AbstractPeepholeOptimization) peepholeRemoveDeadCode0;
    abstractPeepholeOptimizationArray0[2] = (AbstractPeepholeOptimization) peepholeFoldConstants0;
    abstractPeepholeOptimizationArray0[3] = (AbstractPeepholeOptimization) peepholeSubstituteAlternateSyntax0;
    node0.addChildToBack(node0);
    PeepholeOptimizationsPass peepholeOptimizationsPass0 = new PeepholeOptimizationsPass(compiler0, abstractPeepholeOptimizationArray0);
    peepholeOptimizationsPass0.process(node0, node0);
    assertEquals(1, node0.getChildCount());
}",""
"@Override
public void process(Node externs, Node root) {
    PeepholeChangeHandler handler = new PeepholeChangeHandler();
    compiler.addChangeHandler(handler);
    beginTraversal();
    traverse(root);
    endTraversal();
    compiler.removeChangeHandler(handler);
}","public void test34() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""3,Ydm"", "">i"");
    AbstractPeepholeOptimization[] abstractPeepholeOptimizationArray0 = new AbstractPeepholeOptimization[3];
    PeepholeSubstituteAlternateSyntax peepholeSubstituteAlternateSyntax0 = new PeepholeSubstituteAlternateSyntax(false);
    abstractPeepholeOptimizationArray0[0] = (AbstractPeepholeOptimization) peepholeSubstituteAlternateSyntax0;
    PeepholeFoldConstants peepholeFoldConstants0 = new PeepholeFoldConstants(false);
    abstractPeepholeOptimizationArray0[1] = (AbstractPeepholeOptimization) peepholeFoldConstants0;
    StatementFusion statementFusion0 = new StatementFusion();
    abstractPeepholeOptimizationArray0[2] = (AbstractPeepholeOptimization) statementFusion0;
    PeepholeOptimizationsPass peepholeOptimizationsPass0 = new PeepholeOptimizationsPass(compiler0, abstractPeepholeOptimizationArray0);
    // Undeclared exception!
    try {
        peepholeOptimizationsPass0.process(node0, node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.StatementFusion"", e);
    }
}",""
