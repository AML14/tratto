focal_method,test_prefix,docstring
"@Override
public void process(Node externs, Node root) {
    List<Reducer> reducers = ImmutableList.of(new ReturnConstantReducer(), new GetterReducer(), new SetterReducer(), new EmptyFunctionReducer(), new IdentityReducer());
    Multimap<Reducer, Reduction> reductionMap = HashMultimap.create();
    // Accumulate possible reductions in the reduction multi map.  They
    // will be applied in the loop below.
    NodeTraversal.traverse(compiler, root, new ReductionGatherer(reducers, reductionMap));
    // Apply reductions iff they will provide some savings.
    for (Reducer reducer : reducers) {
        Collection<Reduction> reductions = reductionMap.get(reducer);
        if (reductions.isEmpty()) {
            continue;
        }
        Node helperCode = parseHelperCode(reducer);
        if (helperCode == null) {
            continue;
        }
        int helperCodeCost = InlineCostEstimator.getCost(helperCode);
        // Estimate savings
        int savings = 0;
        for (Reduction reduction : reductions) {
            savings += reduction.estimateSavings();
        }
        // Compare estimated savings against the helper cost.  Apply
        // reductions if doing so will result in some savings.
        if (savings > (helperCodeCost + SAVINGS_THRESHOLD)) {
            for (Reduction reduction : reductions) {
                reduction.apply();
            }
            Node addingRoot = compiler.getNodeForCodeInsertion(null);
            addingRoot.addChildrenToFront(helperCode);
            compiler.reportCodeChange();
        }
    }
}","public void test00() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""function JSCompiler_emptyFn() {  return function() {}}"");
    FunctionRewriter functionRewriter0 = new FunctionRewriter(compiler0);
    functionRewriter0.process(node0, node0);
    assertEquals(4, Node.ENUM_PROP);
}",""
"@Override
public void process(Node externs, Node root) {
    List<Reducer> reducers = ImmutableList.of(new ReturnConstantReducer(), new GetterReducer(), new SetterReducer(), new EmptyFunctionReducer(), new IdentityReducer());
    Multimap<Reducer, Reduction> reductionMap = HashMultimap.create();
    // Accumulate possible reductions in the reduction multi map.  They
    // will be applied in the loop below.
    NodeTraversal.traverse(compiler, root, new ReductionGatherer(reducers, reductionMap));
    // Apply reductions iff they will provide some savings.
    for (Reducer reducer : reducers) {
        Collection<Reduction> reductions = reductionMap.get(reducer);
        if (reductions.isEmpty()) {
            continue;
        }
        Node helperCode = parseHelperCode(reducer);
        if (helperCode == null) {
            continue;
        }
        int helperCodeCost = InlineCostEstimator.getCost(helperCode);
        // Estimate savings
        int savings = 0;
        for (Reduction reduction : reductions) {
            savings += reduction.estimateSavings();
        }
        // Compare estimated savings against the helper cost.  Apply
        // reductions if doing so will result in some savings.
        if (savings > (helperCodeCost + SAVINGS_THRESHOLD)) {
            for (Reduction reduction : reductions) {
                reduction.apply();
            }
            Node addingRoot = compiler.getNodeForCodeInsertion(null);
            addingRoot.addChildrenToFront(helperCode);
            compiler.reportCodeChange();
        }
    }
}","public void test11() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""function JSCompiler_identityF() {  return function(JSCompiler_identityFn_value) {return JSCompiler_identityFn_value}}"");
    compiler0.parseSyntheticCode(""X|w!wX<\t~G&LpgmSZs"");
    FunctionRewriter functionRewriter0 = new FunctionRewriter(compiler0);
    functionRewriter0.process(node0, node0);
    assertEquals(1, Node.LEFT);
}",""
"@Override
public void process(Node externs, Node root) {
    List<Reducer> reducers = ImmutableList.of(new ReturnConstantReducer(), new GetterReducer(), new SetterReducer(), new EmptyFunctionReducer(), new IdentityReducer());
    Multimap<Reducer, Reduction> reductionMap = HashMultimap.create();
    // Accumulate possible reductions in the reduction multi map.  They
    // will be applied in the loop below.
    NodeTraversal.traverse(compiler, root, new ReductionGatherer(reducers, reductionMap));
    // Apply reductions iff they will provide some savings.
    for (Reducer reducer : reducers) {
        Collection<Reduction> reductions = reductionMap.get(reducer);
        if (reductions.isEmpty()) {
            continue;
        }
        Node helperCode = parseHelperCode(reducer);
        if (helperCode == null) {
            continue;
        }
        int helperCodeCost = InlineCostEstimator.getCost(helperCode);
        // Estimate savings
        int savings = 0;
        for (Reduction reduction : reductions) {
            savings += reduction.estimateSavings();
        }
        // Compare estimated savings against the helper cost.  Apply
        // reductions if doing so will result in some savings.
        if (savings > (helperCodeCost + SAVINGS_THRESHOLD)) {
            for (Reduction reduction : reductions) {
                reduction.apply();
            }
            Node addingRoot = compiler.getNodeForCodeInsertion(null);
            addingRoot.addChildrenToFront(helperCode);
            compiler.reportCodeChange();
        }
    }
}","public void test22() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""function JSCompiler_set(JSCompiler_set_name) {  return function(JSCompiler_set_value) {this[JSCompiler_set_name] = JSCompiler_set_value}}"", ""function JSCompiler_set(JSCompiler_set_name) {  return function(JSCompiler_set_value) {this[JSCompiler_set_name] = JSCompiler_set_value}}"");
    FunctionRewriter functionRewriter0 = new FunctionRewriter(compiler0);
    functionRewriter0.process(node0, node0);
    assertEquals(16, Node.FLAG_LOCAL_RESULTS);
}",""
"@Override
public void process(Node externs, Node root) {
    List<Reducer> reducers = ImmutableList.of(new ReturnConstantReducer(), new GetterReducer(), new SetterReducer(), new EmptyFunctionReducer(), new IdentityReducer());
    Multimap<Reducer, Reduction> reductionMap = HashMultimap.create();
    // Accumulate possible reductions in the reduction multi map.  They
    // will be applied in the loop below.
    NodeTraversal.traverse(compiler, root, new ReductionGatherer(reducers, reductionMap));
    // Apply reductions iff they will provide some savings.
    for (Reducer reducer : reducers) {
        Collection<Reduction> reductions = reductionMap.get(reducer);
        if (reductions.isEmpty()) {
            continue;
        }
        Node helperCode = parseHelperCode(reducer);
        if (helperCode == null) {
            continue;
        }
        int helperCodeCost = InlineCostEstimator.getCost(helperCode);
        // Estimate savings
        int savings = 0;
        for (Reduction reduction : reductions) {
            savings += reduction.estimateSavings();
        }
        // Compare estimated savings against the helper cost.  Apply
        // reductions if doing so will result in some savings.
        if (savings > (helperCodeCost + SAVINGS_THRESHOLD)) {
            for (Reduction reduction : reductions) {
                reduction.apply();
            }
            Node addingRoot = compiler.getNodeForCodeInsertion(null);
            addingRoot.addChildrenToFront(helperCode);
            compiler.reportCodeChange();
        }
    }
}","public void test33() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""function JSCompiler_get(JSCompiler_get_name) {  return function() {return this[JSCompiler_get_name]}}"", ""function JSCompiler_get(JSCompiler_get_name) {  return function() {return this[JSCompiler_get_name]}}"");
    FunctionRewriter functionRewriter0 = new FunctionRewriter(compiler0);
    functionRewriter0.process(node0, node0);
    assertEquals(2, Node.POST_FLAG);
}",""
"@Override
public void process(Node externs, Node root) {
    List<Reducer> reducers = ImmutableList.of(new ReturnConstantReducer(), new GetterReducer(), new SetterReducer(), new EmptyFunctionReducer(), new IdentityReducer());
    Multimap<Reducer, Reduction> reductionMap = HashMultimap.create();
    // Accumulate possible reductions in the reduction multi map.  They
    // will be applied in the loop below.
    NodeTraversal.traverse(compiler, root, new ReductionGatherer(reducers, reductionMap));
    // Apply reductions iff they will provide some savings.
    for (Reducer reducer : reducers) {
        Collection<Reduction> reductions = reductionMap.get(reducer);
        if (reductions.isEmpty()) {
            continue;
        }
        Node helperCode = parseHelperCode(reducer);
        if (helperCode == null) {
            continue;
        }
        int helperCodeCost = InlineCostEstimator.getCost(helperCode);
        // Estimate savings
        int savings = 0;
        for (Reduction reduction : reductions) {
            savings += reduction.estimateSavings();
        }
        // Compare estimated savings against the helper cost.  Apply
        // reductions if doing so will result in some savings.
        if (savings > (helperCodeCost + SAVINGS_THRESHOLD)) {
            for (Reduction reduction : reductions) {
                reduction.apply();
            }
            Node addingRoot = compiler.getNodeForCodeInsertion(null);
            addingRoot.addChildrenToFront(helperCode);
            compiler.reportCodeChange();
        }
    }
}","public void test44() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Normalize.parseAndNormalizeTestCode(compiler0, ""function JSCompiler_identityF() {  return function(JSAompiler_identityFn_value) {return JSCompi.er_identityFn_value}}"", ""function JSCompiler_identityF() {  return function(JSAompiler_identityFn_value) {return JSCompi.er_identityFn_value}}"");
    FunctionRewriter functionRewriter0 = new FunctionRewriter(compiler0);
    functionRewriter0.process(node0, node0);
    assertEquals(4095, Node.MAX_COLUMN_NUMBER);
}",""
"@Override
public void process(Node externs, Node root) {
    List<Reducer> reducers = ImmutableList.of(new ReturnConstantReducer(), new GetterReducer(), new SetterReducer(), new EmptyFunctionReducer(), new IdentityReducer());
    Multimap<Reducer, Reduction> reductionMap = HashMultimap.create();
    // Accumulate possible reductions in the reduction multi map.  They
    // will be applied in the loop below.
    NodeTraversal.traverse(compiler, root, new ReductionGatherer(reducers, reductionMap));
    // Apply reductions iff they will provide some savings.
    for (Reducer reducer : reducers) {
        Collection<Reduction> reductions = reductionMap.get(reducer);
        if (reductions.isEmpty()) {
            continue;
        }
        Node helperCode = parseHelperCode(reducer);
        if (helperCode == null) {
            continue;
        }
        int helperCodeCost = InlineCostEstimator.getCost(helperCode);
        // Estimate savings
        int savings = 0;
        for (Reduction reduction : reductions) {
            savings += reduction.estimateSavings();
        }
        // Compare estimated savings against the helper cost.  Apply
        // reductions if doing so will result in some savings.
        if (savings > (helperCodeCost + SAVINGS_THRESHOLD)) {
            for (Reduction reduction : reductions) {
                reduction.apply();
            }
            Node addingRoot = compiler.getNodeForCodeInsertion(null);
            addingRoot.addChildrenToFront(helperCode);
            compiler.reportCodeChange();
        }
    }
}","public void test55() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""function JSCompiler_identityFn() {  return function(JSComiler_identityFn_value) {return JSCompiler_identityFn_value}}"", ""function JSCompiler_identityFn() {  return function(JSComiler_identityFn_value) {return JSCompiler_identityFn_value}}"");
    FunctionRewriter functionRewriter0 = new FunctionRewriter(compiler0);
    functionRewriter0.process(node0, node0);
    assertEquals(2, Node.FLAG_THIS_UNMODIFIED);
}",""
