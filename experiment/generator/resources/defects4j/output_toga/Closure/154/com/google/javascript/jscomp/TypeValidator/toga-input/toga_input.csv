focal_method,test_prefix,docstring
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test000() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode("" nl \""rrays*Or ob1ecFsca ce acce(sed"", "" nl \""rrays*Or ob1ecFsca ce acce(sed"");
    UnfoldCompoundAssignments unfoldCompoundAssignments0 = new UnfoldCompoundAssignments(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unfoldCompoundAssignments0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.VOID_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    boolean boolean0 = typeValidator0.expectNotNullOrUndefined(nodeTraversal0, node0, jSType0, ""Named type with empty name component"", jSType0);
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"boolean expectNotNullOrUndefined(NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {
    if (!type.isNoType() && !type.isUnknownType() && type.isSubtype(nullOrUndefined) && !containsForwardDeclaredUnresolvedName(type)) {
        // There's one edge case right now that we don't handle well, and
        // that we don't want to warn about.
        // if (this.x == null) {
        //   this.initializeX();
        //   this.x.foo();
        // }
        // In this case, we incorrectly type x because of how we
        // infer properties locally. See issue 109.
        // http://code.google.com/p/closure-compiler/issues/detail?id=109
        //
        // We do not do this inference globally.
        if (n.getType() == Token.GETPROP && !t.inGlobalScope() && type.isNullType()) {
            return true;
        }
        mismatch(t, n, msg, type, expectedType);
        return false;
    }
    return true;
}","public void test001() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode("" nl \""rrays*Or ob1ecFsca ce acce(sed"", "" nl \""rrays*Or ob1ecFsca ce acce(sed"");
    UnfoldCompoundAssignments unfoldCompoundAssignments0 = new UnfoldCompoundAssignments(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unfoldCompoundAssignments0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.VOID_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    boolean boolean0 = typeValidator0.expectNotNullOrUndefined(nodeTraversal0, node0, jSType0, ""Named type with empty name component"", jSType0);
    assertFalse(boolean0);
}","/**
 * Expect the type to be anything but the null or void type. If the
 * expectation is not met, issue a warning at the provided node's
 * source code position. Note that a union type that includes the
 * void type and at least one other type meets the expectation.
 * @return Whether the expectation was met.
 */"
"Iterable<TypeMismatch> getMismatches() {
    return mismatches;
}","public void test012() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""`JXDCZ[.t:M[!2?B8X"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    Iterable<TypeValidator.TypeMismatch> iterable0 = typeValidator0.getMismatches();
    assertNotNull(iterable0);
}","/**
 * Gets a list of type violations.
 *
 * For each violation, one element is the expected type and the other is
 * the type that is actually found. Order is not signficant.
 */"
"// All non-private methods should have the form:
// expectCondition(NodeTraversal t, Node n, ...);
// If there is a mismatch, the {@code expect} method should issue
// a warning and attempt to correct the mismatch, when possible.
/**
 * Expect the type to be an object, or a type convertible to object. If the
 * expectation is not met, issue a warning at the provided node's source code
 * position.
 * @return True if there was no warning, false if there was a mismatch.
 */
boolean expectObject(NodeTraversal t, Node n, JSType type, String msg) {
    if (!type.matchesObjectContext()) {
        mismatch(t, n, msg, type, OBJECT_TYPE);
        return false;
    }
    return true;
}","public void test034() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Named type with empty name component"");
    GroupVariableDeclarations groupVariableDeclarations0 = new GroupVariableDeclarations(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, groupVariableDeclarations0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    boolean boolean0 = typeValidator0.expectObject(nodeTraversal0, node0, jSType0, ""Not declared as a type name"");
    assertTrue(boolean0);
}",""
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test045() throws Throwable {
    Compiler compiler0 = new Compiler();
    Denormalize denormalize0 = new Denormalize(compiler0);
    Node node0 = compiler0.parseTestCode(""!"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0, (ScopeCreator) null);
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.VOID_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    boolean boolean0 = typeValidator0.expectObject(nodeTraversal0, node0, jSType0, ""Named type with empty name component"");
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"// All non-private methods should have the form:
// expectCondition(NodeTraversal t, Node n, ...);
// If there is a mismatch, the {@code expect} method should issue
// a warning and attempt to correct the mismatch, when possible.
/**
 * Expect the type to be an object, or a type convertible to object. If the
 * expectation is not met, issue a warning at the provided node's source code
 * position.
 * @return True if there was no warning, false if there was a mismatch.
 */
boolean expectObject(NodeTraversal t, Node n, JSType type, String msg) {
    if (!type.matchesObjectContext()) {
        mismatch(t, n, msg, type, OBJECT_TYPE);
        return false;
    }
    return true;
}","public void test046() throws Throwable {
    Compiler compiler0 = new Compiler();
    Denormalize denormalize0 = new Denormalize(compiler0);
    Node node0 = compiler0.parseTestCode(""!"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0, (ScopeCreator) null);
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.VOID_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    boolean boolean0 = typeValidator0.expectObject(nodeTraversal0, node0, jSType0, ""Named type with empty name component"");
    assertFalse(boolean0);
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test057() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Named type with empty name component"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    typeValidator0.expectActualObject((NodeTraversal) null, node0, noType0, ""Unknown class name"");
    assertFalse(noType0.hasCachedValues());
}",""
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test068() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Denormalize denormalize0 = new Denormalize(compiler0);
    Node node0 = compiler0.parseTestCode(""Named type with empty name component"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    NullType nullType0 = (NullType) jSTypeRegistry0.createDefaultObjectUnion(noType0);
    typeValidator0.expectActualObject(nodeTraversal0, node0, nullType0, ""t'ptp$Gy"");
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test069() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Denormalize denormalize0 = new Denormalize(compiler0);
    Node node0 = compiler0.parseTestCode(""Named type with empty name component"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    NullType nullType0 = (NullType) jSTypeRegistry0.createDefaultObjectUnion(noType0);
    typeValidator0.expectActualObject(nodeTraversal0, node0, nullType0, ""t'ptp$Gy"");
    assertFalse(noType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test0710() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("""");
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) null, node0);
    typeValidator0.expectAnyObject(nodeTraversal0, node0, functionType0, ""Named type with empty name component"");
    assertTrue(functionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test0811() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Not declared as a type name"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    UnreachableCodeElimination unreachableCodeElimination0 = new UnreachableCodeElimination(compiler0, false);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unreachableCodeElimination0);
    typeValidator0.expectAnyObject(nodeTraversal0, node0, noType0, ""Named type with empty name component"");
    assertTrue(noType0.hasCachedValues());
}",""
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test0912() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Denormalize denormalize0 = new Denormalize(compiler0);
    Node node0 = compiler0.parseTestCode(""~,,[QIF.L&A"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0, syntacticScopeCreator0);
    JSType jSType1 = jSTypeRegistry0.createOptionalType(jSType0);
    typeValidator0.expectAnyObject(nodeTraversal0, node0, jSType1, ""Named type with empty name component"");
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test1013() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Named type with empty name component"");
    JSTypeNative jSTypeNative0 = JSTypeNative.ARRAY_TYPE;
    InstanceObjectType instanceObjectType0 = (InstanceObjectType) jSTypeRegistry0.getNativeType(jSTypeNative0);
    GroupVariableDeclarations groupVariableDeclarations0 = new GroupVariableDeclarations(compiler0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, groupVariableDeclarations0);
    typeValidator0.expectIndexMatch(nodeTraversal0, node0, instanceObjectType0, noType0);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test1014() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Named type with empty name component"");
    JSTypeNative jSTypeNative0 = JSTypeNative.ARRAY_TYPE;
    InstanceObjectType instanceObjectType0 = (InstanceObjectType) jSTypeRegistry0.getNativeType(jSTypeNative0);
    GroupVariableDeclarations groupVariableDeclarations0 = new GroupVariableDeclarations(compiler0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, groupVariableDeclarations0);
    typeValidator0.expectIndexMatch(nodeTraversal0, node0, instanceObjectType0, noType0);
    assertFalse(noType0.hasCachedValues());
}",""
"void expectIndexMatch(NodeTraversal t, Node n, JSType objType, JSType indexType) {
    if (objType.isUnknownType()) {
        expectStringOrNumber(t, n, indexType, ""property access"");
    } else if (objType.toObjectType() != null && objType.toObjectType().getIndexType() != null) {
        expectCanAssignTo(t, n, indexType, objType.toObjectType().getIndexType(), ""restricted index type"");
    } else if (objType.isArrayType()) {
        expectNumber(t, n, indexType, ""array access"");
    } else if (objType.matchesObjectContext()) {
        expectString(t, n, indexType, ""property access"");
    } else {
        mismatch(t, n, ""only arrays or objects can be accessed"", objType, typeRegistry.createUnionType(ARRAY_TYPE, OBJECT_TYPE));
    }
}","public void test1115() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Named type with empty name component"");
    JSTypeNative jSTypeNative0 = JSTypeNative.ARRAY_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    // Undeclared exception!
    try {
        typeValidator0.expectIndexMatch((NodeTraversal) null, node0, jSType0, jSType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeValidator"", e);
    }
}","/**
 * Expect that the first type can be addressed with GETELEM syntax,
 * and that the second type is the right type for an index into the
 * first type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param objType The type of the left side of the GETELEM.
 * @param indexType The type inside the brackets of the GETELEM.
 */"
"void expectBitwiseable(NodeTraversal t, Node n, JSType type, String msg) {
    if (!type.matchesNumberContext() && !type.isSubtype(allValueTypes)) {
        mismatch(t, n, msg, type, allValueTypes);
    }
}","public void test1216() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Unknown class name"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    FlowSensitiveInlineVariables flowSensitiveInlineVariables0 = new FlowSensitiveInlineVariables(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, flowSensitiveInlineVariables0, (ScopeCreator) null);
    typeValidator0.expectBitwiseable(nodeTraversal0, node0, jSType0, ""^#"");
    assertEquals(0, Node.LABEL_ID_PROP);
}","/**
 * Expect the type to be a valid operand to a bitwise operator. This includes
 * numbers, any type convertible to a number, or any other primitive type
 * (undefined|null|boolean|string).
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test1317() throws Throwable {
    Compiler compiler0 = new Compiler();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.ALL_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    Denormalize denormalize0 = new Denormalize(compiler0);
    Node node0 = compiler0.parseTestCode(""Named type with empty name component"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    typeValidator0.expectBitwiseable(nodeTraversal0, node0, functionType0, ""Not declared as a type name"");
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test1318() throws Throwable {
    Compiler compiler0 = new Compiler();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.ALL_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    Denormalize denormalize0 = new Denormalize(compiler0);
    Node node0 = compiler0.parseTestCode(""Named type with empty name component"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    typeValidator0.expectBitwiseable(nodeTraversal0, node0, functionType0, ""Not declared as a type name"");
    assertTrue(functionType0.hasCachedValues());
}",""
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test1419() throws Throwable {
    Compiler compiler0 = new Compiler();
    Denormalize denormalize0 = new Denormalize(compiler0);
    Node node0 = compiler0.parseTestCode(""!"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0, (ScopeCreator) null);
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.VOID_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    typeValidator0.expectBitwiseable(nodeTraversal0, node0, jSType0, ""Not declared as a constructor"");
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"void expectStringOrNumber(NodeTraversal t, Node n, JSType type, String msg) {
    if (!type.matchesNumberContext() && !type.matchesStringContext()) {
        mismatch(t, n, msg, type, NUMBER_STRING);
    }
}","public void test1520() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Unknown class name"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
    typeValidator0.expectStringOrNumber(nodeTraversal0, node0, jSType0, ""Not declared as a type name"");
    assertEquals(29, Node.VAR_ARGS_NAME);
}","/**
 * Expect the type to be a number or string, or a type convertible to a number
 * or string. If the expectation is not met, issue a warning at the provided
 * node's source code position.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test1621() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("""");
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    JSType jSType0 = jSTypeRegistry0.createNamedType(""Not declared as a constructor"", ""Unknown class name"", 49, 1);
    typeValidator0.expectIndexMatch(nodeTraversal0, node0, jSType0, functionType0);
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test1722() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Denormalize denormalize0 = new Denormalize(compiler0);
    compiler0.parseTestCode(""Unknown class name"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Not declared as a constructor"", jSType0);
    typeValidator0.expectStringOrNumber(nodeTraversal0, (Node) null, enumType0, ""Not declared as a type name"");
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"boolean expectNotNullOrUndefined(NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {
    if (!type.isNoType() && !type.isUnknownType() && type.isSubtype(nullOrUndefined) && !containsForwardDeclaredUnresolvedName(type)) {
        // There's one edge case right now that we don't handle well, and
        // that we don't want to warn about.
        // if (this.x == null) {
        //   this.initializeX();
        //   this.x.foo();
        // }
        // In this case, we incorrectly type x because of how we
        // infer properties locally. See issue 109.
        // http://code.google.com/p/closure-compiler/issues/detail?id=109
        //
        // We do not do this inference globally.
        if (n.getType() == Token.GETPROP && !t.inGlobalScope() && type.isNullType()) {
            return true;
        }
        mismatch(t, n, msg, type, expectedType);
        return false;
    }
    return true;
}","public void test1823() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Unknown class name"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    boolean boolean0 = typeValidator0.expectNotNullOrUndefined((NodeTraversal) null, node0, jSType0, ""Named type with empty name component"", jSType0);
    assertTrue(boolean0);
}","/**
 * Expect the type to be anything but the null or void type. If the
 * expectation is not met, issue a warning at the provided node's
 * source code position. Note that a union type that includes the
 * void type and at least one other type meets the expectation.
 * @return Whether the expectation was met.
 */"
"boolean expectNotNullOrUndefined(NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {
    if (!type.isNoType() && !type.isUnknownType() && type.isSubtype(nullOrUndefined) && !containsForwardDeclaredUnresolvedName(type)) {
        // There's one edge case right now that we don't handle well, and
        // that we don't want to warn about.
        // if (this.x == null) {
        //   this.initializeX();
        //   this.x.foo();
        // }
        // In this case, we incorrectly type x because of how we
        // infer properties locally. See issue 109.
        // http://code.google.com/p/closure-compiler/issues/detail?id=109
        //
        // We do not do this inference globally.
        if (n.getType() == Token.GETPROP && !t.inGlobalScope() && type.isNullType()) {
            return true;
        }
        mismatch(t, n, msg, type, expectedType);
        return false;
    }
    return true;
}","public void test1924() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Attempt to remove() an extern definition."");
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.CHECKED_UNKNOWN_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    boolean boolean0 = typeValidator0.expectNotNullOrUndefined(nodeTraversal0, node0, jSType0, ""/J_G4NIDGVp#"", jSType0);
    assertTrue(boolean0);
}","/**
 * Expect the type to be anything but the null or void type. If the
 * expectation is not met, issue a warning at the provided node's
 * source code position. Note that a union type that includes the
 * void type and at least one other type meets the expectation.
 * @return Whether the expectation was met.
 */"
"boolean expectNotNullOrUndefined(NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {
    if (!type.isNoType() && !type.isUnknownType() && type.isSubtype(nullOrUndefined) && !containsForwardDeclaredUnresolvedName(type)) {
        // There's one edge case right now that we don't handle well, and
        // that we don't want to warn about.
        // if (this.x == null) {
        //   this.initializeX();
        //   this.x.foo();
        // }
        // In this case, we incorrectly type x because of how we
        // infer properties locally. See issue 109.
        // http://code.google.com/p/closure-compiler/issues/detail?id=109
        //
        // We do not do this inference globally.
        if (n.getType() == Token.GETPROP && !t.inGlobalScope() && type.isNullType()) {
            return true;
        }
        mismatch(t, n, msg, type, expectedType);
        return false;
    }
    return true;
}","public void test2025() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode("" nl \""rrays*Or ob1ecFsca ce acce(sed"", "" nl \""rrays*Or ob1ecFsca ce acce(sed"");
    UnfoldCompoundAssignments unfoldCompoundAssignments0 = new UnfoldCompoundAssignments(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unfoldCompoundAssignments0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    boolean boolean0 = typeValidator0.expectNotNullOrUndefined(nodeTraversal0, node0, functionType0, ""Unknown class name"", functionType0);
    assertTrue(boolean0);
}","/**
 * Expect the type to be anything but the null or void type. If the
 * expectation is not met, issue a warning at the provided node's
 * source code position. Note that a union type that includes the
 * void type and at least one other type meets the expectation.
 * @return Whether the expectation was met.
 */"
"boolean expectNotNullOrUndefined(NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {
    if (!type.isNoType() && !type.isUnknownType() && type.isSubtype(nullOrUndefined) && !containsForwardDeclaredUnresolvedName(type)) {
        // There's one edge case right now that we don't handle well, and
        // that we don't want to warn about.
        // if (this.x == null) {
        //   this.initializeX();
        //   this.x.foo();
        // }
        // In this case, we incorrectly type x because of how we
        // infer properties locally. See issue 109.
        // http://code.google.com/p/closure-compiler/issues/detail?id=109
        //
        // We do not do this inference globally.
        if (n.getType() == Token.GETPROP && !t.inGlobalScope() && type.isNullType()) {
            return true;
        }
        mismatch(t, n, msg, type, expectedType);
        return false;
    }
    return true;
}","public void test2126() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Unknown class name"");
    JSTypeNative jSTypeNative0 = JSTypeNative.NO_RESOLVED_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    GatherRawExports gatherRawExports0 = new GatherRawExports(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, gatherRawExports0);
    boolean boolean0 = typeValidator0.expectNotNullOrUndefined(nodeTraversal0, node0, jSType0, ""Not declared as a constructor"", (JSType) null);
    assertTrue(boolean0);
}","/**
 * Expect the type to be anything but the null or void type. If the
 * expectation is not met, issue a warning at the provided node's
 * source code position. Note that a union type that includes the
 * void type and at least one other type meets the expectation.
 * @return Whether the expectation was met.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test2227() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Named type with empty name component"");
    JSTypeNative jSTypeNative0 = JSTypeNative.ARRAY_TYPE;
    InstanceObjectType instanceObjectType0 = (InstanceObjectType) jSTypeRegistry0.getNativeType(jSTypeNative0);
    GroupVariableDeclarations groupVariableDeclarations0 = new GroupVariableDeclarations(compiler0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, groupVariableDeclarations0);
    typeValidator0.expectSwitchMatchesCase(nodeTraversal0, node0, instanceObjectType0, noType0);
    assertTrue(noType0.hasCachedValues());
}",""
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test2328() throws Throwable {
    Compiler compiler0 = new Compiler();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.STRING_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    Denormalize denormalize0 = new Denormalize(compiler0);
    Node node0 = compiler0.parseSyntheticCode(""Not declared as a constructor"", ""Named type with empty name component"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    JSTypeNative jSTypeNative1 = JSTypeNative.TOP_LEVEL_PROTOTYPE;
    ObjectType objectType0 = jSTypeRegistry0.getNativeObjectType(jSTypeNative1);
    typeValidator0.expectSwitchMatchesCase(nodeTraversal0, node0, objectType0, jSType0);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"void expectSwitchMatchesCase(NodeTraversal t, Node n, JSType switchType, JSType caseType) {
    // ECMA-262, page 68, step 3 of evaluation of CaseBlock,
    // but allowing extra autoboxing.
    // TODO(user): remove extra conditions when type annotations
    // in the code base have adapted to the change in the compiler.
    if (!switchType.canTestForShallowEqualityWith(caseType) && (caseType.autoboxesTo() == null || !caseType.autoboxesTo().isSubtype(switchType))) {
        mismatch(t, n.getFirstChild(), ""case expression doesn't match switch"", caseType, switchType);
    }
}","public void test2429() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Not declared as a type name"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
    JSTypeNative jSTypeNative0 = JSTypeNative.ERROR_FUNCTION_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    // Undeclared exception!
    try {
        typeValidator0.expectSwitchMatchesCase((NodeTraversal) null, node0, objectType0, jSType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeValidator"", e);
    }
}","/**
 * Expect that the type of a switch condition matches the type of its
 * case condition.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test2530() throws Throwable {
    Compiler compiler0 = new Compiler();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.STRING_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    Denormalize denormalize0 = new Denormalize(compiler0);
    Node node0 = compiler0.parseTestCode(""Not declared as a type name"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    typeValidator0.expectSwitchMatchesCase(nodeTraversal0, node0, functionType0, jSType0);
    assertTrue(functionType0.hasCachedValues());
}",""
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test2531() throws Throwable {
    Compiler compiler0 = new Compiler();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.STRING_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    Denormalize denormalize0 = new Denormalize(compiler0);
    Node node0 = compiler0.parseTestCode(""Not declared as a type name"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    typeValidator0.expectSwitchMatchesCase(nodeTraversal0, node0, functionType0, jSType0);
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test2632() throws Throwable {
    Compiler compiler0 = new Compiler();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    Denormalize denormalize0 = new Denormalize(compiler0);
    Node node0 = compiler0.parseTestCode(""Named type with empty name component"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    typeValidator0.expectIndexMatch(nodeTraversal0, node0, jSType0, jSType0);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test2733() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Attempt to remove() an extern definition."");
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.VOID_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    typeValidator0.expectIndexMatch(nodeTraversal0, node0, jSType0, jSType0);
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {
    // The NoType check is a hack to make typedefs work ok.
    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {
        if (bothIntrinsics(rightType, leftType)) {
            // We have a superior warning for this mistake, which gives you
            // the line numbers of both types.
            registerMismatch(rightType, leftType);
        } else {
            mismatch(t, n, ""assignment to property "" + propName + "" of "" + getReadableJSTypeName(owner, true), rightType, leftType);
        }
        return false;
    }
    return true;
}","public void test2834() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Unknown class name"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf((NodeTraversal) null, node0, jSType0, jSType0, node0, ""Not declared as a constructor"");
    assertTrue(boolean0);
}","/**
 * Expect that the first type can be assigned to a symbol of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param owner The owner of the property being assigned to.
 * @param propName The name of the property being assigned to.
 * @return True if the types matched, false otherwise.
 */"
"boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {
    // The NoType check is a hack to make typedefs work ok.
    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {
        if (bothIntrinsics(rightType, leftType)) {
            // We have a superior warning for this mistake, which gives you
            // the line numbers of both types.
            registerMismatch(rightType, leftType);
        } else {
            mismatch(t, n, ""assignment to property "" + propName + "" of "" + getReadableJSTypeName(owner, true), rightType, leftType);
        }
        return false;
    }
    return true;
}","public void test2935() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Denormalize denormalize0 = new Denormalize(compiler0);
    Node node0 = compiler0.parseTestCode(""Not declared as a type name"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Not declared as a constructor"", jSType0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, jSType0, enumType0, (Node) null, ""Unknown class name"");
    assertTrue(boolean0);
}","/**
 * Expect that the first type can be assigned to a symbol of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param owner The owner of the property being assigned to.
 * @param propName The name of the property being assigned to.
 * @return True if the types matched, false otherwise.
 */"
"boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {
    // The NoType check is a hack to make typedefs work ok.
    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {
        if (bothIntrinsics(rightType, leftType)) {
            // We have a superior warning for this mistake, which gives you
            // the line numbers of both types.
            registerMismatch(rightType, leftType);
        } else {
            mismatch(t, n, ""assignment to property "" + propName + "" of "" + getReadableJSTypeName(owner, true), rightType, leftType);
        }
        return false;
    }
    return true;
}","public void test3036() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Denormalize denormalize0 = new Denormalize(compiler0);
    Node node0 = compiler0.parseTestCode(""Not declared as a type name"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Not declared as a constructor"", functionType0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    // Undeclared exception!
    try {
        typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, functionType0, enumType0, (Node) null, ""Unknown class name"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeValidator"", e);
    }
}","/**
 * Expect that the first type can be assigned to a symbol of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param owner The owner of the property being assigned to.
 * @param propName The name of the property being assigned to.
 * @return True if the types matched, false otherwise.
 */"
"boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {
    // The NoType check is a hack to make typedefs work ok.
    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {
        if (bothIntrinsics(rightType, leftType)) {
            // We have a superior warning for this mistake, which gives you
            // the line numbers of both types.
            registerMismatch(rightType, leftType);
        } else {
            mismatch(t, n, ""assignment to property "" + propName + "" of "" + getReadableJSTypeName(owner, true), rightType, leftType);
        }
        return false;
    }
    return true;
}","public void test3137() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.REGEXP_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Named type with empty name component"", jSType0);
    Compiler compiler0 = new Compiler();
    Denormalize denormalize0 = new Denormalize(compiler0);
    Node node0 = compiler0.parseTestCode("""");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
    EnumType enumType1 = jSTypeRegistry0.createEnumType(""Not declared as a constructor"", enumType0);
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, enumType1, enumType0, node0, ""Named type with empty name component"");
    assertFalse(boolean0);
}","/**
 * Expect that the first type can be assigned to a symbol of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param owner The owner of the property being assigned to.
 * @param propName The name of the property being assigned to.
 * @return True if the types matched, false otherwise.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test3138() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.REGEXP_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Named type with empty name component"", jSType0);
    Compiler compiler0 = new Compiler();
    Denormalize denormalize0 = new Denormalize(compiler0);
    Node node0 = compiler0.parseTestCode("""");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
    EnumType enumType1 = jSTypeRegistry0.createEnumType(""Not declared as a constructor"", enumType0);
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, enumType1, enumType0, node0, ""Named type with empty name component"");
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {
    if (!rightType.canAssignTo(leftType)) {
        if (bothIntrinsics(rightType, leftType)) {
            // We have a superior warning for this mistake, which gives you
            // the line numbers of both types.
            registerMismatch(rightType, leftType);
        } else {
            mismatch(t, n, msg, rightType, leftType);
        }
        return false;
    }
    return true;
}","public void test3239() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("""");
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) null, node0);
    boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, node0, functionType0, functionType0, ""Unknown class name"");
    assertTrue(boolean0);
}","/**
 * Expect that the first type can be assigned to a symbol of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param msg An extra message for the mismatch warning, if necessary.
 * @return True if the types matched, false otherwise.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test3340() throws Throwable {
    Compiler compiler0 = new Compiler();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.REGEXP_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    Denormalize denormalize0 = new Denormalize(compiler0);
    Node node0 = compiler0.parseTestCode(""Named type with empty name component"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, node0, jSType0, functionType0, ""Named type with empty name component"");
    assertTrue(functionType0.hasCachedValues());
}",""
"boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {
    if (!rightType.canAssignTo(leftType)) {
        if (bothIntrinsics(rightType, leftType)) {
            // We have a superior warning for this mistake, which gives you
            // the line numbers of both types.
            registerMismatch(rightType, leftType);
        } else {
            mismatch(t, n, msg, rightType, leftType);
        }
        return false;
    }
    return true;
}","public void test3341() throws Throwable {
    Compiler compiler0 = new Compiler();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.REGEXP_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    Denormalize denormalize0 = new Denormalize(compiler0);
    Node node0 = compiler0.parseTestCode(""Named type with empty name component"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, node0, jSType0, functionType0, ""Named type with empty name component"");
    assertFalse(boolean0);
}","/**
 * Expect that the first type can be assigned to a symbol of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param msg An extra message for the mismatch warning, if necessary.
 * @return True if the types matched, false otherwise.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test3442() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Named type with empty name component"");
    JSTypeNative jSTypeNative0 = JSTypeNative.ARRAY_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    GroupVariableDeclarations groupVariableDeclarations0 = new GroupVariableDeclarations(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, groupVariableDeclarations0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, node0, functionType0, noType0, ""Not declared as a type name"");
    assertTrue(noType0.hasCachedValues());
}",""
"boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {
    if (!rightType.canAssignTo(leftType)) {
        if (bothIntrinsics(rightType, leftType)) {
            // We have a superior warning for this mistake, which gives you
            // the line numbers of both types.
            registerMismatch(rightType, leftType);
        } else {
            mismatch(t, n, msg, rightType, leftType);
        }
        return false;
    }
    return true;
}","public void test3443() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Named type with empty name component"");
    JSTypeNative jSTypeNative0 = JSTypeNative.ARRAY_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    GroupVariableDeclarations groupVariableDeclarations0 = new GroupVariableDeclarations(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, groupVariableDeclarations0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, node0, functionType0, noType0, ""Not declared as a type name"");
    assertFalse(boolean0);
}","/**
 * Expect that the first type can be assigned to a symbol of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param msg An extra message for the mismatch warning, if necessary.
 * @return True if the types matched, false otherwise.
 */"
"public boolean isQuotedString() {
    return false;
}","public void test3544() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Named type with empty name component"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    typeValidator0.expectArgumentMatchesParameter(nodeTraversal0, node0, jSType0, jSType0, node0, 6);
    assertFalse(node0.isQuotedString());
}","/**
 * This should only be called for STRING nodes children of OBJECTLIT.
 */"
"void expectArgumentMatchesParameter(NodeTraversal t, Node n, JSType argType, JSType paramType, Node callNode, int ordinal) {
    if (!argType.canAssignTo(paramType)) {
        mismatch(t, n, String.format(""actual parameter %d of %s does not match "" + ""formal parameter"", ordinal, getReadableJSTypeName(callNode.getFirstChild(), false)), argType, paramType);
    }
}","public void test3645() throws Throwable {
    Compiler compiler0 = new Compiler();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    Denormalize denormalize0 = new Denormalize(compiler0);
    Node node0 = compiler0.parseTestCode(""Named type with empty name component"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    // Undeclared exception!
    try {
        typeValidator0.expectArgumentMatchesParameter(nodeTraversal0, node0, jSType0, functionType0, node0, 1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeValidator"", e);
    }
}","/**
 * Expect that the type of an argument matches the type of the parameter
 * that it's fulfilling.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param argType The type of the argument.
 * @param paramType The type of the parameter.
 * @param callNode The call node, to help with the warning message.
 * @param ordinal The argument ordinal, to help with the warning message.
 */"
"void expectCanOverride(NodeTraversal t, Node n, JSType overridingType, JSType hiddenType, String propertyName, JSType ownerType) {
    if (!overridingType.canAssignTo(hiddenType)) {
        registerMismatch(overridingType, hiddenType);
        if (shouldReport) {
            compiler.report(t.makeError(n, HIDDEN_PROPERTY_MISMATCH, propertyName, ownerType.toString(), hiddenType.toString(), overridingType.toString()));
        }
    }
}","public void test3746() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Unknown class name"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    typeValidator0.expectCanOverride((NodeTraversal) null, node0, jSType0, jSType0, ""Not declared as a type name"", jSType0);
    assertEquals(43, Node.IS_OPTIONAL_PARAM);
}","/**
 * Expect that the first type can override a property of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param overridingType The overriding type.
 * @param hiddenType The type of the property being overridden.
 * @param propertyName The name of the property, for use in the
 *     warning message.
 * @param ownerType The type of the owner of the property, for use
 *     in the warning message.
 */"
"void expectSuperType(NodeTraversal t, Node n, ObjectType superObject, ObjectType subObject) {
    FunctionType subCtor = subObject.getConstructor();
    ObjectType declaredSuper = subObject.getImplicitPrototype().getImplicitPrototype();
    if (!declaredSuper.equals(superObject)) {
        if (declaredSuper.equals(getNativeType(OBJECT_TYPE))) {
            if (shouldReport) {
                compiler.report(t.makeError(n, MISSING_EXTENDS_TAG_WARNING, subObject.toString()));
            }
            registerMismatch(superObject, declaredSuper);
        } else {
            mismatch(t.getSourceName(), n, ""mismatch in declaration of superclass type"", superObject, declaredSuper);
        }
        // Correct the super type.
        if (!subCtor.hasCachedValues()) {
            subCtor.setPrototypeBasedOn(superObject);
        }
    }
}","public void test3847() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode("" nly arrays*Or ob1ecFscan ce acce(sed"", "" nly arrays*Or ob1ecFscan ce acce(sed"");
    UnfoldCompoundAssignments unfoldCompoundAssignments0 = new UnfoldCompoundAssignments(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unfoldCompoundAssignments0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    JSType[] jSTypeArray0 = new JSType[7];
    jSTypeArray0[6] = (JSType) functionType0;
    FunctionType functionType1 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) null, jSTypeArray0);
    ObjectType objectType0 = jSTypeRegistry0.createObjectType((ObjectType) functionType1);
    typeValidator0.expectSuperType(nodeTraversal0, node0, functionType0, objectType0);
    assertEquals(1, Node.DECR_FLAG);
}","/**
 * Expect that the first type is the direct superclass of the second type.
 *
 * @param t The node traversal.
 * @param n The node where warnings should point to.
 * @param superObject The expected super instance type.
 * @param subObject The sub instance type.
 */"
"void expectSuperType(NodeTraversal t, Node n, ObjectType superObject, ObjectType subObject) {
    FunctionType subCtor = subObject.getConstructor();
    ObjectType declaredSuper = subObject.getImplicitPrototype().getImplicitPrototype();
    if (!declaredSuper.equals(superObject)) {
        if (declaredSuper.equals(getNativeType(OBJECT_TYPE))) {
            if (shouldReport) {
                compiler.report(t.makeError(n, MISSING_EXTENDS_TAG_WARNING, subObject.toString()));
            }
            registerMismatch(superObject, declaredSuper);
        } else {
            mismatch(t.getSourceName(), n, ""mismatch in declaration of superclass type"", superObject, declaredSuper);
        }
        // Correct the super type.
        if (!subCtor.hasCachedValues()) {
            subCtor.setPrototypeBasedOn(superObject);
        }
    }
}","public void test3948() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("""");
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) null, node0);
    // Undeclared exception!
    try {
        typeValidator0.expectSuperType(nodeTraversal0, node0, functionType0, functionType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeValidator"", e);
    }
}","/**
 * Expect that the first type is the direct superclass of the second type.
 *
 * @param t The node traversal.
 * @param n The node where warnings should point to.
 * @param superObject The expected super instance type.
 * @param subObject The sub instance type.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test4049() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode("" nly \""rrays*Or ob1ecFscan ce acce(sed"", "" nly \""rrays*Or ob1ecFscan ce acce(sed"");
    UnfoldCompoundAssignments unfoldCompoundAssignments0 = new UnfoldCompoundAssignments(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unfoldCompoundAssignments0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    typeValidator0.expectSuperType(nodeTraversal0, node0, functionType0, functionType0);
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test4150() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode("" nly \""rrays*Or ob1ecFscan ce acce(sed"", "" nly \""rrays*Or ob1ecFscan ce acce(sed"");
    UnfoldCompoundAssignments unfoldCompoundAssignments0 = new UnfoldCompoundAssignments(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, unfoldCompoundAssignments0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
    typeValidator0.setShouldReport(false);
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    typeValidator0.expectSuperType(nodeTraversal0, node0, functionType0, functionType0);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test4251() throws Throwable {
    Compiler compiler0 = new Compiler();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.ALL_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    Denormalize denormalize0 = new Denormalize(compiler0);
    Node node0 = compiler0.parseTestCode(""Named type with empty name component"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    typeValidator0.expectCanCast(nodeTraversal0, node0, functionType0, jSType0);
    assertFalse(functionType0.hasCachedValues());
}",""
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test4252() throws Throwable {
    Compiler compiler0 = new Compiler();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.ALL_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    Denormalize denormalize0 = new Denormalize(compiler0);
    Node node0 = compiler0.parseTestCode(""Named type with empty name component"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    typeValidator0.expectCanCast(nodeTraversal0, node0, functionType0, jSType0);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test4353() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Not declared as a type name"");
    Denormalize denormalize0 = new Denormalize(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) noType0, (List<JSType>) linkedList0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    typeValidator0.expectCanCast(nodeTraversal0, node0, functionType0, noType0);
    assertTrue(noType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test4354() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Not declared as a type name"");
    Denormalize denormalize0 = new Denormalize(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs((JSType) noType0, (List<JSType>) linkedList0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    typeValidator0.expectCanCast(nodeTraversal0, node0, functionType0, noType0);
    assertFalse(functionType0.hasCachedValues());
}",""
"void expectUndeclaredVariable(String sourceName, Node n, Node parent, Var var, String variableName, JSType newType) {
    boolean allowDupe = false;
    if (n.getType() == Token.GETPROP) {
        JSDocInfo info = n.getJSDocInfo();
        if (info == null) {
            info = parent.getJSDocInfo();
        }
        allowDupe = info != null && info.getSuppressions().contains(""duplicate"");
    }
    JSType varType = var.getType();
    // Only report duplicate declarations that have types. Other duplicates
    // will be reported by the syntactic scope creator later in the
    // compilation process.
    if (varType != null && varType != typeRegistry.getNativeType(UNKNOWN_TYPE) && newType != null && newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) {
        // If there are two typed declarations of the same variable, that
        // is an error and the second declaration is ignored, except in the
        // case of native types. A null input type means that the declaration
        // was made in TypedScopeCreator#createInitialScope and is a
        // native type.
        if (var.input == null) {
            n.setJSType(varType);
            if (parent.getType() == Token.VAR) {
                if (n.getFirstChild() != null) {
                    n.getFirstChild().setJSType(varType);
                }
            } else {
                Preconditions.checkState(parent.getType() == Token.FUNCTION);
                parent.setJSType(varType);
            }
        } else {
            // Always warn about duplicates if the overridden type does not
            // match the original type.
            //
            // If the types match, suppress the warning iff there was a @suppress
            // tag, or if the original declaration was a stub.
            if (!(allowDupe || var.getParentNode().getType() == Token.EXPR_RESULT) || !newType.equals(varType)) {
                if (shouldReport) {
                    compiler.report(JSError.make(sourceName, n, DUP_VAR_DECLARATION, variableName, newType.toString(), var.getInputName(), String.valueOf(var.nameNode.getLineno()), varType.toString()));
                }
            }
        }
    }
}","public void test4455() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Not declared as a type name"");
    Scope scope0 = new Scope(node0, noType0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    Scope.Var scope_Var0 = scope0.declare(""kd0R7KXL)JtA|os=\""f"", node0, noType0, (CompilerInput) null, true);
    // Undeclared exception!
    try {
        typeValidator0.expectUndeclaredVariable(""<k;vjYdTDAt^gO"", node0, node0, scope_Var0, ""kd0R7KXL)JtA|os=\""f"", noType0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Expect that the given variable has not been declared with a type.
 *
 * @param sourceName The name of the source file we're in.
 * @param n The node where warnings should point to.
 * @param parent The parent of {@code n}.
 * @param var The variable that we're checking.
 * @param variableName The name of the variable.
 * @param newType The type being applied to the variable. Mostly just here
 *     for the benefit of the warning.
 */"
"void expectUndeclaredVariable(String sourceName, Node n, Node parent, Var var, String variableName, JSType newType) {
    boolean allowDupe = false;
    if (n.getType() == Token.GETPROP) {
        JSDocInfo info = n.getJSDocInfo();
        if (info == null) {
            info = parent.getJSDocInfo();
        }
        allowDupe = info != null && info.getSuppressions().contains(""duplicate"");
    }
    JSType varType = var.getType();
    // Only report duplicate declarations that have types. Other duplicates
    // will be reported by the syntactic scope creator later in the
    // compilation process.
    if (varType != null && varType != typeRegistry.getNativeType(UNKNOWN_TYPE) && newType != null && newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) {
        // If there are two typed declarations of the same variable, that
        // is an error and the second declaration is ignored, except in the
        // case of native types. A null input type means that the declaration
        // was made in TypedScopeCreator#createInitialScope and is a
        // native type.
        if (var.input == null) {
            n.setJSType(varType);
            if (parent.getType() == Token.VAR) {
                if (n.getFirstChild() != null) {
                    n.getFirstChild().setJSType(varType);
                }
            } else {
                Preconditions.checkState(parent.getType() == Token.FUNCTION);
                parent.setJSType(varType);
            }
        } else {
            // Always warn about duplicates if the overridden type does not
            // match the original type.
            //
            // If the types match, suppress the warning iff there was a @suppress
            // tag, or if the original declaration was a stub.
            if (!(allowDupe || var.getParentNode().getType() == Token.EXPR_RESULT) || !newType.equals(varType)) {
                if (shouldReport) {
                    compiler.report(JSError.make(sourceName, n, DUP_VAR_DECLARATION, variableName, newType.toString(), var.getInputName(), String.valueOf(var.nameNode.getLineno()), varType.toString()));
                }
            }
        }
    }
}","public void test4556() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""Unknown class name"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    Node node0 = new Node(33);
    // Undeclared exception!
    try {
        typeValidator0.expectUndeclaredVariable(""Unknown class name"", node0, node0, (Scope.Var) null, ""Not declared as a type name"", jSType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeValidator"", e);
    }
}","/**
 * Expect that the given variable has not been declared with a type.
 *
 * @param sourceName The name of the source file we're in.
 * @param n The node where warnings should point to.
 * @param parent The parent of {@code n}.
 * @param var The variable that we're checking.
 * @param variableName The name of the variable.
 * @param newType The type being applied to the variable. Mostly just here
 *     for the benefit of the warning.
 */"
"void expectUndeclaredVariable(String sourceName, Node n, Node parent, Var var, String variableName, JSType newType) {
    boolean allowDupe = false;
    if (n.getType() == Token.GETPROP) {
        JSDocInfo info = n.getJSDocInfo();
        if (info == null) {
            info = parent.getJSDocInfo();
        }
        allowDupe = info != null && info.getSuppressions().contains(""duplicate"");
    }
    JSType varType = var.getType();
    // Only report duplicate declarations that have types. Other duplicates
    // will be reported by the syntactic scope creator later in the
    // compilation process.
    if (varType != null && varType != typeRegistry.getNativeType(UNKNOWN_TYPE) && newType != null && newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) {
        // If there are two typed declarations of the same variable, that
        // is an error and the second declaration is ignored, except in the
        // case of native types. A null input type means that the declaration
        // was made in TypedScopeCreator#createInitialScope and is a
        // native type.
        if (var.input == null) {
            n.setJSType(varType);
            if (parent.getType() == Token.VAR) {
                if (n.getFirstChild() != null) {
                    n.getFirstChild().setJSType(varType);
                }
            } else {
                Preconditions.checkState(parent.getType() == Token.FUNCTION);
                parent.setJSType(varType);
            }
        } else {
            // Always warn about duplicates if the overridden type does not
            // match the original type.
            //
            // If the types match, suppress the warning iff there was a @suppress
            // tag, or if the original declaration was a stub.
            if (!(allowDupe || var.getParentNode().getType() == Token.EXPR_RESULT) || !newType.equals(varType)) {
                if (shouldReport) {
                    compiler.report(JSError.make(sourceName, n, DUP_VAR_DECLARATION, variableName, newType.toString(), var.getInputName(), String.valueOf(var.nameNode.getLineno()), varType.toString()));
                }
            }
        }
    }
}","public void test4657() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""SBx' "", ""SBx' "");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    Scope scope0 = new Scope(node0, compiler0);
    Scope.Var scope_Var0 = scope0.declare(""#I-"", node0, (JSType) null, (CompilerInput) null);
    typeValidator0.expectUndeclaredVariable(""SBx' "", node0, node0, scope_Var0, ""JSC_DUP_VAR_DECLARATION"", (JSType) null);
    assertEquals(40, Node.BRACELESS_TYPE);
}","/**
 * Expect that the given variable has not been declared with a type.
 *
 * @param sourceName The name of the source file we're in.
 * @param n The node where warnings should point to.
 * @param parent The parent of {@code n}.
 * @param var The variable that we're checking.
 * @param variableName The name of the variable.
 * @param newType The type being applied to the variable. Mostly just here
 *     for the benefit of the warning.
 */"
"void expectUndeclaredVariable(String sourceName, Node n, Node parent, Var var, String variableName, JSType newType) {
    boolean allowDupe = false;
    if (n.getType() == Token.GETPROP) {
        JSDocInfo info = n.getJSDocInfo();
        if (info == null) {
            info = parent.getJSDocInfo();
        }
        allowDupe = info != null && info.getSuppressions().contains(""duplicate"");
    }
    JSType varType = var.getType();
    // Only report duplicate declarations that have types. Other duplicates
    // will be reported by the syntactic scope creator later in the
    // compilation process.
    if (varType != null && varType != typeRegistry.getNativeType(UNKNOWN_TYPE) && newType != null && newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) {
        // If there are two typed declarations of the same variable, that
        // is an error and the second declaration is ignored, except in the
        // case of native types. A null input type means that the declaration
        // was made in TypedScopeCreator#createInitialScope and is a
        // native type.
        if (var.input == null) {
            n.setJSType(varType);
            if (parent.getType() == Token.VAR) {
                if (n.getFirstChild() != null) {
                    n.getFirstChild().setJSType(varType);
                }
            } else {
                Preconditions.checkState(parent.getType() == Token.FUNCTION);
                parent.setJSType(varType);
            }
        } else {
            // Always warn about duplicates if the overridden type does not
            // match the original type.
            //
            // If the types match, suppress the warning iff there was a @suppress
            // tag, or if the original declaration was a stub.
            if (!(allowDupe || var.getParentNode().getType() == Token.EXPR_RESULT) || !newType.equals(varType)) {
                if (shouldReport) {
                    compiler.report(JSError.make(sourceName, n, DUP_VAR_DECLARATION, variableName, newType.toString(), var.getInputName(), String.valueOf(var.nameNode.getLineno()), varType.toString()));
                }
            }
        }
    }
}","public void test4758() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode("" nly \""rrays*Or ob1ecFscan ce acce(sed"", "" nly \""rrays*Or ob1ecFscan ce acce(sed"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    Scope scope0 = new Scope(node0, compiler0);
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Unknown class name"", functionType0);
    EnumElementType enumElementType0 = enumType0.getElementsType();
    JSType jSType0 = enumElementType0.getPropertyType(""Not declared as a type name"");
    Charset charset0 = Charset.defaultCharset();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""S63MumJVF_q[` sQ\""f"", charset0);
    CompilerInput compilerInput0 = new CompilerInput(jSSourceFile0, false);
    Scope.Var scope_Var0 = scope0.declare(""EP"", node0, jSType0, compilerInput0, false);
    typeValidator0.expectUndeclaredVariable("""", node0, node0, scope_Var0, ""S63MumJVF_q[` sQ\""f"", enumElementType0);
    assertEquals(6, Node.TEMP_PROP);
}","/**
 * Expect that the given variable has not been declared with a type.
 *
 * @param sourceName The name of the source file we're in.
 * @param n The node where warnings should point to.
 * @param parent The parent of {@code n}.
 * @param var The variable that we're checking.
 * @param variableName The name of the variable.
 * @param newType The type being applied to the variable. Mostly just here
 *     for the benefit of the warning.
 */"
"void expectUndeclaredVariable(String sourceName, Node n, Node parent, Var var, String variableName, JSType newType) {
    boolean allowDupe = false;
    if (n.getType() == Token.GETPROP) {
        JSDocInfo info = n.getJSDocInfo();
        if (info == null) {
            info = parent.getJSDocInfo();
        }
        allowDupe = info != null && info.getSuppressions().contains(""duplicate"");
    }
    JSType varType = var.getType();
    // Only report duplicate declarations that have types. Other duplicates
    // will be reported by the syntactic scope creator later in the
    // compilation process.
    if (varType != null && varType != typeRegistry.getNativeType(UNKNOWN_TYPE) && newType != null && newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) {
        // If there are two typed declarations of the same variable, that
        // is an error and the second declaration is ignored, except in the
        // case of native types. A null input type means that the declaration
        // was made in TypedScopeCreator#createInitialScope and is a
        // native type.
        if (var.input == null) {
            n.setJSType(varType);
            if (parent.getType() == Token.VAR) {
                if (n.getFirstChild() != null) {
                    n.getFirstChild().setJSType(varType);
                }
            } else {
                Preconditions.checkState(parent.getType() == Token.FUNCTION);
                parent.setJSType(varType);
            }
        } else {
            // Always warn about duplicates if the overridden type does not
            // match the original type.
            //
            // If the types match, suppress the warning iff there was a @suppress
            // tag, or if the original declaration was a stub.
            if (!(allowDupe || var.getParentNode().getType() == Token.EXPR_RESULT) || !newType.equals(varType)) {
                if (shouldReport) {
                    compiler.report(JSError.make(sourceName, n, DUP_VAR_DECLARATION, variableName, newType.toString(), var.getInputName(), String.valueOf(var.nameNode.getLineno()), varType.toString()));
                }
            }
        }
    }
}","public void test4859() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Unknown class name"");
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""Named type with empty name component"");
    CompilerInput compilerInput0 = new CompilerInput(jSSourceFile0, false);
    Scope scope0 = new Scope(node0, noType0);
    Scope.Var scope_Var0 = scope0.declare(""Named type with empty name component"", node0, noType0, compilerInput0, false);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    typeValidator0.expectUndeclaredVariable(""Named type with empty name component"", node0, node0, scope_Var0, ""Not declared as a type name"", (JSType) null);
    assertEquals(40, Node.BRACELESS_TYPE);
}","/**
 * Expect that the given variable has not been declared with a type.
 *
 * @param sourceName The name of the source file we're in.
 * @param n The node where warnings should point to.
 * @param parent The parent of {@code n}.
 * @param var The variable that we're checking.
 * @param variableName The name of the variable.
 * @param newType The type being applied to the variable. Mostly just here
 *     for the benefit of the warning.
 */"
"public boolean isConstructor() {
    return false;
}","public void test4960() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Named type with empty name component"");
    Scope scope0 = new Scope(node0, noType0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    Scope.Var scope_Var0 = scope0.declare(""_nD1HOfPD"", node0, noType0, (CompilerInput) null, true);
    NameReferenceGraphConstruction nameReferenceGraphConstruction0 = new NameReferenceGraphConstruction(compiler0);
    NameReferenceGraph nameReferenceGraph0 = nameReferenceGraphConstruction0.getNameReferenceGraph();
    NameReferenceGraph.Name nameReferenceGraph_Name0 = nameReferenceGraph0.WINDOW;
    UnknownType unknownType0 = (UnknownType) nameReferenceGraph_Name0.getType();
    typeValidator0.expectUndeclaredVariable("""", node0, node0, scope_Var0, """", unknownType0);
    assertFalse(unknownType0.isConstructor());
}","/**
 * Whether this type is a {@link FunctionType} that is a constructor or a
 * named type that points to such a type.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test5061() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Not declared as a type name"");
    Scope scope0 = new Scope(node0, noType0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    Node node1 = new Node(118, node0, node0, node0, 7, 4095);
    Scope.Var scope_Var0 = scope0.declare(""kd0R7KXL)JtA|os=\""f"", node0, noType0, (CompilerInput) null, true);
    typeValidator0.expectUndeclaredVariable(""<k;vjYdTDAt^gO"", node1, node1, scope_Var0, ""kd0R7KXL)JtA|os=\""f"", noType0);
    typeValidator0.getReadableJSTypeName(node0, true);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test5162() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Not declared as a type name"");
    Scope scope0 = new Scope(node0, noType0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    Node node1 = new Node(118, node0, node0, node0, 7, 4095);
    Scope.Var scope_Var0 = scope0.declare(""kd0R7KXL)JtA|os=\""f"", node0, noType0, (CompilerInput) null, true);
    typeValidator0.expectUndeclaredVariable(""kd0R7KXL)JtA|os=\""f"", node0, node1, scope_Var0, ""*[[2?!+4~yQ"", noType0);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test5263() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Unknown class name"");
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""Named type with empty name component"");
    CompilerInput compilerInput0 = new CompilerInput(jSSourceFile0, true);
    Scope scope0 = new Scope(node0, noType0);
    Scope.Var scope_Var0 = scope0.declare(""Named type with empty name component"", node0, noType0, compilerInput0, true);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    Node node1 = new Node(1, node0, 4095, 10);
    typeValidator0.expectUndeclaredVariable(""Not declared as a constructor"", node0, node1, scope_Var0, ""Not declared as a constructor"", noType0);
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"void expectUndeclaredVariable(String sourceName, Node n, Node parent, Var var, String variableName, JSType newType) {
    boolean allowDupe = false;
    if (n.getType() == Token.GETPROP) {
        JSDocInfo info = n.getJSDocInfo();
        if (info == null) {
            info = parent.getJSDocInfo();
        }
        allowDupe = info != null && info.getSuppressions().contains(""duplicate"");
    }
    JSType varType = var.getType();
    // Only report duplicate declarations that have types. Other duplicates
    // will be reported by the syntactic scope creator later in the
    // compilation process.
    if (varType != null && varType != typeRegistry.getNativeType(UNKNOWN_TYPE) && newType != null && newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) {
        // If there are two typed declarations of the same variable, that
        // is an error and the second declaration is ignored, except in the
        // case of native types. A null input type means that the declaration
        // was made in TypedScopeCreator#createInitialScope and is a
        // native type.
        if (var.input == null) {
            n.setJSType(varType);
            if (parent.getType() == Token.VAR) {
                if (n.getFirstChild() != null) {
                    n.getFirstChild().setJSType(varType);
                }
            } else {
                Preconditions.checkState(parent.getType() == Token.FUNCTION);
                parent.setJSType(varType);
            }
        } else {
            // Always warn about duplicates if the overridden type does not
            // match the original type.
            //
            // If the types match, suppress the warning iff there was a @suppress
            // tag, or if the original declaration was a stub.
            if (!(allowDupe || var.getParentNode().getType() == Token.EXPR_RESULT) || !newType.equals(varType)) {
                if (shouldReport) {
                    compiler.report(JSError.make(sourceName, n, DUP_VAR_DECLARATION, variableName, newType.toString(), var.getInputName(), String.valueOf(var.nameNode.getLineno()), varType.toString()));
                }
            }
        }
    }
}","public void test5364() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Unknown class name"");
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""Named type with empty name component"");
    CompilerInput compilerInput0 = new CompilerInput(jSSourceFile0, false);
    Scope scope0 = new Scope(node0, noType0);
    Scope.Var scope_Var0 = scope0.declare(""Named type with empty name component"", node0, noType0, compilerInput0, false);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    Node node1 = new Node(130, node0, node0, node0, 34, 44);
    typeValidator0.expectUndeclaredVariable(""Not declared as a constructor"", node1, node1, scope_Var0, ""Not declared as a constructor"", noType0);
    assertEquals(1, Node.DECR_FLAG);
}","/**
 * Expect that the given variable has not been declared with a type.
 *
 * @param sourceName The name of the source file we're in.
 * @param n The node where warnings should point to.
 * @param parent The parent of {@code n}.
 * @param var The variable that we're checking.
 * @param variableName The name of the variable.
 * @param newType The type being applied to the variable. Mostly just here
 *     for the benefit of the warning.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test5465() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Unknown class name"");
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""Named type with empty name component"");
    CompilerInput compilerInput0 = new CompilerInput(jSSourceFile0, false);
    Scope scope0 = new Scope(node0, noType0);
    Scope.Var scope_Var0 = scope0.declare(""Named type with empty name component"", node0, noType0, compilerInput0, false);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    Node node1 = new Node(130, node0, node0, node0, 34, 44);
    Vector<JSType> vector0 = new Vector<JSType>();
    FunctionType functionType0 = (FunctionType) jSTypeRegistry0.createFunctionTypeWithVarArgs((ObjectType) noType0, (JSType) noType0, (List<JSType>) vector0);
    typeValidator0.expectUndeclaredVariable(""kI`}oOzsS"", node0, node1, scope_Var0, """", functionType0);
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"void expectAllInterfaceProperties(NodeTraversal t, Node n, FunctionType type) {
    ObjectType instance = type.getInstanceType();
    for (ObjectType implemented : type.getAllImplementedInterfaces()) {
        if (implemented.getImplicitPrototype() != null) {
            for (String prop : implemented.getImplicitPrototype().getOwnPropertyNames()) {
                expectInterfaceProperty(t, n, instance, implemented, prop);
            }
        }
    }
}","public void test5566() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[0];
    NoType noType0 = (NoType) jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Named type with empty name component"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    typeValidator0.expectAllInterfaceProperties((NodeTraversal) null, node0, noType0);
    assertEquals(4, Node.DESCENDANTS_FLAG);
}","/**
 * Expect that all properties on interfaces that this type implements are
 * implemented and correctly typed.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test5667() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""actual parameter %d of %s does not match formal parameter"", ""actual parameter %d of %s does not match formal parameter"");
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    typeValidator0.setShouldReport(false);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_CONSTRUCTOR_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    typeValidator0.expectIndexMatch(nodeTraversal0, node0, functionType0, functionType0);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"@Override
public boolean hasCachedValues() {
    return prototype != null || super.hasCachedValues();
}","public void test5768() throws Throwable {
    Compiler compiler0 = new Compiler();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    Denormalize denormalize0 = new Denormalize(compiler0);
    Node node0 = compiler0.parseTestCode(""Named type with empty name component"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    typeValidator0.expectCanCast(nodeTraversal0, node0, jSType0, functionType0);
    assertTrue(functionType0.hasCachedValues());
}",""
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test5769() throws Throwable {
    Compiler compiler0 = new Compiler();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    Denormalize denormalize0 = new Denormalize(compiler0);
    Node node0 = compiler0.parseTestCode(""Named type with empty name component"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, denormalize0);
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    FunctionType functionType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(jSType0, (List<JSType>) linkedList0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    typeValidator0.expectCanCast(nodeTraversal0, node0, jSType0, functionType0);
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test5870() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Not declared as a constructor"");
    JSTypeNative jSTypeNative1 = JSTypeNative.ARRAY_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative1);
    GroupVariableDeclarations groupVariableDeclarations0 = new GroupVariableDeclarations(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, groupVariableDeclarations0);
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    typeValidator0.expectCanOverride(nodeTraversal0, node0, jSType0, functionType0, ""Unknown class name"", jSType0);
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"String getReadableJSTypeName(Node n, boolean dereference) {
    // If we're analyzing a GETPROP, the property may be inherited by the
    // prototype chain. So climb the prototype chain and find out where
    // the property was originally defined.
    if (n.getType() == Token.GETPROP) {
        ObjectType objectType = getJSType(n.getFirstChild()).dereference();
        if (objectType != null) {
            String propName = n.getLastChild().getString();
            while (objectType != null && !objectType.hasOwnProperty(propName)) {
                objectType = objectType.getImplicitPrototype();
            }
            // Don't show complex function names or anonymous types.
            // Instead, try to get a human-readable type name.
            if (objectType != null && (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) {
                return objectType.toString() + ""."" + propName;
            }
        }
    }
    JSType type = getJSType(n);
    if (dereference) {
        ObjectType dereferenced = type.dereference();
        if (dereferenced != null) {
            type = dereferenced;
        }
    }
    String qualifiedName = n.getQualifiedName();
    if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) {
        return type.toString();
    } else if (qualifiedName != null) {
        return qualifiedName;
    } else if (type instanceof FunctionType) {
        // Don't show complex function names.
        return ""function"";
    } else {
        return type.toString();
    }
}","public void test5971() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""Unknown class name"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    Node node0 = new Node(33);
    Node node1 = Node.newString(45, ""Unknown class name"");
    node0.addChildrenToFront(node1);
    String string0 = typeValidator0.getReadableJSTypeName(node0, true);
    assertNotNull(string0);
}","/**
 * Given a node, get a human-readable name for the type of that node so
 * that will be easy for the programmer to find the original declaration.
 *
 * For example, if SubFoo's property ""bar"" might have the human-readable
 * name ""Foo.prototype.bar"".
 *
 * @param n The node.
 * @param dereference If true, the type of the node will be dereferenced
 *     to an Object type, if possible.
 */"
"String getReadableJSTypeName(Node n, boolean dereference) {
    // If we're analyzing a GETPROP, the property may be inherited by the
    // prototype chain. So climb the prototype chain and find out where
    // the property was originally defined.
    if (n.getType() == Token.GETPROP) {
        ObjectType objectType = getJSType(n.getFirstChild()).dereference();
        if (objectType != null) {
            String propName = n.getLastChild().getString();
            while (objectType != null && !objectType.hasOwnProperty(propName)) {
                objectType = objectType.getImplicitPrototype();
            }
            // Don't show complex function names or anonymous types.
            // Instead, try to get a human-readable type name.
            if (objectType != null && (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) {
                return objectType.toString() + ""."" + propName;
            }
        }
    }
    JSType type = getJSType(n);
    if (dereference) {
        ObjectType dereferenced = type.dereference();
        if (dereferenced != null) {
            type = dereferenced;
        }
    }
    String qualifiedName = n.getQualifiedName();
    if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) {
        return type.toString();
    } else if (qualifiedName != null) {
        return qualifiedName;
    } else if (type instanceof FunctionType) {
        // Don't show complex function names.
        return ""function"";
    } else {
        return type.toString();
    }
}","public void test6072() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""~,,[QIF.L&A"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    String string0 = typeValidator0.getReadableJSTypeName(node0, false);
    assertNotNull(string0);
}","/**
 * Given a node, get a human-readable name for the type of that node so
 * that will be easy for the programmer to find the original declaration.
 *
 * For example, if SubFoo's property ""bar"" might have the human-readable
 * name ""Foo.prototype.bar"".
 *
 * @param n The node.
 * @param dereference If true, the type of the node will be dereferenced
 *     to an Object type, if possible.
 */"
"String getReadableJSTypeName(Node n, boolean dereference) {
    // If we're analyzing a GETPROP, the property may be inherited by the
    // prototype chain. So climb the prototype chain and find out where
    // the property was originally defined.
    if (n.getType() == Token.GETPROP) {
        ObjectType objectType = getJSType(n.getFirstChild()).dereference();
        if (objectType != null) {
            String propName = n.getLastChild().getString();
            while (objectType != null && !objectType.hasOwnProperty(propName)) {
                objectType = objectType.getImplicitPrototype();
            }
            // Don't show complex function names or anonymous types.
            // Instead, try to get a human-readable type name.
            if (objectType != null && (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) {
                return objectType.toString() + ""."" + propName;
            }
        }
    }
    JSType type = getJSType(n);
    if (dereference) {
        ObjectType dereferenced = type.dereference();
        if (dereferenced != null) {
            type = dereferenced;
        }
    }
    String qualifiedName = n.getQualifiedName();
    if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) {
        return type.toString();
    } else if (qualifiedName != null) {
        return qualifiedName;
    } else if (type instanceof FunctionType) {
        // Don't show complex function names.
        return ""function"";
    } else {
        return type.toString();
    }
}","public void test6173() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseSyntheticCode(""actual parameter %d of %s does not match formal parameter"", ""actual parameter %d of %s does not match formal parameter"");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    Node node0 = new Node(42);
    String string0 = typeValidator0.getReadableJSTypeName(node0, true);
    assertEquals(""this"", string0);
}","/**
 * Given a node, get a human-readable name for the type of that node so
 * that will be easy for the programmer to find the original declaration.
 *
 * For example, if SubFoo's property ""bar"" might have the human-readable
 * name ""Foo.prototype.bar"".
 *
 * @param n The node.
 * @param dereference If true, the type of the node will be dereferenced
 *     to an Object type, if possible.
 */"
