focal_method,test_prefix,docstring
"public Result compile(JSSourceFile[] externs, JSSourceFile[] inputs, CompilerOptions options) {
    // The compile method should only be called once.
    Preconditions.checkState(jsRoot == null);
    try {
        init(externs, inputs, options);
        if (hasErrors()) {
            return getResult();
        }
        return compile();
    } finally {
        Tracer t = newTracer(""generateReport"");
        errorManager.generateReport();
        stopTracer(t, ""generateReport"");
    }
}","public void test000() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[0];
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFileArray0, jSSourceFileArray0, compilerOptions0);
    // Undeclared exception!
    try {
        compiler0.compile(jSSourceFileArray0, jSSourceFileArray0, compilerOptions0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Compiles a list of inputs.
 */"
"public String toSource(final JSModule module) {
    return runInCompilerThread(new Callable<String>() {

        public String call() throws Exception {
            List<CompilerInput> inputs = module.getInputs();
            int numInputs = inputs.size();
            if (numInputs == 0) {
                return """";
            }
            CodeBuilder cb = new CodeBuilder();
            for (int i = 0; i < numInputs; i++) {
                Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);
                if (scriptNode == null) {
                    throw new IllegalArgumentException(""Bad module: "" + module.getName());
                }
                toSource(cb, i, scriptNode);
            }
            return cb.toString();
        }
    });
}","public void test011() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSModule jSModule0 = new JSModule(""ul2>|E*M!Z&&"");
    // Undeclared exception!
    try {
        compiler0.toSource(jSModule0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Converts the parse tree for a module back to js code.
 */"
"public String[] toSourceArray() {
    return runInCompilerThread(new Callable<String[]>() {

        public String[] call() throws Exception {
            Tracer tracer = newTracer(""toSourceArray"");
            try {
                int numInputs = inputs.length;
                String[] sources = new String[numInputs];
                CodeBuilder cb = new CodeBuilder();
                for (int i = 0; i < numInputs; i++) {
                    Node scriptNode = inputs[i].getAstRoot(Compiler.this);
                    cb.reset();
                    toSource(cb, i, scriptNode);
                    sources[i] = cb.toString();
                }
                return sources;
            } finally {
                stopTracer(tracer, ""toSourceArray"");
            }
        }
    });
}","public void test022() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.toSourceArray();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Converts the parse tree for each input back to js code.
 */"
"//------------------------------------------------------------------------
// Convert back to source code
//------------------------------------------------------------------------
/**
 * Converts the main parse tree back to js code.
 */
public String toSource() {
    return runInCompilerThread(new Callable<String>() {

        public String call() throws Exception {
            Tracer tracer = newTracer(""toSource"");
            try {
                CodeBuilder cb = new CodeBuilder();
                if (jsRoot != null) {
                    int i = 0;
                    for (Node scriptNode = jsRoot.getFirstChild(); scriptNode != null; scriptNode = scriptNode.getNext()) {
                        toSource(cb, i++, scriptNode);
                    }
                }
                return cb.toString();
            } finally {
                stopTracer(tracer, ""toSource"");
            }
        }
    });
}","public void test033() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.toSource();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {
    runInCompilerThread(new Callable<Void>() {

        public Void call() throws Exception {
            if (options.printInputDelimiter) {
                if ((cb.getLength() > 0) && !cb.endsWith(""\n"")) {
                    // Make sure that the label starts on a new line
                    cb.append(""\n"");
                }
                Preconditions.checkState(root.getType() == Token.SCRIPT);
                String delimiter = options.inputDelimiter;
                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);
                Preconditions.checkState(sourceName != null);
                Preconditions.checkState(!sourceName.isEmpty());
                delimiter = delimiter.replaceAll(""%name%"", sourceName).replaceAll(""%num%"", String.valueOf(inputSeqNum));
                cb.append(delimiter).append(""\n"");
            }
            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {
                cb.append(""/*\n"").append(root.getJSDocInfo().getLicense()).append(""*/\n"");
            }
            // If there is a valid source map, then indicate to it that the current
            // root node's mappings are offset by the given string builder buffer.
            if (options.sourceMapOutputPath != null) {
                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());
            }
            String code = toSource(root);
            if (!code.isEmpty()) {
                cb.append(code);
                if (!code.endsWith("";"")) {
                    cb.append("";"");
                }
            }
            return null;
        }
    });
}","public void test044() throws Throwable {
    Compiler compiler0 = new Compiler();
    Compiler.CodeBuilder compiler_CodeBuilder0 = new Compiler.CodeBuilder();
    Node node0 = new Node((-53));
    // Undeclared exception!
    try {
        compiler0.toSource(compiler_CodeBuilder0, (-53), node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Writes out js code from a root node. If printing input delimiters, this
 * method will attach a comment to the start of the text indicating which
 * input the output derived from. If there were any preserve annotations
 * within the root's source, they will also be printed in a block comment
 * at the beginning of the output.
 */"
"public String[] toSourceArray(final JSModule module) {
    return runInCompilerThread(new Callable<String[]>() {

        public String[] call() throws Exception {
            List<CompilerInput> inputs = module.getInputs();
            int numInputs = inputs.size();
            if (numInputs == 0) {
                return new String[0];
            }
            String[] sources = new String[numInputs];
            CodeBuilder cb = new CodeBuilder();
            for (int i = 0; i < numInputs; i++) {
                Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);
                if (scriptNode == null) {
                    throw new IllegalArgumentException(""Bad module input: "" + inputs.get(i).getName());
                }
                cb.reset();
                toSource(cb, i, scriptNode);
                sources[i] = cb.toString();
            }
            return sources;
        }
    });
}","public void test055() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSModule jSModule0 = new JSModule(""b`(r|;PI"");
    // Undeclared exception!
    try {
        compiler0.toSourceArray(jSModule0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Converts the parse tree for each input in a module back to js code.
 */"
"public void normalize() {
    logger.info(""Normalizing"");
    startPass(""normalize"");
    process(new Normalize(this, false));
    setNormalized();
    endPass();
}","public void test066() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.normalize();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"void stripCode(Set<String> stripTypes, Set<String> stripNameSuffixes, Set<String> stripTypePrefixes, Set<String> stripNamePrefixes) {
    logger.info(""Strip code"");
    startPass(""stripCode"");
    StripCode r = new StripCode(this, stripTypes, stripNameSuffixes, stripTypePrefixes, stripNamePrefixes);
    process(r);
    endPass();
}","public void test077() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    // Undeclared exception!
    try {
        compiler0.stripCode(compilerOptions0.aliasableStrings, compilerOptions0.stripTypes, compilerOptions0.stripNamePrefixes, compilerOptions0.stripTypePrefixes);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Strips code for smaller compiled code. This is useful for removing debug
 * statements to prevent leaking them publicly.
 */"
"@Override
void setNormalized() {
    normalized = true;
}","public void test088() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.setNormalized();
}","/**
 * Set if the normalization pass has been done.
 * Note: non-private to enable test cases that require the Normalize pass.
 */"
"@VisibleForTesting
void resetUniqueNameId() {
    uniqueNameId = 0;
}","public void test099() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.resetUniqueNameId();
}","/**
 * Resets the unique name id counter
 */"
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test1010() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""r@tfHZG; $d6"");
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[0];
    JSSourceFile[] jSSourceFileArray1 = new JSSourceFile[2];
    jSSourceFileArray1[0] = jSSourceFile0;
    jSSourceFileArray1[1] = jSSourceFile0;
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFileArray0, jSSourceFileArray1, compilerOptions0);
    compiler0.parse();
    assertEquals(2, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"public boolean hasErrors() {
    return hasHaltingErrors();
}","public void test1011() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""r@tfHZG; $d6"");
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[0];
    JSSourceFile[] jSSourceFileArray1 = new JSSourceFile[2];
    jSSourceFileArray1[0] = jSSourceFile0;
    jSSourceFileArray1[1] = jSSourceFile0;
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFileArray0, jSSourceFileArray1, compilerOptions0);
    compiler0.parse();
    assertTrue(compiler0.hasErrors());
}","/**
 * Consults the {@link ErrorManager} to see if we've encountered errors
 * that should halt compilation. <p>
 *
 * If {@link CompilerOptions#ideMode} is {@code true}, this function
 * always returns {@code false} without consulting the error manager. The
 * error manager will continue to be told about new errors and warnings, but
 * the compiler will complete compilation of all inputs.<p>
 */"
"@Override
CssRenamingMap getCssRenamingMap() {
    return options.cssRenamingMap;
}","public void test1213() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.getCssRenamingMap();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test1314() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseSyntheticCode(""7}"", ""7}"");
    assertEquals(1, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"public void setState(IntermediateState state) {
    externsRoot = state.externsRoot;
    jsRoot = state.jsRoot;
    externs = state.externs;
    inputs = state.inputs;
    modules = state.modules;
    passes = createPassConfigInternal();
    getPassConfig().setIntermediateState(state.passConfigState);
    typeRegistry = state.typeRegistry;
    normalized = state.normalized;
}","public void test1415() throws Throwable {
    Compiler compiler0 = new Compiler();
    Compiler.IntermediateState compiler_IntermediateState0 = compiler0.getState();
    compiler0.setState(compiler_IntermediateState0);
}","/**
 * Sets the internal state to the capture given.  Note that this assumes that
 * the input files are already set up.
 */"
"public void disableThreads() {
    useThreads = false;
}","public void test1516() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.disableThreads();
}","/**
 * Disable threads. This is for clients that run on AppEngine and
 * don't have threads.
 */"
"@Override
ScopeCreator getScopeCreator() {
    return getPassConfig().getScopeCreator();
}","public void test1617() throws Throwable {
    Compiler compiler0 = new Compiler((PrintStream) null);
    ScopeCreator scopeCreator0 = compiler0.getScopeCreator();
    assertNull(scopeCreator0);
}",""
"public void rebuildInputsFromModules() {
    inputs = getAllInputsFromModules();
    initInputsByNameMap();
}","public void test1718() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.rebuildInputsFromModules();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Rebuilds the internal list of inputs by iterating over all modules.
 * This is necessary if inputs have been added to or removed from a module
 * after the {@link #init(JSSourceFile[], JSModule[], CompilerOptions)} call.
 */"
"boolean precheck() {
    return true;
}","public void test1819() throws Throwable {
    Compiler compiler0 = new Compiler();
    boolean boolean0 = compiler0.precheck();
    assertTrue(boolean0);
}","/**
 * Carry out any special checks or procedures that need to be done before
 * proceeding with rest of the compilation process.
 *
 * @return true, to continue with compilation
 */"
"ControlFlowGraph<Node> computeCFG() {
    logger.info(""Computing Control Flow Graph"");
    Tracer tracer = newTracer(""computeCFG"");
    ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true);
    process(cfa);
    stopTracer(tracer, ""computeCFG"");
    return cfa.getCfg();
}","public void test1920() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.computeCFG();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Control Flow Analysis.
 */"
"@Override
boolean isNormalized() {
    return normalized;
}","public void test2021() throws Throwable {
    Compiler compiler0 = new Compiler();
    boolean boolean0 = compiler0.isNormalized();
    assertFalse(boolean0);
}",""
"VariableMap getPropertyMap() {
    return getPassConfig().getIntermediateState().propertyMap;
}","public void test2122() throws Throwable {
    Compiler compiler0 = new Compiler();
    VariableMap variableMap0 = compiler0.getPropertyMap();
    assertNull(variableMap0);
}",""
"@Override
Node parseSyntheticCode(String js) {
    CompilerInput input = new CompilerInput(JSSourceFile.fromCode("" [synthetic] "", js));
    inputsByName.put(input.getName(), input);
    return input.getAstRoot(this);
}","public void test2223() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.parseSyntheticCode((String) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"public void processDefines() {
    (new DefaultPassConfig(options)).processDefines.create(this).process(externsRoot, jsRoot);
}","public void test2324() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.processDefines();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.DefaultPassConfig"", e);
    }
}","/**
 * Reprocesses the current defines over the AST.  This is used by GwtCompiler
 * to generate N outputs for different targets from the same (checked) AST.
 * For each target, we apply the target-specific defines by calling
 * {@code processDefines} and then {@code optimize} to optimize the AST
 * specifically for that target.
 */"
"//------------------------------------------------------------------------
// Optimizations
//------------------------------------------------------------------------
public void optimize() {
    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker);
    if (options.devMode == DevMode.EVERY_PASS) {
        phaseOptimizer.setSanityCheck(sanityCheck);
    }
    phaseOptimizer.consume(getPassConfig().getOptimizations());
    phaseOptimizer.process(externsRoot, jsRoot);
    if (hasErrors()) {
        return;
    }
}","public void test2425() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.getErrorManager();
    // Undeclared exception!
    try {
        compiler0.optimize();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // null
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"CheckAccessControls(AbstractCompiler compiler) {
    this.compiler = compiler;
    this.validator = compiler.getTypeValidator();
}","public void test2526() throws Throwable {
    Compiler compiler0 = new Compiler();
    CheckAccessControls checkAccessControls0 = new CheckAccessControls(compiler0);
}",""
"@Override
void setCssRenamingMap(CssRenamingMap map) {
    options.cssRenamingMap = map;
}","public void test2627() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.setCssRenamingMap((CssRenamingMap) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test2728() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.getWarningCount();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Gets the number of warnings.
 */"
"VariableMap getVariableMap() {
    return getPassConfig().getIntermediateState().variableMap;
}","public void test2829() throws Throwable {
    Compiler compiler0 = new Compiler();
    VariableMap variableMap0 = compiler0.getVariableMap();
    assertNull(variableMap0);
}",""
"FunctionInformationMap getFunctionalInformationMap() {
    return functionInformationMap;
}","public void test2930() throws Throwable {
    Compiler compiler0 = new Compiler((PrintStream) null);
    FunctionInformationMap functionInformationMap0 = compiler0.getFunctionalInformationMap();
    assertNull(functionInformationMap0);
}",""
"@Override
Supplier<String> getUniqueNameIdSupplier() {
    final Compiler self = this;
    return new Supplier<String>() {

        public String get() {
            return String.valueOf(self.nextUniqueNameId());
        }
    };
}","public void test3031() throws Throwable {
    Compiler compiler0 = new Compiler();
    Supplier<String> supplier0 = compiler0.getUniqueNameIdSupplier();
    assertNotNull(supplier0);
}",""
"void recordFunctionInformation() {
    logger.info(""Recording function information"");
    startPass(""recordFunctionInformation"");
    RecordFunctionInformation recordFunctionInfoPass = new RecordFunctionInformation(this, getPassConfig().getIntermediateState().functionNames);
    process(recordFunctionInfoPass);
    functionInformationMap = recordFunctionInfoPass.getMap();
    endPass();
}","public void test3132() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.recordFunctionInformation();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"@Override
String toSource(Node n) {
    initCompilerOptionsIfTesting();
    CodePrinter.Builder builder = new CodePrinter.Builder(n);
    builder.setPrettyPrint(options.prettyPrint);
    builder.setLineBreak(options.lineBreak);
    builder.setSourceMap(sourceMap);
    builder.setOutputCharset(options.outputCharset);
    return builder.build();
}","public void test3233() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.toSource((Node) null);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Cannot build without root node being specified
        //
        verifyException(""com.google.javascript.jscomp.CodePrinter$Builder"", e);
    }
}","/**
 * Generates JavaScript source code for an AST.
 */"
"public SourceMap getSourceMap() {
    return sourceMap;
}","public void test3334() throws Throwable {
    Compiler compiler0 = new Compiler();
    SourceMap sourceMap0 = compiler0.getSourceMap();
    assertNull(sourceMap0);
}",""
"@Override
public boolean isTypeCheckingEnabled() {
    return options.checkTypes;
}","public void test3435() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.isTypeCheckingEnabled();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"public Node getRoot() {
    return externAndJsRoot;
}","public void test3536() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.getRoot();
    assertNull(node0);
}","/**
 * Returns the root node of the AST, which includes both externs and source.
 */"
"@Override
void removeChangeHandler(CodeChangeHandler handler) {
    codeChangeHandlers.remove(handler);
}","public void test3637() throws Throwable {
    Compiler compiler0 = new Compiler();
    CodeChangeHandler.RecentChange codeChangeHandler_RecentChange0 = new CodeChangeHandler.RecentChange();
    compiler0.removeChangeHandler(codeChangeHandler_RecentChange0);
}",""
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test3738() throws Throwable {
    Logger logger0 = Tracer.logger;
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    assertEquals(0, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"public Result compile(JSSourceFile extern, JSModule[] modules, CompilerOptions options) {
    return compile(new JSSourceFile[] { extern }, modules, options);
}","public void test3839() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode(""r@t<HZG;!$d6"", ""}s"");
    // Undeclared exception!
    try {
        compiler0.compile(jSSourceFile0, (JSModule[]) null, (CompilerOptions) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"public JSError[] getMessages() {
    return getErrors();
}","public void test3940() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.getMessages();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Returns an array constructed from errors + temporary warnings.
 */"
"@Override
public Scope getTopScope() {
    return getPassConfig().getTopScope();
}","public void test4041() throws Throwable {
    Compiler compiler0 = new Compiler();
    Scope scope0 = compiler0.getTopScope();
    assertNull(scope0);
}",""
"@Override
SymbolTable acquireSymbolTable() {
    if (symbolTable == null) {
        symbolTable = new SymbolTable(this);
    }
    symbolTable.acquire();
    return symbolTable;
}","public void test4546() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.acquireSymbolTable();
    // Undeclared exception!
    try {
        compiler0.acquireSymbolTable();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // SymbolTable already acquired
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Acquires the symbol table.
 */"
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test4647() throws Throwable {
    MockPrintStream mockPrintStream0 = new MockPrintStream(""value"");
    Compiler compiler0 = new Compiler(mockPrintStream0);
    compiler0.initCompilerOptionsIfTesting();
    assertEquals(0, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test4748() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.sourceMapOutputPath = ""M,a8X>)j8"";
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""Creating extern file for exports"", (Charset) null);
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    assertEquals(1, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"public boolean hasErrors() {
    return hasHaltingErrors();
}","public void test4849() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[0];
    JSModule[] jSModuleArray0 = new JSModule[0];
    compiler0.compile(jSSourceFileArray0, jSModuleArray0, compilerOptions0);
    assertTrue(compiler0.hasErrors());
}","/**
 * Consults the {@link ErrorManager} to see if we've encountered errors
 * that should halt compilation. <p>
 *
 * If {@link CompilerOptions#ideMode} is {@code true}, this function
 * always returns {@code false} without consulting the error manager. The
 * error manager will continue to be told about new errors and warnings, but
 * the compiler will complete compilation of all inputs.<p>
 */"
"public Result compile(JSSourceFile[] externs, JSModule[] modules, CompilerOptions options) {
    // The compile method should only be called once.
    Preconditions.checkState(jsRoot == null);
    try {
        init(externs, modules, options);
        if (hasErrors()) {
            return getResult();
        }
        return compile();
    } finally {
        Tracer t = newTracer(""generateReport"");
        errorManager.generateReport();
        stopTracer(t, ""generateReport"");
    }
}","public void test4950() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""u?>t]k"");
    JSModule jSModule0 = new JSModule(""u?>t]k"");
    CompilerOptions compilerOptions0 = compiler0.getOptions();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode("""", ""_?.u)>y!P&@MZ"");
    JsAst jsAst0 = new JsAst(jSSourceFile0);
    CompilerInput compilerInput0 = new CompilerInput(jsAst0);
    jSModule0.addFirst(compilerInput0);
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[5];
    JSModule[] jSModuleArray0 = new JSModule[7];
    jSModuleArray0[0] = jSModule0;
    // Undeclared exception!
    try {
        compiler0.compile(jSSourceFileArray0, jSModuleArray0, compilerOptions0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.JsAst"", e);
    }
}","/**
 * Compiles a list of modules.
 */"
"public boolean hasErrors() {
    return hasHaltingErrors();
}","public void test5051() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[0];
    CompilerOptions compilerOptions0 = new CompilerOptions();
    JSModule jSModule0 = new JSModule((String) null);
    JSModule[] jSModuleArray0 = new JSModule[1];
    jSModuleArray0[0] = jSModule0;
    compiler0.compile(jSSourceFileArray0, jSModuleArray0, compilerOptions0);
    assertTrue(compiler0.hasErrors());
}","/**
 * Consults the {@link ErrorManager} to see if we've encountered errors
 * that should halt compilation. <p>
 *
 * If {@link CompilerOptions#ideMode} is {@code true}, this function
 * always returns {@code false} without consulting the error manager. The
 * error manager will continue to be told about new errors and warnings, but
 * the compiler will complete compilation of all inputs.<p>
 */"
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test5152() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""u?>t]k"");
    JSModule jSModule0 = new JSModule(""u?>t]k"");
    CompilerOptions compilerOptions0 = compiler0.getOptions();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode("""", ""_?.u)>y!P&@MZ"");
    JsAst jsAst0 = new JsAst(jSSourceFile0);
    CompilerInput compilerInput0 = new CompilerInput(jsAst0);
    jSModule0.addFirst(compilerInput0);
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[5];
    jSSourceFileArray0[0] = jSSourceFile0;
    jSSourceFileArray0[1] = jSSourceFile0;
    jSSourceFileArray0[2] = jSSourceFile0;
    jSSourceFileArray0[3] = jSSourceFile0;
    jSSourceFileArray0[4] = jSSourceFile0;
    JSModule[] jSModuleArray0 = new JSModule[7];
    jSModuleArray0[0] = jSModule0;
    jSModuleArray0[1] = jSModule0;
    jSModuleArray0[2] = jSModule0;
    jSModuleArray0[3] = jSModule0;
    jSModuleArray0[4] = jSModule0;
    jSModuleArray0[5] = jSModule0;
    jSModuleArray0[6] = jSModule0;
    compiler0.compile(jSSourceFileArray0, jSModuleArray0, compilerOptions0);
    assertEquals(3, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"public Result compile(JSSourceFile[] externs, JSModule[] modules, CompilerOptions options) {
    // The compile method should only be called once.
    Preconditions.checkState(jsRoot == null);
    try {
        init(externs, modules, options);
        if (hasErrors()) {
            return getResult();
        }
        return compile();
    } finally {
        Tracer t = newTracer(""generateReport"");
        errorManager.generateReport();
        stopTracer(t, ""generateReport"");
    }
}","public void test5253() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[0];
    CompilerOptions compilerOptions0 = new CompilerOptions();
    JSModule jSModule0 = new JSModule((String) null);
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode(""]!eUC4{EZ4o"", (String) null);
    JsAst jsAst0 = new JsAst(jSSourceFile0);
    CompilerInput compilerInput0 = new CompilerInput(jsAst0);
    jSModule0.addFirst(compilerInput0);
    JSModule[] jSModuleArray0 = new JSModule[1];
    jSModuleArray0[0] = jSModule0;
    // Undeclared exception!
    try {
        compiler0.compile(jSSourceFileArray0, jSModuleArray0, compilerOptions0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // org.evosuite.runtime.mock.java.lang.MockThrowable: FAILED ASSERTION
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Compiles a list of modules.
 */"
"public Result compile(JSSourceFile[] externs, JSModule[] modules, CompilerOptions options) {
    // The compile method should only be called once.
    Preconditions.checkState(jsRoot == null);
    try {
        init(externs, modules, options);
        if (hasErrors()) {
            return getResult();
        }
        return compile();
    } finally {
        Tracer t = newTracer(""generateReport"");
        errorManager.generateReport();
        stopTracer(t, ""generateReport"");
    }
}","public void test5354() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[0];
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFileArray0, jSSourceFileArray0, compilerOptions0);
    JSModule[] jSModuleArray0 = new JSModule[0];
    // Undeclared exception!
    try {
        compiler0.compile(jSSourceFileArray0, jSModuleArray0, compilerOptions0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Compiles a list of modules.
 */"
"public void setPassConfig(PassConfig passes) {
    // Important to check for null because if setPassConfig(null) is
    // called before this.passes is set, getPassConfig() will create a
    // new PassConfig object and use that, which is probably not what
    // the client wanted since he or she probably meant to use their
    // own PassConfig object.
    Preconditions.checkNotNull(passes);
    if (this.passes != null) {
        throw new IllegalStateException(""this.passes has already been assigned"");
    }
    this.passes = passes;
}","public void test5455() throws Throwable {
    Compiler compiler0 = new Compiler();
    PassConfig passConfig0 = compiler0.createPassConfigInternal();
    compiler0.setPassConfig(passConfig0);
}","/**
 * @param passes The PassConfig to use with this Compiler.
 * @throws NullPointerException if passes is null
 * @throws IllegalStateException if this.passes has already been assigned
 */"
"public void setPassConfig(PassConfig passes) {
    // Important to check for null because if setPassConfig(null) is
    // called before this.passes is set, getPassConfig() will create a
    // new PassConfig object and use that, which is probably not what
    // the client wanted since he or she probably meant to use their
    // own PassConfig object.
    Preconditions.checkNotNull(passes);
    if (this.passes != null) {
        throw new IllegalStateException(""this.passes has already been assigned"");
    }
    this.passes = passes;
}","public void test5556() throws Throwable {
    Compiler compiler0 = new Compiler();
    PassConfig passConfig0 = compiler0.getPassConfig();
    // Undeclared exception!
    try {
        compiler0.setPassConfig(passConfig0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // this.passes has already been assigned
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * @param passes The PassConfig to use with this Compiler.
 * @throws NullPointerException if passes is null
 * @throws IllegalStateException if this.passes has already been assigned
 */"
"public void check() {
    runCustomPasses(CustomPassExecutionTime.BEFORE_CHECKS);
    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker);
    if (options.devMode == DevMode.EVERY_PASS) {
        phaseOptimizer.setSanityCheck(sanityCheck);
    }
    phaseOptimizer.consume(getPassConfig().getChecks());
    phaseOptimizer.process(externsRoot, jsRoot);
    if (hasErrors()) {
        return;
    }
    // TODO(nicksantos): clean this up. The flow here is too hard to follow.
    if (options.nameAnonymousFunctionsOnly) {
        return;
    }
    if (options.removeTryCatchFinally) {
        removeTryCatchFinally();
    }
    if (!options.stripTypes.isEmpty() || !options.stripNameSuffixes.isEmpty() || !options.stripTypePrefixes.isEmpty() || !options.stripNamePrefixes.isEmpty()) {
        stripCode(options.stripTypes, options.stripNameSuffixes, options.stripTypePrefixes, options.stripNamePrefixes);
    }
    runCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATIONS);
    // Ideally, this pass should be the first pass run, however:
    // 1) VariableReferenceCheck reports unexpected warnings if Normalize
    // is done first.
    // 2) ReplaceMessages, stripCode, and potentially custom passes rely on
    // unmodified local names.
    normalize();
}","public void test5657() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.getErrorManager();
    // Undeclared exception!
    try {
        compiler0.check();
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // null
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"void startPass(String passName) {
    Preconditions.checkState(currentTracer == null);
    currentPassName = passName;
    currentTracer = newTracer(passName);
}","public void test5758() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.initCompilerOptionsIfTesting();
    compiler0.startPass((String) null);
    // Undeclared exception!
    try {
        compiler0.startPass((String) null);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Marks the beginning of a pass.
 */"
"void endPass() {
    Preconditions.checkState(currentTracer != null, ""Tracer should not be null at the end of a pass."");
    stopTracer(currentTracer, currentPassName);
    String passToCheck = currentPassName;
    currentPassName = null;
    currentTracer = null;
    maybeSanityCheck();
}","public void test5859() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.endPass();
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Tracer should not be null at the end of a pass.
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Marks the end of a pass.
 */"
"public void parse() {
    parseInputs();
}","public void test5960() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.reportCodeChange();
    compiler0.getErrorManager();
    // Undeclared exception!
    try {
        compiler0.parse();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"public Result compile(JSSourceFile[] externs, JSSourceFile[] inputs, CompilerOptions options) {
    // The compile method should only be called once.
    Preconditions.checkState(jsRoot == null);
    try {
        init(externs, inputs, options);
        if (hasErrors()) {
            return getResult();
        }
        return compile();
    } finally {
        Tracer t = newTracer(""generateReport"");
        errorManager.generateReport();
        stopTracer(t, ""generateReport"");
    }
}","public void test6061() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[0];
    CompilerOptions compilerOptions0 = new CompilerOptions();
    CompilerOptions.TracerMode compilerOptions_TracerMode0 = CompilerOptions.TracerMode.FAST;
    compilerOptions0.tracer = compilerOptions_TracerMode0;
    Result result0 = compiler0.compile(jSSourceFileArray0, jSSourceFileArray0, compilerOptions0);
    assertTrue(result0.success);
}","/**
 * Compiles a list of inputs.
 */"
"@Override
boolean areNodesEqualForInlining(Node n1, Node n2) {
    if (options.ambiguateProperties || options.disambiguateProperties) {
        // The type based optimizations require that type information is preserved
        // during other optimizations.
        return n1.checkTreeTypeAwareEqualsSilent(n2);
    } else {
        return n1.checkTreeEqualsSilent(n2);
    }
}","public void test6162() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""com.google.common.collect.Iterators$3"");
    boolean boolean0 = compiler0.areNodesEqualForInlining(node0, node0);
    assertTrue(boolean0);
}",""
"public boolean isExtern() {
    return isExtern;
}","public void test6263() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[0];
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFileArray0, jSSourceFileArray0, compilerOptions0);
    CompilerInput compilerInput0 = compiler0.newExternInput((String) null);
    assertTrue(compilerInput0.isExtern());
}",""
"@Override
public CompilerInput newExternInput(String name) {
    if (inputsByName.containsKey(name)) {
        throw new IllegalArgumentException(""Conflicting externs name: "" + name);
    }
    SourceAst ast = new SyntheticAst(name);
    CompilerInput input = new CompilerInput(ast, name, true);
    inputsByName.put(name, input);
    externsRoot.addChildToFront(ast.getAstRoot(this));
    return input;
}","public void test6364() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[4];
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode(""// Input %num%"", (String) null);
    jSSourceFileArray0[0] = jSSourceFile0;
    JSSourceFile jSSourceFile1 = JSSourceFile.fromCode((String) null, (String) null);
    jSSourceFileArray0[1] = jSSourceFile1;
    jSSourceFileArray0[2] = jSSourceFile0;
    jSSourceFileArray0[3] = jSSourceFileArray0[2];
    compiler0.compile(jSSourceFileArray0, jSSourceFileArray0, compilerOptions0);
    // Undeclared exception!
    try {
        compiler0.newExternInput((String) null);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Conflicting externs name: null
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"void addIncrementalSourceAst(JsAst ast) {
    String sourceName = ast.getSourceFile().getName();
    Preconditions.checkState(getInput(sourceName) == null, ""Duplicate input of name "" + sourceName);
    inputsByName.put(sourceName, new CompilerInput(ast));
}","public void test6465() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromCode(""u?>t]k"", ""'?0l.vA$cU?Vki&K"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    JsAst jsAst0 = new JsAst(jSSourceFile0);
    // Undeclared exception!
    try {
        compiler0.addIncrementalSourceAst(jsAst0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // Duplicate input of name u?>t]k
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Add a source input dynamically. Intended for incremental compilation.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test6566() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[0];
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFileArray0, jSSourceFileArray0, compilerOptions0);
    SourceFile sourceFile0 = SourceFile.fromCode((String) null, """");
    JsAst jsAst0 = new JsAst(sourceFile0);
    compiler0.addIncrementalSourceAst(jsAst0);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"@Override
public ReverseAbstractInterpreter getReverseAbstractInterpreter() {
    if (abstractInterpreter == null) {
        ChainableReverseAbstractInterpreter interpreter = new SemanticReverseAbstractInterpreter(getCodingConvention(), getTypeRegistry());
        if (options.closurePass) {
            interpreter = new ClosureReverseAbstractInterpreter(getCodingConvention(), getTypeRegistry()).append(interpreter).getFirst();
        }
        abstractInterpreter = interpreter;
    }
    return abstractInterpreter;
}","public void test6667() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.getErrorManager();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    ReverseAbstractInterpreter reverseAbstractInterpreter1 = compiler0.getReverseAbstractInterpreter();
    assertSame(reverseAbstractInterpreter1, reverseAbstractInterpreter0);
}",""
"@Override
public boolean isIdeMode() {
    return options.ideMode;
}","public void test6768() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[0];
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFileArray0, jSSourceFileArray0, compilerOptions0);
    compiler0.parse();
    assertFalse(compiler0.isIdeMode());
}",""
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test6869() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""Creating extern file for exports"", (Charset) null);
    compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    compiler0.parse();
    assertEquals(2, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"boolean isInliningForbidden() {
    return options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC || options.propertyRenaming == PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC;
}","public void test7475() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[0];
    CompilerOptions compilerOptions0 = new CompilerOptions();
    PropertyRenamingPolicy propertyRenamingPolicy0 = PropertyRenamingPolicy.HEURISTIC;
    compilerOptions0.propertyRenaming = propertyRenamingPolicy0;
    compiler0.compile(jSSourceFileArray0, jSSourceFileArray0, compilerOptions0);
    boolean boolean0 = compiler0.isInliningForbidden();
    assertTrue(boolean0);
}",""
"boolean isInliningForbidden() {
    return options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC || options.propertyRenaming == PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC;
}","public void test7576() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.initCompilerOptionsIfTesting();
    boolean boolean0 = compiler0.isInliningForbidden();
    assertFalse(boolean0);
}",""
"public int getCharno() {
    return extractCharno(sourcePosition);
}","public void test7677() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""com.google.common.collect.Iterators$3"");
    Node node0 = compiler0.parseTestCode(""com.google.common.collect.Iterators$3"");
    assertEquals(0, node0.getCharno());
}",""
"@Override
public boolean isIdeMode() {
    return options.ideMode;
}","public void test7778() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[0];
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFileArray0, jSSourceFileArray0, compilerOptions0);
    JSError jSError0 = JSError.make((String) null, (-1305), (-1305), compilerOptions0.checkMethods, compiler0.OPTIMIZE_LOOP_ERROR, (String[]) null);
    compiler0.report(jSError0);
    assertFalse(compiler0.isIdeMode());
}",""
"@Override
void throwInternalError(String message, Exception cause) {
    String finalMessage = ""INTERNAL COMPILER ERROR.\n"" + ""Please report this problem.\n"" + message;
    RuntimeException e = new RuntimeException(finalMessage, cause);
    if (cause != null) {
        e.setStackTrace(cause.getStackTrace());
    }
    throw e;
}","public void test7879() throws Throwable {
    Compiler compiler0 = new Compiler();
    // Undeclared exception!
    try {
        compiler0.throwInternalError(""Duplicate input: {0}"", (Exception) null);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // Duplicate input: {0}
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}","/**
 * Report an internal error.
 */"
"public Result compile(JSSourceFile[] externs, JSSourceFile[] inputs, CompilerOptions options) {
    // The compile method should only be called once.
    Preconditions.checkState(jsRoot == null);
    try {
        init(externs, inputs, options);
        if (hasErrors()) {
            return getResult();
        }
        return compile();
    } finally {
        Tracer t = newTracer(""generateReport"");
        errorManager.generateReport();
        stopTracer(t, ""generateReport"");
    }
}","public void test7980() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[0];
    compilerOptions0.ideMode = true;
    Result result0 = compiler0.compile(jSSourceFileArray0, jSSourceFileArray0, compilerOptions0);
    assertTrue(result0.success);
}","/**
 * Compiles a list of inputs.
 */"
"public Region getSourceRegion(String sourceName, int lineNumber) {
    if (lineNumber < 1) {
        return null;
    }
    SourceFile input = getSourceFileByName(sourceName);
    if (input != null) {
        return input.getRegion(lineNumber);
    }
    return null;
}","public void test8081() throws Throwable {
    Compiler compiler0 = new Compiler();
    Region region0 = compiler0.getSourceRegion(""/Users/elliottzackrone/IdeaProjects/defects4jprefix/Recording function information/Recording function information"", (-1645));
    assertNull(region0);
}",""
"public Region getSourceRegion(String sourceName, int lineNumber) {
    if (lineNumber < 1) {
        return null;
    }
    SourceFile input = getSourceFileByName(sourceName);
    if (input != null) {
        return input.getRegion(lineNumber);
    }
    return null;
}","public void test8182() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[0];
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFileArray0, jSSourceFileArray0, compilerOptions0);
    Region region0 = compiler0.getSourceRegion("""", 301);
    assertNull(region0);
}",""
"public Region getSourceRegion(String sourceName, int lineNumber) {
    if (lineNumber < 1) {
        return null;
    }
    SourceFile input = getSourceFileByName(sourceName);
    if (input != null) {
        return input.getRegion(lineNumber);
    }
    return null;
}","public void test8283() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[1];
    SourceFile.Generator sourceFile_Generator0 = mock(SourceFile.Generator.class, new ViolatedAssumptionAnswer());
    doReturn((String) null).when(sourceFile_Generator0).getCode();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromGenerator((String) null, sourceFile_Generator0);
    jSSourceFileArray0[0] = jSSourceFile0;
    compiler0.compile(jSSourceFileArray0, jSSourceFileArray0, compilerOptions0);
    // Undeclared exception!
    try {
        compiler0.getSourceRegion((String) null, 7);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.SourceFile"", e);
    }
}",""
"//------------------------------------------------------------------------
// Package-private helpers
//------------------------------------------------------------------------
@Override
Node getNodeForCodeInsertion(JSModule module) {
    if (module == null) {
        if (inputs.length == 0) {
            throw new IllegalStateException(""No inputs"");
        }
        return inputs[0].getAstRoot(this);
    }
    List<CompilerInput> inputs = module.getInputs();
    if (inputs.size() > 0) {
        return inputs.get(0).getAstRoot(this);
    }
    for (JSModule m : getModuleGraph().getTransitiveDepsDeepestFirst(module)) {
        inputs = m.getInputs();
        if (inputs.size() > 0) {
            return inputs.get(0).getAstRoot(this);
        }
    }
    throw new IllegalStateException(""Root module has no inputs"");
}","public void test8384() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSModule jSModule0 = new JSModule((String) null);
    // Undeclared exception!
    try {
        compiler0.getNodeForCodeInsertion(jSModule0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test8485() throws Throwable {
    Compiler compiler0 = new Compiler();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile("""", (Charset) null);
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[1];
    jSSourceFileArray0[0] = jSSourceFile0;
    compiler0.compile(jSSourceFileArray0, jSSourceFileArray0, compilerOptions0);
    compiler0.getNodeForCodeInsertion((JSModule) null);
    assertEquals(2, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"//------------------------------------------------------------------------
// Package-private helpers
//------------------------------------------------------------------------
@Override
Node getNodeForCodeInsertion(JSModule module) {
    if (module == null) {
        if (inputs.length == 0) {
            throw new IllegalStateException(""No inputs"");
        }
        return inputs[0].getAstRoot(this);
    }
    List<CompilerInput> inputs = module.getInputs();
    if (inputs.size() > 0) {
        return inputs.get(0).getAstRoot(this);
    }
    for (JSModule m : getModuleGraph().getTransitiveDepsDeepestFirst(module)) {
        inputs = m.getInputs();
        if (inputs.size() > 0) {
            return inputs.get(0).getAstRoot(this);
        }
    }
    throw new IllegalStateException(""Root module has no inputs"");
}","public void test8586() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[0];
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFileArray0, jSSourceFileArray0, compilerOptions0);
    // Undeclared exception!
    try {
        compiler0.getNodeForCodeInsertion((JSModule) null);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // No inputs
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"//------------------------------------------------------------------------
// Package-private helpers
//------------------------------------------------------------------------
@Override
Node getNodeForCodeInsertion(JSModule module) {
    if (module == null) {
        if (inputs.length == 0) {
            throw new IllegalStateException(""No inputs"");
        }
        return inputs[0].getAstRoot(this);
    }
    List<CompilerInput> inputs = module.getInputs();
    if (inputs.size() > 0) {
        return inputs.get(0).getAstRoot(this);
    }
    for (JSModule m : getModuleGraph().getTransitiveDepsDeepestFirst(module)) {
        inputs = m.getInputs();
        if (inputs.size() > 0) {
            return inputs.get(0).getAstRoot(this);
        }
    }
    throw new IllegalStateException(""Root module has no inputs"");
}","public void test8687() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSModule jSModule0 = new JSModule((String) null);
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile(""n"");
    jSModule0.addFirst(jSSourceFile0);
    // Undeclared exception!
    try {
        compiler0.getNodeForCodeInsertion(jSModule0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"public String getAstDotGraph() throws IOException {
    if (jsRoot != null) {
        ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true);
        cfa.process(null, jsRoot);
        return DotFormatter.toDot(jsRoot, cfa.getCfg());
    } else {
        return """";
    }
}","public void test8788() throws Throwable {
    Compiler compiler0 = new Compiler();
    String string0 = compiler0.getAstDotGraph();
    assertEquals("""", string0);
}","/**
 * Gets the DOT graph of the AST generated at the end of compilation.
 */"
"public String getAstDotGraph() throws IOException {
    if (jsRoot != null) {
        ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true);
        cfa.process(null, jsRoot);
        return DotFormatter.toDot(jsRoot, cfa.getCfg());
    } else {
        return """";
    }
}","public void test8889() throws Throwable {
    Compiler compiler0 = new Compiler();
    JSSourceFile[] jSSourceFileArray0 = new JSSourceFile[0];
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compiler0.compile(jSSourceFileArray0, jSSourceFileArray0, compilerOptions0);
    String string0 = compiler0.getAstDotGraph();
    assertEquals(""digraph AST {\n  node [color=lightblue2, style=filled];\n  node0 [label=\""BLOCK\""];\n  node0 -> RETURN [label=\""UNCOND\"", fontcolor=\""red\"", weight=0.01, color=\""red\""];\n}\n"", string0);
}","/**
 * Gets the DOT graph of the AST generated at the end of compilation.
 */"
"int getWarningCount();","public void test8990() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.initCompilerOptionsIfTesting();
    ErrorManager errorManager0 = compiler0.getErrorManager();
    assertEquals(0, errorManager0.getWarningCount());
}","/**
 * Gets the number of reported warnings.
 */"
