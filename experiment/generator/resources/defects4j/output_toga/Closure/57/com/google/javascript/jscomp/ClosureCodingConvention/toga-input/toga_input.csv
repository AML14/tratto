focal_method,test_prefix,docstring
"@Override
public boolean isVarArgsParameter(Node parameter) {
    return false;
}","public void test000() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    boolean boolean0 = closureCodingConvention0.isVarArgsParameter((Node) null);
    assertFalse(boolean0);
}",""
"@Override
public String extractClassNameIfProvide(Node node, Node parent) {
    return extractClassNameIfGoog(node, parent, ""goog.provide"");
}","public void test011() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    // Undeclared exception!
    try {
        googleCodingConvention0.extractClassNameIfProvide((Node) null, (Node) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil"", e);
    }
}","/**
 * Exctracts X from goog.provide('X'), if the applied Node is goog.
 *
 * @return The extracted class name, or null.
 */"
"@Override
public String getExportSymbolFunction() {
    return ""goog.exportSymbol"";
}","public void test022() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    String string0 = googleCodingConvention0.getExportSymbolFunction();
    assertEquals(""goog.exportSymbol"", string0);
}","/**
 * Use closure's implementation.
 * @return closure's function name for exporting symbols.
 */"
"@Override
public boolean isOptionalParameter(Node parameter) {
    return false;
}","public void test033() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    boolean boolean0 = closureCodingConvention0.isOptionalParameter((Node) null);
    assertFalse(boolean0);
}",""
"@Override
public boolean isSuperClassReference(String propertyName) {
    return ""superClass_"".equals(propertyName);
}","public void test044() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    boolean boolean0 = closureCodingConvention0.isSuperClassReference((String) null);
    assertFalse(boolean0);
}",""
"@Override
public String getAbstractMethodName() {
    return ""goog.abstractMethod"";
}","public void test055() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    String string0 = googleCodingConvention0.getAbstractMethodName();
    assertEquals(""goog.abstractMethod"", string0);
}",""
"@Override
public boolean isPrivate(String name) {
    return false;
}","public void test066() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    boolean boolean0 = closureCodingConvention0.isPrivate(""com.google.javascript.jscomp.ControlFlowGraph$Branch"");
    assertFalse(boolean0);
}",""
"@Override
public String getExportPropertyFunction() {
    return ""goog.exportProperty"";
}","public void test077() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    String string0 = googleCodingConvention0.getExportPropertyFunction();
    assertEquals(""goog.exportProperty"", string0);
}","/**
 * Use closure's implementation.
 * @return closure's function name for exporting properties.
 */"
"@Override
public void applySingletonGetter(FunctionType functionType, FunctionType getterType, ObjectType objectType) {
    functionType.defineDeclaredProperty(""getInstance"", getterType, functionType.getSource());
    functionType.defineDeclaredProperty(""instance_"", objectType, functionType.getSource());
}","public void test088() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    // Undeclared exception!
    try {
        googleCodingConvention0.applySingletonGetter((FunctionType) null, (FunctionType) null, (ObjectType) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.ClosureCodingConvention"", e);
    }
}",""
"@Override
public String getGlobalObject() {
    return ""goog.global"";
}","public void test099() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    String string0 = closureCodingConvention0.getGlobalObject();
    assertEquals(""goog.global"", string0);
}",""
"@Override
public Collection<AssertionFunctionSpec> getAssertionFunctions() {
    return ImmutableList.<AssertionFunctionSpec>of(new AssertionFunctionSpec(""goog.asserts.assert""), new AssertionFunctionSpec(""goog.asserts.assertNumber"", JSTypeNative.NUMBER_TYPE), new AssertionFunctionSpec(""goog.asserts.assertString"", JSTypeNative.STRING_TYPE), new AssertionFunctionSpec(""goog.asserts.assertFunction"", JSTypeNative.FUNCTION_INSTANCE_TYPE), new AssertionFunctionSpec(""goog.asserts.assertObject"", JSTypeNative.OBJECT_TYPE), new AssertionFunctionSpec(""goog.asserts.assertArray"", JSTypeNative.ARRAY_TYPE), // TODO(agrieve): It would be better if this could make the first
    // parameter the type of the second parameter.
    new AssertionFunctionSpec(""goog.asserts.assertInstanceof"", JSTypeNative.OBJECT_TYPE));
}","public void test1010() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Collection<CodingConvention.AssertionFunctionSpec> collection0 = googleCodingConvention0.getAssertionFunctions();
    assertNotNull(collection0);
}",""
"@Override
public String getDelegateSuperclassName() {
    return null;
}","public void test1111() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    CodingConvention.SubclassType codingConvention_SubclassType0 = CodingConvention.SubclassType.MIXIN;
    googleCodingConvention0.applySubclassRelationship((FunctionType) null, (FunctionType) null, codingConvention_SubclassType0);
    assertNull(googleCodingConvention0.getDelegateSuperclassName());
}",""
"@Override
public void applySubclassRelationship(FunctionType parentCtor, FunctionType childCtor, SubclassType type) {
    if (type == SubclassType.INHERITS) {
        childCtor.defineDeclaredProperty(""superClass_"", parentCtor.getPrototype(), parentCtor.getSource());
        childCtor.getPrototype().defineDeclaredProperty(""constructor"", childCtor, parentCtor.getSource());
    }
}","public void test1212() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    CodingConvention.SubclassType codingConvention_SubclassType0 = CodingConvention.SubclassType.INHERITS;
    // Undeclared exception!
    try {
        googleCodingConvention0.applySubclassRelationship((FunctionType) null, (FunctionType) null, codingConvention_SubclassType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.ClosureCodingConvention"", e);
    }
}","/**
 * Closure's goog.inherits adds a {@code superClass_} property to the
 * subclass, and a {@code constructor} property.
 */"
"@Override
public SubclassRelationship getClassesDefinedByCall(Node callNode) {
    Node callName = callNode.getFirstChild();
    SubclassType type = typeofClassDefiningName(callName);
    if (type != null) {
        Node subclass = null;
        Node superclass = callNode.getLastChild();
        // There are six possible syntaxes for a class-defining method:
        // SubClass.inherits(SuperClass)
        // goog.inherits(SubClass, SuperClass)
        // goog$inherits(SubClass, SuperClass)
        // SubClass.mixin(SuperClass.prototype)
        // goog.mixin(SubClass.prototype, SuperClass.prototype)
        // goog$mixin(SubClass.prototype, SuperClass.prototype)
        boolean isDeprecatedCall = callNode.getChildCount() == 2 && callName.getType() == Token.GETPROP;
        if (isDeprecatedCall) {
            // SubClass.inherits(SuperClass)
            subclass = callName.getFirstChild();
        } else if (callNode.getChildCount() == 3) {
            // goog.inherits(SubClass, SuperClass)
            subclass = callName.getNext();
        } else {
            return null;
        }
        if (type == SubclassType.MIXIN) {
            // Only consider mixins that mix two prototypes as related to
            // inheritance.
            if (!endsWithPrototype(superclass)) {
                return null;
            }
            if (!isDeprecatedCall) {
                if (!endsWithPrototype(subclass)) {
                    return null;
                }
                // Strip off the prototype from the name.
                subclass = subclass.getFirstChild();
            }
            superclass = superclass.getFirstChild();
        }
        // bail out if either of the side of the ""inherits""
        // isn't a real class name. This prevents us from
        // doing something weird in cases like:
        // goog.inherits(MySubClass, cond ? SuperClass1 : BaseClass2)
        if (subclass != null && subclass.isUnscopedQualifiedName() && superclass.isUnscopedQualifiedName()) {
            return new SubclassRelationship(type, subclass, superclass);
        }
    }
    return null;
}","public void test1313() throws Throwable {
    JSType[] jSTypeArray0 = new JSType[1];
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    Node node0 = jSTypeRegistry0.createParameters(jSTypeArray0);
    CodingConvention.SubclassRelationship codingConvention_SubclassRelationship0 = googleCodingConvention0.getClassesDefinedByCall(node0);
    assertNull(codingConvention_SubclassRelationship0);
}","/**
 * {@inheritDoc}
 *
 * <p>Understands several different inheritance patterns that occur in
 * Google code (various uses of {@code inherits} and {@code mixin}).
 */"
"@Override
public SubclassRelationship getClassesDefinedByCall(Node callNode) {
    Node callName = callNode.getFirstChild();
    SubclassType type = typeofClassDefiningName(callName);
    if (type != null) {
        Node subclass = null;
        Node superclass = callNode.getLastChild();
        // There are six possible syntaxes for a class-defining method:
        // SubClass.inherits(SuperClass)
        // goog.inherits(SubClass, SuperClass)
        // goog$inherits(SubClass, SuperClass)
        // SubClass.mixin(SuperClass.prototype)
        // goog.mixin(SubClass.prototype, SuperClass.prototype)
        // goog$mixin(SubClass.prototype, SuperClass.prototype)
        boolean isDeprecatedCall = callNode.getChildCount() == 2 && callName.getType() == Token.GETPROP;
        if (isDeprecatedCall) {
            // SubClass.inherits(SuperClass)
            subclass = callName.getFirstChild();
        } else if (callNode.getChildCount() == 3) {
            // goog.inherits(SubClass, SuperClass)
            subclass = callName.getNext();
        } else {
            return null;
        }
        if (type == SubclassType.MIXIN) {
            // Only consider mixins that mix two prototypes as related to
            // inheritance.
            if (!endsWithPrototype(superclass)) {
                return null;
            }
            if (!isDeprecatedCall) {
                if (!endsWithPrototype(subclass)) {
                    return null;
                }
                // Strip off the prototype from the name.
                subclass = subclass.getFirstChild();
            }
            superclass = superclass.getFirstChild();
        }
        // bail out if either of the side of the ""inherits""
        // isn't a real class name. This prevents us from
        // doing something weird in cases like:
        // goog.inherits(MySubClass, cond ? SuperClass1 : BaseClass2)
        if (subclass != null && subclass.isUnscopedQualifiedName() && superclass.isUnscopedQualifiedName()) {
            return new SubclassRelationship(type, subclass, superclass);
        }
    }
    return null;
}","public void test1414() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = new Node(33, 33, 33);
    Node node1 = new Node(4, node0, 47, 33);
    // Undeclared exception!
    try {
        googleCodingConvention0.getClassesDefinedByCall(node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.ClosureCodingConvention"", e);
    }
}","/**
 * {@inheritDoc}
 *
 * <p>Understands several different inheritance patterns that occur in
 * Google code (various uses of {@code inherits} and {@code mixin}).
 */"
"@Override
public SubclassRelationship getClassesDefinedByCall(Node callNode) {
    Node callName = callNode.getFirstChild();
    SubclassType type = typeofClassDefiningName(callName);
    if (type != null) {
        Node subclass = null;
        Node superclass = callNode.getLastChild();
        // There are six possible syntaxes for a class-defining method:
        // SubClass.inherits(SuperClass)
        // goog.inherits(SubClass, SuperClass)
        // goog$inherits(SubClass, SuperClass)
        // SubClass.mixin(SuperClass.prototype)
        // goog.mixin(SubClass.prototype, SuperClass.prototype)
        // goog$mixin(SubClass.prototype, SuperClass.prototype)
        boolean isDeprecatedCall = callNode.getChildCount() == 2 && callName.getType() == Token.GETPROP;
        if (isDeprecatedCall) {
            // SubClass.inherits(SuperClass)
            subclass = callName.getFirstChild();
        } else if (callNode.getChildCount() == 3) {
            // goog.inherits(SubClass, SuperClass)
            subclass = callName.getNext();
        } else {
            return null;
        }
        if (type == SubclassType.MIXIN) {
            // Only consider mixins that mix two prototypes as related to
            // inheritance.
            if (!endsWithPrototype(superclass)) {
                return null;
            }
            if (!isDeprecatedCall) {
                if (!endsWithPrototype(subclass)) {
                    return null;
                }
                // Strip off the prototype from the name.
                subclass = subclass.getFirstChild();
            }
            superclass = superclass.getFirstChild();
        }
        // bail out if either of the side of the ""inherits""
        // isn't a real class name. This prevents us from
        // doing something weird in cases like:
        // goog.inherits(MySubClass, cond ? SuperClass1 : BaseClass2)
        if (subclass != null && subclass.isUnscopedQualifiedName() && superclass.isUnscopedQualifiedName()) {
            return new SubclassRelationship(type, subclass, superclass);
        }
    }
    return null;
}","public void test1515() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = Node.newNumber((-10.67296378501237));
    Node node1 = new Node((-1), node0, node0, node0, 20, 16);
    CodingConvention.SubclassRelationship codingConvention_SubclassRelationship0 = googleCodingConvention0.getClassesDefinedByCall(node1);
    assertNull(codingConvention_SubclassRelationship0);
}","/**
 * {@inheritDoc}
 *
 * <p>Understands several different inheritance patterns that occur in
 * Google code (various uses of {@code inherits} and {@code mixin}).
 */"
"@Override
public String extractClassNameIfRequire(Node node, Node parent) {
    return extractClassNameIfGoog(node, parent, ""goog.require"");
}","public void test1616() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = Node.newNumber(1131.2815601);
    String string0 = googleCodingConvention0.extractClassNameIfRequire(node0, node0);
    assertNull(string0);
}","/**
 * Exctracts X from goog.require('X'), if the applied Node is goog.
 *
 * @return The extracted class name, or null.
 */"
"@Override
public List<String> identifyTypeDeclarationCall(Node n) {
    Node callName = n.getFirstChild();
    if (""goog.addDependency"".equals(callName.getQualifiedName()) && n.getChildCount() >= 3) {
        Node typeArray = callName.getNext().getNext();
        if (typeArray.getType() == Token.ARRAYLIT) {
            List<String> typeNames = Lists.newArrayList();
            for (Node name = typeArray.getFirstChild(); name != null; name = name.getNext()) {
                if (name.getType() == Token.STRING) {
                    typeNames.add(name.getString());
                }
            }
            return typeNames;
        }
    }
    return null;
}","public void test1717() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode("";isT$dOPOt2yWcxs"", "";isT$dOPOt2yWcxs"");
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    List<String> list0 = googleCodingConvention0.identifyTypeDeclarationCall(node0);
    assertNull(list0);
}",""
"@Override
public String getSingletonGetterClassName(Node callNode) {
    Node callArg = callNode.getFirstChild();
    String callName = callArg.getQualifiedName();
    // Use both the original name and the post-CollapseProperties name.
    if (!(""goog.addSingletonGetter"".equals(callName) || ""goog$addSingletonGetter"".equals(callName)) || callNode.getChildCount() != 2) {
        return null;
    }
    return callArg.getNext().getQualifiedName();
}","public void test1818() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = Node.newNumber((-2.1474836446971633E9));
    Node node1 = new Node(50, node0, node0, node0, 35, 31);
    String string0 = googleCodingConvention0.getSingletonGetterClassName(node1);
    assertNull(string0);
}",""
"@Override
public boolean isPropertyTestFunction(Node call) {
    Preconditions.checkArgument(call.getType() == Token.CALL);
    return propertyTestFunctions.contains(call.getFirstChild().getQualifiedName());
}","public void test1919() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = Node.newNumber((-1488.2425));
    // Undeclared exception!
    try {
        googleCodingConvention0.isPropertyTestFunction(node0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"@Override
public boolean isPropertyTestFunction(Node call) {
    Preconditions.checkArgument(call.getType() == Token.CALL);
    return propertyTestFunctions.contains(call.getFirstChild().getQualifiedName());
}","public void test2020() throws Throwable {
    Node node0 = new Node((-2921), (-2921), (-2921));
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node1 = new Node(37, node0, node0, node0, node0, 0, 5);
    boolean boolean0 = googleCodingConvention0.isPropertyTestFunction(node1);
    assertFalse(boolean0);
}",""
"@Override
public ObjectLiteralCast getObjectLiteralCast(NodeTraversal t, Node callNode) {
    Preconditions.checkArgument(callNode.getType() == Token.CALL);
    Node callName = callNode.getFirstChild();
    if (!""goog.reflect.object"".equals(callName.getQualifiedName()) || callNode.getChildCount() != 3) {
        return null;
    }
    Node typeNode = callName.getNext();
    if (!typeNode.isQualifiedName()) {
        return null;
    }
    Node objectNode = typeNode.getNext();
    if (objectNode.getType() != Token.OBJECTLIT) {
        // TODO(johnlenz): The coding convention should not be performing checks.
        t.getCompiler().report(JSError.make(t.getSourceName(), callNode, OBJECTLIT_EXPECTED));
        return null;
    }
    return new ObjectLiteralCast(typeNode.getQualifiedName(), typeNode.getNext());
}","public void test2121() throws Throwable {
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node0 = Node.newNumber((-10.67296378501237));
    // Undeclared exception!
    try {
        googleCodingConvention0.getObjectLiteralCast((NodeTraversal) null, node0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"@Override
public ObjectLiteralCast getObjectLiteralCast(NodeTraversal t, Node callNode) {
    Preconditions.checkArgument(callNode.getType() == Token.CALL);
    Node callName = callNode.getFirstChild();
    if (!""goog.reflect.object"".equals(callName.getQualifiedName()) || callNode.getChildCount() != 3) {
        return null;
    }
    Node typeNode = callName.getNext();
    if (!typeNode.isQualifiedName()) {
        return null;
    }
    Node objectNode = typeNode.getNext();
    if (objectNode.getType() != Token.OBJECTLIT) {
        // TODO(johnlenz): The coding convention should not be performing checks.
        t.getCompiler().report(JSError.make(t.getSourceName(), callNode, OBJECTLIT_EXPECTED));
        return null;
    }
    return new ObjectLiteralCast(typeNode.getQualifiedName(), typeNode.getNext());
}","public void test2222() throws Throwable {
    Node node0 = new Node((-2921), (-2921), (-2921));
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node1 = new Node(37, node0, node0, node0, node0, 0, 5);
    CodingConvention.ObjectLiteralCast codingConvention_ObjectLiteralCast0 = googleCodingConvention0.getObjectLiteralCast((NodeTraversal) null, node1);
    assertNull(codingConvention_ObjectLiteralCast0);
}",""
"@Override
public Bind describeFunctionBind(Node n) {
    Bind result = super.describeFunctionBind(n);
    if (result != null) {
        return result;
    }
    // It would be nice to be able to identify a fn.bind call
    // but that requires knowing the type of ""fn"".
    if (n.getType() != Token.CALL) {
        return null;
    }
    Node callTarget = n.getFirstChild();
    String name = callTarget.getQualifiedName();
    if (name != null) {
        if (name.equals(""goog.bind"") || name.equals(""goog$bind"")) {
            // goog.bind(fn, self, args...);
            Node fn = callTarget.getNext();
            if (fn == null) {
                return null;
            }
            Node thisValue = safeNext(fn);
            Node parameters = safeNext(thisValue);
            return new Bind(fn, thisValue, parameters);
        }
        if (name.equals(""goog.partial"") || name.equals(""goog$partial"")) {
            // goog.partial(fn, args...);
            Node fn = callTarget.getNext();
            if (fn == null) {
                return null;
            }
            Node thisValue = null;
            Node parameters = safeNext(fn);
            return new Bind(fn, thisValue, parameters);
        }
    }
    return null;
}","public void test2323() throws Throwable {
    Node node0 = new Node((-2921));
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    CodingConvention.Bind codingConvention_Bind0 = googleCodingConvention0.describeFunctionBind(node0);
    assertNull(codingConvention_Bind0);
}",""
"@Override
public Bind describeFunctionBind(Node n) {
    Bind result = super.describeFunctionBind(n);
    if (result != null) {
        return result;
    }
    // It would be nice to be able to identify a fn.bind call
    // but that requires knowing the type of ""fn"".
    if (n.getType() != Token.CALL) {
        return null;
    }
    Node callTarget = n.getFirstChild();
    String name = callTarget.getQualifiedName();
    if (name != null) {
        if (name.equals(""goog.bind"") || name.equals(""goog$bind"")) {
            // goog.bind(fn, self, args...);
            Node fn = callTarget.getNext();
            if (fn == null) {
                return null;
            }
            Node thisValue = safeNext(fn);
            Node parameters = safeNext(thisValue);
            return new Bind(fn, thisValue, parameters);
        }
        if (name.equals(""goog.partial"") || name.equals(""goog$partial"")) {
            // goog.partial(fn, args...);
            Node fn = callTarget.getNext();
            if (fn == null) {
                return null;
            }
            Node thisValue = null;
            Node parameters = safeNext(fn);
            return new Bind(fn, thisValue, parameters);
        }
    }
    return null;
}","public void test2424() throws Throwable {
    Node node0 = new Node((-2921));
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node1 = new Node(37, node0, node0, node0, node0, 0, 5);
    CodingConvention.Bind codingConvention_Bind0 = googleCodingConvention0.describeFunctionBind(node1);
    assertNull(codingConvention_Bind0);
}",""
"@Override
public Bind describeFunctionBind(Node n) {
    Bind result = super.describeFunctionBind(n);
    if (result != null) {
        return result;
    }
    // It would be nice to be able to identify a fn.bind call
    // but that requires knowing the type of ""fn"".
    if (n.getType() != Token.CALL) {
        return null;
    }
    Node callTarget = n.getFirstChild();
    String name = callTarget.getQualifiedName();
    if (name != null) {
        if (name.equals(""goog.bind"") || name.equals(""goog$bind"")) {
            // goog.bind(fn, self, args...);
            Node fn = callTarget.getNext();
            if (fn == null) {
                return null;
            }
            Node thisValue = safeNext(fn);
            Node parameters = safeNext(thisValue);
            return new Bind(fn, thisValue, parameters);
        }
        if (name.equals(""goog.partial"") || name.equals(""goog$partial"")) {
            // goog.partial(fn, args...);
            Node fn = callTarget.getNext();
            if (fn == null) {
                return null;
            }
            Node thisValue = null;
            Node parameters = safeNext(fn);
            return new Bind(fn, thisValue, parameters);
        }
    }
    return null;
}","public void test2525() throws Throwable {
    Node node0 = new Node(42, 42, 42);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    Node node1 = new Node(37, node0, node0, node0, node0, 0, 5);
    CodingConvention.Bind codingConvention_Bind0 = googleCodingConvention0.describeFunctionBind(node1);
    assertNull(codingConvention_Bind0);
}",""
