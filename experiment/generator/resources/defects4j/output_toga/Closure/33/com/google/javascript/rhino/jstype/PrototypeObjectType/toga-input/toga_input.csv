focal_method,test_prefix,docstring
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test000() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    errorFunctionType0.toStringHelper(false);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean isSubtype(JSType that) {
    if (JSType.isSubtypeHelper(this, that)) {
        return true;
    }
    if (that.isFunctionType()) {
        FunctionType other = that.toMaybeFunctionType();
        if (other.isInterface()) {
            // Any function can be assigned to an interface function.
            return true;
        }
        if (this.isInterface()) {
            // An interface function cannot be assigned to anything.
            return false;
        }
        // If functionA is a subtype of functionB, then their ""this"" types
        // should be contravariant. However, this causes problems because
        // of the way we enforce overrides. Because function(this:SubFoo)
        // is not a subtype of function(this:Foo), our override check treats
        // this as an error. It also screws up out standard method
        // for aliasing constructors. Let's punt on all this for now.
        // TODO(nicksantos): fix this.
        boolean treatThisTypesAsCovariant = // If either one of these is a ctor, skip 'this' checking.
        this.isConstructor() || other.isConstructor() || // An interface 'this'-type is non-restrictive.
        // In practical terms, if C implements I, and I has a method m,
        // then any m doesn't necessarily have to C#m's 'this'
        // type doesn't need to match I.
        (other.typeOfThis.getConstructor() != null && other.typeOfThis.getConstructor().isInterface()) || // If one of the 'this' types is covariant of the other,
        // then we'll treat them as covariant (see comment above).
        other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis);
        return treatThisTypesAsCovariant && this.call.isSubtype(other.call);
    }
    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);
}","public void test011() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""]aYq]:O]t~;X8:W"", (Node) null);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    boolean boolean0 = functionType0.isSubtype(instanceObjectType0);
    assertFalse(boolean0);
}","/**
 * A function is a subtype of another if their call methods are related via
 * subtyping and {@code this} is a subtype of {@code that} with regard to
 * the prototype chain.
 */"
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test012() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""]aYq]:O]t~;X8:W"", (Node) null);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    boolean boolean0 = functionType0.isSubtype(instanceObjectType0);
    assertFalse(instanceObjectType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean hasReferenceName() {
    return getConstructor().hasReferenceName();
}","public void test013() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""]aYq]:O]t~;X8:W"", (Node) null);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    boolean boolean0 = functionType0.isSubtype(instanceObjectType0);
    assertTrue(instanceObjectType0.hasReferenceName());
}",""
"@Override
public boolean matchesObjectContext() {
    return true;
}","public void test024() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    UnknownType unknownType0 = new UnknownType(jSTypeRegistry0, false);
    PrototypeObjectType prototypeObjectType0 = new PrototypeObjectType(jSTypeRegistry0, ""W8%Q&dA}l\""6)L}yU1}("", unknownType0, false);
    JSType[] jSTypeArray0 = new JSType[3];
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) prototypeObjectType0, false, jSTypeArray0);
    boolean boolean0 = functionType0.matchesObjectContext();
    assertTrue(boolean0);
}",""
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test025() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    UnknownType unknownType0 = new UnknownType(jSTypeRegistry0, false);
    PrototypeObjectType prototypeObjectType0 = new PrototypeObjectType(jSTypeRegistry0, ""W8%Q&dA}l\""6)L}yU1}("", unknownType0, false);
    JSType[] jSTypeArray0 = new JSType[3];
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) prototypeObjectType0, false, jSTypeArray0);
    boolean boolean0 = functionType0.matchesObjectContext();
    assertFalse(prototypeObjectType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean hasReferenceName() {
    return className != null || ownerFunction != null;
}","public void test026() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    UnknownType unknownType0 = new UnknownType(jSTypeRegistry0, false);
    PrototypeObjectType prototypeObjectType0 = new PrototypeObjectType(jSTypeRegistry0, ""W8%Q&dA}l\""6)L}yU1}("", unknownType0, false);
    JSType[] jSTypeArray0 = new JSType[3];
    FunctionType functionType0 = jSTypeRegistry0.createFunctionType((JSType) prototypeObjectType0, false, jSTypeArray0);
    boolean boolean0 = functionType0.matchesObjectContext();
    assertTrue(prototypeObjectType0.hasReferenceName());
}",""
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test037() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    recordType0.canBeCalled();
    assertFalse(recordType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean hasReferenceName() {
    return className != null || ownerFunction != null;
}","public void test038() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    recordType0.canBeCalled();
    assertFalse(recordType0.hasReferenceName());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test049() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""H#i{8*"");
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    errorFunctionType0.setPropertyJSDocInfo(""H#i{8*"", jSDocInfo0);
    int int0 = errorFunctionType0.getPropertiesCount();
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public int getPropertiesCount() {
    ObjectType implicitPrototype = getImplicitPrototype();
    if (implicitPrototype == null) {
        return this.properties.size();
    }
    int localCount = 0;
    for (String property : properties.keySet()) {
        if (!implicitPrototype.hasProperty(property)) {
            localCount++;
        }
    }
    return implicitPrototype.getPropertiesCount() + localCount;
}","public void test0410() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""H#i{8*"");
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    errorFunctionType0.setPropertyJSDocInfo(""H#i{8*"", jSDocInfo0);
    int int0 = errorFunctionType0.getPropertiesCount();
    assertEquals(1, int0);
}","/**
 * Gets the number of properties of this object.
 */"
"public boolean isNominalType() {
    return false;
}","public void test0511() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    ObjectType objectType0 = errorFunctionType0.getTopMostDefiningType((String) null);
    assertFalse(objectType0.isNominalType());
}","/**
 * Whether this type is a nominal type (a named instance object or
 * a named enum).
 */"
"public boolean isNativeObjectType() {
    return false;
}","public void test0512() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    ObjectType objectType0 = errorFunctionType0.getTopMostDefiningType((String) null);
    assertTrue(objectType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test0613() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""bind"");
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    errorFunctionType0.setPropertyJSDocInfo(""bind"", jSDocInfo0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean hasReferenceName() {
    return className != null || ownerFunction != null;
}","public void test0714() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(noType0, (Node) null);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    hashMap0.put(""Named type with empty name component"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    noType0.matchConstraint(recordType0);
    assertFalse(recordType0.hasReferenceName());
}",""
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test0715() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(noType0, (Node) null);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    hashMap0.put(""Named type with empty name component"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    noType0.matchConstraint(recordType0);
    assertFalse(recordType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test0816() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""P^"");
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    errorFunctionType0.setPropertyJSDocInfo(""P^"", jSDocInfo0);
    Node node0 = errorFunctionType0.getParametersNode();
    boolean boolean0 = errorFunctionType0.defineProperty(""P^"", (JSType) null, false, node0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
boolean defineProperty(String name, JSType type, boolean inferred, Node propertyNode) {
    if (""prototype"".equals(name)) {
        ObjectType objType = type.toObjectType();
        if (objType != null) {
            if (prototypeSlot != null && objType.isEquivalentTo(prototypeSlot.getType())) {
                return true;
            }
            this.setPrototypeBasedOn(objType, propertyNode);
            return true;
        } else {
            return false;
        }
    }
    return super.defineProperty(name, type, inferred, propertyNode);
}","public void test0817() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""P^"");
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    errorFunctionType0.setPropertyJSDocInfo(""P^"", jSDocInfo0);
    Node node0 = errorFunctionType0.getParametersNode();
    boolean boolean0 = errorFunctionType0.defineProperty(""P^"", (JSType) null, false, node0);
    assertTrue(boolean0);
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test0918() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""{"");
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    errorFunctionType0.setPropertyJSDocInfo(""{"", jSDocInfo0);
    errorFunctionType0.getPropertyNames();
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test1019() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    errorFunctionType0.setPropertyJSDocInfo(""Unknown class name"", jSDocInfo0);
    boolean boolean0 = errorFunctionType0.isPropertyTypeInferred(""Unknown class name"");
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean isPropertyTypeInferred(String property) {
    StaticSlot<JSType> slot = getSlot(property);
    if (slot == null) {
        return false;
    }
    return slot.isTypeInferred();
}","public void test1020() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Named type with empty name component"");
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    errorFunctionType0.setPropertyJSDocInfo(""Unknown class name"", jSDocInfo0);
    boolean boolean0 = errorFunctionType0.isPropertyTypeInferred(""Unknown class name"");
    assertTrue(boolean0);
}",""
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test1121() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    boolean boolean0 = recordType0.isPropertyTypeInferred("":7NM~88QYJbI7/=\""'Q"");
    assertFalse(recordType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean isPropertyTypeInferred(String property) {
    StaticSlot<JSType> slot = getSlot(property);
    if (slot == null) {
        return false;
    }
    return slot.isTypeInferred();
}","public void test1122() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    boolean boolean0 = recordType0.isPropertyTypeInferred("":7NM~88QYJbI7/=\""'Q"");
    assertFalse(boolean0);
}",""
"@Override
public boolean hasReferenceName() {
    return className != null || ownerFunction != null;
}","public void test1123() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    boolean boolean0 = recordType0.isPropertyTypeInferred("":7NM~88QYJbI7/=\""'Q"");
    assertFalse(recordType0.hasReferenceName());
}",""
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test1224() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    boolean boolean0 = recordType0.isPropertyInExterns(""Unknown class name"");
    assertFalse(recordType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean isPropertyInExterns(String propertyName) {
    Property p = properties.get(propertyName);
    if (p != null) {
        return p.isFromExterns();
    }
    ObjectType implicitPrototype = getImplicitPrototype();
    if (implicitPrototype != null) {
        return implicitPrototype.isPropertyInExterns(propertyName);
    }
    return false;
}","public void test1225() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    boolean boolean0 = recordType0.isPropertyInExterns(""Unknown class name"");
    assertFalse(boolean0);
}",""
"@Override
public boolean hasReferenceName() {
    return className != null || ownerFunction != null;
}","public void test1226() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    boolean boolean0 = recordType0.isPropertyInExterns(""Unknown class name"");
    assertFalse(recordType0.hasReferenceName());
}",""
"@Override
public boolean hasReferenceName() {
    return className != null || ownerFunction != null;
}","public void test1327() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(noType0, (Node) null);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    hashMap0.put(""Named type with empty name component"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    recordType0.isPropertyInExterns(""Named type with empty name component"");
    assertFalse(recordType0.hasReferenceName());
}",""
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test1328() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(noType0, (Node) null);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    hashMap0.put(""Named type with empty name component"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    recordType0.isPropertyInExterns(""Named type with empty name component"");
    assertFalse(recordType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean removeProperty(String name) {
    return properties.remove(name) != null;
}","public void test1429() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    boolean boolean0 = errorFunctionType0.removeProperty(""vQw'Fifhnd"");
    assertFalse(boolean0);
}",""
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test1430() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    boolean boolean0 = errorFunctionType0.removeProperty(""vQw'Fifhnd"");
    assertTrue(errorFunctionType0.isNominalConstructor());
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test1531() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""zX@T\""uf-c E;.5Bw0%"", (Node) null);
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    functionType0.setPropertyJSDocInfo(""Named type with empty name component"", jSDocInfo0);
    boolean boolean0 = functionType0.removeProperty(""Named type with empty name component"");
    assertTrue(functionType0.hasCachedValues());
}",""
"@Override
public boolean removeProperty(String name) {
    return properties.remove(name) != null;
}","public void test1532() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""zX@T\""uf-c E;.5Bw0%"", (Node) null);
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    functionType0.setPropertyJSDocInfo(""Named type with empty name component"", jSDocInfo0);
    boolean boolean0 = functionType0.removeProperty(""Named type with empty name component"");
    assertTrue(boolean0);
}",""
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test1633() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    errorFunctionType0.getPropertyNode(""Unknown class name"");
    assertTrue(errorFunctionType0.isNominalConstructor());
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test1734() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, "":6_)or3WKzv+g/!i*|~"");
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    errorFunctionType0.setPropertyJSDocInfo("":6_)or3WKzv+g/!i*|~"", jSDocInfo0);
    errorFunctionType0.getPropertyNode("":6_)or3WKzv+g/!i*|~"");
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test1835() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""zX@T\""uf-c E;.5Bw0%"");
    errorFunctionType0.getOwnPropertyJSDocInfo(""Unknown class name"");
    assertTrue(errorFunctionType0.isNominalConstructor());
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test1936() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(voidType0, (Node) null);
    hashMap0.put(""Unknown class name"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    recordType0.getOwnPropertyJSDocInfo(""Unknown class name"");
    assertFalse(recordType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean hasReferenceName() {
    return className != null || ownerFunction != null;
}","public void test1937() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(voidType0, (Node) null);
    hashMap0.put(""Unknown class name"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    recordType0.getOwnPropertyJSDocInfo(""Unknown class name"");
    assertFalse(recordType0.hasReferenceName());
}",""
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test2038() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""NWQ%bp0qR"");
    errorFunctionType0.setPropertyJSDocInfo(""NWQ%bp0qR"", (JSDocInfo) null);
    assertTrue(errorFunctionType0.isNominalConstructor());
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test2039() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""NWQ%bp0qR"");
    errorFunctionType0.setPropertyJSDocInfo(""NWQ%bp0qR"", (JSDocInfo) null);
    assertFalse(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test2140() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""com.google.common.base.CharMatcher$Or"");
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    errorFunctionType0.setPropertyJSDocInfo(""com.google.common.base.CharMatcher$Or"", jSDocInfo0);
    errorFunctionType0.setPropertyJSDocInfo(""com.google.common.base.CharMatcher$Or"", jSDocInfo0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return super.hasCachedValues();
}","public void test2241() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    recordType0.setPropertyJSDocInfo(""Not declared as a constructor"", jSDocInfo0);
    assertTrue(recordType0.hasCachedValues());
}",""
"public final boolean matchesUint32Context() {
    return matchesNumberContext();
}","public void test2342() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = (InstanceObjectType) numberType0.autoboxesTo();
    boolean boolean0 = instanceObjectType0.matchesUint32Context();
    assertTrue(boolean0);
}","/**
 * This predicate is used to test whether a given type can appear in a
 * 'Uint32' context.  This context includes the right-hand operand of a shift
 * operator.
 */"
"@Override
public boolean hasReferenceName() {
    return getConstructor().hasReferenceName();
}","public void test2343() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = (InstanceObjectType) numberType0.autoboxesTo();
    boolean boolean0 = instanceObjectType0.matchesUint32Context();
    assertTrue(instanceObjectType0.hasReferenceName());
}",""
"@Override
public boolean matchesNumberContext() {
    return isNumberObjectType() || isDateType() || isBooleanObjectType() || isStringObjectType() || hasOverridenNativeProperty(""valueOf"");
}","public void test2444() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    boolean boolean0 = instanceObjectType0.matchesNumberContext();
    assertTrue(boolean0);
}",""
"@Override
public boolean hasReferenceName() {
    return getConstructor().hasReferenceName();
}","public void test2445() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    boolean boolean0 = instanceObjectType0.matchesNumberContext();
    assertTrue(instanceObjectType0.hasReferenceName());
}",""
"@Override
public boolean matchesNumberContext() {
    return isNumberObjectType() || isDateType() || isBooleanObjectType() || isStringObjectType() || hasOverridenNativeProperty(""valueOf"");
}","public void test2546() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""valueOf"");
    JSType[] jSTypeArray0 = new JSType[1];
    Node node0 = jSTypeRegistry0.createParameters(jSTypeArray0);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(errorFunctionType0, node0);
    hashMap0.put(""valueOf"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    boolean boolean0 = recordType0.matchesNumberContext();
    assertTrue(boolean0);
}",""
"@Override
public boolean hasReferenceName() {
    return className != null || ownerFunction != null;
}","public void test2547() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""valueOf"");
    JSType[] jSTypeArray0 = new JSType[1];
    Node node0 = jSTypeRegistry0.createParameters(jSTypeArray0);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(errorFunctionType0, node0);
    hashMap0.put(""valueOf"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    boolean boolean0 = recordType0.matchesNumberContext();
    assertFalse(recordType0.hasReferenceName());
}",""
"@Override
public boolean matchesStringContext() {
    return isTheObjectType() || isStringObjectType() || isDateType() || isRegexpType() || isArrayType() || isNumberObjectType() || isBooleanObjectType() || hasOverridenNativeProperty(""toString"");
}","public void test2648() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""NX\""t"");
    FunctionType functionType0 = errorFunctionType0.getSuperClassConstructor();
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    boolean boolean0 = instanceObjectType0.matchesStringContext();
    assertTrue(boolean0);
}",""
"@Override
public boolean isNominalType() {
    return hasReferenceName();
}","public void test2649() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""NX\""t"");
    FunctionType functionType0 = errorFunctionType0.getSuperClassConstructor();
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    boolean boolean0 = instanceObjectType0.matchesStringContext();
    assertTrue(instanceObjectType0.isNominalType());
}",""
"@Override
public boolean hasReferenceName() {
    return getConstructor().hasReferenceName();
}","public void test2750() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = (InstanceObjectType) numberType0.autoboxesTo();
    boolean boolean0 = instanceObjectType0.matchesStringContext();
    assertTrue(instanceObjectType0.hasReferenceName());
}",""
"@Override
public boolean matchesStringContext() {
    return isTheObjectType() || isStringObjectType() || isDateType() || isRegexpType() || isArrayType() || isNumberObjectType() || isBooleanObjectType() || hasOverridenNativeProperty(""toString"");
}","public void test2751() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = (InstanceObjectType) numberType0.autoboxesTo();
    boolean boolean0 = instanceObjectType0.matchesStringContext();
    assertTrue(boolean0);
}",""
"@Override
public boolean matchesStringContext() {
    return isTheObjectType() || isStringObjectType() || isDateType() || isRegexpType() || isArrayType() || isNumberObjectType() || isBooleanObjectType() || hasOverridenNativeProperty(""toString"");
}","public void test2852() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    boolean boolean0 = instanceObjectType0.matchesStringContext();
    assertTrue(boolean0);
}",""
"@Override
public boolean hasReferenceName() {
    return getConstructor().hasReferenceName();
}","public void test2853() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    boolean boolean0 = instanceObjectType0.matchesStringContext();
    assertTrue(instanceObjectType0.hasReferenceName());
}",""
"@Override
public boolean hasReferenceName() {
    return className != null || ownerFunction != null;
}","public void test2954() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    Node node0 = Node.newNumber((-1079.03800214));
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty((JSType) null, node0);
    hashMap0.put(""toString"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    boolean boolean0 = recordType0.matchesStringContext();
    assertFalse(recordType0.hasReferenceName());
}",""
"@Override
public boolean matchesStringContext() {
    return isTheObjectType() || isStringObjectType() || isDateType() || isRegexpType() || isArrayType() || isNumberObjectType() || isBooleanObjectType() || hasOverridenNativeProperty(""toString"");
}","public void test2955() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    Node node0 = Node.newNumber((-1079.03800214));
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty((JSType) null, node0);
    hashMap0.put(""toString"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    boolean boolean0 = recordType0.matchesStringContext();
    assertTrue(boolean0);
}",""
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test3056() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    boolean boolean0 = errorFunctionType0.matchesStringContext();
    assertTrue(errorFunctionType0.isNominalConstructor());
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"@Override
public boolean matchesStringContext() {
    return isTheObjectType() || isStringObjectType() || isDateType() || isRegexpType() || isArrayType() || isNumberObjectType() || isBooleanObjectType() || hasOverridenNativeProperty(""toString"");
}","public void test3057() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    boolean boolean0 = errorFunctionType0.matchesStringContext();
    assertFalse(boolean0);
}",""
"@Override
public boolean matchesNumberContext() {
    return isNumberObjectType() || isDateType() || isBooleanObjectType() || isStringObjectType() || hasOverridenNativeProperty(""valueOf"");
}","public void test3158() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, """", (Node) null);
    boolean boolean0 = functionType0.matchesNumberContext();
    assertFalse(boolean0);
}",""
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test3159() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, """", (Node) null);
    boolean boolean0 = functionType0.matchesNumberContext();
    assertFalse(functionType0.isNominalConstructor());
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"public boolean isNominalType() {
    return false;
}","public void test3260() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    JSType jSType0 = numberType0.autoboxesTo();
    JSType jSType1 = jSType0.unboxesTo();
    assertTrue(jSType0.isNominalType());
}","/**
 * Whether this type is a nominal type (a named instance object or
 * a named enum).
 */"
"public JSType unboxesTo() {
    return null;
}","public void test3261() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    JSType jSType0 = numberType0.autoboxesTo();
    JSType jSType1 = jSType0.unboxesTo();
    assertNotNull(jSType1);
}","/**
 * Gets the type to which this type unboxes.
 *
 * @return the unboxed type or {@code null} if this type does not unbox.
 */"
"@Override
public boolean hasReferenceName() {
    return getConstructor().hasReferenceName();
}","public void test3362() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    JSType jSType0 = instanceObjectType0.unboxesTo();
    assertTrue(instanceObjectType0.hasReferenceName());
}",""
"@Override
public JSType unboxesTo() {
    if (isStringObjectType()) {
        return getNativeType(JSTypeNative.STRING_TYPE);
    } else if (isBooleanObjectType()) {
        return getNativeType(JSTypeNative.BOOLEAN_TYPE);
    } else if (isNumberObjectType()) {
        return getNativeType(JSTypeNative.NUMBER_TYPE);
    } else {
        return super.unboxesTo();
    }
}","public void test3363() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    JSType jSType0 = instanceObjectType0.unboxesTo();
    assertNotNull(jSType0);
}",""
"@Override
public JSType unboxesTo() {
    if (isStringObjectType()) {
        return getNativeType(JSTypeNative.STRING_TYPE);
    } else if (isBooleanObjectType()) {
        return getNativeType(JSTypeNative.BOOLEAN_TYPE);
    } else if (isNumberObjectType()) {
        return getNativeType(JSTypeNative.NUMBER_TYPE);
    } else {
        return super.unboxesTo();
    }
}","public void test3464() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    JSType jSType0 = noResolvedType0.unboxesTo();
    assertNull(jSType0);
}",""
"@Override
public boolean hasReferenceName() {
    return className != null || ownerFunction != null;
}","public void test3565() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    JSType[] jSTypeArray0 = new JSType[2];
    jSTypeArray0[1] = (JSType) recordType0;
    FunctionType functionType0 = jSTypeRegistry0.createConstructorTypeWithVarArgs(recordType0, jSTypeArray0);
    assertFalse(recordType0.hasReferenceName());
}",""
"@Override
String toStringHelper(boolean forAnnotations) {
    if (hasReferenceName()) {
        return getReferenceName();
    } else if (prettyPrint) {
        // Don't pretty print recursively.
        prettyPrint = false;
        // Use a tree set so that the properties are sorted.
        Set<String> propertyNames = Sets.newTreeSet();
        for (ObjectType current = this; current != null && !current.isNativeObjectType() && propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES; current = current.getImplicitPrototype()) {
            propertyNames.addAll(current.getOwnPropertyNames());
        }
        StringBuilder sb = new StringBuilder();
        sb.append(""{"");
        int i = 0;
        for (String property : propertyNames) {
            if (i > 0) {
                sb.append("", "");
            }
            sb.append(property);
            sb.append("": "");
            sb.append(getPropertyType(property).toStringHelper(forAnnotations));
            ++i;
            if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {
                sb.append("", ..."");
                break;
            }
        }
        sb.append(""}"");
        prettyPrint = true;
        return sb.toString();
    } else {
        return forAnnotations ? ""?"" : ""{...}"";
    }
}","public void test3566() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    JSType[] jSTypeArray0 = new JSType[2];
    jSTypeArray0[1] = (JSType) recordType0;
    FunctionType functionType0 = jSTypeRegistry0.createConstructorTypeWithVarArgs(recordType0, jSTypeArray0);
    recordType0.setOwnerFunction(functionType0);
    String string0 = recordType0.toStringHelper(true);
    assertEquals(""null.prototype"", string0);
}",""
"@Override
String toStringHelper(boolean forAnnotations) {
    if (hasReferenceName()) {
        return getReferenceName();
    } else if (prettyPrint) {
        // Don't pretty print recursively.
        prettyPrint = false;
        // Use a tree set so that the properties are sorted.
        Set<String> propertyNames = Sets.newTreeSet();
        for (ObjectType current = this; current != null && !current.isNativeObjectType() && propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES; current = current.getImplicitPrototype()) {
            propertyNames.addAll(current.getOwnPropertyNames());
        }
        StringBuilder sb = new StringBuilder();
        sb.append(""{"");
        int i = 0;
        for (String property : propertyNames) {
            if (i > 0) {
                sb.append("", "");
            }
            sb.append(property);
            sb.append("": "");
            sb.append(getPropertyType(property).toStringHelper(forAnnotations));
            ++i;
            if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {
                sb.append("", ..."");
                break;
            }
        }
        sb.append(""}"");
        prettyPrint = true;
        return sb.toString();
    } else {
        return forAnnotations ? ""?"" : ""{...}"";
    }
}","public void test3667() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    Node node0 = Node.newString(""com.google.javascript.jscomp.SemanticReverseAbstractInterpreter$RestrictByTrueInstanceOfResultVisitor"", 0, 0);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(numberType0, node0);
    hashMap0.putIfAbsent(""Not declared as a constructor"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    String string0 = recordType0.toStringHelper(true);
    assertNotNull(string0);
}",""
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test3769() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(noType0, (Node) null);
    hashMap0.put(""Not declared as a type name"", recordTypeBuilder_RecordProperty0);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty1 = new RecordTypeBuilder.RecordProperty(voidType0, (Node) null);
    hashMap0.put(""Unknown class name"", recordTypeBuilder_RecordProperty1);
    hashMap0.put(""SP<ufA,)hesR@3"", recordTypeBuilder_RecordProperty1);
    hashMap0.put(""MC7E1F4:3"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    String string0 = recordType0.toStringHelper(false);
    assertFalse(recordType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
String toStringHelper(boolean forAnnotations) {
    if (hasReferenceName()) {
        return getReferenceName();
    } else if (prettyPrint) {
        // Don't pretty print recursively.
        prettyPrint = false;
        // Use a tree set so that the properties are sorted.
        Set<String> propertyNames = Sets.newTreeSet();
        for (ObjectType current = this; current != null && !current.isNativeObjectType() && propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES; current = current.getImplicitPrototype()) {
            propertyNames.addAll(current.getOwnPropertyNames());
        }
        StringBuilder sb = new StringBuilder();
        sb.append(""{"");
        int i = 0;
        for (String property : propertyNames) {
            if (i > 0) {
                sb.append("", "");
            }
            sb.append(property);
            sb.append("": "");
            sb.append(getPropertyType(property).toStringHelper(forAnnotations));
            ++i;
            if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {
                sb.append("", ..."");
                break;
            }
        }
        sb.append(""}"");
        prettyPrint = true;
        return sb.toString();
    } else {
        return forAnnotations ? ""?"" : ""{...}"";
    }
}","public void test3770() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    VoidType voidType0 = new VoidType(jSTypeRegistry0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(noType0, (Node) null);
    hashMap0.put(""Not declared as a type name"", recordTypeBuilder_RecordProperty0);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty1 = new RecordTypeBuilder.RecordProperty(voidType0, (Node) null);
    hashMap0.put(""Unknown class name"", recordTypeBuilder_RecordProperty1);
    hashMap0.put(""SP<ufA,)hesR@3"", recordTypeBuilder_RecordProperty1);
    hashMap0.put(""MC7E1F4:3"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    String string0 = recordType0.toStringHelper(false);
    assertNotNull(string0);
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test3871() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    errorFunctionType0.toAnnotationString();
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public boolean resetImplicitPrototype(JSType type, ObjectType newImplicitProto) {
    if (type instanceof PrototypeObjectType) {
        PrototypeObjectType poType = (PrototypeObjectType) type;
        poType.clearCachedValues();
        poType.setImplicitPrototype(newImplicitProto);
        return true;
    }
    return false;
}","public void test3972() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoType noType0 = new NoType(jSTypeRegistry0);
    JSTypeNative[] jSTypeNativeArray0 = new JSTypeNative[1];
    JSTypeNative jSTypeNative0 = JSTypeNative.FUNCTION_FUNCTION_TYPE;
    jSTypeNativeArray0[0] = jSTypeNative0;
    JSType jSType0 = jSTypeRegistry0.createUnionType(jSTypeNativeArray0);
    // Undeclared exception!
    try {
        jSTypeRegistry0.resetImplicitPrototype(jSType0, noType0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Set the implicit prototype if it's possible to do so.
 * @return True if we were able to set the implicit prototype successfully,
 *     false if it was not possible to do so for some reason. There are
 *     a few different reasons why this could fail: for example, numbers
 *     can't be implicit prototypes, and we don't want to change the implicit
 *     prototype if other classes have already subclassed this one.
 */"
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test4073() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""@iM"");
    ObjectType objectType0 = errorFunctionType0.getParentScope();
    boolean boolean0 = errorFunctionType0.isSubtype(objectType0);
    assertTrue(errorFunctionType0.isNominalConstructor());
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"@Override
public boolean isSubtype(JSType that) {
    if (JSType.isSubtypeHelper(this, that)) {
        return true;
    }
    if (that.isFunctionType()) {
        FunctionType other = that.toMaybeFunctionType();
        if (other.isInterface()) {
            // Any function can be assigned to an interface function.
            return true;
        }
        if (this.isInterface()) {
            // An interface function cannot be assigned to anything.
            return false;
        }
        // If functionA is a subtype of functionB, then their ""this"" types
        // should be contravariant. However, this causes problems because
        // of the way we enforce overrides. Because function(this:SubFoo)
        // is not a subtype of function(this:Foo), our override check treats
        // this as an error. It also screws up out standard method
        // for aliasing constructors. Let's punt on all this for now.
        // TODO(nicksantos): fix this.
        boolean treatThisTypesAsCovariant = // If either one of these is a ctor, skip 'this' checking.
        this.isConstructor() || other.isConstructor() || // An interface 'this'-type is non-restrictive.
        // In practical terms, if C implements I, and I has a method m,
        // then any m doesn't necessarily have to C#m's 'this'
        // type doesn't need to match I.
        (other.typeOfThis.getConstructor() != null && other.typeOfThis.getConstructor().isInterface()) || // If one of the 'this' types is covariant of the other,
        // then we'll treat them as covariant (see comment above).
        other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis);
        return treatThisTypesAsCovariant && this.call.isSubtype(other.call);
    }
    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);
}","public void test4074() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""@iM"");
    ObjectType objectType0 = errorFunctionType0.getParentScope();
    boolean boolean0 = errorFunctionType0.isSubtype(objectType0);
    assertTrue(boolean0);
}","/**
 * A function is a subtype of another if their call methods are related via
 * subtyping and {@code this} is a subtype of {@code that} with regard to
 * the prototype chain.
 */"
"public final boolean isString() {
    return this.isSubtype(getNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE));
}","public void test4175() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = (InstanceObjectType) numberType0.autoboxesTo();
    boolean boolean0 = instanceObjectType0.isString();
    assertFalse(boolean0);
}","/**
 * Tests whether the type is a string (value or Object).
 * @return {@code this &lt;: (String, string)}
 */"
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test4176() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = (InstanceObjectType) numberType0.autoboxesTo();
    boolean boolean0 = instanceObjectType0.isString();
    assertTrue(instanceObjectType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean hasReferenceName() {
    return getConstructor().hasReferenceName();
}","public void test4177() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    NumberType numberType0 = new NumberType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = (InstanceObjectType) numberType0.autoboxesTo();
    boolean boolean0 = instanceObjectType0.isString();
    assertTrue(instanceObjectType0.hasReferenceName());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test4278() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(recordType0, (Node) null);
    hashMap0.put("")jh<s/7x.|.}DA/:$"", recordTypeBuilder_RecordProperty0);
    RecordType recordType1 = new RecordType(jSTypeRegistry0, hashMap0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a constructor"");
    errorFunctionType0.matchConstraint(recordType1);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"@Override
public boolean hasCachedValues() {
    return super.hasCachedValues();
}","public void test4379() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""VHGIOk|KPWJ"", (Node) null);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    boolean boolean0 = instanceObjectType0.isSubtype(functionType0);
    assertTrue(instanceObjectType0.hasCachedValues());
}",""
"@Override
public boolean isSubtype(JSType that) {
    if (JSType.isSubtypeHelper(this, that)) {
        return true;
    }
    // Union types
    if (that.isUnionType()) {
        // The static {@code JSType.isSubtype} check already decomposed
        // union types, so we don't need to check those again.
        return false;
    }
    // record types
    if (that.isRecordType()) {
        return RecordType.isSubtype(this, that.toMaybeRecordType());
    }
    // Interfaces
    // Find all the interfaces implemented by this class and compare each one
    // to the interface instance.
    ObjectType thatObj = that.toObjectType();
    ObjectType thatCtor = thatObj == null ? null : thatObj.getConstructor();
    if (thatCtor != null && thatCtor.isInterface()) {
        Iterable<ObjectType> thisInterfaces = getCtorImplementedInterfaces();
        for (ObjectType thisInterface : thisInterfaces) {
            if (thisInterface.isSubtype(that)) {
                return true;
            }
        }
    }
    if (getConstructor() != null && getConstructor().isInterface()) {
        for (ObjectType thisInterface : getCtorExtendedInterfaces()) {
            if (thisInterface.isSubtype(that)) {
                return true;
            }
        }
    }
    // other prototype based objects
    if (isUnknownType() || implicitPrototypeChainIsUnknown()) {
        // If unsure, say 'yes', to avoid spurious warnings.
        // TODO(user): resolve the prototype chain completely in all cases,
        // to avoid guessing.
        return true;
    }
    return this.isImplicitPrototype(thatObj);
}","public void test4380() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    FunctionType functionType0 = FunctionType.forInterface(jSTypeRegistry0, ""VHGIOk|KPWJ"", (Node) null);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, functionType0);
    boolean boolean0 = instanceObjectType0.isSubtype(functionType0);
    assertFalse(boolean0);
}",""
"@Override
public boolean hasReferenceName() {
    return getConstructor().hasReferenceName();
}","public void test4481() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, noResolvedType0);
    boolean boolean0 = instanceObjectType0.isSubtype(noResolvedType0);
    assertFalse(instanceObjectType0.hasReferenceName());
}",""
"@Override
public boolean isSubtype(JSType that) {
    if (JSType.isSubtypeHelper(this, that)) {
        return true;
    }
    // Union types
    if (that.isUnionType()) {
        // The static {@code JSType.isSubtype} check already decomposed
        // union types, so we don't need to check those again.
        return false;
    }
    // record types
    if (that.isRecordType()) {
        return RecordType.isSubtype(this, that.toMaybeRecordType());
    }
    // Interfaces
    // Find all the interfaces implemented by this class and compare each one
    // to the interface instance.
    ObjectType thatObj = that.toObjectType();
    ObjectType thatCtor = thatObj == null ? null : thatObj.getConstructor();
    if (thatCtor != null && thatCtor.isInterface()) {
        Iterable<ObjectType> thisInterfaces = getCtorImplementedInterfaces();
        for (ObjectType thisInterface : thisInterfaces) {
            if (thisInterface.isSubtype(that)) {
                return true;
            }
        }
    }
    if (getConstructor() != null && getConstructor().isInterface()) {
        for (ObjectType thisInterface : getCtorExtendedInterfaces()) {
            if (thisInterface.isSubtype(that)) {
                return true;
            }
        }
    }
    // other prototype based objects
    if (isUnknownType() || implicitPrototypeChainIsUnknown()) {
        // If unsure, say 'yes', to avoid spurious warnings.
        // TODO(user): resolve the prototype chain completely in all cases,
        // to avoid guessing.
        return true;
    }
    return this.isImplicitPrototype(thatObj);
}","public void test4482() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, noResolvedType0);
    boolean boolean0 = instanceObjectType0.isSubtype(noResolvedType0);
    assertTrue(boolean0);
}",""
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test4483() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, noResolvedType0);
    boolean boolean0 = instanceObjectType0.isSubtype(noResolvedType0);
    assertFalse(instanceObjectType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean hasCachedValues() {
    return super.hasCachedValues();
}","public void test4584() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    ObjectType objectType0 = errorFunctionType0.getInstanceType();
    PrototypeObjectType prototypeObjectType0 = new PrototypeObjectType(jSTypeRegistry0, ""p<#_N&~"", objectType0, false);
    boolean boolean0 = prototypeObjectType0.isSubtype(errorFunctionType0);
    assertTrue(prototypeObjectType0.hasCachedValues());
}",""
"@Override
public boolean isSubtype(JSType that) {
    if (JSType.isSubtypeHelper(this, that)) {
        return true;
    }
    // Union types
    if (that.isUnionType()) {
        // The static {@code JSType.isSubtype} check already decomposed
        // union types, so we don't need to check those again.
        return false;
    }
    // record types
    if (that.isRecordType()) {
        return RecordType.isSubtype(this, that.toMaybeRecordType());
    }
    // Interfaces
    // Find all the interfaces implemented by this class and compare each one
    // to the interface instance.
    ObjectType thatObj = that.toObjectType();
    ObjectType thatCtor = thatObj == null ? null : thatObj.getConstructor();
    if (thatCtor != null && thatCtor.isInterface()) {
        Iterable<ObjectType> thisInterfaces = getCtorImplementedInterfaces();
        for (ObjectType thisInterface : thisInterfaces) {
            if (thisInterface.isSubtype(that)) {
                return true;
            }
        }
    }
    if (getConstructor() != null && getConstructor().isInterface()) {
        for (ObjectType thisInterface : getCtorExtendedInterfaces()) {
            if (thisInterface.isSubtype(that)) {
                return true;
            }
        }
    }
    // other prototype based objects
    if (isUnknownType() || implicitPrototypeChainIsUnknown()) {
        // If unsure, say 'yes', to avoid spurious warnings.
        // TODO(user): resolve the prototype chain completely in all cases,
        // to avoid guessing.
        return true;
    }
    return this.isImplicitPrototype(thatObj);
}","public void test4585() throws Throwable {
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null, false);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, (String) null);
    ObjectType objectType0 = errorFunctionType0.getInstanceType();
    PrototypeObjectType prototypeObjectType0 = new PrototypeObjectType(jSTypeRegistry0, ""p<#_N&~"", objectType0, false);
    boolean boolean0 = prototypeObjectType0.isSubtype(errorFunctionType0);
    assertTrue(boolean0);
}",""
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test4686() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""?"");
    errorFunctionType0.setOwnerFunction(errorFunctionType0);
    errorFunctionType0.setOwnerFunction((FunctionType) null);
    assertTrue(errorFunctionType0.isNominalConstructor());
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"void setOwnerFunction(FunctionType type) {
    Preconditions.checkState(ownerFunction == null || type == null);
    ownerFunction = type;
}","public void test4787() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    NoResolvedType noResolvedType0 = new NoResolvedType(jSTypeRegistry0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""Not declared as a type name"");
    errorFunctionType0.setOwnerFunction(noResolvedType0);
    // Undeclared exception!
    try {
        errorFunctionType0.setOwnerFunction(noResolvedType0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test4888() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    recordType0.getCtorImplementedInterfaces();
    assertFalse(recordType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean hasReferenceName() {
    return className != null || ownerFunction != null;
}","public void test4889() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    RecordType recordType0 = new RecordType(jSTypeRegistry0, hashMap0);
    recordType0.getCtorImplementedInterfaces();
    assertFalse(recordType0.hasReferenceName());
}",""
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test4990() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""toString"");
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    errorFunctionType0.setPropertyJSDocInfo(""toString"", jSDocInfo0);
    assertTrue(errorFunctionType0.hasCachedValues());
}",""
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test4991() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""toString"");
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    errorFunctionType0.setPropertyJSDocInfo(""toString"", jSDocInfo0);
    JSType.safeResolve(errorFunctionType0, simpleErrorReporter0, errorFunctionType0);
    assertTrue(errorFunctionType0.isNominalConstructor());
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"@Override
public boolean hasReferenceName() {
    return getConstructor().hasReferenceName();
}","public void test5092() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""a"");
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, errorFunctionType0, true);
    instanceObjectType0.matchConstraint(errorFunctionType0);
    assertTrue(instanceObjectType0.hasReferenceName());
}",""
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test5093() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ErrorFunctionType errorFunctionType0 = new ErrorFunctionType(jSTypeRegistry0, ""a"");
    InstanceObjectType instanceObjectType0 = new InstanceObjectType(jSTypeRegistry0, errorFunctionType0, true);
    instanceObjectType0.matchConstraint(errorFunctionType0);
    assertTrue(instanceObjectType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
"@Override
public boolean hasReferenceName() {
    return className != null || ownerFunction != null;
}","public void test5194() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    NoType noType0 = new NoType(jSTypeRegistry0);
    Node node0 = new Node(1, 108, 1);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(noType0, node0);
    hashMap0.put(""f@q?7H.}cJ>'Wpmq"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    recordType0.matchConstraint(recordType0);
    assertFalse(recordType0.hasReferenceName());
}",""
"@Override
public boolean hasCachedValues() {
    return super.hasCachedValues();
}","public void test5195() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    NoType noType0 = new NoType(jSTypeRegistry0);
    Node node0 = new Node(1, 108, 1);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(noType0, node0);
    hashMap0.put(""f@q?7H.}cJ>'Wpmq"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    recordType0.matchConstraint(recordType0);
    assertFalse(recordType0.hasCachedValues());
}",""
"@Override
public boolean isNativeObjectType() {
    return nativeType;
}","public void test5196() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    HashMap<String, RecordTypeBuilder.RecordProperty> hashMap0 = new HashMap<String, RecordTypeBuilder.RecordProperty>();
    NoType noType0 = new NoType(jSTypeRegistry0);
    Node node0 = new Node(1, 108, 1);
    RecordTypeBuilder.RecordProperty recordTypeBuilder_RecordProperty0 = new RecordTypeBuilder.RecordProperty(noType0, node0);
    hashMap0.put(""f@q?7H.}cJ>'Wpmq"", recordTypeBuilder_RecordProperty0);
    RecordType recordType0 = jSTypeRegistry0.createRecordType(hashMap0);
    recordType0.matchConstraint(recordType0);
    assertFalse(recordType0.isNativeObjectType());
}","/**
 * Whether this is a built-in object.
 */"
