focal_method,test_prefix,docstring
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test000() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("")c61O2+/IQN!=MR-2"");
    Node node1 = new Node(119, node0, node0, node0, 23, 36);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false);
    controlFlowAnalysis0.process(node1, node1);
    assertEquals(39, Node.EMPTY_BLOCK);
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test011() throws Throwable {
    Node node0 = new Node(127, 127, 127);
    Node node1 = new Node(49, node0, node0, 16, 43);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, true);
    controlFlowAnalysis0.process(node1, node1);
    assertEquals(4095, Node.COLUMN_MASK);
}",""
"ControlFlowGraph<Node> getCfg() {
    return cfg;
}","public void test033() throws Throwable {
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false);
    ControlFlowGraph<Node> controlFlowGraph0 = controlFlowAnalysis0.getCfg();
    assertNull(controlFlowGraph0);
}",""
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    switch(n.getType()) {
        case Token.IF:
            handleIf(n);
            return;
        case Token.WHILE:
            handleWhile(n);
            return;
        case Token.DO:
            handleDo(n);
            return;
        case Token.FOR:
            handleFor(n);
            return;
        case Token.SWITCH:
            handleSwitch(n);
            return;
        case Token.CASE:
            handleCase(n);
            return;
        case Token.DEFAULT:
            handleDefault(n);
            return;
        case Token.BLOCK:
        case Token.SCRIPT:
            handleStmtList(n);
            return;
        case Token.FUNCTION:
            handleFunction(n);
            return;
        case Token.EXPR_RESULT:
            handleExpr(n);
            return;
        case Token.THROW:
            handleThrow(n);
            return;
        case Token.TRY:
            handleTry(n);
            return;
        case Token.CATCH:
            handleCatch(n);
            return;
        case Token.BREAK:
            handleBreak(n);
            return;
        case Token.CONTINUE:
            handleContinue(n);
            return;
        case Token.RETURN:
            handleReturn(n);
            return;
        case Token.WITH:
            handleWith(n);
            return;
        case Token.LABEL:
            return;
        default:
            handleStmt(n);
            return;
    }
}","public void test044() throws Throwable {
    Node node0 = new Node((-42));
    Node node1 = new Node(120, node0, node0, 14, 33);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis((AbstractCompiler) null, true);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, controlFlowAnalysis0);
    // Undeclared exception!
    try {
        controlFlowAnalysis0.visit(nodeTraversal0, node1, node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.ControlFlowAnalysis"", e);
    }
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test055() throws Throwable {
    Node node0 = new Node(103);
    Node node1 = new Node(105, node0, node0, 12, 29);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false);
    // Undeclared exception!
    try {
        controlFlowAnalysis0.process(node1, node1);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // null
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test066() throws Throwable {
    Node node0 = new Node(105, 105, 105);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, true);
    // Undeclared exception!
    try {
        controlFlowAnalysis0.process(node0, node0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // null
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test077() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode("")c61O2+/IQN!=MR-2"", "")c61O2+/IQN!=MR-2"");
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, true);
    Node node1 = new Node(4, node0, node0, node0, node0, 49, 48);
    controlFlowAnalysis0.process(node0, node1);
    assertEquals(12, Node.COLUMN_BITS);
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test088() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("")c61OO2+/IN!=M2"");
    Node node1 = new Node(110, node0, node0, node0, 23, 29);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, true);
    controlFlowAnalysis0.process(node1, node1);
    assertEquals(2, Node.POST_FLAG);
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test099() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(72);
    Node node1 = new Node(111, node0, node0, 4095, 25);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, true);
    node0.addChildrenToFront(node1);
    // Undeclared exception!
    try {
        controlFlowAnalysis0.process(node1, node0);
        fail(""Expecting exception: StackOverflowError"");
    } catch (StackOverflowError e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test1010() throws Throwable {
    Node node0 = new Node(117);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis((AbstractCompiler) null, false);
    node0.addChildrenToFront(node0);
    // Undeclared exception!
    try {
        controlFlowAnalysis0.process(node0, node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.NodeTraversal"", e);
    }
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test1111() throws Throwable {
    Node node0 = new Node(117, 117, 117);
    Node node1 = new Node(118, node0, node0, node0, 39, 19);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis((AbstractCompiler) null, true);
    controlFlowAnalysis0.process(node1, node1);
    assertEquals(4, Node.ENUM_PROP);
}",""
"@Override
public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) {
    astPosition.put(n, astPositionCounter++);
    switch(n.getType()) {
        case Token.FUNCTION:
            if (shouldTraverseFunctions || n == cfg.getEntry().getValue()) {
                exceptionHandler.push(n);
                return true;
            }
            return false;
        case Token.TRY:
            exceptionHandler.push(n);
            return true;
    }
    /*
     * We are going to stop the traversal depending on what the node's parent
     * is.
     *
     * We are only interested in adding edges between nodes that change control
     * flow. The most obvious ones are loops and IF-ELSE's. A statement
     * transfers control to its next sibling.
     *
     * In case of an expression tree, there is no control flow within the tree
     * even when there are short circuited operators and conditionals. When we
     * are doing data flow analysis, we will simply synthesize lattices up the
     * expression tree by finding the meet at each expression node.
     *
     * For example: within a Token.SWITCH, the expression in question does not
     * change the control flow and need not to be considered.
     */
    if (parent != null) {
        switch(parent.getType()) {
            case Token.FOR:
                // Only traverse the body of the for loop.
                return n == parent.getLastChild();
            // Skip the conditions.
            case Token.IF:
            case Token.WHILE:
            case Token.WITH:
                return n != parent.getFirstChild();
            case Token.DO:
                return n != parent.getFirstChild().getNext();
            // Only traverse the body of the cases
            case Token.SWITCH:
            case Token.CASE:
            case Token.CATCH:
            case Token.LABEL:
                return n != parent.getFirstChild();
            case Token.FUNCTION:
                return n == parent.getFirstChild().getNext().getNext();
            case Token.CONTINUE:
            case Token.BREAK:
            case Token.EXPR_RESULT:
            case Token.VAR:
            case Token.RETURN:
            case Token.THROW:
                return false;
            case Token.TRY:
                /* Just before we are about to visit the second child of the TRY node,
           * we know that we will be visiting either the CATCH or the FINALLY.
           * In other words, we know that the post order traversal of the TRY
           * block has been finished, no more exceptions can be caught by the
           * handler at this TRY block and should be taken out of the stack.
           */
                if (n == parent.getFirstChild().getNext()) {
                    Preconditions.checkState(exceptionHandler.peek() == parent);
                    exceptionHandler.pop();
                }
        }
    }
    return true;
}","public void test1212() throws Throwable {
    Compiler compiler0 = new Compiler();
    SyntheticAst syntheticAst0 = new SyntheticAst(""`{,s8u`5e* '8 v"");
    Node node0 = syntheticAst0.getAstRoot(compiler0);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false);
    Node node1 = new Node(120, node0, node0, 18, 14);
    controlFlowAnalysis0.process(node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, controlFlowAnalysis0, (ScopeCreator) null);
    boolean boolean0 = controlFlowAnalysis0.shouldTraverse(nodeTraversal0, node0, node1);
    assertFalse(boolean0);
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test1313() throws Throwable {
    Node node0 = new Node(2337);
    Node node1 = new Node(126, node0, node0, 16, 43);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, true);
    controlFlowAnalysis0.process(node1, node1);
    assertEquals(26, Node.DIRECTCALL_PROP);
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test1414() throws Throwable {
    Node node0 = new Node((-2433));
    Node node1 = new Node((-2433));
    Node node2 = new Node(115, node0, node1, 12, 29);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, true);
    // Undeclared exception!
    try {
        controlFlowAnalysis0.process(node1, node2);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test1515() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("")c6OO2/N!M2"");
    Node node1 = compiler0.parseTestCode("")c6OO2/N!M2"");
    Node node2 = new Node(108, node1, node0, node0, 23, 29);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, true);
    controlFlowAnalysis0.process(node2, node2);
    assertEquals(19, Node.LABEL_PROP);
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test1616() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""a[iBL"");
    Node node1 = compiler0.parseSyntheticCode(""S#xm,}_"");
    Node node2 = new Node(114, node0, node0, node1, 9, 1991);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false);
    controlFlowAnalysis0.process(node2, node2);
    assertEquals(0, Node.LABEL_ID_PROP);
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test1717() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("")c61OO2+/IN!=M2"");
    Node node1 = compiler0.parseTestCode("")c61OO2+/IN!=M2"");
    Node node2 = new Node(110, node1, node0, node0, 23, 29);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, true);
    controlFlowAnalysis0.process(node2, node2);
    assertEquals(48, Node.DIRECTIVES);
}",""
"@Override
public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) {
    astPosition.put(n, astPositionCounter++);
    switch(n.getType()) {
        case Token.FUNCTION:
            if (shouldTraverseFunctions || n == cfg.getEntry().getValue()) {
                exceptionHandler.push(n);
                return true;
            }
            return false;
        case Token.TRY:
            exceptionHandler.push(n);
            return true;
    }
    /*
     * We are going to stop the traversal depending on what the node's parent
     * is.
     *
     * We are only interested in adding edges between nodes that change control
     * flow. The most obvious ones are loops and IF-ELSE's. A statement
     * transfers control to its next sibling.
     *
     * In case of an expression tree, there is no control flow within the tree
     * even when there are short circuited operators and conditionals. When we
     * are doing data flow analysis, we will simply synthesize lattices up the
     * expression tree by finding the meet at each expression node.
     *
     * For example: within a Token.SWITCH, the expression in question does not
     * change the control flow and need not to be considered.
     */
    if (parent != null) {
        switch(parent.getType()) {
            case Token.FOR:
                // Only traverse the body of the for loop.
                return n == parent.getLastChild();
            // Skip the conditions.
            case Token.IF:
            case Token.WHILE:
            case Token.WITH:
                return n != parent.getFirstChild();
            case Token.DO:
                return n != parent.getFirstChild().getNext();
            // Only traverse the body of the cases
            case Token.SWITCH:
            case Token.CASE:
            case Token.CATCH:
            case Token.LABEL:
                return n != parent.getFirstChild();
            case Token.FUNCTION:
                return n == parent.getFirstChild().getNext().getNext();
            case Token.CONTINUE:
            case Token.BREAK:
            case Token.EXPR_RESULT:
            case Token.VAR:
            case Token.RETURN:
            case Token.THROW:
                return false;
            case Token.TRY:
                /* Just before we are about to visit the second child of the TRY node,
           * we know that we will be visiting either the CATCH or the FINALLY.
           * In other words, we know that the post order traversal of the TRY
           * block has been finished, no more exceptions can be caught by the
           * handler at this TRY block and should be taken out of the stack.
           */
                if (n == parent.getFirstChild().getNext()) {
                    Preconditions.checkState(exceptionHandler.peek() == parent);
                    exceptionHandler.pop();
                }
        }
    }
    return true;
}","public void test1818() throws Throwable {
    Node node0 = new Node(59);
    Node node1 = new Node(59);
    Node node2 = new Node(105, node0, node1, 12, 29);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis((AbstractCompiler) null, false);
    controlFlowAnalysis0.process(node1, node1);
    NodeTraversal nodeTraversal0 = new NodeTraversal((AbstractCompiler) null, controlFlowAnalysis0);
    boolean boolean0 = controlFlowAnalysis0.shouldTraverse(nodeTraversal0, node0, node2);
    assertFalse(boolean0);
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test1919() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""left"");
    Node node1 = compiler0.parseSyntheticCode(""left"");
    Node node2 = new Node(77, node1, node1, node0, 44, 33);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false);
    controlFlowAnalysis0.process(node1, node2);
    assertEquals(17, Node.TYPE_PROP);
}",""
"@Override
public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) {
    astPosition.put(n, astPositionCounter++);
    switch(n.getType()) {
        case Token.FUNCTION:
            if (shouldTraverseFunctions || n == cfg.getEntry().getValue()) {
                exceptionHandler.push(n);
                return true;
            }
            return false;
        case Token.TRY:
            exceptionHandler.push(n);
            return true;
    }
    /*
     * We are going to stop the traversal depending on what the node's parent
     * is.
     *
     * We are only interested in adding edges between nodes that change control
     * flow. The most obvious ones are loops and IF-ELSE's. A statement
     * transfers control to its next sibling.
     *
     * In case of an expression tree, there is no control flow within the tree
     * even when there are short circuited operators and conditionals. When we
     * are doing data flow analysis, we will simply synthesize lattices up the
     * expression tree by finding the meet at each expression node.
     *
     * For example: within a Token.SWITCH, the expression in question does not
     * change the control flow and need not to be considered.
     */
    if (parent != null) {
        switch(parent.getType()) {
            case Token.FOR:
                // Only traverse the body of the for loop.
                return n == parent.getLastChild();
            // Skip the conditions.
            case Token.IF:
            case Token.WHILE:
            case Token.WITH:
                return n != parent.getFirstChild();
            case Token.DO:
                return n != parent.getFirstChild().getNext();
            // Only traverse the body of the cases
            case Token.SWITCH:
            case Token.CASE:
            case Token.CATCH:
            case Token.LABEL:
                return n != parent.getFirstChild();
            case Token.FUNCTION:
                return n == parent.getFirstChild().getNext().getNext();
            case Token.CONTINUE:
            case Token.BREAK:
            case Token.EXPR_RESULT:
            case Token.VAR:
            case Token.RETURN:
            case Token.THROW:
                return false;
            case Token.TRY:
                /* Just before we are about to visit the second child of the TRY node,
           * we know that we will be visiting either the CATCH or the FINALLY.
           * In other words, we know that the post order traversal of the TRY
           * block has been finished, no more exceptions can be caught by the
           * handler at this TRY block and should be taken out of the stack.
           */
                if (n == parent.getFirstChild().getNext()) {
                    Preconditions.checkState(exceptionHandler.peek() == parent);
                    exceptionHandler.pop();
                }
        }
    }
    return true;
}","public void test2020() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""com.google.Mavascript.jscomp.ControlFlo!AnalysisAstControlFlowGraph$2"");
    Node node1 = compiler0.parseSyntheticCode(""com.google.Mavascript.jscomp.ControlFlo!AnalysisAstControlFlowGraph$2"");
    Node node2 = new Node(77, node1, node1, node0, 4095, 26);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, true);
    controlFlowAnalysis0.process(node2, node1);
    // Undeclared exception!
    try {
        controlFlowAnalysis0.shouldTraverse((NodeTraversal) null, node0, node2);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    switch(n.getType()) {
        case Token.IF:
            handleIf(n);
            return;
        case Token.WHILE:
            handleWhile(n);
            return;
        case Token.DO:
            handleDo(n);
            return;
        case Token.FOR:
            handleFor(n);
            return;
        case Token.SWITCH:
            handleSwitch(n);
            return;
        case Token.CASE:
            handleCase(n);
            return;
        case Token.DEFAULT:
            handleDefault(n);
            return;
        case Token.BLOCK:
        case Token.SCRIPT:
            handleStmtList(n);
            return;
        case Token.FUNCTION:
            handleFunction(n);
            return;
        case Token.EXPR_RESULT:
            handleExpr(n);
            return;
        case Token.THROW:
            handleThrow(n);
            return;
        case Token.TRY:
            handleTry(n);
            return;
        case Token.CATCH:
            handleCatch(n);
            return;
        case Token.BREAK:
            handleBreak(n);
            return;
        case Token.CONTINUE:
            handleContinue(n);
            return;
        case Token.RETURN:
            handleReturn(n);
            return;
        case Token.WITH:
            handleWith(n);
            return;
        case Token.LABEL:
            return;
        default:
            handleStmt(n);
            return;
    }
}","public void test2121() throws Throwable {
    Node node0 = new Node(105, 105, 105);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, true);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, controlFlowAnalysis0);
    // Undeclared exception!
    try {
        controlFlowAnalysis0.visit(nodeTraversal0, node0, node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test2222() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""h?\"""");
    Node node1 = compiler0.parseTestCode(""h?\"""");
    Node node2 = Node.newString(111, "";]$"");
    Node node3 = new Node(77, node0, node1, node2, 115, 108);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false);
    // Undeclared exception!
    try {
        controlFlowAnalysis0.process((Node) null, node3);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public boolean hasChildren() {
    return first != null;
}","public void test2323() throws Throwable {
    Node node0 = new Node(103);
    Node node1 = new Node(105, node0, node0, 12, 29);
    Compiler compiler0 = new Compiler();
    Node node2 = compiler0.parseSyntheticCode(""*"", ""$iA6vY&QS5:dbf;~Ck1"");
    node2.addChildToFront(node1);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false);
    controlFlowAnalysis0.process(node2, node2);
    assertTrue(node2.hasChildren());
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test2424() throws Throwable {
    Compiler compiler0 = new Compiler();
    ScriptOrFnNode scriptOrFnNode0 = (ScriptOrFnNode) compiler0.parseTestCode(""left"");
    Node node0 = new Node(111, scriptOrFnNode0, scriptOrFnNode0, scriptOrFnNode0, 44, 421);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false);
    controlFlowAnalysis0.process(scriptOrFnNode0, scriptOrFnNode0);
    assertEquals((-2), ScriptOrFnNode.DUPLICATE_CONST);
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test2525() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("")c6OO2/N!=M2"");
    Node node1 = new Node(1, node0, node0, node0, 23, 29);
    node0.setIsSyntheticBlock(true);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, true);
    controlFlowAnalysis0.process(node1, node0);
    assertEquals(15, Node.CASEARRAY_PROP);
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test2626() throws Throwable {
    Node node0 = new Node(116);
    Node node1 = new Node(115, node0, node0, node0, 0, 17);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false);
    controlFlowAnalysis0.process(node1, node0);
    assertEquals(22, Node.TARGETBLOCK_PROP);
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test2727() throws Throwable {
    Node node0 = new Node(117);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis((AbstractCompiler) null, false);
    // Undeclared exception!
    try {
        controlFlowAnalysis0.process(node0, node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.NodeTraversal"", e);
    }
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test2828() throws Throwable {
    Node node0 = new Node(117);
    Node node1 = new Node(115, node0, node0, node0, 39, 19);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis((AbstractCompiler) null, false);
    // Undeclared exception!
    try {
        controlFlowAnalysis0.process(node1, node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.NodeTraversal"", e);
    }
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test2929() throws Throwable {
    Node node0 = new Node(4, 4, 4);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false);
    controlFlowAnalysis0.process(node0, node0);
    assertEquals(44, Node.IS_OPTIONAL_PARAM);
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test3030() throws Throwable {
    Node node0 = new Node(103);
    Node node1 = new Node(103);
    Node node2 = new Node(111, node0, node1, 12, 29);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, true);
    // Undeclared exception!
    try {
        controlFlowAnalysis0.process(node2, node2);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test3232() throws Throwable {
    Node node0 = new Node(103, 103, 103);
    Node node1 = new Node(103, 103, 103);
    Node node2 = new Node(4095, node0, node1, 2, 42);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, true);
    controlFlowAnalysis0.process(node0, node2);
    assertEquals(10, Node.VARS_PROP);
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test3333() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""com.google.javascript.jscomp.ControlFlowAnalysis$AstControlFlowGraph$2"");
    Node node1 = new Node(77, node0, node0, node0, 36, 10);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false);
    // Undeclared exception!
    try {
        controlFlowAnalysis0.process(node1, node1);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test3434() throws Throwable {
    Node node0 = new Node(116, 116, 116);
    MockFile mockFile0 = new MockFile(""XGfS;N+tJG"", ""XGfS;N+tJG"");
    MockPrintStream mockPrintStream0 = new MockPrintStream(mockFile0);
    Compiler compiler0 = new Compiler(mockPrintStream0);
    Node node1 = compiler0.parseSyntheticCode(""com.google.javascript.jscomp.ControlFlowAnalysis$AstControlFlowGraph$2"", ""com.google.javascript.jscomp.ControlFlowAnalysis$AstControlFlowGraph$2"");
    Node node2 = Node.newString(""XGfS;N+tJG"", 26, 98);
    node0.addChildToFront(node2);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false);
    // Undeclared exception!
    try {
        controlFlowAnalysis0.process(node1, node0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // Cannot find break target.
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test3535() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode("")c61OO2+/IQN!=M2"", "")c61OO2+/IQN!=M2"");
    Node node1 = new Node(30, node0, node0, node0, 23, (-539));
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, true);
    controlFlowAnalysis0.process(node0, node1);
    assertEquals(7, Node.LOCAL_PROP);
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test3636() throws Throwable {
    Node node0 = new Node(35);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false);
    controlFlowAnalysis0.process(node0, node0);
    assertEquals(1, Node.SPECIALCALL_EVAL);
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test3737() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(37, 37, 37);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false);
    controlFlowAnalysis0.process(node0, node0);
    assertEquals(49, Node.DIRECT_EVAL);
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test3838() throws Throwable {
    Node node0 = new Node(86, 86, 86);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false);
    controlFlowAnalysis0.process(node0, node0);
    assertEquals(19, Node.LABEL_PROP);
}",""
"public boolean isSyntheticBlock() {
    return getBooleanProp(SYNTHETIC_BLOCK_PROP);
}","public void test3939() throws Throwable {
    Node node0 = new Node(1899);
    Node node1 = new Node(102, node0, node0, node0, 6, 4095);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis((AbstractCompiler) null, false);
    controlFlowAnalysis0.process(node0, node1);
    assertFalse(node0.isSyntheticBlock());
}","/**
 * Returns whether this is a synthetic block that should not be considered
 * a real source block.
 */"
"public int getType() {
    return type;
}","public void test4040() throws Throwable {
    Node node0 = new Node(105, 105, 105);
    Node node1 = new Node(42, node0, node0, node0, 19, (-1542));
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis((AbstractCompiler) null, false);
    controlFlowAnalysis0.process(node1, node1);
    assertEquals(42, node1.getType());
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.getType() == Token.FUNCTION) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test4141() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""com.google.javascript.jsomp.CotrolFlAnalysis$AstControlFlowGraph$2"");
    Node node1 = new Node(0, node0, node0, node0, 36, 10);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false);
    controlFlowAnalysis0.process(node1, node1);
    assertEquals(49, Node.LAST_PROP);
}",""
"static boolean isBreakStructure(Node n, boolean labeled) {
    switch(n.getType()) {
        case Token.FOR:
        case Token.DO:
        case Token.WHILE:
        case Token.SWITCH:
            return true;
        case Token.BLOCK:
        case Token.IF:
        case Token.TRY:
            return labeled;
        default:
            return false;
    }
}","public void test4242() throws Throwable {
    Node node0 = new Node(77);
    boolean boolean0 = ControlFlowAnalysis.isBreakStructure(node0, false);
    assertFalse(boolean0);
}","/**
 * Determines whether the given node can be terminated with a BREAK node.
 */"
"static boolean isBreakStructure(Node n, boolean labeled) {
    switch(n.getType()) {
        case Token.FOR:
        case Token.DO:
        case Token.WHILE:
        case Token.SWITCH:
            return true;
        case Token.BLOCK:
        case Token.IF:
        case Token.TRY:
            return labeled;
        default:
            return false;
    }
}","public void test4343() throws Throwable {
    Node node0 = new Node(103, 103, 103);
    Node node1 = new Node(108, node0, node0, 124, 1);
    boolean boolean0 = ControlFlowAnalysis.isBreakStructure(node1, false);
    assertFalse(boolean0);
}","/**
 * Determines whether the given node can be terminated with a BREAK node.
 */"
"static boolean isBreakStructure(Node n, boolean labeled) {
    switch(n.getType()) {
        case Token.FOR:
        case Token.DO:
        case Token.WHILE:
        case Token.SWITCH:
            return true;
        case Token.BLOCK:
        case Token.IF:
        case Token.TRY:
            return labeled;
        default:
            return false;
    }
}","public void test4444() throws Throwable {
    Node node0 = new Node(110);
    boolean boolean0 = ControlFlowAnalysis.isBreakStructure(node0, false);
    assertTrue(boolean0);
}","/**
 * Determines whether the given node can be terminated with a BREAK node.
 */"
"static boolean isBreakStructure(Node n, boolean labeled) {
    switch(n.getType()) {
        case Token.FOR:
        case Token.DO:
        case Token.WHILE:
        case Token.SWITCH:
            return true;
        case Token.BLOCK:
        case Token.IF:
        case Token.TRY:
            return labeled;
        default:
            return false;
    }
}","public void test4545() throws Throwable {
    Node node0 = new Node(704);
    Node node1 = new Node(113, node0, node0, (-55), 43);
    boolean boolean0 = ControlFlowAnalysis.isBreakStructure(node1, false);
    assertTrue(boolean0);
}","/**
 * Determines whether the given node can be terminated with a BREAK node.
 */"
"static boolean isBreakStructure(Node n, boolean labeled) {
    switch(n.getType()) {
        case Token.FOR:
        case Token.DO:
        case Token.WHILE:
        case Token.SWITCH:
            return true;
        case Token.BLOCK:
        case Token.IF:
        case Token.TRY:
            return labeled;
        default:
            return false;
    }
}","public void test4646() throws Throwable {
    Node node0 = new Node(114);
    boolean boolean0 = ControlFlowAnalysis.isBreakStructure(node0, false);
    assertTrue(boolean0);
}","/**
 * Determines whether the given node can be terminated with a BREAK node.
 */"
"static boolean isBreakStructure(Node n, boolean labeled) {
    switch(n.getType()) {
        case Token.FOR:
        case Token.DO:
        case Token.WHILE:
        case Token.SWITCH:
            return true;
        case Token.BLOCK:
        case Token.IF:
        case Token.TRY:
            return labeled;
        default:
            return false;
    }
}","public void test4747() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode("")c61O2+/IQN!=MR-2"", "")c61O2+/IQN!=MR-2"");
    boolean boolean0 = ControlFlowAnalysis.isBreakStructure(node0, true);
    assertTrue(boolean0);
}","/**
 * Determines whether the given node can be terminated with a BREAK node.
 */"
"static boolean isContinueStructure(Node n) {
    switch(n.getType()) {
        case Token.FOR:
        case Token.DO:
        case Token.WHILE:
            return true;
        default:
            return false;
    }
}","public void test4848() throws Throwable {
    Node node0 = new Node(113, 113, 113);
    boolean boolean0 = ControlFlowAnalysis.isContinueStructure(node0);
    assertTrue(boolean0);
}","/**
 * Determines whether the given node can be advanced with a CONTINUE node.
 */"
"static boolean isContinueStructure(Node n) {
    switch(n.getType()) {
        case Token.FOR:
        case Token.DO:
        case Token.WHILE:
            return true;
        default:
            return false;
    }
}","public void test4949() throws Throwable {
    Node node0 = new Node(114);
    boolean boolean0 = ControlFlowAnalysis.isContinueStructure(node0);
    assertTrue(boolean0);
}","/**
 * Determines whether the given node can be advanced with a CONTINUE node.
 */"
