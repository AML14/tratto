focal_method,test_prefix,docstring
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test000() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNumberType();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    JSTypeNative jSTypeNative0 = JSTypeNative.DATE_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    typeValidator0.expectSwitchMatchesCase(nodeTraversal0, node0, jSType0, functionType0);
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test011() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    CheckLevel checkLevel0 = CheckLevel.ERROR;
    CheckMissingGetCssName checkMissingGetCssName0 = new CheckMissingGetCssName(compiler0, checkLevel0, "" 9+NY"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkMissingGetCssName0);
    typeValidator0.expectValidTypeofName(nodeTraversal0, node0, ""?"");
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test022() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    Normalize.VerifyConstants normalize_VerifyConstants0 = new Normalize.VerifyConstants(compiler0, true);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, normalize_VerifyConstants0);
    TightenTypes tightenTypes0 = new TightenTypes(compiler0);
    JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    ObjectType objectType0 = jSTypeRegistry0.getNativeObjectType(jSTypeNative0);
    typeValidator0.expectNumber(nodeTraversal0, node0, objectType0, ""variable {0} redefined with type {1}, original definition at {2}:{3} with type {4}"");
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public boolean hasCachedValues() {
    return !unknown;
}","public void test023() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    Normalize.VerifyConstants normalize_VerifyConstants0 = new Normalize.VerifyConstants(compiler0, true);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, normalize_VerifyConstants0);
    TightenTypes tightenTypes0 = new TightenTypes(compiler0);
    JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
    JSTypeNative jSTypeNative0 = JSTypeNative.GLOBAL_THIS;
    ObjectType objectType0 = jSTypeRegistry0.getNativeObjectType(jSTypeNative0);
    typeValidator0.expectNumber(nodeTraversal0, node0, objectType0, ""variable {0} redefined with type {1}, original definition at {2}:{3} with type {4}"");
    assertTrue(objectType0.hasCachedValues());
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"InlineProperties(AbstractCompiler compiler) {
    this.compiler = compiler;
    buildInvalidatingTypeSet();
}","public void test034() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode("" 9+NY"");
    InlineProperties inlineProperties0 = new InlineProperties(compiler0);
}",""
"void setShouldReport(boolean report) {
    this.shouldReport = report;
}","public void test045() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode("""");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    typeValidator0.setShouldReport(true);
}",""
"boolean expectObject(NodeTraversal t, Node n, JSType type, String msg) {
    if (!type.matchesObjectContext()) {
        mismatch(t, n, msg, type, OBJECT_TYPE);
        return false;
    }
    return true;
}","public void test067() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    JSTypeNative jSTypeNative0 = JSTypeNative.DATE_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    boolean boolean0 = typeValidator0.expectObject(nodeTraversal0, node0, functionType0, ""8k;Aw-|.G^fIp"");
    assertTrue(boolean0);
}","/**
 * Expect the type to be an object, or a type convertible to object. If the
 * expectation is not met, issue a warning at the provided node's source code
 * position.
 * @return True if there was no warning, false if there was a mismatch.
 */"
"public boolean hasCachedValues() {
    return !unknown;
}","public void test078() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    CheckLevel checkLevel0 = CheckLevel.WARNING;
    CheckMissingGetCssName checkMissingGetCssName0 = new CheckMissingGetCssName(compiler0, checkLevel0, "" 9+NY"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkMissingGetCssName0);
    TightenTypes tightenTypes0 = new TightenTypes(compiler0);
    JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType(jSDocInfo0);
    typeValidator0.expectActualObject(nodeTraversal0, node0, objectType0, ""Object#Element"");
    assertFalse(objectType0.hasCachedValues());
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test079() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    CheckLevel checkLevel0 = CheckLevel.WARNING;
    CheckMissingGetCssName checkMissingGetCssName0 = new CheckMissingGetCssName(compiler0, checkLevel0, "" 9+NY"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkMissingGetCssName0);
    TightenTypes tightenTypes0 = new TightenTypes(compiler0);
    JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType(jSDocInfo0);
    typeValidator0.expectActualObject(nodeTraversal0, node0, objectType0, ""Object#Element"");
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test0810() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("""");
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNumberType();
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    typeValidator0.expectActualObject(nodeTraversal0, node0, jSType0, ""msg.continue.nonloop"");
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public boolean hasCachedValues() {
    return !unknown;
}","public void test0911() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""array access"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType(jSDocInfo0);
    CheckRegExp checkRegExp0 = new CheckRegExp(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkRegExp0);
    typeValidator0.expectAnyObject(nodeTraversal0, node0, objectType0, ""Not declared as a type name"");
    assertTrue(objectType0.hasCachedValues());
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test1012() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("""");
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNumberType();
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    CheckLevel checkLevel0 = CheckLevel.OFF;
    CheckMissingReturn checkMissingReturn0 = new CheckMissingReturn(compiler0, checkLevel0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkMissingReturn0);
    typeValidator0.expectAnyObject(nodeTraversal0, node0, jSType0, ""Object#Element"");
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"@Override
public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
}","public void test1113() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    CheckLevel checkLevel0 = CheckLevel.WARNING;
    CheckMissingGetCssName checkMissingGetCssName0 = new CheckMissingGetCssName(compiler0, checkLevel0, "" 9+NY"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkMissingGetCssName0);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    JSTypeNative jSTypeNative0 = JSTypeNative.NO_RESOLVED_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    typeValidator0.expectAnyObject(nodeTraversal0, node0, functionType0, ""Unknown class name"");
    assertTrue(functionType0.hasCachedValues());
}",""
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test1114() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    CheckLevel checkLevel0 = CheckLevel.WARNING;
    CheckMissingGetCssName checkMissingGetCssName0 = new CheckMissingGetCssName(compiler0, checkLevel0, "" 9+NY"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkMissingGetCssName0);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    JSTypeNative jSTypeNative0 = JSTypeNative.NO_RESOLVED_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    typeValidator0.expectAnyObject(nodeTraversal0, node0, functionType0, ""Unknown class name"");
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test1215() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    CheckLevel checkLevel0 = CheckLevel.WARNING;
    CheckMissingGetCssName checkMissingGetCssName0 = new CheckMissingGetCssName(compiler0, checkLevel0, "" 9+NY"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkMissingGetCssName0);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    TemplateType templateType0 = jSTypeRegistry0.createTemplateType("" 9+NY"");
    typeValidator0.expectString(nodeTraversal0, node0, templateType0, "" 9+NY"");
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public boolean hasCachedValues() {
    return !unknown;
}","public void test1316() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    CheckLevel checkLevel0 = CheckLevel.WARNING;
    CheckMissingGetCssName checkMissingGetCssName0 = new CheckMissingGetCssName(compiler0, checkLevel0, "" 9+NY"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkMissingGetCssName0);
    TightenTypes tightenTypes0 = new TightenTypes(compiler0);
    JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType(jSDocInfo0);
    typeValidator0.expectString(nodeTraversal0, node0, objectType0, ""Object#Element"");
    assertTrue(objectType0.hasCachedValues());
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test1317() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    CheckLevel checkLevel0 = CheckLevel.WARNING;
    CheckMissingGetCssName checkMissingGetCssName0 = new CheckMissingGetCssName(compiler0, checkLevel0, "" 9+NY"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkMissingGetCssName0);
    TightenTypes tightenTypes0 = new TightenTypes(compiler0);
    JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType(jSDocInfo0);
    typeValidator0.expectString(nodeTraversal0, node0, objectType0, ""Object#Element"");
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test1418() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    CheckLevel checkLevel0 = CheckLevel.WARNING;
    CheckMissingGetCssName checkMissingGetCssName0 = new CheckMissingGetCssName(compiler0, checkLevel0, "" 9+NY"");
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    TemplateType templateType0 = jSTypeRegistry0.createTemplateType("" 9+NY"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkMissingGetCssName0, (ScopeCreator) null);
    typeValidator0.expectNumber(nodeTraversal0, node0, templateType0, """");
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public boolean isComma() {
    return this.getType() == Token.COMMA;
}","public void test1519() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    CheckLevel checkLevel0 = CheckLevel.WARNING;
    CheckMissingGetCssName checkMissingGetCssName0 = new CheckMissingGetCssName(compiler0, checkLevel0, "" 9+NY"");
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    TemplateType templateType0 = jSTypeRegistry0.createTemplateType("" 9+NY"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkMissingGetCssName0, (ScopeCreator) null);
    typeValidator0.expectBitwiseable(nodeTraversal0, node0, templateType0, """");
    assertFalse(node0.isComma());
}",""
"public boolean hasCachedValues() {
    return !unknown;
}","public void test1620() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""array access"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType(jSDocInfo0);
    CheckRegExp checkRegExp0 = new CheckRegExp(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkRegExp0);
    typeValidator0.expectBitwiseable(nodeTraversal0, node0, objectType0, ""Not declared as a type name"");
    assertTrue(objectType0.hasCachedValues());
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test1621() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""array access"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType(jSDocInfo0);
    CheckRegExp checkRegExp0 = new CheckRegExp(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkRegExp0);
    typeValidator0.expectBitwiseable(nodeTraversal0, node0, objectType0, ""Not declared as a type name"");
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"void expectStringOrNumber(NodeTraversal t, Node n, JSType type, String msg) {
    if (!type.matchesNumberContext() && !type.matchesStringContext()) {
        mismatch(t, n, msg, type, NUMBER_STRING);
    }
}","public void test1722() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    CheckLevel checkLevel0 = CheckLevel.WARNING;
    CheckMissingGetCssName checkMissingGetCssName0 = new CheckMissingGetCssName(compiler0, checkLevel0, "" 9+NY"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkMissingGetCssName0);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    TemplateType templateType0 = jSTypeRegistry0.createTemplateType("" 9+NY"");
    typeValidator0.expectStringOrNumber(nodeTraversal0, node0, templateType0, ""Not declared as a constructor"");
    assertEquals(37, Node.OPT_ARG_NAME);
}","/**
 * Expect the type to be a number or string, or a type convertible to a number
 * or string. If the expectation is not met, issue a warning at the provided
 * node's source code position.
 */"
"public boolean hasCachedValues() {
    return !unknown;
}","public void test1823() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""array access"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    CheckLevel checkLevel0 = CheckLevel.WARNING;
    CheckMissingGetCssName checkMissingGetCssName0 = new CheckMissingGetCssName(compiler0, checkLevel0, ""array access"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkMissingGetCssName0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType(jSDocInfo0);
    typeValidator0.expectStringOrNumber(nodeTraversal0, node0, objectType0, ""zv-y[|0/N!e9sHo}"");
    assertTrue(objectType0.hasCachedValues());
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test1824() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""array access"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    CheckLevel checkLevel0 = CheckLevel.WARNING;
    CheckMissingGetCssName checkMissingGetCssName0 = new CheckMissingGetCssName(compiler0, checkLevel0, ""array access"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkMissingGetCssName0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType(jSDocInfo0);
    typeValidator0.expectStringOrNumber(nodeTraversal0, node0, objectType0, ""zv-y[|0/N!e9sHo}"");
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test1925() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""vH_ljC#t"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TemplateType templateType0 = jSTypeRegistry0.getObjectElementKey();
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""X{SHS)D6L_E6"", node0, templateType0);
    RemoveUnusedClassProperties removeUnusedClassProperties0 = new RemoveUnusedClassProperties(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, removeUnusedClassProperties0);
    typeValidator0.expectStringOrNumber(nodeTraversal0, (Node) null, enumType0, ""Named type with empty name component"");
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public boolean hasCachedValues() {
    return !unknown;
}","public void test2026() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""array access"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType(jSDocInfo0);
    CheckRegExp checkRegExp0 = new CheckRegExp(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkRegExp0);
    boolean boolean0 = typeValidator0.expectNotNullOrUndefined(nodeTraversal0, node0, objectType0, ""Not declared as a type name"", objectType0);
    assertTrue(objectType0.hasCachedValues());
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"boolean expectNotNullOrUndefined(NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {
    if (!type.isNoType() && !type.isUnknownType() && type.isSubtype(nullOrUndefined) && !containsForwardDeclaredUnresolvedName(type)) {
        // There's one edge case right now that we don't handle well, and
        // that we don't want to warn about.
        // if (this.x == null) {
        //   this.initializeX();
        //   this.x.foo();
        // }
        // In this case, we incorrectly type x because of how we
        // infer properties locally. See issue 109.
        // http://code.google.com/p/closure-compiler/issues/detail?id=109
        //
        // We do not do this inference globally.
        if (n.isGetProp() && !t.inGlobalScope() && type.isNullType()) {
            return true;
        }
        mismatch(t, n, msg, type, expectedType);
        return false;
    }
    return true;
}","public void test2027() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""array access"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType(jSDocInfo0);
    CheckRegExp checkRegExp0 = new CheckRegExp(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkRegExp0);
    boolean boolean0 = typeValidator0.expectNotNullOrUndefined(nodeTraversal0, node0, objectType0, ""Not declared as a type name"", objectType0);
    assertTrue(boolean0);
}","/**
 * Expect the type to be anything but the null or void type. If the
 * expectation is not met, issue a warning at the provided node's
 * source code position. Note that a union type that includes the
 * void type and at least one other type meets the expectation.
 * @return Whether the expectation was met.
 */"
"boolean expectNotNullOrUndefined(NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {
    if (!type.isNoType() && !type.isUnknownType() && type.isSubtype(nullOrUndefined) && !containsForwardDeclaredUnresolvedName(type)) {
        // There's one edge case right now that we don't handle well, and
        // that we don't want to warn about.
        // if (this.x == null) {
        //   this.initializeX();
        //   this.x.foo();
        // }
        // In this case, we incorrectly type x because of how we
        // infer properties locally. See issue 109.
        // http://code.google.com/p/closure-compiler/issues/detail?id=109
        //
        // We do not do this inference globally.
        if (n.isGetProp() && !t.inGlobalScope() && type.isNullType()) {
            return true;
        }
        mismatch(t, n, msg, type, expectedType);
        return false;
    }
    return true;
}","public void test2128() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    CheckLevel checkLevel0 = CheckLevel.WARNING;
    CheckMissingGetCssName checkMissingGetCssName0 = new CheckMissingGetCssName(compiler0, checkLevel0, "" 9+NY"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkMissingGetCssName0);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    TemplateType templateType0 = jSTypeRegistry0.createTemplateType("" 9+NY"");
    boolean boolean0 = typeValidator0.expectNotNullOrUndefined(nodeTraversal0, node0, templateType0, ""Unknown class name"", templateType0);
    assertTrue(boolean0);
}","/**
 * Expect the type to be anything but the null or void type. If the
 * expectation is not met, issue a warning at the provided node's
 * source code position. Note that a union type that includes the
 * void type and at least one other type meets the expectation.
 * @return Whether the expectation was met.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test2229() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    CheckLevel checkLevel0 = CheckLevel.WARNING;
    CheckMissingGetCssName checkMissingGetCssName0 = new CheckMissingGetCssName(compiler0, checkLevel0, "" 9+NY"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkMissingGetCssName0);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    TemplateType templateType0 = jSTypeRegistry0.createTemplateType("" 9+NY"");
    typeValidator0.expectSwitchMatchesCase(nodeTraversal0, node0, templateType0, templateType0);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test2330() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    CheckLevel checkLevel0 = CheckLevel.WARNING;
    CheckMissingGetCssName checkMissingGetCssName0 = new CheckMissingGetCssName(compiler0, checkLevel0, "" 9+NY"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkMissingGetCssName0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNumberType();
    JSTypeNative jSTypeNative0 = JSTypeNative.DATE_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    typeValidator0.expectSwitchMatchesCase(nodeTraversal0, node0, functionType0, jSType0);
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {
    // The NoType check is a hack to make typedefs work OK.
    if (!leftType.isNoType() && !rightType.isSubtype(leftType)) {
        // Do not type-check interface methods, because we expect that
        // they will have dummy implementations that do not match the type
        // annotations.
        JSType ownerType = getJSType(owner);
        if (ownerType.isFunctionPrototypeType()) {
            FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();
            if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {
                return true;
            }
        }
        mismatch(t, n, ""assignment to property "" + propName + "" of "" + getReadableJSTypeName(owner, true), rightType, leftType);
        return false;
    }
    return true;
}","public void test2431() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("""");
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNumberType();
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    CheckLevel checkLevel0 = CheckLevel.OFF;
    CheckMissingReturn checkMissingReturn0 = new CheckMissingReturn(compiler0, checkLevel0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkMissingReturn0);
    JSType jSType1 = modificationVisitor0.caseNoType();
    boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, jSType0, jSType1, node0, ""Unknown class name"");
    assertTrue(boolean0);
}","/**
 * Expect that the first type can be assigned to a symbol of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param owner The owner of the property being assigned to.
 * @param propName The name of the property being assigned to.
 * @return True if the types matched, false otherwise.
 */"
"boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {
    // The NoType check is a hack to make typedefs work OK.
    if (!leftType.isNoType() && !rightType.isSubtype(leftType)) {
        // Do not type-check interface methods, because we expect that
        // they will have dummy implementations that do not match the type
        // annotations.
        JSType ownerType = getJSType(owner);
        if (ownerType.isFunctionPrototypeType()) {
            FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();
            if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {
                return true;
            }
        }
        mismatch(t, n, ""assignment to property "" + propName + "" of "" + getReadableJSTypeName(owner, true), rightType, leftType);
        return false;
    }
    return true;
}","public void test2532() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("""");
    TypeValidator typeValidator0 = compiler0.getTypeValidator();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    TemplateType templateType0 = jSTypeRegistry0.createTemplateType("""");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null, (ScopeCreator) null);
    boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, templateType0, templateType0, node0, ""Object#Element"");
    assertTrue(boolean0);
}","/**
 * Expect that the first type can be assigned to a symbol of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param owner The owner of the property being assigned to.
 * @param propName The name of the property being assigned to.
 * @return True if the types matched, false otherwise.
 */"
"boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {
    if (!rightType.isSubtype(leftType)) {
        mismatch(t, n, msg, rightType, leftType);
        return false;
    }
    return true;
}","public void test2633() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""array access"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType(jSDocInfo0);
    CheckRegExp checkRegExp0 = new CheckRegExp(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkRegExp0);
    boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, node0, objectType0, objectType0, ""Object#Key"");
    assertTrue(boolean0);
}","/**
 * Expect that the first type can be assigned to a symbol of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param msg An extra message for the mismatch warning, if necessary.
 * @return True if the types matched, false otherwise.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test2734() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNumberType();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    JSTypeNative jSTypeNative0 = JSTypeNative.DATE_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, node0, functionType0, jSType0, ""Not declared as a type name"");
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {
    if (!rightType.isSubtype(leftType)) {
        mismatch(t, n, msg, rightType, leftType);
        return false;
    }
    return true;
}","public void test2735() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNumberType();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    JSTypeNative jSTypeNative0 = JSTypeNative.DATE_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    boolean boolean0 = typeValidator0.expectCanAssignTo(nodeTraversal0, node0, functionType0, jSType0, ""Not declared as a type name"");
    assertFalse(boolean0);
}","/**
 * Expect that the first type can be assigned to a symbol of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param msg An extra message for the mismatch warning, if necessary.
 * @return True if the types matched, false otherwise.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test2836() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    CheckLevel checkLevel0 = CheckLevel.WARNING;
    CheckMissingGetCssName checkMissingGetCssName0 = new CheckMissingGetCssName(compiler0, checkLevel0, "" 9+NY"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkMissingGetCssName0);
    TightenTypes tightenTypes0 = new TightenTypes(compiler0);
    JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNumberType();
    typeValidator0.expectArgumentMatchesParameter(nodeTraversal0, node0, jSType0, jSType0, node0, 4095);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"void expectArgumentMatchesParameter(NodeTraversal t, Node n, JSType argType, JSType paramType, Node callNode, int ordinal) {
    if (!argType.isSubtype(paramType)) {
        mismatch(t, n, String.format(""actual parameter %d of %s does not match "" + ""formal parameter"", ordinal, getReadableJSTypeName(callNode.getFirstChild(), false)), argType, paramType);
    }
}","public void test2937() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""H_ljC#t"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNumberType();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    JSTypeNative jSTypeNative0 = JSTypeNative.DATE_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    // Undeclared exception!
    try {
        typeValidator0.expectArgumentMatchesParameter(nodeTraversal0, node0, functionType0, jSType0, node0, 0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeValidator"", e);
    }
}","/**
 * Expect that the type of an argument matches the type of the parameter
 * that it's fulfilling.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param argType The type of the argument.
 * @param paramType The type of the parameter.
 * @param callNode The call node, to help with the warning message.
 * @param ordinal The argument ordinal, to help with the warning message.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test3038() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""array access"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType(jSDocInfo0);
    CheckRegExp checkRegExp0 = new CheckRegExp(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkRegExp0);
    typeValidator0.expectCanOverride(nodeTraversal0, node0, objectType0, objectType0, ""Not declared as a constructor"", objectType0);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"void expectCanOverride(NodeTraversal t, Node n, JSType overridingType, JSType hiddenType, String propertyName, JSType ownerType) {
    if (!overridingType.isSubtype(hiddenType)) {
        registerMismatch(overridingType, hiddenType, report(t.makeError(n, HIDDEN_PROPERTY_MISMATCH, propertyName, ownerType.toString(), hiddenType.toString(), overridingType.toString())));
    }
}","public void test3139() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    CheckLevel checkLevel0 = CheckLevel.WARNING;
    CheckMissingGetCssName checkMissingGetCssName0 = new CheckMissingGetCssName(compiler0, checkLevel0, "" 9+NY"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkMissingGetCssName0);
    TightenTypes tightenTypes0 = new TightenTypes(compiler0);
    JSTypeRegistry jSTypeRegistry0 = tightenTypes0.getTypeRegistry();
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNumberType();
    JSType[] jSTypeArray0 = new JSType[5];
    jSTypeArray0[2] = jSType0;
    jSTypeArray0[4] = jSType0;
    FunctionType functionType0 = jSTypeRegistry0.createConstructorType(jSType0, true, jSTypeArray0);
    // Undeclared exception!
    try {
        typeValidator0.expectCanOverride(nodeTraversal0, node0, functionType0, jSTypeArray0[2], ""x#?q9o'ryW"", functionType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.jstype.FunctionType"", e);
    }
}","/**
 * Expect that the first type can override a property of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param overridingType The overriding type.
 * @param hiddenType The type of the property being overridden.
 * @param propertyName The name of the property, for use in the
 *     warning message.
 * @param ownerType The type of the owner of the property, for use
 *     in the warning message.
 */"
"void expectSuperType(NodeTraversal t, Node n, ObjectType superObject, ObjectType subObject) {
    FunctionType subCtor = subObject.getConstructor();
    ObjectType implicitProto = subObject.getImplicitPrototype();
    ObjectType declaredSuper = implicitProto == null ? null : implicitProto.getImplicitPrototype();
    if (declaredSuper != null && declaredSuper.isTemplatizedType()) {
        declaredSuper = declaredSuper.toMaybeTemplatizedType().getReferencedType();
    }
    if (declaredSuper != null && !(superObject instanceof UnknownType) && !declaredSuper.isEquivalentTo(superObject)) {
        if (declaredSuper.isEquivalentTo(getNativeType(OBJECT_TYPE))) {
            registerMismatch(superObject, declaredSuper, report(t.makeError(n, MISSING_EXTENDS_TAG_WARNING, subObject.toString())));
        } else {
            mismatch(t.getSourceName(), n, ""mismatch in declaration of superclass type"", superObject, declaredSuper);
        }
        // Correct the super type.
        if (!subCtor.hasCachedValues()) {
            subCtor.setPrototypeBasedOn(superObject);
        }
    }
}","public void test3240() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""array access"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType(jSDocInfo0);
    CheckRegExp checkRegExp0 = new CheckRegExp(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkRegExp0);
    // Undeclared exception!
    try {
        typeValidator0.expectSuperType(nodeTraversal0, node0, objectType0, objectType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeValidator"", e);
    }
}","/**
 * Expect that the first type is the direct superclass of the second type.
 *
 * @param t The node traversal.
 * @param n The node where warnings should point to.
 * @param superObject The expected super instance type.
 * @param subObject The sub instance type.
 */"
"public boolean isIf() {
    return this.getType() == Token.IF;
}","public void test3341() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    CheckLevel checkLevel0 = CheckLevel.WARNING;
    CheckMissingGetCssName checkMissingGetCssName0 = new CheckMissingGetCssName(compiler0, checkLevel0, "" 9+NY"");
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    TemplateType templateType0 = jSTypeRegistry0.createTemplateType("" 9+NY"");
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkMissingGetCssName0, (ScopeCreator) null);
    typeValidator0.expectSuperType(nodeTraversal0, node0, templateType0, templateType0);
    assertFalse(node0.isIf());
}",""
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test3442() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("""");
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, false);
    TemplateType templateType0 = jSTypeRegistry0.createTemplateType(""Q\""'"");
    ReferenceCollectingCallback.Behavior referenceCollectingCallback_Behavior0 = ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR;
    ReferenceCollectingCallback referenceCollectingCallback0 = new ReferenceCollectingCallback(compiler0, referenceCollectingCallback_Behavior0);
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
    JSType jSType0 = jSTypeRegistry0.createOptionalType(templateType0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, referenceCollectingCallback0, syntacticScopeCreator0);
    typeValidator0.expectCanCast(nodeTraversal0, node0, jSType0, jSType0);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test3543() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""vH_ljC#t"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TemplateType templateType0 = jSTypeRegistry0.getObjectElementKey();
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""X{SHS)D6L_E6"", node0, templateType0);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNumberType();
    SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
    JSType jSType1 = jSTypeRegistry0.createOptionalType(enumType0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null, syntacticScopeCreator0);
    typeValidator0.expectCanCast(nodeTraversal0, node0, jSType1, jSType0);
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"Var expectUndeclaredVariable(String sourceName, CompilerInput input, Node n, Node parent, Var var, String variableName, JSType newType) {
    Var newVar = var;
    boolean allowDupe = false;
    if (n.isGetProp() || NodeUtil.isObjectLitKey(n)) {
        JSDocInfo info = n.getJSDocInfo();
        if (info == null) {
            info = parent.getJSDocInfo();
        }
        allowDupe = info != null && info.getSuppressions().contains(""duplicate"");
    }
    JSType varType = var.getType();
    // Only report duplicate declarations that have types. Other duplicates
    // will be reported by the syntactic scope creator later in the
    // compilation process.
    if (varType != null && varType != typeRegistry.getNativeType(UNKNOWN_TYPE) && newType != null && newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) {
        // If there are two typed declarations of the same variable, that
        // is an error and the second declaration is ignored, except in the
        // case of native types. A null input type means that the declaration
        // was made in TypedScopeCreator#createInitialScope and is a
        // native type. We should redeclare it at the new input site.
        if (var.input == null) {
            Scope s = var.getScope();
            s.undeclare(var);
            newVar = s.declare(variableName, n, varType, input, false);
            n.setJSType(varType);
            if (parent.isVar()) {
                if (n.getFirstChild() != null) {
                    n.getFirstChild().setJSType(varType);
                }
            } else {
                Preconditions.checkState(parent.isFunction());
                parent.setJSType(varType);
            }
        } else {
            // Always warn about duplicates if the overridden type does not
            // match the original type.
            //
            // If the types match, suppress the warning iff there was a @suppress
            // tag, or if the original declaration was a stub.
            if (!(allowDupe || var.getParentNode().isExprResult()) || !newType.isEquivalentTo(varType)) {
                report(JSError.make(sourceName, n, DUP_VAR_DECLARATION, variableName, newType.toString(), var.getInputName(), String.valueOf(var.nameNode.getLineno()), varType.toString()));
            }
        }
    }
    return newVar;
}","public void test3644() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""array access"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    JSDocInfo jSDocInfo0 = new JSDocInfo();
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType(jSDocInfo0);
    // Undeclared exception!
    try {
        typeValidator0.expectUndeclaredVariable(""Unknown class name"", (CompilerInput) null, node0, node0, (Scope.Var) null, ""Named type with empty name component"", objectType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeValidator"", e);
    }
}","/**
 * Expect that the given variable has not been declared with a type.
 *
 * @param sourceName The name of the source file we're in.
 * @param n The node where warnings should point to.
 * @param parent The parent of {@code n}.
 * @param var The variable that we're checking.
 * @param variableName The name of the variable.
 * @param newType The type being applied to the variable. Mostly just here
 *     for the benefit of the warning.
 * @return The variable we end up with. Most of the time, this will just
 *     be {@code var}, but in some rare cases we will need to declare
 *     a new var with new source info.
 */"
"@Override
public boolean isInterface() {
    return kind == Kind.INTERFACE;
}","public void test3745() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    JSTypeNative jSTypeNative0 = JSTypeNative.DATE_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    typeValidator0.expectAllInterfaceProperties(nodeTraversal0, node0, functionType0);
    assertFalse(functionType0.isInterface());
}",""
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test3846() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TemplateType templateType0 = jSTypeRegistry0.getObjectElementKey();
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Not declared as a constructor"", node0, templateType0);
    ObjectType objectType0 = enumType0.getImplicitPrototype();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, objectType0, enumType0, node0, ""Not declared as a constructor"");
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {
    // The NoType check is a hack to make typedefs work OK.
    if (!leftType.isNoType() && !rightType.isSubtype(leftType)) {
        // Do not type-check interface methods, because we expect that
        // they will have dummy implementations that do not match the type
        // annotations.
        JSType ownerType = getJSType(owner);
        if (ownerType.isFunctionPrototypeType()) {
            FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();
            if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {
                return true;
            }
        }
        mismatch(t, n, ""assignment to property "" + propName + "" of "" + getReadableJSTypeName(owner, true), rightType, leftType);
        return false;
    }
    return true;
}","public void test3847() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TemplateType templateType0 = jSTypeRegistry0.getObjectElementKey();
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Not declared as a constructor"", node0, templateType0);
    ObjectType objectType0 = enumType0.getImplicitPrototype();
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    boolean boolean0 = typeValidator0.expectCanAssignToPropertyOf(nodeTraversal0, node0, objectType0, enumType0, node0, ""Not declared as a constructor"");
    assertFalse(boolean0);
}","/**
 * Expect that the first type can be assigned to a symbol of the second
 * type.
 *
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param owner The owner of the property being assigned to.
 * @param propName The name of the property being assigned to.
 * @return True if the types matched, false otherwise.
 */"
"String getReadableJSTypeName(Node n, boolean dereference) {
    // The best type name is the actual type name.
    // If we're analyzing a GETPROP, the property may be inherited by the
    // prototype chain. So climb the prototype chain and find out where
    // the property was originally defined.
    if (n.isGetProp()) {
        ObjectType objectType = getJSType(n.getFirstChild()).dereference();
        if (objectType != null) {
            String propName = n.getLastChild().getString();
            if (objectType.getConstructor() != null && objectType.getConstructor().isInterface()) {
                objectType = FunctionType.getTopDefiningInterface(objectType, propName);
            } else {
                // classes
                while (objectType != null && !objectType.hasOwnProperty(propName)) {
                    objectType = objectType.getImplicitPrototype();
                }
            }
            // Don't show complex function names or anonymous types.
            // Instead, try to get a human-readable type name.
            if (objectType != null && (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) {
                return objectType.toString() + ""."" + propName;
            }
        }
    }
    JSType type = getJSType(n);
    if (dereference) {
        ObjectType dereferenced = type.dereference();
        if (dereferenced != null) {
            type = dereferenced;
        }
    }
    if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) {
        return type.toString();
    }
    String qualifiedName = n.getQualifiedName();
    if (qualifiedName != null) {
        return qualifiedName;
    } else if (type.isFunctionType()) {
        // Don't show complex function names.
        return ""function"";
    } else {
        return type.toString();
    }
}","public void test3948() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    String string0 = typeValidator0.getReadableJSTypeName(node0, false);
    assertEquals(""?"", string0);
}","/**
 * Given a node, get a human-readable name for the type of that node so
 * that will be easy for the programmer to find the original declaration.
 *
 * For example, if SubFoo's property ""bar"" might have the human-readable
 * name ""Foo.prototype.bar"".
 *
 * @param n The node.
 * @param dereference If true, the type of the node will be dereferenced
 *     to an Object type, if possible.
 */"
"String getReadableJSTypeName(Node n, boolean dereference) {
    // The best type name is the actual type name.
    // If we're analyzing a GETPROP, the property may be inherited by the
    // prototype chain. So climb the prototype chain and find out where
    // the property was originally defined.
    if (n.isGetProp()) {
        ObjectType objectType = getJSType(n.getFirstChild()).dereference();
        if (objectType != null) {
            String propName = n.getLastChild().getString();
            if (objectType.getConstructor() != null && objectType.getConstructor().isInterface()) {
                objectType = FunctionType.getTopDefiningInterface(objectType, propName);
            } else {
                // classes
                while (objectType != null && !objectType.hasOwnProperty(propName)) {
                    objectType = objectType.getImplicitPrototype();
                }
            }
            // Don't show complex function names or anonymous types.
            // Instead, try to get a human-readable type name.
            if (objectType != null && (objectType.getConstructor() != null || objectType.isFunctionPrototypeType())) {
                return objectType.toString() + ""."" + propName;
            }
        }
    }
    JSType type = getJSType(n);
    if (dereference) {
        ObjectType dereferenced = type.dereference();
        if (dereferenced != null) {
            type = dereferenced;
        }
    }
    if (type.isFunctionPrototypeType() || (type.toObjectType() != null && type.toObjectType().getConstructor() != null)) {
        return type.toString();
    }
    String qualifiedName = n.getQualifiedName();
    if (qualifiedName != null) {
        return qualifiedName;
    } else if (type.isFunctionType()) {
        // Don't show complex function names.
        return ""function"";
    } else {
        return type.toString();
    }
}","public void test4049() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("" 9+NY"");
    TypeValidator typeValidator0 = new TypeValidator(compiler0);
    Node node1 = new Node(42, node0, node0, node0, node0, (-2712), 29);
    String string0 = typeValidator0.getReadableJSTypeName(node1, true);
    assertEquals(""this"", string0);
}","/**
 * Given a node, get a human-readable name for the type of that node so
 * that will be easy for the programmer to find the original declaration.
 *
 * For example, if SubFoo's property ""bar"" might have the human-readable
 * name ""Foo.prototype.bar"".
 *
 * @param n The node.
 * @param dereference If true, the type of the node will be dereferenced
 *     to an Object type, if possible.
 */"
