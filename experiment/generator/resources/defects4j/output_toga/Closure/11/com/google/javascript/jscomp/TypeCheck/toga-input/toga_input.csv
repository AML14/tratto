focal_method,test_prefix,docstring
"double getTypedPercent() {
    int total = nullCount + unknownCount + typedCount;
    return (total == 0) ? 0.0 : (100.0 * typedCount) / total;
}","public void test0000() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber(100.0);
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node0, (NodeTraversal.Callback) typeCheck0);
    typeCheck0.getTypedPercent();
}","/**
 * Returns the percentage of nodes typed by the type checker.
 * @return a number between 0.0 and 100.0
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test0011() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3796.095944977192));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(35, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertEquals(30, Node.VAR_ARGS_NAME);
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"public TypeCheck(AbstractCompiler compiler, ReverseAbstractInterpreter reverseInterpreter, JSTypeRegistry typeRegistry, CheckLevel reportMissingOverride, CheckLevel reportUnknownTypes) {
    this(compiler, reverseInterpreter, typeRegistry, null, null, reportMissingOverride, reportUnknownTypes);
}","public void test0022() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    Compiler compiler0 = new Compiler();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    CheckLevel checkLevel0 = CheckLevel.OFF;
    TypeCheck typeCheck0 = null;
    try {
        typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0, checkLevel0, checkLevel0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
    }
}",""
"@Override
public void process(Node externsRoot, Node jsRoot) {
    Preconditions.checkNotNull(scopeCreator);
    Preconditions.checkNotNull(topScope);
    Node externsAndJs = jsRoot.getParent();
    Preconditions.checkState(externsAndJs != null);
    Preconditions.checkState(externsRoot == null || externsAndJs.hasChild(externsRoot));
    if (externsRoot != null) {
        check(externsRoot, true);
    }
    check(jsRoot, false);
}","public void test0033() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3822.821875544676));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(37, node0, node0);
    typeCheck0.processForTesting(node0, node0);
    // Undeclared exception!
    try {
        typeCheck0.process(node0, node1);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Main entry point for this phase of processing. This follows the pattern for
 * JSCompiler phases.
 *
 * @param externsRoot The root of the externs parse tree.
 * @param jsRoot The root of the input parse tree to be checked.
 */"
"@Override
public void process(Node externsRoot, Node jsRoot) {
    Preconditions.checkNotNull(scopeCreator);
    Preconditions.checkNotNull(topScope);
    Node externsAndJs = jsRoot.getParent();
    Preconditions.checkState(externsAndJs != null);
    Preconditions.checkState(externsRoot == null || externsAndJs.hasChild(externsRoot));
    if (externsRoot != null) {
        check(externsRoot, true);
    }
    check(jsRoot, false);
}","public void test0044() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3822.821875544676));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(37, node0, node0);
    typeCheck0.processForTesting(node0, node0);
    // Undeclared exception!
    try {
        typeCheck0.process(node1, node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Main entry point for this phase of processing. This follows the pattern for
 * JSCompiler phases.
 *
 * @param externsRoot The root of the externs parse tree.
 * @param jsRoot The root of the input parse tree to be checked.
 */"
"public Scope processForTesting(Node externsRoot, Node jsRoot) {
    Preconditions.checkState(scopeCreator == null);
    Preconditions.checkState(topScope == null);
    Preconditions.checkState(jsRoot.getParent() != null);
    Node externsAndJsRoot = jsRoot.getParent();
    scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler));
    topScope = scopeCreator.createScope(externsAndJsRoot, null);
    TypeInferencePass inference = new TypeInferencePass(compiler, reverseInterpreter, topScope, scopeCreator);
    inference.process(externsRoot, jsRoot);
    process(externsRoot, jsRoot);
    return topScope;
}","public void test0055() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3797.397032153444));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(42, node0, node0);
    typeCheck0.processForTesting(node0, node0);
    // Undeclared exception!
    try {
        typeCheck0.processForTesting(node1, node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Main entry point of this phase for testing code.
 */"
"public Scope processForTesting(Node externsRoot, Node jsRoot) {
    Preconditions.checkState(scopeCreator == null);
    Preconditions.checkState(topScope == null);
    Preconditions.checkState(jsRoot.getParent() != null);
    Node externsAndJsRoot = jsRoot.getParent();
    scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler));
    topScope = scopeCreator.createScope(externsAndJsRoot, null);
    TypeInferencePass inference = new TypeInferencePass(compiler, reverseInterpreter, topScope, scopeCreator);
    inference.process(externsRoot, jsRoot);
    process(externsRoot, jsRoot);
    return topScope;
}","public void test0066() throws Throwable {
    Compiler compiler0 = new Compiler();
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(googleCodingConvention0, jSTypeRegistry0);
    Node node0 = compiler0.parseTestCode(""(Fissing)"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    JSTypeNative jSTypeNative0 = JSTypeNative.URI_ERROR_FUNCTION_TYPE;
    FunctionType functionType0 = jSTypeRegistry0.getNativeFunctionType(jSTypeNative0);
    Scope scope0 = new Scope(node0, functionType0);
    TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, scope0, (ScopeCreator) null, compilerOptions0.checkGlobalNamesLevel, compilerOptions0.checkGlobalNamesLevel);
    // Undeclared exception!
    try {
        typeCheck0.processForTesting(node0, node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Main entry point of this phase for testing code.
 */"
"public Scope processForTesting(Node externsRoot, Node jsRoot) {
    Preconditions.checkState(scopeCreator == null);
    Preconditions.checkState(topScope == null);
    Preconditions.checkState(jsRoot.getParent() != null);
    Node externsAndJsRoot = jsRoot.getParent();
    scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler));
    topScope = scopeCreator.createScope(externsAndJsRoot, null);
    TypeInferencePass inference = new TypeInferencePass(compiler, reverseInterpreter, topScope, scopeCreator);
    inference.process(externsRoot, jsRoot);
    process(externsRoot, jsRoot);
    return topScope;
}","public void test0077() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    Compiler compiler0 = new Compiler();
    compiler0.initCompilerOptionsIfTesting();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node0 = new Node((-611));
    // Undeclared exception!
    try {
        typeCheck0.processForTesting(node0, node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Main entry point of this phase for testing code.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test0088() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3845.997638529466));
    compiler0.toSource(node0);
    CompilerOptions compilerOptions0 = new CompilerOptions();
    CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null, (ScopeCreator) null);
    TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
    Node[] nodeArray0 = new Node[1];
    nodeArray0[0] = node0;
    Node node1 = new Node(86, nodeArray0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertEquals(16, Node.SOURCENAME_PROP);
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test0099() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3799.2415238348367));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(105, node0, node0);
    // Undeclared exception!
    try {
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}","/**
 * Traverses a node recursively.
 */"
"public String getSourceName() {
    return sourceName;
}","public void test01010() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3797.397032153444));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureCodingConvention closureCodingConvention0 = (ClosureCodingConvention) compiler0.defaultCodingConvention;
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
    SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
    Node node1 = new Node(125, node0, node0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertEquals("""", nodeTraversal0.getSourceName());
}","/**
 * Gets the current input source name.
 *
 * @return A string that may be empty, but not null
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test01111() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3822.821875544676));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(37, node0, node0);
    typeCheck0.processForTesting(node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test01212() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3845.997638529466));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(4, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeCheck"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test01313() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3796.392558868223));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(5, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 5
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test01414() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-1256.818033));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(6, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 6
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test01515() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber(2796.94971040167);
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(7, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 7
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test01616() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3796.095944977192));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(8, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 8
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test01717() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber(100.0);
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
    Node node1 = Node.newString(9, ""100"", 42, 50);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeCheck"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test01818() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-0.5912830825981322));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(10, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public boolean hasErrors() {
    return hasHaltingErrors();
}","public void test01819() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-0.5912830825981322));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(10, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertFalse(compiler0.hasErrors());
}","/**
 * Consults the {@link ErrorManager} to see if we've encountered errors
 * that should halt compilation. <p>
 *
 * If {@link CompilerOptions#ideMode} is {@code true}, this function
 * always returns {@code false} without consulting the error manager. The
 * error manager will continue to be told about new errors and warnings, but
 * the compiler will complete compilation of all inputs.<p>
 */"
"public boolean isGetProp() {
    return this.getType() == Token.GETPROP;
}","public void test01920() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3796.361670421556));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(11, node0, node0);
    typeCheck0.visit((NodeTraversal) null, node1, node0);
    assertFalse(node0.isGetProp());
}",""
"public boolean isTry() {
    return this.getType() == Token.TRY;
}","public void test02021() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3845.997638529466));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
    Node node1 = new Node(12, node0, node0);
    typeCheck0.visit(nodeTraversal0, node1, node1);
    assertFalse(node1.isTry());
}",""
"public int getLineNumber() {
    Node cur = curNode;
    while (cur != null) {
        int line = cur.getLineno();
        if (line >= 0) {
            return line;
        }
        cur = cur.getParent();
    }
    return 0;
}","public void test02122() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber(0.0);
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry((ErrorReporter) null);
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
    Node node1 = new Node(13, node0, node0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertEquals(0, nodeTraversal0.getLineNumber());
}","/**
 * Gets the current line number, or zero if it cannot be determined. The line
 * number is retrieved lazily as a running time optimization.
 */"
"public boolean isWhile() {
    return this.getType() == Token.WHILE;
}","public void test02223() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3848.777093703922));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(15, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertFalse(node1.isWhile());
}",""
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test02324() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3845.997638529466));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(16, 4095, 52);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeCheck"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test02425() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-0.5912830825981322));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(19, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node1);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public boolean isGetElem() {
    return this.getType() == Token.GETELEM;
}","public void test02526() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3845.997638529466));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(closureCodingConvention0);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
    Node node1 = new Node(21, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertFalse(node0.isGetElem());
}",""
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test02627() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3796.095944977192));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(23, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal((AbstractCompiler) null, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node1);
    assertEquals(49, Node.DIRECT_EVAL);
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test02728() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3796.095944977192));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(24, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node1);
    assertEquals(16, Node.SOURCENAME_PROP);
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test02829() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3799.2415238348367));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(25, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertEquals(47, Node.IS_DISPATCHER);
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"public int getLineno() {
    return extractLineno(sourcePosition);
}","public void test02930() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3798.9136336228316));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(26, node0, node0);
    Normalize.NormalizeStatements normalize_NormalizeStatements0 = new Normalize.NormalizeStatements(compiler0, true);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, normalize_NormalizeStatements0);
    typeCheck0.visit(nodeTraversal0, node1, node1);
    assertEquals((-1), node1.getLineno());
}",""
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test03031() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-0.5912830825981322));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(27, node0, node0);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
    assertEquals(41, Node.BRACELESS_TYPE);
}","/**
 * Traverses a node recursively.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test03132() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3797.397032153444));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(28, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node1);
    assertEquals(40, Node.ORIGINALNAME_PROP);
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test03233() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3797.3970322));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = Node.newString(29, ""-3797.3970322"", (-1309), 2);
    // Undeclared exception!
    try {
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}","/**
 * Traverses a node recursively.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test03334() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-1256.818033));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(30, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public boolean hasChildren() {
    return first != null;
}","public void test03435() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3798.9136336228316));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
    Node node1 = Node.newString(31, ""module.exports"", 32, 29);
    typeCheck0.visit(nodeTraversal0, node1, node1);
    assertFalse(node1.hasChildren());
}",""
"public boolean isInc() {
    return this.getType() == Token.INC;
}","public void test03536() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3822.821875544676));
    compiler0.toSource(node0);
    Node node1 = new Node(32, node0, node0);
    CompilerOptions compilerOptions0 = compiler0.options;
    CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
    TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node1);
    assertFalse(node1.isInc());
}",""
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test03637() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber(0.0);
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(33, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // NUMBER 0.0 is not a string node
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test03738() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3799.2415238348367));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(36, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 36
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"public boolean isDo() {
    return this.getType() == Token.DO;
}","public void test03839() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber(0.0);
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = Node.newString(""0"", 2, 45);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
    assertFalse(node1.isDo());
}",""
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test03940() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber(0.0);
    compiler0.toSource(node0);
    SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
    CompilerOptions compilerOptions0 = new CompilerOptions();
    CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
    TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
    Node node1 = new Node(41, node0, node0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertEquals(1, Node.DECR_FLAG);
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test04041() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3845.997638529466));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(42, node0, node0);
    // Undeclared exception!
    try {
        typeCheck0.visit((NodeTraversal) null, node1, node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeCheck"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"public boolean isAdd() {
    return this.getType() == Token.ADD;
}","public void test04142() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber(0.0);
    compiler0.toSource(node0);
    CompilerOptions compilerOptions0 = compiler0.options;
    CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
    TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
    Node node1 = new Node(43, node0, node0);
    typeCheck0.visit((NodeTraversal) null, node1, node0);
    assertFalse(node0.isAdd());
}","/**
 * AST type check methods **
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test04243() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3798.9136336228316));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(44, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal((AbstractCompiler) null, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node1);
    assertEquals(43, Node.IS_CONSTANT_NAME);
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"public boolean hasChildren() {
    return first != null;
}","public void test04344() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber(0.0);
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(45, node0, node0);
    typeCheck0.visit((NodeTraversal) null, node1, node0);
    assertFalse(node0.hasChildren());
}",""
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test04445() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3798.9136336228316));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(46, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node1);
    assertEquals(1, Node.FLAG_GLOBAL_STATE_UNMODIFIED);
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"public boolean isInc() {
    return this.getType() == Token.INC;
}","public void test04546() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-0.5912830825981322));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(47, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node1);
    assertFalse(node1.isInc());
}",""
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test04647() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber(100.0);
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
    Node node1 = new Node(48, node0, node0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 48
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test04748() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3848.777093703922));
    compiler0.toSource(node0);
    SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
    CompilerOptions compilerOptions0 = new CompilerOptions();
    CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
    TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
    Node node1 = new Node(49, node0, node0, node0, 12, 30);
    typeCheck0.visit(nodeTraversal0, node1, node1);
    assertEquals(46, Node.IS_NAMESPACE);
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test04849() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-0.5912830825981322));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = Node.newString(50, ""-0.5912830825981322"");
    Node node2 = new Node(27, node1, node1);
    // Undeclared exception!
    try {
        NodeTraversal.traverse((AbstractCompiler) compiler0, node2, (NodeTraversal.Callback) typeCheck0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // 50
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * Traverses a node recursively.
 */"
"@Override
public double getProgress() {
    return progress;
}","public void test04950() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-0.5912830825981322));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(51, node0, node0);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
    assertEquals(0.0, compiler0.getProgress(), 0.01);
}",""
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test05051() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-1256.818033));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = Node.newString(52, ""pa=clE4"", 32, 139);
    // Undeclared exception!
    try {
        typeCheck0.visit((NodeTraversal) null, node1, node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.TypeCheck"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test05152() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber(0.0);
    compiler0.toSource(node0);
    SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
    CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
    CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
    TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
    Node node1 = new Node(53, node0, node0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 53
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test05253() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    Compiler compiler0 = new Compiler();
    compiler0.initCompilerOptionsIfTesting();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node0 = Node.newString(""left operand"", 158, 158);
    Node node1 = new Node(54, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 54
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test05354() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3848.777093703922));
    compiler0.toSource(node0);
    SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
    CompilerOptions compilerOptions0 = new CompilerOptions();
    CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
    TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
    Node node1 = new Node(55, node0, node0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 55
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test05455() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3797.3970322));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(58, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 58
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test05556() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.parseTestCode(""s{^d|&[+'"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
    ExternExportsPass externExportsPass0 = new ExternExportsPass(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, externExportsPass0, (ScopeCreator) null);
    TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
    Node[] nodeArray0 = new Node[0];
    Node node0 = new Node(60, nodeArray0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node0, node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 60
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test05657() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3798.9136336228316));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(61, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 61
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test05758() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""(Fissing)"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null, (ScopeCreator) null);
    TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
    Node[] nodeArray0 = new Node[1];
    nodeArray0[0] = node0;
    Node node1 = new Node(65, nodeArray0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 65
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test05859() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3845.997638529466));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null, typedScopeCreator0);
    Node node1 = new Node(67, node0, node0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 67
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test05960() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3796.392558868223));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(71, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 71
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test06061() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-0.5912830825981322));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = Node.newString(78, ""6"", 0, 1163);
    // Undeclared exception!
    try {
        typeCheck0.visit((NodeTraversal) null, node1, node1);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 78
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test06162() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber(0.0);
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = Node.newString(79, ""0"", 0, 55);
    // Undeclared exception!
    try {
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // 79
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * Traverses a node recursively.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test06364() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3796.095944977192));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(84, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 84
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"public boolean hasErrors() {
    return hasHaltingErrors();
}","public void test06465() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3799.2415238348367));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(87, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertFalse(compiler0.hasErrors());
}","/**
 * Consults the {@link ErrorManager} to see if we've encountered errors
 * that should halt compilation. <p>
 *
 * If {@link CompilerOptions#ideMode} is {@code true}, this function
 * always returns {@code false} without consulting the error manager. The
 * error manager will continue to be told about new errors and warnings, but
 * the compiler will complete compilation of all inputs.<p>
 */"
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test06466() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3799.2415238348367));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(87, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertEquals(0, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test06567() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber(0.0);
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = Node.newString(95, ""0"", 0, 55);
    // Undeclared exception!
    try {
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}","/**
 * Traverses a node recursively.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test06668() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber(2796.94971040167);
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(97, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node1);
    assertEquals(15, Node.NO_SIDE_EFFECTS);
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"public boolean isGetProp() {
    return this.getType() == Token.GETPROP;
}","public void test06769() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3797.39703215344));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0);
    Node node1 = new Node(98, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertFalse(node0.isGetProp());
}",""
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test06870() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""(Fissing)"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, (NodeTraversal.Callback) null, (ScopeCreator) null);
    TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
    Node[] nodeArray0 = new Node[1];
    nodeArray0[0] = node0;
    Node node1 = new Node(101, nodeArray0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertEquals(4095, Node.MAX_COLUMN_NUMBER);
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"public boolean isTry() {
    return this.getType() == Token.TRY;
}","public void test06971() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3798.103125621546));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, reverseAbstractInterpreter0, jSTypeRegistry0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    Node node1 = new Node(103, node0);
    typeCheck0.visit(nodeTraversal0, node1, (Node) null);
    assertFalse(node1.isTry());
}",""
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test07072() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber(2796.94971040167);
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(105, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // NUMBER 2796.94971040167 is not a string node
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test07173() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3796.833598160275));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
    Node[] nodeArray0 = new Node[1];
    nodeArray0[0] = node0;
    Node node1 = new Node(106, nodeArray0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 106
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test07274() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber(2796.94971040167);
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(107, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 107
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"public boolean isWith() {
    return this.getType() == Token.WITH;
}","public void test07375() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3798.103125621546));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
    Node[] nodeArray0 = new Node[0];
    Node node1 = new Node(108, nodeArray0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertFalse(node1.isWith());
}",""
"public boolean isBlock() {
    return this.getType() == Token.BLOCK;
}","public void test07476() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3797.39703215344));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(110, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node1);
    assertFalse(node1.isBlock());
}",""
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test07577() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3796.392558868223));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(111, node0, node0);
    // Undeclared exception!
    try {
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}","/**
 * Traverses a node recursively.
 */"
"public boolean isAssignAdd() {
    return this.getType() == Token.ASSIGN_ADD;
}","public void test07678() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3797.397032153444));
    compiler0.toSource(node0);
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, (JSTypeRegistry) null);
    Node node1 = new Node(112, node0, node0, node0);
    typeCheck0.visit((NodeTraversal) null, node1, node1);
    assertFalse(node1.isAssignAdd());
}",""
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test07779() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-0.5912830825981322));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = Node.newString(113, ""M)=y<b"", 36, 904);
    typeCheck0.visit((NodeTraversal) null, node1, (Node) null);
    assertEquals(45, Node.IS_VAR_ARGS_PARAM);
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test07880() throws Throwable {
    Compiler compiler0 = new Compiler();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    Node node0 = Node.newNumber(0.0);
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(114, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal((AbstractCompiler) null, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node1);
    assertEquals(51, Node.STATIC_SOURCE_FILE);
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"public boolean isInstanceOf() {
    return this.getType() == Token.INSTANCEOF;
}","public void test07981() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    Node node0 = Node.newNumber(0.0);
    Compiler compiler0 = new Compiler();
    CheckLevel checkLevel0 = CheckLevel.OFF;
    CheckSideEffects checkSideEffects0 = new CheckSideEffects(compiler0, checkLevel0, true);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, checkSideEffects0);
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention(jqueryCodingConvention0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
    Node node1 = new Node(115, node0, node0);
    typeCheck0.visit(nodeTraversal0, node1, node1);
    assertFalse(node1.isInstanceOf());
}",""
"public boolean isInstanceOf() {
    return this.getType() == Token.INSTANCEOF;
}","public void test08082() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3845.997638529466));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(116, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertFalse(node1.isInstanceOf());
}",""
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test08183() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3796.095944977192));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = Node.newString(117, ""could not determine the type of this expression"", 4095, 51);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertEquals(16, Node.FLAG_LOCAL_RESULTS);
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"public int getType() {
    return type;
}","public void test08284() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3797.39703215344));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(119, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node1);
    assertEquals(119, node1.getType());
}",""
"public boolean isThrow() {
    return this.getType() == Token.THROW;
}","public void test08385() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-337.2963172611317));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(120, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertFalse(node0.isThrow());
}",""
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test08486() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3845.997638529466));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(121, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 121
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"public boolean isGetElem() {
    return this.getType() == Token.GETELEM;
}","public void test08587() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3796.095944977192));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
    Node node1 = new Node(122, node0, node0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertFalse(node0.isGetElem());
}",""
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test08688() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3796.392558868223));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(123, 2279, 46);
    // Undeclared exception!
    try {
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // 123
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * Traverses a node recursively.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test08789() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3796.392558868223));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
    Node node1 = new Node(124, node0, node0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertEquals(37, Node.OPT_ARG_NAME);
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test08890() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber(0.0);
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(126, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertEquals(36, Node.QUOTED_PROP);
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test08991() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3797.39703215344));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(127, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 127
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test09092() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3799.2415238348367));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
    Node node1 = new Node(128, node0, node0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 128
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test09193() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    Node node0 = Node.newNumber(0.0);
    Compiler compiler0 = new Compiler();
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = Node.newString(129, ""2P-e3_m9p.z&pzf"", 110, 16);
    // Undeclared exception!
    try {
        typeCheck0.visit((NodeTraversal) null, node1, node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 129
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test09294() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3797.397032153444));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(131, node0, node0);
    // Undeclared exception!
    try {
        typeCheck0.visit((NodeTraversal) null, node1, node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 131
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test09395() throws Throwable {
    Node node0 = Node.newNumber((-1302.779));
    Compiler compiler0 = new Compiler();
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(133, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 133
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test09496() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber(555.79856696);
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, typedScopeCreator0);
    Node node1 = new Node(134, node0, node0, node0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 134
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test09597() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-1812.2566530474));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(135, node0, node0);
    // Undeclared exception!
    try {
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // 135
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * Traverses a node recursively.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test09698() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3796.095944977192));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(136, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 136
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test09799() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3796.361670421556));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = Node.newString(137, """", 4095, 484);
    // Undeclared exception!
    try {
        typeCheck0.visit((NodeTraversal) null, node1, node1);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 137
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test098100() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3845.997638529466));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    Node node1 = Node.newString(138, ""-3845.997638529466"", (-38), 53);
    GroupVariableDeclarations groupVariableDeclarations0 = new GroupVariableDeclarations(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, groupVariableDeclarations0);
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 138
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test099101() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3797.397032153444));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(139, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 139
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test100102() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3798.103125621546));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(140, node0, node0);
    SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 140
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test101103() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3796.095944977192));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
    Node node1 = new Node(141, node0, node0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 141
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test102104() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    Compiler compiler0 = new Compiler();
    compiler0.initCompilerOptionsIfTesting();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    JSType[] jSTypeArray0 = new JSType[0];
    Node node0 = jSTypeRegistry0.createOptionalParameters(jSTypeArray0);
    Node node1 = new Node(142, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 142
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test103105() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-1256.818033));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = Node.newString(143, ""-1256.818033"", (-4317), (-1024));
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, typedScopeCreator0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 143
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test104106() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3845.997638529466));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(144, node0, node0);
    // Undeclared exception!
    try {
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // 144
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * Traverses a node recursively.
 */"
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test105107() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3797.3970322));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(145, node0, node0);
    // Undeclared exception!
    try {
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // 145
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * Traverses a node recursively.
 */"
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test106108() throws Throwable {
    Node node0 = Node.newNumber(0.0);
    Compiler compiler0 = new Compiler();
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    ReverseAbstractInterpreter reverseAbstractInterpreter0 = compiler0.getReverseAbstractInterpreter();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, reverseAbstractInterpreter0, jSTypeRegistry0);
    Node node1 = new Node(146, node0, node0);
    // Undeclared exception!
    try {
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // 146
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * Traverses a node recursively.
 */"
"public boolean isNE() {
    return this.getType() == Token.NE;
}","public void test107109() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3797.397032153444));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(147, node0, node0, node0);
    typeCheck0.visit((NodeTraversal) null, node1, node1);
    assertFalse(node1.isNE());
}",""
"public boolean hasErrors() {
    return hasHaltingErrors();
}","public void test109111() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-6276.1144453));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(149, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertTrue(compiler0.hasErrors());
}","/**
 * Consults the {@link ErrorManager} to see if we've encountered errors
 * that should halt compilation. <p>
 *
 * If {@link CompilerOptions#ideMode} is {@code true}, this function
 * always returns {@code false} without consulting the error manager. The
 * error manager will continue to be told about new errors and warnings, but
 * the compiler will complete compilation of all inputs.<p>
 */"
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test109112() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-6276.1144453));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(149, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertEquals(1, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test110113() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3796.392558868223));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
    Node node1 = new Node(150, node0, node0);
    // Undeclared exception!
    try {
        typeCheck0.visit(nodeTraversal0, node1, node1);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // 150
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test111114() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3796.392558868223));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
    Node node1 = new Node(152, node0, node0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertEquals(55, Node.LAST_PROP);
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"public boolean hasOneChild() {
    return first != null && first == last;
}","public void test112115() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3798.9136336228316));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(googleCodingConvention0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0, jqueryCodingConvention0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, typedScopeCreator0);
    Node node1 = new Node(153, node0, node0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertFalse(node0.hasOneChild());
}","/**
 * Check for one child more efficiently than by iterating over all the
 * children as is done with Node.getChildCount().
 *
 * @return Whether the node has exactly one child.
 */"
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test113116() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber(53.0);
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    GoogleCodingConvention googleCodingConvention0 = new GoogleCodingConvention();
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention(googleCodingConvention0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    TypeCheck typeCheck0 = new TypeCheck(compiler0, semanticReverseAbstractInterpreter0, jSTypeRegistry0);
    Node node1 = new Node(154, node0, node0);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
    assertEquals(8, Node.FLAG_NO_THROWS);
}","/**
 * Traverses a node recursively.
 */"
"public static void traverse(AbstractCompiler compiler, Node root, Callback cb) {
    NodeTraversal t = new NodeTraversal(compiler, cb);
    t.traverse(root);
}","public void test114117() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber(0.0);
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = Node.newString(1, ""0"", 0, 55);
    // Undeclared exception!
    try {
        NodeTraversal.traverse((AbstractCompiler) compiler0, node1, (NodeTraversal.Callback) typeCheck0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // 1
        //
        verifyException(""com.google.javascript.rhino.Token"", e);
    }
}","/**
 * Traverses a node recursively.
 */"
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    JSType childType;
    JSType leftType, rightType;
    Node left, right;
    // To be explicitly set to false if the node is not typeable.
    boolean typeable = true;
    switch(n.getType()) {
        case Token.NAME:
            typeable = visitName(t, n, parent);
            break;
        case Token.PARAM_LIST:
            typeable = false;
            break;
        case Token.COMMA:
            ensureTyped(t, n, getJSType(n.getLastChild()));
            break;
        case Token.TRUE:
        case Token.FALSE:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.THIS:
            ensureTyped(t, n, t.getScope().getTypeOfThis());
            break;
        case Token.NULL:
            ensureTyped(t, n, NULL_TYPE);
            break;
        case Token.NUMBER:
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.STRING:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.STRING_KEY:
            typeable = false;
            break;
        case Token.GETTER_DEF:
        case Token.SETTER_DEF:
            // Object literal keys are handled with OBJECTLIT
            break;
        case Token.ARRAYLIT:
            ensureTyped(t, n, ARRAY_TYPE);
            break;
        case Token.REGEXP:
            ensureTyped(t, n, REGEXP_TYPE);
            break;
        case Token.GETPROP:
            visitGetProp(t, n, parent);
            typeable = !(parent.isAssign() && parent.getFirstChild() == n);
            break;
        case Token.GETELEM:
            visitGetElem(t, n);
            // The type of GETELEM is always unknown, so no point counting that.
            // If that unknown leaks elsewhere (say by an assignment to another
            // variable), then it will be counted.
            typeable = false;
            break;
        case Token.VAR:
            visitVar(t, n);
            typeable = false;
            break;
        case Token.NEW:
            visitNew(t, n);
            break;
        case Token.CALL:
            visitCall(t, n);
            typeable = !parent.isExprResult();
            break;
        case Token.RETURN:
            visitReturn(t, n);
            typeable = false;
            break;
        case Token.DEC:
        case Token.INC:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.NOT:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.VOID:
            ensureTyped(t, n, VOID_TYPE);
            break;
        case Token.TYPEOF:
            ensureTyped(t, n, STRING_TYPE);
            break;
        case Token.BITNOT:
            childType = getJSType(n.getFirstChild());
            if (!childType.matchesInt32Context()) {
                report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString());
            }
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.POS:
        case Token.NEG:
            left = n.getFirstChild();
            validator.expectNumber(t, left, getJSType(left), ""sign operator"");
            ensureTyped(t, n, NUMBER_TYPE);
            break;
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
            {
                left = n.getFirstChild();
                right = n.getLastChild();
                if (left.isTypeOf()) {
                    if (right.isString()) {
                        checkTypeofString(t, right, right.getString());
                    }
                } else if (right.isTypeOf() && left.isString()) {
                    checkTypeofString(t, left, left.getString());
                }
                leftType = getJSType(left);
                rightType = getJSType(right);
                // We do not want to warn about explicit comparisons to VOID. People
                // often do this if they think their type annotations screwed up.
                //
                // We do want to warn about cases where people compare things like
                // (Array|null) == (Function|null)
                // because it probably means they screwed up.
                //
                // This heuristic here is not perfect, but should catch cases we
                // care about without too many false negatives.
                JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
                JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
                TernaryValue result = TernaryValue.UNKNOWN;
                if (n.getType() == Token.EQ || n.getType() == Token.NE) {
                    result = leftTypeRestricted.testForEquality(rightTypeRestricted);
                    if (n.isNE()) {
                        result = result.not();
                    }
                } else {
                    // SHEQ or SHNE
                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
                        result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
                    }
                }
                if (result != TernaryValue.UNKNOWN) {
                    report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());
                }
                ensureTyped(t, n, BOOLEAN_TYPE);
                break;
            }
        case Token.LT:
        case Token.LE:
        case Token.GT:
        case Token.GE:
            leftType = getJSType(n.getFirstChild());
            rightType = getJSType(n.getLastChild());
            if (rightType.isNumber()) {
                validator.expectNumber(t, n, leftType, ""left side of numeric comparison"");
            } else if (leftType.isNumber()) {
                validator.expectNumber(t, n, rightType, ""right side of numeric comparison"");
            } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
                // OK.
            } else {
                // Whether the comparison is numeric will be determined at runtime
                // each time the expression is evaluated. Regardless, both operands
                // should match a string context.
                String message = ""left side of comparison"";
                validator.expectString(t, n, leftType, message);
                validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE));
                message = ""right side of comparison"";
                validator.expectString(t, n, rightType, message);
                validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE));
            }
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.IN:
            validator.expectObject(t, n, getJSType(n.getLastChild()), ""'in' requires an object"");
            left = n.getFirstChild();
            validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.INSTANCEOF:
            left = n.getFirstChild();
            right = n.getLastChild();
            rightType = getJSType(right).restrictByNotNullOrUndefined();
            validator.expectAnyObject(t, left, getJSType(left), ""deterministic instanceof yields false"");
            validator.expectActualObject(t, right, rightType, ""instanceof requires an object"");
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.ASSIGN:
            visitAssign(t, n);
            typeable = false;
            break;
        case Token.ASSIGN_LSH:
        case Token.ASSIGN_RSH:
        case Token.ASSIGN_URSH:
        case Token.ASSIGN_DIV:
        case Token.ASSIGN_MOD:
        case Token.ASSIGN_BITOR:
        case Token.ASSIGN_BITXOR:
        case Token.ASSIGN_BITAND:
        case Token.ASSIGN_SUB:
        case Token.ASSIGN_ADD:
        case Token.ASSIGN_MUL:
        case Token.LSH:
        case Token.RSH:
        case Token.URSH:
        case Token.DIV:
        case Token.MOD:
        case Token.BITOR:
        case Token.BITXOR:
        case Token.BITAND:
        case Token.SUB:
        case Token.ADD:
        case Token.MUL:
            visitBinaryOperator(n.getType(), t, n);
            break;
        case Token.DELPROP:
            ensureTyped(t, n, BOOLEAN_TYPE);
            break;
        case Token.CASE:
            JSType switchType = getJSType(parent.getFirstChild());
            JSType caseType = getJSType(n.getFirstChild());
            validator.expectSwitchMatchesCase(t, n, switchType, caseType);
            typeable = false;
            break;
        case Token.WITH:
            {
                Node child = n.getFirstChild();
                childType = getJSType(child);
                validator.expectObject(t, child, childType, ""with requires an object"");
                typeable = false;
                break;
            }
        case Token.FUNCTION:
            visitFunction(t, n);
            break;
        // These nodes have no interesting type behavior.
        case Token.LABEL:
        case Token.LABEL_NAME:
        case Token.SWITCH:
        case Token.BREAK:
        case Token.CATCH:
        case Token.TRY:
        case Token.SCRIPT:
        case Token.EXPR_RESULT:
        case Token.BLOCK:
        case Token.EMPTY:
        case Token.DEFAULT_CASE:
        case Token.CONTINUE:
        case Token.DEBUGGER:
        case Token.THROW:
            typeable = false;
            break;
        // These nodes require data flow analysis.
        case Token.DO:
        case Token.FOR:
        case Token.IF:
        case Token.WHILE:
            typeable = false;
            break;
        // These nodes are typed during the type inference.
        case Token.AND:
        case Token.HOOK:
        case Token.OBJECTLIT:
        case Token.OR:
            if (n.getJSType() != null) {
                // If we didn't run type inference.
                ensureTyped(t, n);
            } else {
                // If this is an enum, then give that type to the objectlit as well.
                if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
                    ensureTyped(t, n, parent.getJSType());
                } else {
                    ensureTyped(t, n);
                }
            }
            if (n.isObjectLit()) {
                for (Node key : n.children()) {
                    visitObjLitKey(t, key, n);
                }
            }
            break;
        default:
            report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
            ensureTyped(t, n);
            break;
    }
    // Don't count externs since the user's code may not even use that part.
    typeable = typeable && !inExterns;
    if (typeable) {
        doPercentTypedAccounting(t, n);
    }
    checkNoTypeCheckSection(n, false);
}","public void test115118() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber(2796.94971040167);
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(100, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertEquals(46, Node.IS_NAMESPACE);
}","/**
 * This is the meat of the type checking.  It is basically one big switch,
 * with each case representing one type of parse tree node.  The individual
 * cases are usually pretty straightforward.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */"
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test116119() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    Compiler compiler0 = new Compiler();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    Node node0 = compiler0.parseTestCode(""(Fissing)"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    CheckLevel checkLevel0 = CheckLevel.ERROR;
    TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, (Scope) null, (ScopeCreator) null, compilerOptions0.checkMissingGetCssNameLevel, checkLevel0);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node0, (NodeTraversal.Callback) typeCheck0);
    assertEquals(1, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"public boolean hasErrors() {
    return hasHaltingErrors();
}","public void test116120() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    Compiler compiler0 = new Compiler();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    Node node0 = compiler0.parseTestCode(""(Fissing)"");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    CheckLevel checkLevel0 = CheckLevel.ERROR;
    TypeCheck typeCheck0 = new TypeCheck(compiler0, closureReverseAbstractInterpreter0, jSTypeRegistry0, (Scope) null, (ScopeCreator) null, compilerOptions0.checkMissingGetCssNameLevel, checkLevel0);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node0, (NodeTraversal.Callback) typeCheck0);
    assertTrue(compiler0.hasErrors());
}","/**
 * Consults the {@link ErrorManager} to see if we've encountered errors
 * that should halt compilation. <p>
 *
 * If {@link CompilerOptions#ideMode} is {@code true}, this function
 * always returns {@code false} without consulting the error manager. The
 * error manager will continue to be told about new errors and warnings, but
 * the compiler will complete compilation of all inputs.<p>
 */"
"boolean visitName(NodeTraversal t, Node n, Node parent) {
    // At this stage, we need to determine whether this is a leaf
    // node in an expression (which therefore needs to have a type
    // assigned for it) versus some other decorative node that we
    // can safely ignore.  Function names, arguments (children of LP nodes) and
    // variable declarations are ignored.
    // TODO(user): remove this short-circuiting in favor of a
    // pre order traversal of the FUNCTION, CATCH, LP and VAR nodes.
    int parentNodeType = parent.getType();
    if (parentNodeType == Token.FUNCTION || parentNodeType == Token.CATCH || parentNodeType == Token.PARAM_LIST || parentNodeType == Token.VAR) {
        return false;
    }
    JSType type = n.getJSType();
    if (type == null) {
        type = getNativeType(UNKNOWN_TYPE);
        Var var = t.getScope().getVar(n.getString());
        if (var != null) {
            JSType varType = var.getType();
            if (varType != null) {
                type = varType;
            }
        }
    }
    ensureTyped(t, n, type);
    return true;
}","public void test117121() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber(2523.33497);
    compiler0.toSource(node0);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
    Node node1 = new Node(105, node0, node0);
    boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node0, node1);
    assertFalse(boolean0);
}","/**
 * Visits a NAME node.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 * @return whether the node is typeable or not
 */"
"boolean visitName(NodeTraversal t, Node n, Node parent) {
    // At this stage, we need to determine whether this is a leaf
    // node in an expression (which therefore needs to have a type
    // assigned for it) versus some other decorative node that we
    // can safely ignore.  Function names, arguments (children of LP nodes) and
    // variable declarations are ignored.
    // TODO(user): remove this short-circuiting in favor of a
    // pre order traversal of the FUNCTION, CATCH, LP and VAR nodes.
    int parentNodeType = parent.getType();
    if (parentNodeType == Token.FUNCTION || parentNodeType == Token.CATCH || parentNodeType == Token.PARAM_LIST || parentNodeType == Token.VAR) {
        return false;
    }
    JSType type = n.getJSType();
    if (type == null) {
        type = getNativeType(UNKNOWN_TYPE);
        Var var = t.getScope().getVar(n.getString());
        if (var != null) {
            JSType varType = var.getType();
            if (varType != null) {
                type = varType;
            }
        }
    }
    ensureTyped(t, n, type);
    return true;
}","public void test118122() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-337.2963172611317));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(120, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, (ScopeCreator) null);
    boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node1, node1);
    assertFalse(boolean0);
}","/**
 * Visits a NAME node.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 * @return whether the node is typeable or not
 */"
"boolean visitName(NodeTraversal t, Node n, Node parent) {
    // At this stage, we need to determine whether this is a leaf
    // node in an expression (which therefore needs to have a type
    // assigned for it) versus some other decorative node that we
    // can safely ignore.  Function names, arguments (children of LP nodes) and
    // variable declarations are ignored.
    // TODO(user): remove this short-circuiting in favor of a
    // pre order traversal of the FUNCTION, CATCH, LP and VAR nodes.
    int parentNodeType = parent.getType();
    if (parentNodeType == Token.FUNCTION || parentNodeType == Token.CATCH || parentNodeType == Token.PARAM_LIST || parentNodeType == Token.VAR) {
        return false;
    }
    JSType type = n.getJSType();
    if (type == null) {
        type = getNativeType(UNKNOWN_TYPE);
        Var var = t.getScope().getVar(n.getString());
        if (var != null) {
            JSType varType = var.getType();
            if (varType != null) {
                type = varType;
            }
        }
    }
    ensureTyped(t, n, type);
    return true;
}","public void test119123() throws Throwable {
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    Compiler compiler0 = new Compiler();
    compiler0.initCompilerOptionsIfTesting();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    TypedScopeCreator typedScopeCreator0 = new TypedScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, typedScopeCreator0);
    JSType[] jSTypeArray0 = new JSType[0];
    Node node0 = jSTypeRegistry0.createOptionalParameters(jSTypeArray0);
    boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node0, node0);
    assertFalse(boolean0);
}","/**
 * Visits a NAME node.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 * @return whether the node is typeable or not
 */"
"boolean visitName(NodeTraversal t, Node n, Node parent) {
    // At this stage, we need to determine whether this is a leaf
    // node in an expression (which therefore needs to have a type
    // assigned for it) versus some other decorative node that we
    // can safely ignore.  Function names, arguments (children of LP nodes) and
    // variable declarations are ignored.
    // TODO(user): remove this short-circuiting in favor of a
    // pre order traversal of the FUNCTION, CATCH, LP and VAR nodes.
    int parentNodeType = parent.getType();
    if (parentNodeType == Token.FUNCTION || parentNodeType == Token.CATCH || parentNodeType == Token.PARAM_LIST || parentNodeType == Token.VAR) {
        return false;
    }
    JSType type = n.getJSType();
    if (type == null) {
        type = getNativeType(UNKNOWN_TYPE);
        Var var = t.getScope().getVar(n.getString());
        if (var != null) {
            JSType varType = var.getType();
            if (varType != null) {
                type = varType;
            }
        }
    }
    ensureTyped(t, n, type);
    return true;
}","public void test120124() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3799.2415238348367));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = Node.newString(118, ""-3799.2415238348367"", 123, 36);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node1, node1);
    assertFalse(boolean0);
}","/**
 * Visits a NAME node.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 * @return whether the node is typeable or not
 */"
"boolean visitName(NodeTraversal t, Node n, Node parent) {
    // At this stage, we need to determine whether this is a leaf
    // node in an expression (which therefore needs to have a type
    // assigned for it) versus some other decorative node that we
    // can safely ignore.  Function names, arguments (children of LP nodes) and
    // variable declarations are ignored.
    // TODO(user): remove this short-circuiting in favor of a
    // pre order traversal of the FUNCTION, CATCH, LP and VAR nodes.
    int parentNodeType = parent.getType();
    if (parentNodeType == Token.FUNCTION || parentNodeType == Token.CATCH || parentNodeType == Token.PARAM_LIST || parentNodeType == Token.VAR) {
        return false;
    }
    JSType type = n.getJSType();
    if (type == null) {
        type = getNativeType(UNKNOWN_TYPE);
        Var var = t.getScope().getVar(n.getString());
        if (var != null) {
            JSType varType = var.getType();
            if (varType != null) {
                type = varType;
            }
        }
    }
    ensureTyped(t, n, type);
    return true;
}","public void test121125() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber(2796.94971040167);
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node0, node0);
    boolean boolean0 = typeCheck0.visitName(nodeTraversal0, node0, node0);
    assertTrue(boolean0);
}","/**
 * Visits a NAME node.
 *
 * @param t The node traversal object that supplies context, such as the
 * scope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 * @return whether the node is typeable or not
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test122126() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-1256.818033));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(30, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node0, (NodeTraversal.Callback) typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertEquals(1, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public boolean hasErrors() {
    return hasHaltingErrors();
}","public void test122127() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-1256.818033));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    Node node1 = new Node(30, node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    NodeTraversal.traverse((AbstractCompiler) compiler0, node0, (NodeTraversal.Callback) typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertFalse(compiler0.hasErrors());
}","/**
 * Consults the {@link ErrorManager} to see if we've encountered errors
 * that should halt compilation. <p>
 *
 * If {@link CompilerOptions#ideMode} is {@code true}, this function
 * always returns {@code false} without consulting the error manager. The
 * error manager will continue to be told about new errors and warnings, but
 * the compiler will complete compilation of all inputs.<p>
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test123128() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3822.821875544676));
    compiler0.toSource(node0);
    Node node1 = new Node(37, node0, node0);
    CompilerOptions compilerOptions0 = compiler0.options;
    CleanupPasses cleanupPasses0 = new CleanupPasses(compilerOptions0);
    TypeCheck typeCheck0 = cleanupPasses0.makeTypeCheck(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0);
    typeCheck0.visit(nodeTraversal0, node1, node1);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test124129() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber(120.23565214940986);
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
    Node node1 = Node.newString(18, ""120.23565214940986"", 42, 50);
    node1.addChildrenToFront(node0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"public int getErrorCount() {
    return errorManager.getErrorCount();
}","public void test124130() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber(120.23565214940986);
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
    Node node1 = Node.newString(18, ""120.23565214940986"", 42, 50);
    node1.addChildrenToFront(node0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertEquals(0, compiler0.getErrorCount());
}","/**
 * Gets the number of errors.
 */"
"public boolean hasErrors() {
    return hasHaltingErrors();
}","public void test124131() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber(120.23565214940986);
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    SyntacticScopeCreator syntacticScopeCreator0 = new SyntacticScopeCreator(compiler0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, typeCheck0, syntacticScopeCreator0);
    Node node1 = Node.newString(18, ""120.23565214940986"", 42, 50);
    node1.addChildrenToFront(node0);
    typeCheck0.visit(nodeTraversal0, node1, node0);
    assertFalse(compiler0.hasErrors());
}","/**
 * Consults the {@link ErrorManager} to see if we've encountered errors
 * that should halt compilation. <p>
 *
 * If {@link CompilerOptions#ideMode} is {@code true}, this function
 * always returns {@code false} without consulting the error manager. The
 * error manager will continue to be told about new errors and warnings, but
 * the compiler will complete compilation of all inputs.<p>
 */"
"public int getWarningCount() {
    return errorManager.getWarningCount();
}","public void test125132() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-3822.821875544676));
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    node0.addSuppression(""-3822.821875544676"");
    Node node1 = new Node(37, node0, node0);
    typeCheck0.processForTesting(node0, node0);
    assertEquals(0, compiler0.getWarningCount());
}","/**
 * Gets the number of warnings.
 */"
"double getTypedPercent() {
    int total = nullCount + unknownCount + typedCount;
    return (total == 0) ? 0.0 : (100.0 * typedCount) / total;
}","public void test126133() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber(2796.94971040167);
    compiler0.toSource(node0);
    JSTypeRegistry jSTypeRegistry0 = compiler0.getTypeRegistry();
    TypeCheck typeCheck0 = new TypeCheck(compiler0, (ReverseAbstractInterpreter) null, jSTypeRegistry0);
    double double0 = typeCheck0.getTypedPercent();
    assertEquals(0.0, double0, 0.01);
}","/**
 * Returns the percentage of nodes typed by the type checker.
 * @return a number between 0.0 and 100.0
 */"
