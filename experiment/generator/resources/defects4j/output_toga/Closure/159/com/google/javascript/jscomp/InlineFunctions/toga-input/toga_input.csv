focal_method,test_prefix,docstring
"public void enableSpecialization(SpecializeModule.SpecializationState specializationState) {
    this.specializationState = specializationState;
}","public void test000() throws Throwable {
    Compiler compiler0 = new Compiler();
    Supplier<String> supplier0 = compiler0.getUniqueNameIdSupplier();
    InlineFunctions inlineFunctions0 = new InlineFunctions(compiler0, supplier0, false, false, false);
    inlineFunctions0.enableSpecialization((SpecializeModule.SpecializationState) null);
}",""
"InlineFunctions(AbstractCompiler compiler, Supplier<String> safeNameIdSupplier, boolean inlineGlobalFunctions, boolean inlineLocalFunctions, boolean blockFunctionInliningEnabled) {
    Preconditions.checkArgument(compiler != null);
    Preconditions.checkArgument(safeNameIdSupplier != null);
    this.compiler = compiler;
    this.inlineGlobalFunctions = inlineGlobalFunctions;
    this.inlineLocalFunctions = inlineLocalFunctions;
    this.blockFunctionInliningEnabled = blockFunctionInliningEnabled;
    this.injector = new FunctionInjector(compiler, safeNameIdSupplier, true);
}","public void test022() throws Throwable {
    InlineFunctions inlineFunctions0 = null;
    try {
        inlineFunctions0 = new InlineFunctions((AbstractCompiler) null, (Supplier<String>) null, false, false, false);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"InlineFunctions(AbstractCompiler compiler, Supplier<String> safeNameIdSupplier, boolean inlineGlobalFunctions, boolean inlineLocalFunctions, boolean blockFunctionInliningEnabled) {
    Preconditions.checkArgument(compiler != null);
    Preconditions.checkArgument(safeNameIdSupplier != null);
    this.compiler = compiler;
    this.inlineGlobalFunctions = inlineGlobalFunctions;
    this.inlineLocalFunctions = inlineLocalFunctions;
    this.blockFunctionInliningEnabled = blockFunctionInliningEnabled;
    this.injector = new FunctionInjector(compiler, safeNameIdSupplier, true);
}","public void test033() throws Throwable {
    Compiler compiler0 = new Compiler();
    InlineFunctions inlineFunctions0 = null;
    try {
        inlineFunctions0 = new InlineFunctions(compiler0, (Supplier<String>) null, false, false, false);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"@Override
public void process(Node externs, Node root) {
    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());
    NodeTraversal.traverse(compiler, root, new FindCandidateFunctions());
    if (fns.isEmpty()) {
        // Nothing left to do.
        return;
    }
    NodeTraversal.traverse(compiler, root, new FindCandidatesReferences(fns, anonFns));
    trimCanidatesNotMeetingMinimumRequirements();
    if (fns.isEmpty()) {
        // Nothing left to do.
        return;
    }
    // Store the set of function names eligible for inlining and use this to
    // prevent function names from being moved into temporaries during
    // expression decomposition. If this movement were allowed it would prevent
    // the Inline callback from finding the function calls.
    //
    // This pass already assumes these are constants, so this is safe for anyone
    // using function inlining.
    //
    Set<String> fnNames = Sets.newHashSet(fns.keySet());
    injector.setKnownConstants(fnNames);
    trimCanidatesUsingOnCost();
    if (fns.isEmpty()) {
        // Nothing left to do.
        return;
    }
    resolveInlineConflicts();
    decomposeExpressions(fnNames);
    NodeTraversal.traverse(compiler, root, new CallVisitor(fns, anonFns, new Inline(injector, specializationState)));
    removeInlinedFunctions();
}","public void test044() throws Throwable {
    Compiler compiler0 = new Compiler();
    AbstractCompiler.LifeCycleStage abstractCompiler_LifeCycleStage0 = AbstractCompiler.LifeCycleStage.NORMALIZED_OBFUSCATED;
    compiler0.setLifeCycleStage(abstractCompiler_LifeCycleStage0);
    Supplier<String> supplier0 = compiler0.getUniqueNameIdSupplier();
    InlineFunctions inlineFunctions0 = new InlineFunctions(compiler0, supplier0, false, false, false);
    Node node0 = Node.newString(""M"");
    inlineFunctions0.process(node0, node0);
    assertEquals(22, Node.TARGETBLOCK_PROP);
}",""
"@Override
public void process(Node externs, Node root) {
    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());
    NodeTraversal.traverse(compiler, root, new FindCandidateFunctions());
    if (fns.isEmpty()) {
        // Nothing left to do.
        return;
    }
    NodeTraversal.traverse(compiler, root, new FindCandidatesReferences(fns, anonFns));
    trimCanidatesNotMeetingMinimumRequirements();
    if (fns.isEmpty()) {
        // Nothing left to do.
        return;
    }
    // Store the set of function names eligible for inlining and use this to
    // prevent function names from being moved into temporaries during
    // expression decomposition. If this movement were allowed it would prevent
    // the Inline callback from finding the function calls.
    //
    // This pass already assumes these are constants, so this is safe for anyone
    // using function inlining.
    //
    Set<String> fnNames = Sets.newHashSet(fns.keySet());
    injector.setKnownConstants(fnNames);
    trimCanidatesUsingOnCost();
    if (fns.isEmpty()) {
        // Nothing left to do.
        return;
    }
    resolveInlineConflicts();
    decomposeExpressions(fnNames);
    NodeTraversal.traverse(compiler, root, new CallVisitor(fns, anonFns, new Inline(injector, specializationState)));
    removeInlinedFunctions();
}","public void test055() throws Throwable {
    Compiler compiler0 = new Compiler();
    AbstractCompiler.LifeCycleStage abstractCompiler_LifeCycleStage0 = AbstractCompiler.LifeCycleStage.NORMALIZED_OBFUSCATED;
    compiler0.setLifeCycleStage(abstractCompiler_LifeCycleStage0);
    Supplier<String> supplier0 = compiler0.getUniqueNameIdSupplier();
    InlineFunctions inlineFunctions0 = new InlineFunctions(compiler0, supplier0, true, true, true);
    Node node0 = compiler0.parseTestCode(""aB()"");
    // Undeclared exception!
    try {
        inlineFunctions0.process(node0, node0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // null
        //   Node(SCRIPT):  [testcode] :1:0
        // [source unknown]
        //   Parent: NULL
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"static boolean isCandidateUsage(Node name) {
    Node parent = name.getParent();
    Preconditions.checkState(name.getType() == Token.NAME);
    if (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION) {
        // This is a declaration.  Duplicate declarations are handle during
        // function candidate gathering.
        return true;
    }
    if (parent.getType() == Token.CALL && parent.getFirstChild() == name) {
        // This is a normal reference to the function.
        return true;
    }
    // Check for a "".call"" to the named function:
    //   CALL
    //     GETPROP/GETELEM
    //       NAME
    //       STRING == ""call""
    //     This-Value
    //     Function-parameter-1
    //     ...
    if (NodeUtil.isGet(parent) && name == parent.getFirstChild() && name.getNext().getType() == Token.STRING && name.getNext().getString().equals(""call"")) {
        Node gramps = name.getAncestor(2);
        if (gramps.getType() == Token.CALL && gramps.getFirstChild() == parent) {
            // Yep, a "".call"".
            return true;
        }
    }
    return false;
}","public void test066() throws Throwable {
    Node node0 = Node.newNumber(Double.NEGATIVE_INFINITY);
    // Undeclared exception!
    try {
        InlineFunctions.isCandidateUsage(node0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * @return Whether the name is used in a way that might be a candidate
 *   for inlining.
 */"
"static boolean isCandidateUsage(Node name) {
    Node parent = name.getParent();
    Preconditions.checkState(name.getType() == Token.NAME);
    if (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION) {
        // This is a declaration.  Duplicate declarations are handle during
        // function candidate gathering.
        return true;
    }
    if (parent.getType() == Token.CALL && parent.getFirstChild() == name) {
        // This is a normal reference to the function.
        return true;
    }
    // Check for a "".call"" to the named function:
    //   CALL
    //     GETPROP/GETELEM
    //       NAME
    //       STRING == ""call""
    //     This-Value
    //     Function-parameter-1
    //     ...
    if (NodeUtil.isGet(parent) && name == parent.getFirstChild() && name.getNext().getType() == Token.STRING && name.getNext().getString().equals(""call"")) {
        Node gramps = name.getAncestor(2);
        if (gramps.getType() == Token.CALL && gramps.getFirstChild() == parent) {
            // Yep, a "".call"".
            return true;
        }
    }
    return false;
}","public void test077() throws Throwable {
    Node node0 = new Node(38, 38, 38);
    Node node1 = new Node(118, node0, node0, node0);
    boolean boolean0 = InlineFunctions.isCandidateUsage(node0);
    assertTrue(boolean0);
}","/**
 * @return Whether the name is used in a way that might be a candidate
 *   for inlining.
 */"
"static boolean isCandidateUsage(Node name) {
    Node parent = name.getParent();
    Preconditions.checkState(name.getType() == Token.NAME);
    if (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION) {
        // This is a declaration.  Duplicate declarations are handle during
        // function candidate gathering.
        return true;
    }
    if (parent.getType() == Token.CALL && parent.getFirstChild() == name) {
        // This is a normal reference to the function.
        return true;
    }
    // Check for a "".call"" to the named function:
    //   CALL
    //     GETPROP/GETELEM
    //       NAME
    //       STRING == ""call""
    //     This-Value
    //     Function-parameter-1
    //     ...
    if (NodeUtil.isGet(parent) && name == parent.getFirstChild() && name.getNext().getType() == Token.STRING && name.getNext().getString().equals(""call"")) {
        Node gramps = name.getAncestor(2);
        if (gramps.getType() == Token.CALL && gramps.getFirstChild() == parent) {
            // Yep, a "".call"".
            return true;
        }
    }
    return false;
}","public void test088() throws Throwable {
    Node node0 = new Node(38);
    Node node1 = new Node(2, node0, node0, node0);
    boolean boolean0 = InlineFunctions.isCandidateUsage(node0);
    assertFalse(boolean0);
}","/**
 * @return Whether the name is used in a way that might be a candidate
 *   for inlining.
 */"
"static boolean isCandidateUsage(Node name) {
    Node parent = name.getParent();
    Preconditions.checkState(name.getType() == Token.NAME);
    if (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION) {
        // This is a declaration.  Duplicate declarations are handle during
        // function candidate gathering.
        return true;
    }
    if (parent.getType() == Token.CALL && parent.getFirstChild() == name) {
        // This is a normal reference to the function.
        return true;
    }
    // Check for a "".call"" to the named function:
    //   CALL
    //     GETPROP/GETELEM
    //       NAME
    //       STRING == ""call""
    //     This-Value
    //     Function-parameter-1
    //     ...
    if (NodeUtil.isGet(parent) && name == parent.getFirstChild() && name.getNext().getType() == Token.STRING && name.getNext().getString().equals(""call"")) {
        Node gramps = name.getAncestor(2);
        if (gramps.getType() == Token.CALL && gramps.getFirstChild() == parent) {
            // Yep, a "".call"".
            return true;
        }
    }
    return false;
}","public void test099() throws Throwable {
    Node node0 = new Node(38);
    Node node1 = new Node(105, node0, node0, node0);
    boolean boolean0 = InlineFunctions.isCandidateUsage(node0);
    assertTrue(boolean0);
}","/**
 * @return Whether the name is used in a way that might be a candidate
 *   for inlining.
 */"
"static boolean isCandidateUsage(Node name) {
    Node parent = name.getParent();
    Preconditions.checkState(name.getType() == Token.NAME);
    if (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION) {
        // This is a declaration.  Duplicate declarations are handle during
        // function candidate gathering.
        return true;
    }
    if (parent.getType() == Token.CALL && parent.getFirstChild() == name) {
        // This is a normal reference to the function.
        return true;
    }
    // Check for a "".call"" to the named function:
    //   CALL
    //     GETPROP/GETELEM
    //       NAME
    //       STRING == ""call""
    //     This-Value
    //     Function-parameter-1
    //     ...
    if (NodeUtil.isGet(parent) && name == parent.getFirstChild() && name.getNext().getType() == Token.STRING && name.getNext().getString().equals(""call"")) {
        Node gramps = name.getAncestor(2);
        if (gramps.getType() == Token.CALL && gramps.getFirstChild() == parent) {
            // Yep, a "".call"".
            return true;
        }
    }
    return false;
}","public void test1010() throws Throwable {
    Node node0 = new Node(38, 38, 38);
    Node node1 = new Node(37, node0, node0, node0);
    boolean boolean0 = InlineFunctions.isCandidateUsage(node0);
    assertTrue(boolean0);
}","/**
 * @return Whether the name is used in a way that might be a candidate
 *   for inlining.
 */"
"void trimCanidatesUsingOnCost() {
    Iterator<Entry<String, FunctionState>> i;
    for (i = fns.entrySet().iterator(); i.hasNext(); ) {
        FunctionState fs = i.next().getValue();
        if (fs.hasReferences()) {
            // Only inline function if it decreases the code size.
            boolean lowersCost = mimimizeCost(fs);
            if (!lowersCost) {
                // It shouldn't be inlined; remove it from the list.
                i.remove();
            }
        } else if (!fs.canRemove()) {
            // Don't bother tracking functions without references that can't be
            // removed.
            i.remove();
        }
    }
}","public void test1111() throws Throwable {
    Compiler compiler0 = new Compiler();
    Supplier<String> supplier0 = compiler0.getUniqueNameIdSupplier();
    InlineFunctions inlineFunctions0 = new InlineFunctions(compiler0, supplier0, false, false, false);
    inlineFunctions0.trimCanidatesUsingOnCost();
}","/**
 * Remove entries from the list of candidates that can't be inlined.
 */"
"void removeInlinedFunctions() {
    for (FunctionState fs : fns.values()) {
        if (fs.canRemove()) {
            Function fn = fs.getFn();
            Preconditions.checkState(fs.canInline());
            Preconditions.checkState(fn != null);
            verifyAllReferencesInlined(fs);
            if (specializationState != null) {
                specializationState.reportRemovedFunction(fn.getFunctionNode(), fn.getDeclaringBlock());
            }
            fn.remove();
            compiler.reportCodeChange();
        }
    }
}","public void test1212() throws Throwable {
    Compiler compiler0 = new Compiler();
    Supplier<String> supplier0 = compiler0.getUniqueNameIdSupplier();
    InlineFunctions inlineFunctions0 = new InlineFunctions(compiler0, supplier0, false, false, false);
    inlineFunctions0.removeInlinedFunctions();
}","/**
 * Removed inlined functions that no longer have any references.
 */"
