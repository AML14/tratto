focal_method,test_prefix,docstring
"String getHtmlReport() {
    StringBuilder sb = new StringBuilder();
    sb.append(""<html><body><style type=\""text/css\"">"" + ""body, td, p {font-family: Arial; font-size: 83%} "" + ""ul {margin-top:2px; margin-left:0px; padding-left:1em;} "" + ""li {margin-top:3px; margin-left:24px; padding-left:0px;"" + ""padding-bottom: 4px}</style>"");
    sb.append(""OVERALL STATS<ul>"");
    appendListItem(sb, ""Total Names: "" + countOf(TriState.BOTH, TriState.BOTH));
    appendListItem(sb, ""Total Classes: "" + countOf(TriState.TRUE, TriState.BOTH));
    appendListItem(sb, ""Total Static Functions: "" + countOf(TriState.FALSE, TriState.BOTH));
    appendListItem(sb, ""Referenced Names: "" + countOf(TriState.BOTH, TriState.TRUE));
    appendListItem(sb, ""Referenced Classes: "" + countOf(TriState.TRUE, TriState.TRUE));
    appendListItem(sb, ""Referenced Functions: "" + countOf(TriState.FALSE, TriState.TRUE));
    sb.append(""</ul>"");
    sb.append(""ALL NAMES<ul>\n"");
    for (JsName node : allNames.values()) {
        sb.append(""<li>"" + nameAnchor(node.name) + ""<ul>"");
        if (node.prototypeNames.size() > 0) {
            sb.append(""<li>PROTOTYPES: "");
            Iterator<String> protoIter = node.prototypeNames.iterator();
            while (protoIter.hasNext()) {
                sb.append(protoIter.next());
                if (protoIter.hasNext()) {
                    sb.append("", "");
                }
            }
        }
        if (referenceGraph.hasNode(node)) {
            List<DiGraphEdge<JsName, RefType>> refersTo = referenceGraph.getOutEdges(node);
            if (refersTo.size() > 0) {
                sb.append(""<li>REFERS TO: "");
                Iterator<DiGraphEdge<JsName, RefType>> toIter = refersTo.iterator();
                while (toIter.hasNext()) {
                    sb.append(nameLink(toIter.next().getDestination().getValue().name));
                    if (toIter.hasNext()) {
                        sb.append("", "");
                    }
                }
            }
            List<DiGraphEdge<JsName, RefType>> referencedBy = referenceGraph.getInEdges(node);
            if (referencedBy.size() > 0) {
                sb.append(""<li>REFERENCED BY: "");
                Iterator<DiGraphEdge<JsName, RefType>> fromIter = refersTo.iterator();
                while (fromIter.hasNext()) {
                    sb.append(nameLink(fromIter.next().getDestination().getValue().name));
                    if (fromIter.hasNext()) {
                        sb.append("", "");
                    }
                }
            }
        }
        sb.append(""</li>"");
        sb.append(""</ul></li>"");
    }
    sb.append(""</ul>"");
    sb.append(""</body></html>"");
    return sb.toString();
}","public void test000() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    Node node0 = compiler0.parseSyntheticCode(""REGULAR"", ""REGULAR"");
    nameAnalyzer0.process(node0, node0);
    String string0 = nameAnalyzer0.getHtmlReport();
    assertEquals(""<html><body><style type=\""text/css\"">body, td, p {font-family: Arial; font-size: 83%} ul {margin-top:2px; margin-left:0px; padding-left:1em;} li {margin-top:3px; margin-left:24px; padding-left:0px;padding-bottom: 4px}</style>OVERALL STATS<ul><li>Total Names: 2</li>\n<li>Total Classes: 0</li>\n<li>Total Static Functions: 2</li>\n<li>Referenced Names: 2</li>\n<li>Referenced Classes: 0</li>\n<li>Referenced Functions: 2</li>\n</ul>ALL NAMES<ul>\n<li><a name=\""Function\"">Function</a><ul></li></ul></li><li><a name=\""window\"">window</a><ul></li></ul></li></ul></body></html>"", string0);
}","/**
 * Generates an HTML report
 *
 * @return The report
 */"
"String getHtmlReport() {
    StringBuilder sb = new StringBuilder();
    sb.append(""<html><body><style type=\""text/css\"">"" + ""body, td, p {font-family: Arial; font-size: 83%} "" + ""ul {margin-top:2px; margin-left:0px; padding-left:1em;} "" + ""li {margin-top:3px; margin-left:24px; padding-left:0px;"" + ""padding-bottom: 4px}</style>"");
    sb.append(""OVERALL STATS<ul>"");
    appendListItem(sb, ""Total Names: "" + countOf(TriState.BOTH, TriState.BOTH));
    appendListItem(sb, ""Total Classes: "" + countOf(TriState.TRUE, TriState.BOTH));
    appendListItem(sb, ""Total Static Functions: "" + countOf(TriState.FALSE, TriState.BOTH));
    appendListItem(sb, ""Referenced Names: "" + countOf(TriState.BOTH, TriState.TRUE));
    appendListItem(sb, ""Referenced Classes: "" + countOf(TriState.TRUE, TriState.TRUE));
    appendListItem(sb, ""Referenced Functions: "" + countOf(TriState.FALSE, TriState.TRUE));
    sb.append(""</ul>"");
    sb.append(""ALL NAMES<ul>\n"");
    for (JsName node : allNames.values()) {
        sb.append(""<li>"" + nameAnchor(node.name) + ""<ul>"");
        if (node.prototypeNames.size() > 0) {
            sb.append(""<li>PROTOTYPES: "");
            Iterator<String> protoIter = node.prototypeNames.iterator();
            while (protoIter.hasNext()) {
                sb.append(protoIter.next());
                if (protoIter.hasNext()) {
                    sb.append("", "");
                }
            }
        }
        if (referenceGraph.hasNode(node)) {
            List<DiGraphEdge<JsName, RefType>> refersTo = referenceGraph.getOutEdges(node);
            if (refersTo.size() > 0) {
                sb.append(""<li>REFERS TO: "");
                Iterator<DiGraphEdge<JsName, RefType>> toIter = refersTo.iterator();
                while (toIter.hasNext()) {
                    sb.append(nameLink(toIter.next().getDestination().getValue().name));
                    if (toIter.hasNext()) {
                        sb.append("", "");
                    }
                }
            }
            List<DiGraphEdge<JsName, RefType>> referencedBy = referenceGraph.getInEdges(node);
            if (referencedBy.size() > 0) {
                sb.append(""<li>REFERENCED BY: "");
                Iterator<DiGraphEdge<JsName, RefType>> fromIter = refersTo.iterator();
                while (fromIter.hasNext()) {
                    sb.append(nameLink(fromIter.next().getDestination().getValue().name));
                    if (fromIter.hasNext()) {
                        sb.append("", "");
                    }
                }
            }
        }
        sb.append(""</li>"");
        sb.append(""</ul></li>"");
    }
    sb.append(""</ul>"");
    sb.append(""</body></html>"");
    return sb.toString();
}","public void test011() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    String string0 = nameAnalyzer0.getHtmlReport();
    assertEquals(""<html><body><style type=\""text/css\"">body, td, p {font-family: Arial; font-size: 83%} ul {margin-top:2px; margin-left:0px; padding-left:1em;} li {margin-top:3px; margin-left:24px; padding-left:0px;padding-bottom: 4px}</style>OVERALL STATS<ul><li>Total Names: 0</li>\n<li>Total Classes: 0</li>\n<li>Total Static Functions: 0</li>\n<li>Referenced Names: 0</li>\n<li>Referenced Classes: 0</li>\n<li>Referenced Functions: 0</li>\n</ul>ALL NAMES<ul>\n</ul></body></html>"", string0);
}","/**
 * Generates an HTML report
 *
 * @return The report
 */"
"public int getChildCount() {
    int c = 0;
    for (Node n = first; n != null; n = n.next) {
        c++;
    }
    return c;
}","public void test022() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    Node node0 = compiler0.parseSyntheticCode(""RcU=b"", ""RcU=b"");
    nameAnalyzer0.process(node0, node0);
    assertEquals(1, node0.getChildCount());
}",""
"public boolean hasChildren() {
    return first != null;
}","public void test023() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    Node node0 = compiler0.parseSyntheticCode(""RcU=b"", ""RcU=b"");
    nameAnalyzer0.process(node0, node0);
    assertTrue(node0.hasChildren());
}",""
"public boolean isAdd() {
    return this.getType() == Token.ADD;
}","public void test034() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, false);
    Node node0 = compiler0.parseSyntheticCode(""RG5ULAR"", ""RG5ULAR"");
    Node node1 = new Node(37, node0, node0, node0, 15, 36);
    nameAnalyzer0.process(node1, node1);
    assertFalse(node1.isAdd());
}","/**
 * AST type check methods **
 */"
"@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExternals());
    NodeTraversal.traverse(compiler, root, new FindDependencyScopes());
    NodeTraversal.traverse(compiler, root, new HoistVariableAndFunctionDeclarations());
    NodeTraversal.traverse(compiler, root, new FindDeclarationsAndSetters());
    NodeTraversal.traverse(compiler, root, new FindReferences());
    // Create bi-directional references between parent names and their
    // descendants. This may create new names.
    referenceParentNames();
    // If we modify the property of an alias, make sure that modification
    // gets reflected in the original object.
    referenceAliases();
    calculateReferences();
    if (removeUnreferenced) {
        removeUnreferenced();
    }
}","public void test045() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    Node node0 = compiler0.parseSyntheticCode(""om"", ""om"");
    Node node1 = new Node(4, node0, node0, node0, (-4096), 2);
    nameAnalyzer0.process(node1, node1);
    assertEquals(39, Node.EMPTY_BLOCK);
}",""
"@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExternals());
    NodeTraversal.traverse(compiler, root, new FindDependencyScopes());
    NodeTraversal.traverse(compiler, root, new HoistVariableAndFunctionDeclarations());
    NodeTraversal.traverse(compiler, root, new FindDeclarationsAndSetters());
    NodeTraversal.traverse(compiler, root, new FindReferences());
    // Create bi-directional references between parent names and their
    // descendants. This may create new names.
    referenceParentNames();
    // If we modify the property of an alias, make sure that modification
    // gets reflected in the original object.
    referenceAliases();
    calculateReferences();
    if (removeUnreferenced) {
        removeUnreferenced();
    }
}","public void test056() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    Node node0 = compiler0.parseSyntheticCode(""REGULAR"", ""REGULAR"");
    Node node1 = new Node(118, node0, node0, node0, 43, 54);
    // Undeclared exception!
    try {
        nameAnalyzer0.process(node0, node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.Compiler"", e);
    }
}",""
"public boolean isDelProp() {
    return this.getType() == Token.DELPROP;
}","public void test067() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, false);
    Node node0 = Node.newString(""BEFORE_OPTIMIZATION_LOOP"");
    Node node1 = new Node(118, node0, node0, node0, 15, 36);
    nameAnalyzer0.process(node1, node1);
    assertFalse(node1.isDelProp());
}",""
"@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExternals());
    NodeTraversal.traverse(compiler, root, new FindDependencyScopes());
    NodeTraversal.traverse(compiler, root, new HoistVariableAndFunctionDeclarations());
    NodeTraversal.traverse(compiler, root, new FindDeclarationsAndSetters());
    NodeTraversal.traverse(compiler, root, new FindReferences());
    // Create bi-directional references between parent names and their
    // descendants. This may create new names.
    referenceParentNames();
    // If we modify the property of an alias, make sure that modification
    // gets reflected in the original object.
    referenceAliases();
    calculateReferences();
    if (removeUnreferenced) {
        removeUnreferenced();
    }
}","public void test078() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, false);
    Node node0 = Node.newString(""RG5ULAR"");
    Node node1 = new Node(108, node0, node0, node0, 15, 36);
    nameAnalyzer0.process(node1, node1);
    assertEquals(48, Node.DIRECTIVES);
}",""
"public boolean hasOneChild() {
    return first != null && first == last;
}","public void test089() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    Node node0 = compiler0.parseSyntheticCode(""Em"", ""Em"");
    Node node1 = new Node(113, node0, node0, node0, 47, (-1892));
    nameAnalyzer0.process(node0, node1);
    assertTrue(node0.hasOneChild());
}","/**
 * Check for one child more efficiently than by iterating over all the
 * children as is done with Node.getChildCount().
 *
 * @return Whether the node has exactly one child.
 */"
"@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExternals());
    NodeTraversal.traverse(compiler, root, new FindDependencyScopes());
    NodeTraversal.traverse(compiler, root, new HoistVariableAndFunctionDeclarations());
    NodeTraversal.traverse(compiler, root, new FindDeclarationsAndSetters());
    NodeTraversal.traverse(compiler, root, new FindReferences());
    // Create bi-directional references between parent names and their
    // descendants. This may create new names.
    referenceParentNames();
    // If we modify the property of an alias, make sure that modification
    // gets reflected in the original object.
    referenceAliases();
    calculateReferences();
    if (removeUnreferenced) {
        removeUnreferenced();
    }
}","public void test0910() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, false);
    Node node0 = compiler0.parseSyntheticCode(""RG5ULAR"", ""RG5ULAR"");
    Node node1 = new Node(110, node0, node0, node0, 15, 36);
    nameAnalyzer0.process(node1, node1);
    assertEquals(0, Node.SIDE_EFFECTS_ALL);
}",""
"public boolean isInstanceOf() {
    return this.getType() == Token.INSTANCEOF;
}","public void test1011() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    Node node0 = compiler0.parseSyntheticCode(""com.google.javascript.jscomp.NameAnalyzer"", ""com.google.javascript.jscomp.NameAnalyzer"");
    nameAnalyzer0.process(node0, node0);
    assertFalse(node0.isInstanceOf());
}",""
"public boolean isTry() {
    return this.getType() == Token.TRY;
}","public void test1112() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, false);
    Node node0 = compiler0.parseSyntheticCode(""window"", ""window"");
    nameAnalyzer0.process(node0, node0);
    assertFalse(node0.isTry());
}",""
"@Override
public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExternals());
    NodeTraversal.traverse(compiler, root, new FindDependencyScopes());
    NodeTraversal.traverse(compiler, root, new HoistVariableAndFunctionDeclarations());
    NodeTraversal.traverse(compiler, root, new FindDeclarationsAndSetters());
    NodeTraversal.traverse(compiler, root, new FindReferences());
    // Create bi-directional references between parent names and their
    // descendants. This may create new names.
    referenceParentNames();
    // If we modify the property of an alias, make sure that modification
    // gets reflected in the original object.
    referenceAliases();
    calculateReferences();
    if (removeUnreferenced) {
        removeUnreferenced();
    }
}","public void test1213() throws Throwable {
    Compiler compiler0 = new Compiler();
    NameAnalyzer nameAnalyzer0 = new NameAnalyzer(compiler0, true);
    Node node0 = compiler0.parseSyntheticCode(""REGULAR"", ""REGULAR"");
    nameAnalyzer0.process(node0, node0);
    nameAnalyzer0.process(node0, node0);
    assertEquals(36, Node.QUOTED_PROP);
}",""
