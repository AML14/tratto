focal_method,test_prefix,docstring
"public final int getParamCount() {
    return varStart;
}","public void test000() throws Throwable {
    Compiler compiler0 = new Compiler();
    AmbiguateProperties ambiguateProperties0 = new AmbiguateProperties(compiler0, (char[]) null);
    ScriptOrFnNode scriptOrFnNode0 = (ScriptOrFnNode) compiler0.parseTestCode(""com.google.javascript.jscomp.AmbiguateProperties$PropertyGraph"");
    ambiguateProperties0.process(scriptOrFnNode0, scriptOrFnNode0);
    assertEquals(0, scriptOrFnNode0.getParamCount());
}",""
"public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExterns());
    NodeTraversal.traverse(compiler, root, new ProcessProperties());
    Set<String> reservedNames = new HashSet<String>(externedNames.size() + quotedNames.size());
    reservedNames.addAll(externedNames);
    reservedNames.addAll(quotedNames);
    int numRenamedPropertyNames = 0;
    int numSkippedPropertyNames = 0;
    Set<Property> propsByFreq = new TreeSet<Property>(FREQUENCY_COMPARATOR);
    for (Property p : propertyMap.values()) {
        if (!p.skipAmbiguating) {
            ++numRenamedPropertyNames;
            computeRelatedTypes(p.type);
            propsByFreq.add(p);
        } else {
            ++numSkippedPropertyNames;
            reservedNames.add(p.oldName);
        }
    }
    PropertyGraph graph = new PropertyGraph(Lists.newLinkedList(propsByFreq));
    GraphColoring<Property, Void> coloring = new GreedyGraphColoring<Property, Void>(graph, FREQUENCY_COMPARATOR);
    int numNewPropertyNames = coloring.color();
    NameGenerator nameGen = new NameGenerator(reservedNames, """", reservedCharacters);
    for (int i = 0; i < numNewPropertyNames; ++i) {
        colorMap.put(i, nameGen.generateNextName());
    }
    for (GraphNode<Property, Void> node : graph.getNodes()) {
        node.getValue().newName = colorMap.get(node.getAnnotation().hashCode());
        renamingMap.put(node.getValue().oldName, node.getValue().newName);
    }
    // Update the string nodes.
    for (Node n : stringNodesToRename) {
        String oldName = n.getString();
        Property p = propertyMap.get(oldName);
        if (p != null && p.newName != null) {
            Preconditions.checkState(oldName.equals(p.oldName));
            if (!p.newName.equals(oldName)) {
                n.setString(p.newName);
                compiler.reportCodeChange();
            }
        }
    }
    logger.info(""Collapsed "" + numRenamedPropertyNames + "" properties into "" + numNewPropertyNames + "" and skipped renaming "" + numSkippedPropertyNames + "" properties."");
}","public void test022() throws Throwable {
    Compiler compiler0 = new Compiler();
    AmbiguateProperties ambiguateProperties0 = new AmbiguateProperties(compiler0, (char[]) null);
    Node node0 = compiler0.parseTestCode(""com.google.javascript.jscomp.AmbiguateProperties$PropertyGraph"");
    Node node1 = new Node(7);
    ambiguateProperties0.process(node1, node0);
    ambiguateProperties0.process(node1, node0);
    assertEquals(31, Node.INCRDECR_PROP);
}",""
"public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExterns());
    NodeTraversal.traverse(compiler, root, new ProcessProperties());
    Set<String> reservedNames = new HashSet<String>(externedNames.size() + quotedNames.size());
    reservedNames.addAll(externedNames);
    reservedNames.addAll(quotedNames);
    int numRenamedPropertyNames = 0;
    int numSkippedPropertyNames = 0;
    Set<Property> propsByFreq = new TreeSet<Property>(FREQUENCY_COMPARATOR);
    for (Property p : propertyMap.values()) {
        if (!p.skipAmbiguating) {
            ++numRenamedPropertyNames;
            computeRelatedTypes(p.type);
            propsByFreq.add(p);
        } else {
            ++numSkippedPropertyNames;
            reservedNames.add(p.oldName);
        }
    }
    PropertyGraph graph = new PropertyGraph(Lists.newLinkedList(propsByFreq));
    GraphColoring<Property, Void> coloring = new GreedyGraphColoring<Property, Void>(graph, FREQUENCY_COMPARATOR);
    int numNewPropertyNames = coloring.color();
    NameGenerator nameGen = new NameGenerator(reservedNames, """", reservedCharacters);
    for (int i = 0; i < numNewPropertyNames; ++i) {
        colorMap.put(i, nameGen.generateNextName());
    }
    for (GraphNode<Property, Void> node : graph.getNodes()) {
        node.getValue().newName = colorMap.get(node.getAnnotation().hashCode());
        renamingMap.put(node.getValue().oldName, node.getValue().newName);
    }
    // Update the string nodes.
    for (Node n : stringNodesToRename) {
        String oldName = n.getString();
        Property p = propertyMap.get(oldName);
        if (p != null && p.newName != null) {
            Preconditions.checkState(oldName.equals(p.oldName));
            if (!p.newName.equals(oldName)) {
                n.setString(p.newName);
                compiler.reportCodeChange();
            }
        }
    }
    logger.info(""Collapsed "" + numRenamedPropertyNames + "" properties into "" + numNewPropertyNames + "" and skipped renaming "" + numSkippedPropertyNames + "" properties."");
}","public void test033() throws Throwable {
    Compiler compiler0 = new Compiler();
    AmbiguateProperties ambiguateProperties0 = new AmbiguateProperties(compiler0, (char[]) null);
    Node node0 = Node.newString(""msg.dstut.sign.no.init"", 64, 64);
    Node node1 = new Node(64, node0);
    // Undeclared exception!
    try {
        ambiguateProperties0.process(node1, node1);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public boolean isUnscopedQualifiedName() {
    switch(getType()) {
        case Token.NAME:
            return true;
        case Token.GETPROP:
            return getFirstChild().isUnscopedQualifiedName();
        default:
            return false;
    }
}","public void test044() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(64, 64, 64);
    AmbiguateProperties ambiguateProperties0 = new AmbiguateProperties(compiler0, (char[]) null);
    ambiguateProperties0.process(node0, node0);
    assertFalse(node0.isUnscopedQualifiedName());
}","/**
 * Returns whether a node corresponds to a simple or a qualified name
 * without a ""this"" reference, such as <code>a.b.c</code>, but not
 * <code>this.a</code>.
 */"
"public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExterns());
    NodeTraversal.traverse(compiler, root, new ProcessProperties());
    Set<String> reservedNames = new HashSet<String>(externedNames.size() + quotedNames.size());
    reservedNames.addAll(externedNames);
    reservedNames.addAll(quotedNames);
    int numRenamedPropertyNames = 0;
    int numSkippedPropertyNames = 0;
    Set<Property> propsByFreq = new TreeSet<Property>(FREQUENCY_COMPARATOR);
    for (Property p : propertyMap.values()) {
        if (!p.skipAmbiguating) {
            ++numRenamedPropertyNames;
            computeRelatedTypes(p.type);
            propsByFreq.add(p);
        } else {
            ++numSkippedPropertyNames;
            reservedNames.add(p.oldName);
        }
    }
    PropertyGraph graph = new PropertyGraph(Lists.newLinkedList(propsByFreq));
    GraphColoring<Property, Void> coloring = new GreedyGraphColoring<Property, Void>(graph, FREQUENCY_COMPARATOR);
    int numNewPropertyNames = coloring.color();
    NameGenerator nameGen = new NameGenerator(reservedNames, """", reservedCharacters);
    for (int i = 0; i < numNewPropertyNames; ++i) {
        colorMap.put(i, nameGen.generateNextName());
    }
    for (GraphNode<Property, Void> node : graph.getNodes()) {
        node.getValue().newName = colorMap.get(node.getAnnotation().hashCode());
        renamingMap.put(node.getValue().oldName, node.getValue().newName);
    }
    // Update the string nodes.
    for (Node n : stringNodesToRename) {
        String oldName = n.getString();
        Property p = propertyMap.get(oldName);
        if (p != null && p.newName != null) {
            Preconditions.checkState(oldName.equals(p.oldName));
            if (!p.newName.equals(oldName)) {
                n.setString(p.newName);
                compiler.reportCodeChange();
            }
        }
    }
    logger.info(""Collapsed "" + numRenamedPropertyNames + "" properties into "" + numNewPropertyNames + "" and skipped renaming "" + numSkippedPropertyNames + "" properties."");
}","public void test055() throws Throwable {
    Compiler compiler0 = new Compiler();
    AmbiguateProperties ambiguateProperties0 = new AmbiguateProperties(compiler0, (char[]) null);
    Node node0 = compiler0.parseTestCode(""msg.destuct.assign.no.init"");
    Node node1 = new Node(64, node0);
    // Undeclared exception!
    try {
        ambiguateProperties0.process(node1, node1);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExterns());
    NodeTraversal.traverse(compiler, root, new ProcessProperties());
    Set<String> reservedNames = new HashSet<String>(externedNames.size() + quotedNames.size());
    reservedNames.addAll(externedNames);
    reservedNames.addAll(quotedNames);
    int numRenamedPropertyNames = 0;
    int numSkippedPropertyNames = 0;
    Set<Property> propsByFreq = new TreeSet<Property>(FREQUENCY_COMPARATOR);
    for (Property p : propertyMap.values()) {
        if (!p.skipAmbiguating) {
            ++numRenamedPropertyNames;
            computeRelatedTypes(p.type);
            propsByFreq.add(p);
        } else {
            ++numSkippedPropertyNames;
            reservedNames.add(p.oldName);
        }
    }
    PropertyGraph graph = new PropertyGraph(Lists.newLinkedList(propsByFreq));
    GraphColoring<Property, Void> coloring = new GreedyGraphColoring<Property, Void>(graph, FREQUENCY_COMPARATOR);
    int numNewPropertyNames = coloring.color();
    NameGenerator nameGen = new NameGenerator(reservedNames, """", reservedCharacters);
    for (int i = 0; i < numNewPropertyNames; ++i) {
        colorMap.put(i, nameGen.generateNextName());
    }
    for (GraphNode<Property, Void> node : graph.getNodes()) {
        node.getValue().newName = colorMap.get(node.getAnnotation().hashCode());
        renamingMap.put(node.getValue().oldName, node.getValue().newName);
    }
    // Update the string nodes.
    for (Node n : stringNodesToRename) {
        String oldName = n.getString();
        Property p = propertyMap.get(oldName);
        if (p != null && p.newName != null) {
            Preconditions.checkState(oldName.equals(p.oldName));
            if (!p.newName.equals(oldName)) {
                n.setString(p.newName);
                compiler.reportCodeChange();
            }
        }
    }
    logger.info(""Collapsed "" + numRenamedPropertyNames + "" properties into "" + numNewPropertyNames + "" and skipped renaming "" + numSkippedPropertyNames + "" properties."");
}","public void test066() throws Throwable {
    Compiler compiler0 = new Compiler();
    AmbiguateProperties ambiguateProperties0 = new AmbiguateProperties(compiler0, (char[]) null);
    Node node0 = Node.newNumber((double) 35, 35, 35);
    Node node1 = new Node(35, node0, node0, node0, node0, 22, 20);
    ambiguateProperties0.process(node1, node1);
    assertEquals(37, Node.SYNTHETIC_BLOCK_PROP);
}",""
"public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExterns());
    NodeTraversal.traverse(compiler, root, new ProcessProperties());
    Set<String> reservedNames = new HashSet<String>(externedNames.size() + quotedNames.size());
    reservedNames.addAll(externedNames);
    reservedNames.addAll(quotedNames);
    int numRenamedPropertyNames = 0;
    int numSkippedPropertyNames = 0;
    Set<Property> propsByFreq = new TreeSet<Property>(FREQUENCY_COMPARATOR);
    for (Property p : propertyMap.values()) {
        if (!p.skipAmbiguating) {
            ++numRenamedPropertyNames;
            computeRelatedTypes(p.type);
            propsByFreq.add(p);
        } else {
            ++numSkippedPropertyNames;
            reservedNames.add(p.oldName);
        }
    }
    PropertyGraph graph = new PropertyGraph(Lists.newLinkedList(propsByFreq));
    GraphColoring<Property, Void> coloring = new GreedyGraphColoring<Property, Void>(graph, FREQUENCY_COMPARATOR);
    int numNewPropertyNames = coloring.color();
    NameGenerator nameGen = new NameGenerator(reservedNames, """", reservedCharacters);
    for (int i = 0; i < numNewPropertyNames; ++i) {
        colorMap.put(i, nameGen.generateNextName());
    }
    for (GraphNode<Property, Void> node : graph.getNodes()) {
        node.getValue().newName = colorMap.get(node.getAnnotation().hashCode());
        renamingMap.put(node.getValue().oldName, node.getValue().newName);
    }
    // Update the string nodes.
    for (Node n : stringNodesToRename) {
        String oldName = n.getString();
        Property p = propertyMap.get(oldName);
        if (p != null && p.newName != null) {
            Preconditions.checkState(oldName.equals(p.oldName));
            if (!p.newName.equals(oldName)) {
                n.setString(p.newName);
                compiler.reportCodeChange();
            }
        }
    }
    logger.info(""Collapsed "" + numRenamedPropertyNames + "" properties into "" + numNewPropertyNames + "" and skipped renaming "" + numSkippedPropertyNames + "" properties."");
}","public void test077() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString(""JSAbstractCompilerAbiguateProerties$JSTypeBitSet"");
    Node node1 = new Node(64, 11, 48);
    node1.addChildrenToBack(node0);
    AmbiguateProperties ambiguateProperties0 = new AmbiguateProperties(compiler0, (char[]) null);
    // Undeclared exception!
    try {
        ambiguateProperties0.process(node0, node1);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExterns());
    NodeTraversal.traverse(compiler, root, new ProcessProperties());
    Set<String> reservedNames = new HashSet<String>(externedNames.size() + quotedNames.size());
    reservedNames.addAll(externedNames);
    reservedNames.addAll(quotedNames);
    int numRenamedPropertyNames = 0;
    int numSkippedPropertyNames = 0;
    Set<Property> propsByFreq = new TreeSet<Property>(FREQUENCY_COMPARATOR);
    for (Property p : propertyMap.values()) {
        if (!p.skipAmbiguating) {
            ++numRenamedPropertyNames;
            computeRelatedTypes(p.type);
            propsByFreq.add(p);
        } else {
            ++numSkippedPropertyNames;
            reservedNames.add(p.oldName);
        }
    }
    PropertyGraph graph = new PropertyGraph(Lists.newLinkedList(propsByFreq));
    GraphColoring<Property, Void> coloring = new GreedyGraphColoring<Property, Void>(graph, FREQUENCY_COMPARATOR);
    int numNewPropertyNames = coloring.color();
    NameGenerator nameGen = new NameGenerator(reservedNames, """", reservedCharacters);
    for (int i = 0; i < numNewPropertyNames; ++i) {
        colorMap.put(i, nameGen.generateNextName());
    }
    for (GraphNode<Property, Void> node : graph.getNodes()) {
        node.getValue().newName = colorMap.get(node.getAnnotation().hashCode());
        renamingMap.put(node.getValue().oldName, node.getValue().newName);
    }
    // Update the string nodes.
    for (Node n : stringNodesToRename) {
        String oldName = n.getString();
        Property p = propertyMap.get(oldName);
        if (p != null && p.newName != null) {
            Preconditions.checkState(oldName.equals(p.oldName));
            if (!p.newName.equals(oldName)) {
                n.setString(p.newName);
                compiler.reportCodeChange();
            }
        }
    }
    logger.info(""Collapsed "" + numRenamedPropertyNames + "" properties into "" + numNewPropertyNames + "" and skipped renaming "" + numSkippedPropertyNames + "" properties."");
}","public void test088() throws Throwable {
    Compiler compiler0 = new Compiler();
    AmbiguateProperties ambiguateProperties0 = new AmbiguateProperties(compiler0, (char[]) null);
    Node node0 = Node.newNumber((double) 64, 64, 64);
    Node node1 = new Node(64, node0, node0, node0, node0, 47, 2);
    // Undeclared exception!
    try {
        ambiguateProperties0.process(node0, node1);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExterns());
    NodeTraversal.traverse(compiler, root, new ProcessProperties());
    Set<String> reservedNames = new HashSet<String>(externedNames.size() + quotedNames.size());
    reservedNames.addAll(externedNames);
    reservedNames.addAll(quotedNames);
    int numRenamedPropertyNames = 0;
    int numSkippedPropertyNames = 0;
    Set<Property> propsByFreq = new TreeSet<Property>(FREQUENCY_COMPARATOR);
    for (Property p : propertyMap.values()) {
        if (!p.skipAmbiguating) {
            ++numRenamedPropertyNames;
            computeRelatedTypes(p.type);
            propsByFreq.add(p);
        } else {
            ++numSkippedPropertyNames;
            reservedNames.add(p.oldName);
        }
    }
    PropertyGraph graph = new PropertyGraph(Lists.newLinkedList(propsByFreq));
    GraphColoring<Property, Void> coloring = new GreedyGraphColoring<Property, Void>(graph, FREQUENCY_COMPARATOR);
    int numNewPropertyNames = coloring.color();
    NameGenerator nameGen = new NameGenerator(reservedNames, """", reservedCharacters);
    for (int i = 0; i < numNewPropertyNames; ++i) {
        colorMap.put(i, nameGen.generateNextName());
    }
    for (GraphNode<Property, Void> node : graph.getNodes()) {
        node.getValue().newName = colorMap.get(node.getAnnotation().hashCode());
        renamingMap.put(node.getValue().oldName, node.getValue().newName);
    }
    // Update the string nodes.
    for (Node n : stringNodesToRename) {
        String oldName = n.getString();
        Property p = propertyMap.get(oldName);
        if (p != null && p.newName != null) {
            Preconditions.checkState(oldName.equals(p.oldName));
            if (!p.newName.equals(oldName)) {
                n.setString(p.newName);
                compiler.reportCodeChange();
            }
        }
    }
    logger.info(""Collapsed "" + numRenamedPropertyNames + "" properties into "" + numNewPropertyNames + "" and skipped renaming "" + numSkippedPropertyNames + "" properties."");
}","public void test099() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newString("">{wrj, Rp18J4%)^q"");
    Node node1 = new Node(64, 11, 48);
    node0.setQuotedString();
    node1.addChildrenToBack(node0);
    AmbiguateProperties ambiguateProperties0 = new AmbiguateProperties(compiler0, (char[]) null);
    // Undeclared exception!
    try {
        ambiguateProperties0.process(node0, node1);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExterns());
    NodeTraversal.traverse(compiler, root, new ProcessProperties());
    Set<String> reservedNames = new HashSet<String>(externedNames.size() + quotedNames.size());
    reservedNames.addAll(externedNames);
    reservedNames.addAll(quotedNames);
    int numRenamedPropertyNames = 0;
    int numSkippedPropertyNames = 0;
    Set<Property> propsByFreq = new TreeSet<Property>(FREQUENCY_COMPARATOR);
    for (Property p : propertyMap.values()) {
        if (!p.skipAmbiguating) {
            ++numRenamedPropertyNames;
            computeRelatedTypes(p.type);
            propsByFreq.add(p);
        } else {
            ++numSkippedPropertyNames;
            reservedNames.add(p.oldName);
        }
    }
    PropertyGraph graph = new PropertyGraph(Lists.newLinkedList(propsByFreq));
    GraphColoring<Property, Void> coloring = new GreedyGraphColoring<Property, Void>(graph, FREQUENCY_COMPARATOR);
    int numNewPropertyNames = coloring.color();
    NameGenerator nameGen = new NameGenerator(reservedNames, """", reservedCharacters);
    for (int i = 0; i < numNewPropertyNames; ++i) {
        colorMap.put(i, nameGen.generateNextName());
    }
    for (GraphNode<Property, Void> node : graph.getNodes()) {
        node.getValue().newName = colorMap.get(node.getAnnotation().hashCode());
        renamingMap.put(node.getValue().oldName, node.getValue().newName);
    }
    // Update the string nodes.
    for (Node n : stringNodesToRename) {
        String oldName = n.getString();
        Property p = propertyMap.get(oldName);
        if (p != null && p.newName != null) {
            Preconditions.checkState(oldName.equals(p.oldName));
            if (!p.newName.equals(oldName)) {
                n.setString(p.newName);
                compiler.reportCodeChange();
            }
        }
    }
    logger.info(""Collapsed "" + numRenamedPropertyNames + "" properties into "" + numNewPropertyNames + "" and skipped renaming "" + numSkippedPropertyNames + "" properties."");
}","public void test1010() throws Throwable {
    Compiler compiler0 = new Compiler();
    AmbiguateProperties ambiguateProperties0 = new AmbiguateProperties(compiler0, (char[]) null);
    Node node0 = Node.newNumber((double) 35, 35, 35);
    Node node1 = Node.newString(""AmbiguateProperties1"", (-535), 0);
    Node node2 = new Node(35, node0, node0, node0, node1, 22, 20);
    ambiguateProperties0.process(node2, node2);
    assertEquals(20, Node.FINALLY_PROP);
}",""
