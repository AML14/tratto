focal_method,test_prefix,docstring
"public String getDisplayName() {
    return null;
}","public void test000() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNumberType();
    JSType jSType1 = semanticReverseAbstractInterpreter0.getRestrictedWithoutNull(jSType0);
    assertEquals(""number"", jSType1.getDisplayName());
}","/**
 * Returns a user meaningful label for the JSType instance.  For example,
 * Functions and Enums will return their declaration name (if they have one).
 * Some types will not have a meaningful display name.  Calls to
 * hasDisplayName() will return true IFF getDisplayName() will return null
 * or a zero length string.
 *
 * @return the display name of the type, or null if one is not available
 */"
"public final boolean isFunctionType() {
    return toMaybeFunctionType() != null;
}","public void test011() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseUnknownType();
    JSType jSType1 = semanticReverseAbstractInterpreter0.getRestrictedWithoutNull(jSType0);
    assertFalse(jSType1.isFunctionType());
}","/**
 * Returns true if toMaybeFunctionType returns a non-null FunctionType.
 */"
"public boolean isBooleanValueType() {
    return false;
}","public void test022() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NO_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    JSType jSType1 = semanticReverseAbstractInterpreter0.getRestrictedWithoutNull(jSType0);
    assertFalse(jSType1.isBooleanValueType());
}",""
"protected final JSType getRestrictedWithoutNull(JSType type) {
    return type == null ? null : type.visit(restrictNullVisitor);
}","public void test033() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNullType();
    JSType jSType1 = semanticReverseAbstractInterpreter0.getRestrictedWithoutNull(jSType0);
    assertNull(jSType1);
}","/**
 * Returns a version of type where null is not present.
 */"
"public boolean isEnumType() {
    return toMaybeEnumType() != null;
}","public void test044() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNoObjectType();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    JSType jSType1 = semanticReverseAbstractInterpreter0.getRestrictedWithoutNull(jSType0);
    assertFalse(jSType1.isEnumType());
}",""
"public boolean isRecordType() {
    return toMaybeRecordType() != null;
}","public void test055() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseBooleanType();
    JSType jSType1 = semanticReverseAbstractInterpreter0.getRestrictedWithoutNull(jSType0);
    assertFalse(jSType1.isRecordType());
}",""
"public boolean isRecordType() {
    return toMaybeRecordType() != null;
}","public void test066() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_FUNCTION_TYPE;
    FunctionType functionType0 = (FunctionType) jSTypeRegistry0.getNativeType(jSTypeNative0);
    ParameterizedType parameterizedType0 = jSTypeRegistry0.createParameterizedType(functionType0, functionType0);
    ParameterizedType parameterizedType1 = (ParameterizedType) semanticReverseAbstractInterpreter0.getRestrictedWithoutNull(parameterizedType0);
    assertFalse(parameterizedType1.isRecordType());
}",""
"public boolean isBooleanValueType() {
    return false;
}","public void test077() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.ALL_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    JSType jSType1 = semanticReverseAbstractInterpreter0.getRestrictedWithoutNull(jSType0);
    assertFalse(jSType1.isBooleanValueType());
}",""
"public boolean isAllType() {
    return false;
}","public void test088() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
    LinkedList<JSType> linkedList0 = new LinkedList<JSType>();
    JSType jSType0 = jSTypeRegistry0.createFunctionTypeWithVarArgs(objectType0, (JSType) objectType0, (List<JSType>) linkedList0);
    JSType jSType1 = semanticReverseAbstractInterpreter0.getRestrictedWithoutNull(jSType0);
    assertFalse(jSType1.isAllType());
}",""
"public final boolean isResolved() {
    return resolved;
}","public void test099() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NULL_VOID;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    JSType jSType1 = semanticReverseAbstractInterpreter0.getRestrictedWithoutNull(jSType0);
    JSType jSType2 = semanticReverseAbstractInterpreter0.getRestrictedWithoutNull(jSType1);
    assertFalse(jSType2.isResolved());
}","/**
 * Whether the type has been resolved.
 */"
"JSType getRestrictedByTypeOfResult(JSType type, String value, boolean resultEqualsValue) {
    if (type == null) {
        if (resultEqualsValue) {
            JSType result = getNativeTypeForTypeOf(value);
            return result == null ? getNativeType(UNKNOWN_TYPE) : result;
        } else {
            return null;
        }
    }
    return type.visit(new RestrictByOneTypeOfResultVisitor(value, resultEqualsValue));
}","public void test1010() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    JSType jSType1 = semanticReverseAbstractInterpreter0.getRestrictedByTypeOfResult(jSType0, ""function"", true);
    assertEquals(1, JSType.ENUMDECL);
}","/**
 * Returns a version of {@code type} that is restricted by some knowledge
 * about the result of the {@code typeof} operation.
 * <p>
 * The behavior of the {@code typeof} operator can be summarized by the
 * following table:
 * <table>
 * <tr><th>type</th><th>result</th></tr>
 * <tr><td>{@code undefined}</td><td>""undefined""</td></tr>
 * <tr><td>{@code null}</td><td>""object""</td></tr>
 * <tr><td>{@code boolean}</td><td>""boolean""</td></tr>
 * <tr><td>{@code number}</td><td>""number""</td></tr>
 * <tr><td>{@code string}</td><td>""string""</td></tr>
 * <tr><td>{@code Object} (which doesn't implement [[Call]])</td>
 *     <td>""object""</td></tr>
 * <tr><td>{@code Object} (which implements [[Call]])</td>
 *     <td>""function""</td></tr>
 * </table>
 * @param type the type to restrict
 * @param value A value known to be equal or not equal to the result of the
 *        {@code typeof} operation
 * @param resultEqualsValue {@code true} if the {@code typeOf} result is known
 *        to equal {@code value}; {@code false} if it is known <em>not</em> to
 *        equal {@code value}
 * @return the restricted type or null if no version of the type matches the
 *         restriction
 */"
"public boolean isNoType() {
    return false;
}","public void test1111() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    JSTypeNative jSTypeNative0 = JSTypeNative.CHECKED_UNKNOWN_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Node node0 = Node.newString(""com.google.common.base.Predicates$CompositionPredicate"", 1, 3586);
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter$RestrictByTypeOfResultVisitor"", node0, jSType0);
    EnumElementType enumElementType0 = enumType0.getElementsType();
    JSType jSType1 = semanticReverseAbstractInterpreter0.getRestrictedByTypeOfResult(enumElementType0, ""Not declared as a type name"", true);
    assertFalse(jSType1.isNoType());
}",""
"JSType getRestrictedByTypeOfResult(JSType type, String value, boolean resultEqualsValue) {
    if (type == null) {
        if (resultEqualsValue) {
            JSType result = getNativeTypeForTypeOf(value);
            return result == null ? getNativeType(UNKNOWN_TYPE) : result;
        } else {
            return null;
        }
    }
    return type.visit(new RestrictByOneTypeOfResultVisitor(value, resultEqualsValue));
}","public void test1212() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, (JSTypeRegistry) null);
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ParameterizedType parameterizedType0 = jSTypeRegistry0.createParameterizedType((ObjectType) null, (JSType) null);
    JSType jSType0 = semanticReverseAbstractInterpreter0.getRestrictedByTypeOfResult(parameterizedType0, ""Not declared as a constructor"", false);
    assertNull(jSType0);
}","/**
 * Returns a version of {@code type} that is restricted by some knowledge
 * about the result of the {@code typeof} operation.
 * <p>
 * The behavior of the {@code typeof} operator can be summarized by the
 * following table:
 * <table>
 * <tr><th>type</th><th>result</th></tr>
 * <tr><td>{@code undefined}</td><td>""undefined""</td></tr>
 * <tr><td>{@code null}</td><td>""object""</td></tr>
 * <tr><td>{@code boolean}</td><td>""boolean""</td></tr>
 * <tr><td>{@code number}</td><td>""number""</td></tr>
 * <tr><td>{@code string}</td><td>""string""</td></tr>
 * <tr><td>{@code Object} (which doesn't implement [[Call]])</td>
 *     <td>""object""</td></tr>
 * <tr><td>{@code Object} (which implements [[Call]])</td>
 *     <td>""function""</td></tr>
 * </table>
 * @param type the type to restrict
 * @param value A value known to be equal or not equal to the result of the
 *        {@code typeof} operation
 * @param resultEqualsValue {@code true} if the {@code typeOf} result is known
 *        to equal {@code value}; {@code false} if it is known <em>not</em> to
 *        equal {@code value}
 * @return the restricted type or null if no version of the type matches the
 *         restriction
 */"
"public boolean isFunctionPrototypeType() {
    return false;
}","public void test1313() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNoType();
    JSType jSType1 = semanticReverseAbstractInterpreter0.getRestrictedByTypeOfResult(jSType0, ""Not declared as a type name"", false);
    assertFalse(jSType1.isFunctionPrototypeType());
}","/**
 * Whether this is the prototype of a function.
 */"
"public boolean isInterface() {
    return false;
}","public void test1414() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseAllType();
    JSType jSType1 = semanticReverseAbstractInterpreter0.getRestrictedByTypeOfResult(jSType0, ""Unknown class name"", true);
    assertFalse(jSType1.isInterface());
}","/**
 * Whether this type is a {@link FunctionType} that is an interface or a named
 * type that points to such a type.
 */"
"public ChainableReverseAbstractInterpreter getFirst() {
    return firstLink;
}","public void test1515() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    ChainableReverseAbstractInterpreter chainableReverseAbstractInterpreter0 = semanticReverseAbstractInterpreter0.getFirst();
    assertSame(semanticReverseAbstractInterpreter0, chainableReverseAbstractInterpreter0);
}","/**
 * Gets the first link of this chain.
 */"
"protected FlowScope firstPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    return firstLink.getPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test1616() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    Node node0 = new Node(496);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, (JSTypeRegistry) null);
    FlowScope flowScope0 = closureReverseAbstractInterpreter0.firstPreciserScopeKnowingConditionOutcome(node0, (FlowScope) null, false);
    assertNull(flowScope0);
}","/**
 * Calculates the preciser scope starting with the first link.
 */"
"public boolean isNullType() {
    return false;
}","public void test1717() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNumberType();
    JSType jSType1 = jSTypeRegistry0.getGreatestSubtypeWithProperty(jSType0, ""P]I7G7D~`h"");
    JSType jSType2 = semanticReverseAbstractInterpreter0.getRestrictedWithoutUndefined(jSType1);
    assertFalse(jSType2.isNullType());
}",""
"protected final JSType getRestrictedWithoutUndefined(JSType type) {
    return type == null ? null : type.visit(restrictUndefinedVisitor);
}","public void test1818() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    ParameterizedType parameterizedType0 = jSTypeRegistry0.createParameterizedType((ObjectType) null, (JSType) null);
    JSType jSType0 = semanticReverseAbstractInterpreter0.getRestrictedWithoutUndefined(parameterizedType0);
    assertEquals(1, JSType.ENUMDECL);
}","/**
 * Returns a version of type where undefined is not present.
 */"
"public boolean hasReferenceName() {
    return false;
}","public void test1919() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseUnknownType();
    UnknownType unknownType0 = (UnknownType) semanticReverseAbstractInterpreter0.getRestrictedWithoutUndefined(jSType0);
    assertFalse(unknownType0.hasReferenceName());
}","/**
 * Returns true if the object is named.
 * @return true if the object is named, false if it is anonymous
 */"
"protected final JSType getRestrictedWithoutUndefined(JSType type) {
    return type == null ? null : type.visit(restrictUndefinedVisitor);
}","public void test2020() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    JSType jSType1 = semanticReverseAbstractInterpreter0.getRestrictedWithoutUndefined(jSType0);
    assertEquals(0, JSType.NOT_ENUMDECL);
}","/**
 * Returns a version of type where undefined is not present.
 */"
"public final boolean isEnumElementType() {
    return toMaybeEnumElementType() != null;
}","public void test2121() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseAllType();
    JSType jSType1 = semanticReverseAbstractInterpreter0.getRestrictedWithoutUndefined(jSType0);
    assertFalse(jSType1.isEnumElementType());
}",""
"public boolean isNoResolvedType() {
    return false;
}","public void test2222() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.TYPE_ERROR_FUNCTION_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    JSType jSType1 = semanticReverseAbstractInterpreter0.getRestrictedWithoutUndefined(jSType0);
    assertFalse(jSType1.isNoResolvedType());
}",""
"protected final JSType getRestrictedWithoutUndefined(JSType type) {
    return type == null ? null : type.visit(restrictUndefinedVisitor);
}","public void test2323() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NUMBER_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    JSType jSType1 = semanticReverseAbstractInterpreter0.getRestrictedWithoutUndefined(jSType0);
    assertSame(jSType1, jSType0);
}","/**
 * Returns a version of type where undefined is not present.
 */"
"public final boolean isFunctionType() {
    return toMaybeFunctionType() != null;
}","public void test2424() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseBooleanType();
    JSType jSType1 = semanticReverseAbstractInterpreter0.getRestrictedWithoutUndefined(jSType0);
    assertFalse(jSType1.isFunctionType());
}","/**
 * Returns true if toMaybeFunctionType returns a non-null FunctionType.
 */"
"public boolean isRecordType() {
    return toMaybeRecordType() != null;
}","public void test2525() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNoObjectType();
    JSType jSType1 = semanticReverseAbstractInterpreter0.getRestrictedWithoutUndefined(jSType0);
    assertFalse(jSType1.isRecordType());
}",""
"protected final JSType getRestrictedWithoutUndefined(JSType type) {
    return type == null ? null : type.visit(restrictUndefinedVisitor);
}","public void test2626() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.NULL_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    JSType jSType1 = semanticReverseAbstractInterpreter0.getRestrictedWithoutUndefined(jSType0);
    assertSame(jSType1, jSType0);
}","/**
 * Returns a version of type where undefined is not present.
 */"
"public ChainableReverseAbstractInterpreter append(ChainableReverseAbstractInterpreter lastLink) {
    Preconditions.checkArgument(lastLink.nextLink == null);
    this.nextLink = lastLink;
    lastLink.firstLink = this.firstLink;
    return lastLink;
}","public void test2727() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    closureReverseAbstractInterpreter0.append(semanticReverseAbstractInterpreter0);
    // Undeclared exception!
    try {
        semanticReverseAbstractInterpreter0.append(closureReverseAbstractInterpreter0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Appends a link to {@code this}, returning the updated last link.
 * <p>
 * The pattern {@code new X().append(new Y())...append(new Z())} forms a
 * chain starting with X, then Y, then ... Z.
 * @param lastLink a chainable interpreter, with no next link
 * @return the updated last link
 */"
"@Override
public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition, FlowScope blindScope, boolean outcome) {
    // Check for the typeof operator.
    int operatorToken = condition.getType();
    switch(operatorToken) {
        case Token.EQ:
        case Token.NE:
        case Token.SHEQ:
        case Token.SHNE:
        case Token.CASE:
            Node left;
            Node right;
            if (operatorToken == Token.CASE) {
                // the switch condition
                left = condition.getParent().getFirstChild();
                right = condition.getFirstChild();
            } else {
                left = condition.getFirstChild();
                right = condition.getLastChild();
            }
            Node typeOfNode = null;
            Node stringNode = null;
            if (left.isTypeOf() && right.isString()) {
                typeOfNode = left;
                stringNode = right;
            } else if (right.isTypeOf() && left.isString()) {
                typeOfNode = right;
                stringNode = left;
            }
            if (typeOfNode != null && stringNode != null) {
                Node operandNode = typeOfNode.getFirstChild();
                JSType operandType = getTypeIfRefinable(operandNode, blindScope);
                if (operandType != null) {
                    boolean resultEqualsValue = operatorToken == Token.EQ || operatorToken == Token.SHEQ || operatorToken == Token.CASE;
                    if (!outcome) {
                        resultEqualsValue = !resultEqualsValue;
                    }
                    return caseTypeOf(operandNode, operandType, stringNode.getString(), resultEqualsValue, blindScope);
                }
            }
    }
    switch(operatorToken) {
        case Token.AND:
            if (outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, true);
            }
        case Token.OR:
            if (!outcome) {
                return caseAndOrNotShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            } else {
                return caseAndOrMaybeShortCircuiting(condition.getFirstChild(), condition.getLastChild(), blindScope, false);
            }
        case Token.EQ:
            if (outcome) {
                return caseEquality(condition, blindScope, EQ);
            } else {
                return caseEquality(condition, blindScope, NE);
            }
        case Token.NE:
            if (outcome) {
                return caseEquality(condition, blindScope, NE);
            } else {
                return caseEquality(condition, blindScope, EQ);
            }
        case Token.SHEQ:
            if (outcome) {
                return caseEquality(condition, blindScope, SHEQ);
            } else {
                return caseEquality(condition, blindScope, SHNE);
            }
        case Token.SHNE:
            if (outcome) {
                return caseEquality(condition, blindScope, SHNE);
            } else {
                return caseEquality(condition, blindScope, SHEQ);
            }
        case Token.NAME:
        case Token.GETPROP:
            return caseNameOrGetProp(condition, blindScope, outcome);
        case Token.ASSIGN:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild().getNext(), blindScope, outcome), outcome);
        case Token.NOT:
            return firstPreciserScopeKnowingConditionOutcome(condition.getFirstChild(), blindScope, !outcome);
        case Token.LE:
        case Token.LT:
        case Token.GE:
        case Token.GT:
            if (outcome) {
                return caseEquality(condition, blindScope, INEQ);
            }
            break;
        case Token.INSTANCEOF:
            return caseInstanceOf(condition.getFirstChild(), condition.getLastChild(), blindScope, outcome);
        case Token.IN:
            if (outcome && condition.getFirstChild().isString()) {
                return caseIn(condition.getLastChild(), condition.getFirstChild().getString(), blindScope);
            }
            break;
        case Token.CASE:
            Node left = // the switch condition
            condition.getParent().getFirstChild();
            Node right = condition.getFirstChild();
            if (outcome) {
                return caseEquality(left, right, blindScope, SHEQ);
            } else {
                return caseEquality(left, right, blindScope, SHNE);
            }
    }
    return nextPreciserScopeKnowingConditionOutcome(condition, blindScope, outcome);
}","public void test2828() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    Node node0 = new Node((-359));
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, (JSTypeRegistry) null);
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(closureCodingConvention0, (JSTypeRegistry) null);
    semanticReverseAbstractInterpreter0.append(closureReverseAbstractInterpreter0);
    FlowScope flowScope0 = semanticReverseAbstractInterpreter0.getPreciserScopeKnowingConditionOutcome(node0, (FlowScope) null, false);
    assertNull(flowScope0);
}",""
"protected JSType getTypeIfRefinable(Node node, FlowScope scope) {
    switch(node.getType()) {
        case Token.NAME:
            StaticSlot<JSType> nameVar = scope.getSlot(node.getString());
            if (nameVar != null) {
                JSType nameVarType = nameVar.getType();
                if (nameVarType == null) {
                    nameVarType = node.getJSType();
                }
                return nameVarType;
            }
            return null;
        case Token.GETPROP:
            String qualifiedName = node.getQualifiedName();
            if (qualifiedName == null) {
                return null;
            }
            StaticSlot<JSType> propVar = scope.getSlot(qualifiedName);
            JSType propVarType = null;
            if (propVar != null) {
                propVarType = propVar.getType();
            }
            if (propVarType == null) {
                propVarType = node.getJSType();
            }
            if (propVarType == null) {
                propVarType = getNativeType(UNKNOWN_TYPE);
            }
            return propVarType;
    }
    return null;
}","public void test2929() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Node node0 = Node.newNumber((double) 33);
    Node node1 = new Node(33, node0, node0, 49, 48);
    JSType jSType0 = semanticReverseAbstractInterpreter0.getTypeIfRefinable(node1, (FlowScope) null);
    assertNull(jSType0);
}","/**
 * Returns the type of a node in the given scope if the node corresponds to a
 * name whose type is capable of being refined.
 * @return The current type of the node if it can be refined, null otherwise.
 */"
"protected JSType getTypeIfRefinable(Node node, FlowScope scope) {
    switch(node.getType()) {
        case Token.NAME:
            StaticSlot<JSType> nameVar = scope.getSlot(node.getString());
            if (nameVar != null) {
                JSType nameVarType = nameVar.getType();
                if (nameVarType == null) {
                    nameVarType = node.getJSType();
                }
                return nameVarType;
            }
            return null;
        case Token.GETPROP:
            String qualifiedName = node.getQualifiedName();
            if (qualifiedName == null) {
                return null;
            }
            StaticSlot<JSType> propVar = scope.getSlot(qualifiedName);
            JSType propVarType = null;
            if (propVar != null) {
                propVarType = propVar.getType();
            }
            if (propVarType == null) {
                propVarType = node.getJSType();
            }
            if (propVarType == null) {
                propVarType = getNativeType(UNKNOWN_TYPE);
            }
            return propVarType;
    }
    return null;
}","public void test3030() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    Node node0 = new Node((-359));
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, (JSTypeRegistry) null);
    JSType jSType0 = semanticReverseAbstractInterpreter0.getTypeIfRefinable(node0, (FlowScope) null);
    assertNull(jSType0);
}","/**
 * Returns the type of a node in the given scope if the node corresponds to a
 * name whose type is capable of being refined.
 * @return The current type of the node if it can be refined, null otherwise.
 */"
"protected JSType getTypeIfRefinable(Node node, FlowScope scope) {
    switch(node.getType()) {
        case Token.NAME:
            StaticSlot<JSType> nameVar = scope.getSlot(node.getString());
            if (nameVar != null) {
                JSType nameVarType = nameVar.getType();
                if (nameVarType == null) {
                    nameVarType = node.getJSType();
                }
                return nameVarType;
            }
            return null;
        case Token.GETPROP:
            String qualifiedName = node.getQualifiedName();
            if (qualifiedName == null) {
                return null;
            }
            StaticSlot<JSType> propVar = scope.getSlot(qualifiedName);
            JSType propVarType = null;
            if (propVar != null) {
                propVarType = propVar.getType();
            }
            if (propVarType == null) {
                propVarType = node.getJSType();
            }
            if (propVarType == null) {
                propVarType = getNativeType(UNKNOWN_TYPE);
            }
            return propVarType;
    }
    return null;
}","public void test3131() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    Node node0 = new Node(38, 38, 38);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, (JSTypeRegistry) null);
    // Undeclared exception!
    try {
        semanticReverseAbstractInterpreter0.getTypeIfRefinable(node0, (FlowScope) null);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // NAME 38 is not a string node
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}","/**
 * Returns the type of a node in the given scope if the node corresponds to a
 * name whose type is capable of being refined.
 * @return The current type of the node if it can be refined, null otherwise.
 */"
"protected void declareNameInScope(FlowScope scope, Node node, JSType type) {
    switch(node.getType()) {
        case Token.NAME:
            scope.inferSlotType(node.getString(), type);
            break;
        case Token.GETPROP:
            String qualifiedName = node.getQualifiedName();
            Preconditions.checkNotNull(qualifiedName);
            JSType origType = node.getJSType();
            origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;
            scope.inferQualifiedSlot(node, qualifiedName, origType, type);
            break;
        // ""this"" references aren't currently modeled in the CFG.
        default:
            throw new IllegalArgumentException(""Node cannot be refined. \n"" + node.toStringTree());
    }
}","public void test3232() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    Node node0 = new Node(33);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, (JSTypeRegistry) null);
    // Undeclared exception!
    try {
        semanticReverseAbstractInterpreter0.declareNameInScope((FlowScope) null, node0, (JSType) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}","/**
 * Declares a refined type in {@code scope} for the name represented by
 * {@code node}. It must be possible to refine the type of the given node in
 * the given scope, as determined by {@link #getTypeIfRefinable}.
 */"
"protected void declareNameInScope(FlowScope scope, Node node, JSType type) {
    switch(node.getType()) {
        case Token.NAME:
            scope.inferSlotType(node.getString(), type);
            break;
        case Token.GETPROP:
            String qualifiedName = node.getQualifiedName();
            Preconditions.checkNotNull(qualifiedName);
            JSType origType = node.getJSType();
            origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;
            scope.inferQualifiedSlot(node, qualifiedName, origType, type);
            break;
        // ""this"" references aren't currently modeled in the CFG.
        default:
            throw new IllegalArgumentException(""Node cannot be refined. \n"" + node.toStringTree());
    }
}","public void test3333() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    Node node0 = new Node(38);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, (JSTypeRegistry) null);
    // Undeclared exception!
    try {
        semanticReverseAbstractInterpreter0.declareNameInScope((FlowScope) null, node0, (JSType) null);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // NAME is not a string node
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}","/**
 * Declares a refined type in {@code scope} for the name represented by
 * {@code node}. It must be possible to refine the type of the given node in
 * the given scope, as determined by {@link #getTypeIfRefinable}.
 */"
"protected void declareNameInScope(FlowScope scope, Node node, JSType type) {
    switch(node.getType()) {
        case Token.NAME:
            scope.inferSlotType(node.getString(), type);
            break;
        case Token.GETPROP:
            String qualifiedName = node.getQualifiedName();
            Preconditions.checkNotNull(qualifiedName);
            JSType origType = node.getJSType();
            origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;
            scope.inferQualifiedSlot(node, qualifiedName, origType, type);
            break;
        // ""this"" references aren't currently modeled in the CFG.
        default:
            throw new IllegalArgumentException(""Node cannot be refined. \n"" + node.toStringTree());
    }
}","public void test3434() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
    Node node0 = Node.newString(""Unknown class name"");
    // Undeclared exception!
    try {
        semanticReverseAbstractInterpreter0.declareNameInScope((FlowScope) null, node0, objectType0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // Node cannot be refined.
        // STRING Unknown class name
        //
        verifyException(""com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter"", e);
    }
}","/**
 * Declares a refined type in {@code scope} for the name represented by
 * {@code node}. It must be possible to refine the type of the given node in
 * the given scope, as determined by {@link #getTypeIfRefinable}.
 */"
"protected final JSType getRestrictedWithoutUndefined(JSType type) {
    return type == null ? null : type.visit(restrictUndefinedVisitor);
}","public void test3535() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0, true);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    Node node0 = new Node(33, 33, 33);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseVoidType();
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""@geXDYjahV"", node0, jSType0);
    EnumElementType enumElementType0 = enumType0.getElementsType();
    JSType jSType1 = semanticReverseAbstractInterpreter0.getRestrictedWithoutUndefined(enumElementType0);
    assertNull(jSType1);
}","/**
 * Returns a version of type where undefined is not present.
 */"
"protected final JSType getRestrictedWithoutUndefined(JSType type) {
    return type == null ? null : type.visit(restrictUndefinedVisitor);
}","public void test3636() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    Node node0 = Node.newNumber((-2801.9986874646775));
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseStringType();
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Named type with empty name component"", node0, jSType0);
    EnumElementType enumElementType0 = enumType0.getElementsType();
    JSType jSType1 = semanticReverseAbstractInterpreter0.getRestrictedWithoutUndefined(enumElementType0);
    assertSame(enumElementType0, jSType1);
}","/**
 * Returns a version of type where undefined is not present.
 */"
"public boolean isNumberValueType() {
    return false;
}","public void test3737() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    JSTypeRegistry jSTypeRegistry1 = new JSTypeRegistry(simpleErrorReporter0);
    Node node0 = Node.newNumber((-2801.9986874646775));
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry1);
    JSType jSType0 = modificationVisitor0.caseStringType();
    EnumType enumType0 = jSTypeRegistry1.createEnumType(""Named type with empty name component"", node0, jSType0);
    EnumElementType enumElementType0 = enumType0.getElementsType();
    JSType jSType1 = semanticReverseAbstractInterpreter0.getRestrictedWithoutUndefined(enumElementType0);
    assertFalse(jSType1.isNumberValueType());
}",""
"@Override
public JSType caseUnionType(UnionType type) {
    boolean changed = false;
    List<JSType> results = Lists.newArrayList();
    for (JSType alternative : type.getAlternates()) {
        JSType replacement = alternative.visit(this);
        if (replacement != alternative) {
            changed = true;
        }
        results.add(replacement);
    }
    if (changed) {
        UnionTypeBuilder builder = new UnionTypeBuilder(registry);
        for (JSType alternate : results) {
            builder.addAlternate(alternate);
        }
        // maybe not a union
        return builder.build();
    }
    return type;
}","public void test3838() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSTypeRegistry jSTypeRegistry1 = new JSTypeRegistry(simpleErrorReporter0);
    Node.newNumber(0.0);
    UnionType unionType0 = mock(UnionType.class, new ViolatedAssumptionAnswer());
    doReturn((Iterable) null).when(unionType0).getAlternates();
    // Undeclared exception!
    try {
        modificationVisitor0.caseUnionType(unionType0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.rhino.jstype.ModificationVisitor"", e);
    }
}",""
"public boolean isNoObjectType() {
    return false;
}","public void test3939() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
    Node node0 = Node.newString(""Unknown class name"", 0, 1);
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Not declared as a constructor"", node0, objectType0);
    EnumElementType enumElementType0 = enumType0.getElementsType();
    JSType jSType0 = semanticReverseAbstractInterpreter0.getRestrictedWithoutNull(enumElementType0);
    assertFalse(jSType0.isNoObjectType());
}",""
"public boolean isEnumType() {
    return toMaybeEnumType() != null;
}","public void test4040() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    JSTypeRegistry jSTypeRegistry1 = new JSTypeRegistry(simpleErrorReporter0, true);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry1);
    JSType jSType0 = modificationVisitor0.caseStringType();
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Named type with empty name component"", (Node) null, jSType0);
    EnumElementType enumElementType0 = enumType0.getElementsType();
    JSType jSType1 = semanticReverseAbstractInterpreter0.getRestrictedWithoutNull(enumElementType0);
    assertFalse(jSType1.isEnumType());
}",""
"JSType getRestrictedByTypeOfResult(JSType type, String value, boolean resultEqualsValue) {
    if (type == null) {
        if (resultEqualsValue) {
            JSType result = getNativeTypeForTypeOf(value);
            return result == null ? getNativeType(UNKNOWN_TYPE) : result;
        } else {
            return null;
        }
    }
    return type.visit(new RestrictByOneTypeOfResultVisitor(value, resultEqualsValue));
}","public void test4141() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
    Node node0 = Node.newString(""Unknown class name"", 0, 1);
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Not declared as a constructor"", node0, objectType0);
    EnumElementType enumElementType0 = enumType0.getElementsType();
    JSType jSType0 = semanticReverseAbstractInterpreter0.getRestrictedByTypeOfResult(enumElementType0, ""Unknown class name"", false);
    assertNull(jSType0);
}","/**
 * Returns a version of {@code type} that is restricted by some knowledge
 * about the result of the {@code typeof} operation.
 * <p>
 * The behavior of the {@code typeof} operator can be summarized by the
 * following table:
 * <table>
 * <tr><th>type</th><th>result</th></tr>
 * <tr><td>{@code undefined}</td><td>""undefined""</td></tr>
 * <tr><td>{@code null}</td><td>""object""</td></tr>
 * <tr><td>{@code boolean}</td><td>""boolean""</td></tr>
 * <tr><td>{@code number}</td><td>""number""</td></tr>
 * <tr><td>{@code string}</td><td>""string""</td></tr>
 * <tr><td>{@code Object} (which doesn't implement [[Call]])</td>
 *     <td>""object""</td></tr>
 * <tr><td>{@code Object} (which implements [[Call]])</td>
 *     <td>""function""</td></tr>
 * </table>
 * @param type the type to restrict
 * @param value A value known to be equal or not equal to the result of the
 *        {@code typeof} operation
 * @param resultEqualsValue {@code true} if the {@code typeOf} result is known
 *        to equal {@code value}; {@code false} if it is known <em>not</em> to
 *        equal {@code value}
 * @return the restricted type or null if no version of the type matches the
 *         restriction
 */"
"public boolean isNoObjectType() {
    return false;
}","public void test4242() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNoObjectType();
    Node node0 = Node.newString(0, ""WB@ur8'6S^h"");
    EnumType enumType0 = jSTypeRegistry0.createEnumType(""Named type with empty name component"", node0, jSType0);
    EnumElementType enumElementType0 = enumType0.getElementsType();
    JSType jSType1 = jSTypeRegistry0.createOptionalNullableType(enumElementType0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    JSType jSType2 = semanticReverseAbstractInterpreter0.getRestrictedByTypeOfResult(jSType1, ""Unknown class name"", false);
    assertFalse(jSType2.isNoObjectType());
}",""
"public boolean hasCachedValues() {
    return !unknown;
}","public void test4343() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    JSType jSType0 = jSTypeRegistry0.createNamedType(""Named type with empty name component"", ""Unknown class name"", 1, 1);
    UnknownType unknownType0 = (UnknownType) semanticReverseAbstractInterpreter0.getRestrictedByTypeOfResult(jSType0, ""Named type with empty name component"", false);
    assertFalse(unknownType0.hasCachedValues());
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"public boolean matchesObjectContext() {
    return false;
}","public void test4444() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.UNKNOWN_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    JSType jSType1 = semanticReverseAbstractInterpreter0.getRestrictedByTypeOfResult(jSType0, ""undefined"", true);
    assertFalse(jSType1.matchesObjectContext());
}","/**
 * This predicate is used to test whether a given type can appear in an
 * {@code Object} context, such as the expression in a with statement.
 *
 * Most types we will encounter, except notably {@code null}, have at least
 * the potential for converting to {@code Object}.  Host defined objects can
 * get peculiar.
 */"
"public boolean isEnumType() {
    return toMaybeEnumType() != null;
}","public void test4545() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNoObjectType();
    JSType jSType1 = semanticReverseAbstractInterpreter0.getRestrictedByTypeOfResult(jSType0, ""object"", true);
    assertFalse(jSType1.isEnumType());
}",""
"JSType getRestrictedByTypeOfResult(JSType type, String value, boolean resultEqualsValue) {
    if (type == null) {
        if (resultEqualsValue) {
            JSType result = getNativeTypeForTypeOf(value);
            return result == null ? getNativeType(UNKNOWN_TYPE) : result;
        } else {
            return null;
        }
    }
    return type.visit(new RestrictByOneTypeOfResultVisitor(value, resultEqualsValue));
}","public void test4646() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    ModificationVisitor modificationVisitor0 = new ModificationVisitor(jSTypeRegistry0);
    JSType jSType0 = modificationVisitor0.caseNoObjectType();
    ClosureReverseAbstractInterpreter closureReverseAbstractInterpreter0 = new ClosureReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    JSType jSType1 = closureReverseAbstractInterpreter0.getRestrictedByTypeOfResult(jSType0, ""function"", false);
    assertNull(jSType1);
}","/**
 * Returns a version of {@code type} that is restricted by some knowledge
 * about the result of the {@code typeof} operation.
 * <p>
 * The behavior of the {@code typeof} operator can be summarized by the
 * following table:
 * <table>
 * <tr><th>type</th><th>result</th></tr>
 * <tr><td>{@code undefined}</td><td>""undefined""</td></tr>
 * <tr><td>{@code null}</td><td>""object""</td></tr>
 * <tr><td>{@code boolean}</td><td>""boolean""</td></tr>
 * <tr><td>{@code number}</td><td>""number""</td></tr>
 * <tr><td>{@code string}</td><td>""string""</td></tr>
 * <tr><td>{@code Object} (which doesn't implement [[Call]])</td>
 *     <td>""object""</td></tr>
 * <tr><td>{@code Object} (which implements [[Call]])</td>
 *     <td>""function""</td></tr>
 * </table>
 * @param type the type to restrict
 * @param value A value known to be equal or not equal to the result of the
 *        {@code typeof} operation
 * @param resultEqualsValue {@code true} if the {@code typeOf} result is known
 *        to equal {@code value}; {@code false} if it is known <em>not</em> to
 *        equal {@code value}
 * @return the restricted type or null if no version of the type matches the
 *         restriction
 */"
"JSType getRestrictedByTypeOfResult(JSType type, String value, boolean resultEqualsValue) {
    if (type == null) {
        if (resultEqualsValue) {
            JSType result = getNativeTypeForTypeOf(value);
            return result == null ? getNativeType(UNKNOWN_TYPE) : result;
        } else {
            return null;
        }
    }
    return type.visit(new RestrictByOneTypeOfResultVisitor(value, resultEqualsValue));
}","public void test4747() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    JSTypeNative jSTypeNative0 = JSTypeNative.U2U_FUNCTION_TYPE;
    JSType jSType0 = jSTypeRegistry0.getNativeType(jSTypeNative0);
    JSType jSType1 = semanticReverseAbstractInterpreter0.getRestrictedByTypeOfResult(jSType0, ""Unknown class name"", false);
    assertNull(jSType1);
}","/**
 * Returns a version of {@code type} that is restricted by some knowledge
 * about the result of the {@code typeof} operation.
 * <p>
 * The behavior of the {@code typeof} operator can be summarized by the
 * following table:
 * <table>
 * <tr><th>type</th><th>result</th></tr>
 * <tr><td>{@code undefined}</td><td>""undefined""</td></tr>
 * <tr><td>{@code null}</td><td>""object""</td></tr>
 * <tr><td>{@code boolean}</td><td>""boolean""</td></tr>
 * <tr><td>{@code number}</td><td>""number""</td></tr>
 * <tr><td>{@code string}</td><td>""string""</td></tr>
 * <tr><td>{@code Object} (which doesn't implement [[Call]])</td>
 *     <td>""object""</td></tr>
 * <tr><td>{@code Object} (which implements [[Call]])</td>
 *     <td>""function""</td></tr>
 * </table>
 * @param type the type to restrict
 * @param value A value known to be equal or not equal to the result of the
 *        {@code typeof} operation
 * @param resultEqualsValue {@code true} if the {@code typeOf} result is known
 *        to equal {@code value}; {@code false} if it is known <em>not</em> to
 *        equal {@code value}
 * @return the restricted type or null if no version of the type matches the
 *         restriction
 */"
"public boolean hasCachedValues() {
    return !unknown;
}","public void test4848() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
    semanticReverseAbstractInterpreter0.getRestrictedByTypeOfResult(objectType0, ""function"", false);
    assertFalse(objectType0.hasCachedValues());
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"public boolean hasCachedValues() {
    return !unknown;
}","public void test4949() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    ObjectType objectType0 = jSTypeRegistry0.createAnonymousObjectType();
    semanticReverseAbstractInterpreter0.getRestrictedByTypeOfResult(objectType0, ""function"", true);
    assertTrue(objectType0.hasCachedValues());
}","/**
 * Returns true if any cached values have been set for this type.  If true,
 * then the prototype chain should not be changed, as it might invalidate the
 * cached values.
 */"
"protected final JSType getRestrictedWithoutUndefined(JSType type) {
    return type == null ? null : type.visit(restrictUndefinedVisitor);
}","public void test5050() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    JSType jSType0 = semanticReverseAbstractInterpreter0.getRestrictedWithoutUndefined((JSType) null);
    assertNull(jSType0);
}","/**
 * Returns a version of type where undefined is not present.
 */"
"protected final JSType getRestrictedWithoutNull(JSType type) {
    return type == null ? null : type.visit(restrictNullVisitor);
}","public void test5151() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    JSType jSType0 = semanticReverseAbstractInterpreter0.getRestrictedWithoutNull((JSType) null);
    assertNull(jSType0);
}","/**
 * Returns a version of type where null is not present.
 */"
"JSType getRestrictedByTypeOfResult(JSType type, String value, boolean resultEqualsValue) {
    if (type == null) {
        if (resultEqualsValue) {
            JSType result = getNativeTypeForTypeOf(value);
            return result == null ? getNativeType(UNKNOWN_TYPE) : result;
        } else {
            return null;
        }
    }
    return type.visit(new RestrictByOneTypeOfResultVisitor(value, resultEqualsValue));
}","public void test5252() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, (JSTypeRegistry) null);
    // Undeclared exception!
    try {
        semanticReverseAbstractInterpreter0.getRestrictedByTypeOfResult((JSType) null, ""number"", true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter"", e);
    }
}","/**
 * Returns a version of {@code type} that is restricted by some knowledge
 * about the result of the {@code typeof} operation.
 * <p>
 * The behavior of the {@code typeof} operator can be summarized by the
 * following table:
 * <table>
 * <tr><th>type</th><th>result</th></tr>
 * <tr><td>{@code undefined}</td><td>""undefined""</td></tr>
 * <tr><td>{@code null}</td><td>""object""</td></tr>
 * <tr><td>{@code boolean}</td><td>""boolean""</td></tr>
 * <tr><td>{@code number}</td><td>""number""</td></tr>
 * <tr><td>{@code string}</td><td>""string""</td></tr>
 * <tr><td>{@code Object} (which doesn't implement [[Call]])</td>
 *     <td>""object""</td></tr>
 * <tr><td>{@code Object} (which implements [[Call]])</td>
 *     <td>""function""</td></tr>
 * </table>
 * @param type the type to restrict
 * @param value A value known to be equal or not equal to the result of the
 *        {@code typeof} operation
 * @param resultEqualsValue {@code true} if the {@code typeOf} result is known
 *        to equal {@code value}; {@code false} if it is known <em>not</em> to
 *        equal {@code value}
 * @return the restricted type or null if no version of the type matches the
 *         restriction
 */"
"JSType getRestrictedByTypeOfResult(JSType type, String value, boolean resultEqualsValue) {
    if (type == null) {
        if (resultEqualsValue) {
            JSType result = getNativeTypeForTypeOf(value);
            return result == null ? getNativeType(UNKNOWN_TYPE) : result;
        } else {
            return null;
        }
    }
    return type.visit(new RestrictByOneTypeOfResultVisitor(value, resultEqualsValue));
}","public void test5353() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, (JSTypeRegistry) null);
    JSType jSType0 = semanticReverseAbstractInterpreter0.getRestrictedByTypeOfResult((JSType) null, (String) null, false);
    assertNull(jSType0);
}","/**
 * Returns a version of {@code type} that is restricted by some knowledge
 * about the result of the {@code typeof} operation.
 * <p>
 * The behavior of the {@code typeof} operator can be summarized by the
 * following table:
 * <table>
 * <tr><th>type</th><th>result</th></tr>
 * <tr><td>{@code undefined}</td><td>""undefined""</td></tr>
 * <tr><td>{@code null}</td><td>""object""</td></tr>
 * <tr><td>{@code boolean}</td><td>""boolean""</td></tr>
 * <tr><td>{@code number}</td><td>""number""</td></tr>
 * <tr><td>{@code string}</td><td>""string""</td></tr>
 * <tr><td>{@code Object} (which doesn't implement [[Call]])</td>
 *     <td>""object""</td></tr>
 * <tr><td>{@code Object} (which implements [[Call]])</td>
 *     <td>""function""</td></tr>
 * </table>
 * @param type the type to restrict
 * @param value A value known to be equal or not equal to the result of the
 *        {@code typeof} operation
 * @param resultEqualsValue {@code true} if the {@code typeOf} result is known
 *        to equal {@code value}; {@code false} if it is known <em>not</em> to
 *        equal {@code value}
 * @return the restricted type or null if no version of the type matches the
 *         restriction
 */"
"JSType getRestrictedByTypeOfResult(JSType type, String value, boolean resultEqualsValue) {
    if (type == null) {
        if (resultEqualsValue) {
            JSType result = getNativeTypeForTypeOf(value);
            return result == null ? getNativeType(UNKNOWN_TYPE) : result;
        } else {
            return null;
        }
    }
    return type.visit(new RestrictByOneTypeOfResultVisitor(value, resultEqualsValue));
}","public void test5454() throws Throwable {
    ClosureCodingConvention closureCodingConvention0 = new ClosureCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(closureCodingConvention0, jSTypeRegistry0);
    JSType jSType0 = semanticReverseAbstractInterpreter0.getRestrictedByTypeOfResult((JSType) null, ""function"", true);
    assertEquals(1, JSType.ENUMDECL);
}","/**
 * Returns a version of {@code type} that is restricted by some knowledge
 * about the result of the {@code typeof} operation.
 * <p>
 * The behavior of the {@code typeof} operator can be summarized by the
 * following table:
 * <table>
 * <tr><th>type</th><th>result</th></tr>
 * <tr><td>{@code undefined}</td><td>""undefined""</td></tr>
 * <tr><td>{@code null}</td><td>""object""</td></tr>
 * <tr><td>{@code boolean}</td><td>""boolean""</td></tr>
 * <tr><td>{@code number}</td><td>""number""</td></tr>
 * <tr><td>{@code string}</td><td>""string""</td></tr>
 * <tr><td>{@code Object} (which doesn't implement [[Call]])</td>
 *     <td>""object""</td></tr>
 * <tr><td>{@code Object} (which implements [[Call]])</td>
 *     <td>""function""</td></tr>
 * </table>
 * @param type the type to restrict
 * @param value A value known to be equal or not equal to the result of the
 *        {@code typeof} operation
 * @param resultEqualsValue {@code true} if the {@code typeOf} result is known
 *        to equal {@code value}; {@code false} if it is known <em>not</em> to
 *        equal {@code value}
 * @return the restricted type or null if no version of the type matches the
 *         restriction
 */"
"JSType getRestrictedByTypeOfResult(JSType type, String value, boolean resultEqualsValue) {
    if (type == null) {
        if (resultEqualsValue) {
            JSType result = getNativeTypeForTypeOf(value);
            return result == null ? getNativeType(UNKNOWN_TYPE) : result;
        } else {
            return null;
        }
    }
    return type.visit(new RestrictByOneTypeOfResultVisitor(value, resultEqualsValue));
}","public void test5555() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, (JSTypeRegistry) null);
    // Undeclared exception!
    try {
        semanticReverseAbstractInterpreter0.getRestrictedByTypeOfResult((JSType) null, ""^+1[0&,kz"", true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter"", e);
    }
}","/**
 * Returns a version of {@code type} that is restricted by some knowledge
 * about the result of the {@code typeof} operation.
 * <p>
 * The behavior of the {@code typeof} operator can be summarized by the
 * following table:
 * <table>
 * <tr><th>type</th><th>result</th></tr>
 * <tr><td>{@code undefined}</td><td>""undefined""</td></tr>
 * <tr><td>{@code null}</td><td>""object""</td></tr>
 * <tr><td>{@code boolean}</td><td>""boolean""</td></tr>
 * <tr><td>{@code number}</td><td>""number""</td></tr>
 * <tr><td>{@code string}</td><td>""string""</td></tr>
 * <tr><td>{@code Object} (which doesn't implement [[Call]])</td>
 *     <td>""object""</td></tr>
 * <tr><td>{@code Object} (which implements [[Call]])</td>
 *     <td>""function""</td></tr>
 * </table>
 * @param type the type to restrict
 * @param value A value known to be equal or not equal to the result of the
 *        {@code typeof} operation
 * @param resultEqualsValue {@code true} if the {@code typeOf} result is known
 *        to equal {@code value}; {@code false} if it is known <em>not</em> to
 *        equal {@code value}
 * @return the restricted type or null if no version of the type matches the
 *         restriction
 */"
"public final boolean isNominalConstructor() {
    if (isConstructor() || isInterface()) {
        FunctionType fn = toMaybeFunctionType();
        if (fn == null) {
            return false;
        }
        // Programmer-defined constructors will have a link
        // back to the original function in the source tree.
        // Structural constructors will not.
        if (fn.getSource() != null) {
            return true;
        }
        // Native constructors are always nominal.
        return fn.isNativeObjectType();
    }
    return false;
}","public void test5656() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SimpleErrorReporter simpleErrorReporter0 = new SimpleErrorReporter();
    JSTypeRegistry jSTypeRegistry0 = new JSTypeRegistry(simpleErrorReporter0);
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, jSTypeRegistry0);
    JSType jSType0 = semanticReverseAbstractInterpreter0.getRestrictedByTypeOfResult((JSType) null, ""boolean"", true);
    assertFalse(jSType0.isNominalConstructor());
}","/**
 * Whether this type is the original constructor of a nominal type.
 * Does not include structural constructors.
 */"
"JSType getRestrictedByTypeOfResult(JSType type, String value, boolean resultEqualsValue) {
    if (type == null) {
        if (resultEqualsValue) {
            JSType result = getNativeTypeForTypeOf(value);
            return result == null ? getNativeType(UNKNOWN_TYPE) : result;
        } else {
            return null;
        }
    }
    return type.visit(new RestrictByOneTypeOfResultVisitor(value, resultEqualsValue));
}","public void test5757() throws Throwable {
    JqueryCodingConvention jqueryCodingConvention0 = new JqueryCodingConvention();
    SemanticReverseAbstractInterpreter semanticReverseAbstractInterpreter0 = new SemanticReverseAbstractInterpreter(jqueryCodingConvention0, (JSTypeRegistry) null);
    // Undeclared exception!
    try {
        semanticReverseAbstractInterpreter0.getRestrictedByTypeOfResult((JSType) null, ""string"", true);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter"", e);
    }
}","/**
 * Returns a version of {@code type} that is restricted by some knowledge
 * about the result of the {@code typeof} operation.
 * <p>
 * The behavior of the {@code typeof} operator can be summarized by the
 * following table:
 * <table>
 * <tr><th>type</th><th>result</th></tr>
 * <tr><td>{@code undefined}</td><td>""undefined""</td></tr>
 * <tr><td>{@code null}</td><td>""object""</td></tr>
 * <tr><td>{@code boolean}</td><td>""boolean""</td></tr>
 * <tr><td>{@code number}</td><td>""number""</td></tr>
 * <tr><td>{@code string}</td><td>""string""</td></tr>
 * <tr><td>{@code Object} (which doesn't implement [[Call]])</td>
 *     <td>""object""</td></tr>
 * <tr><td>{@code Object} (which implements [[Call]])</td>
 *     <td>""function""</td></tr>
 * </table>
 * @param type the type to restrict
 * @param value A value known to be equal or not equal to the result of the
 *        {@code typeof} operation
 * @param resultEqualsValue {@code true} if the {@code typeOf} result is known
 *        to equal {@code value}; {@code false} if it is known <em>not</em> to
 *        equal {@code value}
 * @return the restricted type or null if no version of the type matches the
 *         restriction
 */"
