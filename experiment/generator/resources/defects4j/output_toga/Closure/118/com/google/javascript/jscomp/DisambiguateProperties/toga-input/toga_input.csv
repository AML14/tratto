focal_method,test_prefix,docstring
"void renameProperties() {
    int propsRenamed = 0, propsSkipped = 0, instancesRenamed = 0, instancesSkipped = 0, singleTypeProps = 0;
    Set<String> reported = Sets.newHashSet();
    for (Property prop : properties.values()) {
        if (prop.shouldRename()) {
            Map<T, String> propNames = buildPropNames(prop.getTypes(), prop.name);
            ++propsRenamed;
            prop.expandTypesToSkip();
            for (Node node : prop.renameNodes) {
                T rootType = prop.rootTypes.get(node);
                if (prop.shouldRename(rootType)) {
                    String newName = propNames.get(rootType);
                    node.setString(newName);
                    compiler.reportCodeChange();
                    ++instancesRenamed;
                } else {
                    ++instancesSkipped;
                    CheckLevel checkLevelForProp = propertiesToErrorFor.get(prop.name);
                    if (checkLevelForProp != null && checkLevelForProp != CheckLevel.OFF && !reported.contains(prop.name)) {
                        reported.add(prop.name);
                        compiler.report(JSError.make(NodeUtil.getSourceName(node), node, checkLevelForProp, Warnings.INVALIDATION_ON_TYPE, prop.name, rootType.toString(), """"));
                    }
                }
            }
        } else {
            if (prop.skipRenaming) {
                ++propsSkipped;
            } else {
                ++singleTypeProps;
            }
        }
    }
    logger.fine(""Renamed "" + instancesRenamed + "" instances of "" + propsRenamed + "" properties."");
    logger.fine(""Skipped renaming "" + instancesSkipped + "" invalidated "" + ""properties, "" + propsSkipped + "" instances of properties "" + ""that were skipped for specific types and "" + singleTypeProps + "" properties that were referenced from only one type."");
}","public void test00() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.getErrorManager();
    TightenTypes tightenTypes0 = new TightenTypes(compiler0);
    CompilerOptions compilerOptions0 = compiler0.newCompilerOptions();
    Map<String, CheckLevel> map0 = compilerOptions0.propertyInvalidationErrors;
    DisambiguateProperties<ConcreteType> disambiguateProperties0 = DisambiguateProperties.forConcreteTypeSystem(compiler0, tightenTypes0, map0);
    disambiguateProperties0.renameProperties();
}","/**
 * Renames all properties with references on more than one type.
 */"
"T getTypeWithProperty(String field, T type) {
    return typeSystem.getTypeWithProperty(field, type);
}","public void test11() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.getErrorManager();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    Map<String, CheckLevel> map0 = compilerOptions0.propertyInvalidationErrors;
    Node node0 = new Node(3021);
    TightenTypes tightenTypes0 = new TightenTypes(compiler0);
    TightenTypes.ConcreteScope tightenTypes_ConcreteScope0 = tightenTypes0.new ConcreteScope((TightenTypes.ConcreteScope) null);
    ConcreteType concreteType0 = tightenTypes0.inferConcreteType(tightenTypes_ConcreteScope0, node0);
    DisambiguateProperties<ConcreteType> disambiguateProperties0 = DisambiguateProperties.forConcreteTypeSystem(compiler0, tightenTypes0, map0);
    ConcreteType concreteType1 = disambiguateProperties0.getTypeWithProperty(""N"", concreteType0);
    assertNotNull(concreteType1);
}","/**
 * Public for testing.
 */"
"static DisambiguateProperties<ConcreteType> forConcreteTypeSystem(AbstractCompiler compiler, TightenTypes tt, Map<String, CheckLevel> propertiesToErrorFor) {
    return new DisambiguateProperties<ConcreteType>(compiler, new ConcreteTypeSystem(tt, compiler.getCodingConvention()), propertiesToErrorFor);
}","public void test33() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.getErrorManager();
    TightenTypes tightenTypes0 = new TightenTypes(compiler0);
    HashMap<String, CheckLevel> hashMap0 = new HashMap<String, CheckLevel>();
    CheckLevel checkLevel0 = CheckLevel.WARNING;
    hashMap0.put("")@J\""uNbn`YUqeO9<"", checkLevel0);
    DisambiguateProperties<ConcreteType> disambiguateProperties0 = DisambiguateProperties.forConcreteTypeSystem(compiler0, tightenTypes0, hashMap0);
    assertNotNull(disambiguateProperties0);
}",""
"@Override
public void process(Node externs, Node root) {
    Preconditions.checkState(compiler.getLifeCycleStage() == LifeCycleStage.NORMALIZED);
    for (TypeMismatch mis : compiler.getTypeValidator().getMismatches()) {
        addInvalidatingType(mis.typeA, mis.src);
        addInvalidatingType(mis.typeB, mis.src);
    }
    NodeTraversal.traverse(compiler, externs, new FindExternProperties());
    NodeTraversal.traverse(compiler, root, new FindRenameableProperties());
    renameProperties();
}","public void test44() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.getErrorManager();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    Map<String, CheckLevel> map0 = compilerOptions0.propertyInvalidationErrors;
    DisambiguateProperties<JSType> disambiguateProperties0 = DisambiguateProperties.forJSTypeSystem(compiler0, map0);
    // Undeclared exception!
    try {
        disambiguateProperties0.process((Node) null, (Node) null);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"Multimap<String, Collection<T>> getRenamedTypesForTesting() {
    Multimap<String, Collection<T>> ret = HashMultimap.create();
    for (Map.Entry<String, Property> entry : properties.entrySet()) {
        Property prop = entry.getValue();
        if (!prop.skipRenaming) {
            for (Collection<T> c : prop.getTypes().allEquivalenceClasses()) {
                if (!c.isEmpty() && !prop.typesToSkip.contains(c.iterator().next())) {
                    ret.put(entry.getKey(), c);
                }
            }
        }
    }
    return ret;
}","public void test55() throws Throwable {
    Compiler compiler0 = new Compiler();
    compiler0.getErrorManager();
    CompilerOptions compilerOptions0 = new CompilerOptions();
    Map<String, CheckLevel> map0 = compilerOptions0.propertyInvalidationErrors;
    DisambiguateProperties<JSType> disambiguateProperties0 = DisambiguateProperties.forJSTypeSystem(compiler0, map0);
    Multimap<String, Collection<JSType>> multimap0 = disambiguateProperties0.getRenamedTypesForTesting();
    assertNotNull(multimap0);
}","/**
 * Returns a map from field name to types for which it will be renamed.
 */"
