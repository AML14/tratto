focal_method,test_prefix,docstring
"Collection<Node> getUses(String name, Node defNode) {
    GraphNode<Node, Branch> n = getCfg().getNode(defNode);
    Preconditions.checkNotNull(n);
    FlowState<ReachingUses> state = n.getAnnotation();
    return state.getOut().mayUseMap.get(jsScope.getVar(name));
}","public void test000() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("";"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    Scope scope0 = new Scope(node0, compiler0);
    MaybeReachingVariableUse maybeReachingVariableUse0 = new MaybeReachingVariableUse(controlFlowGraph0, scope0, compiler0);
    // Undeclared exception!
    try {
        maybeReachingVariableUse0.getUses("";"", node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.MaybeReachingVariableUse"", e);
    }
}","/**
 * Gets a list of nodes that may be using the value assigned to {@code name}
 * in {@code defNode}. {@code defNode} must be one of the control flow graph
 * nodes.
 *
 * @param name name of the variable. It can only be names of local variable
 *     that are not function parameters, escaped variables or variables
 *     declared in catch.
 * @param defNode The list of upward exposed use for the variable.
 */"
"final void analyze() {
    analyze(MAX_STEPS);
}","public void test011() throws Throwable {
    MockPrintStream mockPrintStream0 = new MockPrintStream(""TI"");
    PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
    Compiler compiler0 = new Compiler(printStreamErrorManager0);
    Node node0 = compiler0.parseTestCode(""TI"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    Scope scope0 = new Scope(node0, compiler0);
    MaybeReachingVariableUse maybeReachingVariableUse0 = new MaybeReachingVariableUse(controlFlowGraph0, scope0, compiler0);
    maybeReachingVariableUse0.analyze();
}","/**
 * Finds a fixed-point solution using at most {@link #MAX_STEPS}
 * iterations.
 *
 * @see #analyze(int)
 */"
"final void analyze() {
    analyze(MAX_STEPS);
}","public void test044() throws Throwable {
    MockPrintStream mockPrintStream0 = new MockPrintStream(""TI"");
    PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
    Compiler compiler0 = new Compiler(printStreamErrorManager0);
    Node node0 = compiler0.parseTestCode(""TI"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    Scope scope0 = new Scope(node0, compiler0);
    MaybeReachingVariableUse maybeReachingVariableUse0 = new MaybeReachingVariableUse(controlFlowGraph0, scope0, compiler0);
    InputId inputId0 = node0.getInputId();
    CompilerInput compilerInput0 = compiler0.getInput(inputId0);
    scope0.declare(""TI"", node0, (JSType) null, compilerInput0, false);
    maybeReachingVariableUse0.analyze();
}","/**
 * Finds a fixed-point solution using at most {@link #MAX_STEPS}
 * iterations.
 *
 * @see #analyze(int)
 */"
"@SuppressWarnings(""unchecked"")
protected L join(L latticeA, L latticeB) {
    return joinOp.apply(Lists.<L>newArrayList(latticeA, latticeB));
}","public void test055() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("";"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, true);
    Scope scope0 = new Scope(node0, compiler0);
    MaybeReachingVariableUse maybeReachingVariableUse0 = new MaybeReachingVariableUse(controlFlowGraph0, scope0, compiler0);
    MaybeReachingVariableUse.ReachingUses maybeReachingVariableUse_ReachingUses0 = maybeReachingVariableUse0.createEntryLattice();
    MaybeReachingVariableUse.ReachingUses maybeReachingVariableUse_ReachingUses1 = maybeReachingVariableUse0.join(maybeReachingVariableUse_ReachingUses0, maybeReachingVariableUse_ReachingUses0);
    assertNotSame(maybeReachingVariableUse_ReachingUses1, maybeReachingVariableUse_ReachingUses0);
}",""
"@Override
ReachingUses flowThrough(Node n, ReachingUses input) {
    ReachingUses output = new ReachingUses(input);
    // If there's an ON_EX edge, this cfgNode may or may not get executed.
    // We can express this concisely by just pretending this happens in
    // a conditional.
    boolean conditional = hasExceptionHandler(n);
    computeMayUse(n, n, output, conditional);
    return output;
}","public void test066() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""TI"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    Scope scope0 = new Scope(node0, compiler0);
    MaybeReachingVariableUse maybeReachingVariableUse0 = new MaybeReachingVariableUse(controlFlowGraph0, scope0, compiler0);
    Node node1 = new Node(98, node0, node0, node0, node0);
    MaybeReachingVariableUse.ReachingUses maybeReachingVariableUse_ReachingUses0 = new MaybeReachingVariableUse.ReachingUses();
    // Undeclared exception!
    try {
        maybeReachingVariableUse0.flowThrough(node1, maybeReachingVariableUse_ReachingUses0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.MaybeReachingVariableUse"", e);
    }
}",""
"@Override
ReachingUses flowThrough(Node n, ReachingUses input) {
    ReachingUses output = new ReachingUses(input);
    // If there's an ON_EX edge, this cfgNode may or may not get executed.
    // We can express this concisely by just pretending this happens in
    // a conditional.
    boolean conditional = hasExceptionHandler(n);
    computeMayUse(n, n, output, conditional);
    return output;
}","public void test077() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseSyntheticCode(""TI"", ""TI"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    Scope scope0 = new Scope(node0, compiler0);
    MaybeReachingVariableUse maybeReachingVariableUse0 = new MaybeReachingVariableUse(controlFlowGraph0, scope0, compiler0);
    MaybeReachingVariableUse.ReachingUses maybeReachingVariableUse_ReachingUses0 = maybeReachingVariableUse0.createEntryLattice();
    Node node1 = new Node(100, node0, node0, node0, node0);
    MaybeReachingVariableUse.ReachingUses maybeReachingVariableUse_ReachingUses1 = maybeReachingVariableUse0.flowThrough(node1, maybeReachingVariableUse_ReachingUses0);
    assertNotSame(maybeReachingVariableUse_ReachingUses1, maybeReachingVariableUse_ReachingUses0);
}",""
"@Override
ReachingUses flowThrough(Node n, ReachingUses input) {
    ReachingUses output = new ReachingUses(input);
    // If there's an ON_EX edge, this cfgNode may or may not get executed.
    // We can express this concisely by just pretending this happens in
    // a conditional.
    boolean conditional = hasExceptionHandler(n);
    computeMayUse(n, n, output, conditional);
    return output;
}","public void test088() throws Throwable {
    MockPrintStream mockPrintStream0 = new MockPrintStream(""TI"");
    PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
    Compiler compiler0 = new Compiler(printStreamErrorManager0);
    Node node0 = compiler0.parseTestCode(""TI"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    Scope scope0 = new Scope(node0, compiler0);
    MaybeReachingVariableUse maybeReachingVariableUse0 = new MaybeReachingVariableUse(controlFlowGraph0, scope0, compiler0);
    MaybeReachingVariableUse.ReachingUses maybeReachingVariableUse_ReachingUses0 = maybeReachingVariableUse0.createEntryLattice();
    Node node1 = new Node(101, node0, node0, node0, node0);
    MaybeReachingVariableUse.ReachingUses maybeReachingVariableUse_ReachingUses1 = maybeReachingVariableUse0.flowThrough(node1, maybeReachingVariableUse_ReachingUses0);
    assertNotSame(maybeReachingVariableUse_ReachingUses1, maybeReachingVariableUse_ReachingUses0);
}",""
"@Override
ReachingUses flowThrough(Node n, ReachingUses input) {
    ReachingUses output = new ReachingUses(input);
    // If there's an ON_EX edge, this cfgNode may or may not get executed.
    // We can express this concisely by just pretending this happens in
    // a conditional.
    boolean conditional = hasExceptionHandler(n);
    computeMayUse(n, n, output, conditional);
    return output;
}","public void test099() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""TI"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    Scope scope0 = new Scope(node0, compiler0);
    MaybeReachingVariableUse maybeReachingVariableUse0 = new MaybeReachingVariableUse(controlFlowGraph0, scope0, compiler0);
    MaybeReachingVariableUse.ReachingUses maybeReachingVariableUse_ReachingUses0 = new MaybeReachingVariableUse.ReachingUses();
    Node node1 = new Node(105, 45, 37);
    MaybeReachingVariableUse.ReachingUses maybeReachingVariableUse_ReachingUses1 = maybeReachingVariableUse0.flowThrough(node1, maybeReachingVariableUse_ReachingUses0);
    assertNotSame(maybeReachingVariableUse_ReachingUses1, maybeReachingVariableUse_ReachingUses0);
}",""
"@Override
ReachingUses flowThrough(Node n, ReachingUses input) {
    ReachingUses output = new ReachingUses(input);
    // If there's an ON_EX edge, this cfgNode may or may not get executed.
    // We can express this concisely by just pretending this happens in
    // a conditional.
    boolean conditional = hasExceptionHandler(n);
    computeMayUse(n, n, output, conditional);
    return output;
}","public void test1010() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Tb"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    Scope scope0 = new Scope(node0, compiler0);
    MaybeReachingVariableUse maybeReachingVariableUse0 = new MaybeReachingVariableUse(controlFlowGraph0, scope0, compiler0);
    MaybeReachingVariableUse.ReachingUses maybeReachingVariableUse_ReachingUses0 = new MaybeReachingVariableUse.ReachingUses();
    Node node1 = Node.newString(108, ""/YfP>:^EV(lPK"", 1, 52);
    // Undeclared exception!
    try {
        maybeReachingVariableUse0.flowThrough(node1, maybeReachingVariableUse_ReachingUses0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.MaybeReachingVariableUse"", e);
    }
}",""
"@Override
ReachingUses flowThrough(Node n, ReachingUses input) {
    ReachingUses output = new ReachingUses(input);
    // If there's an ON_EX edge, this cfgNode may or may not get executed.
    // We can express this concisely by just pretending this happens in
    // a conditional.
    boolean conditional = hasExceptionHandler(n);
    computeMayUse(n, n, output, conditional);
    return output;
}","public void test1111() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""TI"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    Scope scope0 = new Scope(node0, compiler0);
    MaybeReachingVariableUse maybeReachingVariableUse0 = new MaybeReachingVariableUse(controlFlowGraph0, scope0, compiler0);
    MaybeReachingVariableUse.ReachingUses maybeReachingVariableUse_ReachingUses0 = new MaybeReachingVariableUse.ReachingUses();
    Node node1 = new Node(113, node0, node0, node0);
    MaybeReachingVariableUse.ReachingUses maybeReachingVariableUse_ReachingUses1 = maybeReachingVariableUse0.flowThrough(node1, maybeReachingVariableUse_ReachingUses0);
    assertNotSame(maybeReachingVariableUse_ReachingUses1, maybeReachingVariableUse_ReachingUses0);
}",""
"@Override
ReachingUses flowThrough(Node n, ReachingUses input) {
    ReachingUses output = new ReachingUses(input);
    // If there's an ON_EX edge, this cfgNode may or may not get executed.
    // We can express this concisely by just pretending this happens in
    // a conditional.
    boolean conditional = hasExceptionHandler(n);
    computeMayUse(n, n, output, conditional);
    return output;
}","public void test1212() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode("";"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    Scope scope0 = new Scope(node0, compiler0);
    MaybeReachingVariableUse maybeReachingVariableUse0 = new MaybeReachingVariableUse(controlFlowGraph0, scope0, compiler0);
    Node node1 = new Node(114, node0, node0, node0, node0);
    MaybeReachingVariableUse.ReachingUses maybeReachingVariableUse_ReachingUses0 = new MaybeReachingVariableUse.ReachingUses();
    MaybeReachingVariableUse.ReachingUses maybeReachingVariableUse_ReachingUses1 = maybeReachingVariableUse0.flowThrough(node1, maybeReachingVariableUse_ReachingUses0);
    assertNotSame(maybeReachingVariableUse_ReachingUses1, maybeReachingVariableUse_ReachingUses0);
}",""
"@Override
ReachingUses flowThrough(Node n, ReachingUses input) {
    ReachingUses output = new ReachingUses(input);
    // If there's an ON_EX edge, this cfgNode may or may not get executed.
    // We can express this concisely by just pretending this happens in
    // a conditional.
    boolean conditional = hasExceptionHandler(n);
    computeMayUse(n, n, output, conditional);
    return output;
}","public void test1313() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""Tb"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    Scope scope0 = new Scope(node0, compiler0);
    MaybeReachingVariableUse maybeReachingVariableUse0 = new MaybeReachingVariableUse(controlFlowGraph0, scope0, compiler0);
    MaybeReachingVariableUse.ReachingUses maybeReachingVariableUse_ReachingUses0 = new MaybeReachingVariableUse.ReachingUses();
    Node node1 = new Node(115, 45, 37);
    // Undeclared exception!
    try {
        maybeReachingVariableUse0.flowThrough(node1, maybeReachingVariableUse_ReachingUses0);
        fail(""Expecting exception: IllegalArgumentException"");
    } catch (IllegalArgumentException e) {
        //
        // malformed 'for' statement FOR 45
        //
        verifyException(""com.google.javascript.jscomp.NodeUtil"", e);
    }
}",""
"@Override
ReachingUses flowThrough(Node n, ReachingUses input) {
    ReachingUses output = new ReachingUses(input);
    // If there's an ON_EX edge, this cfgNode may or may not get executed.
    // We can express this concisely by just pretending this happens in
    // a conditional.
    boolean conditional = hasExceptionHandler(n);
    computeMayUse(n, n, output, conditional);
    return output;
}","public void test1414() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""TI"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, true, true);
    Scope scope0 = new Scope(node0, compiler0);
    MaybeReachingVariableUse maybeReachingVariableUse0 = new MaybeReachingVariableUse(controlFlowGraph0, scope0, compiler0);
    Node node1 = new Node(118, node0, node0, node0, node0);
    MaybeReachingVariableUse.ReachingUses maybeReachingVariableUse_ReachingUses0 = new MaybeReachingVariableUse.ReachingUses();
    // Undeclared exception!
    try {
        maybeReachingVariableUse0.flowThrough(node1, maybeReachingVariableUse_ReachingUses0);
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // SCRIPT 1 [synthetic: com.google.javascript.rhino.Node$IntPropListItem@0000000517] [source_file: com.google.javascript.rhino.Node$ObjectPropListItem@0000000518] [input_id: com.google.javascript.rhino.Node$ObjectPropListItem@0000000519] is not a string node
        //
        verifyException(""com.google.javascript.rhino.Node"", e);
    }
}",""
"@Override
ReachingUses flowThrough(Node n, ReachingUses input) {
    ReachingUses output = new ReachingUses(input);
    // If there's an ON_EX edge, this cfgNode may or may not get executed.
    // We can express this concisely by just pretending this happens in
    // a conditional.
    boolean conditional = hasExceptionHandler(n);
    computeMayUse(n, n, output, conditional);
    return output;
}","public void test1515() throws Throwable {
    MockPrintStream mockPrintStream0 = new MockPrintStream(""TI"");
    PrintStreamErrorManager printStreamErrorManager0 = new PrintStreamErrorManager(mockPrintStream0);
    Compiler compiler0 = new Compiler(printStreamErrorManager0);
    Node node0 = compiler0.parseTestCode(""TI"");
    ControlFlowGraph<Node> controlFlowGraph0 = new ControlFlowGraph<Node>(node0, false, false);
    Scope scope0 = new Scope(node0, compiler0);
    MaybeReachingVariableUse maybeReachingVariableUse0 = new MaybeReachingVariableUse(controlFlowGraph0, scope0, compiler0);
    MaybeReachingVariableUse.ReachingUses maybeReachingVariableUse_ReachingUses0 = maybeReachingVariableUse0.createEntryLattice();
    Node node1 = new Node(91, node0, node0, node0, node0);
    MaybeReachingVariableUse.ReachingUses maybeReachingVariableUse_ReachingUses1 = maybeReachingVariableUse0.flowThrough(node1, maybeReachingVariableUse_ReachingUses0);
    assertNotSame(maybeReachingVariableUse_ReachingUses1, maybeReachingVariableUse_ReachingUses0);
}",""
