focal_method,test_prefix,docstring
"@Override
protected Compiler createCompiler() {
    return new Compiler(getErrorPrintStream());
}","public void test000() throws Throwable {
    String[] stringArray0 = new String[0];
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0);
    Compiler compiler0 = commandLineRunner0.createCompiler();
    assertNotNull(compiler0);
}",""
"@VisibleForTesting
static void createDefineReplacements(List<String> definitions, CompilerOptions options) {
    // Parse the definitions
    for (String override : definitions) {
        String[] assignment = override.split(""="", 2);
        String defName = assignment[0];
        if (defName.length() > 0) {
            if (assignment.length == 1) {
                options.setDefineToBooleanLiteral(defName, true);
                continue;
            } else {
                String defValue = assignment[1];
                if (defValue.equals(""true"")) {
                    options.setDefineToBooleanLiteral(defName, true);
                    continue;
                } else if (defValue.equals(""false"")) {
                    options.setDefineToBooleanLiteral(defName, false);
                    continue;
                } else if (defValue.length() > 1 && ((defValue.charAt(0) == '\'' && defValue.charAt(defValue.length() - 1) == '\'') || (defValue.charAt(0) == '\""' && defValue.charAt(defValue.length() - 1) == '\""'))) {
                    // If the value starts and ends with a single quote,
                    // we assume that it's a string.
                    String maybeStringVal = defValue.substring(1, defValue.length() - 1);
                    if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) {
                        options.setDefineToStringLiteral(defName, maybeStringVal);
                        continue;
                    }
                } else {
                    try {
                        options.setDefineToDoubleLiteral(defName, Double.parseDouble(defValue));
                        continue;
                    } catch (NumberFormatException e) {
                        // do nothing, it will be caught at the end
                    }
                }
            }
        }
        throw new RuntimeException(""--define flag syntax invalid: "" + override);
    }
}","public void test011() throws Throwable {
    String[] stringArray0 = new String[0];
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0);
    CompilerOptions compilerOptions0 = commandLineRunner0.createOptions();
    JSModule jSModule0 = new JSModule("""");
    List<String> list0 = jSModule0.getProvides();
    // Undeclared exception!
    try {
        AbstractCommandLineRunner.createDefineReplacements(list0, compilerOptions0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // --define flag syntax invalid:
        //
        verifyException(""com.google.javascript.jscomp.AbstractCommandLineRunner"", e);
    }
}","/**
 * Create a map of constant names to constant values from a textual
 * description of the map.
 *
 * @param definitions A list of overriding definitions for defines in
 *     the form <name>[=<val>], where <val> is a number, boolean, or
 *     single-quoted string without single quotes.
 */"
"final protected A getCompiler() {
    return compiler;
}","public void test022() throws Throwable {
    String[] stringArray0 = new String[0];
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0);
    Compiler compiler0 = commandLineRunner0.getCompiler();
    assertNull(compiler0);
}",""
"public static void main(String[] args) {
    CommandLineRunner runner = new CommandLineRunner(args);
    if (runner.shouldRunCompiler()) {
        runner.run();
    } else {
        System.exit(-1);
    }
}","public void test033() throws Throwable {
    String[] stringArray0 = new String[0];
    // Undeclared exception!
    try {
        CommandLineRunner.main(stringArray0);
        fail(""Expecting exception: System.SystemExitException"");
    } catch (System.SystemExitException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.System"", e);
    }
}","/**
 * Runs the Compiler. Exits cleanly in the event of an error.
 */"
"final protected void setRunOptions(CompilerOptions options) throws FlagUsageException, IOException {
    DiagnosticGroups diagnosticGroups = getDiagnosticGroups();
    diagnosticGroups.setWarningLevels(options, config.jscompError, CheckLevel.ERROR);
    diagnosticGroups.setWarningLevels(options, config.jscompWarning, CheckLevel.WARNING);
    diagnosticGroups.setWarningLevels(options, config.jscompOff, CheckLevel.OFF);
    createDefineReplacements(config.define, options);
    options.manageClosureDependencies = config.manageClosureDependencies;
    options.devMode = config.jscompDevMode;
    options.setCodingConvention(config.codingConvention);
    options.setSummaryDetailLevel(config.summaryDetailLevel);
    inputCharset = getInputCharset();
    if (config.jsOutputFile.length() > 0) {
        options.jsOutputFile = config.jsOutputFile;
    }
    if (config.createSourceMap.length() > 0) {
        options.sourceMapOutputPath = config.createSourceMap;
    }
    options.sourceMapDetailLevel = config.sourceMapDetailLevel;
    if (!config.variableMapInputFile.equals("""")) {
        options.inputVariableMapSerialized = VariableMap.load(config.variableMapInputFile).toBytes();
    }
    if (!config.propertyMapInputFile.equals("""")) {
        options.inputPropertyMapSerialized = VariableMap.load(config.propertyMapInputFile).toBytes();
    }
}","public void test044() throws Throwable {
    String[] stringArray0 = new String[0];
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0);
    CompilerOptions compilerOptions0 = new CompilerOptions();
    commandLineRunner0.setRunOptions(compilerOptions0);
    assertFalse(compilerOptions0.collapseProperties);
}","/**
 * Sets options based on the configurations set flags API.
 * Called during the run() run() method.
 * If you want to ignore the flags API, or intepret flags your own way,
 * then you should override this method.
 */"
"static JSModule[] createJsModules(List<String> specs, List<String> jsFiles) throws FlagUsageException, IOException {
    Preconditions.checkState(specs != null);
    Preconditions.checkState(!specs.isEmpty());
    Preconditions.checkState(jsFiles != null);
    final int totalNumJsFiles = jsFiles.size();
    int nextJsFileIndex = 0;
    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();
    for (String spec : specs) {
        // Format is ""<name>:<num-js-files>[:[<dep>,...][:]]"".
        String[] parts = spec.split("":"");
        if (parts.length < 2 || parts.length > 4) {
            throw new FlagUsageException(""Expected 2-4 colon-delimited parts in "" + ""module spec: "" + spec);
        }
        // Parse module name.
        String name = parts[0];
        if (!TokenStream.isJSIdentifier(name)) {
            throw new FlagUsageException(""Invalid module name: '"" + name + ""'"");
        }
        if (modulesByName.containsKey(name)) {
            throw new FlagUsageException(""Duplicate module name: "" + name);
        }
        JSModule module = new JSModule(name);
        // Parse module inputs.
        int numJsFiles = -1;
        try {
            numJsFiles = Integer.parseInt(parts[1]);
        } catch (NumberFormatException ignored) {
            numJsFiles = -1;
        }
        // We will allow modules of zero input.
        if (numJsFiles < 0) {
            throw new FlagUsageException(""Invalid js file count '"" + parts[1] + ""' for module: "" + name);
        }
        if (nextJsFileIndex + numJsFiles > totalNumJsFiles) {
            throw new FlagUsageException(""Not enough js files specified. Expected "" + (nextJsFileIndex + numJsFiles - totalNumJsFiles) + "" more in module:"" + name);
        }
        List<String> moduleJsFiles = jsFiles.subList(nextJsFileIndex, nextJsFileIndex + numJsFiles);
        for (JSSourceFile input : createInputs(moduleJsFiles, false)) {
            module.add(input);
        }
        nextJsFileIndex += numJsFiles;
        if (parts.length > 2) {
            // Parse module dependencies.
            String depList = parts[2];
            if (depList.length() > 0) {
                String[] deps = depList.split("","");
                for (String dep : deps) {
                    JSModule other = modulesByName.get(dep);
                    if (other == null) {
                        throw new FlagUsageException(""Module '"" + name + ""' depends on unknown module '"" + dep + ""'. Be sure to list modules in dependency order."");
                    }
                    module.addDependency(other);
                }
            }
        }
        modulesByName.put(name, module);
    }
    if (nextJsFileIndex < totalNumJsFiles) {
        throw new FlagUsageException(""Too many js files specified. Expected "" + nextJsFileIndex + "" but found "" + totalNumJsFiles);
    }
    return modulesByName.values().toArray(new JSModule[modulesByName.size()]);
}","public void test055() throws Throwable {
    LinkedList<String> linkedList0 = new LinkedList<String>();
    linkedList0.addLast(""flFa76rE:'%%"");
    try {
        AbstractCommandLineRunner.createJsModules(linkedList0, linkedList0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Invalid js file count ''%%' for module: flFa76rE
        //
        verifyException(""com.google.javascript.jscomp.AbstractCommandLineRunner"", e);
    }
}","/**
 * Creates module objects from a list of module specifications.
 *
 * @param specs A list of module specifications, not null or empty. The spec
 *        format is: <code>name:num-js-files[:[dep,...][:]]</code>. Module
 *        names must not contain the ':' character.
 * @param jsFiles A list of js file paths, not null
 * @return An array of module objects
 */"
"void exit(RunTimeStats runTimeStats, Throwable error) {
    int result = 0;
    if (error instanceof AbstractCommandLineRunner.FlagUsageException) {
        System.err.println(error.getMessage());
        result = -1;
    } else if (error != null) {
        error.printStackTrace();
        result = -2;
    }
    if (config.computePhaseOrdering) {
        runTimeStats.outputBestPhaseOrdering();
    }
    System.exit(result);
}","public void test077() throws Throwable {
    String[] stringArray0 = new String[0];
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0);
    AbstractCommandLineRunner.RunTimeStats abstractCommandLineRunner_RunTimeStats0 = commandLineRunner0.new RunTimeStats();
    // Undeclared exception!
    try {
        commandLineRunner0.exit(abstractCommandLineRunner_RunTimeStats0, (Throwable) null);
        fail(""Expecting exception: System.SystemExitException"");
    } catch (System.SystemExitException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""org.evosuite.runtime.System"", e);
    }
}","/**
 * Exits the current process. Prints out any ""process"" statistics
 * that the user might need to know about.
 */"
"static JSModule[] createJsModules(List<String> specs, List<String> jsFiles) throws FlagUsageException, IOException {
    Preconditions.checkState(specs != null);
    Preconditions.checkState(!specs.isEmpty());
    Preconditions.checkState(jsFiles != null);
    final int totalNumJsFiles = jsFiles.size();
    int nextJsFileIndex = 0;
    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();
    for (String spec : specs) {
        // Format is ""<name>:<num-js-files>[:[<dep>,...][:]]"".
        String[] parts = spec.split("":"");
        if (parts.length < 2 || parts.length > 4) {
            throw new FlagUsageException(""Expected 2-4 colon-delimited parts in "" + ""module spec: "" + spec);
        }
        // Parse module name.
        String name = parts[0];
        if (!TokenStream.isJSIdentifier(name)) {
            throw new FlagUsageException(""Invalid module name: '"" + name + ""'"");
        }
        if (modulesByName.containsKey(name)) {
            throw new FlagUsageException(""Duplicate module name: "" + name);
        }
        JSModule module = new JSModule(name);
        // Parse module inputs.
        int numJsFiles = -1;
        try {
            numJsFiles = Integer.parseInt(parts[1]);
        } catch (NumberFormatException ignored) {
            numJsFiles = -1;
        }
        // We will allow modules of zero input.
        if (numJsFiles < 0) {
            throw new FlagUsageException(""Invalid js file count '"" + parts[1] + ""' for module: "" + name);
        }
        if (nextJsFileIndex + numJsFiles > totalNumJsFiles) {
            throw new FlagUsageException(""Not enough js files specified. Expected "" + (nextJsFileIndex + numJsFiles - totalNumJsFiles) + "" more in module:"" + name);
        }
        List<String> moduleJsFiles = jsFiles.subList(nextJsFileIndex, nextJsFileIndex + numJsFiles);
        for (JSSourceFile input : createInputs(moduleJsFiles, false)) {
            module.add(input);
        }
        nextJsFileIndex += numJsFiles;
        if (parts.length > 2) {
            // Parse module dependencies.
            String depList = parts[2];
            if (depList.length() > 0) {
                String[] deps = depList.split("","");
                for (String dep : deps) {
                    JSModule other = modulesByName.get(dep);
                    if (other == null) {
                        throw new FlagUsageException(""Module '"" + name + ""' depends on unknown module '"" + dep + ""'. Be sure to list modules in dependency order."");
                    }
                    module.addDependency(other);
                }
            }
        }
        modulesByName.put(name, module);
    }
    if (nextJsFileIndex < totalNumJsFiles) {
        throw new FlagUsageException(""Too many js files specified. Expected "" + nextJsFileIndex + "" but found "" + totalNumJsFiles);
    }
    return modulesByName.values().toArray(new JSModule[modulesByName.size()]);
}","public void test088() throws Throwable {
    // Undeclared exception!
    try {
        AbstractCommandLineRunner.createJsModules((List<String>) null, (List<String>) null);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Creates module objects from a list of module specifications.
 *
 * @param specs A list of module specifications, not null or empty. The spec
 *        format is: <code>name:num-js-files[:[dep,...][:]]</code>. Module
 *        names must not contain the ':' character.
 * @param jsFiles A list of js file paths, not null
 * @return An array of module objects
 */"
"static JSModule[] createJsModules(List<String> specs, List<String> jsFiles) throws FlagUsageException, IOException {
    Preconditions.checkState(specs != null);
    Preconditions.checkState(!specs.isEmpty());
    Preconditions.checkState(jsFiles != null);
    final int totalNumJsFiles = jsFiles.size();
    int nextJsFileIndex = 0;
    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();
    for (String spec : specs) {
        // Format is ""<name>:<num-js-files>[:[<dep>,...][:]]"".
        String[] parts = spec.split("":"");
        if (parts.length < 2 || parts.length > 4) {
            throw new FlagUsageException(""Expected 2-4 colon-delimited parts in "" + ""module spec: "" + spec);
        }
        // Parse module name.
        String name = parts[0];
        if (!TokenStream.isJSIdentifier(name)) {
            throw new FlagUsageException(""Invalid module name: '"" + name + ""'"");
        }
        if (modulesByName.containsKey(name)) {
            throw new FlagUsageException(""Duplicate module name: "" + name);
        }
        JSModule module = new JSModule(name);
        // Parse module inputs.
        int numJsFiles = -1;
        try {
            numJsFiles = Integer.parseInt(parts[1]);
        } catch (NumberFormatException ignored) {
            numJsFiles = -1;
        }
        // We will allow modules of zero input.
        if (numJsFiles < 0) {
            throw new FlagUsageException(""Invalid js file count '"" + parts[1] + ""' for module: "" + name);
        }
        if (nextJsFileIndex + numJsFiles > totalNumJsFiles) {
            throw new FlagUsageException(""Not enough js files specified. Expected "" + (nextJsFileIndex + numJsFiles - totalNumJsFiles) + "" more in module:"" + name);
        }
        List<String> moduleJsFiles = jsFiles.subList(nextJsFileIndex, nextJsFileIndex + numJsFiles);
        for (JSSourceFile input : createInputs(moduleJsFiles, false)) {
            module.add(input);
        }
        nextJsFileIndex += numJsFiles;
        if (parts.length > 2) {
            // Parse module dependencies.
            String depList = parts[2];
            if (depList.length() > 0) {
                String[] deps = depList.split("","");
                for (String dep : deps) {
                    JSModule other = modulesByName.get(dep);
                    if (other == null) {
                        throw new FlagUsageException(""Module '"" + name + ""' depends on unknown module '"" + dep + ""'. Be sure to list modules in dependency order."");
                    }
                    module.addDependency(other);
                }
            }
        }
        modulesByName.put(name, module);
    }
    if (nextJsFileIndex < totalNumJsFiles) {
        throw new FlagUsageException(""Too many js files specified. Expected "" + nextJsFileIndex + "" but found "" + totalNumJsFiles);
    }
    return modulesByName.values().toArray(new JSModule[modulesByName.size()]);
}","public void test099() throws Throwable {
    LinkedList<String> linkedList0 = new LinkedList<String>();
    // Undeclared exception!
    try {
        AbstractCommandLineRunner.createJsModules(linkedList0, linkedList0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Creates module objects from a list of module specifications.
 *
 * @param specs A list of module specifications, not null or empty. The spec
 *        format is: <code>name:num-js-files[:[dep,...][:]]</code>. Module
 *        names must not contain the ':' character.
 * @param jsFiles A list of js file paths, not null
 * @return An array of module objects
 */"
"static JSModule[] createJsModules(List<String> specs, List<String> jsFiles) throws FlagUsageException, IOException {
    Preconditions.checkState(specs != null);
    Preconditions.checkState(!specs.isEmpty());
    Preconditions.checkState(jsFiles != null);
    final int totalNumJsFiles = jsFiles.size();
    int nextJsFileIndex = 0;
    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();
    for (String spec : specs) {
        // Format is ""<name>:<num-js-files>[:[<dep>,...][:]]"".
        String[] parts = spec.split("":"");
        if (parts.length < 2 || parts.length > 4) {
            throw new FlagUsageException(""Expected 2-4 colon-delimited parts in "" + ""module spec: "" + spec);
        }
        // Parse module name.
        String name = parts[0];
        if (!TokenStream.isJSIdentifier(name)) {
            throw new FlagUsageException(""Invalid module name: '"" + name + ""'"");
        }
        if (modulesByName.containsKey(name)) {
            throw new FlagUsageException(""Duplicate module name: "" + name);
        }
        JSModule module = new JSModule(name);
        // Parse module inputs.
        int numJsFiles = -1;
        try {
            numJsFiles = Integer.parseInt(parts[1]);
        } catch (NumberFormatException ignored) {
            numJsFiles = -1;
        }
        // We will allow modules of zero input.
        if (numJsFiles < 0) {
            throw new FlagUsageException(""Invalid js file count '"" + parts[1] + ""' for module: "" + name);
        }
        if (nextJsFileIndex + numJsFiles > totalNumJsFiles) {
            throw new FlagUsageException(""Not enough js files specified. Expected "" + (nextJsFileIndex + numJsFiles - totalNumJsFiles) + "" more in module:"" + name);
        }
        List<String> moduleJsFiles = jsFiles.subList(nextJsFileIndex, nextJsFileIndex + numJsFiles);
        for (JSSourceFile input : createInputs(moduleJsFiles, false)) {
            module.add(input);
        }
        nextJsFileIndex += numJsFiles;
        if (parts.length > 2) {
            // Parse module dependencies.
            String depList = parts[2];
            if (depList.length() > 0) {
                String[] deps = depList.split("","");
                for (String dep : deps) {
                    JSModule other = modulesByName.get(dep);
                    if (other == null) {
                        throw new FlagUsageException(""Module '"" + name + ""' depends on unknown module '"" + dep + ""'. Be sure to list modules in dependency order."");
                    }
                    module.addDependency(other);
                }
            }
        }
        modulesByName.put(name, module);
    }
    if (nextJsFileIndex < totalNumJsFiles) {
        throw new FlagUsageException(""Too many js files specified. Expected "" + nextJsFileIndex + "" but found "" + totalNumJsFiles);
    }
    return modulesByName.values().toArray(new JSModule[modulesByName.size()]);
}","public void test1010() throws Throwable {
    LinkedList<String> linkedList0 = new LinkedList<String>();
    linkedList0.addLast(""Expected module wrapperCto have <name>:<wrapper> fdrmat: "");
    // Undeclared exception!
    try {
        AbstractCommandLineRunner.createJsModules(linkedList0, (List<String>) null);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Creates module objects from a list of module specifications.
 *
 * @param specs A list of module specifications, not null or empty. The spec
 *        format is: <code>name:num-js-files[:[dep,...][:]]</code>. Module
 *        names must not contain the ':' character.
 * @param jsFiles A list of js file paths, not null
 * @return An array of module objects
 */"
"static JSModule[] createJsModules(List<String> specs, List<String> jsFiles) throws FlagUsageException, IOException {
    Preconditions.checkState(specs != null);
    Preconditions.checkState(!specs.isEmpty());
    Preconditions.checkState(jsFiles != null);
    final int totalNumJsFiles = jsFiles.size();
    int nextJsFileIndex = 0;
    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();
    for (String spec : specs) {
        // Format is ""<name>:<num-js-files>[:[<dep>,...][:]]"".
        String[] parts = spec.split("":"");
        if (parts.length < 2 || parts.length > 4) {
            throw new FlagUsageException(""Expected 2-4 colon-delimited parts in "" + ""module spec: "" + spec);
        }
        // Parse module name.
        String name = parts[0];
        if (!TokenStream.isJSIdentifier(name)) {
            throw new FlagUsageException(""Invalid module name: '"" + name + ""'"");
        }
        if (modulesByName.containsKey(name)) {
            throw new FlagUsageException(""Duplicate module name: "" + name);
        }
        JSModule module = new JSModule(name);
        // Parse module inputs.
        int numJsFiles = -1;
        try {
            numJsFiles = Integer.parseInt(parts[1]);
        } catch (NumberFormatException ignored) {
            numJsFiles = -1;
        }
        // We will allow modules of zero input.
        if (numJsFiles < 0) {
            throw new FlagUsageException(""Invalid js file count '"" + parts[1] + ""' for module: "" + name);
        }
        if (nextJsFileIndex + numJsFiles > totalNumJsFiles) {
            throw new FlagUsageException(""Not enough js files specified. Expected "" + (nextJsFileIndex + numJsFiles - totalNumJsFiles) + "" more in module:"" + name);
        }
        List<String> moduleJsFiles = jsFiles.subList(nextJsFileIndex, nextJsFileIndex + numJsFiles);
        for (JSSourceFile input : createInputs(moduleJsFiles, false)) {
            module.add(input);
        }
        nextJsFileIndex += numJsFiles;
        if (parts.length > 2) {
            // Parse module dependencies.
            String depList = parts[2];
            if (depList.length() > 0) {
                String[] deps = depList.split("","");
                for (String dep : deps) {
                    JSModule other = modulesByName.get(dep);
                    if (other == null) {
                        throw new FlagUsageException(""Module '"" + name + ""' depends on unknown module '"" + dep + ""'. Be sure to list modules in dependency order."");
                    }
                    module.addDependency(other);
                }
            }
        }
        modulesByName.put(name, module);
    }
    if (nextJsFileIndex < totalNumJsFiles) {
        throw new FlagUsageException(""Too many js files specified. Expected "" + nextJsFileIndex + "" but found "" + totalNumJsFiles);
    }
    return modulesByName.values().toArray(new JSModule[modulesByName.size()]);
}","public void test1111() throws Throwable {
    List<String> list0 = ResourceBundle.Control.FORMAT_DEFAULT;
    try {
        AbstractCommandLineRunner.createJsModules(list0, list0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Expected 2-4 colon-delimited parts in module spec: java.class
        //
        verifyException(""com.google.javascript.jscomp.AbstractCommandLineRunner"", e);
    }
}","/**
 * Creates module objects from a list of module specifications.
 *
 * @param specs A list of module specifications, not null or empty. The spec
 *        format is: <code>name:num-js-files[:[dep,...][:]]</code>. Module
 *        names must not contain the ':' character.
 * @param jsFiles A list of js file paths, not null
 * @return An array of module objects
 */"
"static JSModule[] createJsModules(List<String> specs, List<String> jsFiles) throws FlagUsageException, IOException {
    Preconditions.checkState(specs != null);
    Preconditions.checkState(!specs.isEmpty());
    Preconditions.checkState(jsFiles != null);
    final int totalNumJsFiles = jsFiles.size();
    int nextJsFileIndex = 0;
    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();
    for (String spec : specs) {
        // Format is ""<name>:<num-js-files>[:[<dep>,...][:]]"".
        String[] parts = spec.split("":"");
        if (parts.length < 2 || parts.length > 4) {
            throw new FlagUsageException(""Expected 2-4 colon-delimited parts in "" + ""module spec: "" + spec);
        }
        // Parse module name.
        String name = parts[0];
        if (!TokenStream.isJSIdentifier(name)) {
            throw new FlagUsageException(""Invalid module name: '"" + name + ""'"");
        }
        if (modulesByName.containsKey(name)) {
            throw new FlagUsageException(""Duplicate module name: "" + name);
        }
        JSModule module = new JSModule(name);
        // Parse module inputs.
        int numJsFiles = -1;
        try {
            numJsFiles = Integer.parseInt(parts[1]);
        } catch (NumberFormatException ignored) {
            numJsFiles = -1;
        }
        // We will allow modules of zero input.
        if (numJsFiles < 0) {
            throw new FlagUsageException(""Invalid js file count '"" + parts[1] + ""' for module: "" + name);
        }
        if (nextJsFileIndex + numJsFiles > totalNumJsFiles) {
            throw new FlagUsageException(""Not enough js files specified. Expected "" + (nextJsFileIndex + numJsFiles - totalNumJsFiles) + "" more in module:"" + name);
        }
        List<String> moduleJsFiles = jsFiles.subList(nextJsFileIndex, nextJsFileIndex + numJsFiles);
        for (JSSourceFile input : createInputs(moduleJsFiles, false)) {
            module.add(input);
        }
        nextJsFileIndex += numJsFiles;
        if (parts.length > 2) {
            // Parse module dependencies.
            String depList = parts[2];
            if (depList.length() > 0) {
                String[] deps = depList.split("","");
                for (String dep : deps) {
                    JSModule other = modulesByName.get(dep);
                    if (other == null) {
                        throw new FlagUsageException(""Module '"" + name + ""' depends on unknown module '"" + dep + ""'. Be sure to list modules in dependency order."");
                    }
                    module.addDependency(other);
                }
            }
        }
        modulesByName.put(name, module);
    }
    if (nextJsFileIndex < totalNumJsFiles) {
        throw new FlagUsageException(""Too many js files specified. Expected "" + nextJsFileIndex + "" but found "" + totalNumJsFiles);
    }
    return modulesByName.values().toArray(new JSModule[modulesByName.size()]);
}","public void test1212() throws Throwable {
    LinkedList<String> linkedList0 = new LinkedList<String>();
    linkedList0.addFirst(""Expected module wrapperCto have <name>:<wrapper> format: "");
    try {
        AbstractCommandLineRunner.createJsModules(linkedList0, linkedList0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Invalid module name: 'Expected module wrapperCto have <name>'
        //
        verifyException(""com.google.javascript.jscomp.AbstractCommandLineRunner"", e);
    }
}","/**
 * Creates module objects from a list of module specifications.
 *
 * @param specs A list of module specifications, not null or empty. The spec
 *        format is: <code>name:num-js-files[:[dep,...][:]]</code>. Module
 *        names must not contain the ':' character.
 * @param jsFiles A list of js file paths, not null
 * @return An array of module objects
 */"
"static Map<String, String> parseModuleWrappers(List<String> specs, JSModule[] modules) throws FlagUsageException {
    Preconditions.checkState(specs != null);
    Map<String, String> wrappers = Maps.newHashMapWithExpectedSize(modules.length);
    // Prepopulate the map with module names.
    for (JSModule m : modules) {
        wrappers.put(m.getName(), """");
    }
    for (String spec : specs) {
        // Format is ""<name>:<wrapper>"".
        int pos = spec.indexOf(':');
        if (pos == -1) {
            throw new FlagUsageException(""Expected module wrapper to have "" + ""<name>:<wrapper> format: "" + spec);
        }
        // Parse module name.
        String name = spec.substring(0, pos);
        if (!wrappers.containsKey(name)) {
            throw new FlagUsageException(""Unknown module: '"" + name + ""'"");
        }
        String wrapper = spec.substring(pos + 1);
        if (!wrapper.contains(""%s"")) {
            throw new FlagUsageException(""No %s placeholder in module wrapper: '"" + wrapper + ""'"");
        }
        wrappers.put(name, wrapper);
    }
    return wrappers;
}","public void test1313() throws Throwable {
    JSModule[] jSModuleArray0 = new JSModule[0];
    // Undeclared exception!
    try {
        AbstractCommandLineRunner.parseModuleWrappers((List<String>) null, jSModuleArray0);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}","/**
 * Parses module wrapper specifications.
 *
 * @param specs A list of module wrapper specifications, not null. The spec
 *        format is: <code>name:wrapper</code>. Wrappers.
 * @param modules The JS modules whose wrappers are specified
 * @return A map from module name to module wrapper. Modules with no wrapper
 *         will have the empty string as their value in this map.
 */"
"int processResults(Result result, JSModule[] modules, B options) throws FlagUsageException, IOException {
    if (config.computePhaseOrdering) {
        return 0;
    }
    if (config.printPassGraph) {
        if (compiler.getRoot() == null) {
            return 1;
        } else {
            out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));
            out.append('\n');
            return 0;
        }
    }
    if (config.printAst) {
        if (compiler.getRoot() == null) {
            return 1;
        } else {
            ControlFlowGraph<Node> cfg = compiler.computeCFG();
            DotFormatter.appendDot(compiler.getRoot(), cfg, out);
            out.append('\n');
            return 0;
        }
    }
    if (config.printTree) {
        if (compiler.getRoot() == null) {
            out.append(""Code contains errors; no tree was generated.\n"");
            return 1;
        } else {
            compiler.getRoot().appendStringTree(out);
            out.append(""\n"");
            return 0;
        }
    }
    if (result.success) {
        if (modules == null) {
            writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, config.outputWrapperMarker);
            // Output the source map if requested.
            outputSourceMap(options);
        } else {
            String moduleFilePrefix = config.moduleOutputPathPrefix;
            maybeCreateDirsForPath(moduleFilePrefix);
            Map<String, String> moduleWrappers = parseModuleWrappers(config.moduleWrapper, modules);
            // If the source map path is in fact a pattern for each
            // module, create a stream per-module. Otherwise, create
            // a single source map.
            Writer mapOut = null;
            if (!shouldGenerateMapPerModule(options)) {
                mapOut = toWriter(expandSourceMapPath(options, null));
            }
            for (JSModule m : modules) {
                if (shouldGenerateMapPerModule(options)) {
                    mapOut = toWriter(expandSourceMapPath(options, m));
                }
                Writer writer = toWriter(moduleFilePrefix + m.getName() + "".js"");
                if (options.sourceMapOutputPath != null) {
                    compiler.getSourceMap().reset();
                }
                writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), ""%s"");
                if (options.sourceMapOutputPath != null) {
                    compiler.getSourceMap().appendTo(mapOut, m.getName());
                }
                writer.close();
                if (shouldGenerateMapPerModule(options) && mapOut != null) {
                    mapOut.close();
                    mapOut = null;
                }
            }
            if (mapOut != null) {
                mapOut.close();
            }
        }
        // Output the externs if required.
        if (options.externExportsPath != null) {
            Writer eeOut = openExternExportsStream(options, options.jsOutputFile);
            eeOut.append(result.externExport);
            eeOut.close();
        }
        // Output the variable and property name maps if requested.
        outputNameMaps(options);
        // Output the manifest if requested.
        outputManifest();
    }
    // return 0 if no errors, the error count otherwise
    return Math.min(result.errors.length, 0x7f);
}","public void test1414() throws Throwable {
    String[] stringArray0 = new String[3];
    stringArray0[0] = ""^2[L9"";
    stringArray0[1] = """";
    stringArray0[2] = ""lWwOf%hEJ=N7]!"";
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0);
    Logger logger0 = Logger.getAnonymousLogger();
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    CompilerOptions compilerOptions0 = new CompilerOptions();
    Result result0 = compiler0.getResult();
    JSModule[] jSModuleArray0 = new JSModule[0];
    int int0 = commandLineRunner0.processResults(result0, jSModuleArray0, compilerOptions0);
    assertEquals(0, int0);
}","/**
 * Processes the results of the compile job, and returns an error code.
 */"
"int processResults(Result result, JSModule[] modules, B options) throws FlagUsageException, IOException {
    if (config.computePhaseOrdering) {
        return 0;
    }
    if (config.printPassGraph) {
        if (compiler.getRoot() == null) {
            return 1;
        } else {
            out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));
            out.append('\n');
            return 0;
        }
    }
    if (config.printAst) {
        if (compiler.getRoot() == null) {
            return 1;
        } else {
            ControlFlowGraph<Node> cfg = compiler.computeCFG();
            DotFormatter.appendDot(compiler.getRoot(), cfg, out);
            out.append('\n');
            return 0;
        }
    }
    if (config.printTree) {
        if (compiler.getRoot() == null) {
            out.append(""Code contains errors; no tree was generated.\n"");
            return 1;
        } else {
            compiler.getRoot().appendStringTree(out);
            out.append(""\n"");
            return 0;
        }
    }
    if (result.success) {
        if (modules == null) {
            writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, config.outputWrapperMarker);
            // Output the source map if requested.
            outputSourceMap(options);
        } else {
            String moduleFilePrefix = config.moduleOutputPathPrefix;
            maybeCreateDirsForPath(moduleFilePrefix);
            Map<String, String> moduleWrappers = parseModuleWrappers(config.moduleWrapper, modules);
            // If the source map path is in fact a pattern for each
            // module, create a stream per-module. Otherwise, create
            // a single source map.
            Writer mapOut = null;
            if (!shouldGenerateMapPerModule(options)) {
                mapOut = toWriter(expandSourceMapPath(options, null));
            }
            for (JSModule m : modules) {
                if (shouldGenerateMapPerModule(options)) {
                    mapOut = toWriter(expandSourceMapPath(options, m));
                }
                Writer writer = toWriter(moduleFilePrefix + m.getName() + "".js"");
                if (options.sourceMapOutputPath != null) {
                    compiler.getSourceMap().reset();
                }
                writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), ""%s"");
                if (options.sourceMapOutputPath != null) {
                    compiler.getSourceMap().appendTo(mapOut, m.getName());
                }
                writer.close();
                if (shouldGenerateMapPerModule(options) && mapOut != null) {
                    mapOut.close();
                    mapOut = null;
                }
            }
            if (mapOut != null) {
                mapOut.close();
            }
        }
        // Output the externs if required.
        if (options.externExportsPath != null) {
            Writer eeOut = openExternExportsStream(options, options.jsOutputFile);
            eeOut.append(result.externExport);
            eeOut.close();
        }
        // Output the variable and property name maps if requested.
        outputNameMaps(options);
        // Output the manifest if requested.
        outputManifest();
    }
    // return 0 if no errors, the error count otherwise
    return Math.min(result.errors.length, 0x7f);
}","public void test1515() throws Throwable {
    String[] stringArray0 = new String[0];
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0);
    Logger logger0 = Logger.getAnonymousLogger();
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    CompilerOptions compilerOptions0 = new CompilerOptions();
    Result result0 = compiler0.getResult();
    JSModule[] jSModuleArray0 = new JSModule[1];
    // Undeclared exception!
    try {
        commandLineRunner0.processResults(result0, jSModuleArray0, compilerOptions0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.AbstractCommandLineRunner"", e);
    }
}","/**
 * Processes the results of the compile job, and returns an error code.
 */"
"static Map<String, String> parseModuleWrappers(List<String> specs, JSModule[] modules) throws FlagUsageException {
    Preconditions.checkState(specs != null);
    Map<String, String> wrappers = Maps.newHashMapWithExpectedSize(modules.length);
    // Prepopulate the map with module names.
    for (JSModule m : modules) {
        wrappers.put(m.getName(), """");
    }
    for (String spec : specs) {
        // Format is ""<name>:<wrapper>"".
        int pos = spec.indexOf(':');
        if (pos == -1) {
            throw new FlagUsageException(""Expected module wrapper to have "" + ""<name>:<wrapper> format: "" + spec);
        }
        // Parse module name.
        String name = spec.substring(0, pos);
        if (!wrappers.containsKey(name)) {
            throw new FlagUsageException(""Unknown module: '"" + name + ""'"");
        }
        String wrapper = spec.substring(pos + 1);
        if (!wrapper.contains(""%s"")) {
            throw new FlagUsageException(""No %s placeholder in module wrapper: '"" + wrapper + ""'"");
        }
        wrappers.put(name, wrapper);
    }
    return wrappers;
}","public void test1616() throws Throwable {
    LinkedList<String> linkedList0 = new LinkedList<String>();
    linkedList0.addLast(""Expected module wrapperCto have <name>:<wrapper> fdrmat: "");
    JSModule[] jSModuleArray0 = new JSModule[0];
    try {
        AbstractCommandLineRunner.parseModuleWrappers(linkedList0, jSModuleArray0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Unknown module: 'Expected module wrapperCto have <name>'
        //
        verifyException(""com.google.javascript.jscomp.AbstractCommandLineRunner"", e);
    }
}","/**
 * Parses module wrapper specifications.
 *
 * @param specs A list of module wrapper specifications, not null. The spec
 *        format is: <code>name:wrapper</code>. Wrappers.
 * @param modules The JS modules whose wrappers are specified
 * @return A map from module name to module wrapper. Modules with no wrapper
 *         will have the empty string as their value in this map.
 */"
"static Map<String, String> parseModuleWrappers(List<String> specs, JSModule[] modules) throws FlagUsageException {
    Preconditions.checkState(specs != null);
    Map<String, String> wrappers = Maps.newHashMapWithExpectedSize(modules.length);
    // Prepopulate the map with module names.
    for (JSModule m : modules) {
        wrappers.put(m.getName(), """");
    }
    for (String spec : specs) {
        // Format is ""<name>:<wrapper>"".
        int pos = spec.indexOf(':');
        if (pos == -1) {
            throw new FlagUsageException(""Expected module wrapper to have "" + ""<name>:<wrapper> format: "" + spec);
        }
        // Parse module name.
        String name = spec.substring(0, pos);
        if (!wrappers.containsKey(name)) {
            throw new FlagUsageException(""Unknown module: '"" + name + ""'"");
        }
        String wrapper = spec.substring(pos + 1);
        if (!wrapper.contains(""%s"")) {
            throw new FlagUsageException(""No %s placeholder in module wrapper: '"" + wrapper + ""'"");
        }
        wrappers.put(name, wrapper);
    }
    return wrappers;
}","public void test1717() throws Throwable {
    List<String> list0 = PhaseOptimizer.OPTIMAL_ORDER;
    JSModule[] jSModuleArray0 = new JSModule[0];
    try {
        AbstractCommandLineRunner.parseModuleWrappers(list0, jSModuleArray0);
        fail(""Expecting exception: Exception"");
    } catch (Exception e) {
        //
        // Expected module wrapper to have <name>:<wrapper> format: removeUnreachableCode
        //
        verifyException(""com.google.javascript.jscomp.AbstractCommandLineRunner"", e);
    }
}","/**
 * Parses module wrapper specifications.
 *
 * @param specs A list of module wrapper specifications, not null. The spec
 *        format is: <code>name:wrapper</code>. Wrappers.
 * @param modules The JS modules whose wrappers are specified
 * @return A map from module name to module wrapper. Modules with no wrapper
 *         will have the empty string as their value in this map.
 */"
"static void writeOutput(Appendable out, Compiler compiler, String code, String wrapper, String codePlaceholder) throws IOException {
    int pos = wrapper.indexOf(codePlaceholder);
    if (pos != -1) {
        String prefix = """";
        if (pos > 0) {
            prefix = wrapper.substring(0, pos);
            out.append(prefix);
        }
        out.append(code);
        int suffixStart = pos + codePlaceholder.length();
        if (suffixStart != wrapper.length()) {
            // Something after placeholder?
            out.append(wrapper.substring(suffixStart));
        }
        // Make sure we always end output with a line feed.
        out.append('\n');
        // If we have a source map, adjust its offsets to match
        // the code WITHIN the wrapper.
        if (compiler != null && compiler.getSourceMap() != null) {
            compiler.getSourceMap().setWrapperPrefix(prefix);
        }
    } else {
        out.append(code);
        out.append('\n');
    }
}","public void test1818() throws Throwable {
    PipedWriter pipedWriter0 = new PipedWriter();
    Compiler compiler0 = new Compiler();
    try {
        AbstractCommandLineRunner.writeOutput(pipedWriter0, compiler0, ""/dev/null"", ""N"", ""/dev/null"");
        fail(""Expecting exception: IOException"");
    } catch (IOException e) {
        //
        // Pipe not connected
        //
        verifyException(""java.io.PipedWriter"", e);
    }
}","/**
 * Writes code to an output stream, optionally wrapping it in an arbitrary
 * wrapper that contains a placeholder where the code should be inserted.
 */"
"int processResults(Result result, JSModule[] modules, B options) throws FlagUsageException, IOException {
    if (config.computePhaseOrdering) {
        return 0;
    }
    if (config.printPassGraph) {
        if (compiler.getRoot() == null) {
            return 1;
        } else {
            out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));
            out.append('\n');
            return 0;
        }
    }
    if (config.printAst) {
        if (compiler.getRoot() == null) {
            return 1;
        } else {
            ControlFlowGraph<Node> cfg = compiler.computeCFG();
            DotFormatter.appendDot(compiler.getRoot(), cfg, out);
            out.append('\n');
            return 0;
        }
    }
    if (config.printTree) {
        if (compiler.getRoot() == null) {
            out.append(""Code contains errors; no tree was generated.\n"");
            return 1;
        } else {
            compiler.getRoot().appendStringTree(out);
            out.append(""\n"");
            return 0;
        }
    }
    if (result.success) {
        if (modules == null) {
            writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, config.outputWrapperMarker);
            // Output the source map if requested.
            outputSourceMap(options);
        } else {
            String moduleFilePrefix = config.moduleOutputPathPrefix;
            maybeCreateDirsForPath(moduleFilePrefix);
            Map<String, String> moduleWrappers = parseModuleWrappers(config.moduleWrapper, modules);
            // If the source map path is in fact a pattern for each
            // module, create a stream per-module. Otherwise, create
            // a single source map.
            Writer mapOut = null;
            if (!shouldGenerateMapPerModule(options)) {
                mapOut = toWriter(expandSourceMapPath(options, null));
            }
            for (JSModule m : modules) {
                if (shouldGenerateMapPerModule(options)) {
                    mapOut = toWriter(expandSourceMapPath(options, m));
                }
                Writer writer = toWriter(moduleFilePrefix + m.getName() + "".js"");
                if (options.sourceMapOutputPath != null) {
                    compiler.getSourceMap().reset();
                }
                writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), ""%s"");
                if (options.sourceMapOutputPath != null) {
                    compiler.getSourceMap().appendTo(mapOut, m.getName());
                }
                writer.close();
                if (shouldGenerateMapPerModule(options) && mapOut != null) {
                    mapOut.close();
                    mapOut = null;
                }
            }
            if (mapOut != null) {
                mapOut.close();
            }
        }
        // Output the externs if required.
        if (options.externExportsPath != null) {
            Writer eeOut = openExternExportsStream(options, options.jsOutputFile);
            eeOut.append(result.externExport);
            eeOut.close();
        }
        // Output the variable and property name maps if requested.
        outputNameMaps(options);
        // Output the manifest if requested.
        outputManifest();
    }
    // return 0 if no errors, the error count otherwise
    return Math.min(result.errors.length, 0x7f);
}","public void test2122() throws Throwable {
    String[] stringArray0 = new String[0];
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0);
    Logger logger0 = Logger.getLogger("""");
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    JSSourceFile jSSourceFile0 = JSSourceFile.fromFile("""");
    CompilerOptions compilerOptions0 = new CompilerOptions();
    Result result0 = compiler0.compile(jSSourceFile0, jSSourceFile0, compilerOptions0);
    JSModule[] jSModuleArray0 = new JSModule[3];
    int int0 = commandLineRunner0.processResults(result0, jSModuleArray0, compilerOptions0);
    assertEquals(1, int0);
}","/**
 * Processes the results of the compile job, and returns an error code.
 */"
"int processResults(Result result, JSModule[] modules, B options) throws FlagUsageException, IOException {
    if (config.computePhaseOrdering) {
        return 0;
    }
    if (config.printPassGraph) {
        if (compiler.getRoot() == null) {
            return 1;
        } else {
            out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));
            out.append('\n');
            return 0;
        }
    }
    if (config.printAst) {
        if (compiler.getRoot() == null) {
            return 1;
        } else {
            ControlFlowGraph<Node> cfg = compiler.computeCFG();
            DotFormatter.appendDot(compiler.getRoot(), cfg, out);
            out.append('\n');
            return 0;
        }
    }
    if (config.printTree) {
        if (compiler.getRoot() == null) {
            out.append(""Code contains errors; no tree was generated.\n"");
            return 1;
        } else {
            compiler.getRoot().appendStringTree(out);
            out.append(""\n"");
            return 0;
        }
    }
    if (result.success) {
        if (modules == null) {
            writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, config.outputWrapperMarker);
            // Output the source map if requested.
            outputSourceMap(options);
        } else {
            String moduleFilePrefix = config.moduleOutputPathPrefix;
            maybeCreateDirsForPath(moduleFilePrefix);
            Map<String, String> moduleWrappers = parseModuleWrappers(config.moduleWrapper, modules);
            // If the source map path is in fact a pattern for each
            // module, create a stream per-module. Otherwise, create
            // a single source map.
            Writer mapOut = null;
            if (!shouldGenerateMapPerModule(options)) {
                mapOut = toWriter(expandSourceMapPath(options, null));
            }
            for (JSModule m : modules) {
                if (shouldGenerateMapPerModule(options)) {
                    mapOut = toWriter(expandSourceMapPath(options, m));
                }
                Writer writer = toWriter(moduleFilePrefix + m.getName() + "".js"");
                if (options.sourceMapOutputPath != null) {
                    compiler.getSourceMap().reset();
                }
                writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), ""%s"");
                if (options.sourceMapOutputPath != null) {
                    compiler.getSourceMap().appendTo(mapOut, m.getName());
                }
                writer.close();
                if (shouldGenerateMapPerModule(options) && mapOut != null) {
                    mapOut.close();
                    mapOut = null;
                }
            }
            if (mapOut != null) {
                mapOut.close();
            }
        }
        // Output the externs if required.
        if (options.externExportsPath != null) {
            Writer eeOut = openExternExportsStream(options, options.jsOutputFile);
            eeOut.append(result.externExport);
            eeOut.close();
        }
        // Output the variable and property name maps if requested.
        outputNameMaps(options);
        // Output the manifest if requested.
        outputManifest();
    }
    // return 0 if no errors, the error count otherwise
    return Math.min(result.errors.length, 0x7f);
}","public void test2223() throws Throwable {
    String[] stringArray0 = new String[0];
    Logger logger0 = Logger.getAnonymousLogger();
    LoggerErrorManager loggerErrorManager0 = new LoggerErrorManager(logger0);
    Compiler compiler0 = new Compiler(loggerErrorManager0);
    CompilerOptions compilerOptions0 = new CompilerOptions();
    Result result0 = compiler0.getResult();
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0);
    // Undeclared exception!
    try {
        commandLineRunner0.processResults(result0, (JSModule[]) null, compilerOptions0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.AbstractCommandLineRunner"", e);
    }
}","/**
 * Processes the results of the compile job, and returns an error code.
 */"
"@VisibleForTesting
String expandManifest(JSModule forModule) {
    if (Strings.isEmpty(config.outputManifest)) {
        return null;
    }
    return expandCommandLinePath(config.outputManifest, forModule);
}","public void test2324() throws Throwable {
    String string0 = ""@?Rci3\\uD;yo#tLR's"";
    JSModule jSModule0 = new JSModule(string0);
    String[] stringArray0 = new String[6];
    stringArray0[0] = string0;
    stringArray0[1] = ""required \""{0\"" namesace not provided yet"";
    stringArray0[2] = ""required \""{0\"" namesace not provided yet"";
    stringArray0[3] = string0;
    stringArray0[4] = ""required \""{0\"" namesace not provided yet"";
    stringArray0[5] = ""required \""{0\"" namesace not provided yet"";
    CommandLineRunner commandLineRunner0 = new CommandLineRunner(stringArray0);
    String string1 = commandLineRunner0.expandManifest(jSModule0);
    assertNull(string1);
}","/**
 * Expansion function for the manifest.
 */"
"@VisibleForTesting
static void createDefineReplacements(List<String> definitions, CompilerOptions options) {
    // Parse the definitions
    for (String override : definitions) {
        String[] assignment = override.split(""="", 2);
        String defName = assignment[0];
        if (defName.length() > 0) {
            if (assignment.length == 1) {
                options.setDefineToBooleanLiteral(defName, true);
                continue;
            } else {
                String defValue = assignment[1];
                if (defValue.equals(""true"")) {
                    options.setDefineToBooleanLiteral(defName, true);
                    continue;
                } else if (defValue.equals(""false"")) {
                    options.setDefineToBooleanLiteral(defName, false);
                    continue;
                } else if (defValue.length() > 1 && ((defValue.charAt(0) == '\'' && defValue.charAt(defValue.length() - 1) == '\'') || (defValue.charAt(0) == '\""' && defValue.charAt(defValue.length() - 1) == '\""'))) {
                    // If the value starts and ends with a single quote,
                    // we assume that it's a string.
                    String maybeStringVal = defValue.substring(1, defValue.length() - 1);
                    if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) {
                        options.setDefineToStringLiteral(defName, maybeStringVal);
                        continue;
                    }
                } else {
                    try {
                        options.setDefineToDoubleLiteral(defName, Double.parseDouble(defValue));
                        continue;
                    } catch (NumberFormatException e) {
                        // do nothing, it will be caught at the end
                    }
                }
            }
        }
        throw new RuntimeException(""--define flag syntax invalid: "" + override);
    }
}","public void test2425() throws Throwable {
    List<String> list0 = ResourceBundle.Control.FORMAT_PROPERTIES;
    // Undeclared exception!
    try {
        AbstractCommandLineRunner.createDefineReplacements(list0, (CompilerOptions) null);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.AbstractCommandLineRunner"", e);
    }
}","/**
 * Create a map of constant names to constant values from a textual
 * description of the map.
 *
 * @param definitions A list of overriding definitions for defines in
 *     the form <name>[=<val>], where <val> is a number, boolean, or
 *     single-quoted string without single quotes.
 */"
