focal_method,test_prefix,docstring
"public void setRemoveAbstractMethods(boolean remove) {
    this.removeAbstractMethods = remove;
}","public void test000() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setRemoveAbstractMethods(true);
    assertFalse(compilerOptions0.checkSuspiciousCode);
}",""
"WarningsGuard getWarningsGuard() {
    return warningsGuard;
}","public void test0110() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.getWarningsGuard();
    assertFalse(compilerOptions0.strictMessageReplacement);
}",""
"public void setNameAnonymousFunctionsOnly(boolean value) {
    this.nameAnonymousFunctionsOnly = value;
}","public void test0220() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setNameAnonymousFunctionsOnly(false);
    assertFalse(compilerOptions0.checkSuspiciousCode);
}","/**
 * If true, name anonymous functions only. All other passes will be skipped.
 */"
"public void setReplaceStringsConfiguration(String placeholderToken, List<String> functionDescriptors) {
    this.replaceStringsPlaceholderToken = placeholderToken;
    this.replaceStringsFunctionDescriptions = Lists.newArrayList(functionDescriptors);
}","public void test0330() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    List<String> list0 = ResourceBundle.Control.FORMAT_DEFAULT;
    compilerOptions0.setReplaceStringsConfiguration(""com.google.common.base.CharMatcher$10"", list0);
    assertFalse(compilerOptions0.checkSymbols);
}","/**
 * Sets the functions whose debug strings to replace.
 */"
"public void setSummaryDetailLevel(int summaryDetailLevel) {
    this.summaryDetailLevel = summaryDetailLevel;
}","public void test0440() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setSummaryDetailLevel(45);
    assertFalse(compilerOptions0.checkTypes);
}","/**
 * Controls how detailed the compilation summary is. Values:
 *  0 (never print summary), 1 (print summary only if there are
 * errors or warnings), 2 (print summary if type checking is on,
 * see --check_types), 3 (always print summary). The default level
 * is 1
 */"
"public boolean shouldColorizeErrorOutput() {
    return colorizeErrorOutput;
}","public void test0550() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setColorizeErrorOutput(true);
    assertTrue(compilerOptions0.shouldColorizeErrorOutput());
}",""
"/**
 * Whether to include ""undefined"" in the default types.
 *   For example:
 *     ""{Object}"" is normally ""Object|null"" becomes ""Object|null|undefined""
 *     ""{?string}"" is normally ""string|null"" becomes ""string|null|undefined""
 * In either case ""!"" annotated types excluded both null and undefined.
 */
public void setLooseTypes(boolean looseTypes) {
    this.looseTypes = looseTypes;
}","public void test0651() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setLooseTypes(true);
    assertFalse(compilerOptions0.strictMessageReplacement);
}","/**
 * Sets the output charset by name.
 */"
"public void setProcessObjectPropertyString(boolean process) {
    processObjectPropertyString = process;
}","public void test0761() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setProcessObjectPropertyString(false);
    assertFalse(compilerOptions0.strictMessageReplacement);
}","/**
 * If true, process goog.testing.ObjectPropertyString instances.
 */"
"public boolean isExternExportsEnabled() {
    return externExports;
}","public void test0871() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    boolean boolean0 = compilerOptions0.isExternExportsEnabled();
    assertFalse(compilerOptions0.checkUnusedPropertiesEarly);
}",""
"public void setChainCalls(boolean value) {
    this.chainCalls = value;
}","public void test0982() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setChainCalls(true);
    assertFalse(compilerOptions0.tightenTypes);
}","/**
 * If true, chain calls to functions that return this.
 */"
"public boolean isExternExportsEnabled() {
    return externExports;
}","public void test1092() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.enableExternExports(true);
    assertTrue(compilerOptions0.isExternExportsEnabled());
}",""
"public void setRewriteNewDateGoogNow(boolean rewrite) {
    this.rewriteNewDateGoogNow = rewrite;
}","public void test1193() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setRewriteNewDateGoogNow(false);
    assertFalse(compilerOptions0.checkSymbols);
}",""
"public void setCodingConvention(CodingConvention codingConvention) {
    this.codingConvention = codingConvention;
}","public void test12103() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setCodingConvention((CodingConvention) null);
    assertFalse(compilerOptions0.tightenTypes);
}",""
"public Map<String, Node> getDefineReplacements() {
    Map<String, Node> map = Maps.newHashMap();
    for (Map.Entry<String, Object> entry : defineReplacements.entrySet()) {
        String name = entry.getKey();
        Object value = entry.getValue();
        if (value instanceof Boolean) {
            map.put(name, ((Boolean) value).booleanValue() ? new Node(Token.TRUE) : new Node(Token.FALSE));
        } else if (value instanceof Integer) {
            map.put(name, Node.newNumber(((Integer) value).intValue()));
        } else if (value instanceof Double) {
            map.put(name, Node.newNumber(((Double) value).doubleValue()));
        } else {
            Preconditions.checkState(value instanceof String);
            map.put(name, Node.newString((String) value));
        }
    }
    return map;
}","public void test13113() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setDefineToStringLiteral("" f"", ""5g,eCF"");
    Map<String, Node> map0 = compilerOptions0.getDefineReplacements();
    assertFalse(compilerOptions0.checkTypes);
}","/**
 * Returns the map of define replacements.
 */"
"public void setIdGenerators(Set<String> idGenerators) {
    this.idGenerators = Sets.newHashSet(idGenerators);
}","public void test14124() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setIdGenerators(compilerOptions0.stripNameSuffixes);
    assertFalse(compilerOptions0.checkSuspiciousCode);
}","/**
 * Sets the id generators to replace.
 */"
"public void enableRuntimeTypeCheck(String logFunction) {
    this.runtimeTypeCheck = true;
    this.runtimeTypeCheckLogFunction = logFunction;
}","public void test15134() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.enableRuntimeTypeCheck("""");
    assertFalse(compilerOptions0.allowLegacyJsMessages);
}","/**
 * Enable runtime type checking, which adds JS type assertions for debugging.
 *
 * @param logFunction A JS function to be used for logging runtime type
 *     assertion failures.
 */"
"@Override
public Object clone() throws CloneNotSupportedException {
    CompilerOptions clone = (CompilerOptions) super.clone();
    // TODO(bolinfest): Add relevant custom cloning.
    return clone;
}","public void test16144() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    CompilerOptions compilerOptions1 = (CompilerOptions) compilerOptions0.clone();
    assertFalse(compilerOptions1.strictMessageReplacement);
}",""
"public Map<String, Node> getDefineReplacements() {
    Map<String, Node> map = Maps.newHashMap();
    for (Map.Entry<String, Object> entry : defineReplacements.entrySet()) {
        String name = entry.getKey();
        Object value = entry.getValue();
        if (value instanceof Boolean) {
            map.put(name, ((Boolean) value).booleanValue() ? new Node(Token.TRUE) : new Node(Token.FALSE));
        } else if (value instanceof Integer) {
            map.put(name, Node.newNumber(((Integer) value).intValue()));
        } else if (value instanceof Double) {
            map.put(name, Node.newNumber(((Double) value).doubleValue()));
        } else {
            Preconditions.checkState(value instanceof String);
            map.put(name, Node.newString((String) value));
        }
    }
    return map;
}","public void test17155() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setDefineToBooleanLiteral(""// Input %num%"", false);
    Map<String, Node> map0 = compilerOptions0.getDefineReplacements();
    assertFalse(compilerOptions0.allowLegacyJsMessages);
}","/**
 * Returns the map of define replacements.
 */"
"public void skipAllCompilerPasses() {
    skipAllPasses = true;
}","public void test18163() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.skipAllCompilerPasses();
    assertFalse(compilerOptions0.checkControlStructures);
}","/**
 * Skip all possible passes, to make the compiler as fast as possible.
 */"
"public void disableRuntimeTypeCheck() {
    this.runtimeTypeCheck = false;
}","public void test19173() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.disableRuntimeTypeCheck();
    assertFalse(compilerOptions0.checkUnusedPropertiesEarly);
}",""
"public void setCollapsePropertiesOnExternTypes(boolean collapse) {
    collapsePropertiesOnExternTypes = collapse;
}","public void test20183() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setCollapsePropertiesOnExternTypes(false);
    assertFalse(compilerOptions0.strictMessageReplacement);
}","/**
 * If true, flattens multi-level property names on extern types
 * (e.g. String$f = x). This should only be used with the typed version of
 * the externs files.
 */"
"public void setManageClosureDependencies(boolean newVal) {
    manageClosureDependencies = newVal;
}","public void test21193() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setManageClosureDependencies(false);
    assertFalse(compilerOptions0.checkSymbols);
}","/**
 * Sort inputs by their goog.provide/goog.require calls, and prune inputs
 * whose symbols are not required.
 */"
"public boolean shouldColorizeErrorOutput() {
    return colorizeErrorOutput;
}","public void test22203() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    boolean boolean0 = compilerOptions0.shouldColorizeErrorOutput();
    assertFalse(compilerOptions0.checkTypes);
}",""
"public CodingConvention getCodingConvention() {
    return codingConvention;
}","public void test23214() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.getCodingConvention();
    assertFalse(compilerOptions0.checkUnusedPropertiesEarly);
}",""
"public void setRenamingPolicy(VariableRenamingPolicy newVariablePolicy, PropertyRenamingPolicy newPropertyPolicy) {
    this.variableRenaming = newVariablePolicy;
    this.propertyRenaming = newPropertyPolicy;
}","public void test24224() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setRenamingPolicy(compilerOptions0.variableRenaming, compilerOptions0.propertyRenaming);
    assertFalse(compilerOptions0.inferTypesInGlobalScope);
}","/**
 * Sets the variable and property renaming policies for the compiler,
 * in a way that clears warnings about the renaming policy being
 * uninitialized from flags.
 */"
"public void setWarningLevel(DiagnosticGroup type, CheckLevel level) {
    addWarningsGuard(new DiagnosticGroupWarningsGuard(type, level));
}","public void test25234() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    DiagnosticType[] diagnosticTypeArray0 = new DiagnosticType[2];
    DiagnosticType diagnosticType0 = TypeCheck.BIT_OPERATION;
    DiagnosticGroup diagnosticGroup0 = new DiagnosticGroup(diagnosticTypeArray0);
    compilerOptions0.setWarningLevel(diagnosticGroup0, diagnosticType0.level);
    assertFalse(compilerOptions0.strictMessageReplacement);
}","/**
 * Configure the given type of warning to the given level.
 */"
"public Map<String, Node> getDefineReplacements() {
    Map<String, Node> map = Maps.newHashMap();
    for (Map.Entry<String, Object> entry : defineReplacements.entrySet()) {
        String name = entry.getKey();
        Object value = entry.getValue();
        if (value instanceof Boolean) {
            map.put(name, ((Boolean) value).booleanValue() ? new Node(Token.TRUE) : new Node(Token.FALSE));
        } else if (value instanceof Integer) {
            map.put(name, Node.newNumber(((Integer) value).intValue()));
        } else if (value instanceof Double) {
            map.put(name, Node.newNumber(((Double) value).doubleValue()));
        } else {
            Preconditions.checkState(value instanceof String);
            map.put(name, Node.newString((String) value));
        }
    }
    return map;
}","public void test26244() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setDefineToDoubleLiteral("""", 45);
    Map<String, Node> map0 = compilerOptions0.getDefineReplacements();
    assertFalse(compilerOptions0.checkUnusedPropertiesEarly);
}","/**
 * Returns the map of define replacements.
 */"
"public Map<String, Node> getDefineReplacements() {
    Map<String, Node> map = Maps.newHashMap();
    for (Map.Entry<String, Object> entry : defineReplacements.entrySet()) {
        String name = entry.getKey();
        Object value = entry.getValue();
        if (value instanceof Boolean) {
            map.put(name, ((Boolean) value).booleanValue() ? new Node(Token.TRUE) : new Node(Token.FALSE));
        } else if (value instanceof Integer) {
            map.put(name, Node.newNumber(((Integer) value).intValue()));
        } else if (value instanceof Double) {
            map.put(name, Node.newNumber(((Double) value).doubleValue()));
        } else {
            Preconditions.checkState(value instanceof String);
            map.put(name, Node.newString((String) value));
        }
    }
    return map;
}","public void test27255() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setDefineToBooleanLiteral(""DblH#"", true);
    Map<String, Node> map0 = compilerOptions0.getDefineReplacements();
    assertFalse(compilerOptions0.checkTypes);
}","/**
 * Returns the map of define replacements.
 */"
"public Map<String, Node> getDefineReplacements() {
    Map<String, Node> map = Maps.newHashMap();
    for (Map.Entry<String, Object> entry : defineReplacements.entrySet()) {
        String name = entry.getKey();
        Object value = entry.getValue();
        if (value instanceof Boolean) {
            map.put(name, ((Boolean) value).booleanValue() ? new Node(Token.TRUE) : new Node(Token.FALSE));
        } else if (value instanceof Integer) {
            map.put(name, Node.newNumber(((Integer) value).intValue()));
        } else if (value instanceof Double) {
            map.put(name, Node.newNumber(((Double) value).doubleValue()));
        } else {
            Preconditions.checkState(value instanceof String);
            map.put(name, Node.newString((String) value));
        }
    }
    return map;
}","public void test28264() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setDefineToNumberLiteral(""FAST"", 45);
    Map<String, Node> map0 = compilerOptions0.getDefineReplacements();
    assertFalse(compilerOptions0.checkSymbols);
}","/**
 * Returns the map of define replacements.
 */"
"boolean enables(DiagnosticGroup type) {
    return warningsGuard != null && warningsGuard.enables(type);
}","public void test29275() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    DiagnosticType[] diagnosticTypeArray0 = new DiagnosticType[2];
    DiagnosticGroup diagnosticGroup0 = new DiagnosticGroup(diagnosticTypeArray0);
    boolean boolean0 = compilerOptions0.enables(diagnosticGroup0);
    assertFalse(compilerOptions0.allowLegacyJsMessages);
}","/**
 * Whether the warnings guard in this Options object enables the given
 * group of warnings.
 */"
"boolean enables(DiagnosticGroup type) {
    return warningsGuard != null && warningsGuard.enables(type);
}","public void test30286() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    DiagnosticType[] diagnosticTypeArray0 = new DiagnosticType[2];
    DiagnosticGroup diagnosticGroup0 = new DiagnosticGroup(diagnosticTypeArray0);
    ShowByPathWarningsGuard showByPathWarningsGuard0 = new ShowByPathWarningsGuard(""4thij4z(P1nbP}ph"");
    compilerOptions0.addWarningsGuard(showByPathWarningsGuard0);
    boolean boolean0 = compilerOptions0.enables(diagnosticGroup0);
    assertFalse(compilerOptions0.allowLegacyJsMessages);
}","/**
 * Whether the warnings guard in this Options object enables the given
 * group of warnings.
 */"
"boolean enables(DiagnosticGroup type) {
    return warningsGuard != null && warningsGuard.enables(type);
}","public void test31297() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    DiagnosticGroup[] diagnosticGroupArray0 = new DiagnosticGroup[3];
    DiagnosticGroup diagnosticGroup0 = TypeCheck.ALL_DIAGNOSTICS;
    diagnosticGroupArray0[0] = diagnosticGroup0;
    DiagnosticType diagnosticType0 = CreateSyntheticBlocks.UNMATCHED_END_MARKER;
    diagnosticType0.format(diagnosticGroupArray0);
    DiagnosticType[] diagnosticTypeArray0 = new DiagnosticType[5];
    DiagnosticType diagnosticType1 = TypeCheck.INEXISTENT_PROPERTY;
    diagnosticTypeArray0[2] = diagnosticType1;
    DiagnosticGroup diagnosticGroup1 = new DiagnosticGroup(diagnosticTypeArray0);
    DiagnosticGroupWarningsGuard diagnosticGroupWarningsGuard0 = new DiagnosticGroupWarningsGuard(diagnosticGroup0, compilerOptions0.brokenClosureRequiresLevel);
    compilerOptions0.addWarningsGuard(diagnosticGroupWarningsGuard0);
    boolean boolean0 = compilerOptions0.enables(diagnosticGroup0);
    assertTrue(boolean0);
}","/**
 * Whether the warnings guard in this Options object enables the given
 * group of warnings.
 */"
"boolean disables(DiagnosticGroup type) {
    return warningsGuard != null && warningsGuard.disables(type);
}","public void test32298() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    DiagnosticType[] diagnosticTypeArray0 = new DiagnosticType[2];
    DiagnosticGroup diagnosticGroup0 = new DiagnosticGroup(diagnosticTypeArray0);
    boolean boolean0 = compilerOptions0.disables(diagnosticGroup0);
    assertFalse(compilerOptions0.checkUnusedPropertiesEarly);
}","/**
 * Whether the warnings guard in this Options object disables the given
 * group of warnings.
 */"
"boolean disables(DiagnosticGroup type) {
    return warningsGuard != null && warningsGuard.disables(type);
}","public void test33309() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    DiagnosticType diagnosticType0 = ProcessDefines.NON_GLOBAL_DEFINE_INIT_ERROR;
    DiagnosticGroup diagnosticGroup0 = DiagnosticGroup.forType(diagnosticType0);
    String[] stringArray0 = new String[3];
    ShowByPathWarningsGuard showByPathWarningsGuard0 = new ShowByPathWarningsGuard(stringArray0);
    compilerOptions0.addWarningsGuard(showByPathWarningsGuard0);
    boolean boolean0 = compilerOptions0.disables(diagnosticGroup0);
    assertFalse(compilerOptions0.checkSymbols);
}","/**
 * Whether the warnings guard in this Options object disables the given
 * group of warnings.
 */"
"boolean disables(DiagnosticGroup type) {
    return warningsGuard != null && warningsGuard.disables(type);
}","public void test34320() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    DiagnosticType diagnosticType0 = PeepholeFoldConstants.DIVIDE_BY_0_ERROR;
    DiagnosticType[] diagnosticTypeArray0 = new DiagnosticType[1];
    diagnosticTypeArray0[0] = diagnosticType0;
    DiagnosticGroup diagnosticGroup0 = new DiagnosticGroup(diagnosticTypeArray0);
    DiagnosticGroupWarningsGuard diagnosticGroupWarningsGuard0 = new DiagnosticGroupWarningsGuard(diagnosticGroup0, compilerOptions0.checkMissingReturn);
    compilerOptions0.addWarningsGuard(diagnosticGroupWarningsGuard0);
    boolean boolean0 = compilerOptions0.disables(diagnosticGroup0);
    assertFalse(compilerOptions0.checkUnusedPropertiesEarly);
}","/**
 * Whether the warnings guard in this Options object disables the given
 * group of warnings.
 */"
"public void addWarningsGuard(WarningsGuard guard) {
    if (warningsGuard == null) {
        warningsGuard = new ComposeWarningsGuard(guard);
    } else {
        warningsGuard.addGuard(guard);
    }
}","public void test35331() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    String[] stringArray0 = new String[0];
    ShowByPathWarningsGuard showByPathWarningsGuard0 = new ShowByPathWarningsGuard(stringArray0);
    compilerOptions0.addWarningsGuard(showByPathWarningsGuard0);
    compilerOptions0.addWarningsGuard(showByPathWarningsGuard0);
    assertFalse(compilerOptions0.allowLegacyJsMessages);
}","/**
 * Add a guard to the set of warnings guards.
 */"
