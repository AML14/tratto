project,bug_num,test_name,test_prefix,except_pred,assert_pred
project,0,test000,"public void test000() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setRemoveAbstractMethods(true);
    assertFalse(compilerOptions0.checkSuspiciousCode);
}",0,
project,0,test0110,"public void test0110() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.getWarningsGuard();
    assertFalse(compilerOptions0.strictMessageReplacement);
}",0,
project,0,test0220,"public void test0220() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setNameAnonymousFunctionsOnly(false);
    assertFalse(compilerOptions0.checkSuspiciousCode);
}",0,
project,0,test0330,"public void test0330() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    List<String> list0 = ResourceBundle.Control.FORMAT_DEFAULT;
    compilerOptions0.setReplaceStringsConfiguration(""com.google.common.base.CharMatcher$10"", list0);
    assertFalse(compilerOptions0.checkSymbols);
}",0,
project,0,test0440,"public void test0440() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setSummaryDetailLevel(45);
    assertFalse(compilerOptions0.checkTypes);
}",0,
project,0,test0550,"public void test0550() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setColorizeErrorOutput(true);
    assertTrue(compilerOptions0.shouldColorizeErrorOutput());
}",0,assertTrue(compilerOptions0.shouldColorizeErrorOutput())
project,0,test0651,"public void test0651() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setLooseTypes(true);
    assertFalse(compilerOptions0.strictMessageReplacement);
}",0,
project,0,test0761,"public void test0761() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setProcessObjectPropertyString(false);
    assertFalse(compilerOptions0.strictMessageReplacement);
}",0,
project,0,test0871,"public void test0871() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    boolean boolean0 = compilerOptions0.isExternExportsEnabled();
    assertFalse(compilerOptions0.checkUnusedPropertiesEarly);
}",0,
project,0,test0982,"public void test0982() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setChainCalls(true);
    assertFalse(compilerOptions0.tightenTypes);
}",0,
project,0,test1092,"public void test1092() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.enableExternExports(true);
    assertTrue(compilerOptions0.isExternExportsEnabled());
}",0,assertTrue(compilerOptions0.isExternExportsEnabled())
project,0,test1193,"public void test1193() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setRewriteNewDateGoogNow(false);
    assertFalse(compilerOptions0.checkSymbols);
}",0,
project,0,test12103,"public void test12103() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setCodingConvention((CodingConvention) null);
    assertFalse(compilerOptions0.tightenTypes);
}",0,
project,0,test13113,"public void test13113() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setDefineToStringLiteral("" f"", ""5g,eCF"");
    Map<String, Node> map0 = compilerOptions0.getDefineReplacements();
    assertFalse(compilerOptions0.checkTypes);
}",0,
project,0,test14124,"public void test14124() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setIdGenerators(compilerOptions0.stripNameSuffixes);
    assertFalse(compilerOptions0.checkSuspiciousCode);
}",0,
project,0,test15134,"public void test15134() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.enableRuntimeTypeCheck("""");
    assertFalse(compilerOptions0.allowLegacyJsMessages);
}",0,
project,0,test16144,"public void test16144() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    CompilerOptions compilerOptions1 = (CompilerOptions) compilerOptions0.clone();
    assertFalse(compilerOptions1.strictMessageReplacement);
}",0,
project,0,test17155,"public void test17155() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setDefineToBooleanLiteral(""// Input %num%"", false);
    Map<String, Node> map0 = compilerOptions0.getDefineReplacements();
    assertFalse(compilerOptions0.allowLegacyJsMessages);
}",0,
project,0,test18163,"public void test18163() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.skipAllCompilerPasses();
    assertFalse(compilerOptions0.checkControlStructures);
}",0,
project,0,test19173,"public void test19173() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.disableRuntimeTypeCheck();
    assertFalse(compilerOptions0.checkUnusedPropertiesEarly);
}",0,
project,0,test20183,"public void test20183() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setCollapsePropertiesOnExternTypes(false);
    assertFalse(compilerOptions0.strictMessageReplacement);
}",0,
project,0,test21193,"public void test21193() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setManageClosureDependencies(false);
    assertFalse(compilerOptions0.checkSymbols);
}",0,
project,0,test22203,"public void test22203() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    boolean boolean0 = compilerOptions0.shouldColorizeErrorOutput();
    assertFalse(compilerOptions0.checkTypes);
}",0,
project,0,test23214,"public void test23214() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.getCodingConvention();
    assertFalse(compilerOptions0.checkUnusedPropertiesEarly);
}",0,
project,0,test24224,"public void test24224() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setRenamingPolicy(compilerOptions0.variableRenaming, compilerOptions0.propertyRenaming);
    assertFalse(compilerOptions0.inferTypesInGlobalScope);
}",0,
project,0,test25234,"public void test25234() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    DiagnosticType[] diagnosticTypeArray0 = new DiagnosticType[2];
    DiagnosticType diagnosticType0 = TypeCheck.BIT_OPERATION;
    DiagnosticGroup diagnosticGroup0 = new DiagnosticGroup(diagnosticTypeArray0);
    compilerOptions0.setWarningLevel(diagnosticGroup0, diagnosticType0.level);
    assertFalse(compilerOptions0.strictMessageReplacement);
}",0,
project,0,test26244,"public void test26244() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setDefineToDoubleLiteral("""", 45);
    Map<String, Node> map0 = compilerOptions0.getDefineReplacements();
    assertFalse(compilerOptions0.checkUnusedPropertiesEarly);
}",0,
project,0,test27255,"public void test27255() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setDefineToBooleanLiteral(""DblH#"", true);
    Map<String, Node> map0 = compilerOptions0.getDefineReplacements();
    assertFalse(compilerOptions0.checkTypes);
}",0,
project,0,test28264,"public void test28264() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    compilerOptions0.setDefineToNumberLiteral(""FAST"", 45);
    Map<String, Node> map0 = compilerOptions0.getDefineReplacements();
    assertFalse(compilerOptions0.checkSymbols);
}",0,
project,0,test29275,"public void test29275() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    DiagnosticType[] diagnosticTypeArray0 = new DiagnosticType[2];
    DiagnosticGroup diagnosticGroup0 = new DiagnosticGroup(diagnosticTypeArray0);
    boolean boolean0 = compilerOptions0.enables(diagnosticGroup0);
    assertFalse(compilerOptions0.allowLegacyJsMessages);
}",0,
project,0,test30286,"public void test30286() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    DiagnosticType[] diagnosticTypeArray0 = new DiagnosticType[2];
    DiagnosticGroup diagnosticGroup0 = new DiagnosticGroup(diagnosticTypeArray0);
    ShowByPathWarningsGuard showByPathWarningsGuard0 = new ShowByPathWarningsGuard(""4thij4z(P1nbP}ph"");
    compilerOptions0.addWarningsGuard(showByPathWarningsGuard0);
    boolean boolean0 = compilerOptions0.enables(diagnosticGroup0);
    assertFalse(compilerOptions0.allowLegacyJsMessages);
}",0,
project,0,test31297,"public void test31297() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    DiagnosticGroup[] diagnosticGroupArray0 = new DiagnosticGroup[3];
    DiagnosticGroup diagnosticGroup0 = TypeCheck.ALL_DIAGNOSTICS;
    diagnosticGroupArray0[0] = diagnosticGroup0;
    DiagnosticType diagnosticType0 = CreateSyntheticBlocks.UNMATCHED_END_MARKER;
    diagnosticType0.format(diagnosticGroupArray0);
    DiagnosticType[] diagnosticTypeArray0 = new DiagnosticType[5];
    DiagnosticType diagnosticType1 = TypeCheck.INEXISTENT_PROPERTY;
    diagnosticTypeArray0[2] = diagnosticType1;
    DiagnosticGroup diagnosticGroup1 = new DiagnosticGroup(diagnosticTypeArray0);
    DiagnosticGroupWarningsGuard diagnosticGroupWarningsGuard0 = new DiagnosticGroupWarningsGuard(diagnosticGroup0, compilerOptions0.brokenClosureRequiresLevel);
    compilerOptions0.addWarningsGuard(diagnosticGroupWarningsGuard0);
    boolean boolean0 = compilerOptions0.enables(diagnosticGroup0);
    assertTrue(boolean0);
}",0,assertTrue(boolean0)
project,0,test32298,"public void test32298() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    DiagnosticType[] diagnosticTypeArray0 = new DiagnosticType[2];
    DiagnosticGroup diagnosticGroup0 = new DiagnosticGroup(diagnosticTypeArray0);
    boolean boolean0 = compilerOptions0.disables(diagnosticGroup0);
    assertFalse(compilerOptions0.checkUnusedPropertiesEarly);
}",0,
project,0,test33309,"public void test33309() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    DiagnosticType diagnosticType0 = ProcessDefines.NON_GLOBAL_DEFINE_INIT_ERROR;
    DiagnosticGroup diagnosticGroup0 = DiagnosticGroup.forType(diagnosticType0);
    String[] stringArray0 = new String[3];
    ShowByPathWarningsGuard showByPathWarningsGuard0 = new ShowByPathWarningsGuard(stringArray0);
    compilerOptions0.addWarningsGuard(showByPathWarningsGuard0);
    boolean boolean0 = compilerOptions0.disables(diagnosticGroup0);
    assertFalse(compilerOptions0.checkSymbols);
}",0,
project,0,test34320,"public void test34320() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    DiagnosticType diagnosticType0 = PeepholeFoldConstants.DIVIDE_BY_0_ERROR;
    DiagnosticType[] diagnosticTypeArray0 = new DiagnosticType[1];
    diagnosticTypeArray0[0] = diagnosticType0;
    DiagnosticGroup diagnosticGroup0 = new DiagnosticGroup(diagnosticTypeArray0);
    DiagnosticGroupWarningsGuard diagnosticGroupWarningsGuard0 = new DiagnosticGroupWarningsGuard(diagnosticGroup0, compilerOptions0.checkMissingReturn);
    compilerOptions0.addWarningsGuard(diagnosticGroupWarningsGuard0);
    boolean boolean0 = compilerOptions0.disables(diagnosticGroup0);
    assertFalse(compilerOptions0.checkUnusedPropertiesEarly);
}",0,
project,0,test35331,"public void test35331() throws Throwable {
    CompilerOptions compilerOptions0 = new CompilerOptions();
    String[] stringArray0 = new String[0];
    ShowByPathWarningsGuard showByPathWarningsGuard0 = new ShowByPathWarningsGuard(stringArray0);
    compilerOptions0.addWarningsGuard(showByPathWarningsGuard0);
    compilerOptions0.addWarningsGuard(showByPathWarningsGuard0);
    assertFalse(compilerOptions0.allowLegacyJsMessages);
}",0,
