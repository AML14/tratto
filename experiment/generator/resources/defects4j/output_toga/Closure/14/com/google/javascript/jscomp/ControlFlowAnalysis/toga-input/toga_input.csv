focal_method,test_prefix,docstring
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities, edgeAnnotations);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.isFunction()) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test000() throws Throwable {
    Node node0 = Node.newString("""");
    Node node1 = new Node(119, node0, node0);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false, false);
    controlFlowAnalysis0.process(node0, node1);
    assertEquals(4095, Node.MAX_COLUMN_NUMBER);
}",""
"public boolean isQuotedString() {
    return false;
}","public void test011() throws Throwable {
    Node node0 = Node.newString("""");
    Node node1 = new Node(77, node0, node0);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false, false);
    controlFlowAnalysis0.process(node0, node1);
    assertFalse(node0.isQuotedString());
}","/**
 * This should only be called for STRING nodes children of OBJECTLIT.
 */"
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities, edgeAnnotations);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.isFunction()) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test022() throws Throwable {
    Node node0 = new Node(77);
    Node node1 = new Node(49, node0, node0, node0, node0);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis((AbstractCompiler) null, false, false);
    // Undeclared exception!
    try {
        controlFlowAnalysis0.process(node0, node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.NodeTraversal"", e);
    }
}",""
"public boolean isGetterDef() {
    return this.getType() == Token.GETTER_DEF;
}","public void test033() throws Throwable {
    Node node0 = new Node(65136, (-95), (-95));
    Node node1 = new Node(112, node0, node0);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis((AbstractCompiler) null, true, true);
    controlFlowAnalysis0.process(node1, node1);
    assertFalse(node1.isGetterDef());
}",""
"ControlFlowGraph<Node> getCfg() {
    return cfg;
}","public void test044() throws Throwable {
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis((AbstractCompiler) null, true, true);
    ControlFlowGraph<Node> controlFlowGraph0 = controlFlowAnalysis0.getCfg();
    assertNull(controlFlowGraph0);
}",""
"public boolean isWhile() {
    return this.getType() == Token.WHILE;
}","public void test055() throws Throwable {
    Node node0 = Node.newString(""JSC_PRIVATE_OVERRIDE"", 114, 114);
    Node node1 = new Node(114, node0, node0);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, true, true);
    controlFlowAnalysis0.process(node0, node1);
    assertFalse(node1.isWhile());
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities, edgeAnnotations);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.isFunction()) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test066() throws Throwable {
    Node node0 = Node.newString(105, "" `<t0R!Q?29!"", 105, 105);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, true, true);
    // Undeclared exception!
    try {
        controlFlowAnalysis0.process(node0, node0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // null
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities, edgeAnnotations);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.isFunction()) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test077() throws Throwable {
    Node node0 = Node.newString(105, "" `<t0R!Q?29!"", 105, 105);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false, false);
    // Undeclared exception!
    try {
        controlFlowAnalysis0.process(node0, node0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // null
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"public boolean isBlock() {
    return this.getType() == Token.BLOCK;
}","public void test088() throws Throwable {
    Node node0 = new Node(160);
    Node node1 = new Node(4, node0, node0);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false, false);
    controlFlowAnalysis0.process(node1, node1);
    assertFalse(node1.isBlock());
}",""
"public boolean isFromExterns() {
    StaticSourceFile file = getStaticSourceFile();
    return file == null ? false : file.isExtern();
}","public void test099() throws Throwable {
    Node node0 = new Node((-1803), (-1803), (-1803));
    Node node1 = new Node(49, node0, node0);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false, false);
    controlFlowAnalysis0.process(node0, node1);
    assertFalse(node0.isFromExterns());
}",""
"@Override
public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) {
    astPosition.put(n, astPositionCounter++);
    switch(n.getType()) {
        case Token.FUNCTION:
            if (shouldTraverseFunctions || n == cfg.getEntry().getValue()) {
                exceptionHandler.push(n);
                return true;
            }
            return false;
        case Token.TRY:
            exceptionHandler.push(n);
            return true;
    }
    /*
     * We are going to stop the traversal depending on what the node's parent
     * is.
     *
     * We are only interested in adding edges between nodes that change control
     * flow. The most obvious ones are loops and IF-ELSE's. A statement
     * transfers control to its next sibling.
     *
     * In case of an expression tree, there is no control flow within the tree
     * even when there are short circuited operators and conditionals. When we
     * are doing data flow analysis, we will simply synthesize lattices up the
     * expression tree by finding the meet at each expression node.
     *
     * For example: within a Token.SWITCH, the expression in question does not
     * change the control flow and need not to be considered.
     */
    if (parent != null) {
        switch(parent.getType()) {
            case Token.FOR:
                // Only traverse the body of the for loop.
                return n == parent.getLastChild();
            // Skip the conditions.
            case Token.IF:
            case Token.WHILE:
            case Token.WITH:
                return n != parent.getFirstChild();
            case Token.DO:
                return n != parent.getFirstChild().getNext();
            // Only traverse the body of the cases
            case Token.SWITCH:
            case Token.CASE:
            case Token.CATCH:
            case Token.LABEL:
                return n != parent.getFirstChild();
            case Token.FUNCTION:
                return n == parent.getFirstChild().getNext().getNext();
            case Token.CONTINUE:
            case Token.BREAK:
            case Token.EXPR_RESULT:
            case Token.VAR:
            case Token.RETURN:
            case Token.THROW:
                return false;
            case Token.TRY:
                /* Just before we are about to visit the second child of the TRY node,
           * we know that we will be visiting either the CATCH or the FINALLY.
           * In other words, we know that the post order traversal of the TRY
           * block has been finished, no more exceptions can be caught by the
           * handler at this TRY block and should be taken out of the stack.
           */
                if (n == parent.getFirstChild().getNext()) {
                    Preconditions.checkState(exceptionHandler.peek() == parent);
                    exceptionHandler.pop();
                }
        }
    }
    return true;
}","public void test1010() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((double) 131, 131, 131);
    Node node1 = new Node(105, node0, 29, 45);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false, false);
    controlFlowAnalysis0.process(node1, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, controlFlowAnalysis0);
    // Undeclared exception!
    try {
        controlFlowAnalysis0.shouldTraverse(nodeTraversal0, node0, node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.ControlFlowAnalysis"", e);
    }
}",""
"@Override
public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) {
    astPosition.put(n, astPositionCounter++);
    switch(n.getType()) {
        case Token.FUNCTION:
            if (shouldTraverseFunctions || n == cfg.getEntry().getValue()) {
                exceptionHandler.push(n);
                return true;
            }
            return false;
        case Token.TRY:
            exceptionHandler.push(n);
            return true;
    }
    /*
     * We are going to stop the traversal depending on what the node's parent
     * is.
     *
     * We are only interested in adding edges between nodes that change control
     * flow. The most obvious ones are loops and IF-ELSE's. A statement
     * transfers control to its next sibling.
     *
     * In case of an expression tree, there is no control flow within the tree
     * even when there are short circuited operators and conditionals. When we
     * are doing data flow analysis, we will simply synthesize lattices up the
     * expression tree by finding the meet at each expression node.
     *
     * For example: within a Token.SWITCH, the expression in question does not
     * change the control flow and need not to be considered.
     */
    if (parent != null) {
        switch(parent.getType()) {
            case Token.FOR:
                // Only traverse the body of the for loop.
                return n == parent.getLastChild();
            // Skip the conditions.
            case Token.IF:
            case Token.WHILE:
            case Token.WITH:
                return n != parent.getFirstChild();
            case Token.DO:
                return n != parent.getFirstChild().getNext();
            // Only traverse the body of the cases
            case Token.SWITCH:
            case Token.CASE:
            case Token.CATCH:
            case Token.LABEL:
                return n != parent.getFirstChild();
            case Token.FUNCTION:
                return n == parent.getFirstChild().getNext().getNext();
            case Token.CONTINUE:
            case Token.BREAK:
            case Token.EXPR_RESULT:
            case Token.VAR:
            case Token.RETURN:
            case Token.THROW:
                return false;
            case Token.TRY:
                /* Just before we are about to visit the second child of the TRY node,
           * we know that we will be visiting either the CATCH or the FINALLY.
           * In other words, we know that the post order traversal of the TRY
           * block has been finished, no more exceptions can be caught by the
           * handler at this TRY block and should be taken out of the stack.
           */
                if (n == parent.getFirstChild().getNext()) {
                    Preconditions.checkState(exceptionHandler.peek() == parent);
                    exceptionHandler.pop();
                }
        }
    }
    return true;
}","public void test1111() throws Throwable {
    Node node0 = new Node(4);
    Compiler compiler0 = new Compiler();
    Node node1 = new Node(110, node0, 2, 35);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, true, true);
    controlFlowAnalysis0.process(node0, node1);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, controlFlowAnalysis0);
    boolean boolean0 = controlFlowAnalysis0.shouldTraverse(nodeTraversal0, node1, node1);
    assertTrue(boolean0);
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities, edgeAnnotations);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.isFunction()) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test1212() throws Throwable {
    Node node0 = new Node(4);
    Node node1 = new Node(113, node0, 4095, 36);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis((AbstractCompiler) null, true, true);
    // Undeclared exception!
    try {
        controlFlowAnalysis0.process(node1, node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.NodeTraversal"", e);
    }
}",""
"@Override
public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) {
    astPosition.put(n, astPositionCounter++);
    switch(n.getType()) {
        case Token.FUNCTION:
            if (shouldTraverseFunctions || n == cfg.getEntry().getValue()) {
                exceptionHandler.push(n);
                return true;
            }
            return false;
        case Token.TRY:
            exceptionHandler.push(n);
            return true;
    }
    /*
     * We are going to stop the traversal depending on what the node's parent
     * is.
     *
     * We are only interested in adding edges between nodes that change control
     * flow. The most obvious ones are loops and IF-ELSE's. A statement
     * transfers control to its next sibling.
     *
     * In case of an expression tree, there is no control flow within the tree
     * even when there are short circuited operators and conditionals. When we
     * are doing data flow analysis, we will simply synthesize lattices up the
     * expression tree by finding the meet at each expression node.
     *
     * For example: within a Token.SWITCH, the expression in question does not
     * change the control flow and need not to be considered.
     */
    if (parent != null) {
        switch(parent.getType()) {
            case Token.FOR:
                // Only traverse the body of the for loop.
                return n == parent.getLastChild();
            // Skip the conditions.
            case Token.IF:
            case Token.WHILE:
            case Token.WITH:
                return n != parent.getFirstChild();
            case Token.DO:
                return n != parent.getFirstChild().getNext();
            // Only traverse the body of the cases
            case Token.SWITCH:
            case Token.CASE:
            case Token.CATCH:
            case Token.LABEL:
                return n != parent.getFirstChild();
            case Token.FUNCTION:
                return n == parent.getFirstChild().getNext().getNext();
            case Token.CONTINUE:
            case Token.BREAK:
            case Token.EXPR_RESULT:
            case Token.VAR:
            case Token.RETURN:
            case Token.THROW:
                return false;
            case Token.TRY:
                /* Just before we are about to visit the second child of the TRY node,
           * we know that we will be visiting either the CATCH or the FINALLY.
           * In other words, we know that the post order traversal of the TRY
           * block has been finished, no more exceptions can be caught by the
           * handler at this TRY block and should be taken out of the stack.
           */
                if (n == parent.getFirstChild().getNext()) {
                    Preconditions.checkState(exceptionHandler.peek() == parent);
                    exceptionHandler.pop();
                }
        }
    }
    return true;
}","public void test1313() throws Throwable {
    Node node0 = new Node((-21), (-21), (-21));
    Node node1 = new Node(115, node0, 4095, 36);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false, false);
    controlFlowAnalysis0.process(node0, node0);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, controlFlowAnalysis0);
    boolean boolean0 = controlFlowAnalysis0.shouldTraverse(nodeTraversal0, node1, node1);
    assertFalse(boolean0);
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities, edgeAnnotations);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.isFunction()) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test1414() throws Throwable {
    Node node0 = new Node(4);
    Node node1 = new Node(116, node0, 4095, 36);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis((AbstractCompiler) null, true, true);
    // Undeclared exception!
    try {
        controlFlowAnalysis0.process(node0, node1);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.NodeTraversal"", e);
    }
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities, edgeAnnotations);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.isFunction()) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test1515() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""ey~oS&n!~T+K"");
    Node node1 = new Node(117, node0, node0);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, true, true);
    // Undeclared exception!
    try {
        controlFlowAnalysis0.process(node0, node1);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public boolean isIf() {
    return this.getType() == Token.IF;
}","public void test1616() throws Throwable {
    Node node0 = new Node((-1216), (-1216), (-1216));
    Node node1 = new Node(118, node0, node0);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis((AbstractCompiler) null, false, false);
    controlFlowAnalysis0.process(node1, node1);
    assertFalse(node1.isIf());
}",""
"public boolean isIn() {
    return this.getType() == Token.IN;
}","public void test1717() throws Throwable {
    Node node0 = new Node(981);
    Node node1 = new Node(120, node0, 2, 35);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, true, true);
    controlFlowAnalysis0.process(node1, node1);
    assertFalse(node1.isIn());
}",""
"public boolean isAnd() {
    return this.getType() == Token.AND;
}","public void test1818() throws Throwable {
    Node node0 = Node.newString(""JSC_PRIVATE_OVERRIDE"", 126, 126);
    Node node1 = new Node(126, node0, node0);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, true, true);
    controlFlowAnalysis0.process(node0, node1);
    assertFalse(node0.isAnd());
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities, edgeAnnotations);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.isFunction()) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test1919() throws Throwable {
    Node node0 = new Node(453);
    Node node1 = new Node(115, node0, 4095, 2);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false, false);
    // Undeclared exception!
    try {
        controlFlowAnalysis0.process(node0, node1);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities, edgeAnnotations);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.isFunction()) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test2020() throws Throwable {
    Node node0 = Node.newString("""");
    Compiler compiler0 = new Compiler();
    Node node1 = compiler0.parseTestCode("""");
    Node node2 = new Node(108, node0, node1);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, true, true);
    controlFlowAnalysis0.process(node1, node2);
    assertEquals(53, Node.INPUT_ID);
}",""
"@Override
public void visit(NodeTraversal t, Node n, Node parent) {
    switch(n.getType()) {
        case Token.IF:
            handleIf(n);
            return;
        case Token.WHILE:
            handleWhile(n);
            return;
        case Token.DO:
            handleDo(n);
            return;
        case Token.FOR:
            handleFor(n);
            return;
        case Token.SWITCH:
            handleSwitch(n);
            return;
        case Token.CASE:
            handleCase(n);
            return;
        case Token.DEFAULT_CASE:
            handleDefault(n);
            return;
        case Token.BLOCK:
        case Token.SCRIPT:
            handleStmtList(n);
            return;
        case Token.FUNCTION:
            handleFunction(n);
            return;
        case Token.EXPR_RESULT:
            handleExpr(n);
            return;
        case Token.THROW:
            handleThrow(n);
            return;
        case Token.TRY:
            handleTry(n);
            return;
        case Token.CATCH:
            handleCatch(n);
            return;
        case Token.BREAK:
            handleBreak(n);
            return;
        case Token.CONTINUE:
            handleContinue(n);
            return;
        case Token.RETURN:
            handleReturn(n);
            return;
        case Token.WITH:
            handleWith(n);
            return;
        case Token.LABEL:
            return;
        default:
            handleStmt(n);
            return;
    }
}","public void test2121() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((double) (-83), (-83), (-83));
    Node node1 = new Node(105, node0, 29, 45);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false, false);
    NodeTraversal nodeTraversal0 = new NodeTraversal(compiler0, controlFlowAnalysis0, (ScopeCreator) null);
    // Undeclared exception!
    try {
        controlFlowAnalysis0.visit(nodeTraversal0, node1, node1);
        fail(""Expecting exception: IllegalStateException"");
    } catch (IllegalStateException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities, edgeAnnotations);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.isFunction()) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test2222() throws Throwable {
    Node node0 = new Node(115);
    Node node1 = new Node(37, node0, node0, node0);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false, false);
    // Undeclared exception!
    try {
        controlFlowAnalysis0.process(node0, node1);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
    }
}",""
"public boolean isGetProp() {
    return this.getType() == Token.GETPROP;
}","public void test2323() throws Throwable {
    Node node0 = new Node(125);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, true, true);
    controlFlowAnalysis0.process(node0, node0);
    assertFalse(node0.isGetProp());
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities, edgeAnnotations);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.isFunction()) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test2424() throws Throwable {
    Node node0 = new Node(125);
    Node node1 = new Node(37, node0, node0, node0);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false, false);
    controlFlowAnalysis0.process(node0, node0);
    assertEquals(12, Node.COLUMN_BITS);
}",""
"public boolean isInc() {
    return this.getType() == Token.INC;
}","public void test2525() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""ey~oS&Vn!~T+K"");
    Node node1 = new Node(77, node0, node0);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, true, true);
    controlFlowAnalysis0.process(node1, node0);
    assertFalse(node1.isInc());
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities, edgeAnnotations);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.isFunction()) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test2626() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""_W`4t9|6R`$%<MrK"");
    Node node1 = new Node(111, node0, node0);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false, true);
    controlFlowAnalysis0.process(node1, node0);
    assertEquals(36, Node.QUOTED_PROP);
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities, edgeAnnotations);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.isFunction()) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test2727() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = new Node(106, 106, 106);
    SyntheticAst syntheticAst0 = new SyntheticAst(""com.google.javascrpt.jscopp.ControlFlowAnalysis$AstControlFlowG5apA$2"");
    Node node1 = syntheticAst0.getAstRoot(compiler0);
    Node node2 = new Node(112, node0, node1, node1, node1);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false, false);
    controlFlowAnalysis0.process(node0, node1);
    assertEquals(54, Node.LAST_PROP);
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities, edgeAnnotations);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.isFunction()) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test2828() throws Throwable {
    Node node0 = new Node(116);
    Compiler compiler0 = new Compiler();
    Node node1 = new Node(110, node0, node0, node0, node0);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false, false);
    controlFlowAnalysis0.process(node0, node0);
    assertEquals(30, Node.VAR_ARGS_NAME);
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities, edgeAnnotations);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.isFunction()) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test2929() throws Throwable {
    Node node0 = new Node(116);
    Compiler compiler0 = new Compiler();
    Node node1 = compiler0.parseTestCode(""xhQBWkiO4%J)^"");
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false, false);
    // Undeclared exception!
    try {
        controlFlowAnalysis0.process(node1, node0);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // Cannot find break target.
        //
        verifyException(""com.google.javascript.jscomp.ControlFlowAnalysis"", e);
    }
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities, edgeAnnotations);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.isFunction()) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test3030() throws Throwable {
    Node node0 = new Node(117, 117, 117);
    Node node1 = new Node(37, node0, node0, node0);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false, false);
    // Undeclared exception!
    try {
        controlFlowAnalysis0.process(node0, node1);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // Cannot find continue target.
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"public boolean isFunction() {
    return this.getType() == Token.FUNCTION;
}","public void test3131() throws Throwable {
    Node node0 = new Node(77);
    Node node1 = new Node(4, node0, node0);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false, false);
    controlFlowAnalysis0.process(node1, node1);
    assertFalse(node1.isFunction());
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities, edgeAnnotations);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.isFunction()) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test3232() throws Throwable {
    Node node0 = new Node(4);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false, false);
    controlFlowAnalysis0.process(node0, node0);
    assertEquals(4095, Node.MAX_COLUMN_NUMBER);
}",""
"static Node computeFollowNode(Node node) {
    return computeFollowNode(node, node, null);
}","public void test3333() throws Throwable {
    Node node0 = new Node(453);
    Node node1 = new Node(136, node0, 4095, 2);
    Node node2 = ControlFlowAnalysis.computeFollowNode(node0);
    assertNull(node2);
}",""
"static Node computeFollowNode(Node node, ControlFlowAnalysis cfa) {
    return computeFollowNode(node, node, cfa);
}","public void test3434() throws Throwable {
    Node node0 = new Node((-1216), (-1216), (-1216));
    Node node1 = new Node(111, node0, node0);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis((AbstractCompiler) null, true, true);
    Node node2 = ControlFlowAnalysis.computeFollowNode(node0, controlFlowAnalysis0);
    assertNull(node2);
}",""
"static Node computeFollowNode(Node node, ControlFlowAnalysis cfa) {
    return computeFollowNode(node, node, cfa);
}","public void test3535() throws Throwable {
    Node node0 = new Node(77);
    Node node1 = new Node(113, node0, node0);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false, true);
    Node node2 = ControlFlowAnalysis.computeFollowNode(node0, controlFlowAnalysis0);
    assertNotNull(node2);
}",""
"public boolean isWhile() {
    return this.getType() == Token.WHILE;
}","public void test3536() throws Throwable {
    Node node0 = new Node(77);
    Node node1 = new Node(113, node0, node0);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false, true);
    Node node2 = ControlFlowAnalysis.computeFollowNode(node0, controlFlowAnalysis0);
    assertTrue(node2.isWhile());
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities, edgeAnnotations);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.isFunction()) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test3637() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = Node.newNumber((-504.6993505358), 423, 423);
    Node node1 = new Node(112, node0, 47, 32);
    SyntheticAst syntheticAst0 = new SyntheticAst(""com.google.javascript.jscomp.ControlFlowAnalysis$AstControlFlowGraph$2"");
    Node node2 = syntheticAst0.getAstRoot(compiler0);
    Node node3 = new Node(8, node2, node1, node1, node2);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false, false);
    // Undeclared exception!
    try {
        controlFlowAnalysis0.process(node1, node1);
        fail(""Expecting exception: RuntimeException"");
    } catch (RuntimeException e) {
        //
        // INTERNAL COMPILER ERROR.
        // Please report this problem.
        // Not reachable
        //
        verifyException(""com.google.common.base.Preconditions"", e);
    }
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities, edgeAnnotations);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.isFunction()) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test3738() throws Throwable {
    Node node0 = Node.newString(""z"");
    Compiler compiler0 = new Compiler();
    Node node1 = compiler0.parseTestCode(""z"");
    Node node2 = new Node(50, node0, node1);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, true, true);
    controlFlowAnalysis0.process(node1, node2);
    assertEquals(50, Node.FREE_CALL);
}",""
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities, edgeAnnotations);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.isFunction()) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test3839() throws Throwable {
    Node node0 = new Node(105, 105, (-1587));
    Node node1 = Node.newString(32, """");
    Node node2 = new Node(30, node1, node0);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false, true);
    controlFlowAnalysis0.process(node0, node2);
    assertEquals(4095, Node.MAX_COLUMN_NUMBER);
}",""
"public boolean isNew() {
    return this.getType() == Token.NEW;
}","public void test3940() throws Throwable {
    Node node0 = new Node((-1148), (-1148), (-1148));
    Node node1 = new Node(111, node0, node0);
    Node node2 = Node.newString(""com.googe.javascrpt.jscomp.ControFlowAnalysis$1"");
    Node node3 = new Node(37, node2, node2, node2, node1);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis((AbstractCompiler) null, true, true);
    controlFlowAnalysis0.process(node3, node3);
    assertFalse(node3.isNew());
}",""
"public static boolean isBreakTarget(Node target, String label) {
    return isBreakStructure(target, label != null) && matchLabel(target.getParent(), label);
}","public void test4041() throws Throwable {
    Node node0 = new Node(125, 125, 125);
    // Undeclared exception!
    try {
        ControlFlowAnalysis.isBreakTarget(node0, """");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.ControlFlowAnalysis"", e);
    }
}","/**
 * Checks if target is actually the break target of labeled continue. The
 * label can be null if it is an unlabeled break.
 */"
"public static boolean isBreakTarget(Node target, String label) {
    return isBreakStructure(target, label != null) && matchLabel(target.getParent(), label);
}","public void test4142() throws Throwable {
    Node node0 = new Node(108);
    Node node1 = new Node(40, node0, node0, node0, node0);
    boolean boolean0 = ControlFlowAnalysis.isBreakTarget(node0, """");
    assertFalse(boolean0);
}","/**
 * Checks if target is actually the break target of labeled continue. The
 * label can be null if it is an unlabeled break.
 */"
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities, edgeAnnotations);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.isFunction()) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test4243() throws Throwable {
    Node node0 = new Node(33);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false, false);
    controlFlowAnalysis0.process(node0, node0);
    assertEquals(29, Node.JSDOC_INFO_PROP);
}",""
"public static boolean mayThrowException(Node n) {
    switch(n.getType()) {
        case Token.CALL:
        case Token.GETPROP:
        case Token.GETELEM:
        case Token.THROW:
        case Token.NEW:
        case Token.ASSIGN:
        case Token.INC:
        case Token.DEC:
        case Token.INSTANCEOF:
            return true;
        case Token.FUNCTION:
            return false;
    }
    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
        if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {
            return true;
        }
    }
    return false;
}","public void test4344() throws Throwable {
    Node node0 = new Node(65136, 65136, 65136);
    Node node1 = new Node(35, node0, node0, node0, 4, 31);
    boolean boolean0 = ControlFlowAnalysis.mayThrowException(node1);
    assertTrue(boolean0);
}","/**
 * Determines if the subtree might throw an exception.
 */"
"@Override
public void process(Node externs, Node root) {
    this.root = root;
    astPositionCounter = 0;
    astPosition = Maps.newHashMap();
    nodePriorities = Maps.newHashMap();
    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities, edgeAnnotations);
    NodeTraversal.traverse(compiler, root, this);
    // the implicit return is last.
    astPosition.put(null, ++astPositionCounter);
    // Now, generate the priority of nodes by doing a depth-first
    // search on the CFG.
    priorityCounter = 0;
    DiGraphNode<Node, Branch> entry = cfg.getEntry();
    prioritizeFromEntryNode(entry);
    if (shouldTraverseFunctions) {
        // If we're traversing inner functions, we need to rank the
        // priority of them too.
        for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
            Node value = candidate.getValue();
            if (value != null && value.isFunction()) {
                Preconditions.checkState(!nodePriorities.containsKey(candidate) || candidate == entry);
                prioritizeFromEntryNode(candidate);
            }
        }
    }
    // At this point, all reachable nodes have been given a priority, but
    // unreachable nodes have not been given a priority. Put them last.
    // Presumably, it doesn't really matter what priority they get, since
    // this shouldn't happen in real code.
    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {
        if (!nodePriorities.containsKey(candidate)) {
            nodePriorities.put(candidate, ++priorityCounter);
        }
    }
    // Again, the implicit return node is always last.
    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);
}","public void test4445() throws Throwable {
    Node node0 = new Node((-1511));
    Node node1 = new Node(52, node0, node0);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, true, true);
    controlFlowAnalysis0.process(node0, node1);
    assertEquals(4095, Node.COLUMN_MASK);
}",""
"public boolean isOptionalArg() {
    return getBooleanProp(OPT_ARG_NAME);
}","public void test4546() throws Throwable {
    Compiler compiler0 = new Compiler();
    Node node0 = compiler0.parseTestCode(""ey~oS&n!~T+K"");
    Node node1 = new Node(86, node0, node0);
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, true, true);
    controlFlowAnalysis0.process(node0, node1);
    assertFalse(node1.isOptionalArg());
}","/**
 * Returns whether this node is an optional argument node. This
 * method's return value is meaningful only on {@link Token#NAME} nodes
 * used to define a {@link Token#FUNCTION}'s argument list.
 */"
"public static boolean mayThrowException(Node n) {
    switch(n.getType()) {
        case Token.CALL:
        case Token.GETPROP:
        case Token.GETELEM:
        case Token.THROW:
        case Token.NEW:
        case Token.ASSIGN:
        case Token.INC:
        case Token.DEC:
        case Token.INSTANCEOF:
            return true;
        case Token.FUNCTION:
            return false;
    }
    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
        if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {
            return true;
        }
    }
    return false;
}","public void test4647() throws Throwable {
    Node node0 = new Node((-447));
    Node node1 = new Node(102, node0);
    boolean boolean0 = ControlFlowAnalysis.mayThrowException(node1);
    assertTrue(boolean0);
}","/**
 * Determines if the subtree might throw an exception.
 */"
"public boolean isEmpty() {
    return this.getType() == Token.EMPTY;
}","public void test4748() throws Throwable {
    Node node0 = new Node(103, 103, 103);
    Compiler compiler0 = new Compiler();
    ControlFlowAnalysis controlFlowAnalysis0 = new ControlFlowAnalysis(compiler0, false, false);
    controlFlowAnalysis0.process(node0, node0);
    assertFalse(node0.isEmpty());
}",""
"public static boolean mayThrowException(Node n) {
    switch(n.getType()) {
        case Token.CALL:
        case Token.GETPROP:
        case Token.GETELEM:
        case Token.THROW:
        case Token.NEW:
        case Token.ASSIGN:
        case Token.INC:
        case Token.DEC:
        case Token.INSTANCEOF:
            return true;
        case Token.FUNCTION:
            return false;
    }
    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
        if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {
            return true;
        }
    }
    return false;
}","public void test4849() throws Throwable {
    Node node0 = new Node(131);
    Node node1 = new Node(105, node0, 29, 45);
    boolean boolean0 = ControlFlowAnalysis.mayThrowException(node1);
    assertFalse(boolean0);
}","/**
 * Determines if the subtree might throw an exception.
 */"
"public static boolean mayThrowException(Node n) {
    switch(n.getType()) {
        case Token.CALL:
        case Token.GETPROP:
        case Token.GETELEM:
        case Token.THROW:
        case Token.NEW:
        case Token.ASSIGN:
        case Token.INC:
        case Token.DEC:
        case Token.INSTANCEOF:
            return true;
        case Token.FUNCTION:
            return false;
    }
    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
        if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {
            return true;
        }
    }
    return false;
}","public void test4950() throws Throwable {
    Node node0 = new Node(49);
    Node node1 = new Node(15, node0, node0, node0);
    boolean boolean0 = ControlFlowAnalysis.mayThrowException(node1);
    assertTrue(boolean0);
}","/**
 * Determines if the subtree might throw an exception.
 */"
"public static boolean isBreakTarget(Node target, String label) {
    return isBreakStructure(target, label != null) && matchLabel(target.getParent(), label);
}","public void test5051() throws Throwable {
    Node node0 = new Node(77);
    // Undeclared exception!
    try {
        ControlFlowAnalysis.isBreakTarget(node0, "";qn"");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.ControlFlowAnalysis"", e);
    }
}","/**
 * Checks if target is actually the break target of labeled continue. The
 * label can be null if it is an unlabeled break.
 */"
"public static boolean isBreakTarget(Node target, String label) {
    return isBreakStructure(target, label != null) && matchLabel(target.getParent(), label);
}","public void test5152() throws Throwable {
    Node node0 = new Node(113, 113, 113);
    // Undeclared exception!
    try {
        ControlFlowAnalysis.isBreakTarget(node0, """");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.ControlFlowAnalysis"", e);
    }
}","/**
 * Checks if target is actually the break target of labeled continue. The
 * label can be null if it is an unlabeled break.
 */"
"public static boolean isBreakTarget(Node target, String label) {
    return isBreakStructure(target, label != null) && matchLabel(target.getParent(), label);
}","public void test5253() throws Throwable {
    Node node0 = Node.newString("""", 114, 114);
    Node node1 = new Node(114, node0, node0);
    // Undeclared exception!
    try {
        ControlFlowAnalysis.isBreakTarget(node1, """");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.ControlFlowAnalysis"", e);
    }
}","/**
 * Checks if target is actually the break target of labeled continue. The
 * label can be null if it is an unlabeled break.
 */"
"public static boolean isBreakTarget(Node target, String label) {
    return isBreakStructure(target, label != null) && matchLabel(target.getParent(), label);
}","public void test5354() throws Throwable {
    Node node0 = new Node(498, 498, 498);
    Node node1 = new Node(115, node0, 4095, 2);
    // Undeclared exception!
    try {
        ControlFlowAnalysis.isBreakTarget(node1, """");
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.ControlFlowAnalysis"", e);
    }
}","/**
 * Checks if target is actually the break target of labeled continue. The
 * label can be null if it is an unlabeled break.
 */"
"static boolean isContinueStructure(Node n) {
    switch(n.getType()) {
        case Token.FOR:
        case Token.DO:
        case Token.WHILE:
            return true;
        default:
            return false;
    }
}","public void test5455() throws Throwable {
    Node node0 = new Node(113, 113, 113);
    boolean boolean0 = ControlFlowAnalysis.isContinueStructure(node0);
    assertTrue(boolean0);
}","/**
 * Determines whether the given node can be advanced with a CONTINUE node.
 */"
"static boolean isContinueStructure(Node n) {
    switch(n.getType()) {
        case Token.FOR:
        case Token.DO:
        case Token.WHILE:
            return true;
        default:
            return false;
    }
}","public void test5556() throws Throwable {
    Node node0 = Node.newString("""", 114, 114);
    Node node1 = new Node(114, node0, node0);
    boolean boolean0 = ControlFlowAnalysis.isContinueStructure(node1);
    assertTrue(boolean0);
}","/**
 * Determines whether the given node can be advanced with a CONTINUE node.
 */"
"static boolean isContinueStructure(Node n) {
    switch(n.getType()) {
        case Token.FOR:
        case Token.DO:
        case Token.WHILE:
            return true;
        default:
            return false;
    }
}","public void test5657() throws Throwable {
    Node node0 = new Node(453, 453, 453);
    Node node1 = new Node(115, node0, 4095, 2);
    boolean boolean0 = ControlFlowAnalysis.isContinueStructure(node1);
    assertTrue(boolean0);
}","/**
 * Determines whether the given node can be advanced with a CONTINUE node.
 */"
"static Node getExceptionHandler(Node n) {
    for (Node cur = n; !cur.isScript() && !cur.isFunction(); cur = cur.getParent()) {
        Node catchNode = getCatchHandlerForBlock(cur);
        if (catchNode != null) {
            return catchNode;
        }
    }
    return null;
}","public void test5758() throws Throwable {
    Node node0 = new Node(132);
    Node node1 = ControlFlowAnalysis.getExceptionHandler(node0);
    assertNull(node1);
}","/**
 * Get the TRY block with a CATCH that would be run if n throws an exception.
 * @return The CATCH node or null if it there isn't a CATCH before the
 *     the function terminates.
 */"
"static Node getExceptionHandler(Node n) {
    for (Node cur = n; !cur.isScript() && !cur.isFunction(); cur = cur.getParent()) {
        Node catchNode = getCatchHandlerForBlock(cur);
        if (catchNode != null) {
            return catchNode;
        }
    }
    return null;
}","public void test5859() throws Throwable {
    Node node0 = new Node(105);
    Node node1 = ControlFlowAnalysis.getExceptionHandler(node0);
    assertNull(node1);
}","/**
 * Get the TRY block with a CATCH that would be run if n throws an exception.
 * @return The CATCH node or null if it there isn't a CATCH before the
 *     the function terminates.
 */"
"static Node getExceptionHandler(Node n) {
    for (Node cur = n; !cur.isScript() && !cur.isFunction(); cur = cur.getParent()) {
        Node catchNode = getCatchHandlerForBlock(cur);
        if (catchNode != null) {
            return catchNode;
        }
    }
    return null;
}","public void test5960() throws Throwable {
    Node node0 = new Node(125, 125, 125);
    Node node1 = new Node(4095, node0, 53, 41);
    // Undeclared exception!
    try {
        ControlFlowAnalysis.getExceptionHandler(node0);
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.ControlFlowAnalysis"", e);
    }
}","/**
 * Get the TRY block with a CATCH that would be run if n throws an exception.
 * @return The CATCH node or null if it there isn't a CATCH before the
 *     the function terminates.
 */"
