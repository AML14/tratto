focal_method,test_prefix,docstring
"boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    JsDocToken token = next();
    ExtractionInfo blockInfo = extractBlockComment(token);
    token = blockInfo.token;
    // If we have a block level comment, record it.
    if (blockInfo.string.length() > 0) {
        jsdocBuilder.recordBlockDescription(blockInfo.string);
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case AUTHOR:
                                ExtractionInfo authorInfo = extractSingleLineBlock();
                                String author = authorInfo.string;
                                if (author.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addAuthor(author);
                                }
                                token = authorInfo.token;
                                continue retry;
                            case CONSTANT:
                                if (!jsdocBuilder.recordConstancy()) {
                                    parser.addWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                String fileOverview = fileOverviewInfo.string;
                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
                                    parser.addWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                token = fileOverviewInfo.token;
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && !matchingRc) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        if (!jsdocBuilder.recordBaseType(type)) {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                String description = descriptionInfo.string;
                                if (description.length() > 0) {
                                    jsdocBuilder.recordThrowDescription(type, description);
                                }
                                token = descriptionInfo.token;
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter annotation.
                                        // It makes no sense under our type system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, lineno, charno);
                                // Find the parameter's description (if applicable).
                                ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                String paramDescription = paramDescriptionInfo.string;
                                if (paramDescription.length() > 0) {
                                    jsdocBuilder.recordParameterDescription(name, paramDescription);
                                }
                                token = paramDescriptionInfo.token;
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PRIVATE:
                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                    parser.addWarning(""msg.jsdoc.visibility.private"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PROTECTED:
                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                    parser.addWarning(""msg.jsdoc.visibility.protected"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PUBLIC:
                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                    parser.addWarning(""msg.jsdoc.visibility.public"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                ExtractionInfo referenceInfo = extractSingleLineBlock();
                                String reference = referenceInfo.string;
                                if (reference.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addReference(reference);
                                }
                                token = referenceInfo.token;
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                ExtractionInfo templateInfo = extractSingleLineBlock();
                                String templateTypeName = templateInfo.string;
                                if (templateTypeName.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
                                    parser.addWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                }
                                token = templateInfo.token;
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case DEFINE:
                            case RETURN:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                skipEOLs();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                token = next();
                                Node typeNode = parseAndRecordTypeNode(token, lineno, charno);
                                if (annotation == Annotation.THIS) {
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && token != JsDocToken.LC) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                }
                                type = createJSTypeExpression(typeNode);
                                if (type == null) {
                                    // error reported during recursive descent
                                    // recovering parsing
                                } else {
                                    switch(annotation) {
                                        case DEFINE:
                                            if (!isValidDefineType(typeNode)) {
                                                parser.addWarning(""msg.jsdoc.define.badtype"", lineno, charno);
                                            } else if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // *Update* the token to that after the type annotation.
                                            token = current();
                                            // Find the return's description (if applicable).
                                            ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                            String returnDescription = returnDescriptionInfo.string;
                                            if (returnDescription.length() > 0) {
                                                jsdocBuilder.recordReturnDescription(returnDescription);
                                            }
                                            token = returnDescriptionInfo.token;
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPE:
                                            if (!jsdocBuilder.recordType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                    token = eatTokensUntilEOL();
                                }
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test000() throws Throwable {
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config config0 = new Config((JSTypeRegistry) null, linkedHashSet0, true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""!,&*/4y1j*'>T()"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, ""!,&*/4y1j*'>T()"", config0, (ErrorReporter) null);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertTrue(boolean0);
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean hasParsedJSDocInfo() {
    return jsdocBuilder.isPopulated();
}","public void test011() throws Throwable {
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config config0 = new Config((JSTypeRegistry) null, linkedHashSet0, true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""=V8yK\""&0RFN%]z"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, ""=V8yK\""&0RFN%]z"", config0, (ErrorReporter) null);
    boolean boolean0 = jsDocInfoParser0.hasParsedJSDocInfo();
    assertFalse(boolean0);
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(new JSTypeRegistry(NullErrorReporter.forOldRhino()), Sets.<String>newHashSet(), false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), ""typeparsing"", config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test022() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""function ("");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"JSDocInfo getFileOverviewJSDocInfo() {
    return fileOverviewJSDocInfo;
}","public void test033() throws Throwable {
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config config0 = new Config((JSTypeRegistry) null, linkedHashSet0, true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""=V8yK\""0RFN%F]z"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, ""=V8yK\""0RFN%F]z"", config0, (ErrorReporter) null);
    JSDocInfo jSDocInfo0 = jsDocInfoParser0.getFileOverviewJSDocInfo();
    assertNull(jSDocInfo0);
}","/**
 * Gets the fileoverview JSDocInfo, if any.
 */"
"void setFileLevelJsDocBuilder(Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) {
    this.fileLevelJsDocBuilder = fileLevelJsDocBuilder;
}","public void test044() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""*Y@pv4<=M2C"");
    Locale locale0 = Locale.TAIWAN;
    Set<String> set0 = locale0.getUnicodeLocaleAttributes();
    Config config0 = new Config((JSTypeRegistry) null, set0, true);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, ""*Y@pv4<=M2C"", config0, (ErrorReporter) null);
    jsDocInfoParser0.setFileLevelJsDocBuilder((Node.FileLevelJsDocBuilder) null);
}","/**
 * Sets the JsDocBuilder for the file-level (root) node of this parse. The
 * parser uses the builder to append any preserve annotations it encounters
 * in jsdoc comments.
 *
 * @param fileLevelJsDocBuilder
 */"
"void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo) {
    this.fileOverviewJSDocInfo = fileOverviewJSDocInfo;
}","public void test055() throws Throwable {
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config config0 = new Config((JSTypeRegistry) null, linkedHashSet0, true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""=V8yK\""0RFN%F]z"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, ""=V8yK\""0RFN%F]z"", config0, (ErrorReporter) null);
    jsDocInfoParser0.setFileOverviewJSDocInfo((JSDocInfo) null);
}","/**
 * Sets the file overview JSDocInfo, in order to warn about multiple uses of
 * the @fileoverview tag in a file.
 */"
"boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    JsDocToken token = next();
    ExtractionInfo blockInfo = extractBlockComment(token);
    token = blockInfo.token;
    // If we have a block level comment, record it.
    if (blockInfo.string.length() > 0) {
        jsdocBuilder.recordBlockDescription(blockInfo.string);
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case AUTHOR:
                                ExtractionInfo authorInfo = extractSingleLineBlock();
                                String author = authorInfo.string;
                                if (author.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addAuthor(author);
                                }
                                token = authorInfo.token;
                                continue retry;
                            case CONSTANT:
                                if (!jsdocBuilder.recordConstancy()) {
                                    parser.addWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                String fileOverview = fileOverviewInfo.string;
                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
                                    parser.addWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                token = fileOverviewInfo.token;
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && !matchingRc) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        if (!jsdocBuilder.recordBaseType(type)) {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                String description = descriptionInfo.string;
                                if (description.length() > 0) {
                                    jsdocBuilder.recordThrowDescription(type, description);
                                }
                                token = descriptionInfo.token;
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter annotation.
                                        // It makes no sense under our type system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, lineno, charno);
                                // Find the parameter's description (if applicable).
                                ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                String paramDescription = paramDescriptionInfo.string;
                                if (paramDescription.length() > 0) {
                                    jsdocBuilder.recordParameterDescription(name, paramDescription);
                                }
                                token = paramDescriptionInfo.token;
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PRIVATE:
                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                    parser.addWarning(""msg.jsdoc.visibility.private"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PROTECTED:
                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                    parser.addWarning(""msg.jsdoc.visibility.protected"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PUBLIC:
                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                    parser.addWarning(""msg.jsdoc.visibility.public"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                ExtractionInfo referenceInfo = extractSingleLineBlock();
                                String reference = referenceInfo.string;
                                if (reference.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addReference(reference);
                                }
                                token = referenceInfo.token;
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                ExtractionInfo templateInfo = extractSingleLineBlock();
                                String templateTypeName = templateInfo.string;
                                if (templateTypeName.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
                                    parser.addWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                }
                                token = templateInfo.token;
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case DEFINE:
                            case RETURN:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                skipEOLs();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                token = next();
                                Node typeNode = parseAndRecordTypeNode(token, lineno, charno);
                                if (annotation == Annotation.THIS) {
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && token != JsDocToken.LC) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                }
                                type = createJSTypeExpression(typeNode);
                                if (type == null) {
                                    // error reported during recursive descent
                                    // recovering parsing
                                } else {
                                    switch(annotation) {
                                        case DEFINE:
                                            if (!isValidDefineType(typeNode)) {
                                                parser.addWarning(""msg.jsdoc.define.badtype"", lineno, charno);
                                            } else if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // *Update* the token to that after the type annotation.
                                            token = current();
                                            // Find the return's description (if applicable).
                                            ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                            String returnDescription = returnDescriptionInfo.string;
                                            if (returnDescription.length() > 0) {
                                                jsdocBuilder.recordReturnDescription(returnDescription);
                                            }
                                            token = returnDescriptionInfo.token;
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPE:
                                            if (!jsdocBuilder.recordType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                    token = eatTokensUntilEOL();
                                }
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test066() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""@*}p=$BV$i6eF"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config config0 = new Config((JSTypeRegistry) null, linkedHashSet0, true);
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(true);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, ""@*}p=$BV$i6eF"", config0, toolErrorReporter0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertFalse(boolean0);
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(new JSTypeRegistry(NullErrorReporter.forOldRhino()), Sets.<String>newHashSet(), false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), ""typeparsing"", config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test077() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""(e8%bz_,9lPF"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"JSDocInfo retrieveAndResetParsedJSDocInfo() {
    return jsdocBuilder.build(sourceName);
}","public void test088() throws Throwable {
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config config0 = new Config((JSTypeRegistry) null, linkedHashSet0, true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""!,&*/4y1j*'>T()"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, ""!,&*/4y1j*'>T()"", config0, (ErrorReporter) null);
    JSDocInfo jSDocInfo0 = jsDocInfoParser0.retrieveAndResetParsedJSDocInfo();
    assertNull(jSDocInfo0);
}",""
"boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    JsDocToken token = next();
    ExtractionInfo blockInfo = extractBlockComment(token);
    token = blockInfo.token;
    // If we have a block level comment, record it.
    if (blockInfo.string.length() > 0) {
        jsdocBuilder.recordBlockDescription(blockInfo.string);
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case AUTHOR:
                                ExtractionInfo authorInfo = extractSingleLineBlock();
                                String author = authorInfo.string;
                                if (author.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addAuthor(author);
                                }
                                token = authorInfo.token;
                                continue retry;
                            case CONSTANT:
                                if (!jsdocBuilder.recordConstancy()) {
                                    parser.addWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                String fileOverview = fileOverviewInfo.string;
                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
                                    parser.addWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                token = fileOverviewInfo.token;
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && !matchingRc) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        if (!jsdocBuilder.recordBaseType(type)) {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                String description = descriptionInfo.string;
                                if (description.length() > 0) {
                                    jsdocBuilder.recordThrowDescription(type, description);
                                }
                                token = descriptionInfo.token;
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter annotation.
                                        // It makes no sense under our type system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, lineno, charno);
                                // Find the parameter's description (if applicable).
                                ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                String paramDescription = paramDescriptionInfo.string;
                                if (paramDescription.length() > 0) {
                                    jsdocBuilder.recordParameterDescription(name, paramDescription);
                                }
                                token = paramDescriptionInfo.token;
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PRIVATE:
                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                    parser.addWarning(""msg.jsdoc.visibility.private"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PROTECTED:
                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                    parser.addWarning(""msg.jsdoc.visibility.protected"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PUBLIC:
                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                    parser.addWarning(""msg.jsdoc.visibility.public"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                ExtractionInfo referenceInfo = extractSingleLineBlock();
                                String reference = referenceInfo.string;
                                if (reference.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addReference(reference);
                                }
                                token = referenceInfo.token;
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                ExtractionInfo templateInfo = extractSingleLineBlock();
                                String templateTypeName = templateInfo.string;
                                if (templateTypeName.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
                                    parser.addWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                }
                                token = templateInfo.token;
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case DEFINE:
                            case RETURN:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                skipEOLs();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                token = next();
                                Node typeNode = parseAndRecordTypeNode(token, lineno, charno);
                                if (annotation == Annotation.THIS) {
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && token != JsDocToken.LC) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                }
                                type = createJSTypeExpression(typeNode);
                                if (type == null) {
                                    // error reported during recursive descent
                                    // recovering parsing
                                } else {
                                    switch(annotation) {
                                        case DEFINE:
                                            if (!isValidDefineType(typeNode)) {
                                                parser.addWarning(""msg.jsdoc.define.badtype"", lineno, charno);
                                            } else if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // *Update* the token to that after the type annotation.
                                            token = current();
                                            // Find the return's description (if applicable).
                                            ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                            String returnDescription = returnDescriptionInfo.string;
                                            if (returnDescription.length() > 0) {
                                                jsdocBuilder.recordReturnDescription(returnDescription);
                                            }
                                            token = returnDescriptionInfo.token;
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPE:
                                            if (!jsdocBuilder.recordType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                    token = eatTokensUntilEOL();
                                }
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test099() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""@[d-TK1\n"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config config0 = new Config((JSTypeRegistry) null, linkedHashSet0, false);
    ToolErrorReporter toolErrorReporter0 = new ToolErrorReporter(false);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, ""@[d-TK1\n"", config0, toolErrorReporter0);
    boolean boolean0 = jsDocInfoParser0.parse();
    assertFalse(boolean0);
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    JsDocToken token = next();
    ExtractionInfo blockInfo = extractBlockComment(token);
    token = blockInfo.token;
    // If we have a block level comment, record it.
    if (blockInfo.string.length() > 0) {
        jsdocBuilder.recordBlockDescription(blockInfo.string);
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case AUTHOR:
                                ExtractionInfo authorInfo = extractSingleLineBlock();
                                String author = authorInfo.string;
                                if (author.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addAuthor(author);
                                }
                                token = authorInfo.token;
                                continue retry;
                            case CONSTANT:
                                if (!jsdocBuilder.recordConstancy()) {
                                    parser.addWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                String fileOverview = fileOverviewInfo.string;
                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
                                    parser.addWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                token = fileOverviewInfo.token;
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && !matchingRc) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        if (!jsdocBuilder.recordBaseType(type)) {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                String description = descriptionInfo.string;
                                if (description.length() > 0) {
                                    jsdocBuilder.recordThrowDescription(type, description);
                                }
                                token = descriptionInfo.token;
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter annotation.
                                        // It makes no sense under our type system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, lineno, charno);
                                // Find the parameter's description (if applicable).
                                ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                String paramDescription = paramDescriptionInfo.string;
                                if (paramDescription.length() > 0) {
                                    jsdocBuilder.recordParameterDescription(name, paramDescription);
                                }
                                token = paramDescriptionInfo.token;
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PRIVATE:
                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                    parser.addWarning(""msg.jsdoc.visibility.private"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PROTECTED:
                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                    parser.addWarning(""msg.jsdoc.visibility.protected"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PUBLIC:
                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                    parser.addWarning(""msg.jsdoc.visibility.public"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                ExtractionInfo referenceInfo = extractSingleLineBlock();
                                String reference = referenceInfo.string;
                                if (reference.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addReference(reference);
                                }
                                token = referenceInfo.token;
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                ExtractionInfo templateInfo = extractSingleLineBlock();
                                String templateTypeName = templateInfo.string;
                                if (templateTypeName.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
                                    parser.addWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                }
                                token = templateInfo.token;
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case DEFINE:
                            case RETURN:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                skipEOLs();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                token = next();
                                Node typeNode = parseAndRecordTypeNode(token, lineno, charno);
                                if (annotation == Annotation.THIS) {
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && token != JsDocToken.LC) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                }
                                type = createJSTypeExpression(typeNode);
                                if (type == null) {
                                    // error reported during recursive descent
                                    // recovering parsing
                                } else {
                                    switch(annotation) {
                                        case DEFINE:
                                            if (!isValidDefineType(typeNode)) {
                                                parser.addWarning(""msg.jsdoc.define.badtype"", lineno, charno);
                                            } else if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // *Update* the token to that after the type annotation.
                                            token = current();
                                            // Find the return's description (if applicable).
                                            ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                            String returnDescription = returnDescriptionInfo.string;
                                            if (returnDescription.length() > 0) {
                                                jsdocBuilder.recordReturnDescription(returnDescription);
                                            }
                                            token = returnDescriptionInfo.token;
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPE:
                                            if (!jsdocBuilder.recordType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                    token = eatTokensUntilEOL();
                                }
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test1010() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream("".<"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    ErrorCollector errorCollector0 = new ErrorCollector();
    Config config0 = new Config((JSTypeRegistry) null, linkedHashSet0, true);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, "".<"", config0, errorCollector0);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.mozilla.rhino.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    JsDocToken token = next();
    ExtractionInfo blockInfo = extractBlockComment(token);
    token = blockInfo.token;
    // If we have a block level comment, record it.
    if (blockInfo.string.length() > 0) {
        jsdocBuilder.recordBlockDescription(blockInfo.string);
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case AUTHOR:
                                ExtractionInfo authorInfo = extractSingleLineBlock();
                                String author = authorInfo.string;
                                if (author.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addAuthor(author);
                                }
                                token = authorInfo.token;
                                continue retry;
                            case CONSTANT:
                                if (!jsdocBuilder.recordConstancy()) {
                                    parser.addWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                String fileOverview = fileOverviewInfo.string;
                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
                                    parser.addWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                token = fileOverviewInfo.token;
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && !matchingRc) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        if (!jsdocBuilder.recordBaseType(type)) {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                String description = descriptionInfo.string;
                                if (description.length() > 0) {
                                    jsdocBuilder.recordThrowDescription(type, description);
                                }
                                token = descriptionInfo.token;
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter annotation.
                                        // It makes no sense under our type system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, lineno, charno);
                                // Find the parameter's description (if applicable).
                                ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                String paramDescription = paramDescriptionInfo.string;
                                if (paramDescription.length() > 0) {
                                    jsdocBuilder.recordParameterDescription(name, paramDescription);
                                }
                                token = paramDescriptionInfo.token;
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PRIVATE:
                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                    parser.addWarning(""msg.jsdoc.visibility.private"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PROTECTED:
                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                    parser.addWarning(""msg.jsdoc.visibility.protected"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PUBLIC:
                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                    parser.addWarning(""msg.jsdoc.visibility.public"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                ExtractionInfo referenceInfo = extractSingleLineBlock();
                                String reference = referenceInfo.string;
                                if (reference.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addReference(reference);
                                }
                                token = referenceInfo.token;
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                ExtractionInfo templateInfo = extractSingleLineBlock();
                                String templateTypeName = templateInfo.string;
                                if (templateTypeName.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
                                    parser.addWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                }
                                token = templateInfo.token;
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case DEFINE:
                            case RETURN:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                skipEOLs();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                token = next();
                                Node typeNode = parseAndRecordTypeNode(token, lineno, charno);
                                if (annotation == Annotation.THIS) {
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && token != JsDocToken.LC) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                }
                                type = createJSTypeExpression(typeNode);
                                if (type == null) {
                                    // error reported during recursive descent
                                    // recovering parsing
                                } else {
                                    switch(annotation) {
                                        case DEFINE:
                                            if (!isValidDefineType(typeNode)) {
                                                parser.addWarning(""msg.jsdoc.define.badtype"", lineno, charno);
                                            } else if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // *Update* the token to that after the type annotation.
                                            token = current();
                                            // Find the return's description (if applicable).
                                            ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                            String returnDescription = returnDescriptionInfo.string;
                                            if (returnDescription.length() > 0) {
                                                jsdocBuilder.recordReturnDescription(returnDescription);
                                            }
                                            token = returnDescriptionInfo.token;
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPE:
                                            if (!jsdocBuilder.recordType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                    token = eatTokensUntilEOL();
                                }
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test1111() throws Throwable {
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    ErrorCollector errorCollector0 = new ErrorCollector();
    Config config0 = new Config((JSTypeRegistry) null, linkedHashSet0, true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream("",^XhGZ0g~*"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, "",^XhGZ0g~*"", config0, errorCollector0);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.mozilla.rhino.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    JsDocToken token = next();
    ExtractionInfo blockInfo = extractBlockComment(token);
    token = blockInfo.token;
    // If we have a block level comment, record it.
    if (blockInfo.string.length() > 0) {
        jsdocBuilder.recordBlockDescription(blockInfo.string);
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case AUTHOR:
                                ExtractionInfo authorInfo = extractSingleLineBlock();
                                String author = authorInfo.string;
                                if (author.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addAuthor(author);
                                }
                                token = authorInfo.token;
                                continue retry;
                            case CONSTANT:
                                if (!jsdocBuilder.recordConstancy()) {
                                    parser.addWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                String fileOverview = fileOverviewInfo.string;
                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
                                    parser.addWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                token = fileOverviewInfo.token;
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && !matchingRc) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        if (!jsdocBuilder.recordBaseType(type)) {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                String description = descriptionInfo.string;
                                if (description.length() > 0) {
                                    jsdocBuilder.recordThrowDescription(type, description);
                                }
                                token = descriptionInfo.token;
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter annotation.
                                        // It makes no sense under our type system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, lineno, charno);
                                // Find the parameter's description (if applicable).
                                ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                String paramDescription = paramDescriptionInfo.string;
                                if (paramDescription.length() > 0) {
                                    jsdocBuilder.recordParameterDescription(name, paramDescription);
                                }
                                token = paramDescriptionInfo.token;
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PRIVATE:
                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                    parser.addWarning(""msg.jsdoc.visibility.private"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PROTECTED:
                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                    parser.addWarning(""msg.jsdoc.visibility.protected"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PUBLIC:
                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                    parser.addWarning(""msg.jsdoc.visibility.public"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                ExtractionInfo referenceInfo = extractSingleLineBlock();
                                String reference = referenceInfo.string;
                                if (reference.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addReference(reference);
                                }
                                token = referenceInfo.token;
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                ExtractionInfo templateInfo = extractSingleLineBlock();
                                String templateTypeName = templateInfo.string;
                                if (templateTypeName.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
                                    parser.addWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                }
                                token = templateInfo.token;
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case DEFINE:
                            case RETURN:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                skipEOLs();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                token = next();
                                Node typeNode = parseAndRecordTypeNode(token, lineno, charno);
                                if (annotation == Annotation.THIS) {
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && token != JsDocToken.LC) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                }
                                type = createJSTypeExpression(typeNode);
                                if (type == null) {
                                    // error reported during recursive descent
                                    // recovering parsing
                                } else {
                                    switch(annotation) {
                                        case DEFINE:
                                            if (!isValidDefineType(typeNode)) {
                                                parser.addWarning(""msg.jsdoc.define.badtype"", lineno, charno);
                                            } else if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // *Update* the token to that after the type annotation.
                                            token = current();
                                            // Find the return's description (if applicable).
                                            ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                            String returnDescription = returnDescriptionInfo.string;
                                            if (returnDescription.length() > 0) {
                                                jsdocBuilder.recordReturnDescription(returnDescription);
                                            }
                                            token = returnDescriptionInfo.token;
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPE:
                                            if (!jsdocBuilder.recordType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                    token = eatTokensUntilEOL();
                                }
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test1212() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream("":!gKmi7n]RSo0u</"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    ErrorCollector errorCollector0 = new ErrorCollector();
    Config config0 = new Config((JSTypeRegistry) null, linkedHashSet0, false);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, "":!gKmi7n]RSo0u</"", config0, errorCollector0);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.mozilla.rhino.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    JsDocToken token = next();
    ExtractionInfo blockInfo = extractBlockComment(token);
    token = blockInfo.token;
    // If we have a block level comment, record it.
    if (blockInfo.string.length() > 0) {
        jsdocBuilder.recordBlockDescription(blockInfo.string);
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case AUTHOR:
                                ExtractionInfo authorInfo = extractSingleLineBlock();
                                String author = authorInfo.string;
                                if (author.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addAuthor(author);
                                }
                                token = authorInfo.token;
                                continue retry;
                            case CONSTANT:
                                if (!jsdocBuilder.recordConstancy()) {
                                    parser.addWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                String fileOverview = fileOverviewInfo.string;
                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
                                    parser.addWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                token = fileOverviewInfo.token;
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && !matchingRc) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        if (!jsdocBuilder.recordBaseType(type)) {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                String description = descriptionInfo.string;
                                if (description.length() > 0) {
                                    jsdocBuilder.recordThrowDescription(type, description);
                                }
                                token = descriptionInfo.token;
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter annotation.
                                        // It makes no sense under our type system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, lineno, charno);
                                // Find the parameter's description (if applicable).
                                ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                String paramDescription = paramDescriptionInfo.string;
                                if (paramDescription.length() > 0) {
                                    jsdocBuilder.recordParameterDescription(name, paramDescription);
                                }
                                token = paramDescriptionInfo.token;
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PRIVATE:
                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                    parser.addWarning(""msg.jsdoc.visibility.private"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PROTECTED:
                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                    parser.addWarning(""msg.jsdoc.visibility.protected"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PUBLIC:
                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                    parser.addWarning(""msg.jsdoc.visibility.public"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                ExtractionInfo referenceInfo = extractSingleLineBlock();
                                String reference = referenceInfo.string;
                                if (reference.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addReference(reference);
                                }
                                token = referenceInfo.token;
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                ExtractionInfo templateInfo = extractSingleLineBlock();
                                String templateTypeName = templateInfo.string;
                                if (templateTypeName.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
                                    parser.addWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                }
                                token = templateInfo.token;
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case DEFINE:
                            case RETURN:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                skipEOLs();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                token = next();
                                Node typeNode = parseAndRecordTypeNode(token, lineno, charno);
                                if (annotation == Annotation.THIS) {
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && token != JsDocToken.LC) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                }
                                type = createJSTypeExpression(typeNode);
                                if (type == null) {
                                    // error reported during recursive descent
                                    // recovering parsing
                                } else {
                                    switch(annotation) {
                                        case DEFINE:
                                            if (!isValidDefineType(typeNode)) {
                                                parser.addWarning(""msg.jsdoc.define.badtype"", lineno, charno);
                                            } else if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // *Update* the token to that after the type annotation.
                                            token = current();
                                            // Find the return's description (if applicable).
                                            ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                            String returnDescription = returnDescriptionInfo.string;
                                            if (returnDescription.length() > 0) {
                                                jsdocBuilder.recordReturnDescription(returnDescription);
                                            }
                                            token = returnDescriptionInfo.token;
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPE:
                                            if (!jsdocBuilder.recordType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                    token = eatTokensUntilEOL();
                                }
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test1313() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream("">!!K)os@ XD$?$l\""#)"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    ErrorCollector errorCollector0 = new ErrorCollector();
    Config config0 = new Config((JSTypeRegistry) null, linkedHashSet0, false);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, "">!!K)os@ XD$?$l\""#)"", config0, errorCollector0);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.mozilla.rhino.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    JsDocToken token = next();
    ExtractionInfo blockInfo = extractBlockComment(token);
    token = blockInfo.token;
    // If we have a block level comment, record it.
    if (blockInfo.string.length() > 0) {
        jsdocBuilder.recordBlockDescription(blockInfo.string);
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case AUTHOR:
                                ExtractionInfo authorInfo = extractSingleLineBlock();
                                String author = authorInfo.string;
                                if (author.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addAuthor(author);
                                }
                                token = authorInfo.token;
                                continue retry;
                            case CONSTANT:
                                if (!jsdocBuilder.recordConstancy()) {
                                    parser.addWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                String fileOverview = fileOverviewInfo.string;
                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
                                    parser.addWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                token = fileOverviewInfo.token;
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && !matchingRc) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        if (!jsdocBuilder.recordBaseType(type)) {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                String description = descriptionInfo.string;
                                if (description.length() > 0) {
                                    jsdocBuilder.recordThrowDescription(type, description);
                                }
                                token = descriptionInfo.token;
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter annotation.
                                        // It makes no sense under our type system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, lineno, charno);
                                // Find the parameter's description (if applicable).
                                ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                String paramDescription = paramDescriptionInfo.string;
                                if (paramDescription.length() > 0) {
                                    jsdocBuilder.recordParameterDescription(name, paramDescription);
                                }
                                token = paramDescriptionInfo.token;
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PRIVATE:
                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                    parser.addWarning(""msg.jsdoc.visibility.private"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PROTECTED:
                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                    parser.addWarning(""msg.jsdoc.visibility.protected"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PUBLIC:
                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                    parser.addWarning(""msg.jsdoc.visibility.public"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                ExtractionInfo referenceInfo = extractSingleLineBlock();
                                String reference = referenceInfo.string;
                                if (reference.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addReference(reference);
                                }
                                token = referenceInfo.token;
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                ExtractionInfo templateInfo = extractSingleLineBlock();
                                String templateTypeName = templateInfo.string;
                                if (templateTypeName.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
                                    parser.addWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                }
                                token = templateInfo.token;
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case DEFINE:
                            case RETURN:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                skipEOLs();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                token = next();
                                Node typeNode = parseAndRecordTypeNode(token, lineno, charno);
                                if (annotation == Annotation.THIS) {
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && token != JsDocToken.LC) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                }
                                type = createJSTypeExpression(typeNode);
                                if (type == null) {
                                    // error reported during recursive descent
                                    // recovering parsing
                                } else {
                                    switch(annotation) {
                                        case DEFINE:
                                            if (!isValidDefineType(typeNode)) {
                                                parser.addWarning(""msg.jsdoc.define.badtype"", lineno, charno);
                                            } else if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // *Update* the token to that after the type annotation.
                                            token = current();
                                            // Find the return's description (if applicable).
                                            ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                            String returnDescription = returnDescriptionInfo.string;
                                            if (returnDescription.length() > 0) {
                                                jsdocBuilder.recordReturnDescription(returnDescription);
                                            }
                                            token = returnDescriptionInfo.token;
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPE:
                                            if (!jsdocBuilder.recordType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                    token = eatTokensUntilEOL();
                                }
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test1414() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""[JVqvaConstructfrc "");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    ErrorCollector errorCollector0 = new ErrorCollector();
    Config config0 = new Config((JSTypeRegistry) null, linkedHashSet0, true);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, ""[JVqvaConstructfrc "", config0, errorCollector0);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.mozilla.rhino.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    JsDocToken token = next();
    ExtractionInfo blockInfo = extractBlockComment(token);
    token = blockInfo.token;
    // If we have a block level comment, record it.
    if (blockInfo.string.length() > 0) {
        jsdocBuilder.recordBlockDescription(blockInfo.string);
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case AUTHOR:
                                ExtractionInfo authorInfo = extractSingleLineBlock();
                                String author = authorInfo.string;
                                if (author.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addAuthor(author);
                                }
                                token = authorInfo.token;
                                continue retry;
                            case CONSTANT:
                                if (!jsdocBuilder.recordConstancy()) {
                                    parser.addWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                String fileOverview = fileOverviewInfo.string;
                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
                                    parser.addWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                token = fileOverviewInfo.token;
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && !matchingRc) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        if (!jsdocBuilder.recordBaseType(type)) {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                String description = descriptionInfo.string;
                                if (description.length() > 0) {
                                    jsdocBuilder.recordThrowDescription(type, description);
                                }
                                token = descriptionInfo.token;
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter annotation.
                                        // It makes no sense under our type system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, lineno, charno);
                                // Find the parameter's description (if applicable).
                                ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                String paramDescription = paramDescriptionInfo.string;
                                if (paramDescription.length() > 0) {
                                    jsdocBuilder.recordParameterDescription(name, paramDescription);
                                }
                                token = paramDescriptionInfo.token;
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PRIVATE:
                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                    parser.addWarning(""msg.jsdoc.visibility.private"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PROTECTED:
                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                    parser.addWarning(""msg.jsdoc.visibility.protected"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PUBLIC:
                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                    parser.addWarning(""msg.jsdoc.visibility.public"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                ExtractionInfo referenceInfo = extractSingleLineBlock();
                                String reference = referenceInfo.string;
                                if (reference.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addReference(reference);
                                }
                                token = referenceInfo.token;
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                ExtractionInfo templateInfo = extractSingleLineBlock();
                                String templateTypeName = templateInfo.string;
                                if (templateTypeName.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
                                    parser.addWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                }
                                token = templateInfo.token;
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case DEFINE:
                            case RETURN:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                skipEOLs();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                token = next();
                                Node typeNode = parseAndRecordTypeNode(token, lineno, charno);
                                if (annotation == Annotation.THIS) {
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && token != JsDocToken.LC) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                }
                                type = createJSTypeExpression(typeNode);
                                if (type == null) {
                                    // error reported during recursive descent
                                    // recovering parsing
                                } else {
                                    switch(annotation) {
                                        case DEFINE:
                                            if (!isValidDefineType(typeNode)) {
                                                parser.addWarning(""msg.jsdoc.define.badtype"", lineno, charno);
                                            } else if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // *Update* the token to that after the type annotation.
                                            token = current();
                                            // Find the return's description (if applicable).
                                            ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                            String returnDescription = returnDescriptionInfo.string;
                                            if (returnDescription.length() > 0) {
                                                jsdocBuilder.recordReturnDescription(returnDescription);
                                            }
                                            token = returnDescriptionInfo.token;
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPE:
                                            if (!jsdocBuilder.recordType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                    token = eatTokensUntilEOL();
                                }
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test1515() throws Throwable {
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    ErrorCollector errorCollector0 = new ErrorCollector();
    Config config0 = new Config((JSTypeRegistry) null, linkedHashSet0, true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""{jtb<maUx_3>%"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, ""{jtb<maUx_3>%"", config0, errorCollector0);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.mozilla.rhino.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    JsDocToken token = next();
    ExtractionInfo blockInfo = extractBlockComment(token);
    token = blockInfo.token;
    // If we have a block level comment, record it.
    if (blockInfo.string.length() > 0) {
        jsdocBuilder.recordBlockDescription(blockInfo.string);
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case AUTHOR:
                                ExtractionInfo authorInfo = extractSingleLineBlock();
                                String author = authorInfo.string;
                                if (author.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addAuthor(author);
                                }
                                token = authorInfo.token;
                                continue retry;
                            case CONSTANT:
                                if (!jsdocBuilder.recordConstancy()) {
                                    parser.addWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                String fileOverview = fileOverviewInfo.string;
                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
                                    parser.addWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                token = fileOverviewInfo.token;
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && !matchingRc) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        if (!jsdocBuilder.recordBaseType(type)) {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                String description = descriptionInfo.string;
                                if (description.length() > 0) {
                                    jsdocBuilder.recordThrowDescription(type, description);
                                }
                                token = descriptionInfo.token;
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter annotation.
                                        // It makes no sense under our type system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, lineno, charno);
                                // Find the parameter's description (if applicable).
                                ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                String paramDescription = paramDescriptionInfo.string;
                                if (paramDescription.length() > 0) {
                                    jsdocBuilder.recordParameterDescription(name, paramDescription);
                                }
                                token = paramDescriptionInfo.token;
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PRIVATE:
                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                    parser.addWarning(""msg.jsdoc.visibility.private"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PROTECTED:
                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                    parser.addWarning(""msg.jsdoc.visibility.protected"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PUBLIC:
                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                    parser.addWarning(""msg.jsdoc.visibility.public"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                ExtractionInfo referenceInfo = extractSingleLineBlock();
                                String reference = referenceInfo.string;
                                if (reference.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addReference(reference);
                                }
                                token = referenceInfo.token;
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                ExtractionInfo templateInfo = extractSingleLineBlock();
                                String templateTypeName = templateInfo.string;
                                if (templateTypeName.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
                                    parser.addWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                }
                                token = templateInfo.token;
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case DEFINE:
                            case RETURN:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                skipEOLs();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                token = next();
                                Node typeNode = parseAndRecordTypeNode(token, lineno, charno);
                                if (annotation == Annotation.THIS) {
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && token != JsDocToken.LC) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                }
                                type = createJSTypeExpression(typeNode);
                                if (type == null) {
                                    // error reported during recursive descent
                                    // recovering parsing
                                } else {
                                    switch(annotation) {
                                        case DEFINE:
                                            if (!isValidDefineType(typeNode)) {
                                                parser.addWarning(""msg.jsdoc.define.badtype"", lineno, charno);
                                            } else if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // *Update* the token to that after the type annotation.
                                            token = current();
                                            // Find the return's description (if applicable).
                                            ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                            String returnDescription = returnDescriptionInfo.string;
                                            if (returnDescription.length() > 0) {
                                                jsdocBuilder.recordReturnDescription(returnDescription);
                                            }
                                            token = returnDescriptionInfo.token;
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPE:
                                            if (!jsdocBuilder.recordType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                    token = eatTokensUntilEOL();
                                }
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test1616() throws Throwable {
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    ErrorCollector errorCollector0 = new ErrorCollector();
    Config config0 = new Config((JSTypeRegistry) null, linkedHashSet0, false);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""(L,VC!F"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, ""(L,VC!F"", config0, errorCollector0);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.mozilla.rhino.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    JsDocToken token = next();
    ExtractionInfo blockInfo = extractBlockComment(token);
    token = blockInfo.token;
    // If we have a block level comment, record it.
    if (blockInfo.string.length() > 0) {
        jsdocBuilder.recordBlockDescription(blockInfo.string);
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case AUTHOR:
                                ExtractionInfo authorInfo = extractSingleLineBlock();
                                String author = authorInfo.string;
                                if (author.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addAuthor(author);
                                }
                                token = authorInfo.token;
                                continue retry;
                            case CONSTANT:
                                if (!jsdocBuilder.recordConstancy()) {
                                    parser.addWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                String fileOverview = fileOverviewInfo.string;
                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
                                    parser.addWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                token = fileOverviewInfo.token;
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && !matchingRc) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        if (!jsdocBuilder.recordBaseType(type)) {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                String description = descriptionInfo.string;
                                if (description.length() > 0) {
                                    jsdocBuilder.recordThrowDescription(type, description);
                                }
                                token = descriptionInfo.token;
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter annotation.
                                        // It makes no sense under our type system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, lineno, charno);
                                // Find the parameter's description (if applicable).
                                ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                String paramDescription = paramDescriptionInfo.string;
                                if (paramDescription.length() > 0) {
                                    jsdocBuilder.recordParameterDescription(name, paramDescription);
                                }
                                token = paramDescriptionInfo.token;
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PRIVATE:
                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                    parser.addWarning(""msg.jsdoc.visibility.private"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PROTECTED:
                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                    parser.addWarning(""msg.jsdoc.visibility.protected"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PUBLIC:
                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                    parser.addWarning(""msg.jsdoc.visibility.public"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                ExtractionInfo referenceInfo = extractSingleLineBlock();
                                String reference = referenceInfo.string;
                                if (reference.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addReference(reference);
                                }
                                token = referenceInfo.token;
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                ExtractionInfo templateInfo = extractSingleLineBlock();
                                String templateTypeName = templateInfo.string;
                                if (templateTypeName.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
                                    parser.addWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                }
                                token = templateInfo.token;
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case DEFINE:
                            case RETURN:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                skipEOLs();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                token = next();
                                Node typeNode = parseAndRecordTypeNode(token, lineno, charno);
                                if (annotation == Annotation.THIS) {
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && token != JsDocToken.LC) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                }
                                type = createJSTypeExpression(typeNode);
                                if (type == null) {
                                    // error reported during recursive descent
                                    // recovering parsing
                                } else {
                                    switch(annotation) {
                                        case DEFINE:
                                            if (!isValidDefineType(typeNode)) {
                                                parser.addWarning(""msg.jsdoc.define.badtype"", lineno, charno);
                                            } else if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // *Update* the token to that after the type annotation.
                                            token = current();
                                            // Find the return's description (if applicable).
                                            ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                            String returnDescription = returnDescriptionInfo.string;
                                            if (returnDescription.length() > 0) {
                                                jsdocBuilder.recordReturnDescription(returnDescription);
                                            }
                                            token = returnDescriptionInfo.token;
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPE:
                                            if (!jsdocBuilder.recordType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                    token = eatTokensUntilEOL();
                                }
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test1717() throws Throwable {
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""?o+6m\""KHvS"");
    Config config0 = new Config((JSTypeRegistry) null, linkedHashSet0, false);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, ""?o+6m\""KHvS"", config0, (ErrorReporter) null);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.parsing.JsDocInfoParser$ErrorReporterParser"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    JsDocToken token = next();
    ExtractionInfo blockInfo = extractBlockComment(token);
    token = blockInfo.token;
    // If we have a block level comment, record it.
    if (blockInfo.string.length() > 0) {
        jsdocBuilder.recordBlockDescription(blockInfo.string);
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case AUTHOR:
                                ExtractionInfo authorInfo = extractSingleLineBlock();
                                String author = authorInfo.string;
                                if (author.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addAuthor(author);
                                }
                                token = authorInfo.token;
                                continue retry;
                            case CONSTANT:
                                if (!jsdocBuilder.recordConstancy()) {
                                    parser.addWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                String fileOverview = fileOverviewInfo.string;
                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
                                    parser.addWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                token = fileOverviewInfo.token;
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && !matchingRc) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        if (!jsdocBuilder.recordBaseType(type)) {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                String description = descriptionInfo.string;
                                if (description.length() > 0) {
                                    jsdocBuilder.recordThrowDescription(type, description);
                                }
                                token = descriptionInfo.token;
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter annotation.
                                        // It makes no sense under our type system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, lineno, charno);
                                // Find the parameter's description (if applicable).
                                ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                String paramDescription = paramDescriptionInfo.string;
                                if (paramDescription.length() > 0) {
                                    jsdocBuilder.recordParameterDescription(name, paramDescription);
                                }
                                token = paramDescriptionInfo.token;
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PRIVATE:
                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                    parser.addWarning(""msg.jsdoc.visibility.private"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PROTECTED:
                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                    parser.addWarning(""msg.jsdoc.visibility.protected"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PUBLIC:
                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                    parser.addWarning(""msg.jsdoc.visibility.public"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                ExtractionInfo referenceInfo = extractSingleLineBlock();
                                String reference = referenceInfo.string;
                                if (reference.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addReference(reference);
                                }
                                token = referenceInfo.token;
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                ExtractionInfo templateInfo = extractSingleLineBlock();
                                String templateTypeName = templateInfo.string;
                                if (templateTypeName.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
                                    parser.addWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                }
                                token = templateInfo.token;
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case DEFINE:
                            case RETURN:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                skipEOLs();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                token = next();
                                Node typeNode = parseAndRecordTypeNode(token, lineno, charno);
                                if (annotation == Annotation.THIS) {
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && token != JsDocToken.LC) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                }
                                type = createJSTypeExpression(typeNode);
                                if (type == null) {
                                    // error reported during recursive descent
                                    // recovering parsing
                                } else {
                                    switch(annotation) {
                                        case DEFINE:
                                            if (!isValidDefineType(typeNode)) {
                                                parser.addWarning(""msg.jsdoc.define.badtype"", lineno, charno);
                                            } else if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // *Update* the token to that after the type annotation.
                                            token = current();
                                            // Find the return's description (if applicable).
                                            ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                            String returnDescription = returnDescriptionInfo.string;
                                            if (returnDescription.length() > 0) {
                                                jsdocBuilder.recordReturnDescription(returnDescription);
                                            }
                                            token = returnDescriptionInfo.token;
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPE:
                                            if (!jsdocBuilder.recordType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                    token = eatTokensUntilEOL();
                                }
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test1818() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""|c+F#6epY-0''knu78"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    ErrorCollector errorCollector0 = new ErrorCollector();
    Config config0 = new Config((JSTypeRegistry) null, linkedHashSet0, false);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, ""|c+F#6epY-0''knu78"", config0, errorCollector0);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.mozilla.rhino.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    JsDocToken token = next();
    ExtractionInfo blockInfo = extractBlockComment(token);
    token = blockInfo.token;
    // If we have a block level comment, record it.
    if (blockInfo.string.length() > 0) {
        jsdocBuilder.recordBlockDescription(blockInfo.string);
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case AUTHOR:
                                ExtractionInfo authorInfo = extractSingleLineBlock();
                                String author = authorInfo.string;
                                if (author.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addAuthor(author);
                                }
                                token = authorInfo.token;
                                continue retry;
                            case CONSTANT:
                                if (!jsdocBuilder.recordConstancy()) {
                                    parser.addWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                String fileOverview = fileOverviewInfo.string;
                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
                                    parser.addWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                token = fileOverviewInfo.token;
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && !matchingRc) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        if (!jsdocBuilder.recordBaseType(type)) {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                String description = descriptionInfo.string;
                                if (description.length() > 0) {
                                    jsdocBuilder.recordThrowDescription(type, description);
                                }
                                token = descriptionInfo.token;
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter annotation.
                                        // It makes no sense under our type system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, lineno, charno);
                                // Find the parameter's description (if applicable).
                                ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                String paramDescription = paramDescriptionInfo.string;
                                if (paramDescription.length() > 0) {
                                    jsdocBuilder.recordParameterDescription(name, paramDescription);
                                }
                                token = paramDescriptionInfo.token;
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PRIVATE:
                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                    parser.addWarning(""msg.jsdoc.visibility.private"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PROTECTED:
                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                    parser.addWarning(""msg.jsdoc.visibility.protected"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PUBLIC:
                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                    parser.addWarning(""msg.jsdoc.visibility.public"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                ExtractionInfo referenceInfo = extractSingleLineBlock();
                                String reference = referenceInfo.string;
                                if (reference.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addReference(reference);
                                }
                                token = referenceInfo.token;
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                ExtractionInfo templateInfo = extractSingleLineBlock();
                                String templateTypeName = templateInfo.string;
                                if (templateTypeName.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
                                    parser.addWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                }
                                token = templateInfo.token;
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case DEFINE:
                            case RETURN:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                skipEOLs();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                token = next();
                                Node typeNode = parseAndRecordTypeNode(token, lineno, charno);
                                if (annotation == Annotation.THIS) {
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && token != JsDocToken.LC) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                }
                                type = createJSTypeExpression(typeNode);
                                if (type == null) {
                                    // error reported during recursive descent
                                    // recovering parsing
                                } else {
                                    switch(annotation) {
                                        case DEFINE:
                                            if (!isValidDefineType(typeNode)) {
                                                parser.addWarning(""msg.jsdoc.define.badtype"", lineno, charno);
                                            } else if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // *Update* the token to that after the type annotation.
                                            token = current();
                                            // Find the return's description (if applicable).
                                            ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                            String returnDescription = returnDescriptionInfo.string;
                                            if (returnDescription.length() > 0) {
                                                jsdocBuilder.recordReturnDescription(returnDescription);
                                            }
                                            token = returnDescriptionInfo.token;
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPE:
                                            if (!jsdocBuilder.recordType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                    token = eatTokensUntilEOL();
                                }
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test1919() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""];ejT0&zo~}"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config config0 = new Config((JSTypeRegistry) null, linkedHashSet0, true);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, ""];ejT0&zo~}"", config0, (ErrorReporter) null);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.parsing.JsDocInfoParser$ErrorReporterParser"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    JsDocToken token = next();
    ExtractionInfo blockInfo = extractBlockComment(token);
    token = blockInfo.token;
    // If we have a block level comment, record it.
    if (blockInfo.string.length() > 0) {
        jsdocBuilder.recordBlockDescription(blockInfo.string);
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case AUTHOR:
                                ExtractionInfo authorInfo = extractSingleLineBlock();
                                String author = authorInfo.string;
                                if (author.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addAuthor(author);
                                }
                                token = authorInfo.token;
                                continue retry;
                            case CONSTANT:
                                if (!jsdocBuilder.recordConstancy()) {
                                    parser.addWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                String fileOverview = fileOverviewInfo.string;
                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
                                    parser.addWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                token = fileOverviewInfo.token;
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && !matchingRc) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        if (!jsdocBuilder.recordBaseType(type)) {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                String description = descriptionInfo.string;
                                if (description.length() > 0) {
                                    jsdocBuilder.recordThrowDescription(type, description);
                                }
                                token = descriptionInfo.token;
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter annotation.
                                        // It makes no sense under our type system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, lineno, charno);
                                // Find the parameter's description (if applicable).
                                ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                String paramDescription = paramDescriptionInfo.string;
                                if (paramDescription.length() > 0) {
                                    jsdocBuilder.recordParameterDescription(name, paramDescription);
                                }
                                token = paramDescriptionInfo.token;
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PRIVATE:
                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                    parser.addWarning(""msg.jsdoc.visibility.private"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PROTECTED:
                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                    parser.addWarning(""msg.jsdoc.visibility.protected"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PUBLIC:
                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                    parser.addWarning(""msg.jsdoc.visibility.public"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                ExtractionInfo referenceInfo = extractSingleLineBlock();
                                String reference = referenceInfo.string;
                                if (reference.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addReference(reference);
                                }
                                token = referenceInfo.token;
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                ExtractionInfo templateInfo = extractSingleLineBlock();
                                String templateTypeName = templateInfo.string;
                                if (templateTypeName.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
                                    parser.addWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                }
                                token = templateInfo.token;
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case DEFINE:
                            case RETURN:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                skipEOLs();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                token = next();
                                Node typeNode = parseAndRecordTypeNode(token, lineno, charno);
                                if (annotation == Annotation.THIS) {
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && token != JsDocToken.LC) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                }
                                type = createJSTypeExpression(typeNode);
                                if (type == null) {
                                    // error reported during recursive descent
                                    // recovering parsing
                                } else {
                                    switch(annotation) {
                                        case DEFINE:
                                            if (!isValidDefineType(typeNode)) {
                                                parser.addWarning(""msg.jsdoc.define.badtype"", lineno, charno);
                                            } else if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // *Update* the token to that after the type annotation.
                                            token = current();
                                            // Find the return's description (if applicable).
                                            ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                            String returnDescription = returnDescriptionInfo.string;
                                            if (returnDescription.length() > 0) {
                                                jsdocBuilder.recordReturnDescription(returnDescription);
                                            }
                                            token = returnDescriptionInfo.token;
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPE:
                                            if (!jsdocBuilder.recordType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                    token = eatTokensUntilEOL();
                                }
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test2020() throws Throwable {
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    ErrorCollector errorCollector0 = new ErrorCollector();
    Config config0 = new Config((JSTypeRegistry) null, linkedHashSet0, false);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""}i_s-.{*+lkNC^"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, ""}i_s-.{*+lkNC^"", config0, errorCollector0);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.mozilla.rhino.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    JsDocToken token = next();
    ExtractionInfo blockInfo = extractBlockComment(token);
    token = blockInfo.token;
    // If we have a block level comment, record it.
    if (blockInfo.string.length() > 0) {
        jsdocBuilder.recordBlockDescription(blockInfo.string);
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case AUTHOR:
                                ExtractionInfo authorInfo = extractSingleLineBlock();
                                String author = authorInfo.string;
                                if (author.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addAuthor(author);
                                }
                                token = authorInfo.token;
                                continue retry;
                            case CONSTANT:
                                if (!jsdocBuilder.recordConstancy()) {
                                    parser.addWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                String fileOverview = fileOverviewInfo.string;
                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
                                    parser.addWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                token = fileOverviewInfo.token;
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && !matchingRc) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        if (!jsdocBuilder.recordBaseType(type)) {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                String description = descriptionInfo.string;
                                if (description.length() > 0) {
                                    jsdocBuilder.recordThrowDescription(type, description);
                                }
                                token = descriptionInfo.token;
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter annotation.
                                        // It makes no sense under our type system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, lineno, charno);
                                // Find the parameter's description (if applicable).
                                ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                String paramDescription = paramDescriptionInfo.string;
                                if (paramDescription.length() > 0) {
                                    jsdocBuilder.recordParameterDescription(name, paramDescription);
                                }
                                token = paramDescriptionInfo.token;
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PRIVATE:
                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                    parser.addWarning(""msg.jsdoc.visibility.private"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PROTECTED:
                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                    parser.addWarning(""msg.jsdoc.visibility.protected"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PUBLIC:
                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                    parser.addWarning(""msg.jsdoc.visibility.public"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                ExtractionInfo referenceInfo = extractSingleLineBlock();
                                String reference = referenceInfo.string;
                                if (reference.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addReference(reference);
                                }
                                token = referenceInfo.token;
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                ExtractionInfo templateInfo = extractSingleLineBlock();
                                String templateTypeName = templateInfo.string;
                                if (templateTypeName.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
                                    parser.addWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                }
                                token = templateInfo.token;
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case DEFINE:
                            case RETURN:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                skipEOLs();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                token = next();
                                Node typeNode = parseAndRecordTypeNode(token, lineno, charno);
                                if (annotation == Annotation.THIS) {
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && token != JsDocToken.LC) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                }
                                type = createJSTypeExpression(typeNode);
                                if (type == null) {
                                    // error reported during recursive descent
                                    // recovering parsing
                                } else {
                                    switch(annotation) {
                                        case DEFINE:
                                            if (!isValidDefineType(typeNode)) {
                                                parser.addWarning(""msg.jsdoc.define.badtype"", lineno, charno);
                                            } else if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // *Update* the token to that after the type annotation.
                                            token = current();
                                            // Find the return's description (if applicable).
                                            ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                            String returnDescription = returnDescriptionInfo.string;
                                            if (returnDescription.length() > 0) {
                                                jsdocBuilder.recordReturnDescription(returnDescription);
                                            }
                                            token = returnDescriptionInfo.token;
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPE:
                                            if (!jsdocBuilder.recordType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                    token = eatTokensUntilEOL();
                                }
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test2121() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream("")c)TF#69pYJ-D''kn78"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    ErrorCollector errorCollector0 = new ErrorCollector();
    Config config0 = new Config((JSTypeRegistry) null, linkedHashSet0, true);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, "")c)TF#69pYJ-D''kn78"", config0, errorCollector0);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.mozilla.rhino.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    JsDocToken token = next();
    ExtractionInfo blockInfo = extractBlockComment(token);
    token = blockInfo.token;
    // If we have a block level comment, record it.
    if (blockInfo.string.length() > 0) {
        jsdocBuilder.recordBlockDescription(blockInfo.string);
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case AUTHOR:
                                ExtractionInfo authorInfo = extractSingleLineBlock();
                                String author = authorInfo.string;
                                if (author.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addAuthor(author);
                                }
                                token = authorInfo.token;
                                continue retry;
                            case CONSTANT:
                                if (!jsdocBuilder.recordConstancy()) {
                                    parser.addWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                String fileOverview = fileOverviewInfo.string;
                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
                                    parser.addWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                token = fileOverviewInfo.token;
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && !matchingRc) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        if (!jsdocBuilder.recordBaseType(type)) {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                String description = descriptionInfo.string;
                                if (description.length() > 0) {
                                    jsdocBuilder.recordThrowDescription(type, description);
                                }
                                token = descriptionInfo.token;
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter annotation.
                                        // It makes no sense under our type system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, lineno, charno);
                                // Find the parameter's description (if applicable).
                                ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                String paramDescription = paramDescriptionInfo.string;
                                if (paramDescription.length() > 0) {
                                    jsdocBuilder.recordParameterDescription(name, paramDescription);
                                }
                                token = paramDescriptionInfo.token;
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PRIVATE:
                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                    parser.addWarning(""msg.jsdoc.visibility.private"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PROTECTED:
                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                    parser.addWarning(""msg.jsdoc.visibility.protected"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PUBLIC:
                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                    parser.addWarning(""msg.jsdoc.visibility.public"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                ExtractionInfo referenceInfo = extractSingleLineBlock();
                                String reference = referenceInfo.string;
                                if (reference.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addReference(reference);
                                }
                                token = referenceInfo.token;
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                ExtractionInfo templateInfo = extractSingleLineBlock();
                                String templateTypeName = templateInfo.string;
                                if (templateTypeName.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
                                    parser.addWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                }
                                token = templateInfo.token;
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case DEFINE:
                            case RETURN:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                skipEOLs();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                token = next();
                                Node typeNode = parseAndRecordTypeNode(token, lineno, charno);
                                if (annotation == Annotation.THIS) {
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && token != JsDocToken.LC) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                }
                                type = createJSTypeExpression(typeNode);
                                if (type == null) {
                                    // error reported during recursive descent
                                    // recovering parsing
                                } else {
                                    switch(annotation) {
                                        case DEFINE:
                                            if (!isValidDefineType(typeNode)) {
                                                parser.addWarning(""msg.jsdoc.define.badtype"", lineno, charno);
                                            } else if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // *Update* the token to that after the type annotation.
                                            token = current();
                                            // Find the return's description (if applicable).
                                            ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                            String returnDescription = returnDescriptionInfo.string;
                                            if (returnDescription.length() > 0) {
                                                jsdocBuilder.recordReturnDescription(returnDescription);
                                            }
                                            token = returnDescriptionInfo.token;
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPE:
                                            if (!jsdocBuilder.recordType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                    token = eatTokensUntilEOL();
                                }
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test2222() throws Throwable {
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""..."");
    Config config0 = new Config((JSTypeRegistry) null, linkedHashSet0, false);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, ""..."", config0, (ErrorReporter) null);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.parsing.JsDocInfoParser$ErrorReporterParser"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    JsDocToken token = next();
    ExtractionInfo blockInfo = extractBlockComment(token);
    token = blockInfo.token;
    // If we have a block level comment, record it.
    if (blockInfo.string.length() > 0) {
        jsdocBuilder.recordBlockDescription(blockInfo.string);
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case AUTHOR:
                                ExtractionInfo authorInfo = extractSingleLineBlock();
                                String author = authorInfo.string;
                                if (author.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addAuthor(author);
                                }
                                token = authorInfo.token;
                                continue retry;
                            case CONSTANT:
                                if (!jsdocBuilder.recordConstancy()) {
                                    parser.addWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                String fileOverview = fileOverviewInfo.string;
                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
                                    parser.addWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                token = fileOverviewInfo.token;
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && !matchingRc) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        if (!jsdocBuilder.recordBaseType(type)) {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                String description = descriptionInfo.string;
                                if (description.length() > 0) {
                                    jsdocBuilder.recordThrowDescription(type, description);
                                }
                                token = descriptionInfo.token;
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter annotation.
                                        // It makes no sense under our type system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, lineno, charno);
                                // Find the parameter's description (if applicable).
                                ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                String paramDescription = paramDescriptionInfo.string;
                                if (paramDescription.length() > 0) {
                                    jsdocBuilder.recordParameterDescription(name, paramDescription);
                                }
                                token = paramDescriptionInfo.token;
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PRIVATE:
                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                    parser.addWarning(""msg.jsdoc.visibility.private"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PROTECTED:
                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                    parser.addWarning(""msg.jsdoc.visibility.protected"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PUBLIC:
                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                    parser.addWarning(""msg.jsdoc.visibility.public"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                ExtractionInfo referenceInfo = extractSingleLineBlock();
                                String reference = referenceInfo.string;
                                if (reference.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addReference(reference);
                                }
                                token = referenceInfo.token;
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                ExtractionInfo templateInfo = extractSingleLineBlock();
                                String templateTypeName = templateInfo.string;
                                if (templateTypeName.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
                                    parser.addWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                }
                                token = templateInfo.token;
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case DEFINE:
                            case RETURN:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                skipEOLs();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                token = next();
                                Node typeNode = parseAndRecordTypeNode(token, lineno, charno);
                                if (annotation == Annotation.THIS) {
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && token != JsDocToken.LC) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                }
                                type = createJSTypeExpression(typeNode);
                                if (type == null) {
                                    // error reported during recursive descent
                                    // recovering parsing
                                } else {
                                    switch(annotation) {
                                        case DEFINE:
                                            if (!isValidDefineType(typeNode)) {
                                                parser.addWarning(""msg.jsdoc.define.badtype"", lineno, charno);
                                            } else if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // *Update* the token to that after the type annotation.
                                            token = current();
                                            // Find the return's description (if applicable).
                                            ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                            String returnDescription = returnDescriptionInfo.string;
                                            if (returnDescription.length() > 0) {
                                                jsdocBuilder.recordReturnDescription(returnDescription);
                                            }
                                            token = returnDescriptionInfo.token;
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPE:
                                            if (!jsdocBuilder.recordType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                    token = eatTokensUntilEOL();
                                }
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test2323() throws Throwable {
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config config0 = new Config((JSTypeRegistry) null, linkedHashSet0, false);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""=V8yK\""0RF[?F]z"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, ""=V8yK\""0RF[?F]z"", config0, (ErrorReporter) null);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.parsing.JsDocInfoParser$ErrorReporterParser"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    JsDocToken token = next();
    ExtractionInfo blockInfo = extractBlockComment(token);
    token = blockInfo.token;
    // If we have a block level comment, record it.
    if (blockInfo.string.length() > 0) {
        jsdocBuilder.recordBlockDescription(blockInfo.string);
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case AUTHOR:
                                ExtractionInfo authorInfo = extractSingleLineBlock();
                                String author = authorInfo.string;
                                if (author.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addAuthor(author);
                                }
                                token = authorInfo.token;
                                continue retry;
                            case CONSTANT:
                                if (!jsdocBuilder.recordConstancy()) {
                                    parser.addWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                String fileOverview = fileOverviewInfo.string;
                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
                                    parser.addWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                token = fileOverviewInfo.token;
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && !matchingRc) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        if (!jsdocBuilder.recordBaseType(type)) {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                String description = descriptionInfo.string;
                                if (description.length() > 0) {
                                    jsdocBuilder.recordThrowDescription(type, description);
                                }
                                token = descriptionInfo.token;
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter annotation.
                                        // It makes no sense under our type system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, lineno, charno);
                                // Find the parameter's description (if applicable).
                                ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                String paramDescription = paramDescriptionInfo.string;
                                if (paramDescription.length() > 0) {
                                    jsdocBuilder.recordParameterDescription(name, paramDescription);
                                }
                                token = paramDescriptionInfo.token;
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PRIVATE:
                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                    parser.addWarning(""msg.jsdoc.visibility.private"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PROTECTED:
                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                    parser.addWarning(""msg.jsdoc.visibility.protected"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PUBLIC:
                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                    parser.addWarning(""msg.jsdoc.visibility.public"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                ExtractionInfo referenceInfo = extractSingleLineBlock();
                                String reference = referenceInfo.string;
                                if (reference.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addReference(reference);
                                }
                                token = referenceInfo.token;
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                ExtractionInfo templateInfo = extractSingleLineBlock();
                                String templateTypeName = templateInfo.string;
                                if (templateTypeName.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
                                    parser.addWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                }
                                token = templateInfo.token;
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case DEFINE:
                            case RETURN:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                skipEOLs();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                token = next();
                                Node typeNode = parseAndRecordTypeNode(token, lineno, charno);
                                if (annotation == Annotation.THIS) {
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && token != JsDocToken.LC) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                }
                                type = createJSTypeExpression(typeNode);
                                if (type == null) {
                                    // error reported during recursive descent
                                    // recovering parsing
                                } else {
                                    switch(annotation) {
                                        case DEFINE:
                                            if (!isValidDefineType(typeNode)) {
                                                parser.addWarning(""msg.jsdoc.define.badtype"", lineno, charno);
                                            } else if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // *Update* the token to that after the type annotation.
                                            token = current();
                                            // Find the return's description (if applicable).
                                            ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                            String returnDescription = returnDescriptionInfo.string;
                                            if (returnDescription.length() > 0) {
                                                jsdocBuilder.recordReturnDescription(returnDescription);
                                            }
                                            token = returnDescriptionInfo.token;
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPE:
                                            if (!jsdocBuilder.recordType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                    token = eatTokensUntilEOL();
                                }
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test2424() throws Throwable {
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""*Y@pv4<=M2C"");
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    ErrorCollector errorCollector0 = new ErrorCollector();
    Config config0 = new Config((JSTypeRegistry) null, linkedHashSet0, true);
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, ""*Y@pv4<=M2C"", config0, errorCollector0);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: UnsupportedOperationException"");
    } catch (UnsupportedOperationException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.mozilla.rhino.ast.ErrorCollector"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"boolean parse() {
    int lineno;
    int charno;
    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;
    state = State.SEARCHING_ANNOTATION;
    JsDocToken token = next();
    ExtractionInfo blockInfo = extractBlockComment(token);
    token = blockInfo.token;
    // If we have a block level comment, record it.
    if (blockInfo.string.length() > 0) {
        jsdocBuilder.recordBlockDescription(blockInfo.string);
    }
    // Parse the actual JsDoc.
    retry: for (; ; ) {
        switch(token) {
            case ANNOTATION:
                if (state == State.SEARCHING_ANNOTATION) {
                    state = State.SEARCHING_NEWLINE;
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                    String annotationName = stream.getString();
                    Annotation annotation = annotationNames.get(annotationName);
                    if (annotation == null) {
                        parser.addWarning(""msg.bad.jsdoc.tag"", annotationName, stream.getLineno(), stream.getCharno());
                    } else {
                        // Mark the beginning of the annotation.
                        jsdocBuilder.markAnnotation(annotationName, lineno, charno);
                        switch(annotation) {
                            case AUTHOR:
                                ExtractionInfo authorInfo = extractSingleLineBlock();
                                String author = authorInfo.string;
                                if (author.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.authormissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addAuthor(author);
                                }
                                token = authorInfo.token;
                                continue retry;
                            case CONSTANT:
                                if (!jsdocBuilder.recordConstancy()) {
                                    parser.addWarning(""msg.jsdoc.const"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case CONSTRUCTOR:
                                if (!jsdocBuilder.recordConstructor()) {
                                    if (jsdocBuilder.isInterfaceRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DEPRECATED:
                                if (!jsdocBuilder.recordDeprecated()) {
                                    parser.addWarning(""msg.jsdoc.deprecated"", stream.getLineno(), stream.getCharno());
                                }
                                // Find the reason/description, if any.
                                ExtractionInfo reasonInfo = extractMultilineTextualBlock(token);
                                String reason = reasonInfo.string;
                                if (reason.length() > 0) {
                                    jsdocBuilder.recordDeprecationReason(reason);
                                }
                                token = reasonInfo.token;
                                continue retry;
                            case INTERFACE:
                                if (!jsdocBuilder.recordInterface()) {
                                    if (jsdocBuilder.isConstructorRecorded()) {
                                        parser.addWarning(""msg.jsdoc.interface.constructor"", stream.getLineno(), stream.getCharno());
                                    } else {
                                        parser.addWarning(""msg.jsdoc.incompat.type"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case DESC:
                                if (jsdocBuilder.isDescriptionRecorded()) {
                                    parser.addWarning(""msg.jsdoc.desc.extra"", stream.getLineno(), stream.getCharno());
                                    token = eatTokensUntilEOL();
                                    continue retry;
                                } else {
                                    ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                    String description = descriptionInfo.string;
                                    jsdocBuilder.recordDescription(description);
                                    token = descriptionInfo.token;
                                    continue retry;
                                }
                            case FILE_OVERVIEW:
                                ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
                                String fileOverview = fileOverviewInfo.string;
                                if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
                                    parser.addWarning(""msg.jsdoc.fileoverview.extra"", stream.getLineno(), stream.getCharno());
                                }
                                token = fileOverviewInfo.token;
                                continue retry;
                            case LICENSE:
                            case PRESERVE:
                                ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
                                String preserve = preserveInfo.string;
                                if (preserve.length() > 0) {
                                    if (fileLevelJsDocBuilder != null) {
                                        fileLevelJsDocBuilder.append(preserve);
                                    }
                                }
                                token = preserveInfo.token;
                                continue retry;
                            case ENUM:
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                }
                                if (type == null) {
                                    type = createJSTypeExpression(newStringNode(""number""));
                                }
                                if (!jsdocBuilder.recordEnumParameterType(type)) {
                                    parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case EXPORT:
                                if (!jsdocBuilder.recordExport()) {
                                    parser.addWarning(""msg.jsdoc.export"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTERNS:
                                if (!jsdocBuilder.recordExterns()) {
                                    parser.addWarning(""msg.jsdoc.externs"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case JAVA_DISPATCH:
                                if (!jsdocBuilder.recordJavaDispatch()) {
                                    parser.addWarning(""msg.jsdoc.javadispatch"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case EXTENDS:
                            case IMPLEMENTS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                boolean matchingRc = false;
                                if (token == JsDocToken.LC) {
                                    token = next();
                                    matchingRc = true;
                                }
                                if (token == JsDocToken.STRING) {
                                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && !matchingRc) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                    type = createJSTypeExpression(typeNode);
                                    if (annotation == Annotation.EXTENDS) {
                                        if (!jsdocBuilder.recordBaseType(type)) {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                        }
                                    } else {
                                        Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
                                        if (!jsdocBuilder.recordImplementedInterface(type)) {
                                            parser.addWarning(""msg.jsdoc.implements.duplicate"", lineno, charno);
                                        }
                                    }
                                    token = next();
                                    if (matchingRc) {
                                        if (token != JsDocToken.RC) {
                                            parser.addWarning(""msg.jsdoc.missing.rc"", stream.getLineno(), stream.getCharno());
                                        }
                                    } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
                                        parser.addWarning(""msg.end.annotation.expected"", stream.getLineno(), stream.getCharno());
                                    }
                                } else {
                                    parser.addWarning(""msg.no.type.name"", lineno, charno);
                                }
                                token = eatTokensUntilEOL(token);
                                continue retry;
                            case HIDDEN:
                                if (!jsdocBuilder.recordHiddenness()) {
                                    parser.addWarning(""msg.jsdoc.hidden"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_ALIAS:
                                if (!jsdocBuilder.recordNoAlias()) {
                                    parser.addWarning(""msg.jsdoc.noalias"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_TYPE_CHECK:
                                if (!jsdocBuilder.recordNoTypeCheck()) {
                                    parser.addWarning(""msg.jsdoc.nocheck"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NOT_IMPLEMENTED:
                                token = eatTokensUntilEOL();
                                continue retry;
                            case INHERIT_DOC:
                            case OVERRIDE:
                                if (!jsdocBuilder.recordOverride()) {
                                    parser.addWarning(""msg.jsdoc.override"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case THROWS:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                }
                                // *Update* the token to that after the type annotation.
                                token = current();
                                // Save the throw type.
                                jsdocBuilder.recordThrowType(type);
                                // Find the throw's description (if applicable).
                                ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token);
                                String description = descriptionInfo.string;
                                if (description.length() > 0) {
                                    jsdocBuilder.recordThrowDescription(type, description);
                                }
                                token = descriptionInfo.token;
                                continue retry;
                            case PARAM:
                                skipEOLs();
                                token = next();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                type = null;
                                if (token == JsDocToken.LC) {
                                    type = createJSTypeExpression(parseAndRecordParamTypeNode(token));
                                    if (type == null) {
                                        // parsing error reported during recursive descent
                                        // recovering parsing
                                        token = eatTokensUntilEOL();
                                        continue retry;
                                    }
                                    skipEOLs();
                                    token = next();
                                    lineno = stream.getLineno();
                                    charno = stream.getCharno();
                                }
                                String name = null;
                                boolean isBracketedParam = JsDocToken.LB == token;
                                if (isBracketedParam) {
                                    token = next();
                                }
                                if (JsDocToken.STRING != token) {
                                    parser.addWarning(""msg.missing.variable.name"", lineno, charno);
                                } else {
                                    name = stream.getString();
                                    if (isBracketedParam) {
                                        token = next();
                                        // Throw out JsDocToolkit's ""default"" parameter annotation.
                                        // It makes no sense under our type system.
                                        if (JsDocToken.EQUALS == token) {
                                            token = next();
                                            if (JsDocToken.STRING == token) {
                                                token = next();
                                            }
                                        }
                                        if (JsDocToken.RB != token) {
                                            reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                                        } else if (type != null) {
                                            // Make the type expression optional, if it isn't
                                            // already.
                                            type = JSTypeExpression.makeOptionalArg(type);
                                        }
                                    }
                                    // If the param name has a DOT in it, just throw it out
                                    // quietly. We do not handle the JsDocToolkit method
                                    // for handling properties of params.
                                    if (name.indexOf('.') > -1) {
                                        name = null;
                                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                                        if (jsdocBuilder.hasParameter(name)) {
                                            parser.addWarning(""msg.dup.variable.name"", name, lineno, charno);
                                        } else {
                                            parser.addWarning(""msg.jsdoc.incompat.type"", name, lineno, charno);
                                        }
                                    }
                                }
                                if (name == null) {
                                    token = eatTokensUntilEOL(token);
                                    continue retry;
                                }
                                jsdocBuilder.markName(name, lineno, charno);
                                // Find the parameter's description (if applicable).
                                ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token);
                                String paramDescription = paramDescriptionInfo.string;
                                if (paramDescription.length() > 0) {
                                    jsdocBuilder.recordParameterDescription(name, paramDescription);
                                }
                                token = paramDescriptionInfo.token;
                                continue retry;
                            case PRESERVE_TRY:
                                if (!jsdocBuilder.recordPreserveTry()) {
                                    parser.addWarning(""msg.jsdoc.preservertry"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PRIVATE:
                                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                                    parser.addWarning(""msg.jsdoc.visibility.private"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PROTECTED:
                                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                                    parser.addWarning(""msg.jsdoc.visibility.protected"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case PUBLIC:
                                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                                    parser.addWarning(""msg.jsdoc.visibility.public"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SHADOW:
                                if (!jsdocBuilder.recordNoShadow()) {
                                    parser.addWarning(""msg.jsdoc.noshadow"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case NO_SIDE_EFFECTS:
                                if (!jsdocBuilder.recordNoSideEffects()) {
                                    parser.addWarning(""msg.jsdoc.nosideeffects"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case IMPLICIT_CAST:
                                if (!jsdocBuilder.recordImplicitCast()) {
                                    parser.addWarning(""msg.jsdoc.implicitcast"", stream.getLineno(), stream.getCharno());
                                }
                                token = eatTokensUntilEOL();
                                continue retry;
                            case SEE:
                                ExtractionInfo referenceInfo = extractSingleLineBlock();
                                String reference = referenceInfo.string;
                                if (reference.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.seemissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    jsdocBuilder.addReference(reference);
                                }
                                token = referenceInfo.token;
                                continue retry;
                            case SUPPRESS:
                                token = parseSuppressTag(next());
                                continue retry;
                            case TEMPLATE:
                                ExtractionInfo templateInfo = extractSingleLineBlock();
                                String templateTypeName = templateInfo.string;
                                if (templateTypeName.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.templatemissing"", stream.getLineno(), stream.getCharno());
                                } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
                                    parser.addWarning(""msg.jsdoc.template.at.most.once"", stream.getLineno(), stream.getCharno());
                                }
                                token = templateInfo.token;
                                continue retry;
                            case VERSION:
                                ExtractionInfo versionInfo = extractSingleLineBlock();
                                String version = versionInfo.string;
                                if (version.length() == 0) {
                                    parser.addWarning(""msg.jsdoc.versionmissing"", stream.getLineno(), stream.getCharno());
                                } else {
                                    if (!jsdocBuilder.recordVersion(version)) {
                                        parser.addWarning(""msg.jsdoc.extraversion"", stream.getLineno(), stream.getCharno());
                                    }
                                }
                                token = versionInfo.token;
                                continue retry;
                            case DEFINE:
                            case RETURN:
                            case THIS:
                            case TYPE:
                            case TYPEDEF:
                                skipEOLs();
                                lineno = stream.getLineno();
                                charno = stream.getCharno();
                                token = next();
                                Node typeNode = parseAndRecordTypeNode(token, lineno, charno);
                                if (annotation == Annotation.THIS) {
                                    typeNode = wrapNode(Token.BANG, typeNode);
                                    if (typeNode != null && token != JsDocToken.LC) {
                                        typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                                    }
                                }
                                type = createJSTypeExpression(typeNode);
                                if (type == null) {
                                    // error reported during recursive descent
                                    // recovering parsing
                                } else {
                                    switch(annotation) {
                                        case DEFINE:
                                            if (!isValidDefineType(typeNode)) {
                                                parser.addWarning(""msg.jsdoc.define.badtype"", lineno, charno);
                                            } else if (!jsdocBuilder.recordDefineType(type)) {
                                                parser.addWarning(""msg.jsdoc.define"", lineno, charno);
                                            }
                                            break;
                                        case RETURN:
                                            if (!jsdocBuilder.recordReturnType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                                break;
                                            }
                                            // *Update* the token to that after the type annotation.
                                            token = current();
                                            // Find the return's description (if applicable).
                                            ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token);
                                            String returnDescription = returnDescriptionInfo.string;
                                            if (returnDescription.length() > 0) {
                                                jsdocBuilder.recordReturnDescription(returnDescription);
                                            }
                                            token = returnDescriptionInfo.token;
                                            continue retry;
                                        case THIS:
                                            if (!jsdocBuilder.recordThisType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPE:
                                            if (!jsdocBuilder.recordType(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                        case TYPEDEF:
                                            if (!jsdocBuilder.recordTypedef(type)) {
                                                parser.addWarning(""msg.jsdoc.incompat.type"", lineno, charno);
                                            }
                                            break;
                                    }
                                    token = eatTokensUntilEOL();
                                }
                                continue retry;
                        }
                    }
                }
                break;
            case EOC:
                if (hasParsedFileOverviewDocInfo()) {
                    fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
                }
                return true;
            case EOF:
                // discard any accumulated information
                jsdocBuilder.build(null);
                parser.addWarning(""msg.unexpected.eof"", stream.getLineno(), stream.getCharno());
                return false;
            case EOL:
                if (state == State.SEARCHING_NEWLINE) {
                    state = State.SEARCHING_ANNOTATION;
                }
                token = next();
                continue retry;
            default:
                if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
                    token = next();
                    continue retry;
                } else {
                    state = State.SEARCHING_NEWLINE;
                    token = eatTokensUntilEOL();
                    continue retry;
                }
        }
        // next token
        token = next();
    }
}","public void test2525() throws Throwable {
    LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
    Config config0 = new Config((JSTypeRegistry) null, linkedHashSet0, true);
    JsDocTokenStream jsDocTokenStream0 = new JsDocTokenStream(""Node cannot be refined. \n"");
    JsDocInfoParser jsDocInfoParser0 = new JsDocInfoParser(jsDocTokenStream0, ""Node cannot be refined. \n"", config0, (ErrorReporter) null);
    // Undeclared exception!
    try {
        jsDocInfoParser0.parse();
        fail(""Expecting exception: NullPointerException"");
    } catch (NullPointerException e) {
        //
        // no message in exception (getMessage() returned null)
        //
        verifyException(""com.google.javascript.jscomp.parsing.JsDocInfoParser$ErrorReporterParser"", e);
    }
}","/**
 * Parses a {@link JSDocInfo} object. This parsing method reads all tokens
 * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the
 * {@link JsDocToken#EOC} is returned.
 *
 * @return {@code true} if JSDoc information was correctly parsed,
 *     {@code false} otherwise
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(new JSTypeRegistry(NullErrorReporter.forOldRhino()), Sets.<String>newHashSet(), false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), ""typeparsing"", config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test2626() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""$&.<NE>"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public boolean hasChildren() {
    return first != null;
}","public void test2627() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""$&.<NE>"");
    assertTrue(node0.hasChildren());
}",""
"public int getType() {
    return type;
}","public void test2728() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""0&|A|#TTyq2"");
    assertEquals(301, node0.getType());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(new JSTypeRegistry(NullErrorReporter.forOldRhino()), Sets.<String>newHashSet(), false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), ""typeparsing"", config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test2729() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""0&|A|#TTyq2"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getChildCount() {
    int c = 0;
    for (Node n = first; n != null; n = n.next) c++;
    return c;
}","public void test2730() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""0&|A|#TTyq2"");
    assertEquals(3, node0.getChildCount());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(new JSTypeRegistry(NullErrorReporter.forOldRhino()), Sets.<String>newHashSet(), false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), ""typeparsing"", config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test2831() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""s%T.<"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getType() {
    return type;
}","public void test2832() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""s%T.<"");
    assertEquals(40, node0.getType());
}",""
"public int getType() {
    return type;
}","public void test2933() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""?VFt;*Hp>:Ng{"");
    assertEquals(304, node0.getType());
}",""
"public int getCharno() {
    return extractCharno(sourcePosition);
}","public void test2934() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""?VFt;*Hp>:Ng{"");
    assertEquals(5, node0.getCharno());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(new JSTypeRegistry(NullErrorReporter.forOldRhino()), Sets.<String>newHashSet(), false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), ""typeparsing"", config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test2935() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""?VFt;*Hp>:Ng{"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(new JSTypeRegistry(NullErrorReporter.forOldRhino()), Sets.<String>newHashSet(), false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), ""typeparsing"", config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test3036() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""!"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(new JSTypeRegistry(NullErrorReporter.forOldRhino()), Sets.<String>newHashSet(), false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), ""typeparsing"", config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test3137() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""x?5,mc@y@C"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getType() {
    return type;
}","public void test3138() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""x?5,mc@y@C"");
    assertEquals(304, node0.getType());
}",""
"public int getType() {
    return type;
}","public void test3239() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""NL6e~7sR!"");
    assertEquals(306, node0.getType());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(new JSTypeRegistry(NullErrorReporter.forOldRhino()), Sets.<String>newHashSet(), false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), ""typeparsing"", config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test3240() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""NL6e~7sR!"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(new JSTypeRegistry(NullErrorReporter.forOldRhino()), Sets.<String>newHashSet(), false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), ""typeparsing"", config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test3341() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""*Y@pv4<=2C"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getType() {
    return type;
}","public void test3342() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""*Y@pv4<=2C"");
    assertEquals(302, node0.getType());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(new JSTypeRegistry(NullErrorReporter.forOldRhino()), Sets.<String>newHashSet(), false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), ""typeparsing"", config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test3443() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""[s,+\n"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(new JSTypeRegistry(NullErrorReporter.forOldRhino()), Sets.<String>newHashSet(), false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), ""typeparsing"", config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test3544() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""{Eg:n9;5q3 "");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getType() {
    return type;
}","public void test3645() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""null"");
    assertEquals(40, node0.getType());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(new JSTypeRegistry(NullErrorReporter.forOldRhino()), Sets.<String>newHashSet(), false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), ""typeparsing"", config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test3646() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""null"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getType() {
    return type;
}","public void test3747() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""undefined"");
    assertEquals(40, node0.getType());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(new JSTypeRegistry(NullErrorReporter.forOldRhino()), Sets.<String>newHashSet(), false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), ""typeparsing"", config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test3748() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""undefined"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(new JSTypeRegistry(NullErrorReporter.forOldRhino()), Sets.<String>newHashSet(), false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), ""typeparsing"", config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test3849() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""s%T.<n[w"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(new JSTypeRegistry(NullErrorReporter.forOldRhino()), Sets.<String>newHashSet(), false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), ""typeparsing"", config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test3950() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""function"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(new JSTypeRegistry(NullErrorReporter.forOldRhino()), Sets.<String>newHashSet(), false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), ""typeparsing"", config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test4051() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""ed`;\""5ha4Hp13I|"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getType() {
    return type;
}","public void test4152() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""(Lorg/mozilla/javascript/Context;)Lorg/mozilla/javascript/RegExpProxy;"");
    assertEquals(301, node0.getType());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(new JSTypeRegistry(NullErrorReporter.forOldRhino()), Sets.<String>newHashSet(), false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), ""typeparsing"", config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test4153() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""(Lorg/mozilla/javascript/Context;)Lorg/mozilla/javascript/RegExpProxy;"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public boolean hasChildren() {
    return first != null;
}","public void test4154() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""(Lorg/mozilla/javascript/Context;)Lorg/mozilla/javascript/RegExpProxy;"");
    assertTrue(node0.hasChildren());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(new JSTypeRegistry(NullErrorReporter.forOldRhino()), Sets.<String>newHashSet(), false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), ""typeparsing"", config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test4255() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""[\n"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getType() {
    return type;
}","public void test4356() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""[EJavaConsNr]cttfrc "");
    assertEquals(79, node0.getType());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(new JSTypeRegistry(NullErrorReporter.forOldRhino()), Sets.<String>newHashSet(), false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), ""typeparsing"", config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test4357() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""[EJavaConsNr]cttfrc "");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getChildCount() {
    int c = 0;
    for (Node n = first; n != null; n = n.next) c++;
    return c;
}","public void test4358() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""[EJavaConsNr]cttfrc "");
    assertEquals(1, node0.getChildCount());
}",""
"public static Node parseTypeString(String typeString) {
    Config config = new Config(new JSTypeRegistry(NullErrorReporter.forOldRhino()), Sets.<String>newHashSet(), false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), ""typeparsing"", config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test4459() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""{'q^eM2rJVlr:@,y9AE"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public int getType() {
    return type;
}","public void test4560() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""{wKbM&}p{$]G>05T2e"");
    assertEquals(81, node0.getType());
}",""
"public boolean hasOneChild() {
    return first != null && first == last;
}","public void test4561() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""{wKbM&}p{$]G>05T2e"");
    assertTrue(node0.hasOneChild());
}","/**
 * Check for one child more efficiently than by iterating over all the
 * children as is done with Node.getChildCount().
 * @return Whether the node has exactly one child.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(new JSTypeRegistry(NullErrorReporter.forOldRhino()), Sets.<String>newHashSet(), false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), ""typeparsing"", config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test4562() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""{wKbM&}p{$]G>05T2e"");
    assertNotNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(new JSTypeRegistry(NullErrorReporter.forOldRhino()), Sets.<String>newHashSet(), false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), ""typeparsing"", config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test4663() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""{QP,dNQ3V>VP*Hf"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
"public static Node parseTypeString(String typeString) {
    Config config = new Config(new JSTypeRegistry(NullErrorReporter.forOldRhino()), Sets.<String>newHashSet(), false);
    JsDocInfoParser parser = new JsDocInfoParser(new JsDocTokenStream(typeString), ""typeparsing"", config, NullErrorReporter.forNewRhino());
    return parser.parseTopLevelTypeExpression(parser.next());
}","public void test4764() throws Throwable {
    Node node0 = JsDocInfoParser.parseTypeString(""{"");
    assertNull(node0);
}","/**
 * Parses a string containing a JsDoc type declaration, returning the
 * type if the parsing succeeded or {@code null} if it failed.
 */"
